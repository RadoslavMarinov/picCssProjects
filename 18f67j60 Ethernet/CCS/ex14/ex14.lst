CCS PCH C Compiler, Version 5.015, 5967               05-ώνθ-14 16:33

               Filename:   D:\Projects\18f67j60 Ethernet\CCS\ex14\ex14.lst

               ROM used:   22314 bytes (17%)
                           Largest free fragment is 65528
               RAM used:   366 (10%) at main() level
                           714 (19%) worst case
               Stack used: 12 locations (10 in main + 2 for interrupts)
               Stack size: 31

*
00000:  GOTO   562C
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FFB,15
0003C:  MOVFF  00,0E
00040:  MOVFF  01,0F
00044:  MOVFF  02,10
00048:  MOVFF  03,11
0004C:  BTFSS  FF2.5
0004E:  GOTO   0058
00052:  BTFSC  FF2.2
00054:  GOTO   00B8
00058:  MOVFF  0E,00
0005C:  MOVFF  0F,01
00060:  MOVFF  10,02
00064:  MOVFF  11,03
00068:  MOVFF  0C,FE9
0006C:  MOVFF  07,FEA
00070:  BSF    07.7
00072:  MOVFF  08,FE1
00076:  MOVFF  09,FE2
0007A:  MOVFF  0A,FD9
0007E:  MOVFF  0B,FDA
00082:  MOVFF  12,FF3
00086:  MOVFF  13,FF4
0008A:  MOVFF  14,FFA
0008E:  MOVFF  15,FFB
00092:  MOVF   04,W
00094:  MOVFF  06,FE0
00098:  MOVFF  05,FD8
0009C:  RETFIE 0
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // ex14.c - Example 14 from the Embedded Internet/Embedded Ethernet tutorial 
.................... // 
.................... // A very simple webserver.  Webserver is written in this example (see 
.................... // HTTPTask()), does not use a CCS or Microchip written HTTP library. 
.................... // 
.................... // NOTE: Change the code in IPAddrInit() to your desired IP address, which 
.................... //       is based on your network. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // force enabling of LCD library.  if hardware doesn't have LCD hardware, 
.................... // then it will use RS232/Serial for lcd_putc(). 
.................... #define STACK_USE_PICDEM_LCD     1 
....................  
.................... #define STACK_USE_ICMP_SERVER 
.................... #define STACK_USE_TCP 
....................  
.................... // configure TCP stack for the correct number of sockets and RAM needed. 
.................... #define TCP_CONFIGURATION  1   //tell TCPIPConfig.h to not include default TCPSocketInitializer[] array. 
.................... // See ex13b.c for comments. 
.................... #define TCP_ETH_RAM_SIZE   1280 
....................  
.................... #include "ccstcpip.h" 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // ccstcpip.h - Common code shared among all Embedded Internet/Embedded 
.................... // Ethernet tutorial book examples. 
.................... // 
.................... // If you are using a CCS Embedded Ethernet Board (labeled PICENS, which 
.................... // has an MCP ENC28J60) then define STACK_USE_CCS_PICENS to TRUE. 
.................... // 
.................... // If you are using a CCS Embedded Internet Board (labeled PICNET, which 
.................... // has a Realtek RTL8019AS and a 56K Modem) then define STACK_USE_CCS_PICNET 
.................... // to TRUE. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // 10/25/06 
.................... //  - Added STACK_USE_CCS_PICEEC 
.................... //  - ExamplePacket[] UDP header length fixed 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #define STACK_USE_CCS_EWLWIFIB      0 //18f67k22 + mrf24wb0m 
.................... #define STACK_USE_CCS_EWLWIFIG      0 //18f67k22 + mrf24wg0m 
.................... #define STACK_USE_CCS_PICEEC        1 //18f67j60 
.................... #define STACK_USE_CCS_PICENS        0 //18f4620 + enc28j60 
.................... #define STACK_USE_PIC24FJGA110_ENC28     0 //explorer 16, PIC24FJ256GA110, ENC28J60.  unfortunately with this combinatin you cannot use ENC28J60 and 25LC256 at same time 
.................... #define STACK_USE_PIC24FJGA010_ENC28     0 //explorer 16, PIC24FJ128GA010, ENC28J60. 
.................... #define STACK_USE_CCS_EWL5V_REV5    0 //ezWebLynx 5V (REV5), 18f67k22 + enc28j60 
.................... #define STACK_USE_CCS_EWL3V         0 //ezWebLynx 3V, 18f67j60 
.................... //#define STACK_USE_CCS_PICNET        0 //18f6722 + realtek 
....................  
.................... #define STACK_IS_CCS_EXAMPLE 
....................  
.................... /* not working right now 
.................... #define STACK_USE_CCS_PICNET        0 //18f6722 + realtek 
.................... #define STACK_USE_CCS_EWL5V         0 //ezWebLynx 5V 
.................... #define STACK_USE_CCS_EWL5V_REV2    0 //ezWebLynx 5V (REV2) 
.................... */ 
....................  
.................... #if STACK_USE_CCS_EWLWIFIB || STACK_USE_CCS_EWLWIFIG 
....................    #define WF_DEBUG  
....................    #define STACK_USE_WIFI 1 
....................    #if STACK_USE_CCS_EWLWIFIG 
....................       #define MRF24WG 
....................    #endif 
.................... #else 
....................    #define STACK_USE_WIFI 0 
.................... #endif 
....................  
.................... #define LCD_EXTENDED_NEWLINE  //configuration for lcd.c driver/library 
....................   
.................... #if STACK_USE_CCS_EWLWIFIB || STACK_USE_CCS_EWLWIFIG 
....................    #include <18F67K22.h> 
....................    #device HIGH_INTS = TRUE 
....................    #include "tcpip\p18cxxx.h" 
....................     
....................    #reserve 0xF16:0xFFF   //SFR 
....................    #use delay(clock=64M, XTAL=16M) 
....................     
....................    //took out fuses 12/13/11 
....................    //#fuses HSH 
....................    //#fuses PLLEN 
....................    //#fuses MCLR 
....................     
....................    #use rs232(baud=9600, uart1, stream=STREAM_UI, errors) 
....................  
....................    #define wf_debug_printf printf 
....................    void wf_debug_putc(char c) {putc(c);} 
....................  
....................    void lcd_putc(char c) 
....................    { 
....................      #if STACK_USE_PICDEM_LCD 
....................        if (c == '\f') 
....................          printf("\r\n\n"); 
....................        else 
....................          putc(c); 
....................      #endif 
....................    } 
....................    #define lcd_init() 
....................    #ifndef STACK_USE_PICDEM_LCD 
....................       #define STACK_USE_PICDEM_LCD 0   // no hardware LCD support 
....................    #endif 
....................      
....................    #define LED_ON       output_high 
....................    #define LED_OFF      output_low 
....................    #define USER_LED1    PIN_G3                 //input1 
....................    #define USER_LED2    PIN_G4                 //input2 
....................    #define USER_LED3    PIN_F3                 //input3 
....................    #define STANDARD_ADC_STRING  "AN9" 
....................    #define STANDARD_ADC_CHANNEL 9              //input4 
....................    #define BUTTON1_PRESSED() (input(PIN_F5))   //input5 
....................    #define BUTTON2_PRESSED() (input(PIN_A5))   //input6 
....................  
....................    // more gpio / hardware definitions hiding in HardwareProfile.h 
....................  
....................    // macros used by CCS's WIFIConnectTask() 
....................    #define LED_WIFI  PIN_E0 
....................    #define LED_CONNECTION_ON()   output_drive(LED_WIFI);   output_high(LED_WIFI) 
....................    #define LED_CONNECTION_OFF()   output_drive(LED_WIFI);   output_low(LED_WIFI) 
....................     
....................    void init_user_io(void) 
....................    { 
....................       setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_2); 
....................       setup_adc_ports(sAN9); 
....................       set_adc_channel(STANDARD_ADC_CHANNEL); 
....................        
....................       output_drive(USER_LED1); 
....................       output_drive(USER_LED2); 
....................       output_float(PIN_G4); 
....................       output_float(PIN_G3); 
....................       LED_OFF(USER_LED1); 
....................       LED_OFF(USER_LED2); 
....................       LED_CONNECTION_OFF(); 
....................    } 
....................           
....................    #define __AT45DB_D__ 
....................    #define FLASH_SELECT PIN_D2 
....................    #define FLASH_CLOCK  PIN_D6 
....................    #define FLASH_DI     PIN_D4 
....................    #define FLASH_DO     PIN_D5 
....................    #define FLASH_BUFFER_SIZE    264 
....................    #define FLASH_BUFFER_COUNT   4096 
....................    #include "at45db.c"  
....................        
....................    #define __SPIFLASH_H    //prevent spiflash.h from being loaded/used 
....................    #define SPIFlashReadArray(dwAddress, pData, wLen)  ext_flash_read(dwAddress, pData, wLen) 
....................    #define SPIFlashInit()                             init_ext_flash() 
....................    #define SPIFlashBeginWrite(addy)                   ext_flash_startWrite(addy) 
....................    #define SPIFlashWrite(d)                           ext_flash_continuousWrite(d) 
....................    #define SPIFlashStopWrite()                        ext_flash_flushWrites() 
....................    #define SPIFlashWriteBytes(dwAddress, pData, wLen) ext_flash_writeBytes(dwAddress, pData, wLen) 
....................     
....................    // if you want TCP/IP settings saved to internal EEPROM, then comment 
....................    // out the next few lines: 
....................    #define EEInit SPIFlashInit 
....................    #define EEReadBytes(dst, src, len)  SPIFlashReadArray(src, dst, len) 
....................    #define EEWriteBytes(dst, src, len) SPIFlashWriteBytes(dst, src, len) 
....................     
.................... #elif STACK_USE_PIC24FJGA010_ENC28 
....................    #include <24FJ128GA010.h> 
....................    //#device ICD=TRUE 
....................    #device ADC=8 
....................    #include "tcpip\p24fxxxx.h"   //C30 to CCS compatability layer 
....................    #use delay(clock=32MHz) 
....................    #fuses PR_PLL, XT                 //cw2 
....................    #fuses NOWDT, NOJTAG             //cw1 
....................     
....................    //pin_f13 = rts 
....................    //pin_f12 = cts 
....................    #use rs232(baud=9600, uart2, stream=STREAM_UI, errors) 
....................     
....................    #define BUTTON1_PRESSED()  (!input(PIN_D6))  //marked S3 on PCB 
....................    #define USER_LED1    PIN_A0   //marked D3 on PCB 
....................    #define USER_LED2    PIN_A1   //marked D4 on PCB 
....................    #define USER_LED3    PIN_A2   //marked D5 on PCB 
....................    #define LED_ON       output_high 
....................    #define LED_OFF      output_low 
....................    #define STANDARD_ADC_STRING  "AN5" 
....................    #define STANDARD_ADC_CHANNEL 5   //rb5/an5 
....................         
....................    #define LCD_ENABLE_PIN  PIN_D4 
....................    #define LCD_RS_PIN      PIN_B15 
....................    #define LCD_RW_PIN      PIN_D5 
....................    #define LCD_DATA4       PIN_E4 
....................    #define LCD_DATA5       PIN_E5 
....................    #define LCD_DATA6       PIN_E6 
....................    #define LCD_DATA7       PIN_E7 
....................     
....................    #ifndef STACK_USE_PICDEM_LCD 
....................       #define STACK_USE_PICDEM_LCD 1 
....................    #endif 
....................    #if STACK_USE_PICDEM_LCD 
....................       #include "lcd.c"    
....................    #endif 
....................    
....................    #define ENC_CS_IO       LATDbits.LATD14 
....................    #define ENC_CS_TRIS     TRISDbits.TRISD14 
....................    #define ENC_RST_IO      LATDbits.LATD15 
....................    #define ENC_RST_TRIS    TRISDbits.TRISD15 
....................    #define ENC_SPI_IF         IFS0bits.SPI1IF 
....................    #define ENC_SPICON1        SPI1CON1 
....................    #define ENC_SPICON2        SPI1CON2 
....................    #define ENC_SPISTAT        SPI1STAT 
....................    #define ENC_SSPBUF         SPI1BUF 
....................    #define ENC_SPICON1bits    SPI1CON1bits 
....................    #define ENC_SPICON2bits    SPI1CON2bits 
....................    #define ENC_SPISTATbits    SPI1STATbits 
....................    //!INT pin is RE9/INT2 
....................  
....................    void init_user_io(void)  
....................    { 
....................       setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_2); 
....................       setup_adc_ports(sAN5); 
....................       set_adc_channel(STANDARD_ADC_CHANNEL); 
....................        
....................       output_drive(USER_LED1); 
....................       output_drive(USER_LED2); 
....................       output_drive(USER_LED3); 
....................       LED_OFF(USER_LED1); 
....................       LED_OFF(USER_LED2); 
....................       LED_OFF(USER_LED3); 
....................    } 
....................    // 25LC256 
.................... //#define debug_ee  printf 
.................... //void debug_ee_putc(char c) {putc(c);} 
....................    #define EEPROM_SELECT PIN_D12 
....................    #define EEPROM_CLK    PIN_G6 
....................    #define EEPROM_DI     PIN_G7 
....................    #define EEPROM_DO     PIN_G8 
....................    #include "25lc256.c" 
....................     
....................    #define __SPIFLASH_H    //prevent spiflash.h from being loaded/used 
....................    #define SPIFlashReadArray(dwAddress, pData, wLen)  read_ext_eeprom_bytes(pData, dwAddress, wLen) 
....................    #define SPIFlashInit()                             init_ext_eeprom() 
....................    EEPROM_ADDRESS g_SpiFlashCurrWrite; 
....................    #define SPIFlashBeginWrite(addy)                   g_SpiFlashCurrWrite=addy 
....................    #define SPIFlashWrite(d)                           write_ext_eeprom(g_SpiFlashCurrWrite++, d) 
....................    #define SPIFlashStopWrite() 
....................    #define SPIFlashWriteBytes(dwAddress, pData, wLen) write_ext_eeprom_bytes(dwAddress, pData, wLen) 
....................     
....................    // if you want TCP/IP settings saved to internal EEPROM, then comment 
....................    // out the next few lines: 
....................    #define EEInit SPIFlashInit 
....................    #define EEReadBytes(dst, src, len)  SPIFlashReadArray(src, dst, len) 
....................    #define EEWriteBytes(dst, src, len) SPIFlashWriteBytes(dst, src, len); SPIFlashStopWrite() 
....................     
....................     
.................... #elif STACK_USE_PIC24FJGA110_ENC28 
....................    #include <24FJ256GA110.h> 
....................    //#device ICD=TRUE 
....................    #device ADC=8 
....................    #include "tcpip\p24fxxxx.h" 
....................    #use delay(clock=32MHz) 
....................    #fuses PR_PLL, XT                 //cw2 
....................    #fuses NOWDT, NOJTAG, ICSP2      //cw1 
....................     
....................    #pin_select U2TX=PIN_F5 
....................    #pin_select U2RX=PIN_F4 
....................    //pin_f13 = rts 
....................    //pin_f12 = cts 
....................    #use rs232(baud=9600, uart2, stream=STREAM_UI, errors) 
....................     
....................    #define BUTTON1_PRESSED()  (!input(PIN_D6))  //marked S3 on PCB 
....................    #define USER_LED1    PIN_A0   //marked D3 on PCB 
....................    #define USER_LED2    PIN_A1   //marked D4 on PCB 
....................    #define USER_LED3    PIN_A2   //marked D5 on PCB 
....................    #define LED_ON       output_high 
....................    #define LED_OFF      output_low 
....................    #define STANDARD_ADC_STRING  "AN5" 
....................    #define STANDARD_ADC_CHANNEL 5   //rb5/an5 
....................         
....................    #define LCD_ENABLE_PIN  PIN_D4 
....................    #define LCD_RS_PIN      PIN_B15 
....................    #define LCD_RW_PIN      PIN_D5 
....................    #define LCD_DATA4       PIN_E4 
....................    #define LCD_DATA5       PIN_E5 
....................    #define LCD_DATA6       PIN_E6 
....................    #define LCD_DATA7       PIN_E7 
....................     
....................    #ifndef STACK_USE_PICDEM_LCD 
....................       #define STACK_USE_PICDEM_LCD 1 
....................    #endif 
....................    #if STACK_USE_PICDEM_LCD 
....................       #include "lcd.c"    
....................    #endif 
....................    
....................    // When using 24FJ256GA110, due to an errata with SPI1 we must use SPI2. 
....................    // so when inserting the ENC28J60 PICTail into the Explorer 16, insert 
....................    // it into the second slot.  The definitions below are for the second 
....................    // slot. 
....................    //ENC28J60 INT is mapped to RA15, but not used by software 
....................    #pin_select SDO2=PIN_G8 
....................    #pin_select SDI2=PIN_G7 
....................    #pin_select SCK2OUT=PIN_G6 
....................    #define ENC_CS_IO       LATFbits.LATF12    
....................    #define ENC_CS_TRIS     TRISFbits.TRISF12 
....................    #define ENC_RST_IO      LATFbits.LATF13 
....................    #define ENC_RST_TRIS    TRISFbits.TRISF13 
....................    #define ENC_SPI_IF         IFS2bits.SPI2IF 
....................    #define ENC_SPICON1        SPI2CON1 
....................    #define ENC_SPICON2        SPI2CON2 
....................    #define ENC_SPISTAT        SPI2STAT 
....................    #define ENC_SSPBUF         SPI2BUF 
....................    #define ENC_SPICON1bits    SPI2CON1bits 
....................    #define ENC_SPICON2bits    SPI2CON2bits 
....................    #define ENC_SPISTATbits    SPI2STATbits 
....................  
....................    void init_user_io(void)  
....................    { 
....................       setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_2); 
....................       setup_adc_ports(sAN5); 
....................       set_adc_channel(STANDARD_ADC_CHANNEL); 
....................        
....................       output_drive(USER_LED1); 
....................       output_drive(USER_LED2); 
....................       output_drive(USER_LED3); 
....................       LED_OFF(USER_LED1); 
....................       LED_OFF(USER_LED2); 
....................       LED_OFF(USER_LED3); 
....................    } 
....................  
.................... #elif STACK_USE_CCS_PICEEC 
....................    #include <18F67J60.h> 
.................... //////////// Standard Header file for the PIC18F67J60 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F67J60 
*
000BE:  DATA 0D,0A
000C0:  DATA 48,54
000C2:  DATA 54,50
000C4:  DATA 3A,20
000C6:  DATA 4C,69
000C8:  DATA 73,74
000CA:  DATA 65,6E
000CC:  DATA 69,6E
000CE:  DATA 67,00
000D0:  DATA 0D,0A
000D2:  DATA 48,54
000D4:  DATA 54,50
000D6:  DATA 3A,20
000D8:  DATA 43,6F
000DA:  DATA 6E,6E
000DC:  DATA 65,63
000DE:  DATA 74,65
000E0:  DATA 64,00
000E2:  DATA 0D,0A
000E4:  DATA 48,54
000E6:  DATA 54,50
000E8:  DATA 3A,20
000EA:  DATA 47,6F
000EC:  DATA 74,20
000EE:  DATA 50,61
000F0:  DATA 67,65
000F2:  DATA 20,52
000F4:  DATA 65,71
000F6:  DATA 75,65
000F8:  DATA 73,74
000FA:  DATA 00,00
000FC:  DATA 0D,0A
000FE:  DATA 48,54
00100:  DATA 54,50
00102:  DATA 3A,20
00104:  DATA 50,75
00106:  DATA 74,74
00108:  DATA 69,6E
0010A:  DATA 67,20
0010C:  DATA 50,61
0010E:  DATA 67,65
00110:  DATA 20,52
00112:  DATA 65,73
00114:  DATA 70,6F
00116:  DATA 6E,73
00118:  DATA 65,00
0011A:  DATA 3C,48
0011C:  DATA 54,4D
0011E:  DATA 4C,3E
00120:  DATA 3C,48
00122:  DATA 45,41
00124:  DATA 44,3E
00126:  DATA 3C,54
00128:  DATA 49,54
0012A:  DATA 4C,45
0012C:  DATA 3E,50
0012E:  DATA 49,43
00130:  DATA 4E,45
00132:  DATA 54,3C
00134:  DATA 2F,54
00136:  DATA 49,54
00138:  DATA 4C,45
0013A:  DATA 3E,3C
0013C:  DATA 2F,48
0013E:  DATA 45,41
00140:  DATA 44,3E
00142:  DATA 3C,42
00144:  DATA 4F,44
00146:  DATA 59,3E
00148:  DATA 3C,48
0014A:  DATA 31,3E
0014C:  DATA 48,45
0014E:  DATA 4C,4C
00150:  DATA 4F,3C
00152:  DATA 2F,48
00154:  DATA 31,3E
00156:  DATA 00,00
00158:  DATA 3C,50
0015A:  DATA 3E,25
0015C:  DATA 73,20
0015E:  DATA 3D,20
00160:  DATA 30,78
00162:  DATA 25,58
00164:  DATA 00,00
00166:  DATA 41,4E
00168:  DATA 32,00
0016A:  DATA 3C,2F
0016C:  DATA 42,4F
0016E:  DATA 44,59
00170:  DATA 3E,3C
00172:  DATA 2F,48
00174:  DATA 54,4D
00176:  DATA 4C,3E
00178:  DATA 00,00
0017A:  DATA 48,54
0017C:  DATA 54,50
0017E:  DATA 2F,31
00180:  DATA 2E,31
00182:  DATA 20,32
00184:  DATA 30,30
00186:  DATA 20,4F
00188:  DATA 4B,0D
0018A:  DATA 0A,00
0018C:  DATA 43,6F
0018E:  DATA 6E,74
00190:  DATA 65,6E
00192:  DATA 74,2D
00194:  DATA 54,79
00196:  DATA 70,65
00198:  DATA 3A,20
0019A:  DATA 74,65
0019C:  DATA 78,74
0019E:  DATA 2F,68
001A0:  DATA 74,6D
001A2:  DATA 6C,0D
001A4:  DATA 0A,00
001A6:  DATA 43,6F
001A8:  DATA 6E,74
001AA:  DATA 65,6E
001AC:  DATA 74,2D
001AE:  DATA 4C,65
001B0:  DATA 6E,67
001B2:  DATA 74,68
001B4:  DATA 3A,20
001B6:  DATA 25,75
001B8:  DATA 0D,0A
001BA:  DATA 00,00
001BC:  DATA 0D,0A
001BE:  DATA 48,54
001C0:  DATA 54,50
001C2:  DATA 3A,20
001C4:  DATA 46,6C
001C6:  DATA 75,73
001C8:  DATA 68,69
001CA:  DATA 6E,67
001CC:  DATA 2E,2E
001CE:  DATA 2E,00
001D0:  DATA 0D,0A
001D2:  DATA 48,54
001D4:  DATA 54,50
001D6:  DATA 3A,20
001D8:  DATA 46,6C
001DA:  DATA 75,73
001DC:  DATA 68,65
001DE:  DATA 64,21
001E0:  DATA 00,00
001E2:  DATA 0D,0A
001E4:  DATA 48,54
001E6:  DATA 54,50
001E8:  DATA 3A,20
001EA:  DATA 46,6F
001EC:  DATA 72,63
001EE:  DATA 65,20
001F0:  DATA 44,69
001F2:  DATA 73,63
001F4:  DATA 6F,6E
001F6:  DATA 6E,65
001F8:  DATA 63,74
001FA:  DATA 00,00
001FC:  DATA 0D,0A
001FE:  DATA 0A,43
00200:  DATA 43,53
00202:  DATA 20,54
00204:  DATA 43,50
00206:  DATA 2F,49
00208:  DATA 50,20
0020A:  DATA 54,55
0020C:  DATA 54,4F
0020E:  DATA 52,49
00210:  DATA 41,4C
00212:  DATA 2C,20
00214:  DATA 45,58
00216:  DATA 41,4D
00218:  DATA 50,4C
0021A:  DATA 45,20
0021C:  DATA 31,34
0021E:  DATA 20,28
00220:  DATA 48,54
00222:  DATA 54,50
00224:  DATA 20,53
00226:  DATA 45,52
00228:  DATA 56,45
0022A:  DATA 52,29
0022C:  DATA 0D,0A
0022E:  DATA 00,00
*
00332:  TBLRD*+
00334:  MOVF   FF5,F
00336:  BZ    035A
00338:  MOVFF  FF6,26A
0033C:  MOVFF  FF7,26B
00340:  MOVFF  FF8,26C
00344:  MOVF   FF5,W
00346:  BTFSS  F9E.4
00348:  BRA    0346
0034A:  MOVWF  FAD
0034C:  MOVFF  26A,FF6
00350:  MOVFF  26B,FF7
00354:  MOVFF  26C,FF8
00358:  BRA    0332
0035A:  RETURN 0
*
006C0:  TSTFSZ 01
006C2:  BRA    06CA
006C4:  TSTFSZ 02
006C6:  BRA    06CC
006C8:  BRA    06D8
006CA:  INCF   02,F
006CC:  MOVFF  00,FEE
006D0:  DECFSZ 01,F
006D2:  BRA    06CC
006D4:  DECFSZ 02,F
006D6:  BRA    06CC
006D8:  GOTO   0C66 (RETURN)
*
00EDC:  MOVLB  1
00EDE:  MOVF   xAB,W
00EE0:  MULWF  xAD
00EE2:  MOVFF  FF3,01
00EE6:  MOVFF  FF4,00
00EEA:  MULWF  xAE
00EEC:  MOVF   FF3,W
00EEE:  ADDWF  00,F
00EF0:  MOVF   xAC,W
00EF2:  MULWF  xAD
00EF4:  MOVF   FF3,W
00EF6:  ADDWFC 00,W
00EF8:  MOVWF  02
00EFA:  MOVLB  0
00EFC:  RETURN 0
*
04F1A:  MOVFF  165,FEA
04F1E:  MOVFF  164,FE9
04F22:  MOVLB  2
04F24:  MOVFF  270,FEF
04F28:  INCF   FE9,F
04F2A:  BTFSC  FD8.2
04F2C:  INCF   FEA,F
04F2E:  CLRF   FEF
04F30:  MOVLB  1
04F32:  INCF   x64,F
04F34:  BTFSC  FD8.2
04F36:  INCF   x65,F
04F38:  MOVLB  0
04F3A:  RETURN 0
04F3C:  TBLRD*+
04F3E:  MOVF   FF5,F
04F40:  BZ    4F62
04F42:  MOVFF  FF6,26C
04F46:  MOVFF  FF7,26D
04F4A:  MOVFF  FF8,26E
04F4E:  MOVFF  FF5,270
04F52:  RCALL  4F1A
04F54:  MOVFF  26C,FF6
04F58:  MOVFF  26D,FF7
04F5C:  MOVFF  26E,FF8
04F60:  BRA    4F3C
04F62:  RETURN 0
*
04F9E:  TBLRD*+
04FA0:  MOVFF  FF6,26D
04FA4:  MOVFF  FF7,26E
04FA8:  MOVFF  FF8,26F
04FAC:  MOVFF  FF5,270
04FB0:  RCALL  4F1A
04FB2:  MOVFF  26D,FF6
04FB6:  MOVFF  26E,FF7
04FBA:  MOVFF  26F,FF8
04FBE:  MOVLB  2
04FC0:  DECFSZ x6C,F
04FC2:  BRA    4FC6
04FC4:  BRA    4FCA
04FC6:  MOVLB  0
04FC8:  BRA    4F9E
04FCA:  MOVLB  0
04FCC:  RETURN 0
04FCE:  MOVLB  2
04FD0:  BTFSC  x6D.7
04FD2:  BRA    4FF6
04FD4:  MOVLW  0F
04FD6:  MOVWF  00
04FD8:  SWAPF  x6C,W
04FDA:  ANDWF  00,F
04FDC:  MOVLW  0A
04FDE:  SUBWF  00,W
04FE0:  BC    4FE8
04FE2:  MOVLW  30
04FE4:  ADDWF  00,F
04FE6:  BRA    4FEC
04FE8:  MOVF   x6D,W
04FEA:  ADDWF  00,F
04FEC:  MOVFF  00,270
04FF0:  MOVLB  0
04FF2:  RCALL  4F1A
04FF4:  MOVLB  2
04FF6:  MOVLW  0F
04FF8:  ANDWF  x6C,F
04FFA:  MOVLW  0A
04FFC:  SUBWF  x6C,W
04FFE:  BC    5004
05000:  MOVLW  30
05002:  BRA    5008
05004:  BCF    x6D.7
05006:  MOVF   x6D,W
05008:  ADDWF  x6C,F
0500A:  MOVFF  26C,270
0500E:  MOVLB  0
05010:  RCALL  4F1A
05012:  GOTO   54D4 (RETURN)
*
05184:  TBLRD*+
05186:  MOVF   FF5,F
05188:  BZ    51AA
0518A:  MOVFF  FF6,26A
0518E:  MOVFF  FF7,26B
05192:  MOVFF  FF8,26C
05196:  MOVFF  FF5,26F
0519A:  RCALL  5178
0519C:  MOVFF  26A,FF6
051A0:  MOVFF  26B,FF7
051A4:  MOVFF  26C,FF8
051A8:  BRA    5184
051AA:  RETURN 0
051AC:  TBLRD*+
051AE:  MOVFF  FF6,26C
051B2:  MOVFF  FF7,26D
051B6:  MOVFF  FF8,26E
051BA:  MOVFF  FF5,26F
051BE:  RCALL  5178
051C0:  MOVFF  26C,FF6
051C4:  MOVFF  26D,FF7
051C8:  MOVFF  26E,FF8
051CC:  MOVLB  2
051CE:  DECFSZ x6B,F
051D0:  BRA    51D4
051D2:  BRA    51D8
051D4:  MOVLB  0
051D6:  BRA    51AC
051D8:  MOVLB  0
051DA:  GOTO   554E (RETURN)
051DE:  MOVLB  2
051E0:  MOVF   x6E,W
051E2:  CLRF   01
051E4:  SUBWF  x6D,W
051E6:  BC    51EE
051E8:  MOVFF  26D,00
051EC:  BRA    5206
051EE:  CLRF   00
051F0:  MOVLW  08
051F2:  MOVWF  x6F
051F4:  RLCF   x6D,F
051F6:  RLCF   00,F
051F8:  MOVF   x6E,W
051FA:  SUBWF  00,W
051FC:  BTFSC  FD8.0
051FE:  MOVWF  00
05200:  RLCF   01,F
05202:  DECFSZ x6F,F
05204:  BRA    51F4
05206:  MOVLB  0
05208:  RETURN 0
0520A:  MOVF   01,W
0520C:  MOVFF  26B,26D
05210:  MOVLW  64
05212:  MOVLB  2
05214:  MOVWF  x6E
05216:  MOVLB  0
05218:  RCALL  51DE
0521A:  MOVFF  00,26B
0521E:  MOVF   01,W
05220:  MOVLW  30
05222:  BNZ   5234
05224:  MOVLB  2
05226:  BTFSS  x6C.1
05228:  BRA    5248
0522A:  BTFSC  x6C.3
0522C:  BRA    5248
0522E:  BTFSC  x6C.4
05230:  MOVLW  20
05232:  BRA    523C
05234:  MOVLB  2
05236:  BCF    x6C.3
05238:  BCF    x6C.4
0523A:  BSF    x6C.0
0523C:  ADDWF  01,F
0523E:  MOVFF  01,26F
05242:  MOVLB  0
05244:  RCALL  5178
05246:  MOVLB  2
05248:  MOVFF  26B,26D
0524C:  MOVLW  0A
0524E:  MOVWF  x6E
05250:  MOVLB  0
05252:  RCALL  51DE
05254:  MOVFF  00,26B
05258:  MOVF   01,W
0525A:  MOVLW  30
0525C:  BNZ   526E
0525E:  MOVLB  2
05260:  BTFSC  x6C.3
05262:  BRA    5278
05264:  BTFSS  x6C.0
05266:  BRA    5278
05268:  BTFSC  x6C.4
0526A:  MOVLW  20
0526C:  MOVLB  0
0526E:  ADDWF  01,F
05270:  MOVFF  01,26F
05274:  RCALL  5178
05276:  MOVLB  2
05278:  MOVLW  30
0527A:  ADDWF  x6B,F
0527C:  MOVFF  26B,26F
05280:  MOVLB  0
05282:  RCALL  5178
05284:  GOTO   555C (RETURN)
05288:  MOVF   FEF,F
0528A:  BZ    52AA
0528C:  MOVFF  FEA,26B
05290:  MOVFF  FE9,26A
05294:  MOVFF  FEF,26F
05298:  RCALL  5178
0529A:  MOVFF  26B,FEA
0529E:  MOVFF  26A,FE9
052A2:  INCF   FE9,F
052A4:  BTFSC  FD8.2
052A6:  INCF   FEA,F
052A8:  BRA    5288
052AA:  GOTO   558E (RETURN)
*
055F8:  MOVFF  FF2,0D
055FC:  BCF    FF2.7
055FE:  ADDWF  FE8,W
05600:  CLRF   FF7
05602:  RLCF   FF7,F
05604:  ADDLW  23
05606:  MOVWF  FF6
05608:  MOVLW  56
0560A:  ADDWFC FF7,F
0560C:  MOVLW  00
0560E:  MOVWF  FF8
05610:  MOVWF  FFB
05612:  TBLRD*-
05614:  MOVF   FF5,W
05616:  MOVWF  FFA
05618:  TBLRD*
0561A:  MOVF   FF5,W
0561C:  BTFSC  0D.7
0561E:  BSF    FF2.7
05620:  MOVWF  FF9
05622:  DATA 3A,53
05624:  DATA 92,53
05626:  DATA CE,53
05628:  DATA 26,54
0562A:  DATA C0,55
....................  
.................... #list 
....................  
....................    #include "tcpip\p18cxxx.h" 
.................... // CCS PCH C Compiler to Microchip C18 Compiler compatability layer. 
....................  
.................... #ifndef __P18CXXXX_H__ 
.................... #define __P18CXXXX_H__ 
....................  
.................... #ifndef __18CXX 
.................... #define __18CXX 
.................... #endif 
....................  
.................... //#zero_local_ram 
.................... #zero_ram 
....................  
....................  
.................... #device PASS_STRINGS=IN_RAM 
.................... #device CONST=READ_ONLY 
....................  
.................... #case 
.................... #type signed 
.................... #type short=16 int=16 long=32 
....................  
.................... #define _asm #asm 
.................... #define _endasm #endasm 
....................  
.................... /* usualy 
.................... #define GetSystemClock()      getenv("CLOCK") 
.................... #define GetInstructionClock()   (GetSystemClock()/4) 
.................... #define GetPeripheralClock()   (unsigned int32)GetInstructionClock() 
.................... */ 
....................  
.................... #if getenv("DEVICE") == "PIC18F97J60" 
....................  #define __18F97J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F96J65" 
....................  #define __18F96J65) 
.................... #elif getenv("DEVICE") == "PIC18F96J60" 
....................  #define __18F96J60 
.................... #elif getenv("DEVICE") == "PIC18F87J60" 
....................  #define __18F87J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J60" 
....................  #define __18F86J60 
.................... #elif getenv("DEVICE") == "PIC18F67J60" 
....................  #define __18F67J60 
....................  #include "PIC18F67J60_registers.h" 
.................... #byte TOSU = 0xFFF 
....................  
.................... #byte TOSH = 0xFFE 
....................  
.................... #byte TOSL = 0xFFD 
....................  
.................... struct STKPTRBITS { 
....................    unsigned int STKPTR0:1; 
....................    unsigned int STKPTR1:1; 
....................    unsigned int STKPTR2:1; 
....................    unsigned int STKPTR3:1; 
....................    unsigned int STKPTR4:1; 
....................    unsigned int :1; 
....................    unsigned int STKUNF:1; 
....................    unsigned int STKFUL:1; 
.................... } STKPTRbits; 
.................... #byte STKPTRbits = 0xFFC 
.................... #byte STKPTR = 0xFFC 
....................  
.................... #byte PCLATU = 0xFFB 
....................  
.................... #byte PCLATH = 0xFFA 
....................  
.................... #byte PCL = 0xFF9 
....................  
.................... struct TBLPTRUBITS { 
....................    unsigned int TBLPTRU0:1; 
....................    unsigned int TBLPTRU1:1; 
....................    unsigned int TBLPTRU2:1; 
....................    unsigned int TBLPTRU3:1; 
....................    unsigned int TBLPTRU4:1; 
....................    unsigned int ACSS:1; 
.................... } TBLPTRUbits; 
.................... #byte TBLPTRUbits = 0xFF8 
.................... #byte TBLPTRU = 0xFF8 
....................  
.................... #byte TBLPTRH = 0xFF7 
....................  
.................... #byte TBLPTRL = 0xFF6 
....................  
.................... #byte TABLAT = 0xFF5 
....................  
.................... #byte PRODH = 0xFF4 
....................  
.................... #byte PRODL = 0xFF3 
....................  
.................... struct INTCONBITS { 
....................    unsigned int RBIF:1; 
....................    unsigned int INT0IF:1; 
....................    unsigned int TMR0IF:1; 
....................    unsigned int RBIE:1; 
....................    unsigned int INT0IE:1; 
....................    unsigned int TMR0IE:1; 
....................    unsigned int PEIE_GIEL:1; 
....................    unsigned int GIE_GIEH:1; 
.................... } INTCONbits; 
.................... #byte INTCONbits = 0xFF2 
.................... #byte INTCON = 0xFF2 
....................  
.................... struct INTCON2BITS { 
....................    unsigned int RBIP:1; 
....................    unsigned int INT3IP:1; 
....................    unsigned int TMR0IP:1; 
....................    unsigned int INTEDG3:1; 
....................    unsigned int INTEDG4:1; 
....................    unsigned int INTEDG5:1; 
....................    unsigned int INTEDG6:1; 
....................    unsigned int RBPU:1; 
.................... } INTCON2bits; 
.................... #byte INTCON2bits = 0xFF1 
.................... #byte INTCON2 = 0xFF1 
....................  
.................... struct INTCON3BITS { 
....................    unsigned int INT1IF:1; 
....................    unsigned int INT2IF:1; 
....................    unsigned int INT3IF:1; 
....................    unsigned int INT1IE:1; 
....................    unsigned int INT2IE:1; 
....................    unsigned int INT3IE:1; 
....................    unsigned int INT1IP:1; 
....................    unsigned int INT2IP:1; 
.................... } INTCON3bits; 
.................... #byte INTCON3bits = 0xFF0 
.................... #byte INTCON3 = 0xFF0 
....................  
.................... #byte INDF0 = 0xFEF 
....................  
.................... #byte POSTINC0 = 0xFEE 
....................  
.................... #byte POSTDEC0 = 0xFED 
....................  
.................... #byte PREINC0 = 0xFEC 
....................  
.................... #byte PLUSW0 = 0xFEB 
....................  
.................... #byte FSR0H = 0xFEA 
....................  
.................... #byte FSR0L = 0xFE9 
....................  
.................... #byte WREG = 0xFE8 
....................  
.................... #byte INDF1 = 0xFE7 
....................  
.................... #byte POSTINC1 = 0xFE6 
....................  
.................... #byte POSTDEC1 = 0xFE5 
....................  
.................... #byte PREINC1 = 0xFE4 
....................  
.................... #byte PLUSW1 = 0xFE3 
....................  
.................... #byte FSR1H = 0xFE2 
....................  
.................... #byte FSR1L = 0xFE1 
....................  
.................... #byte BSR = 0xFE0 
....................  
.................... #byte INDF2 = 0xFDF 
....................  
.................... #byte POSTINC2 = 0xFDE 
....................  
.................... #byte POSTDEC2 = 0xFDD 
....................  
.................... #byte PREINC2 = 0xFDC 
....................  
.................... #byte PLUSW2 = 0xFDB 
....................  
.................... #byte FSR2H = 0xFDA 
....................  
.................... #byte FSR2L = 0xFD9 
....................  
.................... struct STATUSBITS { 
....................    unsigned int C:1; 
....................    unsigned int DC:1; 
....................    unsigned int Z:1; 
....................    unsigned int OV:1; 
....................    unsigned int N:1; 
.................... } STATUSbits; 
.................... #byte STATUSbits = 0xFD8 
.................... #byte STATUS = 0xFD8 
....................  
.................... #byte TMR0H = 0xFD7 
....................  
.................... #byte TMR0L = 0xFD6 
....................  
.................... struct T0CONBITS { 
....................    unsigned int T0PS0:1; 
....................    unsigned int T0PS1:1; 
....................    unsigned int T0PS2:1; 
....................    unsigned int PSA:1; 
....................    unsigned int T0SE:1; 
....................    unsigned int T0CS:1; 
....................    unsigned int T08BIT:1; 
....................    unsigned int TMR0ON:1; 
.................... } T0CONbits; 
.................... #byte T0CONbits = 0xFD5 
.................... #byte T0CON = 0xFD5 
....................  
.................... struct OSCCONBITS { 
....................    unsigned int SCS0:1; 
....................    unsigned int SCS1:1; 
....................    unsigned int :1; 
....................    unsigned int OSTS:1; 
....................    unsigned int :3; 
....................    unsigned int IDLEN:1; 
.................... } OSCCONbits; 
.................... #byte OSCCONbits = 0xFD3 
.................... #byte OSCCON = 0xFD3 
....................  
.................... struct ECON1BITS { 
....................    unsigned int :2; 
....................    unsigned int RXEN:1; 
....................    unsigned int TXRTS:1; 
....................    unsigned int CSUMEN:1; 
....................    unsigned int DMAST:1; 
....................    unsigned int RXRST:1; 
....................    unsigned int TXRST:1; 
.................... } ECON1bits; 
.................... #byte ECON1bits = 0xFD2 
.................... #byte ECON1 = 0xFD2 
....................  
.................... struct WDTCONBITS { 
....................    unsigned int SWDTEN:1; 
.................... } WDTCONbits; 
.................... #byte WDTCONbits = 0xFD1 
.................... #byte WDTCON = 0xFD1 
....................  
.................... struct RCONBITS { 
....................    unsigned int BOR:1; 
....................    unsigned int POR:1; 
....................    unsigned int PD:1; 
....................    unsigned int TO:1; 
....................    unsigned int RI:1; 
....................    unsigned int :2; 
....................    unsigned int IPEN:1; 
.................... } RCONbits; 
.................... #byte RCONbits = 0xFD0 
.................... #byte RCON = 0xFD0 
....................  
.................... #byte TMR1H = 0xFCF 
....................  
.................... #byte TMR1L = 0xFCE 
....................  
.................... struct T1CONBITS { 
....................    unsigned int TMR1ON:1; 
....................    unsigned int TMR1CS:1; 
....................    unsigned int T1SYNC:1; 
....................    unsigned int T1OSCEN:1; 
....................    unsigned int T1CKPS4:1; 
....................    unsigned int T1CKPS5:1; 
....................    unsigned int T1RUN:1; 
....................    unsigned int RD16:1; 
.................... } T1CONbits; 
.................... #byte T1CONbits = 0xFCD 
.................... #byte T1CON = 0xFCD 
....................  
.................... #byte TMR2 = 0xFCC 
....................  
.................... #byte PR2 = 0xFCB 
....................  
.................... struct T2CONBITS { 
....................    unsigned int T2CKPS0:1; 
....................    unsigned int T2CKPS1:1; 
....................    unsigned int TMR2ON:1; 
....................    unsigned int TOUTPS0:1; 
....................    unsigned int TOUTPS1:1; 
....................    unsigned int TOUTPS2:1; 
....................    unsigned int TOUTPS3:1; 
.................... } T2CONbits; 
.................... #byte T2CONbits = 0xFCA 
.................... #byte T2CON = 0xFCA 
....................  
.................... #byte SSP1BUF = 0xFC9 
....................  
.................... #byte SSP1ADD = 0xFC8 
....................  
.................... struct SSP1STATBITS { 
....................    unsigned int BF:1; 
....................    unsigned int UA:1; 
....................    unsigned int R:1; 
....................    unsigned int S:1; 
....................    unsigned int P:1; 
....................    unsigned int D:1; 
....................    unsigned int CKE:1; 
....................    unsigned int SMP:1; 
.................... } SSP1STATbits; 
.................... #byte SSP1STATbits = 0xFC7 
.................... #byte SSP1STAT = 0xFC7 
....................  
.................... struct SSP1CON1BITS { 
....................    unsigned int SSPM0:1; 
....................    unsigned int SSPM1:1; 
....................    unsigned int SSPM2:1; 
....................    unsigned int SSPM3:1; 
....................    unsigned int CKP:1; 
....................    unsigned int SSPEN:1; 
....................    unsigned int SSPOV:1; 
....................    unsigned int WCOL:1; 
.................... } SSP1CON1bits; 
.................... #byte SSP1CON1bits = 0xFC6 
.................... #byte SSP1CON1 = 0xFC6 
....................  
.................... struct SSP1CON2BITS { 
....................    unsigned int SEN:1; 
....................    unsigned int RSEN:1; 
....................    unsigned int PEN:1; 
....................    unsigned int RCEN:1; 
....................    unsigned int ACKEN:1; 
....................    unsigned int ACKDT:1; 
....................    unsigned int ACKSTAT:1; 
....................    unsigned int GCEN:1; 
.................... } SSP1CON2bits; 
.................... #byte SSP1CON2bits = 0xFC5 
.................... #byte SSP1CON2 = 0xFC5 
....................  
.................... #byte ADRESH = 0xFC4 
....................  
.................... #byte ADRESL = 0xFC3 
....................  
.................... struct ADCON0BITS { 
....................    unsigned int ADON:1; 
....................    unsigned int GO:1; 
....................    unsigned int CHS0:1; 
....................    unsigned int CHS1:1; 
....................    unsigned int CHS2:1; 
....................    unsigned int CHS3:1; 
....................    unsigned int reserved:1; 
....................    unsigned int ADCAL:1; 
.................... } ADCON0bits; 
.................... #byte ADCON0bits = 0xFC2 
.................... #byte ADCON0 = 0xFC2 
....................  
.................... struct ADCON1BITS { 
....................    unsigned int PCFG0:1; 
....................    unsigned int PCFG1:1; 
....................    unsigned int PCFG2:1; 
....................    unsigned int PCFG3:1; 
....................    unsigned int VCFG4:1; 
....................    unsigned int VCFG1:1; 
.................... } ADCON1bits; 
.................... #byte ADCON1bits = 0xFC1 
.................... #byte ADCON1 = 0xFC1 
....................  
.................... struct ADCON2BITS { 
....................    unsigned int ADCS0:1; 
....................    unsigned int ADCS1:1; 
....................    unsigned int ADCS2:1; 
....................    unsigned int ACQT3:1; 
....................    unsigned int ACQT4:1; 
....................    unsigned int ACQT2:1; 
....................    unsigned int :1; 
....................    unsigned int ADFM:1; 
.................... } ADCON2bits; 
.................... #byte ADCON2bits = 0xFC0 
.................... #byte ADCON2 = 0xFC0 
....................  
.................... #byte CCPR1H = 0xFBF 
....................  
.................... #byte CCPR1L = 0xFBE 
....................  
.................... struct CCP1CONBITS { 
....................    unsigned int CCP1M0:1; 
....................    unsigned int CCP1M1:1; 
....................    unsigned int CCP1M2:1; 
....................    unsigned int CCP1M3:1; 
....................    unsigned int DC1B4:1; 
....................    unsigned int DC1B5:1; 
....................    unsigned int P1M6:1; 
....................    unsigned int P1M1:1; 
.................... } CCP1CONbits; 
.................... #byte CCP1CONbits = 0xFBD 
.................... #byte CCP1CON = 0xFBD 
....................  
.................... #byte CCPR2H = 0xFBC 
....................  
.................... #byte CCPR2L = 0xFBB 
....................  
.................... struct CCP2CONBITS { 
....................    unsigned int CCP2M0:1; 
....................    unsigned int CCP2M1:1; 
....................    unsigned int CCP2M2:1; 
....................    unsigned int CCP2M3:1; 
....................    unsigned int DC2B4:1; 
....................    unsigned int DC2B5:1; 
....................    unsigned int P2M6:1; 
....................    unsigned int P2M1:1; 
.................... } CCP2CONbits; 
.................... #byte CCP2CONbits = 0xFBA 
.................... #byte CCP2CON = 0xFBA 
....................  
.................... #byte CCPR3H = 0xFB9 
....................  
.................... #byte CCPR3L = 0xFB8 
....................  
.................... struct CCP3CONBITS { 
....................    unsigned int CCP3M0:1; 
....................    unsigned int CCP3M1:1; 
....................    unsigned int CCP3M2:1; 
....................    unsigned int CCP3M3:1; 
....................    unsigned int DC3B4:1; 
....................    unsigned int DC3B5:1; 
....................    unsigned int P3M6:1; 
....................    unsigned int P3M1:1; 
.................... } CCP3CONbits; 
.................... #byte CCP3CONbits = 0xFB7 
.................... #byte CCP3CON = 0xFB7 
....................  
.................... struct ECCP1ASBITS { 
....................    unsigned int PSSBD0:1; 
....................    unsigned int PSSBD1:1; 
....................    unsigned int PSSAC2:1; 
....................    unsigned int PSSAC3:1; 
....................    unsigned int ECCPAS4:1; 
....................    unsigned int ECCPAS5:1; 
....................    unsigned int ECCPAS6:1; 
....................    unsigned int ECCPASE:1; 
.................... } ECCP1ASbits; 
.................... #byte ECCP1ASbits = 0xFB6 
.................... #byte ECCP1AS = 0xFB6 
....................  
.................... struct CVRCONBITS { 
....................    unsigned int CVR0:1; 
....................    unsigned int CVR1:1; 
....................    unsigned int CVR2:1; 
....................    unsigned int CVR3:1; 
....................    unsigned int CVRSS:1; 
....................    unsigned int CVRR:1; 
....................    unsigned int CVROE:1; 
....................    unsigned int CVREN:1; 
.................... } CVRCONbits; 
.................... #byte CVRCONbits = 0xFB5 
.................... #byte CVRCON = 0xFB5 
....................  
.................... struct CMCONBITS { 
....................    unsigned int CM0:1; 
....................    unsigned int CM1:1; 
....................    unsigned int CM2:1; 
....................    unsigned int CIS:1; 
....................    unsigned int C1INV:1; 
....................    unsigned int C2INV:1; 
....................    unsigned int C1OUT:1; 
....................    unsigned int C2OUT:1; 
.................... } CMCONbits; 
.................... #byte CMCONbits = 0xFB4 
.................... #byte CMCON = 0xFB4 
....................  
.................... #byte TMR3H = 0xFB3 
....................  
.................... #byte TMR3L = 0xFB2 
....................  
.................... struct T3CONBITS { 
....................    unsigned int TMR3ON:1; 
....................    unsigned int TMR3CS:1; 
....................    unsigned int T3SYNC:1; 
....................    unsigned int T3CCP3:1; 
....................    unsigned int T3CKPS4:1; 
....................    unsigned int T3CKPS5:1; 
....................    unsigned int T3CCP6:1; 
....................    unsigned int RD16:1; 
.................... } T3CONbits; 
.................... #byte T3CONbits = 0xFB1 
.................... #byte T3CON = 0xFB1 
....................  
.................... #byte SPBRG1 = 0xFAF 
....................  
.................... #byte RCREG1 = 0xFAE 
....................  
.................... #byte TXREG1 = 0xFAD 
....................  
.................... struct TXSTA1BITS { 
....................    unsigned int TX9D:1; 
....................    unsigned int TRMT:1; 
....................    unsigned int BRGH:1; 
....................    unsigned int SENDB:1; 
....................    unsigned int SYNC:1; 
....................    unsigned int TXEN:1; 
....................    unsigned int TX:1; 
....................    unsigned int CSRC:1; 
.................... } TXSTA1bits; 
.................... #byte TXSTA1bits = 0xFAC 
.................... #byte TXSTA1 = 0xFAC 
....................  
.................... struct RCSTA1BITS { 
....................    unsigned int RX9D:1; 
....................    unsigned int OERR:1; 
....................    unsigned int FERR:1; 
....................    unsigned int ADDEN:1; 
....................    unsigned int CREN:1; 
....................    unsigned int SREN:1; 
....................    unsigned int RX:1; 
....................    unsigned int SPEN:1; 
.................... } RCSTA1bits; 
.................... #byte RCSTA1bits = 0xFAB 
.................... #byte RCSTA1 = 0xFAB 
....................  
.................... #byte EECON2 = 0xFA7 
....................  
.................... struct EECON1BITS { 
....................    unsigned int :1; 
....................    unsigned int WR:1; 
....................    unsigned int WREN:1; 
....................    unsigned int WRERR:1; 
....................    unsigned int FREE:1; 
.................... } EECON1bits; 
.................... #byte EECON1bits = 0xFA6 
.................... #byte EECON1 = 0xFA6 
....................  
.................... struct IPR3BITS { 
....................    unsigned int CCP3IP:1; 
....................    unsigned int CCP4IP:1; 
....................    unsigned int CCP5IP:1; 
....................    unsigned int TMR4IP:1; 
.................... } IPR3bits; 
.................... #byte IPR3bits = 0xFA5 
.................... #byte IPR3 = 0xFA5 
....................  
.................... struct PIR3BITS { 
....................    unsigned int CCP3IF:1; 
....................    unsigned int CCP4IF:1; 
....................    unsigned int CCP5IF:1; 
....................    unsigned int TMR4IF:1; 
.................... } PIR3bits; 
.................... #byte PIR3bits = 0xFA4 
.................... #byte PIR3 = 0xFA4 
....................  
.................... struct PIE3BITS { 
....................    unsigned int CCP3IE:1; 
....................    unsigned int CCP4IE:1; 
....................    unsigned int CCP5IE:1; 
....................    unsigned int TMR4IE:1; 
.................... } PIE3bits; 
.................... #byte PIE3bits = 0xFA3 
.................... #byte PIE3 = 0xFA3 
....................  
.................... struct IPR2BITS { 
....................    unsigned int CCP2IP:1; 
....................    unsigned int TMR3IP:1; 
....................    unsigned int :1; 
....................    unsigned int BCL1IP:1; 
....................    unsigned int WOLIP:1; 
....................    unsigned int ETHIP:1; 
....................    unsigned int CMIP:1; 
....................    unsigned int OSCFIP:1; 
.................... } IPR2bits; 
.................... #byte IPR2bits = 0xFA2 
.................... #byte IPR2 = 0xFA2 
....................  
.................... struct PIR2BITS { 
....................    unsigned int CCP2IF:1; 
....................    unsigned int TMR3IF:1; 
....................    unsigned int :1; 
....................    unsigned int BCL1IF:1; 
....................    unsigned int WOLIF:1; 
....................    unsigned int ETHIF:1; 
....................    unsigned int CMIF:1; 
....................    unsigned int OSCFIF:1; 
.................... } PIR2bits; 
.................... #byte PIR2bits = 0xFA1 
.................... #byte PIR2 = 0xFA1 
....................  
.................... struct PIE2BITS { 
....................    unsigned int CCP2IE:1; 
....................    unsigned int TMR3IE:1; 
....................    unsigned int :1; 
....................    unsigned int BCL1IE:1; 
....................    unsigned int WOLIE:1; 
....................    unsigned int ETHIE:1; 
....................    unsigned int CMIE:1; 
....................    unsigned int OSCFIE:1; 
.................... } PIE2bits; 
.................... #byte PIE2bits = 0xFA0 
.................... #byte PIE2 = 0xFA0 
....................  
.................... struct IPR1BITS { 
....................    unsigned int TMR1IP:1; 
....................    unsigned int TMR2IP:1; 
....................    unsigned int CCP1IP:1; 
....................    unsigned int SSP1IP:1; 
....................    unsigned int TX1IP:1; 
....................    unsigned int RC1IP:1; 
....................    unsigned int ADIP:1; 
.................... } IPR1bits; 
.................... #byte IPR1bits = 0xF9F 
.................... #byte IPR1 = 0xF9F 
....................  
.................... struct PIR1BITS { 
....................    unsigned int TMR1IF:1; 
....................    unsigned int TMR2IF:1; 
....................    unsigned int CCP1IF:1; 
....................    unsigned int SSP1IF:1; 
....................    unsigned int TX1IF:1; 
....................    unsigned int RC1IF:1; 
....................    unsigned int ADIF:1; 
.................... } PIR1bits; 
.................... #byte PIR1bits = 0xF9E 
.................... #byte PIR1 = 0xF9E 
....................  
.................... struct PIE1BITS { 
....................    unsigned int TMR1IE:1; 
....................    unsigned int TMR2IE:1; 
....................    unsigned int CCP1IE:1; 
....................    unsigned int SSP1IE:1; 
....................    unsigned int TX1IE:1; 
....................    unsigned int RC1IE:1; 
....................    unsigned int ADIE:1; 
.................... } PIE1bits; 
.................... #byte PIE1bits = 0xF9D 
.................... #byte PIE1 = 0xF9D 
....................  
.................... struct OSCTUNEBITS { 
....................    unsigned int :4; 
....................    unsigned int PPRE:1; 
....................    unsigned int PPST5:1; 
....................    unsigned int PLLEN:1; 
....................    unsigned int PPST1:1; 
.................... } OSCTUNEbits; 
.................... #byte OSCTUNEbits = 0xF9B 
.................... #byte OSCTUNE = 0xF9B 
....................  
.................... struct TRISGBITS { 
....................    unsigned int :4; 
....................    unsigned int TRISG4:1; 
.................... } TRISGbits; 
.................... #byte TRISGbits = 0xF98 
.................... #byte TRISG = 0xF98 
....................  
.................... struct TRISFBITS { 
....................    unsigned int :1; 
....................    unsigned int TRISF1:1; 
....................    unsigned int TRISF2:1; 
....................    unsigned int TRISF3:1; 
....................    unsigned int TRISF4:1; 
....................    unsigned int TRISF5:1; 
....................    unsigned int TRISF6:1; 
....................    unsigned int TRISF7:1; 
.................... } TRISFbits; 
.................... #byte TRISFbits = 0xF97 
.................... #byte TRISF = 0xF97 
....................  
.................... struct TRISEBITS { 
....................    unsigned int TRISE0:1; 
....................    unsigned int TRISE1:1; 
....................    unsigned int TRISE2:1; 
....................    unsigned int TRISE3:1; 
....................    unsigned int TRISE4:1; 
....................    unsigned int TRISE5:1; 
....................    unsigned int TRISE6:1; 
....................    unsigned int TRISE7:1; 
.................... } TRISEbits; 
.................... #byte TRISEbits = 0xF96 
.................... #byte TRISE = 0xF96 
....................  
.................... struct TRISDBITS { 
....................    unsigned int TRISD0:1; 
....................    unsigned int TRISD1:1; 
....................    unsigned int TRISD2:1; 
....................    unsigned int TRISD3:1; 
....................    unsigned int TRISD4:1; 
....................    unsigned int TRISD5:1; 
....................    unsigned int TRISD6:1; 
....................    unsigned int TRISD7:1; 
.................... } TRISDbits; 
.................... #byte TRISDbits = 0xF95 
.................... #byte TRISD = 0xF95 
....................  
.................... struct TRISCBITS { 
....................    unsigned int TRISC0:1; 
....................    unsigned int TRISC1:1; 
....................    unsigned int TRISC2:1; 
....................    unsigned int TRISC3:1; 
....................    unsigned int TRISC4:1; 
....................    unsigned int TRISC5:1; 
....................    unsigned int TRISC6:1; 
....................    unsigned int TRISC7:1; 
.................... } TRISCbits; 
.................... #byte TRISCbits = 0xF94 
.................... #byte TRISC = 0xF94 
....................  
.................... struct TRISBBITS { 
....................    unsigned int TRISB0:1; 
....................    unsigned int TRISB1:1; 
....................    unsigned int TRISB2:1; 
....................    unsigned int TRISB3:1; 
....................    unsigned int TRISB4:1; 
....................    unsigned int TRISB5:1; 
....................    unsigned int TRISB6:1; 
....................    unsigned int TRISB7:1; 
.................... } TRISBbits; 
.................... #byte TRISBbits = 0xF93 
.................... #byte TRISB = 0xF93 
....................  
.................... struct TRISABITS { 
....................    unsigned int TRISA0:1; 
....................    unsigned int TRISA1:1; 
....................    unsigned int TRISA2:1; 
....................    unsigned int TRISA3:1; 
....................    unsigned int TRISA4:1; 
....................    unsigned int TRISA5:1; 
....................    unsigned int TRISA6:1; 
....................    unsigned int TRISA7:1; 
.................... } TRISAbits; 
.................... #byte TRISAbits = 0xF92 
.................... #byte TRISA = 0xF92 
....................  
.................... struct LATGBITS { 
....................    unsigned int :4; 
....................    unsigned int LATG4:1; 
.................... } LATGbits; 
.................... #byte LATGbits = 0xF8F 
.................... #byte LATG = 0xF8F 
....................  
.................... struct LATFBITS { 
....................    unsigned int :1; 
....................    unsigned int LATF1:1; 
....................    unsigned int LATF2:1; 
....................    unsigned int LATF3:1; 
....................    unsigned int LATF4:1; 
....................    unsigned int LATF5:1; 
....................    unsigned int LATF6:1; 
....................    unsigned int LATF7:1; 
.................... } LATFbits; 
.................... #byte LATFbits = 0xF8E 
.................... #byte LATF = 0xF8E 
....................  
.................... struct LATEBITS { 
....................    unsigned int LATE0:1; 
....................    unsigned int LATE1:1; 
....................    unsigned int LATE2:1; 
....................    unsigned int LATE3:1; 
....................    unsigned int LATE4:1; 
....................    unsigned int LATE5:1; 
....................    unsigned int LATE6:1; 
....................    unsigned int LATE7:1; 
.................... } LATEbits; 
.................... #byte LATEbits = 0xF8D 
.................... #byte LATE = 0xF8D 
....................  
.................... struct LATDBITS { 
....................    unsigned int LATD0:1; 
....................    unsigned int LATD1:1; 
....................    unsigned int LATD2:1; 
....................    unsigned int LATD3:1; 
....................    unsigned int LATD4:1; 
....................    unsigned int LATD5:1; 
....................    unsigned int LATD6:1; 
....................    unsigned int LATD7:1; 
.................... } LATDbits; 
.................... #byte LATDbits = 0xF8C 
.................... #byte LATD = 0xF8C 
....................  
.................... struct LATCBITS { 
....................    unsigned int LATC0:1; 
....................    unsigned int LATC1:1; 
....................    unsigned int LATC2:1; 
....................    unsigned int LATC3:1; 
....................    unsigned int LATC4:1; 
....................    unsigned int LATC5:1; 
....................    unsigned int LATC6:1; 
....................    unsigned int LATC7:1; 
.................... } LATCbits; 
.................... #byte LATCbits = 0xF8B 
.................... #byte LATC = 0xF8B 
....................  
.................... struct LATBBITS { 
....................    unsigned int LATB0:1; 
....................    unsigned int LATB1:1; 
....................    unsigned int LATB2:1; 
....................    unsigned int LATB3:1; 
....................    unsigned int LATB4:1; 
....................    unsigned int LATB5:1; 
....................    unsigned int LATB6:1; 
....................    unsigned int LATB7:1; 
.................... } LATBbits; 
.................... #byte LATBbits = 0xF8A 
.................... #byte LATB = 0xF8A 
....................  
.................... struct LATABITS { 
....................    unsigned int LATA0:1; 
....................    unsigned int LATA1:1; 
....................    unsigned int LATA2:1; 
....................    unsigned int LATA3:1; 
....................    unsigned int LATA4:1; 
....................    unsigned int LATA5:1; 
....................    unsigned int REPU:1; 
....................    unsigned int RDPU:1; 
.................... } LATAbits; 
.................... #byte LATAbits = 0xF89 
.................... #byte LATA = 0xF89 
....................  
.................... struct PORTGBITS { 
....................    unsigned int :4; 
....................    unsigned int RG4:1; 
.................... } PORTGbits; 
.................... #byte PORTGbits = 0xF86 
.................... #byte PORTG = 0xF86 
....................  
.................... struct PORTFBITS { 
....................    unsigned int :1; 
....................    unsigned int RF1:1; 
....................    unsigned int RF2:1; 
....................    unsigned int RF3:1; 
....................    unsigned int RF4:1; 
....................    unsigned int RF5:1; 
....................    unsigned int RF6:1; 
....................    unsigned int RF7:1; 
.................... } PORTFbits; 
.................... #byte PORTFbits = 0xF85 
.................... #byte PORTF = 0xF85 
....................  
.................... struct PORTEBITS { 
....................    unsigned int RE0:1; 
....................    unsigned int RE1:1; 
....................    unsigned int RE2:1; 
....................    unsigned int RE3:1; 
....................    unsigned int RE4:1; 
....................    unsigned int RE5:1; 
....................    unsigned int RE6:1; 
....................    unsigned int RE7:1; 
.................... } PORTEbits; 
.................... #byte PORTEbits = 0xF84 
.................... #byte PORTE = 0xF84 
....................  
.................... struct PORTDBITS { 
....................    unsigned int RD0:1; 
....................    unsigned int RD1:1; 
....................    unsigned int RD2:1; 
....................    unsigned int RD3:1; 
....................    unsigned int RD4:1; 
....................    unsigned int RD5:1; 
....................    unsigned int RD6:1; 
....................    unsigned int RD7:1; 
.................... } PORTDbits; 
.................... #byte PORTDbits = 0xF83 
.................... #byte PORTD = 0xF83 
....................  
.................... struct PORTCBITS { 
....................    unsigned int RC0:1; 
....................    unsigned int RC1:1; 
....................    unsigned int RC2:1; 
....................    unsigned int RC3:1; 
....................    unsigned int RC4:1; 
....................    unsigned int RC5:1; 
....................    unsigned int RC6:1; 
....................    unsigned int RC7:1; 
.................... } PORTCbits; 
.................... #byte PORTCbits = 0xF82 
.................... #byte PORTC = 0xF82 
....................  
.................... struct PORTBBITS { 
....................    unsigned int RB0:1; 
....................    unsigned int RB1:1; 
....................    unsigned int RB2:1; 
....................    unsigned int RB3:1; 
....................    unsigned int RB4:1; 
....................    unsigned int RB5:1; 
....................    unsigned int RB6:1; 
....................    unsigned int RB7:1; 
.................... } PORTBbits; 
.................... #byte PORTBbits = 0xF81 
.................... #byte PORTB = 0xF81 
....................  
.................... struct PORTABITS { 
....................    unsigned int RA0:1; 
....................    unsigned int RA1:1; 
....................    unsigned int RA2:1; 
....................    unsigned int RA3:1; 
....................    unsigned int RA4:1; 
....................    unsigned int RA5:1; 
....................    unsigned int RA6:1; 
....................    unsigned int RA7:1; 
.................... } PORTAbits; 
.................... #byte PORTAbits = 0xF80 
.................... #byte PORTA = 0xF80 
....................  
.................... #byte SPBRGH1 = 0xF7F 
....................  
.................... struct BAUDCON1BITS { 
....................    unsigned int ABDEN:1; 
....................    unsigned int WUE:1; 
....................    unsigned int :1; 
....................    unsigned int BRG1:1; 
....................    unsigned int TXCKP:1; 
....................    unsigned int RXDTP:1; 
....................    unsigned int RCIDL:1; 
....................    unsigned int ABDOVF:1; 
.................... } BAUDCON1bits; 
.................... #byte BAUDCON1bits = 0xF7E 
.................... #byte BAUDCON1 = 0xF7E 
....................  
.................... #byte ERDPTH = 0xF7B 
....................  
.................... #byte ERDPTL = 0xF7A 
....................  
.................... #word ERDPT = 0xF7A 
....................  
.................... struct ECCP1DELBITS { 
....................    unsigned int PDC0:1; 
....................    unsigned int PDC1:1; 
....................    unsigned int PDC2:1; 
....................    unsigned int PDC3:1; 
....................    unsigned int PDC4:1; 
....................    unsigned int PDC5:1; 
....................    unsigned int PDC6:1; 
....................    unsigned int PRSEN:1; 
.................... } ECCP1DELbits; 
.................... #byte ECCP1DELbits = 0xF79 
.................... #byte ECCP1DEL = 0xF79 
....................  
.................... #byte TMR4 = 0xF78 
....................  
.................... #byte PR4 = 0xF77 
....................  
.................... struct T4CONBITS { 
....................    unsigned int T4CKPS0:1; 
....................    unsigned int T4CKPS1:1; 
....................    unsigned int TMR4ON:1; 
....................    unsigned int T4OUTPS0:1; 
....................    unsigned int T4OUTPS1:1; 
....................    unsigned int T4OUTPS2:1; 
....................    unsigned int T4OUTPS3:1; 
.................... } T4CONbits; 
.................... #byte T4CONbits = 0xF76 
.................... #byte T4CON = 0xF76 
....................  
.................... #byte CCPR4H = 0xF75 
....................  
.................... #byte CCPR4L = 0xF74 
....................  
.................... struct CCP4CONBITS { 
....................    unsigned int CCP4M0:1; 
....................    unsigned int CCP4M1:1; 
....................    unsigned int CCP4M2:1; 
....................    unsigned int CCP4M3:1; 
....................    unsigned int DC4B4:1; 
....................    unsigned int DC4B1:1; 
.................... } CCP4CONbits; 
.................... #byte CCP4CONbits = 0xF73 
.................... #byte CCP4CON = 0xF73 
....................  
.................... #byte CCPR5H = 0xF72 
....................  
.................... #byte CCPR5L = 0xF71 
....................  
.................... struct CCP5CONBITS { 
....................    unsigned int CCP5M0:1; 
....................    unsigned int CCP5M1:1; 
....................    unsigned int CCP5M2:1; 
....................    unsigned int CCP5M3:1; 
....................    unsigned int DC5B4:1; 
....................    unsigned int DC5B1:1; 
.................... } CCP5CONbits; 
.................... #byte CCP5CONbits = 0xF70 
.................... #byte CCP5CON = 0xF70 
....................  
.................... struct ECCP3ASBITS { 
....................    unsigned int PSSBD0:1; 
....................    unsigned int PSSBD1:1; 
....................    unsigned int PSSAC2:1; 
....................    unsigned int PSSAC3:1; 
....................    unsigned int ECCPAS4:1; 
....................    unsigned int ECCPAS5:1; 
....................    unsigned int ECCPAS6:1; 
....................    unsigned int ECCPASE:1; 
.................... } ECCP3ASbits; 
.................... #byte ECCP3ASbits = 0xF6A 
.................... #byte ECCP3AS = 0xF6A 
....................  
.................... struct ECCP3DELBITS { 
....................    unsigned int PDC0:1; 
....................    unsigned int PDC1:1; 
....................    unsigned int PDC2:1; 
....................    unsigned int PDC3:1; 
....................    unsigned int PDC4:1; 
....................    unsigned int PDC5:1; 
....................    unsigned int PDC6:1; 
....................    unsigned int PRSEN:1; 
.................... } ECCP3DELbits; 
.................... #byte ECCP3DELbits = 0xF69 
.................... #byte ECCP3DEL = 0xF69 
....................  
.................... struct ECCP2ASBITS { 
....................    unsigned int PSSBD0:1; 
....................    unsigned int PSSBD1:1; 
....................    unsigned int PSSAC2:1; 
....................    unsigned int PSSAC3:1; 
....................    unsigned int ECCPAS4:1; 
....................    unsigned int ECCPAS5:1; 
....................    unsigned int ECCPAS6:1; 
....................    unsigned int ECCPASE:1; 
.................... } ECCP2ASbits; 
.................... #byte ECCP2ASbits = 0xF68 
.................... #byte ECCP2AS = 0xF68 
....................  
.................... struct ECCP2DELBITS { 
....................    unsigned int PDC0:1; 
....................    unsigned int PDC1:1; 
....................    unsigned int PDC2:1; 
....................    unsigned int PDC3:1; 
....................    unsigned int PDC4:1; 
....................    unsigned int PDC5:1; 
....................    unsigned int PDC6:1; 
....................    unsigned int PRSEN:1; 
.................... } ECCP2DELbits; 
.................... #byte ECCP2DELbits = 0xF67 
.................... #byte ECCP2DEL = 0xF67 
....................  
.................... #byte EDATA = 0xF61 
....................  
.................... struct EIRBITS { 
....................    unsigned int RXERIF:1; 
....................    unsigned int TXERIF:1; 
....................    unsigned int :1; 
....................    unsigned int TXIF:1; 
....................    unsigned int LINKIF:1; 
....................    unsigned int DMAIF:1; 
....................    unsigned int PKTIF:1; 
.................... } EIRbits; 
.................... #byte EIRbits = 0xF60 
.................... #byte EIR = 0xF60 
....................  
.................... struct ECON2BITS { 
....................    unsigned int :5; 
....................    unsigned int ETHEN:1; 
....................    unsigned int PKTDEC:1; 
....................    unsigned int AUTOINC:1; 
.................... } ECON2bits; 
.................... #byte ECON2bits = 0xEFE 
.................... #byte ECON2 = 0xEFE 
....................  
.................... struct ESTATBITS { 
....................    unsigned int PHYRDY:1; 
....................    unsigned int TXABRT:1; 
....................    unsigned int RXBUSY:1; 
....................    unsigned int :1; 
....................    unsigned int LATECOL:1; 
....................    unsigned int :1; 
....................    unsigned int BUFER:1; 
.................... } ESTATbits; 
.................... #byte ESTATbits = 0xEFD 
.................... #byte ESTAT = 0xEFD 
....................  
.................... struct EIEBITS { 
....................    unsigned int RXERIE:1; 
....................    unsigned int TXERIE:1; 
....................    unsigned int :1; 
....................    unsigned int TXIE:1; 
....................    unsigned int LINKIE:1; 
....................    unsigned int DMAIE:1; 
....................    unsigned int PKTIE:1; 
.................... } EIEbits; 
.................... #byte EIEbits = 0xEFB 
.................... #byte EIE = 0xEFB 
....................  
.................... #byte EDMACSH = 0xEF7 
....................  
.................... #byte EDMACSL = 0xEF6 
....................  
.................... #byte EDMADSTH = 0xEF5 
....................  
.................... #byte EDMADSTL = 0xEF4 
....................  
.................... #word EDMADST = 0xEF4 
....................  
.................... #byte EDMANDH = 0xEF3 
....................  
.................... #byte EDMANDL = 0xEF2 
....................  
.................... #word EDMAND = 0xEF2 
....................  
.................... #byte EDMASTH = 0xEF1 
....................  
.................... #byte EDMASTL = 0xEF0 
....................  
.................... #word EDMAST = 0xEF0 
....................  
.................... #byte ERXWRPTH = 0xEEF 
....................  
.................... #byte ERXWRPTL = 0xEEE 
....................  
.................... #word ERXWRPT = 0xEEE 
....................  
.................... #byte ERXRDPTH = 0xEED 
....................  
.................... #byte ERXRDPTL = 0xEEC 
....................  
.................... #word ERXRDPT = 0xEEC 
....................  
.................... #byte ERXNDH = 0xEEB 
....................  
.................... #byte ERXNDL = 0xEEA 
....................  
.................... #word ERXND = 0xEEA 
....................  
.................... #byte ERXSTH = 0xEE9 
....................  
.................... #byte ERXSTL = 0xEE8 
....................  
.................... #word ERXST = 0xEE8 
....................  
.................... #byte ETXNDH = 0xEE7 
....................  
.................... #byte ETXNDL = 0xEE6 
....................  
.................... #word ETXND = 0xEE6 
....................  
.................... #byte ETXSTH = 0xEE5 
....................  
.................... #byte ETXSTL = 0xEE4 
....................  
.................... #word ETXST = 0xEE4 
....................  
.................... #byte EWRPTH = 0xEE3 
....................  
.................... #byte EWRPTL = 0xEE2 
....................  
.................... #word EWRPT = 0xEE2 
....................  
.................... #byte EPKTCNT = 0xED9 
....................  
.................... struct ERXFCONBITS { 
....................    unsigned int BCEN:1; 
....................    unsigned int MCEN:1; 
....................    unsigned int HTEN:1; 
....................    unsigned int MPEN:1; 
....................    unsigned int PMEN:1; 
....................    unsigned int CRCEN:1; 
....................    unsigned int ANDOR:1; 
....................    unsigned int UCEN:1; 
.................... } ERXFCONbits; 
.................... #byte ERXFCONbits = 0xED8 
.................... #byte ERXFCON = 0xED8 
....................  
.................... #byte EPMOH = 0xED5 
....................  
.................... #byte EPMOL = 0xED4 
....................  
.................... #byte EPMCSH = 0xED1 
....................  
.................... #byte EPMCSL = 0xED0 
....................  
.................... #byte EPMM7 = 0xECF 
....................  
.................... #byte EPMM6 = 0xECE 
....................  
.................... #byte EPMM5 = 0xECD 
....................  
.................... #byte EPMM4 = 0xECC 
....................  
.................... #byte EPMM3 = 0xECB 
....................  
.................... #byte EPMM2 = 0xECA 
....................  
.................... #byte EPMM1 = 0xEC9 
....................  
.................... #byte EPMM0 = 0xEC8 
....................  
.................... #byte EHT7 = 0xEC7 
....................  
.................... #byte EHT6 = 0xEC6 
....................  
.................... #byte EHT5 = 0xEC5 
....................  
.................... #byte EHT4 = 0xEC4 
....................  
.................... #byte EHT3 = 0xEC3 
....................  
.................... #byte EHT2 = 0xEC2 
....................  
.................... #byte EHT1 = 0xEC1 
....................  
.................... #byte EHT0 = 0xEC0 
....................  
.................... #byte MIRDH = 0xEB9 
....................  
.................... #byte MIRDL = 0xEB8 
....................  
.................... #byte MIWRH = 0xEB7 
....................  
.................... #byte MIWRL = 0xEB6 
....................  
.................... #byte MIREGADR = 0xEB4 
....................  
.................... struct MICMDBITS { 
....................    unsigned int MIIRD:1; 
....................    unsigned int MIISCAN:1; 
.................... } MICMDbits; 
.................... #byte MICMDbits = 0xEB2 
.................... #byte MICMD = 0xEB2 
....................  
.................... struct MICONBITS { 
....................    unsigned int :7; 
....................    unsigned int RSTMII:1; 
.................... } MICONbits; 
.................... #byte MICONbits = 0xEB1 
.................... #byte MICON = 0xEB1 
....................  
.................... #byte MAMXFLH = 0xEAB 
....................  
.................... #byte MAMXFLL = 0xEAA 
....................  
.................... #byte MACLCON2 = 0xEA9 
....................  
.................... #byte MACLCON1 = 0xEA8 
....................  
.................... #byte MAIPGH = 0xEA7 
....................  
.................... #byte MAIPGL = 0xEA6 
....................  
.................... #byte MABBIPG = 0xEA4 
....................  
.................... struct MACON4BITS { 
....................    unsigned int :4; 
....................    unsigned int NOBKOFF:1; 
....................    unsigned int BPEN:1; 
....................    unsigned int DEFER:1; 
.................... } MACON4bits; 
.................... #byte MACON4bits = 0xEA3 
.................... #byte MACON4 = 0xEA3 
....................  
.................... struct MACON3BITS { 
....................    unsigned int FULDPX:1; 
....................    unsigned int FRMLNEN:1; 
....................    unsigned int HFRMEN:1; 
....................    unsigned int PHDREN:1; 
....................    unsigned int TXCRCEN:1; 
....................    unsigned int PADCFG5:1; 
....................    unsigned int PADCFG6:1; 
....................    unsigned int PADCFG2:1; 
.................... } MACON3bits; 
.................... #byte MACON3bits = 0xEA2 
.................... #byte MACON3 = 0xEA2 
....................  
.................... struct MACON1BITS { 
....................    unsigned int MARXEN:1; 
....................    unsigned int PASSALL:1; 
....................    unsigned int RXPAUS:1; 
....................    unsigned int TXPAUS:1; 
.................... } MACON1bits; 
.................... #byte MACON1bits = 0xEA0 
.................... #byte MACON1 = 0xEA0 
....................  
.................... #byte EPAUSH = 0xE99 
....................  
.................... #byte EPAUSL = 0xE98 
....................  
.................... struct EFLOCONBITS { 
....................    unsigned int FCEN0:1; 
....................    unsigned int FCEN1:1; 
....................    unsigned int FULDPXS:1; 
.................... } EFLOCONbits; 
.................... #byte EFLOCONbits = 0xE97 
.................... #byte EFLOCON = 0xE97 
....................  
.................... struct MISTATBITS { 
....................    unsigned int BUSY:1; 
....................    unsigned int SCAN:1; 
....................    unsigned int NVALID:1; 
....................    unsigned int LINKFL:1; 
.................... } MISTATbits; 
.................... #byte MISTATbits = 0xE8A 
.................... #byte MISTAT = 0xE8A 
....................  
.................... #byte MAADR2 = 0xE85 
....................  
.................... #byte MAADR1 = 0xE84 
....................  
.................... #byte MAADR4 = 0xE83 
....................  
.................... #byte MAADR3 = 0xE82 
....................  
.................... #byte MAADR6 = 0xE81 
....................  
.................... #byte MAADR5 = 0xE80 
....................  
....................  
.................... #elif getenv("DEVICE") == "PIC18F66J65" 
....................  #define __18F66J65 
.................... #elif getenv("DEVICE") == "PIC18F66J60" 
....................  #define __18F66J60 
.................... #elif getenv("DEVICE") == "PIC18F67K22" 
....................  #define __18F67K22 
....................  #include "PIC18F67K22_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F4620" 
....................  #define __18F4620 
....................  #include "PIC18F4620_registers.h" 
.................... #else 
....................    #error Do this for your chip 
.................... #endif 
....................  
.................... #if defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) 
....................    #reserve 0xE80:0xEFF 
....................    #reserve 0xF00:0xFFF 
.................... #endif 
....................  
.................... #if defined(TRUE) 
....................    #undef TRUE 
.................... #endif 
....................  
.................... #if defined(FALSE) 
....................    #undef FALSE 
.................... #endif 
....................  
.................... #if defined(BYTE) 
....................    #undef BYTE 
.................... #endif 
....................  
....................       #define Reset()            reset_cpu() 
....................         #define far 
....................         #define ClrWdt()         restart_wdt() 
....................       #define Nop()            delay_cycles(1)       
....................  
.................... #define __CCS__ 
....................  
.................... //signed int8 memcmppgm2ram(void * s1, rom char *s2, unsigned int8 n); 
.................... signed int8 strcmppgm2ram(char *s1, __ADDRESS__ s2); 
.................... char *strchrpgm(__ADDRESS__ s, unsigned int8 c); 
.................... char *strstrrampgm(char *s1, __ADDRESS__ s2); 
.................... unsigned int8 strlenpgm(__ADDRESS__ s); 
.................... void memcpypgm2ram(unsigned int8 *d, __ADDRESS__ s, unsigned int16 n); 
.................... //char* strupr(char *s);   now in string.h 
.................... void strcpypgm2ram(char *d, __ADDRESS__ s); 
.................... #endif 
....................  
....................    #reserve 0xE80:0xEFF   //SFR 
....................    #reserve 0xF00:0xFFF   //SFR 
....................    #use delay(clock=41666667) 
*
00230:  MOVLW  01
00232:  MOVWF  FEA
00234:  MOVLW  6E
00236:  MOVWF  FE9
00238:  MOVF   FEF,W
0023A:  BZ    0258
0023C:  MOVLW  0D
0023E:  MOVWF  01
00240:  CLRF   00
00242:  DECFSZ 00,F
00244:  BRA    0242
00246:  DECFSZ 01,F
00248:  BRA    0240
0024A:  MOVLW  81
0024C:  MOVWF  00
0024E:  DECFSZ 00,F
00250:  BRA    024E
00252:  BRA    0254
00254:  DECFSZ FEF,F
00256:  BRA    023C
00258:  GOTO   0272 (RETURN)
....................    #fuses NOWDT, NODEBUG, H4_SW, NOIESO, NOFCMEN, PRIMARY, ETHLED 
....................     
....................    #use rs232(baud=9600, uart1, stream=STREAM_UI, errors) 
....................        
....................    //#include "tcpip/elcd.c" //removed, use standard lcd.c that has #define'able pins 
....................    #define BUTTON1_PRESSED()  (!input(PIN_A4)) 
....................    #define USER_LED1    PIN_B3 
....................    #define USER_LED2    PIN_B4 
....................    #define USER_LED3    PIN_B5 
....................    #define LED_ON       output_low 
....................    #define LED_OFF      output_high 
....................    #define STANDARD_ADC_STRING  "AN2" 
....................    #define STANDARD_ADC_CHANNEL 2 
....................  
....................    #define LCD_ENABLE_PIN  PIN_F3 
....................    #define LCD_RS_PIN      PIN_F1 
....................    #define LCD_RW_PIN      PIN_F2 
....................    #define LCD_DATA4       PIN_F4 
....................    #define LCD_DATA5       PIN_F5 
....................    #define LCD_DATA6       PIN_F6 
....................    #define LCD_DATA7       PIN_F7 
....................     
....................    #ifndef STACK_USE_PICDEM_LCD 
....................       #define STACK_USE_PICDEM_LCD 1 
....................    #endif 
....................    #if STACK_USE_PICDEM_LCD 
....................       #include "lcd.c" 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
....................    delay_cycles(1); 
....................    lcd_output_enable(1); 
....................    delay_cycles(1); 
....................    high = lcd_read_nibble(); 
....................        
....................    lcd_output_enable(0); 
....................    delay_cycles(1); 
....................    lcd_output_enable(1); 
....................    delay_us(1); 
....................    low = lcd_read_nibble(); 
....................        
....................    lcd_output_enable(0); 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
....................    lcd_output_enable(1); 
....................    delay_us(2); 
....................    lcd_output_enable(0); 
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
....................    lcd_rs_tris(); 
....................    lcd_rw_tris(); 
....................   #endif 
....................  
....................    lcd_output_rs(0); 
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
....................    lcd_output_rs(address); 
....................    delay_cycles(1); 
....................    lcd_output_rw(0); 
....................    delay_cycles(1); 
....................    lcd_output_enable(0); 
....................    lcd_send_nibble(n >> 4); 
....................    lcd_send_nibble(n & 0xf); 
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
....................    lcd_output_rs(0); 
....................    lcd_output_rw(0); 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
....................    lcd_rs_tris(); 
....................    lcd_rw_tris(); 
....................  #endif 
....................      
....................    delay_ms(15); 
....................    for(i=1;i<=3;++i) 
....................    { 
....................        lcd_send_nibble(3); 
....................        delay_ms(5); 
....................    } 
....................     
....................    lcd_send_nibble(2); 
....................    delay_ms(5); 
....................    for(i=0;i<=3;++i) 
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
....................       address=LCD_LINE_TWO; 
....................    else 
....................       address=0; 
....................       
....................    address+=x-1; 
....................    lcd_send_byte(0,0x80|address); 
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
....................                      delay_ms(2); 
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
....................      #endif 
....................    } 
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................    #endif 
....................     
....................    void init_user_io(void)  
....................    { 
....................       setup_oscillator(OSC_PLL_5_DIV_3 | OSC_NORMAL); 
0025C:  MOVLW  40
0025E:  MOVWF  F9B
00260:  MOVLW  02
00262:  MOVWF  FD3
00264:  MOVF   FD3,W
....................       restart_wdt(); 
00266:  CLRWDT
....................       delay_ms(144); 
00268:  MOVLW  90
0026A:  MOVLB  1
0026C:  MOVWF  x6E
0026E:  MOVLB  0
00270:  BRA    0230
....................       restart_wdt(); 
00272:  CLRWDT
....................        
....................       setup_adc(ADC_CLOCK_INTERNAL); 
00274:  MOVF   FC0,W
00276:  ANDLW  C0
00278:  IORLW  07
0027A:  MOVWF  FC0
0027C:  BCF    FC0.7
0027E:  BSF    FC2.0
00280:  BSF    FC2.7
00282:  BSF    FC2.1
00284:  BTFSC  FC2.1
00286:  BRA    0284
00288:  BCF    FC2.7
....................       setup_adc_ports(AN0_TO_AN2); 
0028A:  MOVF   FC1,W
0028C:  ANDLW  C0
0028E:  IORLW  0C
00290:  MOVWF  FC1
....................       set_adc_channel(STANDARD_ADC_CHANNEL); 
00292:  MOVLW  08
00294:  MOVWF  01
00296:  MOVF   FC2,W
00298:  ANDLW  C3
0029A:  IORWF  01,W
0029C:  MOVWF  FC2
....................        
....................       setup_comparator(NC_NC_NC_NC); 
0029E:  MOVLW  07
002A0:  MOVWF  FB4
002A2:  MOVF   F97,W
002A4:  MOVWF  F97
002A6:  MOVLW  22
002A8:  MOVWF  00
002AA:  DECFSZ 00,F
002AC:  BRA    02AA
002AE:  NOP   
002B0:  MOVF   FB4,W
002B2:  BCF    FA1.6
....................        
....................       output_drive(PIN_A1);   //ethernet led 
002B4:  BCF    F92.1
....................       output_drive(PIN_A0);   //ethernet led 
002B6:  BCF    F92.0
....................        
....................       output_drive(USER_LED1); 
002B8:  BCF    F93.3
....................       output_drive(USER_LED2); 
002BA:  BCF    F93.4
....................       output_drive(USER_LED3); 
002BC:  BCF    F93.5
....................       LED_OFF(USER_LED1); 
002BE:  BCF    F93.3
002C0:  BSF    F8A.3
....................       LED_OFF(USER_LED2); 
002C2:  BCF    F93.4
002C4:  BSF    F8A.4
....................       LED_OFF(USER_LED3); 
002C6:  BCF    F93.5
002C8:  BSF    F8A.5
002CA:  GOTO   0324 (RETURN)
....................    } 
....................     
....................    #define EEPROM_SELECT   PIN_C1  //o 
....................    #define EEPROM_DI       PIN_C5  //o 
....................    #define EEPROM_DO       PIN_C4  //i 
....................    #define EEPROM_CLK      PIN_C3  //o 
....................    #define EEPROM_USE_SPI  1 
....................    #include "AT25256.C" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for an ATMEL25128 or ATMEL25256                         //// 
.................... ////    ATMEL25128 has 16,384 (or 13bits of addressing) locations      //// 
.................... ////    ATMEL25256 has 32,768 words of 8 bits                          //// 
.................... ////                                                                   //// 
.................... ////   Uses software (bit banging on the port pins)                    //// 
.................... ////                                                                   //// 
.................... ////                     Pin Layout                                    //// 
.................... ////   ATMEL EEPROM pin     to      Microchip MCU Pin                  //// 
.................... ////   ----------------             -----------------                  //// 
.................... ////   1 (CS)                       PortB 0                            //// 
.................... ////   2 (SO)                       PortC 4                            //// 
.................... ////   3 (WP)                       +5V                                //// 
.................... ////   4 (GND)                      GND                                //// 
.................... ////   5 (SI)                       PortC 5                            //// 
.................... ////   6 (SCK)                      PortC 3                            //// 
.................... ////   7 (HOLD)                     +5V                                //// 
.................... ////   8 (VCC)                      +5V                                //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the unsigned int8 d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the unsigned int8 d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   b = ext_eerpom_ready();  Returns TRUE if the eeprom is ready    //// 
.................... ////                            to receive opcodes                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef EEPROM_SELECT 
.................... #define EEPROM_SELECT PIN_B0 
.................... #define EEPROM_DI     PIN_C5 
.................... #define EEPROM_DO     PIN_C4 
.................... #define EEPROM_CLK    PIN_C3 
.................... #endif 
....................  
.................... #ifndef EEPROM_ADDRESS 
.................... #define EEPROM_ADDRESS long 
.................... #endif 
....................  
.................... #byte SSPSTAT=0x94 
.................... #byte SSPCON=0x14 
....................  
.................... void init_ext_eeprom() { 
....................    int1 i; 
....................  
....................    output_low(EEPROM_DI); 
....................    output_low(EEPROM_CLK); 
....................    output_high(EEPROM_SELECT);   //at25256 is cs active LOW 
....................    i=input(EEPROM_DO); 
.................... } 
....................  
.................... BOOLEAN ext_eeprom_ready() { 
....................    unsigned int8 cmd[1],i,data; 
....................  
....................    cmd[0] = 0x05;         //rdsr opcode 
....................  
....................    output_low(EEPROM_SELECT); 
....................  
....................    for(i=1;i<=8;++i) { 
....................       output_bit(EEPROM_DI, shift_left(cmd,1,0)); 
....................       output_high(EEPROM_CLK);      //data latches 
....................       output_low(EEPROM_CLK);      //back to idle 
....................    } 
....................  
....................    for(i=1;i<=8;++i) { 
....................         output_high(EEPROM_CLK);      //data latches 
....................         shift_left(&data,1,input(EEPROM_DO)); 
....................         output_low(EEPROM_CLK);              //back to idle 
....................    } 
....................    output_high(EEPROM_SELECT); 
....................    return (!(bit_test(data, 0))); 
.................... } 
....................  
....................  
.................... void write_ext_eeprom(EEPROM_ADDRESS address, unsigned int8 data) { 
....................  
....................    unsigned int8 cmd[4]; 
....................    unsigned int8 i; 
....................    cmd[2]=((address>>8)&(0xFF));   //address msb (16bit addressing) 
....................    cmd[1]=address-cmd[2];      //address lsb 
....................  
....................    do {} while (!(ext_eeprom_ready())); //wait until the eeprom is out of the previous write state, if applicable 
....................  
....................    cmd[0]=0x06; 
....................    output_low(EEPROM_SELECT); //cs is active low 
....................    for(i=1;i<=8;++i) { 
....................       output_bit(EEPROM_DI, shift_left(cmd,1,0)); 
....................       output_high(EEPROM_CLK);      //data latches 
....................       output_low(EEPROM_CLK);      //back to idle 
....................    } 
....................    output_high(EEPROM_SELECT); 
....................  
....................    cmd[0]=data; 
....................    cmd[3]=0x02;      //write opcode 
....................    output_low(EEPROM_SELECT); 
....................    for(i=1;i<=32;++i) { 
....................       output_bit(EEPROM_DI, shift_left(cmd,4,0)); 
....................       output_high(EEPROM_CLK);      //data latches 
....................       output_low(EEPROM_CLK);      //back to idle 
....................    } 
....................  
....................    output_high(EEPROM_SELECT); 
.................... } 
....................  
....................  
.................... unsigned int8 read_ext_eeprom(EEPROM_ADDRESS address) { 
....................    unsigned int8 i,data; 
....................    unsigned int8 cmd[3]; 
....................    cmd[2]=0x03;            //read opcode 
....................    cmd[1]=((address>>8)&(0xFF)); 
....................    cmd[0]=address-cmd[1]; 
....................  
....................    do {} while (!(ext_eeprom_ready())); //wait until the eeprom is out of the previous write state, if applicable 
....................    output_low(EEPROM_SELECT); 
....................    for(i=1;i<=24;++i) { 
....................       output_bit(EEPROM_DI, shift_left(cmd,3,0)); 
....................       output_high(EEPROM_CLK);      //data latches 
....................       output_low(EEPROM_CLK);      //back to idle 
....................    } 
....................  
....................    for(i=1;i<=8;++i) { 
....................         output_high(EEPROM_CLK);      //data latches 
....................         shift_left(&data,1,input(EEPROM_DO)); 
....................         output_low(EEPROM_CLK);              //back to idle 
....................    } 
....................  
....................    output_high(EEPROM_SELECT); 
....................  
....................    return(data); 
.................... } 
....................  
....................  
....................    #define __SPIFLASH_H    //prevent spiflash.h from being loaded/used 
....................    #define SPIFlashReadArray(dwAddress, pData, wLen)  read_ext_eeprom_buf(dwAddress, pData, wLen) 
....................    #define SPIFlashInit()                             init_ext_eeprom() 
....................    EEPROM_ADDRESS g_SpiFlashCurrWrite; 
....................    #define SPIFlashBeginWrite(addy)                   g_SpiFlashCurrWrite=addy 
....................    #define SPIFlashWrite(d)                           write_ext_eeprom(g_SpiFlashCurrWrite++, d) 
....................    #define SPIFlashStopWrite() 
....................    #define SPIFlashWriteBytes(dwAddress, pData, wLen) write_ext_eeprom_buf(dwAddress, pData, wLen) 
....................     
....................    // if you want TCP/IP settings saved to internal EEPROM, then comment 
....................    // out the next few lines: 
....................    //#define EEInit SPIFlashInit 
....................    //#define EEReadBytes(dst, src, len)  SPIFlashReadArray(src, dst, len) 
....................    //#define EEWriteBytes(dst, src, len) SPIFlashWriteBytes(dst, src, len); SPIFlashStopWrite() 
....................  
.................... #elif STACK_USE_CCS_PICENS 
....................    #include <18F4620.h> 
....................    #include "tcpip\p18cxxx.h" 
....................    #use delay(clock=40000000) 
....................    #fuses H4, NOWDT, NOLVP, NODEBUG  
....................     
....................    #use rs232(baud=9600, uart1, stream=STREAM_UI, errors) 
....................        
....................    #define BUTTON1_PRESSED()  (!input(PIN_A4)) 
....................    #define USER_LED1    PIN_A5 
....................    #define USER_LED2    PIN_B4 
....................    #define USER_LED3    PIN_B5 
....................    #define LED_ON       output_low 
....................    #define LED_OFF      output_high 
....................    #define STANDARD_ADC_STRING  "AN0" 
....................    #define STANDARD_ADC_CHANNEL 0 
....................     
....................    #define LCD_ENABLE_PIN  PIN_E2 
....................    #define LCD_RS_PIN      PIN_E0 
....................    #define LCD_RW_PIN      PIN_E1 
....................    #define LCD_DATA4       PIN_D4 
....................    #define LCD_DATA5       PIN_D5 
....................    #define LCD_DATA6       PIN_D6 
....................    #define LCD_DATA7       PIN_D7 
....................     
....................    #ifndef STACK_USE_PICDEM_LCD 
....................       #define STACK_USE_PICDEM_LCD 1 
....................    #endif 
....................    #if STACK_USE_PICDEM_LCD 
....................       #include "lcd.c" 
....................    #endif 
....................     
....................    #define ENC_CS_IO       LATDbits.LATD1 
....................    #define ENC_CS_TRIS     TRISDbits.TRISD1 
....................    #define ENC_SCK_TRIS    TRISCbits.TRISC3 
....................    #define ENC_SDO_TRIS    TRISCbits.TRISC5 
....................    #define ENC_SDI_TRIS    TRISCbits.TRISC4 
....................    #define ENC_SPI_IF         PIR1bits.SSPIF 
....................    #define ENC_SPICON1        SSPCON1bits 
....................    #define ENC_SPISTATbits    SSPSTATbits 
....................    #define ENC_SSPBUF         SSPBUF 
....................     
....................    void init_user_io(void)  
....................    { 
....................       setup_adc(ADC_CLOCK_INTERNAL); 
....................       setup_adc_ports(AN0); 
....................       set_adc_channel(STANDARD_ADC_CHANNEL); 
....................        
....................       setup_comparator(NC_NC_NC_NC); 
....................        
....................       output_drive(USER_LED1); 
....................       output_drive(USER_LED2); 
....................       output_drive(USER_LED3); 
....................       LED_OFF(USER_LED1); 
....................       LED_OFF(USER_LED2); 
....................       LED_OFF(USER_LED3); 
....................    } 
....................     
....................    #define EEPROM_SELECT     PIN_B3 
....................    #define EEPROM_DI         PIN_C5 
....................    #define EEPROM_DO         PIN_C4 
....................    #define EEPROM_CLK        PIN_C3 
....................    #define EEPROM_USE_SPI    1 
....................    #include "AT25256.C" 
....................     
....................    #define __SPIFLASH_H    //prevent spiflash.h from being loaded/used 
....................    #define SPIFlashReadArray(dwAddress, pData, wLen)  read_ext_eeprom_buf(dwAddress, pData, wLen) 
....................    #define SPIFlashInit()                             init_ext_eeprom() 
....................    EEPROM_ADDRESS g_SpiFlashCurrWrite; 
....................    #define SPIFlashBeginWrite(addy)                   g_SpiFlashCurrWrite=addy 
....................    #define SPIFlashWrite(d)                           write_ext_eeprom(g_SpiFlashCurrWrite++, d) 
....................    #define SPIFlashStopWrite() 
....................    #define SPIFlashWriteBytes(dwAddress, pData, wLen) write_ext_eeprom_buf(dwAddress, pData, wLen) 
....................     
....................    // if you want TCP/IP settings saved to internal EEPROM, then comment 
....................    // out the next few lines: 
....................    #define EEInit SPIFlashInit 
....................    #define EEReadBytes(dst, src, len)  SPIFlashReadArray(src, dst, len) 
....................    #define EEWriteBytes(dst, src, len) SPIFlashWriteBytes(dst, src, len); SPIFlashStopWrite() 
....................  
.................... #elif STACK_USE_CCS_EWL3V 
....................    #include <18F67J60.h> 
....................    #include "tcpip\p18cxxx.h" 
....................    #reserve 0xE80:0xEFF   //SFR 
....................    #reserve 0xF00:0xFFF   //SFR 
....................    #use delay(clock=41666667) 
....................    #fuses NOWDT, NODEBUG, H4_SW, NOIESO, NOFCMEN, PRIMARY, ETHLED 
....................   
....................    #use rs232(baud=9600, uart1, stream=STREAM_UI, errors)  
....................  
....................    void lcd_putc(char c) 
....................    { 
....................      #if STACK_USE_PICDEM_LCD 
....................        if (c == '\f') 
....................          printf("\r\n\n"); 
....................        else 
....................          putc(c); 
....................      #endif 
....................    } 
....................    #define lcd_init() 
....................    #ifndef STACK_USE_PICDEM_LCD 
....................       #define STACK_USE_PICDEM_LCD 0   // no hardware LCD support 
....................    #endif 
....................     
....................    #define LED_ON       output_high 
....................    #define LED_OFF      output_low 
....................    #define USER_LED1    PIN_F1                 //input1 
....................    #define USER_LED2    PIN_F2                 //input2 
....................    #define USER_LED3    PIN_F3                 //input3 
....................    #define STANDARD_ADC_STRING  "AN9" 
....................    #define STANDARD_ADC_CHANNEL 9              //input4 
....................    #define BUTTON1_PRESSED() (input(PIN_F5))   //input5 
....................    #define BUTTON2_PRESSED() (input(PIN_F6))   //input6 
....................  
....................    void init_user_io(void) 
....................    { 
....................       setup_oscillator(OSC_PLL_5_DIV_3 | OSC_NORMAL); 
....................       restart_wdt(); 
....................       delay_ms(144); 
....................       restart_wdt(); 
....................     
....................       setup_adc(ADC_CLOCK_INTERNAL); 
....................       setup_adc_ports(AN0_TO_AN9); 
....................       set_adc_channel(STANDARD_ADC_CHANNEL); 
....................        
....................       setup_comparator(NC_NC_NC_NC); 
....................  
....................       output_drive(USER_LED1); 
....................       output_drive(USER_LED2); 
....................       output_drive(USER_LED3); 
....................       LED_OFF(USER_LED1); 
....................       LED_OFF(USER_LED2); 
....................       LED_OFF(USER_LED3); 
....................       output_low(pin_c0); 
....................       output_low(pin_c1); 
....................    } 
....................      
....................    #define __AT45DB_B__ 
....................    #define FLASH_SELECT PIN_C2 
....................    #define FLASH_CLOCK  PIN_C3 
....................    #define FLASH_DI     PIN_C5 
....................    #define FLASH_DO     PIN_C4 
....................    #define FLASH_BUFFER_SIZE    264     //bytes per page 
....................    #define FLASH_BUFFER_COUNT   4096   //page count 
....................    #include "at45db.c"  
....................        
....................    #define __SPIFLASH_H    //prevent spiflash.h from being loaded/used 
....................    #define SPIFlashReadArray(dwAddress, pData, wLen)  ext_flash_read(dwAddress, pData, wLen) 
....................    #define SPIFlashInit()                             init_ext_flash() 
....................    #define SPIFlashBeginWrite(addy)                   ext_flash_startWrite(addy) 
....................    #define SPIFlashWrite(d)                           ext_flash_continuousWrite(d) 
....................    #define SPIFlashStopWrite()                        ext_flash_flushWrites() 
....................    #define SPIFlashWriteBytes(dwAddress, pData, wLen) ext_flash_writeBytes(dwAddress, pData, wLen) 
....................     
....................    // if you want TCP/IP settings saved to internal EEPROM, then comment 
....................    // out the next few lines: 
....................   // #define EEInit SPIFlashInit 
....................    //#define EEReadBytes(dst, src, len)  SPIFlashReadArray(src, dst, len) 
....................    //#define EEWriteBytes(dst, src, len) SPIFlashWriteBytes(dst, src, len)  
....................     
.................... #elif STACK_USE_CCS_EWL5V_REV5 
....................    #include <18F67K22.h> 
....................    #include "tcpip\p18cxxx.h" 
....................    #reserve 0xF16:0xFFF   //SFR 
....................    #use delay(clock=64M, XTAL=16M) 
....................     
....................    #use rs232(baud=9600, uart1, stream=STREAM_UI, errors) 
....................  
....................    void lcd_putc(char c) 
....................    { 
....................      #if STACK_USE_PICDEM_LCD 
....................        if (c == '\f') 
....................          printf("\r\n\n"); 
....................        else 
....................          putc(c); 
....................      #endif 
....................    } 
....................    #define lcd_init() 
....................    #ifndef STACK_USE_PICDEM_LCD 
....................       #define STACK_USE_PICDEM_LCD 0   // no hardware LCD support 
....................    #endif 
....................      
....................    #define LED_ON       output_high 
....................    #define LED_OFF      output_low 
....................    #define USER_LED1    PIN_G3                 //input1 
....................    #define USER_LED2    PIN_G4                 //input2 
....................    #define USER_LED3    PIN_A2                 //input3 
....................    #define STANDARD_ADC_STRING  "AN3" 
....................    #define STANDARD_ADC_CHANNEL 3              //input4 
....................    #define BUTTON1_PRESSED() (input(PIN_A5))   //input5 
....................    #define BUTTON2_PRESSED() (input(PIN_B5))   //input6 
....................  
....................    #define ENC_CS_IO       LATFbits.LATF2    
....................    #define ENC_CS_TRIS     TRISFbits.TRISF2 
....................    #define ENC_SCK_TRIS    TRISCbits.TRISC3 
....................    #define ENC_SDO_TRIS    TRISCbits.TRISC5 
....................    #define ENC_SDI_TRIS    TRISCbits.TRISC4 
....................    #define ENC_RST_IO      LATDbits.LATD0 
....................    #define ENC_RST_TRIS    TRISDbits.TRISD0 
....................    #define ENC_SPI_IF         PIR1bits.SSP1IF 
....................    #define ENC_SPICON1        SSP1CON1bits   //SPI1CON1 
....................    #define ENC_SPICON2        SPI1CON2 
....................    #define ENC_SPISTAT        SPI1STAT 
....................    #define ENC_SSPBUF         SSP1BUF        //SPI1BUF 
....................    #define ENC_SPICON1bits    SPI1CON1bits 
....................    #define ENC_SPICON2bits    SPI1CON2bits 
....................    #define ENC_SPISTATbits    SSP1STATbits   //SPI1STATbits   
....................  
....................    void init_user_io(void) 
....................    { 
....................       setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_2); 
....................       setup_adc_ports(sAN3); 
....................       set_adc_channel(STANDARD_ADC_CHANNEL); 
....................       output_drive(USER_LED1); 
....................       output_drive(USER_LED2); 
....................       output_drive(USER_LED3); 
....................       LED_OFF(USER_LED1); 
....................       LED_OFF(USER_LED2); 
....................       LED_OFF(USER_LED3); 
....................    } 
....................     
....................    #define __AT45DB_D__ 
....................    #define FLASH_SELECT PIN_F1 
....................    #define FLASH_CLOCK  PIN_D6 
....................    #define FLASH_DO     PIN_D5   //MISO 
....................    #define FLASH_DI     PIN_D4   //MOSI 
....................    #define FLASH_BUFFER_SIZE    264 
....................    #define FLASH_BUFFER_COUNT   4096 
....................    #include "at45db.c" 
....................        
....................    #define __SPIFLASH_H    //prevent spiflash.h from being loaded/used 
....................    #define SPIFlashReadArray(dwAddress, pData, wLen)  ext_flash_read(dwAddress, pData, wLen) 
....................    #define SPIFlashInit()                             init_ext_flash() 
....................    #define SPIFlashBeginWrite(addy)                   ext_flash_startWrite(addy) 
....................    #define SPIFlashWrite(d)                           ext_flash_continuousWrite(d) 
....................    #define SPIFlashStopWrite()                        ext_flash_flushWrites() 
....................    #define SPIFlashWriteBytes(dwAddress, pData, wLen) ext_flash_writeBytes(dwAddress, pData, wLen) 
....................     
....................    // if you want TCP/IP settings saved to internal EEPROM, then comment 
....................    // out the next few lines: 
....................    #define EEInit SPIFlashInit 
....................    #define EEReadBytes(dst, src, len)  SPIFlashReadArray(src, dst, len) 
....................    #define EEWriteBytes(dst, src, len) SPIFlashWriteBytes(dst, src, len) 
....................  
.................... /* currently working on this - not functional */ 
.................... #elif STACK_USE_CCS_PICNET 
....................    #include <18F6722.h> 
....................    #include "tcpip\p18cxxx.h" 
....................    // SFR? 
....................    #use delay (clock=40000000) 
....................    #fuses H4, NOLVP, NOWDT, NODEBUG 
....................     
....................    #use rs232(baud=9600, uart1, stream=STREAM_UI, errors) 
....................  
....................    #define STACK_USE_PICDEM_LCD TRUE 
....................    #define BUTTON1_PRESSED()  (!input(PIN_B0)) 
....................    #define BUTTON2_PRESSED()  (!input(PIN_B1)) 
....................    #define USER_LED1    PIN_B2 
....................    #define USER_LED2    PIN_B4 
....................    #define LED_ON       output_low 
....................    #define LED_OFF      output_high 
....................    #define STANDARD_ADC_STRING  "AN0" 
....................    #define STANDARD_ADC_CHANNEL 0 
....................    #define SECONDARY_ADC_STRING "AN1" 
....................    #define SECONDARY_ADC_CHANNEL 1 
....................     
....................    #define LCD_ENABLE_PIN  PIN_D0 
....................    #define LCD_RS_PIN      PIN_D1 
....................    #define LCD_RW_PIN      PIN_D2 
....................    #define LCD_DATA4       PIN_D4 
....................    #define LCD_DATA5       PIN_D5 
....................    #define LCD_DATA6       PIN_D6 
....................    #define LCD_DATA7       PIN_D7 
....................     
....................    #ifndef STACK_USE_PICDEM_LCD 
....................       #define STACK_USE_PICDEM_LCD 1 
....................    #endif 
....................    #if STACK_USE_PICDEM_LCD 
....................       #include "lcd.c" 
....................    #endif 
....................     
....................    void init_user_io(void) { 
....................       setup_adc(ADC_CLOCK_INTERNAL ); 
....................       setup_adc_ports(ANALOG_AN0_TO_AN1); 
....................       set_adc_channel(STANDARD_ADC_CHANNEL); 
....................       //*0xF92=*0xF92 | 3;            //a0 and a1 input (for ADC) 
....................       //*0xF93=(*0xF93 & 0xEB) | 3;   //B0 and B1 input, B2 and B4 output 
....................       output_drive(USER_LED1); 
....................       output_drive(USER_LED2); 
....................       LED_OFF(USER_LED1); 
....................       LED_OFF(USER_LED2); 
....................    } 
....................  
.................... #else 
....................  #error You need to define your custom hardware 
.................... #endif 
....................  
.................... #ifndef LED_ACTIVITY_BLINK 
.................... #define LED_ACTIVITY_BLINK() 
.................... #endif 
....................  
.................... #if !STACK_USE_PICDEM_LCD 
....................    #define lcd_putc(c) 
....................    #define lcd_init() 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_WIFI 
....................    #define STACK_USE_CCS_GRATUITOUS_ARP 
....................     
....................    #define WIFI_CCS_RESET_ON_MODULE_HANG 
....................     
....................    #define WF_USE_TX_POWER_CONTROL_FUNCTIONS 
....................  
....................    #define WF_FORCE_NO_PS_POLL 
....................      
....................    //#define FORCE_ADHOC_ACTIVATED !input(PIN_G4)     //a certain button press can force ad hoc mode regardless of EE setting 
....................     
....................    #define STACK_USE_DNS_SERVER   //strongly recommended if using ad-hoc mode 
....................    #define STACK_USE_DHCP_SERVER  //strongly recommended if using ad-hoc mode 
.................... #endif 
....................  
.................... #ifndef STACK_USE_CCS_INI 
....................  #define STACK_USE_CCS_INI 0 
....................  #define UITask() 
.................... #endif 
....................  
.................... #if STACK_USE_CCS_INI 
....................    #define STACK_USE_DHCP_CLIENT 
.................... #endif 
....................  
.................... // clock definitions required by Microchip's TCP/IP Stack. 
.................... #if defined(__PCH__) //pic18 
....................    #define GetSystemClock()      getenv("CLOCK") 
....................    #define GetInstructionClock()   (GetSystemClock()/4) 
....................    #define GetPeripheralClock()   (unsigned int32)GetInstructionClock() 
.................... #else //pic24,dspic30,dspic33f 
....................    #define GetSystemClock()       getenv("CLOCK") 
....................    #define GetInstructionClock()  (GetSystemClock()/2) 
....................    #define GetPeripheralClock()   (GetSystemClock()/2) 
.................... #endif 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define MIN(a,b)  ((a > b) ? b : a) 
....................  
.................... #include "tcpip/StackTsk2.h" 
.................... // 'glue' file for using Microchip's TCP/IP stack inside CCS C Compiler without 
.................... // a linker.   
.................... // Also includes some macros/defines for porting older V3 stack to this current 
.................... // stack. 
.................... // Also provides extra routines written by CCS to improve the stack. 
....................  
.................... #ifndef __CCS_STACKTSK2_H__ 
.................... #define __CCS_STACKTSK2_H__ 
....................  
.................... #if !defined(debug_mpfs2) 
....................  #define debug_mpfs2(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) 
.................... #else 
....................  #define __DO_DEBUG_MPFS2 
.................... #endif 
....................  
.................... #if defined(__PCH__) && !defined(__18CXX) 
....................  #define __18CXX 
.................... #endif 
....................  
.................... #define SIZEOF_MAC_HEADER 14 
....................  
.................... // override delay.c/delay.h with CCS compatible code 
.................... #define __DELAY_H 
.................... #define Delay10us(x) delay_us((uint16_t)10*(uint16_t)x) 
.................... #define DelayMs(x)   delay_ms(x) 
....................  
.................... #define __WF_DEBUG_STRINGS_H  //don't include this file 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
04F64:  MOVFF  26B,26D
04F68:  MOVFF  26A,26C
04F6C:  MOVFF  26D,03
04F70:  MOVLB  2
04F72:  MOVFF  26C,FE9
04F76:  MOVFF  26D,FEA
04F7A:  MOVF   FEF,F
04F7C:  BZ    4F8A
04F7E:  INCF   x6C,F
04F80:  BTFSC  FD8.2
04F82:  INCF   x6D,F
04F84:  MOVLB  0
04F86:  BRA    4F6C
04F88:  MOVLB  2
....................    return(sc - s); 
04F8A:  MOVF   x6A,W
04F8C:  SUBWF  x6C,W
04F8E:  MOVWF  00
04F90:  MOVF   x6B,W
04F92:  SUBWFB x6D,W
04F94:  MOVWF  03
04F96:  MOVFF  00,01
04F9A:  MOVLB  0
04F9C:  RETURN 0
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... #ifdef BYTE 
.................... #undef BYTE 
.................... #endif 
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
.................... #include "Compiler.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Compiler and hardware specific definitions 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Compiler.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, PIC24E, dsPIC30F, dsPIC33F,  
....................  *               dsPIC33E, PIC32 
....................  * Compiler:        Microchip C32 v1.00 or higher 
....................  *               Microchip C30 v3.01 or higher 
....................  *               Microchip C18 v3.13 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights  
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and  
....................  * distribute:  
....................  * (i)  the Software when embedded on a Microchip microcontroller or  
....................  *      digital signal controller product ("Device") which is  
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c and  
....................  *      ENC28J60.h ported to a non-Microchip device used in  
....................  *      conjunction with a Microchip ethernet controller for the  
....................  *      sole purpose of interfacing with the ethernet controller.  
....................  * 
....................  * You should refer to the license agreement accompanying this  
....................  * Software for additional information regarding your rights and  
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT  
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT  
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A  
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL  
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR  
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF  
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS  
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER  
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT  
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * 10/03/2006   Original, copied from old Compiler.h 
....................  * 11/07/2007   Reorganized and simplified 
....................  * 03/31/2010   Removed dependency on WORD and DWORD typedefs 
....................  * 04/14/2010   Added defines to uniquely identify each compiler 
....................  ********************************************************************/ 
.................... #ifndef __COMPILER_H 
.................... #define __COMPILER_H 
....................  
.................... // Include proper device header file 
.................... #if defined(__18CXX) && !defined(HI_TECH_C)    
....................    // PIC18 processor with Microchip C18 compiler 
....................     #define COMPILER_MPLAB_C18 
....................     #include <p18cxxx.h> 
.................... // CCS PCH C Compiler to Microchip C18 Compiler compatability layer. 
....................  
.................... #ifndef __P18CXXXX_H__ 
.................... #define __P18CXXXX_H__ 
....................  
.................... #ifndef __18CXX 
.................... #define __18CXX 
.................... #endif 
....................  
.................... //#zero_local_ram 
.................... #zero_ram 
....................  
....................  
.................... #device PASS_STRINGS=IN_RAM 
.................... #device CONST=READ_ONLY 
....................  
.................... #case 
.................... #type signed 
.................... #type short=16 int=16 long=32 
....................  
.................... #define _asm #asm 
.................... #define _endasm #endasm 
....................  
.................... /* usualy 
.................... #define GetSystemClock()      getenv("CLOCK") 
.................... #define GetInstructionClock()   (GetSystemClock()/4) 
.................... #define GetPeripheralClock()   (unsigned int32)GetInstructionClock() 
.................... */ 
....................  
.................... #if getenv("DEVICE") == "PIC18F97J60" 
....................  #define __18F97J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F96J65" 
....................  #define __18F96J65) 
.................... #elif getenv("DEVICE") == "PIC18F96J60" 
....................  #define __18F96J60 
.................... #elif getenv("DEVICE") == "PIC18F87J60" 
....................  #define __18F87J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J60" 
....................  #define __18F86J60 
.................... #elif getenv("DEVICE") == "PIC18F67J60" 
....................  #define __18F67J60 
....................  #include "PIC18F67J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F66J65" 
....................  #define __18F66J65 
.................... #elif getenv("DEVICE") == "PIC18F66J60" 
....................  #define __18F66J60 
.................... #elif getenv("DEVICE") == "PIC18F67K22" 
....................  #define __18F67K22 
....................  #include "PIC18F67K22_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F4620" 
....................  #define __18F4620 
....................  #include "PIC18F4620_registers.h" 
.................... #else 
....................    #error Do this for your chip 
.................... #endif 
....................  
.................... #if defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) 
....................    #reserve 0xE80:0xEFF 
....................    #reserve 0xF00:0xFFF 
.................... #endif 
....................  
.................... #if defined(TRUE) 
....................    #undef TRUE 
.................... #endif 
....................  
.................... #if defined(FALSE) 
....................    #undef FALSE 
.................... #endif 
....................  
.................... #if defined(BYTE) 
....................    #undef BYTE 
.................... #endif 
....................  
....................       #define Reset()            reset_cpu() 
....................         #define far 
....................         #define ClrWdt()         restart_wdt() 
....................       #define Nop()            delay_cycles(1)       
....................  
.................... #define __CCS__ 
....................  
.................... //signed int8 memcmppgm2ram(void * s1, rom char *s2, unsigned int8 n); 
.................... signed int8 strcmppgm2ram(char *s1, __ADDRESS__ s2); 
.................... char *strchrpgm(__ADDRESS__ s, unsigned int8 c); 
.................... char *strstrrampgm(char *s1, __ADDRESS__ s2); 
.................... unsigned int8 strlenpgm(__ADDRESS__ s); 
.................... void memcpypgm2ram(unsigned int8 *d, __ADDRESS__ s, unsigned int16 n); 
.................... //char* strupr(char *s);   now in string.h 
.................... void strcpypgm2ram(char *d, __ADDRESS__ s); 
.................... #endif 
....................  
.................... #elif defined(__PICC18__) && defined(HI_TECH_C)    
....................    // PIC18 processor with (Microchip) HI-TECH PICC-18 compiler 
....................    #if !defined(__18CXX) 
....................       #define __18CXX 
....................    #endif 
....................     #define COMPILER_HITECH_PICC18 
....................    #include <htc.h> 
.................... #elif (defined(__PIC24F__) || defined(__PIC24FK__)) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Fxxxx.h> 
.................... #elif defined(__PIC24H__) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24H processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Hxxxx.h> 
.................... #elif defined(__PIC24E__) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24E processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Exxxx.h> 
.................... #elif defined(__dsPIC33F__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC33F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p33Fxxxx.h> 
.................... #elif defined(__dsPIC33E__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC33E processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p33Exxxx.h> 
.................... #elif defined(__dsPIC30F__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC30F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p30fxxxx.h> 
.................... #elif defined(__C30__)      // Microchip C30 compiler, but targeting "generic-16bit" processor. 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p30sim.h> 
....................    // Define some useful inline assembly functions which are normally in the  
....................    // processor header files, but absent from the generic p30sim.h file. 
....................    #if !defined(Nop) 
....................       #define Nop()    __builtin_nop() 
....................       #define ClrWdt() {__asm__ volatile ("clrwdt");} 
....................       #define Sleep()  {__asm__ volatile ("pwrsav #0");} 
....................       #define Idle()   {__asm__ volatile ("pwrsav #1");} 
....................    #endif 
.................... #elif defined(__PIC32MX__)   // Microchip C32 compiler 
....................    #if !defined(__C32__) 
....................       #define __C32__ 
....................    #endif 
....................     #define COMPILER_MPLAB_C32 
....................    #include <p32xxxx.h> 
....................    #include <plib.h> 
.................... #else 
....................    #error Unknown processor or compiler.  See Compiler.h 
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... // Base RAM and ROM pointer types for given architecture 
.................... #if defined(__PCH__) || defined(__PCD__) 
....................    #define PTR_BASE      unsigned int16 
....................    #define ROM_PTR_BASE   unsigned int32 
.................... #elif defined(__PIC32MX__) 
....................    #define PTR_BASE      unsigned long 
....................    #define ROM_PTR_BASE   unsigned long 
.................... #elif defined(__C30__) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned short 
.................... #elif defined(COMPILER_MPLAB_C18) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned short long 
.................... #elif defined(COMPILER_HITECH_PICC18) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned long 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all except Microchip MPLAB C Compiler for PIC18 MCUs (C18) 
.................... #if !defined(COMPILER_MPLAB_C18) 
....................    #define memcmppgm2ram(a,b,c)   memcmp(a,b,c) 
....................    #define strcmppgm2ram(a,b)      strcmp(a,b) 
....................   #if defined(__PCD__) 
....................    #warning temporary 4.121 fix 
....................    #define memcpypgm2ram(a,b,c)   memcpy(a,b|0x8000,c) 
....................   #else 
....................    #define memcpypgm2ram(a,b,c)   memcpy(a,b,c) 
....................   #endif 
....................    #define strcpypgm2ram(a,b)      strcpy(a,b) 
....................    #define strncpypgm2ram(a,b,c)   strncpy(a,b,c) 
....................    #define strstrrampgm(a,b)      strstr(a,b) 
....................    #define   strlenpgm(a)         strlen(a) 
....................    #define strchrpgm(a,b)         strchr(a,b) 
....................    #define strcatpgm2ram(a,b)      strcat(a,b) 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all 8-bit products 
.................... // (PIC18) 
.................... #if defined(__18CXX) 
....................    #define   __attribute__(a) 
....................  
....................     #define FAR                         far 
....................  
....................    // Microchip C18 specific defines 
....................    #if defined(COMPILER_MPLAB_C18) 
....................        #define ROM                    rom 
....................    #endif 
....................     
....................    // HI TECH PICC-18 specific defines 
....................    #if defined(COMPILER_HITECH_PICC18) 
....................        #define ROM                    const 
....................       #define rom 
....................        #define Nop()                  asm("NOP"); 
....................       #define ClrWdt()            asm("CLRWDT"); 
....................        #define Reset()               asm("RESET"); 
....................    #endif 
....................      
.................... // Definitions that apply to all 16-bit and 32-bit products 
.................... // (PIC24F, PIC24H, dsPIC30F, dsPIC33F, and PIC32) 
.................... #else 
....................    #define   ROM                  const 
....................  
....................    // 16-bit specific defines (PIC24F, PIC24H, dsPIC30F, dsPIC33F) 
....................    #if defined(__C30__) && !defined(__PCD__) 
....................       #define Reset()            asm("reset") 
....................         #define FAR                 __attribute__((far)) 
....................    #endif 
....................  
....................    // 32-bit specific defines (PIC32) 
....................    #if defined(__PIC32MX__) 
....................       #define persistent 
....................       #define far 
....................         #define FAR 
....................       #define Reset()            SoftReset() 
....................       #define ClrWdt()         (WDTCONSET = _WDTCON_WDTCLR_MASK) 
....................  
....................       // MPLAB C Compiler for PIC32 MCUs version 1.04 and below don't have a  
....................       // Nop() function. However, version 1.05 has Nop() declared as _nop(). 
....................       #if !defined(Nop) && (__C32_VERSION__ <= 104) 
....................          #define Nop()            asm("nop") 
....................       #endif 
....................    #endif 
.................... #endif 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "HardwareProfile.h" 
.................... // hardwareprofile.h 
....................  
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #if STACK_USE_CCS_EWLWIFIB || STACK_USE_CCS_EWLWIFIG 
....................  
....................    #bit WF_CS_TRIS1   =     0xF96.1 //E1 
....................    #define WF_CS_TRIS WF_CS_TRIS1 
....................    #bit WF_CS_IO     =  0xF8D.1    //LatE1 
....................    #bit WF_SDI_TRIS  =  0xF94.4    // (TRISCbits.TRISC4) 
....................    #bit WF_SCK_TRIS  =  0xF94.3    // (TRISCbits.TRISC3) 
....................    #bit WF_SDO_TRIS  =  0xF94.5    // (TRISCbits.TRISC5) 
....................    #bit WF_RESET_TRIS=  0xF93.1    //(TRISBbits.TRISB1) 
....................    #bit WF_RESET_IO  =  0xF8A.1     //(LATBbits.LATB1)   
....................    #bit WF_INT_TRIS  =  0xF93.0     // (TRISBbits.TRISB0)  // INT1 
....................    #bit WF_INT_IO    =  0xF81.0   //(PORTBbits.RB0)  
....................    #bit WF_HIBERNATE_TRIS= 0xF93.2  //(TRISBbits.TRISB2)  
....................    #bit   WF_HIBERNATE_IO=  0xF81.2    //(PORTBbits.RB2) 
....................     
....................    #bit WF_INT_EDGE  =  0xFF1.6      //(INTCON2bits.INTEDG0) 
....................    #bit WF_INT_IE    =  0xFF2.4   //(INTCONbits.INT0IE) 
....................    #bit WF_INT_IF    =  0xFF2.1   //(INTCONbits.INT0IF) 
....................    #define WF_SSPBUF  (SSP1BUF) 
....................    #define WF_SPISTAT  (SSP1STATbits) 
....................    #define WF_SPISTATbits SSP1STATbits     //(SSP1STATbits) 
....................    #define WF_SPICON1  (SSP1CON1bits) 
....................    #define WF_SPICON1bits WF_SPICON1    // (SSP1CON1bits) 
....................    #define WF_SPICON2  (SSP1CON2bits) 
....................    #bit WF_SPI_IE    =   0xF9D.3  //(PIE1bits.SSPIE) 
....................    #bit WF_SPI_IP    =   0xF9F.3  //(IPR1bits.SSPIP) 
....................    #bit WF_SPI_IF    =   0xF9E.3  //(PIR1bits.SSPIF) 
....................     
.................... #else 
....................  
.................... //#error define necessary hardware for TCPIP stack 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
.................... /* 
....................    TCPIPConfig.h used by all of CCS's TCP/IP examples. 
....................     
....................    Usually you use a Microchip tool to generate one of these files for 
....................    your projects.  But since we are using this .h for many projects, 
....................    some stuff is conditionally compiled out or commented out, and then 
....................    defined in the application code instead. 
.................... */ 
.................... /********************************************************************* 
....................  * 
....................  *   Microchip TCP/IP Stack Demo Application Configuration Header 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIPConfig.h 
....................  * Dependencies:    Microchip TCP/IP Stack 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.10 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.34 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder      10/04/2006   Original 
....................  * Ken Hesky            07/01/2008  Added ZG2100-specific features 
....................  * SG                   03/25/2009  Added ZGLinkMgrII specific features 
....................  ********************************************************************/ 
.................... #ifndef __TCPIPCONFIG_H 
.................... #define __TCPIPCONFIG_H 
....................  
.................... #include "GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... #ifdef BYTE 
.................... #undef BYTE 
.................... #endif 
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
.................... #include "Compiler.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Compiler and hardware specific definitions 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Compiler.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, PIC24E, dsPIC30F, dsPIC33F,  
....................  *               dsPIC33E, PIC32 
....................  * Compiler:        Microchip C32 v1.00 or higher 
....................  *               Microchip C30 v3.01 or higher 
....................  *               Microchip C18 v3.13 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights  
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and  
....................  * distribute:  
....................  * (i)  the Software when embedded on a Microchip microcontroller or  
....................  *      digital signal controller product ("Device") which is  
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c and  
....................  *      ENC28J60.h ported to a non-Microchip device used in  
....................  *      conjunction with a Microchip ethernet controller for the  
....................  *      sole purpose of interfacing with the ethernet controller.  
....................  * 
....................  * You should refer to the license agreement accompanying this  
....................  * Software for additional information regarding your rights and  
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT  
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT  
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A  
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL  
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR  
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF  
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS  
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER  
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT  
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * 10/03/2006   Original, copied from old Compiler.h 
....................  * 11/07/2007   Reorganized and simplified 
....................  * 03/31/2010   Removed dependency on WORD and DWORD typedefs 
....................  * 04/14/2010   Added defines to uniquely identify each compiler 
....................  ********************************************************************/ 
.................... #ifndef __COMPILER_H 
.................... #define __COMPILER_H 
....................  
.................... // Include proper device header file 
.................... #if defined(__18CXX) && !defined(HI_TECH_C)    
....................    // PIC18 processor with Microchip C18 compiler 
....................     #define COMPILER_MPLAB_C18 
....................     #include <p18cxxx.h> 
.................... #elif defined(__PICC18__) && defined(HI_TECH_C)    
....................    // PIC18 processor with (Microchip) HI-TECH PICC-18 compiler 
....................    #if !defined(__18CXX) 
....................       #define __18CXX 
....................    #endif 
....................     #define COMPILER_HITECH_PICC18 
....................    #include <htc.h> 
.................... #elif (defined(__PIC24F__) || defined(__PIC24FK__)) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Fxxxx.h> 
.................... #elif defined(__PIC24H__) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24H processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Hxxxx.h> 
.................... #elif defined(__PIC24E__) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24E processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Exxxx.h> 
.................... #elif defined(__dsPIC33F__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC33F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p33Fxxxx.h> 
.................... #elif defined(__dsPIC33E__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC33E processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p33Exxxx.h> 
.................... #elif defined(__dsPIC30F__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC30F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p30fxxxx.h> 
.................... #elif defined(__C30__)      // Microchip C30 compiler, but targeting "generic-16bit" processor. 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p30sim.h> 
....................    // Define some useful inline assembly functions which are normally in the  
....................    // processor header files, but absent from the generic p30sim.h file. 
....................    #if !defined(Nop) 
....................       #define Nop()    __builtin_nop() 
....................       #define ClrWdt() {__asm__ volatile ("clrwdt");} 
....................       #define Sleep()  {__asm__ volatile ("pwrsav #0");} 
....................       #define Idle()   {__asm__ volatile ("pwrsav #1");} 
....................    #endif 
.................... #elif defined(__PIC32MX__)   // Microchip C32 compiler 
....................    #if !defined(__C32__) 
....................       #define __C32__ 
....................    #endif 
....................     #define COMPILER_MPLAB_C32 
....................    #include <p32xxxx.h> 
....................    #include <plib.h> 
.................... #else 
....................    #error Unknown processor or compiler.  See Compiler.h 
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... #include <stdlib.h> 
.................... #include <string.h> 
....................  
....................  
.................... // Base RAM and ROM pointer types for given architecture 
.................... #if defined(__PCH__) || defined(__PCD__) 
....................    #define PTR_BASE      unsigned int16 
....................    #define ROM_PTR_BASE   unsigned int32 
.................... #elif defined(__PIC32MX__) 
....................    #define PTR_BASE      unsigned long 
....................    #define ROM_PTR_BASE   unsigned long 
.................... #elif defined(__C30__) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned short 
.................... #elif defined(COMPILER_MPLAB_C18) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned short long 
.................... #elif defined(COMPILER_HITECH_PICC18) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned long 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all except Microchip MPLAB C Compiler for PIC18 MCUs (C18) 
.................... #if !defined(COMPILER_MPLAB_C18) 
....................    #define memcmppgm2ram(a,b,c)   memcmp(a,b,c) 
....................    #define strcmppgm2ram(a,b)      strcmp(a,b) 
....................   #if defined(__PCD__) 
....................    #warning temporary 4.121 fix 
....................    #define memcpypgm2ram(a,b,c)   memcpy(a,b|0x8000,c) 
....................   #else 
....................    #define memcpypgm2ram(a,b,c)   memcpy(a,b,c) 
....................   #endif 
....................    #define strcpypgm2ram(a,b)      strcpy(a,b) 
....................    #define strncpypgm2ram(a,b,c)   strncpy(a,b,c) 
....................    #define strstrrampgm(a,b)      strstr(a,b) 
....................    #define   strlenpgm(a)         strlen(a) 
....................    #define strchrpgm(a,b)         strchr(a,b) 
....................    #define strcatpgm2ram(a,b)      strcat(a,b) 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all 8-bit products 
.................... // (PIC18) 
.................... #if defined(__18CXX) 
....................    #define   __attribute__(a) 
....................  
....................     #define FAR                         far 
....................  
....................    // Microchip C18 specific defines 
....................    #if defined(COMPILER_MPLAB_C18) 
....................        #define ROM                    rom 
....................    #endif 
....................     
....................    // HI TECH PICC-18 specific defines 
....................    #if defined(COMPILER_HITECH_PICC18) 
....................        #define ROM                    const 
....................       #define rom 
....................        #define Nop()                  asm("NOP"); 
....................       #define ClrWdt()            asm("CLRWDT"); 
....................        #define Reset()               asm("RESET"); 
....................    #endif 
....................      
.................... // Definitions that apply to all 16-bit and 32-bit products 
.................... // (PIC24F, PIC24H, dsPIC30F, dsPIC33F, and PIC32) 
.................... #else 
....................    #define   ROM                  const 
....................  
....................    // 16-bit specific defines (PIC24F, PIC24H, dsPIC30F, dsPIC33F) 
....................    #if defined(__C30__) && !defined(__PCD__) 
....................       #define Reset()            asm("reset") 
....................         #define FAR                 __attribute__((far)) 
....................    #endif 
....................  
....................    // 32-bit specific defines (PIC32) 
....................    #if defined(__PIC32MX__) 
....................       #define persistent 
....................       #define far 
....................         #define FAR 
....................       #define Reset()            SoftReset() 
....................       #define ClrWdt()         (WDTCONSET = _WDTCON_WDTCLR_MASK) 
....................  
....................       // MPLAB C Compiler for PIC32 MCUs version 1.04 and below don't have a  
....................       // Nop() function. However, version 1.05 has Nop() declared as _nop(). 
....................       #if !defined(Nop) && (__C32_VERSION__ <= 104) 
....................          #define Nop()            asm("nop") 
....................       #endif 
....................    #endif 
.................... #endif 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... // ======================================================================= 
.................... //   Application Options 
.................... // ======================================================================= 
....................  
.................... /* Application Level Module Selection 
....................  *   Uncomment or comment the following lines to enable or 
....................  *   disabled the following high-level application modules. 
....................  */ 
.................... //#define STACK_USE_UART               // Application demo using UART for IP address display and stack configuration 
.................... //#define STACK_USE_UART2TCP_BRIDGE      // UART to TCP Bridge application example 
.................... //#define STACK_USE_IP_GLEANING 
.................... //#define STACK_USE_ICMP_SERVER         // Ping query and response capability 
.................... //#define STACK_USE_ICMP_CLIENT         // Ping transmission capability 
.................... //#define STACK_USE_HTTP_SERVER         // Old HTTP server 
.................... //#define STACK_USE_HTTP2_SERVER         // New HTTP server with POST, Cookies, Authentication, etc. 
.................... //#define STACK_USE_SSL_SERVER         // SSL server socket support (Requires SW300052) 
.................... //#define STACK_USE_SSL_CLIENT         // SSL client socket support (Requires SW300052) 
.................... //#define STACK_USE_AUTO_IP               // Dynamic link-layer IP address automatic configuration protocol 
.................... //#define STACK_USE_DHCP_CLIENT         // Dynamic Host Configuration Protocol client for obtaining IP address and other parameters 
.................... //#define STACK_USE_DHCP_SERVER         // Single host DHCP server 
.................... //#define STACK_USE_FTP_SERVER         // File Transfer Protocol (old) 
.................... //#define STACK_USE_SMTP_CLIENT         // Simple Mail Transfer Protocol for sending email 
.................... //#define STACK_USE_SNMP_SERVER         // Simple Network Management Protocol v2C Community Agent 
.................... //#define STACK_USE_SNMPV3_SERVER         // Simple Network Management Protocol v3 Agent 
.................... //#define STACK_USE_TFTP_CLIENT         // Trivial File Transfer Protocol client 
.................... //#define STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE   // HTTP Client example in GenericTCPClient.c 
.................... //#define STACK_USE_GENERIC_TCP_SERVER_EXAMPLE   // ToUpper server example in GenericTCPServer.c 
.................... //#define STACK_USE_TELNET_SERVER         // Telnet server 
.................... //#define STACK_USE_ANNOUNCE            // Microchip Embedded Ethernet Device Discoverer server/client 
.................... //#define STACK_USE_DNS               // Domain Name Service Client for resolving hostname strings to IP addresses 
.................... //#define STACK_USE_DNS_SERVER         // Domain Name Service Server for redirection to the local device 
.................... //#define STACK_USE_NBNS               // NetBIOS Name Service Server for repsonding to NBNS hostname broadcast queries 
.................... //#define STACK_USE_REBOOT_SERVER         // Module for resetting this PIC remotely.  Primarily useful for a Bootloader. 
.................... //#define STACK_USE_SNTP_CLIENT         // Simple Network Time Protocol for obtaining current date/time from Internet 
.................... //#define STACK_USE_UDP_PERFORMANCE_TEST   // Module for testing UDP TX performance characteristics.  NOTE: Enabling this will cause a huge amount of UDP broadcast packets to flood your network on the discard port.  Use care when enabling this on production networks, especially with VPNs (could tunnel broadcast traffic across a limited bandwidth connection). 
.................... //#define STACK_USE_TCP_PERFORMANCE_TEST   // Module for testing TCP TX performance characteristics 
.................... //#define STACK_USE_DYNAMICDNS_CLIENT      // Dynamic DNS client updater module 
.................... //#define STACK_USE_BERKELEY_API         // Berekely Sockets APIs are available 
.................... //#define STACK_USE_ZEROCONF_LINK_LOCAL   // Zeroconf IPv4 Link-Local Addressing 
.................... //#define STACK_USE_ZEROCONF_MDNS_SD      // Zeroconf mDNS and mDNS service discovery 
....................  
....................  
.................... // ======================================================================= 
.................... //   Data Storage Options 
.................... // ======================================================================= 
....................  
.................... /* MPFS Configuration 
....................  *   MPFS is automatically included when required for other 
....................  *   applications.  If your custom application requires it 
....................  *   otherwise, uncomment the appropriate selection. 
....................  */ 
.................... //#define STACK_USE_MPFS 
.................... //#define STACK_USE_MPFS2 
....................  
.................... /* MPFS Storage Location 
....................  *   If html pages are stored in internal program memory, 
....................  *   comment both MPFS_USE_EEPROM and MPFS_USE_SPI_FLASH, then 
....................  *   include an MPFS image (.c or .s file) in the project. 
....................  *   If html pages are stored in external memory, uncomment the 
....................  *   appropriate definition. 
....................  * 
....................  *   Supported serial flash parts include the SST25VFxxxB series. 
....................  */ 
.................... //#define MPFS_USE_EEPROM 
.................... //#define MPFS_USE_SPI_FLASH 
....................  
.................... /* EEPROM Addressing Selection 
....................  *   If using the 1Mbit EEPROM, uncomment this line 
....................  */ 
.................... //#define USE_EEPROM_25LC1024 
....................  
.................... /* EEPROM Reserved Area 
....................  *   Number of EEPROM bytes to be reserved before MPFS storage starts. 
....................  *   These bytes host application configurations such as IP Address, 
....................  *   MAC Address, and any other required variables. 
....................  * 
....................  *   For MPFS Classic, this setting must match the Reserved setting 
....................  *    on the Advanced Settings page of the MPFS2 Utility. 
....................  */ 
.................... //#define MPFS_RESERVE_BLOCK            #error do this 
....................  
.................... /* MPFS File Handles 
....................  *   Maximum number of simultaneously open MPFS2 files. 
....................  *   For MPFS Classic, this has no effect. 
....................  */ 
.................... //#define MAX_MPFS_HANDLES            (7ul) 
....................  
....................  
.................... // ======================================================================= 
.................... //   Network Addressing Options 
.................... // ======================================================================= 
....................  
.................... /* Default Network Configuration 
....................  *   These settings are only used if data is not found in EEPROM. 
....................  *   To clear EEPROM, hold BUTTON0, reset the board, and continue 
....................  *   holding until the LEDs flash.  Release, and reset again. 
....................  */ 
.................... #define MY_DEFAULT_HOST_NAME            "CCS_EXAMPLES" 
....................  
.................... /*#define MY_DEFAULT_MAC_BYTE1            (0x00)   // Use the default of 00-04-A3-00-00-00 
.................... #define MY_DEFAULT_MAC_BYTE2            (0x04)   // if using an ENCX24J600, MRF24WB0M, or 
.................... #define MY_DEFAULT_MAC_BYTE3            (0xA3)   // PIC32MX6XX/7XX internal Ethernet  
.................... #define MY_DEFAULT_MAC_BYTE4            (0x00)   // controller and wish to use the  
.................... #define MY_DEFAULT_MAC_BYTE5            (0x00)   // internal factory programmed MAC 
.................... #define MY_DEFAULT_MAC_BYTE6            (0x00)   // address instead. */ 
....................  
.................... #define MY_DEFAULT_MAC_BYTE1            (0x00)   // Use the default of 00-04-A3-00-00-00 
.................... #define MY_DEFAULT_MAC_BYTE2            (0x20)   // if using an ENCX24J600, MRF24WB0M, or 
.................... #define MY_DEFAULT_MAC_BYTE3            (0x30)   // PIC32MX6XX/7XX internal Ethernet  
.................... #define MY_DEFAULT_MAC_BYTE4            (0x40)   // controller and wish to use the  
.................... #define MY_DEFAULT_MAC_BYTE5            (0x50)   // internal factory programmed MAC 
.................... #define MY_DEFAULT_MAC_BYTE6            (0x60)   // address instead. 
....................  
.................... #define MY_DEFAULT_IP_ADDR_BYTE1        (192ul) 
.................... #define MY_DEFAULT_IP_ADDR_BYTE2        (168ul) 
.................... #define MY_DEFAULT_IP_ADDR_BYTE3        (100ul) 
.................... #define MY_DEFAULT_IP_ADDR_BYTE4        (120ul) 
....................  
.................... #define MY_DEFAULT_MASK_BYTE1           (255ul) 
.................... #define MY_DEFAULT_MASK_BYTE2           (255ul) 
.................... #define MY_DEFAULT_MASK_BYTE3           (255ul) 
.................... #define MY_DEFAULT_MASK_BYTE4           (0ul) 
....................  
.................... #define MY_DEFAULT_GATE_BYTE1           (192ul) 
.................... #define MY_DEFAULT_GATE_BYTE2           (168ul) 
.................... #define MY_DEFAULT_GATE_BYTE3           (100ul) 
.................... #define MY_DEFAULT_GATE_BYTE4           (1ul) 
....................  
.................... #define MY_DEFAULT_PRIMARY_DNS_BYTE1   (192ul) 
.................... #define MY_DEFAULT_PRIMARY_DNS_BYTE2   (168ul) 
.................... #define MY_DEFAULT_PRIMARY_DNS_BYTE3   (100ul) 
.................... #define MY_DEFAULT_PRIMARY_DNS_BYTE4   (1ul) 
....................  
.................... #define MY_DEFAULT_SECONDARY_DNS_BYTE1   (0ul) 
.................... #define MY_DEFAULT_SECONDARY_DNS_BYTE2   (0ul) 
.................... #define MY_DEFAULT_SECONDARY_DNS_BYTE3   (0ul) 
.................... #define MY_DEFAULT_SECONDARY_DNS_BYTE4   (0ul) 
....................  
.................... // ======================================================================= 
.................... //   PIC32MX7XX/6XX MAC Layer Options 
.................... //   If not using a PIC32MX7XX/6XX device, ignore this section. 
.................... // ======================================================================= 
.................... /*#define   ETH_CFG_LINK         0      // set to 1 if you need to config the link to specific following parameters 
....................                               // otherwise the default connection will be attempted 
....................                               // depending on the selected PHY 
....................    #define   ETH_CFG_AUTO      1      // use auto negotiation 
....................    #define   ETH_CFG_10         1      // use/advertise 10 Mbps capability 
....................    #define   ETH_CFG_100         1      // use/advertise 100 Mbps capability 
....................    #define   ETH_CFG_HDUPLEX      1      // use/advertise half duplex capability 
....................    #define   ETH_CFG_FDUPLEX      1      // use/advertise full duplex capability 
....................    #define   ETH_CFG_AUTO_MDIX   1      // use/advertise auto MDIX capability 
....................    #define   ETH_CFG_SWAP_MDIX   1      // use swapped MDIX. else normal MDIX 
....................  
.................... #define EMAC_TX_DESCRIPTORS      2      // number of the TX descriptors to be created 
.................... #define EMAC_RX_DESCRIPTORS      8      // number of the RX descriptors and RX buffers to be created 
....................  
.................... #define   EMAC_RX_BUFF_SIZE      1536   // size of a RX buffer. should be multiple of 16 
....................                               // this is the size of all receive buffers processed by the ETHC 
....................                               // The size should be enough to accomodate any network received packet 
....................                               // If the packets are larger, they will have to take multiple RX buffers 
....................                               // The current implementation does not handle this situation right now and the packet is discarded. 
.................... */ 
....................  
.................... // ======================================================================= 
.................... //   Transport Layer Options 
.................... // ======================================================================= 
....................  
.................... /* Transport Layer Configuration 
....................  *   The following low level modules are automatically enabled 
....................  *   based on module selections above.  If your custom module 
....................  *   requires them otherwise, enable them here. 
....................  */ 
.................... //#define STACK_USE_TCP 
.................... //#define STACK_USE_UDP 
....................  
.................... /* Client Mode Configuration 
....................  *   Uncomment following line if this stack will be used in CLIENT 
....................  *   mode.  In CLIENT mode, some functions specific to client operation 
....................  *   are enabled. 
....................  */ 
.................... #define STACK_CLIENT_MODE 
....................  
.................... /* TCP Socket Memory Allocation 
....................  *   TCP needs memory to buffer incoming and outgoing data.  The 
....................  *   amount and medium of storage can be allocated on a per-socket 
....................  *   basis using the example below as a guide. 
....................  */ 
....................    // Allocate how much total RAM (in bytes) you want to allocate 
....................    // for use by your TCP TCBs, RX FIFOs, and TX FIFOs. 
....................   #ifndef TCP_ETH_RAM_SIZE 
....................    #define TCP_ETH_RAM_SIZE                 (8192ul) 
....................   #endif 
....................    #define TCP_PIC_RAM_SIZE                 (0ul) 
....................    #define TCP_SPI_RAM_SIZE                 (0ul) 
....................    #define TCP_SPI_RAM_BASE_ADDRESS         (0x00) 
....................  
....................    // Define names of socket types 
....................    #define TCP_SOCKET_TYPES 
....................       #define TCP_PURPOSE_GENERIC_TCP_CLIENT 0 
....................       #define TCP_PURPOSE_GENERIC_TCP_SERVER 1 
....................       #define TCP_PURPOSE_TELNET 2 
....................       #define TCP_PURPOSE_FTP_COMMAND 3 
....................       #define TCP_PURPOSE_FTP_DATA 4 
....................       #define TCP_PURPOSE_TCP_PERFORMANCE_TX 5 
....................       #define TCP_PURPOSE_TCP_PERFORMANCE_RX 6 
....................       #define TCP_PURPOSE_UART_2_TCP_BRIDGE 7 
....................       #define TCP_PURPOSE_HTTP_SERVER 8 
....................       #define TCP_PURPOSE_DEFAULT 9 
....................       #define TCP_PURPOSE_BERKELEY_SERVER 10 
....................       #define TCP_PURPOSE_BERKELEY_CLIENT 11 
....................    #define END_OF_TCP_SOCKET_TYPES 
....................  
....................    //changed the check here because it was set up for linking, not static compiling 
....................       typedef struct 
....................       { 
....................          BYTE vSocketPurpose; 
....................          BYTE vMemoryMedium; 
....................          WORD wTXBufferSize; 
....................          WORD wRXBufferSize;       
....................       } TCPSocketInitializer_t; 
....................      #if defined(STACK_USE_TCP) && defined(TCP_CONFIGURATION) 
....................       //ccs bug, wouldn't let me extern empty brace 
....................       extern TCPSocketInitializer_t TCPSocketInitializer[TCP_CONFIGURATION]; 
....................      #endif 
....................    #if defined(STACK_USE_TCP) && !defined(TCP_CONFIGURATION) 
....................       // Define what types of sockets are needed, how many of 
....................       // each to include, where their TCB, TX FIFO, and RX FIFO 
....................       // should be stored, and how big the RX and TX FIFOs should 
....................       // be.  Making this initializer bigger or smaller defines 
....................       // how many total TCP sockets are available. 
....................       // 
....................       // Each socket requires up to 56 bytes of PIC RAM and 
....................       // 48+(TX FIFO size)+(RX FIFO size) bytes of TCP_*_RAM each. 
....................       // 
....................       // Note: The RX FIFO must be at least 1 byte in order to 
....................       // receive SYN and FIN messages required by TCP.  The TX 
....................       // FIFO can be zero if desired. 
....................       #define TCP_CONFIGURATION  1 
....................       //REMOVED ROM prefix -Tim 
....................       TCPSocketInitializer_t TCPSocketInitializer[TCP_CONFIGURATION] = 
....................       { 
....................           {TCP_PURPOSE_DEFAULT, TCP_ETH_RAM, 250, 250} 
....................       }; 
....................       #define END_OF_TCP_CONFIGURATION 
....................    #endif  
....................  
.................... #ifndef MAX_HTTP_CONNECTIONS 
....................    #define  MAX_HTTP_CONNECTIONS 1 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
....................    #define MAX_UDP_SOCKETS 7 
.................... #endif    
....................     
.................... /* UDP Socket Configuration 
....................  *   Define the maximum number of available UDP Sockets, and whether 
....................  *   or not to include a checksum on packets being transmitted. 
....................  */ 
.................... //#define MAX_UDP_SOCKETS           
.................... //#define UDP_USE_TX_CHECKSUM      // This slows UDP TX performance by nearly 50%, except when using the ENCX24J600 or PIC32MX6XX/7XX, which have a super fast DMA and incurs virtually no speed pentalty. 
....................  
....................  
.................... /* Berkeley API Sockets Configuration 
....................  *   Note that each Berkeley socket internally uses one TCP or UDP socket 
....................  *   defined by MAX_UDP_SOCKETS and the TCPSocketInitializer[] array. 
....................  *   Therefore, this number MUST be less than or equal to MAX_UDP_SOCKETS + the 
....................  *   number of TCP sockets defined by the TCPSocketInitializer[] array 
....................  *   (i.e. sizeof(TCPSocketInitializer)/sizeof(TCPSocketInitializer[0])). 
....................  *   This define has no effect if STACK_USE_BERKELEY_API is not defined and 
....................  *   Berkeley Sockets are disabled.  Set this value as low as your application 
....................  *   requires to avoid waisting RAM. 
....................  */ 
.................... //#define BSD_SOCKET_COUNT (5u) 
....................  
....................  
.................... // ======================================================================= 
.................... //   Application-Specific Options 
.................... // ======================================================================= 
....................  
.................... // -- HTTP2 Server options ----------------------------------------------- 
....................  
....................    // Maximum numbers of simultaneous HTTP connections allowed. 
....................    // Each connection consumes 2 bytes of RAM and a TCP socket 
....................    //#define MAX_HTTP_CONNECTIONS   (2u) 
....................  
....................    // Optional setting to use PIC RAM instead of Ethernet/Wi-Fi RAM for 
....................    // storing HTTP Connection Context variables (HTTP_CONN structure for each  
....................    // HTTP connection).  Undefining this macro results in the Ethernet/Wi-Fi  
....................    // RAM being used (minimum PIC RAM usage, lower performance).  Defining  
....................    // this macro results in PIC RAM getting used (higher performance, but uses  
....................    // PIC RAM).  This option should not be enabled on PIC18 devices.  The  
....................    // performance increase of having this option defined is only apparent when  
....................    // the HTTP server is servicing multiple connections simultaneously. 
....................    //#define HTTP_SAVE_CONTEXT_IN_PIC_RAM 
....................  
....................    // Indicate what file to serve when no specific one is requested 
....................    //#define HTTP_DEFAULT_FILE      "index.htm" 
....................    //#define HTTPS_DEFAULT_FILE      "index.htm" 
....................    //#define HTTP_DEFAULT_LEN      (10u)      // For buffer overrun protection. 
....................                                     // Set to longest length of above two strings. 
....................  
....................    // Configure MPFS over HTTP updating 
....................    // Comment this line to disable updating via HTTP 
....................    //#define HTTP_MPFS_UPLOAD      "mpfsupload" 
....................    //#define HTTP_MPFS_UPLOAD_REQUIRES_AUTH   // Require password for MPFS uploads 
....................       // Certain firewall and router combinations cause the MPFS2 Utility to fail 
....................       // when uploading.  If this happens, comment out this definition. 
....................  
....................    // Define which HTTP modules to use 
....................    // If not using a specific module, comment it to save resources 
....................    //#define HTTP_USE_POST               // Enable POST support 
....................    //#define HTTP_USE_COOKIES            // Enable cookie support 
....................    //#define HTTP_USE_AUTHENTICATION         // Enable basic authentication support 
....................  
....................    //#define HTTP_NO_AUTH_WITHOUT_SSL      // Uncomment to require SSL before requesting a password 
....................  
....................     // Define the listening port for the HTTP server 
....................      //#define HTTP_PORT               (80u) 
....................     
....................     // Define the listening port for the HTTPS server (if STACK_USE_SSL_SERVER is enabled) 
....................    //#define HTTPS_PORT            (443u) 
....................     
....................     // Define the maximum data length for reading cookie and GET/POST arguments (bytes) 
....................    //#define HTTP_MAX_DATA_LEN      (%HTTP_MAX_DATA_LEN%) 
....................     
....................     // Define the minimum number of bytes free in the TX FIFO before executing callbacks 
....................    //#define HTTP_MIN_CALLBACK_FREE   (16u) 
.................... // -- SSL Options -------------------------------------------------------- 
....................  
....................    //#define MAX_SSL_CONNECTIONS      (2ul)   // Maximum connections via SSL 
....................    //#define MAX_SSL_SESSIONS      (2ul)   // Max # of cached SSL sessions 
....................    //#define MAX_SSL_BUFFERS         (4ul)   // Max # of SSL buffers (2 per socket) 
....................    //#define MAX_SSL_HASHES         (5ul)   // Max # of SSL hashes  (2 per, plus 1 to avoid deadlock) 
....................  
....................    // Bits in SSL RSA key.  This parameter is used for SSL sever 
....................    // connections only.  The only valid value is 512 bits (768 and 1024 
....................    // bits do not work at this time).  Note, however, that SSL client 
....................    // operations do currently work up to 1024 bit RSA key length. 
....................    #define SSL_RSA_KEY_SIZE      (512ul) 
....................  
....................  
.................... // -- Telnet Options ----------------------------------------------------- 
....................  
....................    // Number of simultaneously allowed Telnet sessions.  Note that you 
....................    // must have an equal number of TCP_PURPOSE_TELNET type TCP sockets 
....................    // declared in the TCPSocketInitializer[] array above for multiple 
....................    // connections to work.  If fewer sockets are available than this 
....................    // definition, then the the lesser of the two quantities will be the 
....................    // actual limit. 
....................    //#define MAX_TELNET_CONNECTIONS   (1u) 
....................  
....................    // Default local listening port for the Telnet server.  Port 23 is the 
....................    // protocol default. 
....................    //#define TELNET_PORT            23 
....................  
....................    // Default local listening port for the Telnet server when SSL secured. 
....................    // Port 992 is the telnets protocol default. 
....................    //#define TELNETS_PORT         992 
....................  
....................    // Force all connecting clients to be SSL secured and connected via 
....................    // TELNETS_PORT.  Connections on port TELNET_PORT will be ignored.  If 
....................    // STACK_USE_SSL_SERVER is undefined, this entire setting is ignored 
....................    // (server will accept unsecured connections on TELNET_PORT and won't even 
....................    // listen on TELNETS_PORT). 
....................    //#define TELNET_REJECT_UNSECURED 
....................  
....................    // Default username and password required to login to the Telnet server. 
....................    //#define TELNET_USERNAME         "admin" 
....................    //#define TELNET_PASSWORD         "microchip" 
....................  
....................  
.................... // -- SNMP Options ------------------------------------------------------- 
....................  
....................    // Comment following line if SNMP TRAP support is needed 
....................    //#define SNMP_TRAP_DISABLED 
....................  
....................    //#define SNMP_STACK_USE_V2_TRAP 
....................    #if defined(STACK_USE_SNMPV3_SERVER) 
....................       #define SNMP_V1_V2_TRAP_WITH_SNMPV3 
....................    #endif 
....................  
....................    // This is the maximum length for community string. 
....................    // Application must ensure that this length is observed. 
....................    // SNMP module adds one byte extra after SNMP_COMMUNITY_MAX_LEN 
....................    // for adding '\0' NULL character. 
....................    //#define SNMP_COMMUNITY_MAX_LEN     (8u) 
....................    //#define SNMP_MAX_COMMUNITY_SUPPORT   (3u) 
....................    //#define NOTIFY_COMMUNITY_LEN      (SNMP_COMMUNITY_MAX_LEN) 
....................  
....................    // Default SNMPv2C community names.  These can be overridden at run time if 
....................    // alternate strings are present in external EEPROM or Flash (actual 
....................    // strings are stored in AppConfig.readCommunity[] and 
....................    // AppConfig.writeCommunity[] arrays).  These strings are case sensitive. 
....................    // An empty string means disabled (not matchable). 
....................    // For application security, these default community names should not be 
....................    // used, but should all be disabled to force the end user to select unique 
....................    // community names.  These defaults are provided only to make it easier to 
....................    // start development.  Specifying more strings than 
....................    // SNMP_MAX_COMMUNITY_SUPPORT will result in the later strings being 
....................    // ignored (but still wasting program memory).  Specifying fewer strings is 
....................    // legal, as long as at least one is present.  A string larger than 
....................    // SNMP_COMMUNITY_MAX_LEN bytes will be ignored. 
....................    //#define SNMP_READ_COMMUNITIES      {"public", "read", ""} 
....................    //#define END_OF_SNMP_READ_COMMUNITIES 
....................    //#define SNMP_WRITE_COMMUNITIES        {"private", "write", "public"} 
....................    //#define END_OF_SNMP_WRITE_COMMUNITIES 
.................... #endif 
....................  
....................  
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definitions 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    Compiler.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,  
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,  
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook/CCS      WIFI networkType added to AppConfig, hopefully 
....................  *                         this doesn't conflict with EZ_CONFIG_STORE.  
....................  *                      WIFI adhocBehavior added to AppConfig. 
....................  ********************************************************************/ 
.................... #ifndef __STACK_TSK_H 
.................... #define __STACK_TSK_H 
....................  
.................... #if defined (WF_CS_TRIS) 
....................     #include "WF_Config.h"      
.................... #endif 
....................  
.................... // Check for potential configuration errors in "TCPIPConfig.h" 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 ) 
.................... #error Invalid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... // Check for potential configuration errors in "TCPIPConfig.h" 
.................... #if (MAX_HTTP_CONNECTIONS <= 0 || MAX_HTTP_CONNECTIONS > 255 ) 
.................... #error Invalid MAX_HTTP_CONNECTIONS value specified. 
.................... #endif 
....................  
.................... // Structure to contain a MAC address 
.................... typedef struct __attribute__((__packed__)) 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... // Definition to represent an IP address 
.................... #define IP_ADDR      DWORD_VAL 
....................  
.................... // Address structure for a node 
.................... typedef struct __attribute__((__packed__)) 
.................... { 
....................     IP_ADDR     IPAddr; 
....................     MAC_ADDR    MACAddr; 
.................... } NODE_INFO; 
....................  
.................... // Application-dependent structure used to contain address information 
.................... typedef struct __attribute__((__packed__)) appConfigStruct  
.................... { 
....................    IP_ADDR      MyIPAddr;               // IP address 
....................    IP_ADDR      MyMask;                 // Subnet mask 
....................    IP_ADDR      MyGateway;              // Default Gateway 
....................    IP_ADDR      PrimaryDNSServer;       // Primary DNS Server 
....................    IP_ADDR      SecondaryDNSServer;     // Secondary DNS Server 
....................    IP_ADDR      DefaultIPAddr;          // Default IP address 
....................    IP_ADDR      DefaultMask;            // Default subnet mask 
....................    BYTE      NetBIOSName[16];        // NetBIOS name 
....................    struct 
....................    { 
....................       unsigned char : 6; 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    } Flags;                            // Flag structure 
....................    MAC_ADDR   MyMACAddr;              // Application MAC address 
....................  
.................... #if defined(WF_CS_TRIS) 
....................    BYTE      MySSID[32];             // Wireless SSID (if using MRF24W) 
....................    BYTE        SsidLength;             // number of bytes in SSID 
....................    BYTE        SecurityMode;           // WF_SECURITY_OPEN or one of the other security modes 
....................    BYTE        SecurityKey[64];        // WiFi Security key, or passphrase.    
....................    BYTE        SecurityKeyLength;      // number of bytes in security key (can be 0) 
....................    BYTE        WepKeyIndex;            // WEP key index (only valid for WEP) 
....................    BYTE        networkType; 
....................    BYTE        adhocBehavior; 
....................     #if defined(EZ_CONFIG_STORE) // WLAN configuration data stored to NVM 
....................     BYTE        dataValid; 
....................     //BYTE        networkType; 
....................     BYTE        saveSecurityInfo;       // Save 32-byte PSK 
....................     #endif 
.................... #endif 
....................     
.................... #if defined(STACK_USE_SNMP_SERVER) || defined(STACK_USE_SNMPV3_SERVER) 
....................    // SNMPv2C Read community names 
....................    // SNMP_COMMUNITY_MAX_LEN (8) + 1 null termination byte 
....................    BYTE readCommunity[SNMP_MAX_COMMUNITY_SUPPORT][SNMP_COMMUNITY_MAX_LEN+1];  
....................  
....................    // SNMPv2C Write community names 
....................    // SNMP_COMMUNITY_MAX_LEN (8) + 1 null termination byte 
....................    BYTE writeCommunity[SNMP_MAX_COMMUNITY_SUPPORT][SNMP_COMMUNITY_MAX_LEN+1]; 
....................  
....................    UINT32 SnmpEngineBootRcrd; 
.................... #endif 
....................  
.................... } APP_CONFIG; 
....................  
.................... #ifndef THIS_IS_STACK_APPLICATION 
....................     extern APP_CONFIG AppConfig; 
.................... #endif 
....................  
....................  
.................... void StackInit(void); 
.................... void StackTask(void); 
.................... void StackApplications(void); 
.................... #endif 
....................  
.................... #include "TCPIP Stack/Helpers.h" 
.................... /********************************************************************* 
....................  Header file for Helpers.c 
....................   
....................  FileName:      Helpers.h 
....................  Dependencies:  See INCLUDES section 
....................  Processor:     PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:      Microchip C18, C30, C32 
....................  Company:       Microchip Technology, Inc. 
....................  
....................  Software License Agreement 
....................  
....................  Copyright (C) 2002-2011 Microchip Technology Inc.  All rights 
....................  reserved. 
....................  
....................  Microchip licenses to you the right to use, modify, copy, and 
....................  distribute: 
....................  (i)  the Software when embedded on a Microchip microcontroller or 
....................       digital signal controller product ("Device") which is 
....................       integrated into Licensee's product; or 
....................  (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
.................... 		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
.................... 		used in conjunction with a Microchip ethernet controller for 
.................... 		the sole purpose of interfacing with the ethernet controller. 
....................  
....................  You should refer to the license agreement accompanying this 
....................  Software for additional information regarding your rights and 
....................  obligations. 
....................  
....................  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  
....................  ******************************************************************** 
....................  File Description: 
....................   
....................  Change History: 
....................   
....................   Rev         Description 
....................   ----------  ------------------------------------------------------- 
....................   1.0 - 5.31  Initial release 
....................   5.36        Updated compile time check for ultoa(); 
....................  ********************************************************************/ 
.................... #ifndef __HELPERS_H 
.................... #define __HELPERS_H 
....................  
....................  
.................... #if !defined(__18CXX) || defined(HI_TECH_C) 
.................... 	char *strupr(char* s); 
.................... #endif 
....................  
.................... // Implement consistent ultoa() function 
.................... #if (defined(__PIC32MX__) && (__C32_VERSION__ < 112)) || (defined (__C30__) && (__C30_VERSION__ < 325)) || defined(__C30_LEGACY_LIBC__) || defined(__C32_LEGACY_LIBC__) 
.................... 	// C32 < 1.12 and C30 < v3.25 need this 2 parameter stack implemented function 
.................... 	void ultoa(DWORD Value, BYTE* Buffer); 
.................... #elif defined(__18CXX) && !defined(HI_TECH_C) 
.................... 	// C18 already has a 2 parameter ultoa() function 
.................... 	#include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #else 
.................... 	// HI-TECH PICC-18 PRO 9.63, C30 v3.25+, and C32 v1.12+ already have a ultoa() stdlib  
.................... 	// library function, but it requires 3 parameters.  The TCP/IP Stack  
.................... 	// assumes the C18 style 2 parameter ultoa() function, so we shall  
.................... 	// create a macro to automatically convert the code. 
.................... 	#include <stdlib.h> 
.................... 	#define ultoa(val,buf)	ultoa((char*)(buf),(val),10) 
.................... #endif 
....................  
.................... #if defined(DEBUG) 
.................... 	#define DebugPrint(a)	{putrsUART(a);} 
.................... #else 
.................... 	#define DebugPrint(a) 
.................... #endif 
....................  
.................... DWORD	LFSRSeedRand(DWORD dwSeed); 
.................... WORD	LFSRRand(void); 
.................... DWORD	GenerateRandomDWORD(void); 
.................... void 	uitoa(WORD Value, BYTE* Buffer); 
.................... void 	UnencodeURL(BYTE* URL); 
.................... WORD 	Base64Decode(BYTE* cSourceData, WORD wSourceLen, BYTE* cDestData, WORD wDestLen); 
.................... WORD	Base64Encode(BYTE* cSourceData, WORD wSourceLen, BYTE* cDestData, WORD wDestLen); 
.................... BOOL	StringToIPAddress(BYTE* str, IP_ADDR* IPAddress); 
.................... BYTE 	ReadStringUART(BYTE* Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
.................... signed char stricmppgm2ram(BYTE* a, ROM BYTE* b); 
.................... char * 	strnchr(const char *searchString, size_t count, char c); 
.................... size_t  strncpy_m(char* destStr, size_t destSize, int nStrings, ...); 
....................  
.................... #if defined(__18CXX) 
.................... 	BOOL	ROMStringToIPAddress(ROM BYTE* str, IP_ADDR* IPAddress); 
.................... #else 
.................... 	// Non-ROM variant for C30 and C32 
.................... 	#define ROMStringToIPAddress(a,b)	StringToIPAddress((BYTE*)a,b) 
.................... #endif 
....................  
....................  
.................... WORD    swaps(WORD v); 
....................  
.................... #if defined(__C32__) 
.................... DWORD   __attribute__((nomips16)) swapl(DWORD v); 
.................... #else 
.................... DWORD   swapl(DWORD v); 
.................... #endif 
....................  
.................... WORD    CalcIPChecksum(BYTE* buffer, WORD len); 
....................  
....................  
.................... #if defined(__18CXX) 
.................... 	DWORD leftRotateDWORD(DWORD val, BYTE bits); 
.................... #else 
.................... 	// Rotations are more efficient in C30 and C32 
.................... 	#define leftRotateDWORD(x, n) (((x) << (n)) | ((x) >> (32-(n)))) 
.................... #endif 
....................  
.................... void FormatNetBIOSName(BYTE Name[16]); 
....................  
....................  
.................... // Protocols understood by the ExtractURLFields() function.  IMPORTANT: If you  
.................... // need to reorder these (change their constant values), you must also reorder  
.................... // the constant arrays in ExtractURLFields(). 
.................... typedef enum 
.................... { 
.................... 	PROTOCOL_HTTP = 0u, 
.................... 	PROTOCOL_HTTPS, 
.................... 	PROTOCOL_MMS, 
.................... 	PROTOCOL_RTSP 
.................... } PROTOCOLS; 
....................  
.................... BYTE ExtractURLFields(BYTE *vURL, PROTOCOLS *protocol, BYTE *vUsername, WORD *wUsernameLen, BYTE *vPassword, WORD *wPasswordLen, BYTE *vHostname, WORD *wHostnameLen, WORD *wPort, BYTE *vFilePath, WORD *wFilePathLen); 
.................... SHORT Replace(BYTE *vExpression, ROM BYTE *vFind, ROM BYTE *vReplacement, WORD wMaxLen, BOOL bSearchCaseInsensitive); 
....................  
.................... #endif 
....................  
.................... #include "TCPIP Stack/Delay.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  General Delay rouines 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Delay.h 
....................  * Dependencies:    Compiler.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/9/02  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     6/10/02 Fixed C18 ms and us routines 
....................  * Howard Schlunder		4/04/06	Changed for C30 
....................  ********************************************************************/ 
.................... #ifndef __DELAY_H 
.................... #define __DELAY_H 
....................  
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
.................... #if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 	#include <delays.h> 
.................... #endif 
....................  
.................... #if !defined(GetInstructionClock) 
.................... 	#error GetInstructionClock() must be defined. 
.................... #endif 
....................  
.................... #if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 	#define Delay10us(us)		Delay10TCYx(((GetInstructionClock()/1000000)*(us))) 
.................... 	#define DelayMs(ms)												\ 
.................... 	do																\ 
.................... 	{																\ 
.................... 		unsigned int _iTemp = (ms); 								\ 
.................... 		while(_iTemp--)												\ 
.................... 			Delay1KTCYx((GetInstructionClock()+999999)/1000000);	\ 
.................... 	} while(0) 
....................  
.................... #elif defined(__C30__) || defined(__C32__) 
.................... 	void Delay10us(DWORD dwCount); 
.................... 	void DelayMs(WORD ms); 
....................  
.................... #else 
.................... 	#define Delay10us(x)			\ 
.................... 	do 								\ 
.................... 	{								\ 
.................... 		unsigned long _dcnt;		\ 
.................... 		_dcnt=x*((unsigned long)(0.00001/(1.0/GetInstructionClock())/6));	\ 
.................... 		while(_dcnt--);				\ 
.................... 	} while(0) 
.................... 	void DelayMs(WORD ms); 
.................... #endif 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "TCPIP Stack/Tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  ********************************************************************/ 
.................... #ifndef __TICK_H 
.................... #define __TICK_H 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... // All TICKS are stored as 32-bit unsigned integers. 
.................... // This is deprecated since it conflicts with other TICK definitions used in  
.................... // other Microchip software libraries and therefore poses a merge and maintence  
.................... // problem.  Instead of using the TICK data type, just use the base DWORD data  
.................... // type instead. 
.................... typedef __attribute__((__deprecated__)) DWORD TICK; 
....................  
.................... // This value is used by TCP and other modules to implement timeout actions. 
.................... // For this definition, the Timer must be initialized to use a 1:256 prescalar  
.................... // in Tick.c.  If using a 32kHz watch crystal as the time base, modify the  
.................... // Tick.c file to use no prescalar. 
.................... #define TICKS_PER_SECOND		((GetPeripheralClock()+128ull)/256ull)	// Internal core clock drives timer with 1:256 prescaler 
.................... //#define TICKS_PER_SECOND		(32768ul)								// 32kHz crystal drives timer with no scalar 
....................  
.................... // Represents one second in Ticks 
.................... #define TICK_SECOND				((QWORD)TICKS_PER_SECOND) 
.................... // Represents one minute in Ticks 
.................... #define TICK_MINUTE				((QWORD)TICKS_PER_SECOND*60ull) 
.................... // Represents one hour in Ticks 
.................... #define TICK_HOUR				((QWORD)TICKS_PER_SECOND*3600ull) 
....................  
....................  
.................... void TickInit(void); 
.................... DWORD TickGet(void); 
.................... DWORD TickGetDiv256(void); 
.................... DWORD TickGetDiv64K(void); 
.................... DWORD TickConvertToMilliseconds(DWORD dwTickValue); 
.................... void TickUpdate(void); 
....................  
.................... #endif 
....................  
.................... #include "TCPIP Stack/MAC.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  ********************************************************************/ 
.................... #ifndef __MAC_H 
.................... #define __MAC_H 
....................  
.................... #include "HardwareProfile.h" 
.................... // hardwareprofile.h 
....................  
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #if STACK_USE_CCS_EWLWIFIB || STACK_USE_CCS_EWLWIFIG 
....................  
....................    #bit WF_CS_TRIS1   =     0xF96.1 //E1 
....................    #define WF_CS_TRIS WF_CS_TRIS1 
....................    #bit WF_CS_IO     =  0xF8D.1    //LatE1 
....................    #bit WF_SDI_TRIS  =  0xF94.4    // (TRISCbits.TRISC4) 
....................    #bit WF_SCK_TRIS  =  0xF94.3    // (TRISCbits.TRISC3) 
....................    #bit WF_SDO_TRIS  =  0xF94.5    // (TRISCbits.TRISC5) 
....................    #bit WF_RESET_TRIS=  0xF93.1    //(TRISBbits.TRISB1) 
....................    #bit WF_RESET_IO  =  0xF8A.1     //(LATBbits.LATB1)   
....................    #bit WF_INT_TRIS  =  0xF93.0     // (TRISBbits.TRISB0)  // INT1 
....................    #bit WF_INT_IO    =  0xF81.0   //(PORTBbits.RB0)  
....................    #bit WF_HIBERNATE_TRIS= 0xF93.2  //(TRISBbits.TRISB2)  
....................    #bit   WF_HIBERNATE_IO=  0xF81.2    //(PORTBbits.RB2) 
....................     
....................    #bit WF_INT_EDGE  =  0xFF1.6      //(INTCON2bits.INTEDG0) 
....................    #bit WF_INT_IE    =  0xFF2.4   //(INTCONbits.INT0IE) 
....................    #bit WF_INT_IF    =  0xFF2.1   //(INTCONbits.INT0IF) 
....................    #define WF_SSPBUF  (SSP1BUF) 
....................    #define WF_SPISTAT  (SSP1STATbits) 
....................    #define WF_SPISTATbits SSP1STATbits     //(SSP1STATbits) 
....................    #define WF_SPICON1  (SSP1CON1bits) 
....................    #define WF_SPICON1bits WF_SPICON1    // (SSP1CON1bits) 
....................    #define WF_SPICON2  (SSP1CON2bits) 
....................    #bit WF_SPI_IE    =   0xF9D.3  //(PIE1bits.SSPIE) 
....................    #bit WF_SPI_IP    =   0xF9F.3  //(IPR1bits.SSPIP) 
....................    #bit WF_SPI_IF    =   0xF9E.3  //(PIR1bits.SSPIF) 
....................     
.................... #else 
....................  
.................... //#error define necessary hardware for TCPIP stack 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #if defined(WF_CS_TRIS) 
....................    // Do not use the DMA and other goodies that Microchip Ethernet modules have 
....................    #define NON_MCHP_MAC 
.................... #endif 
....................  
.................... #if defined(ENC_CS_TRIS) && defined(WF_CS_TRIS) 
....................    #error "Error in HardwareProfile.h.  Must select either the ENC28J60 or the MRF24WB10 but not both ENC_CS_TRIS and WF_CS_TRIS." 
.................... #endif 
.................... #if defined(ENC100_INTERFACE_MODE) && defined(WF_CS_TRIS) 
....................    #error "Error in HardwareProfile.h.  Must select either the ENCX24J600 or the MRF24WB10 but not both ENC100_INTERFACE_MODE and WF_CS_TRIS." 
.................... #endif 
.................... #if defined(ENC100_INTERFACE_MODE) && defined(ENC_CS_TRIS) 
....................    #error "Error in HardwareProfile.h.  Must select either the ENC28J60 or the ENCX24J600 but not both ENC_CS_TRIS and ENC100_INTERFACE_MODE." 
.................... #endif 
....................  
....................  
....................  
.................... #if !defined(ENC_CS_TRIS) && !defined(WF_CS_TRIS) && !defined(ENC100_INTERFACE_MODE) && \ 
....................     (defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) || \ 
....................      defined(_18F97J60) ||  defined(_18F96J65) ||  defined(_18F96J60) ||  defined(_18F87J60) ||  defined(_18F86J65) ||  defined(_18F86J60) ||  defined(_18F67J60) ||  defined(_18F66J65) ||  defined(_18F66J60)) 
....................    #include "TCPIP Stack/ETH97J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            Ethernet registers/bits for PIC18F97J60 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ETH97J60.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18F97J60 Family 
....................  * Compiler:        Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/12/05	Modified for 97J60 (from ENC28J60) 
....................  * Howard Schlunder		03/23/06	Updated for Advance Data Sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3_PHDRLEN to MACON3_PHDREN 
....................  * Howard Schlunder		09/13/06	Removed a lot of bits for  
....................  *									preliminary data sheet, added RXAPDIS 
....................  ********************************************************************/ 
....................  
.................... #ifndef __ETH97J60_H 
.................... #define __ETH97J60_H 
.................... #include "GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... #ifdef BYTE 
.................... #undef BYTE 
.................... #endif 
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		WORD	 ByteCount; 
.................... 		unsigned CollisionCount:4; 
.................... 		unsigned CRCError:1; 
.................... 		unsigned LengthCheckError:1; 
.................... 		unsigned LengthOutOfRange:1; 
.................... 		unsigned Done:1; 
.................... 		unsigned Multicast:1; 
.................... 		unsigned Broadcast:1; 
.................... 		unsigned PacketDefer:1; 
.................... 		unsigned ExcessiveDefer:1; 
.................... 		unsigned MaximumCollisions:1; 
.................... 		unsigned LateCollision:1; 
.................... 		unsigned Giant:1; 
.................... 		unsigned Underrun:1; 
.................... 		WORD 	 BytesTransmittedOnWire; 
.................... 		unsigned ControlFrame:1; 
.................... 		unsigned PAUSEControlFrame:1; 
.................... 		unsigned BackpressureApplied:1; 
.................... 		unsigned VLANTaggedFrame:1; 
.................... 		unsigned Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	BYTE v[4]; 
.................... 	struct { 
.................... 		WORD	 ByteCount; 
.................... 		unsigned PreviouslyIgnored:1; 
.................... 		unsigned RXDCPreviouslySeen:1; 
.................... 		unsigned CarrierPreviouslySeen:1; 
.................... 		unsigned CodeViolation:1; 
.................... 		unsigned CRCError:1; 
.................... 		unsigned LengthCheckError:1; 
.................... 		unsigned LengthOutOfRange:1; 
.................... 		unsigned ReceiveOk:1; 
.................... 		unsigned Multicast:1; 
.................... 		unsigned Broadcast:1; 
.................... 		unsigned DribbleNibble:1; 
.................... 		unsigned ControlFrame:1; 
.................... 		unsigned PauseControlFrame:1; 
.................... 		unsigned UnsupportedOpcode:1; 
.................... 		unsigned VLANType:1; 
.................... 		unsigned Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
....................  
....................  
.................... /****************************************************************************** 
.................... * PHY Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	WORD Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		unsigned :8; 
.................... 		unsigned PDPXMD:1; 
.................... 		unsigned :7; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		unsigned :2; 
.................... 		unsigned LLSTAT:1; 
.................... 		unsigned :5; 
.................... 		unsigned :8; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		unsigned :4; 
.................... 		unsigned RXAPDIS:1; 
.................... 		unsigned :3; 
.................... 		unsigned HDLDIS:1; 
.................... 		unsigned :5; 
.................... 		unsigned FRCLNK:1; 
.................... 		unsigned :1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		unsigned :8; 
.................... 		unsigned :2; 
.................... 		unsigned LSTAT:1; 
.................... 		unsigned COLSTAT:1; 
.................... 		unsigned RXSTAT:1; 
.................... 		unsigned TXSTAT:1; 
.................... 		unsigned :2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		unsigned :1; 
.................... 		unsigned PGEIE:1; 
.................... 		unsigned :2; 
.................... 		unsigned PLNKIE:1; 
.................... 		unsigned :3; 
.................... 		unsigned :8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		unsigned :2; 
.................... 		unsigned PGIF:1; 
.................... 		unsigned :1; 
.................... 		unsigned PLNKIF:1; 
.................... 		unsigned :3; 
.................... 		unsigned :8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		unsigned :1; 
.................... 		unsigned STRCH:1; 
.................... 		unsigned LFRQ0:1; 
.................... 		unsigned LFRQ1:1; 
.................... 		unsigned LBCFG0:1; 
.................... 		unsigned LBCFG1:1; 
.................... 		unsigned LBCFG2:1; 
.................... 		unsigned LBCFG3:1; 
.................... 		unsigned LACFG0:1; 
.................... 		unsigned LACFG1:1; 
.................... 		unsigned LACFG2:1; 
.................... 		unsigned LACFG3:1; 
.................... 		unsigned :4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		unsigned :1; 
.................... 		unsigned STRCH:1; 
.................... 		unsigned LFRQ:2; 
.................... 		unsigned LBCFG:4; 
.................... 		unsigned LACFG:4; 
.................... 		unsigned :4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
.................... 	 
.................... // ESTAT bits --------- 
.................... #define	ESTAT_BUFER		(1<<6) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_PHYRDY	(1) 
.................... 	 
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_ETHEN		(1<<5) 
.................... 	 
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... 	 
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
.................... 	 
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
.................... 	 
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDREN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
.................... 	 
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... 	 
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
.................... 	 
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
.................... #define PHCON2_RXAPDIS	(1ul<<4) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
.................... #elif defined(ENC_CS_TRIS) || defined(WF_CS_TRIS) 
....................    #include "TCPIP Stack/ENC28J60.h" 
.................... #elif defined(ENC100_INTERFACE_MODE) 
....................    #include "TCPIP Stack/ENCX24J600.h" 
....................    #define PHYREG WORD 
.................... #elif defined(__PIC32MX__) && defined(_ETH) 
....................    // extra includes for PIC32MX with embedded ETH Controller 
.................... #else 
....................    #error No Ethernet/WiFi controller defined in HardwareProfile.h.  Defines for an ENC28J60, ENC424J600/624J600, or WiFi MRF24WB10 must be present. 
.................... #endif 
....................  
....................  
.................... #define MAC_TX_BUFFER_SIZE         (1500ul) 
....................  
.................... // A generic structure representing the Ethernet header starting all Ethernet 
.................... // frames 
.................... typedef struct   
.................... #if defined(__CCS__) 
.................... __attribute__((packed)) 
.................... #else 
.................... __attribute__((aligned(2), packed)) 
.................... #endif 
.................... { 
....................    MAC_ADDR        DestMACAddr; 
....................    MAC_ADDR        SourceMACAddr; 
....................    WORD_VAL        Type; 
.................... } ETHER_HEADER; 
....................  
....................  
.................... #define MAC_IP         (0x00u) 
.................... #define MAC_ARP        (0x06u) 
.................... #define MAC_UNKNOWN    (0xFFu) 
....................  
....................  
.................... #if !defined(STACK_USE_HTTP2_SERVER) 
....................    #define RESERVED_HTTP_MEMORY 0ul 
.................... #endif 
....................  
.................... #if !defined(STACK_USE_SSL) 
....................    #define RESERVED_SSL_MEMORY 0ul 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #define MAX_PACKET_SIZE     (1514ul) 
.................... #endif 
....................  
.................... // MAC RAM definitions 
.................... #if defined(ENC100_INTERFACE_MODE) 
....................    #define RESERVED_CRYPTO_MEMORY   (128ul) 
....................    #define RAMSIZE         (24*1024ul) 
....................    #define TXSTART       (0x0000ul) 
....................    #define RXSTART       ((TXSTART + 1518ul + TCP_ETH_RAM_SIZE + RESERVED_HTTP_MEMORY + RESERVED_SSL_MEMORY + RESERVED_CRYPTO_MEMORY + 1ul) & 0xFFFE) 
....................    #define   RXSTOP         (RAMSIZE-1ul) 
....................    #define RXSIZE         (RXSTOP-RXSTART+1ul) 
....................    #define BASE_TX_ADDR   (TXSTART) 
....................    #define BASE_TCB_ADDR   (BASE_TX_ADDR + 1518ul) 
....................    #define BASE_HTTPB_ADDR (BASE_TCB_ADDR + TCP_ETH_RAM_SIZE) 
....................    #define BASE_SSLB_ADDR   (BASE_HTTPB_ADDR + RESERVED_HTTP_MEMORY) 
....................    #define BASE_CRYPTOB_ADDR   (BASE_SSLB_ADDR + RESERVED_SSL_MEMORY) 
.................... #elif defined(WF_CS_TRIS) 
....................    #define RAMSIZE       (14170ul - 8192ul - RESERVED_HTTP_MEMORY - RESERVED_SSL_MEMORY) 
....................    #define TXSTART       (RAMSIZE - (4ul + MAX_PACKET_SIZE + 4ul)) 
....................    #define RXSTART       (0ul) 
....................    #define RXSTOP         ((TXSTART-2ul) | 0x0001ul) 
....................    #define RXSIZE         (RXSTOP-RXSTART+1ul) 
....................    #define BASE_TX_ADDR   (TXSTART + 4ul) 
....................    #define BASE_SCRATCH_ADDR (BASE_TX_ADDR + (MAX_PACKET_SIZE + 4ul)) 
....................    #define BASE_HTTPB_ADDR  (BASE_SCRATCH_ADDR) 
....................    #define BASE_SSLB_ADDR   (BASE_HTTPB_ADDR + RESERVED_HTTP_MEMORY) 
....................    #define BASE_TCB_ADDR   (BASE_SSLB_ADDR + RESERVED_SSL_MEMORY) 
.................... #elif defined(__PIC32MX__) && defined(_ETH) && !defined(ENC_CS_TRIS) 
....................    #define BASE_TX_ADDR   (MACGetTxBaseAddr()) 
....................    #define BASE_HTTPB_ADDR   (MACGetHttpBaseAddr()) 
....................    #define BASE_SSLB_ADDR   (MACGetSslBaseAddr()) 
....................    #define RXSIZE         (EMAC_RX_BUFF_SIZE) 
....................    #define RAMSIZE         (2*RXSIZE)   // not used but silences the compiler 
.................... #else   // ENC28J60 or PIC18F97J60 family internal Ethernet controller 
....................    #define RAMSIZE         (8*1024ul) 
....................    #define TXSTART       (RAMSIZE - (1ul+1518ul+7ul) - TCP_ETH_RAM_SIZE - RESERVED_HTTP_MEMORY - RESERVED_SSL_MEMORY) 
....................    #define RXSTART         (0ul)                  // Should be an even memory address; must be 0 for errata 
....................    #define   RXSTOP         ((TXSTART-2ul) | 0x0001ul)   // Odd for errata workaround 
....................    #define RXSIZE         (RXSTOP-RXSTART+1ul) 
....................    #define BASE_TX_ADDR   (TXSTART + 1ul) 
....................    #define BASE_TCB_ADDR   (BASE_TX_ADDR + (1514ul+7ul)) 
....................    #define BASE_HTTPB_ADDR (BASE_TCB_ADDR + TCP_ETH_RAM_SIZE) 
....................    #define BASE_SSLB_ADDR   (BASE_HTTPB_ADDR + RESERVED_HTTP_MEMORY) 
.................... #endif 
....................  
.................... #if (RXSIZE < 1400) || (RXSIZE > RAMSIZE) 
....................    #error Warning, Ethernet RX buffer is tiny.  Reduce TCP socket count, the size of each TCP socket, or move sockets to a different RAM 
.................... #endif 
....................  
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void   MACEDPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... #if defined(ENC_CS_TRIS) || defined(ENC100_INTERFACE_MODE) || \ 
....................    (defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) || \ 
....................      defined(_18F97J60) ||  defined(_18F96J65) ||  defined(_18F96J60) ||  defined(_18F87J60) ||  defined(_18F86J65) ||  defined(_18F86J60) ||  defined(_18F67J60) ||  defined(_18F66J65) ||  defined(_18F66J60)) 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... #endif 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
.................... // ENC28J60 specific 
.................... void   SetCLKOUT(BYTE NewConfig); 
.................... BYTE   GetCLKOUT(void); 
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
....................  
.................... void MACInit(void); 
.................... void MACProcess(void); 
.................... BOOL MACIsLinked(void); 
....................  
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void MACSetReadPtrInRx(WORD offset); 
.................... PTR_BASE MACSetWritePtr(PTR_BASE address); 
.................... PTR_BASE MACSetReadPtr(PTR_BASE address); 
.................... BYTE MACGet(void); 
.................... WORD MACGetArray(BYTE *val, WORD len); 
.................... void MACDiscardRx(void); 
.................... WORD MACGetFreeRxSize(void); 
.................... void MACMemCopyAsync(PTR_BASE destAddr, PTR_BASE sourceAddr, WORD len); 
.................... BOOL MACIsMemCopyDone(void); 
....................  
.................... void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen); 
.................... BOOL MACIsTxReady(void); 
.................... void MACPut(BYTE val); 
.................... void MACPutArray(BYTE *val, WORD len); 
.................... void MACFlush(void); 
....................  
....................  
.................... // ROM function variants for PIC18 
.................... #if defined(__18CXX) 
....................    void MACPutROMArray(ROM BYTE *val, WORD len); 
.................... #else 
....................    #define MACPutROMArray(a,b)   MACPutArray((BYTE*)a,b) 
.................... #endif 
....................  
.................... // PIC32MX with embedded ETHC functions 
.................... #if defined(__PIC32MX__) && defined(_ETH) 
....................    PTR_BASE MACGetTxBaseAddr(void); 
....................    PTR_BASE MACGetHttpBaseAddr(void); 
....................    PTR_BASE MACGetSslBaseAddr(void); 
.................... #endif 
....................  
....................     
.................... #endif 
....................  
.................... #include "TCPIP Stack/IP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  ********************************************************************/ 
.................... #ifndef __IP_H 
.................... #define __IP_H 
....................  
....................  
.................... #define IP_PROT_ICMP    (1u) 
.................... #define IP_PROT_TCP     (6u) 
.................... #define IP_PROT_UDP     (17u) 
....................  
....................  
.................... // IP packet header definition 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
.................... } IP_HEADER; 
....................  
.................... // IP Pseudo header as defined by RFC 793 (needed for TCP and UDP  
.................... // checksum calculations/verification) 
.................... typedef struct _PSEUDO_HEADER 
.................... { 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................     BYTE Zero; 
....................     BYTE Protocol; 
....................     WORD Length; 
.................... } PSEUDO_HEADER; 
....................  
.................... #define SwapPseudoHeader(h)  (h.Length = swaps(h.Length)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady()       MACIsTxReady() 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(b) MACSetWritePtr(b + BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by  
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset  
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "TCPIP Stack/ARP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder      8/17/06   Combined ARP.h and ARPTsk.h into ARP.h 
....................  ********************************************************************/ 
.................... #ifndef __ARP_H 
.................... #define __ARP_H 
....................  
.................... #ifdef STACK_CLIENT_MODE 
....................    void ARPInit(void); 
.................... #else 
....................    #define ARPInit() 
.................... #endif 
....................  
.................... #define ARP_OPERATION_REQ       0x0001u      // Operation code indicating an ARP Request 
.................... #define ARP_OPERATION_RESP      0x0002u      // Operation code indicating an ARP Response 
....................  
.................... #define HW_ETHERNET             (0x0001u)   // ARP Hardware type as defined by IEEE 802.3 
.................... #define ARP_IP                  (0x0800u)   // ARP IP packet type as defined by IEEE 802.3 
....................  
....................  
.................... // ARP packet structure 
.................... typedef struct  
.................... #if defined(__CCS__) 
.................... __attribute__((packed)) 
.................... #else 
.................... __attribute__((aligned(2), packed)) 
.................... #endif 
.................... { 
....................     WORD        HardwareType;   // Link-layer protocol type (Ethernet is 1). 
....................     WORD        Protocol;       // The upper-layer protocol issuing an ARP request (0x0800 for IPv4).. 
....................     BYTE        MACAddrLen;     // MAC address length (6). 
....................     BYTE        ProtocolLen;    // Length of addresses used in the upper-layer protocol (4). 
....................     WORD        Operation;      // The operation the sender is performing (ARP_REQ or ARP_RESP). 
....................     MAC_ADDR    SenderMACAddr;  // The sender's hardware (MAC) address. 
....................     IP_ADDR     SenderIPAddr;   // The sender's IP address. 
....................     MAC_ADDR    TargetMACAddr;  // The target node's hardware (MAC) address. 
....................     IP_ADDR     TargetIPAddr;   // The target node's IP address. 
.................... } ARP_PACKET; 
....................  
.................... BOOL ARPProcess(void); 
.................... void ARPResolve(IP_ADDR* IPAddr); 
.................... BOOL ARPIsResolved(IP_ADDR* IPAddr, MAC_ADDR* MACAddr); 
.................... void SwapARPPacket(ARP_PACKET* p); 
....................  
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................    /* API specific Definitions */ 
....................    #define ARP_REQ       0x0001u      // Operation code indicating an ARP Request 
....................    #define ARP_RESP      0x0002u      // Operation code indicating an ARP Response 
....................  
....................    struct arp_app_callbacks { 
....................        BOOL used; 
....................        void (*ARPPkt_notify)(DWORD SenderIPAddr, DWORD TargetIPAddr,  
....................                              MAC_ADDR* SenderMACAddr, MAC_ADDR* TargetMACAddr, BYTE op_req); 
....................    }; 
....................    CHAR ARPRegisterCallbacks(struct arp_app_callbacks *app); 
....................    BOOL ARPDeRegisterCallbacks(CHAR id); 
.................... #endif 
....................    BOOL ARPSendPkt(DWORD SrcIPAddr, DWORD DestIPAddr, BYTE op_req ); 
.................... #endif 
....................  
....................  
....................  
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... /********************************************************************* 
....................  * 
....................  *               External serial data EEPROM Access Defs. 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        XEEPROM.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/20/02     Original (Rev. 1.0) 
.................... ********************************************************************/ 
.................... #ifndef __XEEPROM_H 
.................... #define __XEEPROM_H 
....................  
.................... #include "HardwareProfile.h" 
.................... // hardwareprofile.h 
....................  
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #if STACK_USE_CCS_EWLWIFIB || STACK_USE_CCS_EWLWIFIG 
....................  
....................    #bit WF_CS_TRIS1   =     0xF96.1 //E1 
....................    #define WF_CS_TRIS WF_CS_TRIS1 
....................    #bit WF_CS_IO     =  0xF8D.1    //LatE1 
....................    #bit WF_SDI_TRIS  =  0xF94.4    // (TRISCbits.TRISC4) 
....................    #bit WF_SCK_TRIS  =  0xF94.3    // (TRISCbits.TRISC3) 
....................    #bit WF_SDO_TRIS  =  0xF94.5    // (TRISCbits.TRISC5) 
....................    #bit WF_RESET_TRIS=  0xF93.1    //(TRISBbits.TRISB1) 
....................    #bit WF_RESET_IO  =  0xF8A.1     //(LATBbits.LATB1)   
....................    #bit WF_INT_TRIS  =  0xF93.0     // (TRISBbits.TRISB0)  // INT1 
....................    #bit WF_INT_IO    =  0xF81.0   //(PORTBbits.RB0)  
....................    #bit WF_HIBERNATE_TRIS= 0xF93.2  //(TRISBbits.TRISB2)  
....................    #bit   WF_HIBERNATE_IO=  0xF81.2    //(PORTBbits.RB2) 
....................     
....................    #bit WF_INT_EDGE  =  0xFF1.6      //(INTCON2bits.INTEDG0) 
....................    #bit WF_INT_IE    =  0xFF2.4   //(INTCONbits.INT0IE) 
....................    #bit WF_INT_IF    =  0xFF2.1   //(INTCONbits.INT0IF) 
....................    #define WF_SSPBUF  (SSP1BUF) 
....................    #define WF_SPISTAT  (SSP1STATbits) 
....................    #define WF_SPISTATbits SSP1STATbits     //(SSP1STATbits) 
....................    #define WF_SPICON1  (SSP1CON1bits) 
....................    #define WF_SPICON1bits WF_SPICON1    // (SSP1CON1bits) 
....................    #define WF_SPICON2  (SSP1CON2bits) 
....................    #bit WF_SPI_IE    =   0xF9D.3  //(PIE1bits.SSPIE) 
....................    #bit WF_SPI_IP    =   0xF9F.3  //(IPR1bits.SSPIP) 
....................    #bit WF_SPI_IF    =   0xF9E.3  //(PIR1bits.SSPIF) 
....................     
.................... #else 
....................  
.................... //#error define necessary hardware for TCPIP stack 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... typedef BOOL XEE_RESULT; 
.................... #define XEE_SUCCESS FALSE 
....................  
.................... #if defined(EEPROM_CS_TRIS)	 
.................... 	void XEEInit(void); 
.................... 	XEE_RESULT XEEBeginWrite(DWORD address); 
.................... 	XEE_RESULT XEEWrite(BYTE val); 
.................... 	void XEEWriteArray(BYTE *val, WORD wLen); 
.................... 	XEE_RESULT XEEEndWrite(void); 
.................... 	XEE_RESULT XEEBeginRead(DWORD address); 
.................... 	BYTE XEERead(void); 
.................... 	XEE_RESULT XEEReadArray(DWORD address, BYTE *buffer, WORD length); 
.................... 	XEE_RESULT XEEEndRead(void); 
.................... 	BOOL XEEIsBusy(void); 
.................... #else 
.................... 	// If you get any of these linker errors, it means that you either have an  
.................... 	// error in your HardwareProfile.h or TCPIPConfig.h definitions.  The code  
.................... 	// is attempting to call a function that can't possibly work because you  
.................... 	// have not specified what pins and SPI module the physical SPI EEPROM chip  
.................... 	// is connected to.  Alternatively, if you don't have an SPI EERPOM chip, it  
.................... 	// means you have enabled a stack feature that requires SPI EEPROM hardware. 
.................... 	// In this case, you need to edit TCPIPConfig.h and disable this stack  
.................... 	// feature.  The linker error tells you which object file this error was  
.................... 	// generated from.  It should be a clue as to what feature you need to  
.................... 	// disable. 
.................... 	void 		You_cannot_call_the_XEEInit_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEBeginWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void 		You_cannot_call_the_XEEWriteArray_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEEndWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEBeginRead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	BYTE 		You_cannot_call_the_XEERead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEReadArray_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEEndRead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	BOOL 		You_cannot_call_the_XEEIsBusy_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	#define XEEInit()				You_cannot_call_the_XEEInit_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEBeginWrite(a) 		You_cannot_call_the_XEEBeginWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEWrite(a)				You_cannot_call_the_XEEWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEWriteArray(a,b)		You_cannot_call_the_XEEWriteArray_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEEndWrite()			You_cannot_call_the_XEEEndWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEBeginRead(a)			You_cannot_call_the_XEEBeginRead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEERead(a)				You_cannot_call_the_XEERead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEReadArray(a, b, c)	You_cannot_call_the_XEEReadArray_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEEndRead()			You_cannot_call_the_XEEEndRead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEIsBusy()				You_cannot_call_the_XEEIsBusy_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... #endif 
....................  
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... /********************************************************************* 
....................  * 
....................  *  SPI Flash Memory Driver Header 
....................  *	- Tested to be compatible with SST25VF016B 
....................  *  - Expected compatibility with other SST (Microchip) SST25 series  
....................  *    devices 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        SPIFlash.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * E. Wood				3/20/08	Original 
.................... ********************************************************************/ 
.................... #ifndef __SPIFLASH_H 
.................... #define __SPIFLASH_H 
....................  
.................... #include "HardwareProfile.h" 
....................  
.................... #define SPI_FLASH_SECTOR_SIZE		(4096ul) 
.................... #define SPI_FLASH_PAGE_SIZE			(0ul)		// SST has no page boundary requirements 
....................  
.................... #define SPI_FLASH_SECTOR_MASK		(SPI_FLASH_SECTOR_SIZE - 1) 
....................  
....................  
.................... #if defined(SPIFLASH_CS_TRIS) 
.................... 	void SPIFlashInit(void);		 
.................... 	void SPIFlashReadArray(DWORD dwAddress, BYTE *vData, WORD wLen); 
.................... 	void SPIFlashBeginWrite(DWORD dwAddr); 
.................... 	void SPIFlashWrite(BYTE vData); 
.................... 	void SPIFlashWriteArray(BYTE *vData, WORD wLen); 
.................... 	void SPIFlashEraseSector(DWORD dwAddr); 
.................... #else 
.................... 	// If you get any of these linker errors, it means that you either have an  
.................... 	// error in your HardwareProfile.h or TCPIPConfig.h definitions.  The code  
.................... 	// is attempting to call a function that can't possibly work because you  
.................... 	// have not specified what pins and SPI module the physical SPI Flash chip  
.................... 	// is connected to.  Alternatively, if you don't have an SPI Flash chip, it  
.................... 	// means you have enabled a stack feature that requires SPI Flash hardware. 
.................... 	// In this case, you need to edit TCPIPConfig.h and disable this stack  
.................... 	// feature.  The linker error tells you which object file this error was  
.................... 	// generated from.  It should be a clue as to what feature you need to  
.................... 	// disable. 
.................... 	void You_cannot_call_the_SPIFlashInit_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashReadArray_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashBeginWrite_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashWrite_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashWriteArray_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashEraseSector_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	#define SPIFlashInit()				You_cannot_call_the_SPIFlashInit_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashReadArray(a,b,c)	You_cannot_call_the_SPIFlashReadArray_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashBeginWrite(a)		You_cannot_call_the_SPIFlashBeginWrite_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashWrite(a)			You_cannot_call_the_SPIFlashWrite_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashWriteArray(a,b)		You_cannot_call_the_SPIFlashWriteArray_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashEraseSector(a)		You_cannot_call_the_SPIFlashEraseSector_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... #endif 
....................  
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/SPIRAM.h" 
.................... /********************************************************************* 
....................  * 
....................  * Data SPI RAM Access Routines 
....................  *  -Tested with AMI Semiconductor N256S0830HDA 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        SPIRAM.h 
....................  * Dependencies:    Compiler.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * \file SPIRAM.h 
....................  * \author Howard Henry Schlunder 
....................  * \date 25 July 2007 
.................... ********************************************************************/ 
.................... #ifndef __SPIRAM_H 
.................... #define __SPIRAM_H 
....................  
.................... #include "HardwareProfile.h" 
.................... // hardwareprofile.h 
....................  
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #if STACK_USE_CCS_EWLWIFIB || STACK_USE_CCS_EWLWIFIG 
....................  
....................    #bit WF_CS_TRIS1   =     0xF96.1 //E1 
....................    #define WF_CS_TRIS WF_CS_TRIS1 
....................    #bit WF_CS_IO     =  0xF8D.1    //LatE1 
....................    #bit WF_SDI_TRIS  =  0xF94.4    // (TRISCbits.TRISC4) 
....................    #bit WF_SCK_TRIS  =  0xF94.3    // (TRISCbits.TRISC3) 
....................    #bit WF_SDO_TRIS  =  0xF94.5    // (TRISCbits.TRISC5) 
....................    #bit WF_RESET_TRIS=  0xF93.1    //(TRISBbits.TRISB1) 
....................    #bit WF_RESET_IO  =  0xF8A.1     //(LATBbits.LATB1)   
....................    #bit WF_INT_TRIS  =  0xF93.0     // (TRISBbits.TRISB0)  // INT1 
....................    #bit WF_INT_IO    =  0xF81.0   //(PORTBbits.RB0)  
....................    #bit WF_HIBERNATE_TRIS= 0xF93.2  //(TRISBbits.TRISB2)  
....................    #bit   WF_HIBERNATE_IO=  0xF81.2    //(PORTBbits.RB2) 
....................     
....................    #bit WF_INT_EDGE  =  0xFF1.6      //(INTCON2bits.INTEDG0) 
....................    #bit WF_INT_IE    =  0xFF2.4   //(INTCONbits.INT0IE) 
....................    #bit WF_INT_IF    =  0xFF2.1   //(INTCONbits.INT0IF) 
....................    #define WF_SSPBUF  (SSP1BUF) 
....................    #define WF_SPISTAT  (SSP1STATbits) 
....................    #define WF_SPISTATbits SSP1STATbits     //(SSP1STATbits) 
....................    #define WF_SPICON1  (SSP1CON1bits) 
....................    #define WF_SPICON1bits WF_SPICON1    // (SSP1CON1bits) 
....................    #define WF_SPICON2  (SSP1CON2bits) 
....................    #bit WF_SPI_IE    =   0xF9D.3  //(PIE1bits.SSPIE) 
....................    #bit WF_SPI_IP    =   0xF9F.3  //(IPR1bits.SSPIP) 
....................    #bit WF_SPI_IF    =   0xF9E.3  //(PIR1bits.SSPIF) 
....................     
.................... #else 
....................  
.................... //#error define necessary hardware for TCPIP stack 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #if defined(SPIRAM_CS_TRIS) 
.................... 	void SPIRAMInit(void); 
.................... 	void SPIRAMGetArray(WORD wAddress, BYTE *vData, WORD wLength); 
.................... 	void SPIRAMPutArray(WORD wAddress, BYTE *vData, WORD wLength); 
.................... 	 
.................... 	#define SPIRAMPutString(a,b)			SPIRAMPutArray(a, strlen((char*)b)) 
.................... 	 
.................... 	#if defined(__18CXX) 
.................... 		void SPIRAMPutROMArray(WORD wAddress, ROM BYTE *vData, WORD wLength); 
.................... 		#define SPIRAMPutROMString(a,b)		SPIRAMPutROMArray(a, strlenpgm((ROM char*)b)) 
.................... 	#else 
.................... 		#define SPIRAMPutROMString(a,b)		SPIRAMPutArray(a, strlen((char*)b)) 
.................... 		#define SPIRAMPutROMArray(a,b,c)	SPIRAMPutROMArray(a, b, c) 
.................... 	#endif 
.................... #else 
.................... 	// If you get any of these linker errors, it means that you either have an  
.................... 	// error in your HardwareProfile.h or TCPIPConfig.h definitions.  The code  
.................... 	// is attempting to call a function that can't possibly work because you  
.................... 	// have not specified what pins and SPI module the physical SPI SRAM chip  
.................... 	// is connected to.  Alternatively, if you don't have an SPI SRAM chip, it  
.................... 	// means you have enabled a stack feature that requires SPI SRAM hardware. 
.................... 	// In this case, you need to edit TCPIPConfig.h and disable this stack  
.................... 	// feature.  The linker error tells you which object file this error was  
.................... 	// generated from.  It should be a clue as to what feature you need to  
.................... 	// disable. 
.................... 	void You_cannot_call_the_SPIRAMInit_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMGetArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMPutArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMPutString_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMPutROMArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMPutROMString_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	#define SPIRAMInit()				You_cannot_call_the_SPIRAMInit_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMGetArray(a,b,c)		You_cannot_call_the_SPIRAMGetArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMPutArray(a,b,c)		You_cannot_call_the_SPIRAMPutArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMPutString(a,b)		You_cannot_call_the_SPIRAMPutString_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMPutROMArray(a,b,c)	You_cannot_call_the_SPIRAMPutROMArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMPutROMString(a,b)		You_cannot_call_the_SPIRAMPutROMString_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... #endif 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCP.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    	Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01  	Original        (Rev 1.0) 
....................  * Howard Schlunder		11/30/06	See "TCPIP Stack Version.txt" file 
....................  ********************************************************************/ 
.................... #ifndef __TCP_HITECH_WORKAROUND_H 
.................... #define __TCP_HITECH_WORKAROUND_H 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	Type Definitions 
....................   ***************************************************************************/ 
....................  
.................... // A TCP_SOCKET is stored as a single BYTE 
.................... typedef BYTE TCP_SOCKET; 
....................  
.................... #define INVALID_SOCKET      (0xFE)	// The socket is invalid or could not be opened 
.................... #define UNKNOWN_SOCKET      (0xFF)	// The socket is not known 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	State Machine Variables 
....................   ***************************************************************************/ 
....................  
.................... // TCP States as defined by RFC 793 
.................... typedef enum 
.................... { 
.................... 	TCP_GET_DNS_MODULE,		// Special state for TCP client mode sockets 
.................... 	TCP_DNS_RESOLVE,		// Special state for TCP client mode sockets 
.................... 	TCP_GATEWAY_SEND_ARP,	// Special state for TCP client mode sockets 
.................... 	TCP_GATEWAY_GET_ARP,	// Special state for TCP client mode sockets 
....................  
....................     TCP_LISTEN,				// Socket is listening for connections 
....................     TCP_SYN_SENT,			// A SYN has been sent, awaiting an SYN+ACK 
....................     TCP_SYN_RECEIVED,		// A SYN has been received, awaiting an ACK 
....................     TCP_ESTABLISHED,		// Socket is connected and connection is established 
....................     TCP_FIN_WAIT_1,			// FIN WAIT state 1 
....................     TCP_FIN_WAIT_2,			// FIN WAIT state 2 
....................     TCP_CLOSING,			// Socket is closing 
.................... //	TCP_TIME_WAIT, state is not implemented 
.................... 	TCP_CLOSE_WAIT,			// Waiting to close the socket 
....................     TCP_LAST_ACK,			// The final ACK has been sent 
....................     TCP_CLOSED,				// Socket is idle and unallocated 
....................  
....................     TCP_CLOSED_BUT_RESERVED	// Special state for TCP client mode sockets.  Socket is idle, but still allocated pending application closure of the handle. 
.................... } TCP_STATE; 
....................  
.................... typedef enum 
.................... { 
.................... 	SSL_NONE = 0,			// No security is enabled 
.................... 	SSL_HANDSHAKING,		// Handshake is progressing (no application data allowed) 
.................... 	SSL_ESTABLISHED,		// Connection is established and secured 
.................... 	SSL_CLOSED				// Connection has been closed (no applicaiton data is allowed) 
.................... } SSL_STATE; 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	TCB Definitions 
....................   ***************************************************************************/ 
....................  
.................... // TCP Control Block (TCB) stub data storage.  Stubs are stored in local PIC RAM for speed. 
.................... // Current size is 34 bytes (PIC18), 36 bytes (PIC24/dsPIC), or 56 (PIC32) 
.................... typedef struct 
.................... { 
.................... 	PTR_BASE bufferTxStart;		// First byte of TX buffer 
.................... 	PTR_BASE bufferRxStart;		// First byte of RX buffer.  TX buffer ends 1 byte prior 
.................... 	PTR_BASE bufferEnd;			// Last byte of RX buffer 
.................... 	PTR_BASE txHead;			// Head pointer for TX 
.................... 	PTR_BASE txTail;			// Tail pointer for TX 
.................... 	PTR_BASE rxHead;			// Head pointer for RX 
.................... 	PTR_BASE rxTail;			// Tail pointer for RX 
....................     DWORD eventTime;			// Packet retransmissions, state changes 
.................... 	WORD eventTime2;			// Window updates, automatic transmission 
.................... 	union 
.................... 	{ 
.................... 		WORD delayedACKTime;	// Delayed Acknowledgement timer 
.................... 		WORD closeWaitTime;		// TCP_CLOSE_WAIT timeout timer 
.................... 	} OverlappedTimers; 
....................     TCP_STATE smState;			// State of this socket 
....................     struct 
....................     { 
.................... 	    unsigned char vUnackedKeepalives : 3;		// Count of how many keepalives have been sent with no response 
....................         unsigned char bServer : 1;					// Socket should return to listening state when closed 
.................... 		unsigned char bTimerEnabled	: 1;			// Timer is enabled 
.................... 		unsigned char bTimer2Enabled : 1;			// Second timer is enabled 
.................... 		unsigned char bDelayedACKTimerEnabled : 1;	// DelayedACK timer is enabled 
.................... 		unsigned char bOneSegmentReceived : 1;		// A segment has been received 
.................... 		unsigned char bHalfFullFlush : 1;			// Flush is for being half full 
.................... 		unsigned char bTXASAP : 1;					// Transmit as soon as possible (for Flush) 
.................... 		unsigned char bTXASAPWithoutTimerReset : 1;	// Transmit as soon as possible (for Flush), but do not reset retransmission timers 
.................... 		unsigned char bTXFIN : 1;					// FIN needs to be transmitted 
.................... 		unsigned char bSocketReset : 1;				// Socket has been reset (self-clearing semaphore) 
.................... 		unsigned char bSSLHandshaking : 1;			// Socket is in an SSL handshake 
.................... 		unsigned char filler : 2;					// Future expansion 
....................     } Flags; 
.................... 	WORD_VAL remoteHash;	// Consists of remoteIP, remotePort, localPort for connected sockets.  It is a localPort number only for listening server sockets. 
....................  
....................     #if defined(STACK_USE_SSL) 
....................     PTR_BASE sslTxHead;		// Position of data being written in next SSL application record 
....................     						//   Also serves as cache of localSSLPort when smState = TCP_LISTENING 
....................     PTR_BASE sslRxHead;		// Position of incoming data not yet handled by SSL 
....................     BYTE sslStubID;			// Which sslStub is associated with this connection 
....................     BYTE sslReqMessage;		// Currently requested SSL message 
....................     #endif 
....................  
.................... 	BYTE vMemoryMedium;		// Which memory medium the TCB is actually stored 
.................... 	 
.................... } TCB_STUB; 
....................  
.................... // Remainder of TCP Control Block data. 
.................... // The rest of the TCB is stored in Ethernet buffer RAM or elsewhere as defined by vMemoryMedium. 
.................... // Current size is 41 (PIC18), 42 (PIC24/dsPIC), or 48 bytes (PIC32) 
.................... typedef struct 
.................... { 
.................... 	DWORD		retryInterval;			// How long to wait before retrying transmission 
.................... 	DWORD		MySEQ;					// Local sequence number 
.................... 	DWORD		RemoteSEQ;				// Remote sequence number 
.................... 	PTR_BASE	txUnackedTail;			// TX tail pointer for data that is not yet acked 
....................     WORD_VAL	remotePort;				// Remote port number 
....................     WORD_VAL	localPort;				// Local port number 
.................... 	WORD		remoteWindow;			// Remote window size 
.................... 	WORD		wFutureDataSize;		// How much out-of-order data has been received 
.................... 	union 
.................... 	{ 
.................... 		NODE_INFO	niRemoteMACIP;		// 10 bytes for MAC and IP address 
.................... 		DWORD		dwRemoteHost;		// RAM or ROM pointer to a hostname string (ex: "www.microchip.com") 
.................... 	} remote; 
.................... 	SHORT		sHoleSize;				// Size of the hole, or -1 for none exists.  (0 indicates hole has just been filled) 
....................     struct 
....................     { 
....................         unsigned char bFINSent : 1;		// A FIN has been sent 
.................... 		unsigned char bSYNSent : 1;		// A SYN has been sent 
.................... 		unsigned char bRemoteHostIsROM : 1;	// Remote host is stored in ROM 
.................... 		unsigned char bRXNoneACKed1 : 1;	// A duplicate ACK was likely received 
.................... 		unsigned char bRXNoneACKed2 : 1;	// A second duplicate ACK was likely received 
.................... 		unsigned char filler : 3;		// future use 
....................     } flags; 
.................... 	WORD		wRemoteMSS;				// Maximum Segment Size option advirtised by the remote node during initial handshaking 
....................     #if defined(STACK_USE_SSL) 
....................     WORD_VAL	localSSLPort;			// Local SSL port number (for listening sockets) 
....................     #endif 
.................... 	BYTE		retryCount;				// Counter for transmission retries 
.................... 	BYTE		vSocketPurpose;			// Purpose of socket (as defined in TCPIPConfig.h) 
.................... } TCB; 
....................  
.................... // Information about a socket 
.................... typedef struct 
.................... { 
.................... 	NODE_INFO remote;		// NODE_INFO structure for remote node 
.................... 	WORD_VAL remotePort;	// Port number associated with remote node 
.................... } SOCKET_INFO; 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	Function Declarations 
....................   ***************************************************************************/ 
....................  
.................... void TCPInit(void); 
.................... SOCKET_INFO* TCPGetRemoteInfo(TCP_SOCKET hTCP); 
.................... BOOL TCPWasReset(TCP_SOCKET hTCP); 
.................... BOOL TCPIsConnected(TCP_SOCKET hTCP); 
.................... void TCPDisconnect(TCP_SOCKET hTCP); 
.................... void TCPClose(TCP_SOCKET hTCP); 
.................... WORD TCPIsPutReady(TCP_SOCKET hTCP); 
.................... BOOL TCPPut(TCP_SOCKET hTCP, BYTE byte); 
.................... WORD TCPPutArray(TCP_SOCKET hTCP, BYTE* Data, WORD Len); 
.................... BYTE* TCPPutString(TCP_SOCKET hTCP, BYTE* Data); 
.................... WORD TCPIsGetReady(TCP_SOCKET hTCP); 
.................... WORD TCPGetRxFIFOFree(TCP_SOCKET hTCP); 
.................... BOOL TCPGet(TCP_SOCKET hTCP, BYTE* byte); 
.................... WORD TCPGetArray(TCP_SOCKET hTCP, BYTE* buffer, WORD count); 
.................... BYTE TCPPeek(TCP_SOCKET hTCP, WORD wStart); 
.................... WORD TCPPeekArray(TCP_SOCKET hTCP, BYTE *vBuffer, WORD wLen, WORD wStart); 
.................... WORD TCPFindEx(TCP_SOCKET hTCP, BYTE cFind, WORD wStart, WORD wSearchLen, BOOL bTextCompare); 
.................... WORD TCPFindArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare); 
.................... void TCPDiscard(TCP_SOCKET hTCP); 
.................... BOOL TCPProcess(NODE_INFO* remote, IP_ADDR* localIP, WORD len); 
.................... void TCPTick(void); 
.................... void TCPFlush(TCP_SOCKET hTCP); 
....................  
.................... // Create a server socket and ignore dwRemoteHost. 
.................... #define TCP_OPEN_SERVER		0u 
.................... #if defined(STACK_CLIENT_MODE) 
.................... 	#if defined(STACK_USE_DNS) 
.................... 		// Create a client socket and use dwRemoteHost as a RAM pointer to a hostname string. 
.................... 		#define TCP_OPEN_RAM_HOST	1u 
.................... 		// Create a client socket and use dwRemoteHost as a ROM pointer to a hostname string. 
.................... 		#define TCP_OPEN_ROM_HOST	2u 
.................... 	#else 
.................... 		// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_RAM_HOST while the DNS client module is not enabled.  
.................... 		#define TCP_OPEN_RAM_HOST	You_need_to_enable_STACK_USE_DNS_to_use_TCP_OPEN_RAM_HOST 
.................... 		// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_ROM_HOST while the DNS client module is not enabled.  
.................... 		#define TCP_OPEN_ROM_HOST	You_need_to_enable_STACK_USE_DNS_to_use_TCP_OPEN_ROM_HOST 
.................... 	#endif 
.................... 	// Create a client socket and use dwRemoteHost as a literal IP address. 
.................... 	#define TCP_OPEN_IP_ADDRESS	3u 
.................... 	// Create a client socket and use dwRemoteHost as a pointer to a NODE_INFO structure containing the exact remote IP address and MAC address to use. 
.................... 	#define TCP_OPEN_NODE_INFO	4u 
.................... #else 
.................... 	// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_RAM_HOST while STACK_CLIENT_MODE feature is not enabled.  
.................... 	#define TCP_OPEN_RAM_HOST	You_need_to_enable_STACK_CLIENT_MODE_to_use_TCP_OPEN_RAM_HOST 
.................... 	// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_ROM_HOST while STACK_CLIENT_MODE feature is not enabled.  
.................... 	#define TCP_OPEN_ROM_HOST	You_need_to_enable_STACK_CLIENT_MODE_to_use_TCP_OPEN_ROM_HOST 
.................... 	// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_IP_ADDRESS while STACK_CLIENT_MODE feature is not enabled.  
.................... 	#define TCP_OPEN_IP_ADDRESS	You_need_to_enable_STACK_CLIENT_MODE_to_use_TCP_OPEN_IP_ADDRESS 
.................... 	// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_NODE_INFO while STACK_CLIENT_MODE feature is not enabled.  
.................... 	#define TCP_OPEN_NODE_INFO	You_need_to_enable_STACK_CLIENT_MODE_to_use_TCP_OPEN_NODE_INFO 
.................... #endif 
.................... TCP_SOCKET TCPOpen(DWORD dwRemoteHost, BYTE vRemoteHostType, WORD wPort, BYTE vSocketPurpose); 
....................  
.................... #if defined(__18CXX) 
.................... 	WORD TCPFindROMArrayEx(TCP_SOCKET hTCP, ROM BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare); 
....................  
.................... 	/***************************************************************************** 
.................... 	  Summary: 
.................... 		Alias to TCPFindROMArrayEx with no length parameter. 
.................... 	 
.................... 	  Description: 
.................... 		This function is an alias to TCPFindROMArrayEx with no length parameter.   
.................... 		It is provided for backwards compatibility with an older API. 
.................... 	  ***************************************************************************/ 
.................... 	#define TCPFindROMArray(a,b,c,d,e)		TCPFindROMArrayEx(a,b,c,d,0,e) 
.................... 	 
.................... 	WORD TCPPutROMArray(TCP_SOCKET hTCP, ROM BYTE* Data, WORD Len); 
.................... 	ROM BYTE* TCPPutROMString(TCP_SOCKET hTCP, ROM BYTE* Data); 
.................... #else 
.................... 	#define TCPFindROMArray(a,b,c,d,e) 		TCPFindArray(a,(BYTE*)b,c,d,e) 
.................... 	#define TCPFindROMArrayEx(a,b,c,d,e,f) 	TCPFindArrayEx(a,(BYTE*)b,c,d,e,f) 
.................... 	#define TCPPutROMArray(a,b,c)			TCPPutArray(a,(BYTE*)b,c) 
.................... 	#define TCPPutROMString(a,b)			TCPPutString(a,(BYTE*)b) 
.................... #endif 
....................  
.................... WORD TCPGetTxFIFOFull(TCP_SOCKET hTCP); 
.................... // Alias to TCPIsGetReady provided for API completeness 
.................... #define TCPGetRxFIFOFull(a)					TCPIsGetReady(a) 
.................... // Alias to TCPIsPutReady provided for API completeness 
.................... #define TCPGetTxFIFOFree(a) 				TCPIsPutReady(a) 
....................  
.................... #define TCP_ADJUST_GIVE_REST_TO_RX	0x01u	// Resize flag: extra bytes go to RX  
.................... #define TCP_ADJUST_GIVE_REST_TO_TX	0x02u	// Resize flag: extra bytes go to TX 
.................... #define TCP_ADJUST_PRESERVE_RX		0x04u	// Resize flag: attempt to preserve RX buffer 
.................... #define TCP_ADJUST_PRESERVE_TX		0x08u	// Resize flag: attempt to preserve TX buffer 
.................... BOOL TCPAdjustFIFOSize(TCP_SOCKET hTCP, WORD wMinRXSize, WORD wMinTXSize, BYTE vFlags); 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... BOOL TCPStartSSLClient(TCP_SOCKET hTCP, BYTE* host); 
.................... BOOL TCPStartSSLClientEx(TCP_SOCKET hTCP, BYTE* host, void * buffer, BYTE suppDataType); 
.................... BOOL TCPStartSSLServer(TCP_SOCKET hTCP); 
.................... BOOL TCPAddSSLListener(TCP_SOCKET hTCP, WORD port); 
.................... BOOL TCPRequestSSLMessage(TCP_SOCKET hTCP, BYTE msg); 
.................... BOOL TCPSSLIsHandshaking(TCP_SOCKET hTCP); 
.................... BOOL TCPIsSSL(TCP_SOCKET hTCP); 
.................... void TCPSSLHandshakeComplete(TCP_SOCKET hTCP); 
.................... void TCPSSLDecryptMAC(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, WORD len); 
.................... void TCPSSLInPlaceMACEncrypt(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, BYTE* MACSecret, WORD len); 
.................... void TCPSSLPutRecordHeader(TCP_SOCKET hTCP, BYTE* hdr, BOOL recDone); 
.................... WORD TCPSSLGetPendingTxSize(TCP_SOCKET hTCP); 
.................... void TCPSSLHandleIncoming(TCP_SOCKET hTCP); 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Summary: 
.................... 	Alias to TCPFindEx with no length parameter. 
....................  
....................   Description: 
.................... 	This function is an alias to TCPFindEx with no length parameter.  It is 
.................... 	provided for backwards compatibility with an older API. 
....................   ***************************************************************************/ 
.................... #define TCPFind(a,b,c,d)					TCPFindEx(a,b,c,0,d) 
....................  
....................  
.................... /***************************************************************************** 
....................   Summary: 
.................... 	Alias to TCPFindArrayEx with no length parameter. 
....................  
....................   Description: 
.................... 	This function is an alias to TCPFindArrayEx with no length parameter.  It is 
.................... 	provided for backwards compatibility with an older API. 
....................   ***************************************************************************/ 
.................... #define TCPFindArray(a,b,c,d,e)				TCPFindArrayEx(a,b,c,d,0,e) 
....................  
.................... /***************************************************************************** 
....................   Summary: 
.................... 	Alias to TCPOpen as a server. 
....................  
....................   Description: 
.................... 	This function is an alias to TCPOpen for server sockets.  It is provided 
.................... 	for backwards compatibility with older versions of the stack.  New 
.................... 	applications should use the TCPOpen API instead. 
....................   ***************************************************************************/ 
.................... #define TCPListen(port)			TCPOpen(0, TCP_OPEN_SERVER, port, TCP_PURPOSE_DEFAULT) 
....................  
.................... /***************************************************************************** 
....................   Summary: 
.................... 	Alias to TCPOpen as a client. 
....................  
....................   Description: 
.................... 	This function is an alias to TCPOpen for client sockets.  It is provided 
.................... 	for backwards compatibility with older versions of the stack.  New 
.................... 	applications should use the TCPOpen API instead. 
....................   ***************************************************************************/ 
.................... #define TCPConnect(remote,port)	TCPOpen((DWORD)remote, TCP_OPEN_NODE_INFO, port, TCP_PURPOSE_DEFAULT) 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    	Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		03/16/07	Original 
....................  ********************************************************************/ 
.................... #ifndef __ICMP_H 
.................... #define __ICMP_H 
....................  
.................... void ICMPProcess(NODE_INFO *remote, WORD len); 
....................  
.................... BOOL ICMPBeginUsage(void); 
.................... void ICMPSendPing(DWORD dwRemoteIP); 
.................... void ICMPSendPingToHost(BYTE * szRemoteHost); 
.................... LONG ICMPGetReply(void); 
.................... void ICMPEndUsage(void); 
....................  
.................... #if defined(__18CXX) 
.................... 	void ICMPSendPingToHostROM(ROM BYTE * szRemoteHost); 
.................... #else 
.................... 	#define ICMPSendPingToHostROM(a) 	ICMPSendPingToHost((BYTE*)(a)) 
.................... #endif 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #if defined(MRF24WG) 
....................  #define WF_DisplayModuleAssertInfo() 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_CCS_HTTP1_SERVER) 
....................    #include "ccs_HTTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    #include "ccs_HTTP2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_TWITTER) 
....................    #include "ccs_twitter.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SMTP) 
....................    #include "ccs_SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_TFTP_SERVER) 
....................    #include "ccs_TFTPs.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    #include "ccs_SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_GRATUITOUS_ARP) 
....................    #include "ccs_gratarp.h" 
.................... #endif 
....................  
.................... #define TickGetDiff(a, b)  (a-b) 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................        #if !defined(STACK_USE_DNS) 
....................            #define STACK_USE_DNS 
....................        #endif 
....................        #if !defined(STACK_USE_UDP) 
....................            #define STACK_USE_UDP 
....................        #endif        
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    #ifndef STACK_USE_MPFS 
....................       #define STACK_USE_MPFS 
....................     #endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    #if !defined(STACK_CLIENT_MODE) 
....................        #define STACK_CLIENT_MODE 
....................    #endif 
.................... #endif 
....................  
.................... #if STACK_USE_WIFI 
....................    // if defined, MyWFIsConnected() won't return TRUE in AdHoc mode until after 
....................    // it receives some IP traffic.  It will then stay connected until after 5 
....................    // minutes of no activity. 
....................    #define WIFI_ADHOC_CONNECTION_TIMER ((TICK)TICKS_PER_SECOND * 300) 
....................     
....................    #if defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    extern int1 g_WifiAdhocIsConn; 
....................    extern TICK g_WifiAdhocTickConn; 
....................    #endif 
....................     
....................    extern unsigned int8 WIFI_channelList[16]; 
....................    extern unsigned int8 WIFI_numChannelsInList; 
....................    extern unsigned int8 WIFI_region; 
....................    extern int1 g_WifiConnectFail; 
....................     
....................    // this is similar to MACIsLinked() and WFisConnected().  this one has some 
....................    // filters and extra UI logic to better represent link status to the user. 
....................    // use this for UI displays. 
....................    // REMOVED - Use IsLinked() instead 
....................    //int1 MyWFisConnected(void); 
....................     
....................    // This routine does a few things: 
....................    //  * Reset WIFI unit if no it goes a long time without a connection, 
....................    //       because old modules would hang on WPA connect failure. 
....................    //  * Ad-Hoc connection timer support (WIFI_ADHOC_CONNECTION_TIMER) 
....................    //  * LED Traffic flickering and LED connection status 
....................    void WIFIConnectTask(void); 
....................     
....................    #if defined(WF_FORCE_NO_PS_POLL) 
....................       void WF_CCS_PsPollDisable(void); 
....................    #endif 
.................... #endif 
....................  
.................... int1 DHCPBoundOrDisabled(void); 
....................  
.................... // A higher level version of MACIsLinked(). 
.................... //  - returns FALSE if MACIsLinked() is TRUE -but- DHCP is enabled and not 
.................... //       bound. 
.................... //  - returns FALSE in WIFI if using AdHoc mode and it has been a while 
.................... //       since no traffic 
.................... //  - else, returns MACIsLinked() 
.................... int1 IsLinked(void); 
....................  
.................... //this macro called by stack when new tcp/ip traffic tx/rx. 
.................... #if STACK_USE_WIFI 
....................    #define STACK_USE_CCS_TX_EVENT()  LinkTraffic(TRUE) 
....................    #define STACK_USE_CCS_RX_EVENT()  LinkTraffic(FALSE) 
....................    void LinkTraffic(int1 isTx); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS) 
....................    #include "TCPIP Stack/mpfs.h" 
....................     
....................    extern MPFS _MpfsEofLoc; 
....................     
....................    //returns number of bytes read before EOF. 
....................    //if it returns n then no EOF. 
....................    unsigned int16 MPFSGetBytes(unsigned int8 *pDest, unsigned int16 n); 
.................... #endif 
....................  
.................... #if defined(__PCH__) 
.................... TICK TickGetSafe(void); 
.................... #endif 
....................  
.................... BYTE GenerateRandomByteFromTimers(void); 
....................  
.................... #endif 
....................  
....................  
.................... #if STACK_USE_CCS_INI 
....................    #include "ee.h" 
....................    #include "ccsui.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS) 
....................    #if !defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)  
....................       #if defined(__PCD__) 
....................          #import(RAW, file="mpfs/mpfsimg.bin", location=MPFS_Start, bpi=2) 
....................       #else 
....................          #import(RAW, file="mpfs/mpfsimg.bin", location=MPFS_Start) 
....................       #endif 
....................    #endif 
.................... #endif 
....................  
....................  
.................... void DebugPutc(char c) 
.................... { 
....................    fputc(c, STREAM_UI); 
.................... } 
....................  
.................... //#define debug_tftp   printf 
.................... //#define debug_tftp_putc DebugPutc 
....................  
.................... //#define debug_html         printf 
.................... //#define debug_html_putc    DebugPutc 
....................  
.................... //#define debug_mpfs         printf 
.................... //#define debug_mpfs_putc    DebugPutc 
....................  
.................... //#define debug_enc28j60  printf 
.................... //#define debug_enc28j60_putc  DebugPutc 
.................... //void MACToString(char *str, MAC_ADDR *mac); 
....................  
.................... //#define debug_dhcp   printf 
.................... //#define debug_dhcp_putc DebugPutc 
....................  
.................... //#define debug_tcp printf 
.................... //#define debug_tcp_putc  DebugPutc 
....................  
.................... #include "tcpip/StackTsk2.c" 
.................... // 'glue' file for using Microchip's TCP/IP stack inside CCS C Compiler without 
.................... // a linker.   
.................... // Also includes some macros/defines for porting older V3 stack to this current 
.................... // stack. 
.................... // Also provides extra routines written by CCS to improve the stack. 
.................... // 
.................... // __DISABLE_WIFI_INTERRUPT__ was supported in an older 5.3x version of the 
.................... // stack, but it is currently not supported anymore. 
....................  
.................... #ifndef __CCS_STACKTSK2_C__ 
.................... #define __CCS_STACKTSK2_C__ 
....................  
.................... #if defined(__DISABLE_WIFI_INTERRUPT__) 
....................    #error This has been removed. 
.................... #endif 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if defined(__PCH__) 
.................... #int_timer0 NOCLEAR 
.................... void ISRTimer0(void) 
.................... { 
....................    TickUpdate(); 
*
000B8:  BRA    009E
.................... } 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) && !defined(__DISABLE_WIFI_INTERRUPT__) 
.................... #int_EXT HIGH NOCLEAR 
....................    void ISREXT0(void) 
....................    { 
....................          WFEintISR(); 
....................        
....................    } 
.................... #endif 
....................  
.................... #if defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    int1 g_WifiAdhocIsConn = FALSE; 
....................    TICK g_WifiAdhocTickConn; 
....................    #define WIFIAdhocConnectionPing()   g_WifiAdhocIsConn=TRUE; g_WifiAdhocTickConn=TickGet() 
....................    #define WIFIAdhocConnectionReset()  g_WifiAdhocIsConn = FALSE 
.................... #endif 
....................  
.................... #include "StackTsk.c" 
.................... /********************************************************************* 
....................  * 
....................  *   TCP/IP Stack Manager 
....................  *  Module for Microchip TCP/IP Stack 
....................  *    -Handles internal RX packet pre-processing prior to dispatching  
....................  *    to upper application layers. 
....................  *    -Reference: AN833 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.c 
....................  * Dependencies:    ARP, IP, Network layer interface (ENC28J60.c,  
....................  *               ETH97J60.c, ENCX24J600.c, or WFMac.c) 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  * 
....................  * Darren Rook/CCS       4/13/11    Added some CCS modules (see STACK_USE_CCS_*) 
....................  *                                  Added STACK_USE_CCS_RX_EVENT() macro on TCP/IP traffic.  
.................... ********************************************************************/ 
.................... #define __STACKTSK_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
000BA:  GOTO   0058
.................... #if defined( WF_CS_TRIS ) 
....................     #if defined( WF_CONFIG_CONSOLE ) 
....................         #include "TCPIP Stack/WFConsole.h" 
....................     #endif 
....................     #if defined( STACK_USE_EZ_CONFIG ) || defined( EZ_CONFIG_SCAN ) 
....................         #include "TCPIP Stack/WFEasyConfig.h" 
....................     #endif 
....................    #include "TCPIP Stack/WFApi.h" 
.................... #endif 
....................  
.................... // Stack FSM states. 
.................... typedef enum 
.................... { 
....................     SM_STACK_IDLE, 
....................     SM_STACK_MAC, 
....................     SM_STACK_IP, 
....................     SM_STACK_ARP, 
....................     SM_STACK_TCP, 
....................     SM_STACK_UDP 
.................... } SM_STACK; 
.................... static SM_STACK smStack; 
....................  
.................... NODE_INFO remoteNode; 
....................  
.................... #if defined (WF_CS_TRIS) && defined (STACK_USE_DHCP_CLIENT) 
.................... BOOL g_DhcpRenew = FALSE; 
.................... extern void SetDhcpProgressState(void); 
.................... UINT32 g_DhcpRetryTimer = 0; 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componets are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines are used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void) 
.................... { 
....................    static BOOL once = FALSE; 
....................     smStack                     = SM_STACK_IDLE; 
*
00DC0:  CLRF   5D
....................  
.................... #if defined(STACK_USE_IP_GLEANING) || defined(STACK_USE_DHCP_CLIENT) 
....................     /* 
....................      * If DHCP or IP Gleaning is enabled, 
....................      * startup in Config Mode. 
....................      */ 
....................     AppConfig.Flags.bInConfigMode = TRUE; 
....................  
.................... #endif 
....................  
.................... #if defined (WF_CS_TRIS) && defined (STACK_USE_DHCP_CLIENT) 
....................    g_DhcpRenew = FALSE; 
....................    g_DhcpRetryTimer = 0; 
.................... #endif 
....................  
....................    if (!once) { 
00DC2:  BTFSC  x68.0
00DC4:  BRA    0DF0
....................       // Seed the LFSRRand() function 
....................       LFSRSeedRand(GenerateRandomDWORD()); 
00DC6:  CALL   045C
00DCA:  MOVFF  03,171
00DCE:  MOVFF  02,170
00DD2:  MOVFF  01,16F
00DD6:  MOVFF  00,16E
00DDA:  MOVFF  03,192
00DDE:  MOVFF  02,191
00DE2:  MOVFF  01,190
00DE6:  MOVFF  00,18F
00DEA:  CALL   03FA
....................       once = TRUE; 
00DEE:  BSF    x68.0
....................    } 
....................  
....................     MACInit(); 
00DF0:  GOTO   05DA
....................  
.................... #if defined (WF_AGGRESSIVE_PS) && defined (WF_CS_TRIS) 
....................    WFEnableAggressivePowerSave(); 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) && defined(STACK_USE_EZ_CONFIG) && !defined(__18CXX) 
....................     WFEasyConfigInit(); 
.................... #endif     
....................  
....................     ARPInit(); 
00DF4:  BRA    06A8
....................  
.................... #if defined(STACK_USE_UDP) 
....................     UDPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
....................     TCPInit(); 
00DF6:  BRA    0C1E
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
....................    BerkeleySocketInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
....................     HTTPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
....................    RSAInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
....................     SSLInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) && defined(STACK_USE_MPFS2) 
....................     FTPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
....................    SNMPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) 
....................    DHCPInit(0); 
....................     if(!AppConfig.Flags.bIsDHCPEnabled) 
....................     { 
....................         DHCPDisable(0); 
....................     } 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     AutoIPInit(0); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
....................    DDNSInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
....................    RandomInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SMTP) 
....................    SMTPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    NTPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_GRATUITOUS_ARP) 
....................    GratArpInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP1_SERVER) || defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    HTTPInit(); 
.................... #endif 
....................  
....................    #if defined(STACK_USE_CCS_TFTP_SERVER) 
00DF8:  GOTO   5722 (RETURN)
....................    TFTPSInit(); 
....................    #endif 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically to 
....................  *                  ensure timely responses. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void) 
.................... { 
....................     WORD dataCount; 
....................     IP_ADDR tempLocalIP; 
....................    BYTE cFrameType; 
....................    BYTE cIPFrameType; 
....................  
....................     
....................     #if defined( WF_CS_TRIS ) 
....................         // This task performs low-level MAC processing specific to the MRF24W 
....................         MACProcess(); 
....................         #if defined( STACK_USE_EZ_CONFIG ) && !defined(__18CXX) 
....................             WFEasyConfigMgr(); 
....................         #endif 
....................          
....................        #if defined(STACK_USE_DHCP_CLIENT) 
....................            // Normally, an application would not include  DHCP module 
....................            // if it is not enabled. But in case some one wants to disable 
....................            // DHCP module at run-time, remember to not clear our IP 
....................            // address if link is removed. 
....................            if(AppConfig.Flags.bIsDHCPEnabled) 
....................            { 
....................               if(g_DhcpRenew == TRUE) 
....................               { 
....................                  g_DhcpRenew = FALSE; 
....................                   AppConfig.MyIPAddr.Val = AppConfig.DefaultIPAddr.Val; 
....................                  AppConfig.MyMask.Val = AppConfig.DefaultMask.Val; 
....................                  AppConfig.Flags.bInConfigMode = TRUE; 
....................                  DHCPInit(0); 
....................                g_DhcpRetryTimer = (UINT32)TickGet(); 
....................               } else { 
....................                  if (g_DhcpRetryTimer && TickGet() - g_DhcpRetryTimer >= TICKS_PER_SECOND * 8) { 
....................                   DHCPInit(0); 
....................                   g_DhcpRetryTimer = (UINT32)TickGet(); 
....................                  } 
....................               } 
....................             
....................               // DHCP must be called all the time even after IP configuration is 
....................               // discovered. 
....................               // DHCP has to account lease expiration time and renew the configuration 
....................               // time. 
....................               DHCPTask(); 
....................                
....................               if(DHCPIsBound(0)) { 
....................                  AppConfig.Flags.bInConfigMode = FALSE; 
....................                g_DhcpRetryTimer = 0; 
....................               } 
....................            } 
....................        #endif // STACK_USE_DHCP_CLIENT 
....................          
....................     #endif // WF_CS_TRIS 
....................  
....................  
....................    #if defined(STACK_USE_DHCP_CLIENT) && !defined(WF_CS_TRIS) 
....................    // Normally, an application would not include  DHCP module 
....................    // if it is not enabled. But in case some one wants to disable 
....................    // DHCP module at run-time, remember to not clear our IP 
....................    // address if link is removed. 
....................    if(AppConfig.Flags.bIsDHCPEnabled) 
....................    { 
....................       static BOOL bLastLinkState = FALSE; 
....................       BOOL bCurrentLinkState; 
....................        
....................       bCurrentLinkState = MACIsLinked(); 
....................       if(bCurrentLinkState != bLastLinkState) 
....................       { 
....................          bLastLinkState = bCurrentLinkState; 
....................          if(!bCurrentLinkState) 
....................          { 
....................             AppConfig.MyIPAddr.Val = AppConfig.DefaultIPAddr.Val; 
....................             AppConfig.MyMask.Val = AppConfig.DefaultMask.Val; 
....................             AppConfig.Flags.bInConfigMode = TRUE; 
....................             DHCPInit(0); 
....................          } 
....................       } 
....................     
....................       // DHCP must be called all the time even after IP configuration is 
....................       // discovered. 
....................       // DHCP has to account lease expiration time and renew the configuration 
....................       // time. 
....................       DHCPTask(); 
....................        
....................       if(DHCPIsBound(0)) 
....................          AppConfig.Flags.bInConfigMode = FALSE; 
....................    } 
....................    #endif 
....................     
....................  
....................     #if defined (STACK_USE_AUTO_IP) 
....................     AutoIPTasks(); 
....................     #endif 
....................  
....................    #if defined(STACK_USE_TCP) 
....................    // Perform all TCP time related tasks (retransmit, send acknowledge, close connection, etc) 
....................    TCPTick(); 
*
049F8:  GOTO   224E
....................    #endif 
....................  
....................  
....................    #if defined(STACK_USE_UDP) 
....................    UDPTask(); 
....................    #endif 
....................  
....................   #if defined(STACK_USE_CCS_GRATUITOUS_ARP) 
....................    GratArpTask(); 
....................   #endif 
....................  
....................    // Process as many incomming packets as we can 
....................    while(1) 
....................    { 
....................       //if using the random module, generate entropy 
....................       #if defined(STACK_USE_RANDOM) 
....................          RandomAdd(remoteNode.MACAddr.v[5]); 
....................       #endif 
....................  
....................       // We are about to fetch a new packet, make sure that the  
....................       // UDP module knows that any old RX data it has laying  
....................       // around will now be gone. 
....................       #if defined(STACK_USE_UDP) 
....................          UDPDiscard(); 
....................       #endif 
....................  
....................       // Fetch a packet (throws old one away, if not thrown away  
....................       // yet) 
....................       if(!MACGetHeader(&remoteNode.MACAddr, &cFrameType)) 
049FC:  MOVLB  1
049FE:  CLRF   x77
04A00:  MOVLW  62
04A02:  MOVWF  x76
04A04:  MOVLW  01
04A06:  MOVWF  x79
04A08:  MOVLW  74
04A0A:  MOVWF  x78
04A0C:  MOVLB  0
04A0E:  GOTO   2B06
04A12:  MOVF   01,F
04A14:  BNZ   4A18
....................          break; 
04A16:  BRA    4B2E
....................  
....................       // When using a WiFi module, filter out all incoming packets that have  
....................       // the same source MAC address as our own MAC address.  This is to  
....................       // prevent receiving and passing our own broadcast packets up to other  
....................       // layers and avoid, for example, having our own gratuitous ARPs get  
....................       // answered by ourself. 
....................       #if defined(WF_CS_TRIS) 
....................          if(memcmp((void*)&remoteNode.MACAddr, (void*)&AppConfig.MyMACAddr, 6) == 0u) 
....................             continue; 
....................       #endif 
....................        
....................       #if defined(STACK_USE_CCS_RX_EVENT) 
....................       STACK_USE_CCS_RX_EVENT();  //__CCS__ 
....................       #endif 
....................        
....................       // Dispatch the packet to the appropriate handler 
....................       switch(cFrameType) 
04A18:  MOVLB  1
04A1A:  MOVF   x74,W
04A1C:  XORLW  06
04A1E:  MOVLB  0
04A20:  BZ    4A28
04A22:  XORLW  06
04A24:  BZ    4A2E
04A26:  BRA    4B2C
....................       { 
....................          case MAC_ARP: 
....................             ARPProcess(); 
04A28:  GOTO   2C18
....................             break; 
04A2C:  BRA    4B2C
....................     
....................          case MAC_IP: 
....................             if(!IPGetHeader(&tempLocalIP, &remoteNode, &cIPFrameType, &dataCount)) 
04A2E:  MOVLW  01
04A30:  MOVLB  1
04A32:  MOVWF  x77
04A34:  MOVLW  70
04A36:  MOVWF  x76
04A38:  CLRF   x79
04A3A:  MOVLW  5E
04A3C:  MOVWF  x78
04A3E:  MOVLW  01
04A40:  MOVWF  x7B
04A42:  MOVLW  75
04A44:  MOVWF  x7A
04A46:  MOVLW  01
04A48:  MOVWF  x7D
04A4A:  MOVLW  6E
04A4C:  MOVWF  x7C
04A4E:  MOVLB  0
04A50:  GOTO   2E1A
04A54:  MOVF   01,F
04A56:  BNZ   4A5A
....................                break; 
04A58:  BRA    4B2C
....................  
....................             #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................             if(cIPFrameType == IP_PROT_ICMP) 
04A5A:  MOVLB  1
04A5C:  DECFSZ x75,W
04A5E:  BRA    4B06
....................             { 
....................                #if defined(STACK_USE_IP_GLEANING) 
....................                if(AppConfig.Flags.bInConfigMode && AppConfig.Flags.bIsDHCPEnabled) 
....................                { 
....................                   // According to "IP Gleaning" procedure, 
....................                   // when we receive an ICMP packet with a valid 
....................                   // IP address while we are still in configuration 
....................                   // mode, accept that address as ours and conclude 
....................                   // configuration mode. 
....................                   if(tempLocalIP.Val != 0xffffffff) 
....................                   { 
....................                      AppConfig.Flags.bInConfigMode = FALSE; 
....................                      AppConfig.MyIPAddr = tempLocalIP; 
....................                   } 
....................                } 
....................                #endif 
....................  
....................                // Process this ICMP packet if it the destination IP address matches our address or one of the broadcast IP addressees 
....................                if( (tempLocalIP.Val == AppConfig.MyIPAddr.Val) || 
....................                   (tempLocalIP.Val == 0xFFFFFFFF) || 
.................... #if defined(STACK_USE_ZEROCONF_LINK_LOCAL) || defined(STACK_USE_ZEROCONF_MDNS_SD) 
....................                                                 (tempLocalIP.Val == 0xFB0000E0) || 
.................... #endif 
....................                   (tempLocalIP.Val == ((AppConfig.MyIPAddr.Val & AppConfig.MyMask.Val) | ~AppConfig.MyMask.Val))) 
04A60:  MOVF   2A,W
04A62:  SUBWF  x70,W
04A64:  BNZ   4A78
04A66:  MOVF   2B,W
04A68:  SUBWF  x71,W
04A6A:  BNZ   4A78
04A6C:  MOVF   2C,W
04A6E:  SUBWF  x72,W
04A70:  BNZ   4A78
04A72:  MOVF   2D,W
04A74:  SUBWF  x73,W
04A76:  BZ    4AEA
04A78:  INCFSZ x70,W
04A7A:  BRA    4A8A
04A7C:  INCFSZ x71,W
04A7E:  BRA    4A8A
04A80:  INCFSZ x72,W
04A82:  BRA    4A8A
04A84:  INCFSZ x73,W
04A86:  BRA    4A8A
04A88:  BRA    4AEA
04A8A:  MOVF   2A,W
04A8C:  ANDWF  2E,W
04A8E:  MOVWF  x76
04A90:  MOVF   2B,W
04A92:  ANDWF  2F,W
04A94:  MOVWF  x77
04A96:  MOVF   2C,W
04A98:  ANDWF  30,W
04A9A:  MOVWF  x78
04A9C:  MOVF   2D,W
04A9E:  ANDWF  31,W
04AA0:  MOVWF  x79
04AA2:  MOVFF  2E,00
04AA6:  COMF   00,F
04AA8:  MOVFF  2F,01
04AAC:  COMF   01,F
04AAE:  MOVFF  30,02
04AB2:  COMF   02,F
04AB4:  MOVFF  31,03
04AB8:  COMF   03,F
04ABA:  MOVF   00,W
04ABC:  IORWF  x76,W
04ABE:  MOVWF  00
04AC0:  MOVF   01,W
04AC2:  IORWF  x77,W
04AC4:  MOVWF  01
04AC6:  MOVF   02,W
04AC8:  IORWF  x78,W
04ACA:  MOVWF  02
04ACC:  MOVF   03,W
04ACE:  IORWF  x79,W
04AD0:  MOVWF  03
04AD2:  MOVF   00,W
04AD4:  SUBWF  x70,W
04AD6:  BNZ   4B00
04AD8:  MOVF   01,W
04ADA:  SUBWF  x71,W
04ADC:  BNZ   4B00
04ADE:  MOVF   02,W
04AE0:  SUBWF  x72,W
04AE2:  BNZ   4B00
04AE4:  MOVF   03,W
04AE6:  SUBWF  x73,W
04AE8:  BNZ   4B00
....................                { 
....................                   ICMPProcess(&remoteNode, dataCount); 
04AEA:  CLRF   x77
04AEC:  MOVLW  5E
04AEE:  MOVWF  x76
04AF0:  MOVFF  16F,179
04AF4:  MOVFF  16E,178
04AF8:  MOVLB  0
04AFA:  GOTO   2F1E
04AFE:  MOVLB  1
....................                } 
....................  
....................                break; 
04B00:  MOVLB  0
04B02:  BRA    4B2C
04B04:  MOVLB  1
....................             } 
....................             #endif 
....................              
....................             #if defined(STACK_USE_TCP) 
....................             if(cIPFrameType == IP_PROT_TCP) 
04B06:  MOVF   x75,W
04B08:  SUBLW  06
04B0A:  BNZ   4B2A
....................             { 
....................                TCPProcess(&remoteNode, &tempLocalIP, dataCount); 
04B0C:  CLRF   x77
04B0E:  MOVLW  5E
04B10:  MOVWF  x76
04B12:  MOVLW  01
04B14:  MOVWF  x79
04B16:  MOVLW  70
04B18:  MOVWF  x78
04B1A:  MOVFF  16F,17B
04B1E:  MOVFF  16E,17A
04B22:  MOVLB  0
04B24:  BRA    487C
....................                break; 
04B26:  BRA    4B2C
04B28:  MOVLB  1
....................             } 
....................             #endif 
....................              
....................             #if defined(STACK_USE_UDP) 
....................             if(cIPFrameType == IP_PROT_UDP) 
....................             { 
....................                // Stop processing packets if we came upon a UDP frame with application data in it 
....................                if(UDPProcess(&remoteNode, &tempLocalIP, dataCount)) 
....................                   return; 
....................             } 
....................             #endif 
....................  
....................             break; 
04B2A:  MOVLB  0
....................       } 
04B2C:  BRA    49FC
....................    } 
04B2E:  GOTO   5728 (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackApplications(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Calls all loaded application modules. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called periodically to 
....................  *                  ensure timely responses. 
....................  * 
....................  ********************************************************************/ 
.................... void StackApplications(void) 
.................... { 
....................    #if defined(STACK_USE_HTTP2_SERVER) 
....................    HTTPServer(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_FTP_SERVER) && defined(STACK_USE_MPFS2) 
....................    FTPServer(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_SNMP_SERVER) 
....................    SNMPTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_ANNOUNCE) 
....................    DiscoveryTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_NBNS) 
....................    NBNSTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_DHCP_SERVER) 
....................    DHCPServerTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_DNS_SERVER) 
....................    DNSServerTask(); 
....................    #endif 
....................     
....................    #if defined (STACK_USE_DYNAMICDNS_CLIENT) 
....................    DDNSTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_TELNET_SERVER) 
....................    TelnetTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_REBOOT_SERVER) 
....................    RebootTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_SNTP_CLIENT) 
....................    SNTPClient(); 
....................    #endif 
....................  
....................    #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
....................    UDPPerformanceTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
....................    TCPPerformanceTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_SMTP_CLIENT) 
....................    SMTPTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_UART2TCP_BRIDGE) 
....................    UART2TCPBridgeTask(); 
....................    #endif 
....................  
....................    #if defined(STACK_USE_CCS_SMTP) 
....................    SMTPTask(); 
....................    #endif    
....................  
....................    #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    NTPTask(); 
....................    #endif 
....................  
....................    #if defined(STACK_USE_CCS_HTTP1_SERVER) || defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    HTTPServer(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_CCS_TFTP_SERVER) 
....................    TFTPSTask(); 
....................    #endif 
....................  
....................    #if defined(STACK_USE_TWITTER)   //should be renamed STACK_USE_CCS_TWITTER 
....................    TwitterTask();         // processes TCP tasks including the Tweet tasks 
....................    #endif    
.................... } 
....................  
.................... #if defined(WF_CS_TRIS) && defined(STACK_USE_DHCP_CLIENT) 
.................... void RenewDhcp(void) 
.................... { 
....................     g_DhcpRenew = TRUE; 
....................     SetDhcpProgressState(); 
.................... }     
....................      
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "Helpers.c" 
.................... /********************************************************************* 
....................   
....................  Helper Functions for Microchip TCPIP Stack 
....................   
....................  FileName:      Helpers.c 
....................  Dependencies:  See INCLUDES section 
....................  Processor:     PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:      Microchip C18, C30, C32 
....................  Company:       Microchip Technology, Inc. 
....................  
....................  Software License Agreement 
....................  
....................  Copyright (C) 2002-2011 Microchip Technology Inc.  All rights 
....................  reserved. 
....................  
....................  Microchip licenses to you the right to use, modify, copy, and 
....................  distribute: 
....................  (i)  the Software when embedded on a Microchip microcontroller or 
....................       digital signal controller product ("Device") which is 
....................       integrated into Licensee's product; or 
....................  (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................       ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................       used in conjunction with a Microchip ethernet controller for 
....................       the sole purpose of interfacing with the ethernet controller. 
....................  
....................  You should refer to the license agreement accompanying this 
....................  Software for additional information regarding your rights and 
....................  obligations. 
....................  
....................  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  
....................  ******************************************************************** 
....................  File Description: 
....................   
....................  Change History: 
....................   
....................   Rev         Description 
....................   ----------  ------------------------------------------------------- 
....................   1.0 - 5.31  Initial release; Rewritten CalcIPChecksum() to avoid 
....................               multi-byte shift operation; Added hexatob(), 
....................               btohexa_high(), and btohexa_low(); Optimized swapl(); 
....................               Added leftRotateDWORD() 
....................   5.36        Updated compile time check for ultoa(); 
....................  
....................    DARREN ROOK/CCS   Remove leftRotateDWORD() 
....................  
....................  ********************************************************************/ 
.................... #define __HELPERS_C 
....................  
.................... #include <stdarg.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDARG 
....................  
.................... #define _STDARG 
....................  
.................... typedef char * va_list; 
....................  
.................... #define va_start(a,b)  a=_VA_LIST 
.................... #define va_arg(a,b)    *(b *)_va_arg(a) 
.................... #define va_end 
.................... #define nargs          _nargs(&_va_list) 
....................  
.................... int8 _nargs(int8 * ptr) { 
....................   int8 n; 
....................  
....................   n=0; 
....................   while(*ptr) { 
....................     n++; 
....................     ptr+=*ptr; 
....................   } 
....................   return(n); 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
....................  
.................... // Default Random Number Generator seed. 0x41FE9F9E corresponds to calling LFSRSeedRand(1) 
.................... static DWORD dwLFSRRandSeed = 0x41FE9F9E; 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    DWORD LFSRSeedRand(DWORD dwSeed) 
....................  
....................   Summary: 
....................    Seeds the LFSR random number generator invoked by the LFSRRand() function.   
....................    The prior seed is returned. 
....................  
....................   Description: 
....................    Seeds the LFSR random number generator invoked by the LFSRRand() function.   
....................    The prior seed is returned. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    wSeed - The new 32-bit seed value to assign to the LFSR. 
....................  
....................   Returns: 
....................      The last seed in use.  This can be saved and restored by a subsequent call  
....................    to LFSRSeedRand() if you wish to use LFSRRand() in multiple contexts  
....................    without disrupting the random number sequence from the alternative  
....................    context.  For example, if App 1 needs a given sequence of random numbers  
....................    to perform a test, if you save and restore the seed in App 2, it is  
....................    possible for App 2 to not disrupt the random number sequence provided to  
....................    App 1, even if the number of times App 2 calls LFSRRand() varies. 
....................       
....................   Side Effects: 
....................    None 
....................     
....................   Remarks: 
....................    Upon initial power up, the internal seed is initialized to 0x1.  Using a  
....................    dwSeed value of 0x0 will return the same sequence of random numbers as  
....................    using the seed of 0x1. 
....................   ***************************************************************************/ 
.................... DWORD LFSRSeedRand(DWORD dwSeed) 
.................... { 
....................    DWORD dwOldSeed; 
....................    BYTE i; 
....................  
....................    // Save original seed to be returned later 
....................    dwOldSeed = dwLFSRRandSeed; 
*
003FA:  MOVFF  6C,196
003FE:  MOVFF  6B,195
00402:  MOVFF  6A,194
00406:  MOVFF  69,193
....................  
....................    // Ensure zero isn't selected as a seed value, this would result in all  
....................    // 0x0000 output values from the LFSR 
....................    if(dwSeed == 0u) 
0040A:  MOVLB  1
0040C:  MOVF   x8F,F
0040E:  BNZ   0426
00410:  MOVF   x90,F
00412:  BNZ   0426
00414:  MOVF   x91,F
00416:  BNZ   0426
00418:  MOVF   x92,F
0041A:  BNZ   0426
....................       dwSeed = 1; 
0041C:  CLRF   x92
0041E:  CLRF   x91
00420:  CLRF   x90
00422:  MOVLW  01
00424:  MOVWF  x8F
....................        
....................    // Set the new seed 
....................    dwLFSRRandSeed = dwSeed; 
00426:  MOVFF  192,6C
0042A:  MOVFF  191,6B
0042E:  MOVFF  190,6A
00432:  MOVFF  18F,69
....................     
....................    // Run the LFSR a few times to get rid of obvious start up artifacts for  
....................    // seed values that don't have many set bits. 
....................    for(i = 0; i < 16; i++) 
00436:  CLRF   x97
00438:  MOVF   x97,W
0043A:  SUBLW  0F
0043C:  BNC   0448
....................       LFSRRand(); 
0043E:  MOVLB  0
00440:  RCALL  035C
00442:  MOVLB  1
00444:  INCF   x97,F
00446:  BRA    0438
....................     
....................    // Return saved old seed 
....................    return dwOldSeed; 
00448:  MOVFF  193,00
0044C:  MOVFF  194,01
00450:  MOVFF  195,02
00454:  MOVFF  196,03
00458:  MOVLB  0
0045A:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD LFSRRand(void) 
....................  
....................   Summary: 
....................    Returns a pseudo-random 16-bit unsigned integer in the range from 0  
....................    to 65535 (0x0000 to 0xFFFF). 
....................  
....................   Description: 
....................    Returns a pseudo-random 16-bit unsigned integer in the range from 0  
....................    to 65535 (0x0000 to 0xFFFF).  The random number is generated using a  
....................    Linear Feedback Shift Register (LFSR) type pseudo-random number generator  
....................    algorithm.  The LFSR can be seeded by calling the LFSRSeedRand() function 
....................    to generate the same sequence of random numbers as a prior string of calls. 
....................     
....................    The internal LFSR will repeat after 2^32-1 iterations. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................      Random 16-bit unsigned integer. 
....................       
....................   Side Effects: 
....................    The internal LFSR seed is updated so that the next call to LFSRRand()  
....................    will return a different random number. 
....................     
....................   Remarks: 
....................    None 
....................   ***************************************************************************/ 
.................... WORD LFSRRand(void) 
.................... { 
....................    BYTE i; 
....................     
....................    // Taps: 32 31 29 1 
....................    // Characteristic polynomial: x^32 + x^31 + x^29 + x + 1 
....................    // Repeat 15 times to make the shift pattern less obvious 
....................    for(i = 0; i < 15; i++) 
*
0035C:  MOVLB  2
0035E:  CLRF   x6F
00360:  MOVF   x6F,W
00362:  SUBLW  0E
00364:  BNC   03EE
....................       dwLFSRRandSeed = (dwLFSRRandSeed >> 1) ^ ((0ul - (dwLFSRRandSeed & 1ul)) & 0xD0000001ul); 
00366:  BCF    FD8.0
00368:  MOVLB  0
0036A:  RRCF   x6C,W
0036C:  MOVLB  2
0036E:  MOVWF  x74
00370:  MOVLB  0
00372:  RRCF   x6B,W
00374:  MOVLB  2
00376:  MOVWF  x73
00378:  MOVLB  0
0037A:  RRCF   x6A,W
0037C:  MOVLB  2
0037E:  MOVWF  x72
00380:  MOVLB  0
00382:  RRCF   x69,W
00384:  MOVLB  2
00386:  MOVWF  x71
00388:  MOVLB  0
0038A:  MOVF   x69,W
0038C:  ANDLW  01
0038E:  MOVWF  00
00390:  CLRF   01
00392:  CLRF   02
00394:  CLRF   03
00396:  MOVLW  00
00398:  BSF    FD8.0
0039A:  SUBFWB 00,W
0039C:  MOVLB  2
0039E:  MOVWF  x75
003A0:  MOVLW  00
003A2:  SUBFWB 01,W
003A4:  MOVWF  x76
003A6:  MOVLW  00
003A8:  SUBFWB 02,W
003AA:  MOVWF  x77
003AC:  MOVLW  00
003AE:  SUBFWB 03,W
003B0:  MOVWF  x78
003B2:  MOVF   x75,W
003B4:  ANDLW  01
003B6:  MOVWF  00
003B8:  CLRF   01
003BA:  CLRF   02
003BC:  MOVF   x78,W
003BE:  ANDLW  D0
003C0:  MOVWF  03
003C2:  MOVF   00,W
003C4:  XORWF  x71,W
003C6:  MOVLB  0
003C8:  MOVWF  x69
003CA:  MOVF   01,W
003CC:  MOVLB  2
003CE:  XORWF  x72,W
003D0:  MOVLB  0
003D2:  MOVWF  x6A
003D4:  MOVF   02,W
003D6:  MOVLB  2
003D8:  XORWF  x73,W
003DA:  MOVLB  0
003DC:  MOVWF  x6B
003DE:  MOVF   03,W
003E0:  MOVLB  2
003E2:  XORWF  x74,W
003E4:  MOVLB  0
003E6:  MOVWF  x6C
003E8:  MOVLB  2
003EA:  INCF   x6F,F
003EC:  BRA    0360
....................  
....................    // Return 16-bits as pseudo-random number 
....................    return (WORD)dwLFSRRandSeed; 
003EE:  MOVLB  0
003F0:  MOVFF  69,01
003F4:  MOVFF  6A,02
003F8:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    DWORD GenerateRandomDWORD(void) 
....................  
....................   Summary: 
....................    Generates a random DWORD. 
....................  
....................   Description: 
....................    This function generates a random 32-bit integer.  It collects 
....................    randomness by comparing the A/D converter's internal R/C oscillator 
....................    clock with our main system clock.  By passing collected entropy to the 
....................    LFSRSeedRand()/LFSRRand() functions, the output is normalized (deskewed)  
....................    in the hopes of meeting statistical randomness tests. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................      Random 32-bit number. 
....................       
....................   Side Effects: 
....................    This function uses the A/D converter (and so you must disable  
....................    interrupts if you use the A/D converted in your ISR).  The LFSRRand()  
....................    function will be reseeded, and Timer0 (PIC18) and Timer1 (PIC24,  
....................    dsPIC, and PIC32) will be used.  TMR#H:TMR#L will have a new value. 
....................    Note that this is the same timer used by the Tick module. 
....................     
....................   Remarks: 
....................    This function times out after 1 second of attempting to generate the  
....................    random DWORD.  In such a case, the output may not be truly random.   
....................    Typically, this function executes in around 500,000 instruction cycles. 
....................     
....................    The intent of this function is to produce statistically random and 
....................    cryptographically secure random number.  Whether or not this is true on 
....................    all (or any) devices/voltages/temperatures is not tested. 
....................   ***************************************************************************/ 
.................... DWORD GenerateRandomDWORD(void) 
.................... { 
....................    BYTE vBitCount; 
....................    WORD w, wTime, wLastValue; 
....................    DWORD dwTotalTime; 
....................    union 
....................    { 
....................       DWORD   dw; 
....................       WORD   w[2]; 
....................    } randomResult; 
....................  
.................... #if defined __18CXX    
.................... { 
....................    BYTE ADCON0Save, ADCON2Save; 
....................    BYTE T0CONSave, TMR0HSave, TMR0LSave; 
....................  
....................    // Save hardware SFRs 
....................    ADCON0Save = ADCON0; 
*
0045C:  MOVFF  FC2,188
....................    ADCON2Save = ADCON2; 
00460:  MOVFF  FC0,189
....................    T0CONSave = T0CON; 
00464:  MOVFF  FD5,18A
....................    TMR0LSave = TMR0L; 
00468:  MOVFF  FD6,18C
....................    TMR0HSave = TMR0H; 
0046C:  MOVFF  FD7,18B
....................  
....................    // Set up Timer and A/D converter module 
....................    ADCON0 = 0x01;   // Turn on the A/D module 
00470:  MOVLW  01
00472:  MOVWF  FC2
....................    ADCON2 = 0x3F;   // 20 Tad acquisition, Frc A/D clock used for conversion 
00474:  MOVLW  3F
00476:  MOVWF  FC0
....................    T0CON = 0x88;   // TMR0ON = 1, no prescalar 
00478:  MOVLW  88
0047A:  MOVWF  FD5
....................    vBitCount = 0; 
0047C:  MOVLB  1
0047E:  CLRF   x79
....................    dwTotalTime = 0; 
00480:  CLRF   x83
00482:  CLRF   x82
00484:  CLRF   x81
00486:  CLRF   x80
....................    wLastValue = 0; 
00488:  CLRF   x7F
0048A:  CLRF   x7E
....................    randomResult.dw = LFSRRand(); 
0048C:  MOVLB  0
0048E:  RCALL  035C
00490:  MOVLB  1
00492:  CLRF   x87
00494:  CLRF   x86
00496:  MOVFF  02,185
0049A:  MOVFF  01,184
....................    while(1) 
....................    { 
....................       // Time the duration of an A/D acquisition and conversion 
....................       TMR0H = 0x00; 
0049E:  CLRF   FD7
....................       TMR0L = 0x00; 
004A0:  CLRF   FD6
....................       ADCON0bits.GO = 1; 
004A2:  BSF    FC2.1
....................       ClrWdt(); 
004A4:  CLRWDT
....................       while(ADCON0bits.GO); 
004A6:  BTFSC  FC2.1
004A8:  BRA    04A6
....................       ((BYTE*)&wTime)[0] = TMR0L; 
004AA:  MOVFF  FD6,17C
....................       ((BYTE*)&wTime)[1] = TMR0H; 
004AE:  MOVFF  FD7,17D
....................       w = LFSRRand(); 
004B2:  MOVLB  0
004B4:  RCALL  035C
004B6:  MOVFF  02,17B
004BA:  MOVFF  01,17A
....................     
....................       // Wait no longer than 1 second obtaining entropy 
....................       dwTotalTime += wTime; 
004BE:  MOVLB  1
004C0:  MOVF   x7C,W
004C2:  ADDWF  x80,F
004C4:  MOVF   x7D,W
004C6:  ADDWFC x81,F
004C8:  MOVLW  00
004CA:  ADDWFC x82,F
004CC:  ADDWFC x83,F
....................       if(dwTotalTime >= GetInstructionClock()) 
004CE:  MOVF   x83,F
004D0:  BNZ   04EC
004D2:  MOVF   x82,W
004D4:  SUBLW  9D
004D6:  BC    050A
004D8:  XORLW  FF
004DA:  BNZ   04EC
004DC:  MOVF   x81,W
004DE:  SUBLW  F1
004E0:  BC    050A
004E2:  XORLW  FF
004E4:  BNZ   04EC
004E6:  MOVF   x80,W
004E8:  SUBLW  19
004EA:  BC    050A
....................       { 
....................          randomResult.w[0] ^= LFSRRand(); 
004EC:  MOVLB  0
004EE:  RCALL  035C
004F0:  MOVF   01,W
004F2:  MOVLB  1
004F4:  XORWF  x84,F
004F6:  MOVF   02,W
004F8:  XORWF  x85,F
....................          randomResult.w[1] ^= LFSRRand(); 
004FA:  MOVLB  0
004FC:  RCALL  035C
004FE:  MOVF   01,W
00500:  MOVLB  1
00502:  XORWF  x86,F
00504:  MOVF   02,W
00506:  XORWF  x87,F
....................          break; 
00508:  BRA    0578
....................       } 
....................     
....................       // Keep sampling if minimal entropy was likely obtained this round 
....................       if(wLastValue == wTime) 
0050A:  MOVF   x7C,W
0050C:  SUBWF  x7E,W
0050E:  BNZ   0518
00510:  MOVF   x7D,W
00512:  SUBWF  x7F,W
00514:  BNZ   0518
....................          continue; 
00516:  BRA    049E
....................     
....................       // Add this entropy into the pseudo random number generator by reseeding 
....................       LFSRSeedRand(w + (wLastValue - wTime)); 
00518:  MOVF   x7C,W
0051A:  SUBWF  x7E,W
0051C:  MOVWF  00
0051E:  MOVF   x7D,W
00520:  SUBWFB x7F,W
00522:  MOVWF  03
00524:  MOVF   00,W
00526:  ADDWF  x7A,W
00528:  MOVWF  x8D
0052A:  MOVF   03,W
0052C:  ADDWFC x7B,W
0052E:  MOVWF  x8E
00530:  CLRF   x92
00532:  CLRF   x91
00534:  MOVWF  x90
00536:  MOVFF  18D,18F
0053A:  MOVLB  0
0053C:  RCALL  03FA
....................       wLastValue = wTime; 
0053E:  MOVFF  17D,17F
00542:  MOVFF  17C,17E
....................     
....................       // Accumulate at least 32 bits of randomness over time 
....................       randomResult.dw <<= 1; 
00546:  BCF    FD8.0
00548:  MOVLB  1
0054A:  RLCF   x84,F
0054C:  RLCF   x85,F
0054E:  RLCF   x86,F
00550:  RLCF   x87,F
....................       if(LFSRRand() & 0x0080) 
00552:  MOVLB  0
00554:  RCALL  035C
00556:  MOVFF  02,18E
0055A:  MOVFF  01,18D
0055E:  MOVLB  1
00560:  MOVF   01,W
00562:  ANDLW  80
00564:  MOVWF  00
00566:  CLRF   03
00568:  MOVF   00,W
0056A:  IORWF  03,W
0056C:  BZ    0570
....................          randomResult.w[0] |= 0x1; 
0056E:  BSF    x84.0
....................     
....................       // See if we've collected a fair amount of entropy and can quit early 
....................       if(++vBitCount == 0u) 
00570:  INCF   x79,F
00572:  BNZ   0576
....................          break; 
00574:  BRA    0578
00576:  BRA    049E
....................    } 
....................  
....................    // Restore hardware SFRs 
....................    ADCON0 = ADCON0Save; 
00578:  MOVFF  188,FC2
....................    ADCON2 = ADCON2Save; 
0057C:  MOVFF  189,FC0
....................    TMR0H = TMR0HSave; 
00580:  MOVFF  18B,FD7
....................    TMR0L = TMR0LSave; 
00584:  MOVFF  18C,FD6
....................    T0CON = T0CONSave; 
00588:  MOVFF  18A,FD5
.................... } 
.................... #else 
.................... { 
....................    WORD AD1CON1Save, AD1CON2Save, AD1CON3Save; 
....................    WORD T1CONSave, PR1Save; 
....................  
....................    // Save hardware SFRs 
....................    AD1CON1Save = AD1CON1; 
....................    AD1CON2Save = AD1CON2; 
....................    AD1CON3Save = AD1CON3; 
....................    T1CONSave = T1CON; 
....................    PR1Save = PR1; 
....................  
....................    // Set up Timer and A/D converter module 
....................    AD1CON1 = 0x0000;      // Turn off the ADC so we can write to it 
....................    AD1CON3 = 0x9F00;      // Frc A/D clock, 31 Tad acquisition 
....................    AD1CON2 = 0x003F;      // Interrupt after every 16th sample/convert 
....................    AD1CON1 = 0x80E4;      // Turn on the A/D module, auto-convert 
....................    T1CON = 0x8000;         // TON = 1, no prescalar 
....................    PR1 = 0xFFFF;         // Don't clear timer early 
....................    vBitCount = 0; 
....................    dwTotalTime = 0; 
....................    wLastValue = 0; 
....................    randomResult.dw = LFSRRand(); 
....................    while(1) 
....................    { 
....................       ClrWdt(); 
....................       #if defined(__C30__) 
....................          while(!IFS0bits.AD1IF); 
....................       #else 
....................          while(!IFS1bits.AD1IF); 
....................       #endif 
....................       wTime = TMR1; 
....................       TMR1 = 0x0000; 
....................  
....................       #if defined(__C30__) 
....................          IFS0bits.AD1IF = 0; 
....................       #else 
....................          IFS1CLR = _IFS1_AD1IF_MASK; 
....................       #endif 
....................       w = LFSRRand(); 
....................     
....................       // Wait no longer than 1 second obtaining entropy 
....................       dwTotalTime += wTime; 
....................       if(dwTotalTime >= GetInstructionClock()) 
....................       { 
....................          randomResult.w[0] ^= LFSRRand(); 
....................          randomResult.w[1] ^= LFSRRand(); 
....................          break; 
....................       } 
....................     
....................       // Keep sampling if minimal entropy was likely obtained this round 
....................       if(wLastValue == wTime) 
....................          continue; 
....................     
....................       // Add this entropy into the pseudo random number generator by reseeding 
....................       LFSRSeedRand(w + (wLastValue - wTime)); 
....................       wLastValue = wTime; 
....................     
....................       // Accumulate at least 32 bits of randomness over time 
....................       randomResult.dw <<= 1; 
....................       if(LFSRRand() & 0x0080) 
....................          randomResult.w[0] |= 0x1; 
....................     
....................       // See if we've collected a fair amount of entropy and can quit early 
....................       if(++vBitCount == 0u) 
....................          break; 
....................    } 
....................  
....................  
....................    // Restore hardware SFRs 
....................    AD1CON1 = 0x0000;      // Turn off the ADC so we can write to it 
....................    AD1CON3 = AD1CON3Save; 
....................    AD1CON2 = AD1CON2Save; 
....................    AD1CON1 = AD1CON1Save; 
....................    T1CON = T1CONSave; 
....................    PR1 = PR1Save; 
.................... } 
.................... #endif 
....................  
....................    return randomResult.dw; 
0058C:  MOVFF  184,00
00590:  MOVFF  185,01
00594:  MOVFF  186,02
00598:  MOVFF  187,03
0059C:  MOVLB  0
0059E:  RETURN 0
.................... } 
....................  
....................  
.................... #if defined(STACK_USE_HTTP_SERVER) 
.................... /***************************************************************************** 
....................   Function: 
....................    void UnencodeURL(BYTE* URL) 
....................  
....................   Summary: 
....................    Decodes a URL-encoded string. 
....................  
....................   Description: 
....................    This function is deprecated except for use with HTTP Classic.  It 
....................    attempts to decode a URL encoded string, converting all hex escape 
....................    sequences into a literal byte.  However, it is inefficient over long 
....................    strings and does not handle URL-encoded data strings ('&' and '='). 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    URL - the null-terminated string to decode 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... void UnencodeURL(BYTE* URL) 
.................... { 
....................    BYTE *Right, *Copy; 
....................    WORD_VAL Number; 
....................  
....................    while((Right = (BYTE*)strchr((char*)URL, '%'))) 
....................    { 
....................       // Make sure the string is long enough 
....................       if(Right[1] == '\0') 
....................          break; 
....................       if(Right[2] == '\0') 
....................          break; 
....................  
....................       // Update the string in place 
....................       Number.v[0] = Right[2]; 
....................       Number.v[1] = Right[1]; 
....................       *Right++ = hexatob(Number); 
....................       URL = Right; 
....................  
....................       // Remove two blank spots by shifting all remaining characters right two 
....................       Copy = Right + 2; 
....................       while((*Right++ = *Copy++)); 
....................    } 
.................... }           
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL StringToIPAddress(BYTE* str, IP_ADDR* IPAddress) 
....................  
....................   Summary: 
....................    Converts a string to an IP address 
....................  
....................   Description: 
....................    This function parses a dotted-quad decimal IP address string into an  
....................    IP_ADDR struct.  The output result is big-endian. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    str - Pointer to a dotted-quad IP address string 
....................    IPAddress - Pointer to IP_ADDR in which to store the result 
....................  
....................   Return Values: 
....................      TRUE - an IP address was successfully decoded 
....................      FALSE - no IP address could be found, or the format was incorrect 
....................   ***************************************************************************/ 
.................... BOOL StringToIPAddress(BYTE* str, IP_ADDR* IPAddress) 
.................... { 
....................    DWORD_VAL dwVal; 
....................    BYTE i, charLen, currentOctet; 
....................  
....................    charLen = 0; 
....................    currentOctet = 0; 
....................    dwVal.Val = 0; 
....................    while((i = *str++)) 
....................    { 
....................       if(currentOctet > 3u) 
....................          break; 
....................  
....................       i -= '0'; 
....................        
....................  
....................       // Validate the character is a numerical digit or dot, depending on location 
....................       if(charLen == 0u) 
....................       { 
....................          if(i > 9u) 
....................             return FALSE; 
....................       } 
....................       else if(charLen == 3u) 
....................       { 
....................          if(i != (BYTE)('.' - '0')) 
....................             return FALSE; 
....................  
....................          if(dwVal.Val > 0x00020505ul) 
....................             return FALSE; 
....................  
....................          IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................          charLen = 0; 
....................          dwVal.Val = 0; 
....................          continue; 
....................       } 
....................       else 
....................       { 
....................          if(i == (BYTE)('.' - '0')) 
....................          { 
....................             if(dwVal.Val > 0x00020505ul) 
....................                return FALSE; 
....................  
....................             IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................             charLen = 0; 
....................             dwVal.Val = 0; 
....................             continue; 
....................          } 
....................          if(i > 9u) 
....................             return FALSE; 
....................       } 
....................  
....................       charLen++; 
....................       dwVal.Val <<= 8; 
....................       dwVal.v[0] = i; 
....................    } 
....................  
....................    // Make sure the very last character is a valid termination character  
....................    // (i.e., not more hostname, which could be legal and not an IP  
....................    // address as in "10.5.13.233.picsaregood.com" 
....................    if(i != 0u && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t' && i != ':') 
....................       return FALSE; 
....................  
....................    // Verify and convert the last octet and return the result 
....................    if(dwVal.Val > 0x00020505ul) 
....................       return FALSE; 
....................  
....................    IPAddress->v[3] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................  
....................    return TRUE; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL ROMStringToIPAddress(ROM BYTE* str, IP_ADDR* IPAddress) 
....................  
....................   Summary: 
....................    Converts a string to an IP address 
....................  
....................   Description: 
....................    This function parses a dotted-quad decimal IP address string into an  
....................    IP_ADDR struct.  The output result is big-endian. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    str - Pointer to a dotted-quad IP address string 
....................    IPAddress - Pointer to IP_ADDR in which to store the result 
....................  
....................   Return Values: 
....................      TRUE - an IP address was successfully decoded 
....................      FALSE - no IP address could be found, or the format was incorrect 
....................    
....................   Remarks: 
....................    This function is aliased to StringToIPAddress on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... BOOL ROMStringToIPAddress(ROM BYTE* str, IP_ADDR* IPAddress) 
.................... { 
....................    DWORD_VAL dwVal; 
....................    BYTE i, charLen, currentOctet; 
....................  
....................    charLen = 0; 
....................    currentOctet = 0; 
....................    dwVal.Val = 0; 
....................    while(i = *str++) 
....................    { 
....................       if(currentOctet > 3u) 
....................          break; 
....................  
....................       i -= '0'; 
....................        
....................  
....................       // Validate the character is a numerical digit or dot, depending on location 
....................       if(charLen == 0u) 
....................       { 
....................          if(i > 9u) 
....................             return FALSE; 
....................       } 
....................       else if(charLen == 3u) 
....................       { 
....................          if(i != (BYTE)('.' - '0')) 
....................             return FALSE; 
....................  
....................          if(dwVal.Val > 0x00020505ul) 
....................             return FALSE; 
....................  
....................          IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................          charLen = 0; 
....................          dwVal.Val = 0; 
....................          continue; 
....................       } 
....................       else 
....................       { 
....................          if(i == (BYTE)('.' - '0')) 
....................          { 
....................             if(dwVal.Val > 0x00020505ul) 
....................                return FALSE; 
....................  
....................             IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................             charLen = 0; 
....................             dwVal.Val = 0; 
....................             continue; 
....................          } 
....................          if(i > 9u) 
....................             return FALSE; 
....................       } 
....................  
....................       charLen++; 
....................       dwVal.Val <<= 8; 
....................       dwVal.v[0] = i; 
....................    } 
....................  
....................    // Make sure the very last character is a valid termination character  
....................    // (i.e., not more hostname, which could be legal and not an IP  
....................    // address as in "10.5.13.233.picsaregood.com" 
....................    if(i != 0u && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t') 
....................       return FALSE; 
....................  
....................    // Verify and convert the last octet and return the result 
....................    if(dwVal.Val > 0x00020505ul) 
....................       return FALSE; 
....................  
....................    IPAddress->v[3] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................  
....................    return TRUE; 
.................... } 
.................... #endif 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD Base64Decode(BYTE* cSourceData, WORD wSourceLen,  
....................                   BYTE* cDestData, WORD wDestLen) 
....................  
....................   Description: 
....................    Decodes a Base-64 array to its literal representation. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    cSourceData - Pointer to a string of Base-64 encoded data 
....................    wSourceLen   - Length of the Base-64 source data 
....................    cDestData   - Pointer to write the decoded data 
....................    wSourceLen   - Maximum length that can be written to cDestData 
....................  
....................   Returns: 
....................      Number of decoded bytes written to cDestData. 
....................    
....................   Remarks: 
....................    This function is binary safe and will ignore invalid characters (CR, LF,  
....................    etc).  If cSourceData is equal to cDestData, the data will be converted 
....................    in-place.  If cSourceData is not equal to cDestData, but the regions  
....................    overlap, the behavior is undefined. 
....................     
....................    Decoded data is always at least 1/4 smaller than the source data. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_BASE64_DECODE) 
.................... WORD Base64Decode(BYTE* cSourceData, WORD wSourceLen, BYTE* cDestData, WORD wDestLen) 
.................... { 
....................    BYTE i; 
....................    BYTE vByteNumber; 
....................    WORD wBytesOutput; 
....................  
....................    vByteNumber = 0; 
....................    wBytesOutput = 0; 
....................  
....................    // Loop over all provided bytes 
....................    while(wSourceLen--) 
....................    { 
....................       // Fetch a Base64 byte and decode it to the original 6 bits 
....................       i = *cSourceData++; 
....................       if(i >= 'A' && i <= 'Z')   // Regular data 
....................          i -= 'A' - 0; 
....................       else if(i >= 'a' && i <= 'z') 
....................          i -= 'a' - 26; 
....................       else if(i >= '0' && i <= '9') 
....................          i -= '0' - 52; 
....................       else if(i == '+' || i == '-') 
....................          i = 62; 
....................       else if(i == '/' || i == '_') 
....................          i = 63; 
....................       else                   // Skip all padding (=) and non-Base64 characters 
....................          continue; 
....................  
....................  
....................       // Write the 6 bits to the correct destination location(s) 
....................       if(vByteNumber == 0u) 
....................       { 
....................          vByteNumber++; 
....................          if(wBytesOutput >= wDestLen) 
....................             break; 
....................          wBytesOutput++; 
....................          *cDestData = i << 2; 
....................       } 
....................       else if(vByteNumber == 1u) 
....................       { 
....................          vByteNumber++; 
....................          *cDestData++ |= i >> 4; 
....................          if(wBytesOutput >= wDestLen) 
....................             break; 
....................          wBytesOutput++; 
....................          *cDestData = i << 4; 
....................       } 
....................       else if(vByteNumber == 2u) 
....................       { 
....................          vByteNumber++; 
....................          *cDestData++ |= i >> 2; 
....................          if(wBytesOutput >= wDestLen) 
....................             break; 
....................          wBytesOutput++; 
....................          *cDestData = i << 6; 
....................       } 
....................       else 
....................       { 
....................          vByteNumber = 0; 
....................          *cDestData++ |= i; 
....................       } 
....................    } 
....................  
....................    return wBytesOutput; 
.................... } 
.................... #endif   // #if defined(STACK_USE_BASE64_DECODE) 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD Base64Encode(BYTE* cSourceData, WORD wSourceLen, 
....................                   BYTE* cDestData, WORD wDestLen) 
....................  
....................   Description: 
....................    Encodes a binary array to Base-64. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    cSourceData - Pointer to a string of binary data 
....................    wSourceLen   - Length of the binary source data 
....................    cDestData   - Pointer to write the Base-64 encoded data 
....................    wSourceLen   - Maximum length that can be written to cDestData 
....................  
....................   Returns: 
....................      Number of encoded bytes written to cDestData.  This will always be 
....................      a multiple of 4. 
....................    
....................   Remarks: 
....................    Encoding cannot be performed in-place.  If cSourceData overlaps with  
....................    cDestData, the behavior is undefined. 
....................     
....................    Encoded data is always at least 1/3 larger than the source data.  It may 
....................    be 1 or 2 bytes larger than that. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_BASE64_ENCODE) || defined(STACK_USE_SMTP_CLIENT) || defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... WORD Base64Encode(BYTE* cSourceData, WORD wSourceLen, BYTE* cDestData, WORD wDestLen) 
.................... { 
....................    BYTE i, j; 
....................    BYTE vOutput[4]; 
....................    WORD wOutputLen; 
....................  
....................    wOutputLen = 0; 
....................    while(wDestLen >= 4u) 
....................    { 
....................       // Start out treating the output as all padding 
....................       vOutput[0] = 0xFF; 
....................       vOutput[1] = 0xFF; 
....................       vOutput[2] = 0xFF; 
....................       vOutput[3] = 0xFF; 
....................  
....................       // Get 3 input octets and split them into 4 output hextets (6-bits each)  
....................       if(wSourceLen == 0u) 
....................          break; 
....................       i = *cSourceData++; 
....................       wSourceLen--; 
....................       vOutput[0] = (i & 0xFC)>>2; 
....................       vOutput[1] = (i & 0x03)<<4; 
....................       if(wSourceLen) 
....................       { 
....................          i = *cSourceData++; 
....................          wSourceLen--; 
....................          vOutput[1] |= (i & 0xF0)>>4; 
....................          vOutput[2] = (i & 0x0F)<<2; 
....................          if(wSourceLen) 
....................          { 
....................             i = *cSourceData++; 
....................             wSourceLen--; 
....................             vOutput[2] |= (i & 0xC0)>>6; 
....................             vOutput[3] = i & 0x3F; 
....................          } 
....................       } 
....................     
....................       // Convert hextets into Base 64 alphabet and store result 
....................       for(i = 0; i < 4u; i++) 
....................       { 
....................          j = vOutput[i]; 
....................  
....................          if(j <= 25u) 
....................             j += 'A' - 0; 
....................          else if(j <= 51u) 
....................             j += 'a' - 26; 
....................          else if(j <= 61u) 
....................             j += '0' - 52; 
....................          else if(j == 62u) 
....................             j = '+'; 
....................          else if(j == 63u) 
....................             j = '/'; 
....................          else            // Padding 
....................             j = '='; 
....................  
....................          *cDestData++ = j; 
....................       } 
....................  
....................       // Update counters 
....................       wDestLen -= 4; 
....................       wOutputLen += 4; 
....................    } 
....................  
....................    return wOutputLen; 
.................... } 
.................... #endif // #if defined(STACK_USE_BASE64_ENCODE) || defined(STACK_USE_SMTP) || defined(STACK_USE_DYNAMICDNS_CLIENT) 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void uitoa(WORD Value, BYTE* Buffer) 
....................  
....................   Summary: 
....................    Converts an unsigned integer to a decimal string. 
....................     
....................   Description: 
....................    Converts a 16-bit unsigned integer to a null-terminated decimal string. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    Value   - The number to be converted 
....................    Buffer   - Pointer in which to store the converted string 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... void uitoa(WORD Value, BYTE* Buffer) 
.................... { 
....................    BYTE i; 
....................    WORD Digit; 
....................    WORD Divisor; 
....................    BOOL Printed = FALSE; 
....................  
....................    if(Value) 
....................    { 
....................       for(i = 0, Divisor = 10000; i < 5u; i++) 
....................       { 
....................          Digit = Value/Divisor; 
....................          if(Digit || Printed) 
....................          { 
....................             *Buffer++ = '0' + Digit; 
....................             Value -= Digit*Divisor; 
....................             Printed = TRUE; 
....................          } 
....................          Divisor /= 10; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       *Buffer++ = '0'; 
....................    } 
....................  
....................    *Buffer = '\0'; 
.................... }              
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ultoa(DWORD Value, BYTE* Buffer) 
....................  
....................   Summary: 
....................    Converts an unsigned integer to a decimal string. 
....................     
....................   Description: 
....................    Converts a 32-bit unsigned integer to a null-terminated decimal string. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    Value   - The number to be converted 
....................    Buffer   - Pointer in which to store the converted string 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... // HI-TECH PICC-18 PRO 9.63, C30 v3.25, and C32 v1.12 already have a ultoa() library function 
.................... // C18 already has a ultoa() function that more-or-less matches this one 
.................... // C32 < 1.12 and C30 < v3.25 need this function 
.................... #if (defined(__PIC32MX__) && (__C32_VERSION__ < 112)) || (defined (__C30__) && (__C30_VERSION__ < 325)) || defined(__C30_LEGACY_LIBC__) || defined(__C32_LEGACY_LIBC__) 
.................... void ultoa(DWORD Value, BYTE* Buffer) 
.................... { 
....................    BYTE i; 
....................    DWORD Digit; 
....................    DWORD Divisor; 
....................    BOOL Printed = FALSE; 
....................  
....................    if(Value) 
....................    { 
....................       for(i = 0, Divisor = 1000000000; i < 10; i++) 
....................       { 
....................          Digit = Value/Divisor; 
....................          if(Digit || Printed) 
....................          { 
....................             *Buffer++ = '0' + Digit; 
....................             Value -= Digit*Divisor; 
....................             Printed = TRUE; 
....................          } 
....................          Divisor /= 10; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       *Buffer++ = '0'; 
....................    } 
....................  
....................    *Buffer = '\0'; 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE hexatob(WORD_VAL AsciiChars) 
....................  
....................   Summary: 
....................    Converts a hex string to a single byte. 
....................     
....................   Description: 
....................    Converts a two-character ASCII hex string to a single packed byte. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    AsciiChars - WORD_VAL where .v[0] is the ASCII value for the lower nibble 
....................                and .v[1] is the ASCII value for the upper nibble.  Each 
....................                must range from '0'-'9', 'A'-'F', or 'a'-'f'. 
....................  
....................   Returns: 
....................      Resulting packed byte 0x00 - 0xFF. 
....................   ***************************************************************************/ 
.................... BYTE hexatob(WORD_VAL AsciiChars) 
.................... { 
....................    // Convert lowercase to uppercase 
....................    if(AsciiChars.v[1] > 'F') 
....................       AsciiChars.v[1] -= 'a'-'A'; 
....................    if(AsciiChars.v[0] > 'F') 
....................       AsciiChars.v[0] -= 'a'-'A'; 
....................  
....................    // Convert 0-9, A-F to 0x0-0xF 
....................    if(AsciiChars.v[1] > '9') 
....................       AsciiChars.v[1] -= 'A' - 10; 
....................    else 
....................       AsciiChars.v[1] -= '0'; 
....................  
....................    if(AsciiChars.v[0] > '9') 
....................       AsciiChars.v[0] -= 'A' - 10; 
....................    else 
....................       AsciiChars.v[0] -= '0'; 
....................  
....................    // Concatenate 
....................    return (AsciiChars.v[1]<<4) |  AsciiChars.v[0]; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE btohexa_high(BYTE b) 
....................  
....................   Summary: 
....................    Converts the upper nibble of a binary value to a hexadecimal ASCII byte. 
....................  
....................   Description: 
....................    Converts the upper nibble of a binary value to a hexadecimal ASCII byte. 
....................    For example, btohexa_high(0xAE) will return 'A'. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    b - the byte to convert 
....................  
....................   Returns: 
....................      The upper hexadecimal ASCII byte '0'-'9' or 'A'-'F'. 
....................   ***************************************************************************/ 
.................... BYTE btohexa_high(BYTE b) 
.................... { 
....................    b >>= 4; 
....................    return (b>0x9u) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE btohexa_high(BYTE b) 
....................  
....................   Summary: 
....................    Converts the lower nibble of a binary value to a hexadecimal ASCII byte. 
....................  
....................   Description: 
....................    Converts the lower nibble of a binary value to a hexadecimal ASCII byte. 
....................    For example, btohexa_high(0xAE) will return 'E'. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    b - the byte to convert 
....................  
....................   Returns: 
....................      The lower hexadecimal ASCII byte '0'-'9' or 'A'-'F'. 
....................   ***************************************************************************/ 
.................... BYTE btohexa_low(BYTE b) 
.................... { 
....................    b &= 0x0F; 
....................    return (b>9u) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    signed char stricmppgm2ram(BYTE* a, ROM BYTE* b) 
....................  
....................   Summary: 
....................    Case-insensitive comparison of a string in RAM to a string in ROM. 
....................  
....................   Description: 
....................    Performs a case-insensitive comparison of a string in RAM to a string 
....................    in ROM.  This function performs identically to strcmppgm2ram, except that 
....................    the comparison is not case-sensitive. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    a - Pinter to tring in RAM 
....................    b - Pointer to string in ROM 
....................  
....................   Return Values: 
....................      \-1 - a < b 
....................      0   - a = b 
....................      1   - a > b 
....................   ***************************************************************************/ 
.................... signed char stricmppgm2ram(BYTE* a, ROM BYTE* b) 
.................... { 
....................    BYTE cA, cB; 
....................     
....................    // Load first two characters 
....................    cA = *a; 
....................    cB = *b; 
....................     
....................    // Loop until one string terminates 
....................    while(cA != '\0' && cB != '\0') 
....................    { 
....................       // Shift case if necessary 
....................       if(cA >= 'a' && cA <= 'z') 
....................          cA -= 'a' - 'A'; 
....................       if(cB >= 'a' && cB <= 'z') 
....................          cB -= 'a' - 'A'; 
....................           
....................       // Compare 
....................       if(cA > cB) 
....................          return 1; 
....................       if(cA < cB) 
....................          return -1; 
....................        
....................       // Characters matched, so continue 
....................       a++; 
....................       b++; 
....................       cA = *a; 
....................       cB = *b; 
....................    } 
....................     
....................    // See if one string terminated first 
....................    if(cA > cB) 
....................       return 1; 
....................    if(cA < cB) 
....................       return -1; 
....................        
....................    // Strings match 
....................    return 0; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD swaps(WORD v) 
....................  
....................   Description: 
....................    Swaps the endian-ness of a WORD. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    v - the WORD to swap 
....................  
....................   Returns: 
....................    The swapped version of v. 
....................   ***************************************************************************/ 
.................... WORD swaps(WORD v) 
.................... { 
....................    WORD_VAL t; 
....................    BYTE b; 
....................  
....................    t.Val   = v; 
*
00F92:  MOVFF  2BF,2C1
00F96:  MOVFF  2BE,2C0
....................    b       = t.v[1]; 
00F9A:  MOVFF  2C1,2C2
....................    t.v[1]  = t.v[0]; 
00F9E:  MOVFF  2C0,2C1
....................    t.v[0]  = b; 
00FA2:  MOVFF  2C2,2C0
....................  
....................    return t.Val; 
00FA6:  MOVLB  2
00FA8:  MOVFF  2C0,01
00FAC:  MOVFF  2C1,02
00FB0:  MOVLB  0
00FB2:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    DWORD swapl(DWORD v) 
....................  
....................   Description: 
....................    Swaps the endian-ness of a DWORD. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    v - the DWORD to swap 
....................  
....................   Returns: 
....................    The swapped version of v. 
....................   ***************************************************************************/ 
.................... #if defined(__C32__) 
.................... DWORD   __attribute__((nomips16)) swapl(DWORD v) 
.................... #else 
.................... DWORD swapl(DWORD v) 
.................... #endif 
.................... { 
....................    // Swap bytes 0 and 3 
....................    ((DWORD_VAL*)&v)->v[0] ^= ((DWORD_VAL*)&v)->v[3]; 
00FB4:  MOVLW  02
00FB6:  MOVLB  2
00FB8:  MOVWF  xAC
00FBA:  MOVLW  A7
00FBC:  MOVWF  01
00FBE:  MOVFF  2AC,FEA
00FC2:  MOVWF  FE9
00FC4:  MOVFF  FEF,2AF
00FC8:  MOVLW  02
00FCA:  MOVWF  xB1
00FCC:  MOVLW  A7
00FCE:  MOVWF  xB0
00FD0:  MOVLW  03
00FD2:  ADDWF  xB0,W
00FD4:  MOVWF  FE9
00FD6:  MOVLW  00
00FD8:  ADDWFC xB1,W
00FDA:  MOVWF  FEA
00FDC:  MOVF   FEF,W
00FDE:  XORWF  xAF,W
00FE0:  MOVFF  2AC,FEA
00FE4:  MOVFF  01,FE9
00FE8:  MOVWF  FEF
....................    ((DWORD_VAL*)&v)->v[3] ^= ((DWORD_VAL*)&v)->v[0]; 
00FEA:  MOVLW  02
00FEC:  MOVWF  xAC
00FEE:  MOVLW  A7
00FF0:  MOVWF  xAB
00FF2:  MOVLW  03
00FF4:  ADDWF  xAB,W
00FF6:  MOVWF  01
00FF8:  MOVLW  00
00FFA:  ADDWFC xAC,W
00FFC:  MOVWF  03
00FFE:  MOVWF  FEA
01000:  MOVFF  01,FE9
01004:  MOVFF  FEF,2AF
01008:  MOVLW  02
0100A:  MOVWF  xB1
0100C:  MOVLW  A7
0100E:  MOVWF  FE9
01010:  MOVFF  2B1,FEA
01014:  MOVF   FEF,W
01016:  XORWF  xAF,W
01018:  MOVFF  03,FEA
0101C:  MOVFF  01,FE9
01020:  MOVWF  FEF
....................    ((DWORD_VAL*)&v)->v[0] ^= ((DWORD_VAL*)&v)->v[3]; 
01022:  MOVLW  02
01024:  MOVWF  xAC
01026:  MOVLW  A7
01028:  MOVWF  01
0102A:  MOVFF  2AC,FEA
0102E:  MOVWF  FE9
01030:  MOVFF  FEF,2AF
01034:  MOVLW  02
01036:  MOVWF  xB1
01038:  MOVLW  A7
0103A:  MOVWF  xB0
0103C:  MOVLW  03
0103E:  ADDWF  xB0,W
01040:  MOVWF  FE9
01042:  MOVLW  00
01044:  ADDWFC xB1,W
01046:  MOVWF  FEA
01048:  MOVF   FEF,W
0104A:  XORWF  xAF,W
0104C:  MOVFF  2AC,FEA
01050:  MOVFF  01,FE9
01054:  MOVWF  FEF
....................  
....................    // Swap bytes 1 and 2 
....................    ((DWORD_VAL*)&v)->v[1] ^= ((DWORD_VAL*)&v)->v[2]; 
01056:  MOVLW  02
01058:  MOVWF  xAC
0105A:  MOVLW  A7
0105C:  MOVWF  xAB
0105E:  MOVLW  01
01060:  ADDWF  xAB,W
01062:  MOVWF  01
01064:  MOVLW  00
01066:  ADDWFC xAC,W
01068:  MOVWF  03
0106A:  MOVWF  FEA
0106C:  MOVFF  01,FE9
01070:  MOVFF  FEF,2AF
01074:  MOVLW  02
01076:  MOVWF  xB1
01078:  MOVLW  A7
0107A:  MOVWF  xB0
0107C:  MOVLW  02
0107E:  ADDWF  xB0,W
01080:  MOVWF  FE9
01082:  MOVLW  00
01084:  ADDWFC xB1,W
01086:  MOVWF  FEA
01088:  MOVF   FEF,W
0108A:  XORWF  xAF,W
0108C:  MOVFF  03,FEA
01090:  MOVFF  01,FE9
01094:  MOVWF  FEF
....................    ((DWORD_VAL*)&v)->v[2] ^= ((DWORD_VAL*)&v)->v[1]; 
01096:  MOVLW  02
01098:  MOVWF  xAC
0109A:  MOVLW  A7
0109C:  MOVWF  xAB
0109E:  MOVLW  02
010A0:  ADDWF  xAB,W
010A2:  MOVWF  01
010A4:  MOVLW  00
010A6:  ADDWFC xAC,W
010A8:  MOVWF  03
010AA:  MOVWF  FEA
010AC:  MOVFF  01,FE9
010B0:  MOVFF  FEF,2AF
010B4:  MOVLW  02
010B6:  MOVWF  xB1
010B8:  MOVLW  A7
010BA:  MOVWF  xB0
010BC:  MOVLW  01
010BE:  ADDWF  xB0,W
010C0:  MOVWF  FE9
010C2:  MOVLW  00
010C4:  ADDWFC xB1,W
010C6:  MOVWF  FEA
010C8:  MOVF   FEF,W
010CA:  XORWF  xAF,W
010CC:  MOVFF  03,FEA
010D0:  MOVFF  01,FE9
010D4:  MOVWF  FEF
....................    ((DWORD_VAL*)&v)->v[1] ^= ((DWORD_VAL*)&v)->v[2]; 
010D6:  MOVLW  02
010D8:  MOVWF  xAC
010DA:  MOVLW  A7
010DC:  MOVWF  xAB
010DE:  MOVLW  01
010E0:  ADDWF  xAB,W
010E2:  MOVWF  01
010E4:  MOVLW  00
010E6:  ADDWFC xAC,W
010E8:  MOVWF  03
010EA:  MOVWF  FEA
010EC:  MOVFF  01,FE9
010F0:  MOVFF  FEF,2AF
010F4:  MOVLW  02
010F6:  MOVWF  xB1
010F8:  MOVLW  A7
010FA:  MOVWF  xB0
010FC:  MOVLW  02
010FE:  ADDWF  xB0,W
01100:  MOVWF  FE9
01102:  MOVLW  00
01104:  ADDWFC xB1,W
01106:  MOVWF  FEA
01108:  MOVF   FEF,W
0110A:  XORWF  xAF,W
0110C:  MOVFF  03,FEA
01110:  MOVFF  01,FE9
01114:  MOVWF  FEF
....................  
....................    return v; 
01116:  MOVFF  2A7,00
0111A:  MOVFF  2A8,01
0111E:  MOVFF  2A9,02
01122:  MOVFF  2AA,03
01126:  MOVLB  0
01128:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD CalcIPChecksum(BYTE* buffer, WORD count) 
....................  
....................   Summary: 
....................    Calculates an IP checksum value. 
....................  
....................   Description: 
....................    This function calculates an IP checksum over an array of input data.  The 
....................    checksum is the 16-bit one's complement of one's complement sum of all  
....................    words in the data (with zero-padding if an odd number of bytes are  
....................    summed).  This checksum is defined in RFC 793. 
....................  
....................   Precondition: 
....................    buffer is WORD aligned (even memory address) on 16- and 32-bit PICs. 
....................  
....................   Parameters: 
....................    buffer - pointer to the data to be checksummed 
....................    count  - number of bytes to be checksummed 
....................  
....................   Returns: 
....................    The calculated checksum. 
....................     
....................   Internal: 
....................    This function could be improved to do 32-bit sums on PIC32 platforms. 
....................   ***************************************************************************/ 
.................... WORD CalcIPChecksum(BYTE* buffer, WORD count) 
.................... { 
....................    WORD i; 
....................    WORD *val; 
....................    union 
....................    { 
....................       WORD w[2]; 
....................       DWORD dw; 
....................    } sum; 
....................  
....................    i = count >> 1; 
*
01346:  BCF    FD8.0
01348:  MOVLB  2
0134A:  RRCF   xBD,W
0134C:  MOVWF  xBF
0134E:  RRCF   xBC,W
01350:  MOVWF  xBE
....................    val = (WORD*)buffer; 
01352:  MOVFF  2BB,2C1
01356:  MOVFF  2BA,2C0
....................  
....................    // Calculate the sum of all words 
....................    sum.dw = 0x00000000ul; 
0135A:  CLRF   xC5
0135C:  CLRF   xC4
0135E:  CLRF   xC3
01360:  CLRF   xC2
....................    while(i--) 
01362:  MOVFF  2BF,03
01366:  MOVF   xBE,W
01368:  BTFSC  FD8.2
0136A:  DECF   xBF,F
0136C:  DECF   xBE,F
0136E:  IORWF  03,W
01370:  BZ    13AE
....................       sum.dw += (DWORD)*val++; 
01372:  MOVFF  2C1,03
01376:  MOVFF  2C0,00
0137A:  MOVLW  02
0137C:  ADDWF  xC0,F
0137E:  BTFSC  FD8.0
01380:  INCF   xC1,F
01382:  MOVFF  00,FE9
01386:  MOVFF  03,FEA
0138A:  MOVFF  FEC,03
0138E:  MOVF   FED,F
01390:  MOVFF  FEF,00
01394:  MOVFF  03,01
01398:  CLRF   02
0139A:  CLRF   03
0139C:  MOVF   00,W
0139E:  ADDWF  xC2,F
013A0:  MOVF   01,W
013A2:  ADDWFC xC3,F
013A4:  MOVF   02,W
013A6:  ADDWFC xC4,F
013A8:  MOVF   03,W
013AA:  ADDWFC xC5,F
013AC:  BRA    1362
....................  
....................    // Add in the sum of the remaining byte, if present 
....................    if(count & 0x1) 
013AE:  MOVF   xBC,W
013B0:  ANDLW  01
013B2:  MOVWF  00
013B4:  CLRF   03
013B6:  MOVF   00,W
013B8:  IORWF  03,W
013BA:  BZ    13E2
....................       sum.dw += (DWORD)*(BYTE*)val; 
013BC:  MOVFF  2C1,03
013C0:  MOVFF  2C0,FE9
013C4:  MOVFF  2C1,FEA
013C8:  MOVFF  FEF,00
013CC:  CLRF   01
013CE:  CLRF   02
013D0:  CLRF   03
013D2:  MOVF   00,W
013D4:  ADDWF  xC2,F
013D6:  MOVF   01,W
013D8:  ADDWFC xC3,F
013DA:  MOVF   02,W
013DC:  ADDWFC xC4,F
013DE:  MOVF   03,W
013E0:  ADDWFC xC5,F
....................  
....................    // Do an end-around carry (one's complement arrithmatic) 
....................    sum.dw = (DWORD)sum.w[0] + (DWORD)sum.w[1]; 
013E2:  CLRF   xC9
013E4:  CLRF   xC8
013E6:  MOVFF  2C3,2C7
013EA:  MOVFF  2C2,2C6
013EE:  MOVFF  2C4,00
013F2:  MOVFF  2C5,01
013F6:  CLRF   02
013F8:  CLRF   03
013FA:  MOVF   xC4,W
013FC:  ADDWF  xC2,W
013FE:  MOVWF  xC2
01400:  MOVF   xC5,W
01402:  ADDWFC xC3,W
01404:  MOVWF  xC3
01406:  MOVF   02,W
01408:  ADDWFC xC8,W
0140A:  MOVWF  xC4
0140C:  MOVF   03,W
0140E:  ADDWFC xC9,W
01410:  MOVWF  xC5
....................  
....................    // Do another end-around carry in case if the prior add  
....................    // caused a carry out 
....................    sum.w[0] += sum.w[1]; 
01412:  MOVF   xC4,W
01414:  ADDWF  xC2,F
01416:  MOVF   xC5,W
01418:  ADDWFC xC3,F
....................  
....................    // Return the resulting checksum 
....................    return ~sum.w[0]; 
0141A:  MOVFF  2C3,03
0141E:  COMF   03,F
01420:  MOVF   xC2,W
01422:  XORLW  FF
01424:  MOVWF  01
01426:  MOVFF  03,02
0142A:  MOVLB  0
0142C:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    char* strupr(char* s) 
....................  
....................   Summary: 
....................    Converts a string to uppercase. 
....................  
....................   Description: 
....................    This function converts strings to uppercase on platforms that do not 
....................    already have this function defined.  All lower-case characters are 
....................    converted, an characters not included in 'a'-'z' are left as-is. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    s - the null-terminated string to be converted. 
....................  
....................   Returns: 
....................    Pointer to the initial string. 
....................   ***************************************************************************/ 
.................... #if (!defined(__PCD__) && !defined(__18CXX)) || defined(HI_TECH_C) 
.................... char* strupr(char* s) 
.................... { 
....................    char c; 
....................    char *t; 
....................  
....................    t = s; 
....................    while( (c = *t) ) 
....................    { 
....................       if(c >= 'a' && c <= 'z') 
....................       { 
....................          *t -= ('a' - 'A'); 
....................       } 
....................       t++; 
....................    } 
....................    return s; 
.................... } 
.................... #endif 
....................  
.................... #if defined(__18CXX) //&& !defined(__PCH__) 
.................... // Make this variable global for the following function. 
.................... // Hi-Tech PICC18 cannot access local function variables from inline asm. 
.................... DWORD_VAL toRotate;  
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    DWORD leftRotateDWORD(DWORD val, BYTE bits) 
....................  
....................   Summary: 
....................    Left-rotates a DWORD. 
....................  
....................   Description: 
....................    This function rotates the bits in a 32-bit DWORD left by a specific  
....................    number of bits. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    val      - the DWORD to be rotated 
....................    bits   - the number of bits by which to shift 
....................  
....................   Returns: 
....................    Rotated DWORD value. 
....................     
....................   Remarks: 
....................    This function is only implemented on 8-bit platforms for now.  The  
....................    8-bit compilers generate excessive code for this function, while C30 
....................    and C32 already generate compact code.  Those compilers are served 
....................    by a macro defined in Helpers.h. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... DWORD leftRotateDWORD(DWORD val, BYTE bits) 
.................... { 
....................    BYTE i, t; 
....................    //DWORD_VAL toRotate; 
....................    toRotate.Val = val; 
....................     
....................    for(i = bits; i >= 8u; i -= 8) 
....................    { 
....................       t = toRotate.v[3]; 
....................       toRotate.v[3] = toRotate.v[2]; 
....................       toRotate.v[2] = toRotate.v[1]; 
....................       toRotate.v[1] = toRotate.v[0]; 
....................       toRotate.v[0] = t; 
....................    } 
....................     
....................     
....................    #if defined(HI_TECH_C) 
....................    for(; i != 0; i--) 
....................    { 
....................       asm("movlb (_toRotate)>>8"); 
....................       //asm("bcf _STATUS,0,C"); 
....................       asm("bcf 0xFD8,0,C");      // HI-TECH PICC-18 PRO 9.63PL1 doesn't define _STATUS 
....................       asm("btfsc (_toRotate)&0ffh+3,7,B"); 
....................       //asm("bsf _STATUS,0,C"); 
....................       asm("bsf 0xFD8,0,C");      // HI-TECH PICC-18 PRO 9.63PL1 doesn't define _STATUS 
....................       asm("rlcf (_toRotate)&0ffh+0,F,B"); 
....................       asm("rlcf (_toRotate)&0ffh+1,F,B"); 
....................       asm("rlcf (_toRotate)&0ffh+2,F,B"); 
....................       asm("rlcf (_toRotate)&0ffh+3,F,B"); 
....................    } 
....................    #else 
....................    for(; i != 0u; i--) 
....................    { 
....................       _asm 
....................       movlb toRotate 
....................       bcf STATUS,0,0 
....................       btfsc toRotate+3,7,1 
....................       bsf STATUS,0,0 
....................       rlcf toRotate+0,1,1 
....................       rlcf toRotate+1,1,1 
....................       rlcf toRotate+2,1,1 
....................       rlcf toRotate+3,1,1 
....................       _endasm 
....................    } 
....................    #endif 
....................     
....................    return toRotate.Val; 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void FormatNetBIOSName(BYTE Name[]) 
....................  
....................   Summary: 
....................    Formats a string to a valid NetBIOS name. 
....................  
....................   Description: 
....................    This function formats a string to a valid NetBIOS name.  Names will be 
....................    exactly 16 characters, as defined by the NetBIOS spec.  The 16th  
....................    character will be a 0x00 byte, while the other 15 will be the  
....................    provided string, padded with spaces as necessary. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    Name - the string to format as a NetBIOS name.  This parameter must have 
....................      at least 16 bytes allocated. 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... void FormatNetBIOSName(BYTE Name[]) 
.................... { 
....................    BYTE i; 
....................  
....................    Name[15] = '\0'; 
....................    strupr((char*)Name); 
....................    i = 0; 
....................    while(i < 15u) 
....................    { 
....................       if(Name[i] == '\0') 
....................       { 
....................          while(i < 15u) 
....................          { 
....................             Name[i++] = ' '; 
....................          } 
....................          break; 
....................       } 
....................       i++; 
....................    } 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    char * strnchr(const char *searchString, size_t count, char c) 
....................  
....................   Summary: 
....................    Searches a string up to a specified number of characters for a specific  
....................    character. 
....................  
....................   Description: 
....................    Searches a string up to a specified number of characters for a specific  
....................    character.  The string is searched forward and the first occurance  
....................    location is returned.  If the search character is not present in the  
....................    string, or if the maximum character count is reached first, then a NULL  
....................    pointer is returned. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    searchString - Pointer to a null terminated string to search.  If count is  
....................       less than the string size, then the string need not be null terminated. 
....................    count - Maximum number of characters to search before aborting. 
....................    c - Character to search for 
....................     
....................   Returns: 
....................    Pointer to the first occurance of the character c in the string  
....................    searchString.  If the character is not found or the maximum count is  
....................    reached, a NULL pointer is returned. 
....................   ***************************************************************************/ 
.................... char * strnchr(const char *searchString, size_t count, char c) 
.................... { 
....................    char c2; 
....................     
....................    while(count--) 
....................    { 
....................       c2  = *searchString++; 
....................       if(c2 == 0u) 
....................          return NULL; 
....................       if(c2 == c) 
....................          return (char*)--searchString; 
....................    } 
....................    return NULL; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    char* strncpy_m(char* destStr, size_t destSize, int nStrings, ...) 
....................  
....................   Summary: 
....................    Copies multiple strings to a destination 
....................  
....................   Description: 
....................    Copies multiple strings to a destination 
....................     but doesn't copy more than destSize characters. 
....................     Useful where the destination is actually an array and an extra \0 
....................     won't be appended to overflow the buffer 
....................      
....................   Precondition: 
....................    - valid string pointers 
....................     - destSize should be > 0 
....................  
....................   Parameters: 
....................    destStr - Pointer to a string to be initialized with the multiple strings provided as arguments. 
....................  
....................     destSize    - the maximum size of the destStr field, that cannot be exceeded. 
....................                   An \0 won't be appended if the resulting size is > destSize 
....................  
....................     nStrings    - number of string parameters to be copied into destStr 
....................  
....................     ...         - variable number of arguments 
....................      
....................     
....................   Returns: 
....................    Length of the destination string, terminating \0 (if exists) not included 
....................   ***************************************************************************/ 
.................... size_t strncpy_m(char* destStr, size_t destSize, int nStrings, ...) 
.................... { 
....................     va_list     args; 
....................     const char* str; 
....................     char*       end; 
....................     size_t      len; 
....................  
....................     destStr[0] = '\0'; 
....................     end = destStr + destSize - 1; 
....................     *end = '\0'; 
....................     len = 0; 
....................      
....................     va_start( args, nStrings ); 
....................      
....................     while(nStrings--) 
....................     { 
....................         if(*end) 
....................         {   // if already full don't calculate strlen outside the string area 
....................             len = destSize; 
....................             break; 
....................         } 
....................          
....................         str = va_arg(args, const char*); 
....................         strncpy(destStr + len, str, destSize - len); 
....................         len += strlen(str); 
....................     } 
....................  
....................     va_end( args ); 
....................      
....................     return len; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE ExtractURLFields(BYTE *vURL,  
....................                     PROTOCOLS *protocol,  
....................                     BYTE *vUsername, WORD *wUsernameLen,  
....................                     BYTE *vPassword, WORD *wPasswordLen,  
....................                     BYTE *vHostname, WORD *wHostnameLen,  
....................                     WORD *wPort,  
....................                     BYTE *vFilePath, WORD *wFilePathLen) 
....................  
....................   Summary: 
....................    Extracts all parameters from an URL string (ex:  
....................    "http://admin:passwd@www.microchip.com:8080/myfile.gif" is split into  
....................    {PROTOCOL_HTTP, "admin", "passwd", "www.microchip.com", 8080, "/myfile.gif"}. 
....................  
....................   Description: 
....................    Extracts all parameters from an URL string (ex:  
....................    "http://admin:passwd@www.microchip.com:8080/myfile.gif" is split into  
....................    {PROTOCOL_HTTP, "admin", "passwd", "www.microchip.com", 8080, "/myfile.gif"}. 
....................     
....................    The URL string can be null terminated, or alternatively could be terminated  
....................    by a carriage return or line feed. 
....................     
....................    If the protocol is unrecognized or the protocol is recognized but the URL  
....................    is malformed, than an error is safely returned.  For more information on  
....................    URL/URI interpretation see RFC 2396. 
....................  
....................   Precondition: 
....................    This function is commented out by default to save code space because  
....................    it is not used by any current stack features.  However, if you want to use  
....................    it, go ahead and uncomment it.  It has been tested, so it (should) work  
....................    correctly. 
....................  
....................   Parameters: 
....................    vURL -   Pointer to null terminated URL to decode and extract from.  This  
....................       parameter is required and needs to have the minimum RFC 1738 components  
....................       in it (protocol and hostname). 
....................        
....................    protocol - Optional pointer to a PROTOCOLS enum to retrieve the decoded  
....................       protocol type.  If this parameter is unneeded, specify a NULL pointer.   
....................       The protocol is a required part of the URL, so it must always be  
....................       present.  The protocol also determines what scheme all other parameters  
....................       are decoded using, so the function will fail if an unrecognized  
....................       protocol is provided.  The PROTOCOLS enum members show all of the  
....................       currently supported protocols for this function. 
....................        
....................       <p>For the example URL provided in the function description,  
....................       PROTOCOL_HTTP would be returned for this field. 
....................        
....................    vUsername - Optional pointer to a buffer to write the decoded username  
....................       portion of the URL.  If the URL does not contain a username or a NULL  
....................       pointer is supplied, then this field is ignored. 
....................  
....................       <p>For the example URL provided in the function description, "admin"  
....................       would be returned for this field. 
....................        
....................    wUsernameLen - 
....................       On call\: Optional pointer to a WORD specifying the maximum length of  
....................       the vUsername buffer, including the null terminator character. 
....................        
....................       <p>Upon return\: If wUsernameLen and vUsername are non-NULL, the  
....................       *wUsernameLen WORD is updated with the actual number of characters  
....................       written to the vUsername buffer, including the null terminator  
....................       character.  If vUsername is NULL but wUsernameLen is non-NULL, then no  
....................       characters are copied, but *wUsernameLen will return the number of  
....................       characters required to fit the full username string.  If wUsernameLen  
....................       is NULL, then the username field in the URL, if present, is ignored and  
....................       the vUsername pointer is not used. 
....................        
....................       <p>If zero characters were written, this indicates that the URL did not  
....................       contain a username field.  If one character was written, this indicates  
....................       that a username field was present, but was a zero character string  
....................       (ex\: ""). 
....................         
....................       <p>For the example URL provided in the function description, 6 (0x0006)  
....................       would be returned for this field. 
....................        
....................    vPassword - Optional pointer to a buffer to write the decoded password  
....................       portion of the URL.  If the URL does not contain a password or a NULL  
....................       pointer is supplied, then this field is ignored. 
....................  
....................       <p>For the example URL provided in the function description, "passwd"  
....................       would be returned for this field. 
....................        
....................    wPasswordLen - 
....................       On call\: Optional pointer to a WORD specifying the maximum length of  
....................       the vPassword buffer, including the null terminator character. 
....................        
....................       <p>Upon return\: If wPasswordLen and vPassword are non-NULL, the  
....................       *wPasswordLen WORD is updated with the actual number of characters  
....................       written to the vPassword buffer, including the null terminator  
....................       character.  If vPassword is NULL but wPasswordLen is non-NULL, then no  
....................       characters are copied, but *wPasswordLen will return the number of  
....................       characters required to fit the full password string.  If wPasswordLen  
....................       is NULL, then the password field in the URL, if present, is ignored and  
....................       the vPassword pointer is not used. 
....................        
....................       <p>If zero characters were written, this indicates that the URL did not  
....................       contain a password field.  If one character was written, this indicates  
....................       that a password field was present, but was a zero character string  
....................       (ex\: ""). 
....................         
....................       <p>For the example URL provided in the function description, 7 (0x0007)  
....................       would be returned for this field. 
....................        
....................    vHostname - Optional pointer to a buffer to write the decoded hostname  
....................       portion of the URL.  All Internet URLs must contain a hostname or IP  
....................       address, however, if a NULL pointer is supplied, then this field is  
....................       ignored. 
....................  
....................       <p>For the example URL provided in the function description,  
....................       "www.microchip.com" would be returned for this field.  If the URL was  
....................       "http://192.168.0.1", then this field would be returned as  
....................       "192.168.0.1".   The IP address would not be decoded to a DWORD (use the  
....................       StringToIPAddress() helper function to do this). 
....................        
....................    wHostnameLen - 
....................       On call\: Optional pointer to a WORD specifying the maximum length of  
....................       the vHostname buffer, including the null terminator character. 
....................        
....................       <p>Upon return\: If wHostnameLen and vHostname are non-NULL, the  
....................       *wHostnameLen WORD is updated with the actual number of characters  
....................       written to the vHostname buffer, including the null terminator  
....................       character.  If vHostname is NULL but wHostnameLen is non-NULL, then no  
....................       characters are copied, but *wHostnameLen will return the number of  
....................       characters required to fit the full hostname string.  If wHostnameLen  
....................       is NULL, then the hostname field in the URL, is ignored and the  
....................       vHostname pointer is not used. 
....................        
....................       <p>For the example URL provided in the function description,  
....................       18 (0x0012) would be returned for this field.  If the URL was  
....................       "http://192.168.0.1", then this field would be returned as 12 (0x000C). 
....................        
....................    wPort - Optional pointer to a WORD specifying the TCP or UDP port that the  
....................       server is listening on.  If the port field is absent from the URL, then  
....................       this parameter will specify the default port for the protocol.  For  
....................       example, "http://www.microchip.com" would result in 80 being return as  
....................       the specified port. 
....................         
....................       <p>If the wPort pointer is NULL, then the port field in the URL  
....................       is ignored, if present. 
....................        
....................    vFilePath - Optional pointer to a buffer to write the decoded file path  
....................       portion of the URL.  If a NULL pointer is supplied, then this field is  
....................       ignored.  If a file path is not present in the URL, then "/" will be  
....................       returned in this field.   
....................  
....................       <p>For the example URL provided in the function description,  
....................       "/myfile.gif" would be returned for this field. 
....................        
....................    wFilePathLen - 
....................       On call\: Optional pointer to a WORD specifying the maximum length of  
....................       the vFilePath buffer, including the null terminator character. 
....................        
....................       <p>Upon return\: If wFilePathLen and vFilePath are non-NULL, the  
....................       *wFilePathLen WORD is updated with the actual number of characters  
....................       written to the vFilePath buffer, including the null terminator  
....................       character.  If vFilePath is NULL but wFilePathLen is non-NULL, then no  
....................       characters are copied, but *wFilePathLen will return the number of  
....................       characters required to fit the full file path string.  If wFilePathLen  
....................       is NULL, then the file path field in the URL, if present, is ignored and  
....................       the vFilePath pointer is not used. 
....................        
....................       <p>This function always returns "/" if no file path is present, so 
....................       *wFilePathLen will also be at least 2 characters ('/' and null  
....................       terminator) if the pointer is non-NULL. 
....................     
....................       <p>For the example URL provided in the function description, 12 (0x000C)  
....................       would be returned for this field. 
....................        
....................   Returns: 
....................    Zero on success.  Nonzero indicates an error code.  If a nonzero error code  
....................    is returned, none of the returned buffers or pointer values should be  
....................    treated as valid, but some of them may have been written to.  The following  
....................    are all possible return values. 
....................    <table> 
....................       0   No error 
....................       1   Protocol unknown (additional code needs to be added to  
....................           ExtractURLFields() and the PROTOCOLS enum needs to be updated if  
....................           you want to decode URLs of this protocol type. 
....................       2   URL malformed. Illegal or unknown URL format encountered. 
....................       3   Buffer too small.  One of the input buffer sizes is too small to  
....................           contain the URL parameter. 
....................    </table> 
....................   ***************************************************************************/ 
.................... #if 0    
.................... BYTE ExtractURLFields(BYTE *vURL, PROTOCOLS *protocol, BYTE *vUsername, WORD *wUsernameLen, BYTE *vPassword, WORD *wPasswordLen, BYTE *vHostname, WORD *wHostnameLen, WORD *wPort, BYTE *vFilePath, WORD *wFilePathLen) 
.................... { 
....................    // These two arrays must exactly match up each other and the PROTOCOLS enum  
....................    // elements.  The protocol name strings must also be specified in all  
....................    // lowercase. 
....................    static ROM char * ROM   vProtocolNames[] = {"http", "https", "mms", "rtsp"}; 
....................    static ROM WORD       wProtocolPorts[] = { 80,     443,     1755,  554}; 
....................    WORD w, w2; 
....................    BYTE i, j; 
....................    PROTOCOLS prot; 
....................    BYTE *temp, *temp2; 
....................    WORD wURLLen; 
....................    WORD wLocalPort; 
....................     
....................     
....................    // Calculate how long this URL is 
....................    wURLLen = strlen((char*)vURL); 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, '\r'); 
....................    if(temp) 
....................       wURLLen = temp - vURL; 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, '\n'); 
....................    if(temp) 
....................       wURLLen = temp - vURL; 
....................     
....................  
....................    // Parse starting protocol field 
....................    // Find out how long the protocol name field is 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, ':'); 
....................    if(temp == NULL) 
....................       return 2; 
....................     
....................    // Search protocol list to see if this is a recognized protocol 
....................    for(prot = 0; (BYTE)prot < sizeof(wProtocolPorts)/sizeof(wProtocolPorts[0]); prot++) 
....................    { 
....................       w = strlenpgm(vProtocolNames[prot]); 
....................       if((WORD)(temp - vURL) == w) 
....................       { 
....................          w2 = 0; 
....................          temp2 = vURL; 
....................          while(w) 
....................          { 
....................             i = *temp2++; 
....................             if((i >= 'A') && (i <= 'Z')) 
....................                i += 'a' - 'A'; 
....................             if(i != (BYTE)vProtocolNames[prot][w2++]) 
....................                break; 
....................             w--; 
....................          } 
....................          if(w == 0u) 
....................          { 
....................             if(protocol) 
....................                *protocol = prot; 
....................             break; 
....................          } 
....................       } 
....................    } 
....................  
....................    // If we've search the whole list and didn't find a match, then  
....................    // this protocol is unknown and this URL cannot be parsed. 
....................    if((BYTE)prot >= sizeof(wProtocolPorts)/sizeof(wProtocolPorts[0])) 
....................       return 1; 
....................     
....................    w = temp - vURL + 1; 
....................    vURL += w; 
....................    wURLLen -= w; 
....................  
....................    // Protocols using the authority field all must have a double  
....................    // slash "//" prefix 
....................    if(wURLLen < 2u) 
....................       return 2; 
....................    for(j = 0; j < 2u; j++) 
....................    { 
....................       i = *vURL++; 
....................       if(i != '/') 
....................          return 2; 
....................    } 
....................    wURLLen -= 2; 
....................     
....................  
....................    // Parse username and password fields 
....................    // See if there is a @ sign, indicating that there is at  
....................    // least a username and possibly a password in this URL 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, '@'); 
....................    if(temp == NULL) 
....................    { 
....................       if(wUsernameLen) 
....................          *wUsernameLen = 0; 
....................       if(wPasswordLen) 
....................          *wPasswordLen = 0; 
....................    } 
....................    else 
....................    { 
....................       // If we get down here, there is a user name present, let's  
....................       // see if a password is also present by searching for a  
....................       // colon between the current string position and the @  
....................       // symbol. 
....................       temp2 = (BYTE*)strnchr((char*)vURL, temp - vURL, ':'); 
....................        
....................       // Calculate username length and password length, including  
....................       // null terminator (if the field exists) 
....................       if(temp2 == NULL) 
....................       { 
....................          w = temp - vURL + 1;   // Username 
....................          w2 = 0;               // Password 
....................       } 
....................       else 
....................       { 
....................          w = temp2 - vURL + 1;   // Username 
....................          w2 = temp - temp2;      // Password 
....................       } 
....................        
....................       if(wUsernameLen) 
....................       { 
....................          if(vUsername) 
....................          { 
....................             if(*wUsernameLen < w) 
....................                return 3; 
....................             memcpy((void*)vUsername, (void*)vURL, w - 1); 
....................             vUsername[w-1] = 0; 
....................          } 
....................          *wUsernameLen = w; 
....................       } 
....................     
....................       if(wPasswordLen) 
....................       { 
....................          if(vPassword) 
....................          { 
....................             if(*wPasswordLen < w2) 
....................                return 3; 
....................             if(w2) 
....................             { 
....................                memcpy((void*)vPassword, (void*)temp2+1, w2 - 1); 
....................                vPassword[w2-1] = 0; 
....................             } 
....................          } 
....................          *wPasswordLen = w2; 
....................       } 
....................     
....................       vURL += w; 
....................       wURLLen -= w; 
....................       if(w2) 
....................       { 
....................          vURL += w2; 
....................          wURLLen -= w2; 
....................       } 
....................    } 
....................  
....................  
....................    // Parse hostname field 
....................    // Find the length of the hostname, including NULL  
....................    // terminator 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, ':'); 
....................    temp2 = (BYTE*)strnchr((char*)vURL, wURLLen, '/'); 
....................    if(temp && temp2) 
....................    { 
....................       if(temp > temp2) 
....................          temp = NULL; 
....................    } 
....................    if(temp == NULL) 
....................    { 
....................       temp = temp2; 
....................       if(temp2 == NULL) 
....................          temp = vURL + wURLLen; 
....................    } 
....................    w = temp - vURL + 1; 
....................    if(wHostnameLen) 
....................    { 
....................       if(vHostname) 
....................       { 
....................          if(*wHostnameLen < w) 
....................             return 3; 
....................          memcpy((void*)vHostname, (void*)vURL, w - 1); 
....................          vHostname[w-1] = 0; 
....................       } 
....................       *wHostnameLen = w; 
....................    } 
....................    vURL += w - 1; 
....................    wURLLen -= w - 1; 
....................  
....................  
....................    // Parse port field 
....................    if(*vURL == ':') 
....................    { 
....................       vURL++; 
....................       wURLLen--; 
....................       wLocalPort = 0; 
....................       w = wURLLen; 
....................       temp = (BYTE*)strnchr((char*)vURL, wURLLen, '/'); 
....................       if(temp != NULL) 
....................          w = temp - vURL; 
....................       w2 = w; 
....................       if(wPort) 
....................       { 
....................          while(w--) 
....................          { 
....................             wLocalPort *= 10; 
....................             wLocalPort += *vURL++ - '0'; 
....................          } 
....................          *wPort = wLocalPort; 
....................       } 
....................       else 
....................          vURL += w2; 
....................       wURLLen -= w2; 
....................    } 
....................    else if(wPort) 
....................       *wPort = wProtocolPorts[prot]; 
....................  
....................  
....................    // Parse file path field 
....................    if(wFilePathLen) 
....................    { 
....................       w = ++wURLLen; 
....................       if(wURLLen == 1u) 
....................          w = 2; 
....................       if(vFilePath) 
....................       { 
....................          if(*wFilePathLen < w) 
....................             return 3; 
....................          if(wURLLen == 1u) 
....................             vFilePath[0] = '/'; 
....................          else 
....................             memcpy((void*)vFilePath, (void*)vURL, wURLLen - 1); 
....................          vFilePath[w - 1] = 0; 
....................          *wFilePathLen = w; 
....................          return 0; 
....................       } 
....................       *wFilePathLen = w; 
....................    } 
....................    return 0; 
.................... } 
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    SHORT Replace(BYTE *vExpression, ROM BYTE *vFind, ROM BYTE *vReplacement,  
....................               WORD wMaxLen, BOOL bSearchCaseInsensitive) 
....................  
....................   Summary: 
....................    Replaces all instances of a particular substring with a new string 
....................  
....................   Description: 
....................    Searches a string (vExpression) and replaces all instances of a particular  
....................    substring (vFind) with a new string (vReplacement).  The start offset to  
....................    being searching and a maximum number of replacements can be specified.  The  
....................    search can be performed in a case sensitive or case insensitive manner. 
....................  
....................   Precondition: 
....................    This function is commented out by default to save code space because  
....................    it is not used by any current stack features.  However, if you want to use  
....................    it, go ahead and uncomment it.  It has been tested, so it (should) work  
....................    correctly. 
....................  
....................   Parameters: 
....................    vExpression - Null terminated string to search and make replacements within. 
....................    vFind - Null terminated string to search for. 
....................    vReplacement - Null terminated string to replace all instances of vFind with. 
....................    wMaxLen - Maximum length of the output vExpression string if string  
....................       expansion is going to occur (replacement length is longer than find  
....................       length).  If the replacements will cause this maximum string length to  
....................       be exceeded, then no replacements will be made and a negative result  
....................       will be returned, indicating failure.  If the replacement length is  
....................       shorter or equal to the search length, then this parameter is ignored. 
....................    bSearchCaseInsensitive - Boolean indicating if the search should be  
....................       performed in a case insensitive manner.  Specify TRUE for case  
....................       insensitive searches (slower) or FALSE for case sensitive  
....................       searching (faster). 
....................  
....................   Remarks: 
....................    If the replacement string length is shorter than or equal to the search  
....................    string length and the search string occurs in multiple overlapping  
....................    locations (ex\: expression is "aaa", find is "aa", and replacement is "bb")  
....................    then the first find match occuring when searching from left to right will  
....................    be replaced.  (ex\: output expression will be "bba"). 
....................     
....................    However, if the replacement string length is longer than the search string  
....................    length, the search will occur starting from the end of the string and  
....................    proceed to the beginning (right to left searching).  In this case if the  
....................    expression was "aaa", find was "aa", and replacement was "bbb", then the  
....................    final output expression will be "abbb".   
....................  
....................   Returns: 
....................    If zero or greater, indicates the count of how many replacements were made.   
....................    If less than zero (negative result), indicates that wMaxLen was too small  
....................    to make the necessary replacements.  In this case, no replacements were  
....................    made. 
....................   ***************************************************************************/ 
.................... #if 0 
.................... SHORT Replace(BYTE *vExpression, ROM BYTE *vFind, ROM BYTE *vReplacement, WORD wMaxLen, BOOL bSearchCaseInsensitive) 
.................... { 
....................    WORD wExpressionLen, wFindLen, wFindLenMinusOne, wReplacementLen; 
....................    WORD wFindCount, wReplacementsLeft; 
....................    BYTE i, j; 
....................    BYTE vFirstFindChar; 
....................    WORD wBytesLeft; 
....................    BYTE *vDest; 
....................    BYTE *vExpressionCompare; 
....................    ROM BYTE *vFindCompare; 
....................    WORD w; 
....................  
....................    wFindLen = strlenpgm((ROM char*)vFind); 
....................    if(wFindLen == 0u) 
....................       return 0; 
....................     
....................    wExpressionLen = strlen((char*)vExpression); 
....................    wReplacementLen = strlenpgm((ROM char*)vReplacement); 
....................  
....................    wFindCount = 0; 
....................    wFindLenMinusOne = wFindLen - 1; 
....................    vFirstFindChar = *vFind++; 
....................    if(bSearchCaseInsensitive)   // Convert to all lowercase if needed 
....................       if((vFirstFindChar >= (BYTE)'A') && (vFirstFindChar <= (BYTE)'Z')) 
....................          vFirstFindChar += 'a' - 'A'; 
....................  
....................    // If the replacement string is the same length as the search string, then  
....................    // we can immediately do the needed replacements inline and return. 
....................    if(wFindLen == wReplacementLen) 
....................    { 
....................       for(wBytesLeft = wExpressionLen; wBytesLeft; wBytesLeft--) 
....................       { 
....................          i = *vExpression++; 
....................          if(bSearchCaseInsensitive) 
....................          { 
....................             if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                i += 'a' - 'A'; 
....................             if(i != vFirstFindChar) 
....................                continue; 
....................             vExpressionCompare = vExpression; 
....................             vFindCompare = vFind; 
....................             w = wFindLenMinusOne; 
....................             while(w) 
....................             { 
....................                i = *vExpressionCompare++; 
....................                j = *vFindCompare++; 
....................                if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                   i += 'a' - 'A'; 
....................                if((j >= (BYTE)'A') && (j <= (BYTE)'Z')) 
....................                   j += 'a' - 'A'; 
....................                if(i != j) 
....................                   break; 
....................                w--; 
....................             } 
....................             if(w) 
....................                continue; 
....................          } 
....................          else 
....................          { 
....................             if(i != vFirstFindChar) 
....................                continue; 
....................             if(memcmppgm2ram((void*)vExpression, (ROM void*)vFind, wFindLenMinusOne)) 
....................                continue; 
....................          } 
....................     
....................          memcpypgm2ram((void*)vExpression-1, (ROM void*)vReplacement, wReplacementLen); 
....................          wFindCount++; 
....................          vExpression += wFindLenMinusOne; 
....................          wBytesLeft -= wFindLenMinusOne; 
....................       } 
....................       return wFindCount; 
....................    } 
....................     
....................     
....................    // If the replacement string is shorter than the search string, then we can  
....................    // search from left to right and move the string over as we find occurrences. 
....................    if(wFindLen > wReplacementLen) 
....................    { 
....................       vDest = vExpression; 
....................       for(wBytesLeft = wExpressionLen; wBytesLeft; wBytesLeft--) 
....................       { 
....................          i = *vExpression++; 
....................          *vDest++ = i; 
....................          if(bSearchCaseInsensitive) 
....................          { 
....................             if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                i += 'a' - 'A'; 
....................             if(i != vFirstFindChar) 
....................                continue; 
....................             vExpressionCompare = vExpression; 
....................             vFindCompare = vFind; 
....................             w = wFindLenMinusOne; 
....................             while(w) 
....................             { 
....................                i = *vExpressionCompare++; 
....................                j = *vFindCompare++; 
....................                if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                   i += 'a' - 'A'; 
....................                if((j >= (BYTE)'A') && (j <= (BYTE)'Z')) 
....................                   j += 'a' - 'A'; 
....................                if(i != j) 
....................                   break; 
....................                w--; 
....................             } 
....................             if(w) 
....................                continue; 
....................          } 
....................          else 
....................          { 
....................             if(i != vFirstFindChar) 
....................                continue; 
....................             if(memcmppgm2ram((void*)vExpression, (ROM void*)vFind, wFindLenMinusOne)) 
....................                continue; 
....................          } 
....................     
....................          memcpypgm2ram((void*)vDest-1, (ROM void*)vReplacement, wReplacementLen); 
....................          vDest += wReplacementLen-1; 
....................          wFindCount++; 
....................          vExpression += wFindLenMinusOne; 
....................          wBytesLeft -= wFindLenMinusOne; 
....................       } 
....................       *vDest = 0x00;   // Write new null terminator since the string may have shrunk 
....................       return wFindCount; 
....................    } 
....................     
....................    // If the replacement string is longer than the search string, then we will  
....................    // take a two pass approach.  On the first pass, we will merely count how  
....................    // many replacements to make.  With this we can calculate how long the  
....................    // final string is going to be.  On the second pass, we will search from  
....................    // right to left and expand the string as needed. 
....................  
....................    // Pass 1: count how many occurrences of vFind are in vExpression 
....................    for(wBytesLeft = wExpressionLen; wBytesLeft; wBytesLeft--) 
....................    { 
....................       i = *vExpression++; 
....................       if(bSearchCaseInsensitive) 
....................       { 
....................          if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................             i += 'a' - 'A'; 
....................          if(i != vFirstFindChar) 
....................             continue; 
....................          vExpressionCompare = vExpression; 
....................          vFindCompare = vFind; 
....................          w = wFindLenMinusOne; 
....................          while(w) 
....................          { 
....................             i = *vExpressionCompare++; 
....................             j = *vFindCompare++; 
....................             if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                i += 'a' - 'A'; 
....................             if((j >= (BYTE)'A') && (j <= (BYTE)'Z')) 
....................                j += 'a' - 'A'; 
....................             if(i != j) 
....................                break; 
....................             w--; 
....................          } 
....................          if(w) 
....................             continue; 
....................       } 
....................       else 
....................       { 
....................          if(i != vFirstFindChar) 
....................             continue; 
....................          if(memcmppgm2ram((void*)vExpression, (ROM void*)vFind, wFindLenMinusOne)) 
....................             continue; 
....................       } 
....................  
....................       wFindCount++; 
....................       vExpression += wFindLenMinusOne; 
....................       wBytesLeft -= wFindLenMinusOne; 
....................    } 
....................     
....................    // Return immediately if no replacements are needed 
....................    if(wFindCount == 0u) 
....................       return 0; 
....................  
....................    // Pass 2: make replacements and move string over 
....................    vDest = vExpression + wFindCount * (wReplacementLen - wFindLen); 
....................    if(vDest > vExpression - wExpressionLen + wMaxLen) 
....................       return -1; 
....................    *vDest-- = 0x00;   // Write new null terminator 
....................    vExpression -= 1; 
....................    vFind -= 1; 
....................    vFirstFindChar = vFind[wFindLenMinusOne]; 
....................    if(bSearchCaseInsensitive)   // Convert to all lowercase if needed 
....................       if((vFirstFindChar >= (BYTE)'A') && (vFirstFindChar <= (BYTE)'Z')) 
....................          vFirstFindChar += 'a' - 'A'; 
....................    wReplacementsLeft = wFindCount; 
....................    while(wReplacementsLeft) 
....................    { 
....................       i = *vExpression--; 
....................       *vDest-- = i; 
....................       if(bSearchCaseInsensitive) 
....................       { 
....................          if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................             i += 'a' - 'A'; 
....................          if(i != vFirstFindChar) 
....................             continue; 
....................          vExpressionCompare = vExpression; 
....................          vFindCompare = &vFind[wFindLenMinusOne-1]; 
....................          w = wFindLenMinusOne; 
....................          while(w) 
....................          { 
....................             i = *vExpressionCompare--; 
....................             j = *vFindCompare--; 
....................             if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                i += 'a' - 'A'; 
....................             if((j >= (BYTE)'A') && (j <= (BYTE)'Z')) 
....................                j += 'a' - 'A'; 
....................             if(i != j) 
....................                break; 
....................             w--; 
....................          } 
....................          if(w) 
....................             continue; 
....................       } 
....................       else 
....................       { 
....................          if(i != vFirstFindChar) 
....................             continue; 
....................          if(memcmppgm2ram((void*)vExpression-wFindLenMinusOne, (ROM void*)vFind, wFindLenMinusOne)) 
....................             continue; 
....................       } 
....................       memcpypgm2ram((void*)vDest-wReplacementLen+2, (ROM void*)vReplacement, wReplacementLen); 
....................       vDest -= wReplacementLen-1; 
....................  
....................       vExpression -= wFindLenMinusOne; 
....................       wBytesLeft -= wFindLenMinusOne; 
....................       wReplacementsLeft--; 
....................    } 
....................    return wFindCount; 
.................... } 
.................... #endif 
....................  
.................... //#include "Delay.c" //not needed, we overrode this in StackTsk2.h 
.................... #include "Tick.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for Timekeeping 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.c 
....................  * Dependencies:    Timer 0 (PIC18) or Timer 1 (PIC24F, PIC24H,  
....................  *					dsPIC30F, dsPIC33F, PIC32) 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.10b or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder		6/13/07		Changed to use timer without  
....................  *									writing for perfect accuracy. 
.................... ********************************************************************/ 
.................... #define __TICK_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... // Internal counter to store Ticks.  This variable is incremented in an ISR and  
.................... // therefore must be marked volatile to prevent the compiler optimizer from  
.................... // reordering code to use this value in the main context while interrupts are  
.................... // disabled. 
.................... static volatile DWORD dwInternalTicks = 0; 
....................  
.................... // 6-byte value to store Ticks.  Allows for use over longer periods of time. 
.................... static BYTE vTickReading[6]; 
....................  
.................... static void GetTickCopy(void); 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	void TickInit(void) 
....................  
....................   Summary: 
.................... 	Initializes the Tick manager module. 
....................  
....................   Description: 
.................... 	Configures the Tick module and any necessary hardware resources. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	None 
....................   	 
....................   Remarks: 
.................... 	This function is called only one during lifetime of the application. 
....................   ***************************************************************************/ 
.................... void TickInit(void) 
.................... { 
.................... #if defined(__18CXX) 
.................... 	// Use Timer0 for 8 bit processors 
....................     // Initialize the time 
....................     TMR0H = 0; 
*
00310:  CLRF   FD7
....................     TMR0L = 0; 
00312:  CLRF   FD6
....................  
.................... 	// Set up the timer interrupt 
.................... 	INTCON2bits.TMR0IP = 0;		// Low priority 
00314:  BCF    FF1.2
....................     INTCONbits.TMR0IF = 0; 
00316:  BCF    FF2.2
....................     INTCONbits.TMR0IE = 1;		// Enable interrupt 
00318:  BSF    FF2.5
....................  
....................     // Timer0 on, 16-bit, internal timer, 1:256 prescalar 
....................     T0CON = 0x87; 
0031A:  MOVLW  87
0031C:  MOVWF  FD5
....................  
.................... #else 
0031E:  GOTO   032A (RETURN)
.................... 	// Use Timer 1 for 16-bit and 32-bit processors 
.................... 	// 1:256 prescale 
.................... 	T1CONbits.TCKPS = 3; 
.................... 	// Base 
.................... 	PR1 = 0xFFFF; 
.................... 	// Clear counter 
.................... 	TMR1 = 0; 
....................  
.................... 	// Enable timer interrupt 
.................... 	#if defined(__C30__) 
.................... 		IPC0bits.T1IP = 2;	// Interrupt priority 2 (low) 
.................... 		IFS0bits.T1IF = 0; 
.................... 		IEC0bits.T1IE = 1; 
.................... 	#else 
.................... 		IPC1bits.T1IP = 2;	// Interrupt priority 2 (low) 
.................... 		IFS0CLR = _IFS0_T1IF_MASK; 
.................... 		IEC0SET = _IEC0_T1IE_MASK; 
.................... 	#endif 
....................  
.................... 	// Start timer 
.................... 	T1CONbits.TON = 1; 
.................... #endif 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	static void GetTickCopy(void) 
....................  
....................   Summary: 
.................... 	Reads the tick value. 
....................  
....................   Description: 
.................... 	This function performs an interrupt-safe and synchronized read of the  
.................... 	48-bit Tick value. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	None 
....................   ***************************************************************************/ 
.................... static void GetTickCopy(void) 
.................... { 
.................... 	// Perform an Interrupt safe and synchronized read of the 48-bit  
.................... 	// tick value 
.................... #if defined(__18CXX) 
.................... 	do 
.................... 	{ 
.................... 		INTCONbits.TMR0IE = 1;		// Enable interrupt 
*
00DFC:  BSF    FF2.5
.................... 		Nop(); 
00DFE:  NOP   
.................... 		INTCONbits.TMR0IE = 0;		// Disable interrupt 
00E00:  BCF    FF2.5
.................... 		vTickReading[0] = TMR0L; 
00E02:  MOVFF  FD6,75
.................... 		vTickReading[1] = TMR0H; 
00E06:  MOVFF  FD7,76
.................... 		*((DWORD*)&vTickReading[2]) = dwInternalTicks; 
00E0A:  MOVLB  2
00E0C:  CLRF   xA1
00E0E:  MOVLW  77
00E10:  MOVWF  FE9
00E12:  MOVFF  2A1,FEA
00E16:  MOVFF  71,FEF
00E1A:  MOVFF  72,FEC
00E1E:  MOVFF  73,FEC
00E22:  MOVFF  74,FEC
.................... 	} while(INTCONbits.TMR0IF); 
00E26:  BTFSS  FF2.2
00E28:  BRA    0E2E
00E2A:  MOVLB  0
00E2C:  BRA    0DFC
.................... 	INTCONbits.TMR0IE = 1;			// Enable interrupt 
00E2E:  BSF    FF2.5
.................... #elif defined(__C30__) 
00E30:  MOVLB  0
00E32:  RETURN 0
.................... 	do 
.................... 	{ 
.................... 		DWORD dwTempTicks; 
.................... 		 
.................... 		IEC0bits.T1IE = 1;			// Enable interrupt 
.................... 		Nop(); 
.................... 		IEC0bits.T1IE = 0;			// Disable interrupt 
....................  
.................... 		// Get low 2 bytes 
.................... 		((WORD*)vTickReading)[0] = TMR1; 
.................... 		 
.................... 		// Correct corner case where interrupt increments byte[4+] but  
.................... 		// TMR1 hasn't rolled over to 0x0000 yet 
.................... 		dwTempTicks = dwInternalTicks; 
.................... 		if(((WORD*)vTickReading)[0] == 0xFFFFu) 
.................... 			dwTempTicks--; 
.................... 		 
.................... 		// Get high 4 bytes 
.................... 		vTickReading[2] = ((BYTE*)&dwTempTicks)[0]; 
.................... 		vTickReading[3] = ((BYTE*)&dwTempTicks)[1]; 
.................... 		vTickReading[4] = ((BYTE*)&dwTempTicks)[2]; 
.................... 		vTickReading[5] = ((BYTE*)&dwTempTicks)[3]; 
.................... 	} while(IFS0bits.T1IF); 
.................... 	IEC0bits.T1IE = 1;				// Enable interrupt 
.................... #else	// PIC32 
.................... 	do 
.................... 	{ 
.................... 		DWORD dwTempTicks; 
.................... 		 
.................... 		IEC0SET = _IEC0_T1IE_MASK;	// Enable interrupt 
.................... 		Nop(); 
.................... 		IEC0CLR = _IEC0_T1IE_MASK;	// Disable interrupt 
.................... 		 
.................... 		// Get low 2 bytes 
.................... 		((volatile WORD*)vTickReading)[0] = TMR1; 
.................... 		 
.................... 		// Correct corner case where interrupt increments byte[4+] but  
.................... 		// TMR1 hasn't rolled over to 0x0000 yet 
.................... 		dwTempTicks = dwInternalTicks; 
....................  
.................... 		// PIC32MX3XX/4XX devices trigger the timer interrupt when TMR1 == PR1  
.................... 		// (TMR1 prescalar is 0x00), requiring us to undo the ISR's increment  
.................... 		// of the upper 32 bits of our 48 bit timer in the special case when  
.................... 		// TMR1 == PR1 == 0xFFFF.  For other PIC32 families, the ISR is  
.................... 		// triggered when TMR1 increments from PR1 to 0x0000, making no special  
.................... 		// corner case. 
.................... 		#if __PIC32_FEATURE_SET__ <= 460 
.................... 			if(((WORD*)vTickReading)[0] == 0xFFFFu) 
.................... 				dwTempTicks--; 
.................... 		#elif !defined(__PIC32_FEATURE_SET__) 
.................... 			#error __PIC32_FEATURE_SET__ macro must be defined.  You need to download a newer C32 compiler version. 
.................... 		#endif 
.................... 		 
.................... 		// Get high 4 bytes 
.................... 		vTickReading[2] = ((BYTE*)&dwTempTicks)[0]; 
.................... 		vTickReading[3] = ((BYTE*)&dwTempTicks)[1]; 
.................... 		vTickReading[4] = ((BYTE*)&dwTempTicks)[2]; 
.................... 		vTickReading[5] = ((BYTE*)&dwTempTicks)[3]; 
.................... 	} while(IFS0bits.T1IF); 
.................... 	IEC0SET = _IEC0_T1IE_MASK;		// Enable interrupt 
.................... #endif 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	DWORD TickGet(void) 
....................  
....................   Summary: 
.................... 	Obtains the current Tick value. 
....................  
....................   Description: 
.................... 	This function retrieves the current Tick value, allowing timing and 
.................... 	measurement code to be written in a non-blocking fashion.  This function 
.................... 	retrieves the least significant 32 bits of the internal tick counter,  
.................... 	and is useful for measuring time increments ranging from a few  
.................... 	microseconds to a few hours.  Use TickGetDiv256 or TickGetDiv64K for 
.................... 	longer periods of time. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	Lower 32 bits of the current Tick value. 
....................   ***************************************************************************/ 
.................... DWORD TickGet(void) 
.................... { 
.................... 	GetTickCopy(); 
00E34:  RCALL  0DFC
.................... 	return *((DWORD*)&vTickReading[0]); 
00E36:  MOVLB  2
00E38:  CLRF   xA1
00E3A:  MOVLW  75
00E3C:  MOVFF  2A1,03
00E40:  MOVWF  FE9
00E42:  MOVFF  2A1,FEA
00E46:  MOVFF  FEF,00
00E4A:  MOVFF  FEC,01
00E4E:  MOVFF  FEC,02
00E52:  MOVFF  FEC,03
00E56:  MOVLB  0
00E58:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	DWORD TickGetDiv256(void) 
....................  
....................   Summary: 
.................... 	Obtains the current Tick value divided by 256. 
....................  
....................   Description: 
.................... 	This function retrieves the current Tick value, allowing timing and 
.................... 	measurement code to be written in a non-blocking fashion.  This function 
.................... 	retrieves the middle 32 bits of the internal tick counter,  
.................... 	and is useful for measuring time increments ranging from a few  
.................... 	minutes to a few weeks.  Use TickGet for shorter periods or TickGetDiv64K 
.................... 	for longer ones. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	Middle 32 bits of the current Tick value. 
....................   ***************************************************************************/ 
.................... DWORD TickGetDiv256(void) 
.................... { 
.................... 	DWORD dw; 
....................  
.................... 	GetTickCopy(); 
*
00EB8:  RCALL  0DFC
.................... 	((BYTE*)&dw)[0] = vTickReading[1];	// Note: This copy must be done one  
00EBA:  MOVFF  76,274
.................... 	((BYTE*)&dw)[1] = vTickReading[2];	// byte at a time to prevent misaligned  
00EBE:  MOVFF  77,275
.................... 	((BYTE*)&dw)[2] = vTickReading[3];	// memory reads, which will reset the PIC. 
00EC2:  MOVFF  78,276
.................... 	((BYTE*)&dw)[3] = vTickReading[4]; 
00EC6:  MOVFF  79,277
.................... 	 
.................... 	return dw; 
00ECA:  MOVFF  274,00
00ECE:  MOVFF  275,01
00ED2:  MOVFF  276,02
00ED6:  MOVFF  277,03
00EDA:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	DWORD TickGetDiv64K(void) 
....................  
....................   Summary: 
.................... 	Obtains the current Tick value divided by 64K. 
....................  
....................   Description: 
.................... 	This function retrieves the current Tick value, allowing timing and 
.................... 	measurement code to be written in a non-blocking fashion.  This function 
.................... 	retrieves the most significant 32 bits of the internal tick counter,  
.................... 	and is useful for measuring time increments ranging from a few  
.................... 	days to a few years, or for absolute time measurements.  Use TickGet or 
.................... 	TickGetDiv256 for shorter periods of time. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	Upper 32 bits of the current Tick value. 
....................   ***************************************************************************/ 
.................... DWORD TickGetDiv64K(void) 
.................... { 
.................... 	DWORD dw; 
....................  
.................... 	GetTickCopy(); 
.................... 	((BYTE*)&dw)[0] = vTickReading[2];	// Note: This copy must be done one  
.................... 	((BYTE*)&dw)[1] = vTickReading[3];	// byte at a time to prevent misaligned  
.................... 	((BYTE*)&dw)[2] = vTickReading[4];	// memory reads, which will reset the PIC. 
.................... 	((BYTE*)&dw)[3] = vTickReading[5]; 
.................... 	 
.................... 	return dw; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	DWORD TickConvertToMilliseconds(DWORD dwTickValue) 
....................  
....................   Summary: 
.................... 	Converts a Tick value or difference to milliseconds. 
....................  
....................   Description: 
.................... 	This function converts a Tick value or difference to milliseconds.  For 
.................... 	example, TickConvertToMilliseconds(32768) returns 1000 when a 32.768kHz  
.................... 	clock with no prescaler drives the Tick module interrupt. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	dwTickValue	- Value to convert to milliseconds 
....................  
....................   Returns: 
....................   	Input value expressed in milliseconds. 
....................  
....................   Remarks: 
.................... 	This function performs division on DWORDs, which is slow.  Avoid using 
.................... 	it unless you absolutely must (such as displaying data to a user).  For 
.................... 	timeout comparisons, compare the current value to a multiple or fraction  
.................... 	of TICK_SECOND, which will be calculated only once at compile time. 
....................   ***************************************************************************/ 
.................... DWORD TickConvertToMilliseconds(DWORD dwTickValue) 
.................... { 
.................... 	return (dwTickValue+(TICKS_PER_SECOND/2000ul))/((DWORD)(TICKS_PER_SECOND/1000ul)); 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	void TickUpdate(void) 
....................  
....................   Description: 
.................... 	Updates the tick value when an interrupt occurs. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	None 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... void TickUpdate(void) 
.................... { 
....................     if(INTCONbits.TMR0IF) 
*
0009E:  BTFSS  FF2.2
000A0:  BRA    00B4
....................     { 
.................... 		// Increment internal high tick counter 
.................... 		dwInternalTicks++; 
000A2:  MOVLW  01
000A4:  ADDWF  x71,F
000A6:  BTFSC  FD8.0
000A8:  INCF   x72,F
000AA:  BTFSC  FD8.2
000AC:  INCF   x73,F
000AE:  BTFSC  FD8.2
000B0:  INCF   x74,F
....................  
.................... 		// Reset interrupt flag 
....................         INTCONbits.TMR0IF = 0; 
000B2:  BCF    FF2.2
....................     } 
000B4:  GOTO   00BA (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	void _ISR _T1Interrupt(void) 
....................  
....................   Description: 
.................... 	Updates the tick value when an interrupt occurs. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	None 
....................   ***************************************************************************/ 
.................... #elif defined(__PIC32MX__) 
.................... void __attribute((interrupt(ipl2), vector(_TIMER_1_VECTOR), nomips16)) _T1Interrupt(void) 
.................... { 
.................... 	// Increment internal high tick counter 
.................... 	dwInternalTicks++; 
....................  
.................... 	// Reset interrupt flag 
.................... 	IFS0CLR = _IFS0_T1IF_MASK; 
.................... } 
.................... #else 
.................... #if defined(__PCD__)  //__CCS__ __PCH__ __PCD__ ccs added 
.................... #int_timer1 NOCLEAR 
.................... void _T1Interrupt(void) 
.................... #elif __C30_VERSION__ >= 300 
.................... void _ISR __attribute__((__no_auto_psv__)) _T1Interrupt(void) 
.................... #else 
.................... void _ISR _T1Interrupt(void) 
.................... #endif 
.................... { 
.................... 	// Increment internal high tick counter 
.................... 	dwInternalTicks++; 
....................  
.................... 	// Reset interrupt flag 
.................... 	IFS0bits.T1IF = 0; 
.................... } 
.................... #endif 
....................  
.................... #if !defined(ENC_CS_TRIS) && !defined(WF_CS_TRIS) && !defined(ENC100_INTERFACE_MODE) && \ 
....................     (defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) || \ 
....................      defined(_18F97J60) ||  defined(_18F96J65) ||  defined(_18F96J60) ||  defined(_18F87J60) ||  defined(_18F86J65) ||  defined(_18F86J60) ||  defined(_18F67J60) ||  defined(_18F66J65) ||  defined(_18F66J60)) 
....................    #include "ETH97J60.c" 
.................... /********************************************************************* 
....................  PIC18F97J60 Family Ethernet Driver 
....................   - This is a driver module for Microchip TCPIP stack 
....................   - PIC18F97J60 family data sheet 
....................   - IEEE 802.3 standard 
....................   
....................  FileName:      ETH97J60.c 
....................  Dependencies:	See INCLUDES section 
....................  Processor:		PIC18F97J60 Family 
....................  Complier:  	Microchip C18 (for PIC18) 
....................  Company:		Microchip Technology, Inc. 
....................  Misc:          Medium Access Control (MAC) Layer for Microchip  
....................                 PIC18F97J60 family 
....................   
....................   Software License Agreement 
....................   
....................   Copyright (C) 2002-2010 Microchip Technology Inc.  All rights 
....................   reserved. 
....................   
....................   Microchip licenses to you the right to use, modify, copy, and 
....................   distribute: 
....................   (i)  the Software when embedded on a Microchip microcontroller or 
....................        digital signal controller product ("Device") which is 
....................        integrated into Licensee's product; or 
....................   (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  		used in conjunction with a Microchip ethernet controller for 
....................  		the sole purpose of interfacing with the ethernet controller. 
....................   
....................   You should refer to the license agreement accompanying this 
....................   Software for additional information regarding your rights and 
....................   obligations. 
....................   
....................   THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................   WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................   LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................   PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................   MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................   CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................   PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................   BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................   THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................   SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................   (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................   
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Description 
....................   ----  ----------------------------------------- 
....................   1.0   Initial release 
....................  
....................   5.31  Added support for external auto-parity detection/correction 
....................    
....................   5.36  Fixed a run-time bug in MACPut() when using extended instruction set 
....................    
....................   Darren Rook/CCS    Added __MY_ENC_LED_CONFIG__, so your application can redefine LED config. 
.................... ********************************************************************/ 
.................... #define __ETH97J60_C 
....................  
.................... #include "HardwareProfile.h" 
.................... // hardwareprofile.h 
....................  
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #if STACK_USE_CCS_EWLWIFIB || STACK_USE_CCS_EWLWIFIG 
....................  
....................    #bit WF_CS_TRIS1   =     0xF96.1 //E1 
....................    #define WF_CS_TRIS WF_CS_TRIS1 
....................    #bit WF_CS_IO     =  0xF8D.1    //LatE1 
....................    #bit WF_SDI_TRIS  =  0xF94.4    // (TRISCbits.TRISC4) 
....................    #bit WF_SCK_TRIS  =  0xF94.3    // (TRISCbits.TRISC3) 
....................    #bit WF_SDO_TRIS  =  0xF94.5    // (TRISCbits.TRISC5) 
....................    #bit WF_RESET_TRIS=  0xF93.1    //(TRISBbits.TRISB1) 
....................    #bit WF_RESET_IO  =  0xF8A.1     //(LATBbits.LATB1)   
....................    #bit WF_INT_TRIS  =  0xF93.0     // (TRISBbits.TRISB0)  // INT1 
....................    #bit WF_INT_IO    =  0xF81.0   //(PORTBbits.RB0)  
....................    #bit WF_HIBERNATE_TRIS= 0xF93.2  //(TRISBbits.TRISB2)  
....................    #bit   WF_HIBERNATE_IO=  0xF81.2    //(PORTBbits.RB2) 
....................     
....................    #bit WF_INT_EDGE  =  0xFF1.6      //(INTCON2bits.INTEDG0) 
....................    #bit WF_INT_IE    =  0xFF2.4   //(INTCONbits.INT0IE) 
....................    #bit WF_INT_IF    =  0xFF2.1   //(INTCONbits.INT0IF) 
....................    #define WF_SSPBUF  (SSP1BUF) 
....................    #define WF_SPISTAT  (SSP1STATbits) 
....................    #define WF_SPISTATbits SSP1STATbits     //(SSP1STATbits) 
....................    #define WF_SPICON1  (SSP1CON1bits) 
....................    #define WF_SPICON1bits WF_SPICON1    // (SSP1CON1bits) 
....................    #define WF_SPICON2  (SSP1CON2bits) 
....................    #bit WF_SPI_IE    =   0xF9D.3  //(PIE1bits.SSPIE) 
....................    #bit WF_SPI_IP    =   0xF9F.3  //(IPR1bits.SSPIP) 
....................    #bit WF_SPI_IF    =   0xF9E.3  //(PIR1bits.SSPIF) 
....................     
.................... #else 
....................  
.................... //#error define necessary hardware for TCPIP stack 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... // Make sure that this hardware profile has a PIC18F97J60 family device in it 
.................... #if (defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) || \ 
.................... 	  defined(_18F97J60) ||  defined(_18F96J65) ||  defined(_18F96J60) ||  defined(_18F87J60) ||  defined(_18F86J65) ||  defined(_18F86J60) ||  defined(_18F67J60) ||  defined(_18F66J65) ||  defined(_18F66J60)) \ 
.................... 	&& !defined(ENC_CS_TRIS) && !defined(ENC100_INTERFACE_MODE) && !defined(WF_CS_TRIS) 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
....................    // Configure LEDA to display LINK status, LEDB to display TX/RX activity 
....................   #ifndef __MY_ENC_LED_CONFIG__ 
....................    #define __MY_ENC_LED_CONFIG__ 0x3472 
....................   #endif 
....................  
.................... /** D E F I N I T I O N S ****************************************************/ 
.................... // Since the Ethernet PHY doesn't support auto-negotiation, full-duplex mode is 
.................... // not compatible with most switches/routers.  If a dedicated network is used 
.................... // where the duplex of the remote node can be manually configured, you may 
.................... // change this configuration.  Otherwise, half duplex should always be used. 
.................... #define HALF_DUPLEX 
.................... //#define FULL_DUPLEX 
....................  
.................... // Pseudo Functions 
.................... #define LOW(a) 					(a & 0xFF) 
.................... #define HIGH(a) 				((a>>8) & 0xFF) 
....................  
.................... #define ETHER_IP	(0x00u) 
.................... #define ETHER_ARP	(0x06u) 
....................  
.................... // A header appended at the start of all RX frames by the hardware 
.................... typedef struct 
.................... { 
....................     WORD			NextPacketPointer; 
....................     RXSTATUS		StatusVector; 
....................  
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ENC_PREAMBLE; 
....................  
....................  
.................... // Internal MAC level variables and flags. 
.................... static WORD_VAL NextPacketLocation; 
.................... static WORD_VAL CurrentPacketLocation; 
.................... static union 
.................... { 
.................... 	unsigned char v; 
.................... 	struct 
.................... 	{ 
.................... 		unsigned char bWasDiscarded : 1; 
.................... 		unsigned char bRXPolarityValid : 1; 
.................... 		unsigned char bRXPolarityTimerOnTX	: 1; 
.................... 		unsigned char bRXPolarityAtNextTX : 1; 
.................... 		unsigned char filler : 4; 
.................... 	} bits; 
.................... } flags; 
.................... static WORD wTXWatchdog;	// Time of last transmission (high resolution); used for determining when TX hardware may need software intervention 
.................... #if defined(ETH_RX_POLARITY_SWAP_TRIS) 
.................... 	static WORD wRXPolarityTimer;	// Time of last transmission (long duration); used for determining when a RX polarity swap may be needed 
.................... #endif 
....................  
.................... #if defined(HI_TECH_C) 
.................... 	// Define a temporary register for passing data to inline assembly  
.................... 	// statements.  MPLAB C18 uses PRODL and therefore doesn't need this temp  
.................... 	// byte, but the HI-TECH PICC-18 compiler uses PRODL differently and doesn't  
.................... 	// allow it to be used as a temporary byte. 
.................... 	static unsigned char errataTempL @ 0xE7E;	// Six least significant address bits must not be '110110' for Ethernet MIIM Errata workaround (issue #5). 
.................... 	static unsigned char errataTempH @ 0xE7F;	// Six least significant address bits must not be '110110' for Ethernet MIIM Errata workaround (issue #5). 
.................... #endif 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACInit enables the Ethernet module, waits for the 
....................  *                  to become ready, and programs all registers for future 
....................  *                  TX/RX operations. 
....................  * 
....................  * Note:            This function blocks for at least 1ms, waiting for the 
....................  *                  hardware to stabilize. 
....................  *****************************************************************************/ 
.................... void MACInit(void) 
.................... { 
.................... 	BYTE i; 
....................  
.................... 	TRISA &= 0xFC;			// Clear TRISA0 and TRISA1 to set LED0 and LED1 as outputs for Ethernet module status 
*
005DA:  MOVLW  FC
005DC:  ANDWF  F92,F
....................     ECON2bits.ETHEN = 1;	// Enable Ethernet! 
005DE:  MOVLB  E
005E0:  BSF    xFE.5
....................  
.................... 	// If Ethernet TPIN+/- RX polarity swap hardware exists, start controlling  
.................... 	// it and default it to the non-swapped state. 
.................... 	#if defined(ETH_RX_POLARITY_SWAP_TRIS) 
.................... 		ETH_RX_POLARITY_SWAP_TRIS = 0; 
.................... 		ETH_RX_POLARITY_SWAP_IO = 0; 
.................... 	#endif 
....................  
.................... 	// Wait for PHYRDY to become set. 
....................     while(!ESTATbits.PHYRDY); 
005E2:  BTFSS  xFD.0
005E4:  BRA    05E2
....................  
.................... 	// Configure the receive buffer boundary pointers 
.................... 	// and the buffer write protect pointer (receive buffer read pointer) 
.................... 	flags.v = 0; 
005E6:  MOVLB  0
005E8:  CLRF   x7F
.................... 	flags.bits.bWasDiscarded = 1; 
005EA:  BSF    x7F.0
.................... 	NextPacketLocation.Val = RXSTART; 
005EC:  CLRF   x7C
005EE:  CLRF   x7B
.................... 	ERXST = RXSTART; 
005F0:  MOVLB  E
005F2:  CLRF   xE9
005F4:  CLRF   xE8
.................... 	ERXRDPTL = LOW(RXSTOP);	// Write low byte first 
005F6:  MOVLW  09
005F8:  MOVWF  xEC
.................... 	ERXRDPTH = HIGH(RXSTOP);// Write high byte last 
005FA:  MOVLW  15
005FC:  MOVWF  xED
.................... 	ERXND = RXSTOP; 
005FE:  MOVWF  xEB
00600:  MOVLW  09
00602:  MOVWF  xEA
.................... 	ETXST = TXSTART; 
00604:  MOVLW  15
00606:  MOVWF  xE5
00608:  MOVLW  0A
0060A:  MOVWF  xE4
....................  
.................... 	// Write a permanant per packet control byte of 0x00 
.................... 	EWRPT = TXSTART; 
0060C:  MOVLW  15
0060E:  MOVWF  xE3
00610:  MOVLW  0A
00612:  MOVWF  xE2
.................... 	MACPut(0x00); 
00614:  MOVLB  2
00616:  CLRF   xC2
00618:  MOVLB  0
0061A:  RCALL  05A0
....................  
.................... 	// Configure Receive Filters 
.................... 	// (No need to reconfigure - Unicast OR Broadcast with CRC checking is 
.................... 	// acceptable) 
.................... 	//ERXFCON = ERXFCON_CRCEN;     // Promiscious mode 
....................  
.................... 	// Configure the MAC 
.................... 	// Enable the receive portion of the MAC 
....................     MACON1 = MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN; Nop(); 
0061C:  MOVLW  0D
0061E:  MOVLB  E
00620:  MOVWF  xA0
00622:  NOP   
....................  
.................... 	// Pad packets to 60 bytes, add CRC, and check Type/Length field. 
.................... #if defined(FULL_DUPLEX) 
.................... 	MACON3 = MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN | MACON3_FULDPX; Nop(); 
.................... 	MABBIPG = 0x15; Nop(); 
.................... #else 
.................... 	MACON3 = MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN; Nop(); 
00624:  MOVLW  32
00626:  MOVWF  xA2
00628:  NOP   
.................... 	MABBIPG = 0x12; Nop(); 
0062A:  MOVLW  12
0062C:  MOVWF  xA4
0062E:  NOP   
.................... #endif 
....................  
....................     // Allow infinite deferals if the medium is continuously busy 
....................     // (do not time out a transmission if the half duplex medium is 
....................     // completely saturated with other people's data) 
....................     MACON4 = MACON4_DEFER; Nop(); 
00630:  MOVLW  40
00632:  MOVWF  xA3
00634:  NOP   
....................  
.................... 	// Set non-back-to-back inter-packet gap to 9.6us.  The back-to-back 
.................... 	// inter-packet gap (MABBIPG) is set by MACSetDuplex() which is called 
.................... 	// later. 
....................     MAIPGL = 0x12; Nop(); 
00636:  MOVLW  12
00638:  MOVWF  xA6
0063A:  NOP   
....................     MAIPGH = 0x0C; Nop(); 
0063C:  MOVLW  0C
0063E:  MOVWF  xA7
00640:  NOP   
....................  
.................... 	// Set the maximum packet size which the controller will accept 
....................     MAMXFLL = LOW(6+6+2+1500+4); Nop(); 
00642:  MOVLW  EE
00644:  MOVWF  xAA
00646:  NOP   
....................     MAMXFLH = HIGH(6+6+2+1500+4); Nop(); 
00648:  MOVLW  05
0064A:  MOVWF  xAB
0064C:  NOP   
....................  
....................     // Initialize physical MAC address registers 
.................... 	MAADR1 = AppConfig.MyMACAddr.v[0]; Nop(); 
0064E:  MOVFF  57,E84
00652:  NOP   
.................... 	MAADR2 = AppConfig.MyMACAddr.v[1]; Nop(); 
00654:  MOVFF  58,E85
00658:  NOP   
.................... 	MAADR3 = AppConfig.MyMACAddr.v[2]; Nop(); 
0065A:  MOVFF  59,E82
0065E:  NOP   
.................... 	MAADR4 = AppConfig.MyMACAddr.v[3]; Nop(); 
00660:  MOVFF  5A,E83
00664:  NOP   
.................... 	MAADR5 = AppConfig.MyMACAddr.v[4]; Nop(); 
00666:  MOVFF  5B,E80
0066A:  NOP   
.................... 	MAADR6 = AppConfig.MyMACAddr.v[5]; Nop(); 
0066C:  MOVFF  5C,E81
00670:  NOP   
....................  
.................... 	// Disable half duplex loopback in PHY and set RXAPDIS bit as per errata 
.................... 	WritePHYReg(PHCON2, PHCON2_HDLDIS | PHCON2_RXAPDIS); 
00672:  MOVLW  10
00674:  MOVLB  1
00676:  MOVWF  x6F
00678:  MOVLW  01
0067A:  MOVWF  x71
0067C:  MOVLW  10
0067E:  MOVWF  x70
00680:  MOVLB  0
00682:  RCALL  05AA
....................  
.................... 	// Configure LEDA to display LINK status, LEDB to display TX/RX activity 
.................... 	SetLEDConfig(__MY_ENC_LED_CONFIG__);   //__CCS__ 
00684:  MOVLW  14
00686:  MOVLB  1
00688:  MOVWF  x6F
0068A:  MOVLW  34
0068C:  MOVWF  x71
0068E:  MOVLW  72
00690:  MOVWF  x70
00692:  MOVLB  0
00694:  RCALL  05AA
....................  
.................... 	// Set the PHY into the proper duplex state 
.................... #if defined(FULL_DUPLEX) 
.................... 	WritePHYReg(PHCON1, PHCON1_PDPXMD); 
.................... #else 
.................... 	WritePHYReg(PHCON1, 0x0000); 
00696:  MOVLB  1
00698:  CLRF   x6F
0069A:  CLRF   x71
0069C:  CLRF   x70
0069E:  MOVLB  0
006A0:  RCALL  05AA
.................... #endif 
....................  
.................... 	// Enable packet reception 
....................     ECON1bits.RXEN = 1; 
006A2:  BSF    FD2.2
006A4:  GOTO   0DF4 (RETURN)
.................... }//end MACInit 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsLinked(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: If the PHY reports that a link partner is present 
....................  *						  and the link has been up continuously since the last 
....................  *						  call to MACIsLinked() 
....................  *					FALSE: If the PHY reports no link partner, or the link went 
....................  *						   down momentarily since the last call to MACIsLinked() 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the PHSTAT1.LLSTAT bit. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsLinked(void) 
.................... { 
.................... 	// LLSTAT is a latching low link status bit.  Therefore, if the link 
.................... 	// goes down and comes back up before a higher level stack program calls 
.................... 	// MACIsLinked(), MACIsLinked() will still return FALSE.  The next 
.................... 	// call to MACIsLinked() will return TRUE (unless the link goes down 
.................... 	// again). 
.................... 	return ReadPHYReg(PHSTAT1).PHSTAT1bits.LLSTAT; 
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsTxReady(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: If no Ethernet transmission is in progress 
....................  *					FALSE: If a previous transmission was started, and it has 
....................  *						   not completed yet.  While FALSE, the data in the 
....................  *						   transmit buffer and the TXST/TXND pointers must not 
....................  *						   be changed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the ECON1.TXRTS bit 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsTxReady(void) 
.................... { 
.................... 	if(!ECON1bits.TXRTS) 
*
00E7E:  BTFSC  FD2.3
00E80:  BRA    0E88
.................... 		return TRUE; 
00E82:  MOVLW  01
00E84:  MOVWF  01
00E86:  BRA    0EB6
....................  
.................... 	// Retry transmission if the current packet seems to be not completing 
.................... 	// Wait 3ms before triggering the retry. 
.................... 	if((WORD)TickGet() - wTXWatchdog >= (3ull*TICK_SECOND/1000ull)) 
00E88:  RCALL  0E34
00E8A:  MOVFF  01,2A0
00E8E:  MOVFF  00,29F
00E92:  MOVF   x80,W
00E94:  MOVLB  2
00E96:  SUBWF  x9F,F
00E98:  MOVLB  0
00E9A:  MOVF   x81,W
00E9C:  MOVLB  2
00E9E:  SUBWFB xA0,F
00EA0:  BNZ   0EA8
00EA2:  MOVF   x9F,W
00EA4:  SUBLW  79
00EA6:  BC    0EB0
.................... 	{ 
.................... 		ECON1bits.TXRTS = 0; 
00EA8:  BCF    FD2.3
.................... 		MACFlush(); 
00EAA:  MOVLB  0
00EAC:  RCALL  0E5A
00EAE:  MOVLB  2
.................... 	} 
....................  
.................... 	return FALSE; 
00EB0:  MOVLW  00
00EB2:  MOVWF  01
00EB4:  MOVLB  0
00EB6:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDiscardRx(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Marks the last received packet (obtained using 
....................  *					MACGetHeader())as being processed and frees the buffer 
....................  *					memory associated with it 
....................  * 
....................  * Note:            Is is safe to call this function multiple times between 
....................  *					MACGetHeader() calls.  Extra packets won't be thrown away 
....................  *					until MACGetHeader() makes it available. 
....................  *****************************************************************************/ 
.................... void MACDiscardRx(void) 
.................... { 
.................... 	WORD_VAL NewRXRDLocation; 
....................  
.................... 	// Make sure the current packet was not already discarded 
.................... 	if(flags.bits.bWasDiscarded) 
*
02AC4:  BTFSS  x7F.0
02AC6:  BRA    2ACA
.................... 		return; 
02AC8:  BRA    2B04
.................... 	flags.bits.bWasDiscarded = 1; 
02ACA:  BSF    x7F.0
....................  
.................... 	// Decrement the next packet pointer before writing it into 
.................... 	// the ERXRDPT registers.  This is a silicon errata workaround. 
.................... 	// RX buffer wrapping must be taken into account if the 
.................... 	// NextPacketLocation is precisely RXSTART. 
.................... 	NewRXRDLocation.Val = NextPacketLocation.Val - 1; 
02ACC:  MOVLW  01
02ACE:  SUBWF  x7B,W
02AD0:  MOVLB  1
02AD2:  MOVWF  xA1
02AD4:  MOVLW  00
02AD6:  MOVLB  0
02AD8:  SUBWFB x7C,W
02ADA:  MOVLB  1
02ADC:  MOVWF  xA2
.................... //#if RXSTART == 0 
.................... //	if(NewRXRDLocation.Val > RXSTOP) 
.................... //#else 
.................... 	if(NewRXRDLocation.Val < RXSTART || NewRXRDLocation.Val > RXSTOP) 
02ADE:  MOVF   xA2,W
02AE0:  SUBLW  14
02AE2:  BC    2AF6
02AE4:  XORLW  FF
02AE6:  BNZ   2AEE
02AE8:  MOVF   xA1,W
02AEA:  SUBLW  09
02AEC:  BC    2AF6
.................... //#endif 
.................... 	{ 
.................... 		NewRXRDLocation.Val = RXSTOP; 
02AEE:  MOVLW  15
02AF0:  MOVWF  xA2
02AF2:  MOVLW  09
02AF4:  MOVWF  xA1
.................... 	} 
....................  
.................... 	// Decrement the RX packet counter register, EPKTCNT 
....................     ECON2bits.PKTDEC = 1; 
02AF6:  MOVLB  E
02AF8:  BSF    xFE.6
....................  
.................... 	// Move the receive read pointer to unwrite-protect the memory used by the 
.................... 	// last packet.  The writing order is important: set the low byte first, 
.................... 	// high byte last. 
....................     ERXRDPTL = NewRXRDLocation.v[0]; 
02AFA:  MOVFF  1A1,EEC
.................... 	ERXRDPTH = NewRXRDLocation.v[1]; 
02AFE:  MOVFF  1A2,EED
02B02:  MOVLB  0
02B04:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetFreeRxSize(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          A WORD estimate of how much RX buffer space is free at 
....................  *					the present time. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetFreeRxSize(void) 
.................... { 
.................... 	WORD_VAL ReadPT, WritePT; 
....................  
.................... 	// Read the Ethernet hardware buffer write pointer.  Because packets can be 
.................... 	// received at any time, it can change between reading the low and high 
.................... 	// bytes.  A loop is necessary to make certain a proper low/high byte pair 
.................... 	// is read. 
.................... 	do { 
.................... 		// Save EPKTCNT in a temporary location 
.................... 		ReadPT.v[0] = EPKTCNT; 
*
00EFE:  MOVFF  ED9,29F
....................  
.................... 		WritePT.Val = ERXWRPT; 
00F02:  MOVFF  EEF,2A2
00F06:  MOVFF  EEE,2A1
.................... 	} while(EPKTCNT != ReadPT.v[0]); 
00F0A:  MOVLB  2
00F0C:  MOVF   x9F,W
00F0E:  MOVLB  E
00F10:  SUBWF  xD9,W
00F12:  BTFSC  FD8.2
00F14:  BRA    0F1A
00F16:  MOVLB  0
00F18:  BRA    0EFE
....................  
.................... 	// Determine where the write protection pointer is 
.................... 	ReadPT.Val = ERXRDPT; 
00F1A:  MOVFF  EED,2A0
00F1E:  MOVFF  EEC,29F
....................  
....................  
.................... 	// Calculate the difference between the pointers, taking care to account 
.................... 	// for buffer wrapping conditions 
.................... 	if(WritePT.Val > ReadPT.Val) 
00F22:  MOVLB  2
00F24:  MOVF   xA0,W
00F26:  SUBWF  xA2,W
00F28:  BNC   0F56
00F2A:  BNZ   0F32
00F2C:  MOVF   xA1,W
00F2E:  SUBWF  x9F,W
00F30:  BC    0F56
.................... 	{ 
.................... 		return (RXSTOP - RXSTART) - (WritePT.Val - ReadPT.Val); 
00F32:  MOVF   x9F,W
00F34:  SUBWF  xA1,W
00F36:  MOVWF  00
00F38:  MOVF   xA0,W
00F3A:  SUBWFB xA2,W
00F3C:  MOVWF  03
00F3E:  MOVF   00,W
00F40:  XORLW  FF
00F42:  ADDLW  0A
00F44:  MOVWF  00
00F46:  MOVLW  15
00F48:  SUBFWB 03,F
00F4A:  MOVFF  00,01
00F4E:  MOVFF  03,02
00F52:  BRA    0F8C
.................... 	} 
00F54:  BRA    0F8C
.................... 	else if(WritePT.Val == ReadPT.Val) 
00F56:  MOVF   x9F,W
00F58:  SUBWF  xA1,W
00F5A:  BNZ   0F6E
00F5C:  MOVF   xA0,W
00F5E:  SUBWF  xA2,W
00F60:  BNZ   0F6E
.................... 	{ 
.................... 		return RXSIZE - 1; 
00F62:  MOVLW  09
00F64:  MOVWF  01
00F66:  MOVLW  15
00F68:  MOVWF  02
00F6A:  BRA    0F8C
.................... 	} 
00F6C:  BRA    0F8C
.................... 	else 
....................     { 
.................... 		return ReadPT.Val - WritePT.Val - 1; 
00F6E:  MOVF   xA1,W
00F70:  SUBWF  x9F,W
00F72:  MOVWF  xA3
00F74:  MOVF   xA2,W
00F76:  SUBWFB xA0,W
00F78:  MOVWF  xA4
00F7A:  MOVLW  01
00F7C:  SUBWF  xA3,W
00F7E:  MOVWF  00
00F80:  MOVLW  00
00F82:  SUBWFB xA4,W
00F84:  MOVWF  03
00F86:  MOVFF  00,01
00F8A:  MOVWF  02
.................... 	} 
00F8C:  MOVLB  0
00F8E:  GOTO   1C1E (RETURN)
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           *remote: Location to store the Source MAC address of the 
....................  *							 received frame. 
....................  *					*type: Location of a BYTE to store the constant 
....................  *						   MAC_UNKNOWN, ETHER_IP, or ETHER_ARP, representing 
....................  *						   the contents of the Ethernet type field. 
....................  * 
....................  * Output:          TRUE: If a packet was waiting in the RX buffer.  The 
....................  *						  remote, and type values are updated. 
....................  *					FALSE: If a packet was not pending.  remote and type are 
....................  *						   not changed. 
....................  * 
....................  * Side Effects:    Last packet is discarded if MACDiscardRx() hasn't already 
....................  *					been called. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
.................... { 
.................... 	ENC_PREAMBLE header; 
....................  
.................... 	// Test if at least one packet has been received and is waiting 
.................... 	if(EPKTCNT == 0u) 
*
02B06:  MOVLB  E
02B08:  MOVF   xD9,F
02B0A:  BNZ   2B12
.................... 	{ 
.................... 		// If we've never received a packet, see if it is appropraite to swap  
.................... 		// the RX polarity right now 
.................... 		#if defined(ETH_RX_POLARITY_SWAP_TRIS) 
.................... 		{ 
.................... 			// See if the polarty swap timer has expired (happens every 429ms) 
.................... 			if((WORD)TickGetDiv256() - wRXPolarityTimer > (WORD)(TICK_SECOND*3/7/256)) 
.................... 			{ 
.................... 				// Check if the Ethernet link is up.  If it isn't we need to  
.................... 				// clear the bRXPolarityValid flag because the user could plug  
.................... 				// the node into a different network device which has opposite  
.................... 				// polarity. 
.................... 				if(ReadPHYReg(PHSTAT2).PHSTAT2bits.LSTAT) 
.................... 				{// Linked 
.................... 					// See if we have received a packet already or not.  If we  
.................... 					// haven't the RX polarity may not be correct. 
.................... 					if(!flags.bits.bRXPolarityValid) 
.................... 					{ 
.................... 						// Swap the TPIN+/- polarity 
.................... 						ETH_RX_POLARITY_SWAP_IO ^= 1; 
.................... 					} 
.................... 				} 
.................... 				else 
.................... 				{// Not linked 
.................... 					flags.bits.bRXPolarityValid = 0; 
.................... 					flags.bits.bRXPolarityAtNextTX = 0; 
.................... 					ETH_RX_POLARITY_SWAP_IO = 0;	// Default back to IEEE 802.3 correct polarity 
.................... 				} 
.................... 	 
.................... 				// Reset timer for next polarity swap test 
.................... 				wRXPolarityTimer = (WORD)TickGetDiv256(); 
.................... 				flags.bits.bRXPolarityTimerOnTX = 0; 
.................... 			} 
.................... 		} 
.................... 		#endif 
.................... 	     
.................... 		return FALSE; 
02B0C:  MOVLW  00
02B0E:  MOVWF  01
02B10:  BRA    2C12
.................... 	} 
....................  
.................... 	// Flag that we have received a packet so that we don't swap the RX polarity  
.................... 	// anymore. 
.................... 	flags.bits.bRXPolarityValid = 1; 
02B12:  MOVLB  0
02B14:  BSF    x7F.1
....................  
.................... 	// Make absolutely certain that any previous packet was discarded 
.................... 	if(flags.bits.bWasDiscarded == 0u) 
02B16:  BTFSC  x7F.0
02B18:  BRA    2B26
.................... 	{ 
.................... 		MACDiscardRx(); 
02B1A:  RCALL  2AC4
.................... 		return FALSE; 
02B1C:  MOVLW  00
02B1E:  MOVWF  01
02B20:  MOVLB  E
02B22:  BRA    2C12
02B24:  MOVLB  0
.................... 	} 
.................... 	// Save the location of this packet 
.................... 	CurrentPacketLocation.Val = NextPacketLocation.Val; 
02B26:  MOVFF  7C,7E
02B2A:  MOVFF  7B,7D
....................  
.................... 	// Set the read pointer to the beginning of the next unprocessed packet 
....................     ERDPT = CurrentPacketLocation.Val; 
02B2E:  MOVFF  7E,F7B
02B32:  MOVFF  7D,F7A
....................  
.................... 	// Obtain the MAC header from the Ethernet buffer 
.................... 	MACGetArray((BYTE*)&header, sizeof(header)); 
02B36:  MOVLW  01
02B38:  MOVLB  1
02B3A:  MOVWF  x8F
02B3C:  MOVLW  7A
02B3E:  MOVWF  x8E
02B40:  MOVFF  18F,2C0
02B44:  MOVFF  FE8,2BF
02B48:  MOVLB  2
02B4A:  CLRF   xC2
02B4C:  MOVLW  14
02B4E:  MOVWF  xC1
02B50:  MOVLB  0
02B52:  CALL   07EA
....................  
.................... 	// The EtherType field, like most items transmitted on the Ethernet medium 
.................... 	// are in big endian. 
.................... 	header.Type.Val = swaps(header.Type.Val); 
02B56:  MOVFF  18D,2BF
02B5A:  MOVFF  18C,2BE
02B5E:  CALL   0F92
02B62:  MOVFF  02,18D
02B66:  MOVFF  01,18C
....................  
.................... 	// Do a sanity check.  There might be a bug in code someplace if this 
.................... 	// Reset() ever happens.  Check for potential errors in array/pointer writing code. 
.................... 	if(header.NextPacketPointer > RXSTOP || ((BYTE_VAL*)(&header.NextPacketPointer))->bits.b0 || 
.................... 	   header.StatusVector.bits.Zero || 
.................... 	   header.StatusVector.bits.CRCError || 
.................... 	   header.StatusVector.bits.ByteCount > 1518u || 
.................... 	   !header.StatusVector.bits.ReceiveOk) 
02B6A:  MOVLB  1
02B6C:  MOVF   x7B,W
02B6E:  SUBLW  14
02B70:  BC    2B7C
02B72:  XORLW  FF
02B74:  BNZ   2BA8
02B76:  MOVF   x7A,W
02B78:  SUBLW  09
02B7A:  BNC   2BA8
02B7C:  MOVLW  01
02B7E:  MOVWF  x8F
02B80:  MOVLW  7A
02B82:  MOVWF  FE9
02B84:  MOVFF  18F,FEA
02B88:  BTFSC  FEF.0
02B8A:  BRA    2BA8
02B8C:  BTFSC  x7F.7
02B8E:  BRA    2BA8
02B90:  BTFSC  x7E.4
02B92:  BRA    2BA8
02B94:  MOVF   x7D,W
02B96:  SUBLW  04
02B98:  BC    2BA4
02B9A:  XORLW  FF
02B9C:  BNZ   2BA8
02B9E:  MOVF   x7C,W
02BA0:  SUBLW  EE
02BA2:  BNC   2BA8
02BA4:  BTFSC  x7E.7
02BA6:  BRA    2BAA
.................... 	{ 
.................... 		Reset(); 
02BA8:  RESET
.................... 	} 
....................  
.................... 	// Save the location where the hardware will write the next packet to 
.................... 	NextPacketLocation.Val = header.NextPacketPointer; 
02BAA:  MOVFF  17B,7C
02BAE:  MOVFF  17A,7B
....................  
.................... 	// Return the Ethernet frame's Source MAC address field to the caller 
.................... 	// This parameter is useful for replying to requests without requiring an 
.................... 	// ARP cycle. 
....................     memcpy((void*)remote->v, (void*)header.SourceMACAddr.v, sizeof(*remote)); 
02BB2:  MOVFF  177,03
02BB6:  MOVFF  176,18E
02BBA:  MOVFF  177,18F
02BBE:  MOVLW  01
02BC0:  MOVWF  x91
02BC2:  MOVLW  86
02BC4:  MOVFF  177,FEA
02BC8:  MOVFF  176,FE9
02BCC:  MOVFF  191,FE2
02BD0:  MOVWF  FE1
02BD2:  MOVLW  06
02BD4:  MOVWF  01
02BD6:  MOVFF  FE6,FEE
02BDA:  DECFSZ 01,F
02BDC:  BRA    2BD6
....................  
.................... 	// Return a simplified version of the EtherType field to the caller 
....................     *type = MAC_UNKNOWN; 
02BDE:  MOVFF  179,03
02BE2:  MOVFF  178,FE9
02BE6:  MOVFF  03,FEA
02BEA:  SETF   FEF
....................     if( (header.Type.v[1] == 0x08u) && 
....................     	((header.Type.v[0] == ETHER_IP) || (header.Type.v[0] == ETHER_ARP)) ) 
02BEC:  MOVF   x8D,W
02BEE:  SUBLW  08
02BF0:  BNZ   2C08
02BF2:  MOVF   x8C,F
02BF4:  BZ    2BFC
02BF6:  MOVF   x8C,W
02BF8:  SUBLW  06
02BFA:  BNZ   2C08
....................     { 
....................     	*type = header.Type.v[0]; 
02BFC:  MOVFF  178,FE9
02C00:  MOVFF  179,FEA
02C04:  MOVFF  18C,FEF
....................     } 
....................  
....................     // Mark this packet as discardable 
....................     flags.bits.bWasDiscarded = 0; 
02C08:  MOVLB  0
02C0A:  BCF    x7F.0
.................... 	return TRUE; 
02C0C:  MOVLW  01
02C0E:  MOVWF  01
02C10:  MOVLB  E
02C12:  MOVLB  0
02C14:  GOTO   4A12 (RETURN)
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen) 
....................  * 
....................  * PreCondition:    MACIsTxReady() must return TRUE. 
....................  * 
....................  * Input:           *remote: Pointer to memory which contains the destination 
....................  * 							 MAC address (6 bytes) 
....................  *					type: The constant ETHER_ARP or ETHER_IP, defining which 
....................  *						  value to write into the Ethernet header's type field. 
....................  *					dataLen: Length of the Ethernet data payload 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Because of the dataLen parameter, it is probably 
....................  *					advantagous to call this function immediately before 
....................  *					transmitting a packet rather than initially when the 
....................  *					packet is first created.  The order in which the packet 
....................  *					is constructed (header first or data first) is not 
....................  *					important. 
....................  *****************************************************************************/ 
.................... void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen) 
.................... { 
.................... 	// Set the write pointer to the beginning of the transmit buffer 
.................... 	EWRPT = TXSTART + 1; 
*
01508:  MOVLW  15
0150A:  MOVLB  E
0150C:  MOVWF  xE3
0150E:  MOVLW  0B
01510:  MOVWF  xE2
....................  
.................... 	// Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TXSTART; 
01512:  MOVLW  18
01514:  MOVLB  2
01516:  ADDWF  xBF,F
01518:  MOVLW  15
0151A:  ADDWFC xC0,F
....................  
.................... 	// Write the TXND pointer into the registers, given the dataLen given 
.................... 	ETXND = dataLen; 
0151C:  MOVFF  2C0,EE7
01520:  MOVFF  2BF,EE6
....................  
.................... 	// Set the per-packet control byte and write the Ethernet destination 
.................... 	// address 
....................     MACPutArray((BYTE*)remote, sizeof(*remote)); 
01524:  MOVFF  2BD,2C4
01528:  MOVFF  2BC,2C3
0152C:  CLRF   xC6
0152E:  MOVLW  06
01530:  MOVWF  xC5
01532:  MOVLB  0
01534:  CALL   079A
....................  
.................... 	// Write our MAC address in the Ethernet source field 
.................... 	MACPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr)); 
01538:  MOVLB  2
0153A:  CLRF   xC2
0153C:  MOVLW  57
0153E:  MOVWF  xC1
01540:  MOVFF  2C2,2C4
01544:  MOVWF  xC3
01546:  CLRF   xC6
01548:  MOVLW  06
0154A:  MOVWF  xC5
0154C:  MOVLB  0
0154E:  CALL   079A
....................  
.................... 	// Write the appropriate Ethernet Type WORD for the protocol being used 
....................     MACPut(0x08); 
01552:  MOVLW  08
01554:  MOVLB  2
01556:  MOVWF  xC2
01558:  MOVLB  0
0155A:  CALL   05A0
....................     MACPut((type == MAC_IP) ? ETHER_IP : ETHER_ARP); 
0155E:  MOVLB  2
01560:  MOVF   xBE,F
01562:  BNZ   1568
01564:  MOVLW  00
01566:  BRA    156A
01568:  MOVLW  06
0156A:  MOVWF  xC1
0156C:  MOVWF  xC2
0156E:  MOVLB  0
01570:  CALL   05A0
01574:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACFlush(void) 
....................  * 
....................  * PreCondition:    A packet has been created by calling MACPut() and 
....................  *					MACPutHeader(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACFlush causes the current TX packet to be sent out on 
....................  *					the Ethernet medium.  The hardware MAC will take control 
....................  *					and handle CRC generation, collision retransmission and 
....................  *					other details. 
....................  * 
....................  * Note:			After transmission completes (MACIsTxReady() returns TRUE), 
....................  *					the packet can be modified and transmitted again by calling 
....................  *					MACFlush() again.  Until MACPutHeader() or MACPut() is 
....................  *					called (in the TX data area), the data in the TX buffer 
....................  *					will not be corrupted. 
....................  *****************************************************************************/ 
.................... void MACFlush(void) 
.................... { 
.................... 	// Reset the Ethernet TX logic.  This is an errata workaround to 
.................... 	// prevent the TXRTS bit from getting stuck set indefinitely, causing the 
.................... 	// stack to lock up under certain bad conditions. 
.................... 	ECON1bits.TXRST = 1; 
*
00E5A:  BSF    FD2.7
.................... 	ECON1bits.TXRST = 0; 
00E5C:  BCF    FD2.7
....................  
.................... 	// Wait at least 1.6us after TX Reset before setting TXRTS. 
.................... 	// If you don't wait long enough, the TX logic won't be finished resetting. 
.................... 	{volatile BYTE i = 8; while(i--);} 
00E5E:  MOVLW  08
00E60:  MOVLB  2
00E62:  MOVWF  x9F
00E64:  MOVF   x9F,W
00E66:  DECF   x9F,F
00E68:  XORLW  00
00E6A:  BNZ   0E64
.................... 	EIRbits.TXERIF = 0; 
00E6C:  BCF    F60.1
....................  
.................... 	// Since we are about to transmit something (which usually results in RX  
.................... 	// traffic), start a timer to look for RX traffic and control RX polarity  
.................... 	// swapping. 
.................... 	#if defined(ETH_RX_POLARITY_SWAP_TRIS) 
.................... 	{ 
.................... 		// See if we have received a packet already or not.  If we haven't the  
.................... 		// RX polarity may not be correct. 
.................... 		if(!flags.bits.bRXPolarityValid) 
.................... 		{ 
.................... 			// See if we transmitted a packet and twidled with the polarity  
.................... 			// already in the last 429ms. 
.................... 			if(!flags.bits.bRXPolarityTimerOnTX) 
.................... 			{ 
.................... 				// Reset the timer and swap the polarity 
.................... 				wRXPolarityTimer = (WORD)TickGetDiv256(); 
.................... 				flags.bits.bRXPolarityTimerOnTX = 1; 
.................... 				if(flags.bits.bRXPolarityAtNextTX) 
.................... 					ETH_RX_POLARITY_SWAP_IO = 1; 
.................... 				else 
.................... 					ETH_RX_POLARITY_SWAP_IO = 0; 
.................... 				flags.bits.bRXPolarityAtNextTX ^= 1;	// Swap for next time 
.................... 			} 
.................... 		} 
.................... 	} 
.................... 	#endif 
....................  
.................... 	// Start the transmission 
.................... 	// After transmission completes (MACIsTxReady() returns TRUE), the packet 
.................... 	// can be modified and transmitted again by calling MACFlush() again. 
.................... 	// Until MACPutHeader() is called, the data in the TX buffer will not be 
.................... 	// corrupted. 
....................     ECON1bits.TXRTS = 1; 
00E6E:  BSF    FD2.3
.................... 	wTXWatchdog = TickGet(); 
00E70:  MOVLB  0
00E72:  RCALL  0E34
00E74:  MOVFF  01,81
00E78:  MOVFF  00,80
00E7C:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetReadPtrInRx(WORD offset) 
....................  * 
....................  * PreCondition:    A packet has been obtained by calling MACGetHeader() and 
....................  *					getting a TRUE result. 
....................  * 
....................  * Input:           offset: WORD specifying how many bytes beyond the Ethernet 
....................  *							header's type field to relocate the SPI read 
....................  *							pointer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read pointer are updated.  All calls to 
....................  *					MACGet() and MACGetArray() will use these new values. 
....................  * 
....................  * Note:			RXSTOP must be statically defined as being > RXSTART for 
....................  *					this function to work correctly.  In other words, do not 
....................  *					define an RX buffer which spans the 0x1FFF->0x0000 memory 
....................  *					boundary. 
....................  *****************************************************************************/ 
.................... void MACSetReadPtrInRx(WORD offset) 
.................... { 
.................... 	WORD_VAL ReadPT; 
....................  
.................... 	// Determine the address of the beginning of the entire packet 
.................... 	// and adjust the address to the desired location 
.................... 	ReadPT.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
02DD8:  MOVLW  14
02DDA:  ADDWF  x7D,W
02DDC:  MOVLB  1
02DDE:  MOVWF  xCD
02DE0:  MOVLW  00
02DE2:  MOVLB  0
02DE4:  ADDWFC x7E,W
02DE6:  MOVLB  1
02DE8:  MOVWF  xCE
02DEA:  MOVF   xC9,W
02DEC:  ADDWF  xCD,W
02DEE:  MOVWF  xCB
02DF0:  MOVF   xCA,W
02DF2:  ADDWFC xCE,W
02DF4:  MOVWF  xCC
....................  
.................... 	// Since the receive buffer is circular, adjust if a wraparound is needed 
.................... 	if(ReadPT.Val > RXSTOP) 
02DF6:  MOVF   xCC,W
02DF8:  SUBLW  14
02DFA:  BC    2E0E
02DFC:  XORLW  FF
02DFE:  BNZ   2E06
02E00:  MOVF   xCB,W
02E02:  SUBLW  09
02E04:  BC    2E0E
.................... 		ReadPT.Val -= RXSIZE; 
02E06:  MOVLW  0A
02E08:  SUBWF  xCB,F
02E0A:  MOVLW  15
02E0C:  SUBWFB xCC,F
....................  
.................... 	// Set the read pointer to the new calculated value 
.................... 	ERDPTL = ReadPT.v[0]; 
02E0E:  MOVFF  1CB,F7A
.................... 	ERDPTH = ReadPT.v[1]; 
02E12:  MOVFF  1CC,F7B
02E16:  MOVLB  0
02E18:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        PTR_BASE MACSetWritePtr(PTR_BASE Address) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           Address: Address to seek to 
....................  * 
....................  * Output:          WORD: Old EWRPT location 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI write pointer is updated.  All calls to 
....................  *					MACPut() and MACPutArray() will use this new value. 
....................  * 
....................  * Note:			None 
....................  *****************************************************************************/ 
.................... PTR_BASE MACSetWritePtr(PTR_BASE address) 
.................... { 
.................... 	WORD oldVal; 
....................  
.................... 	oldVal = EWRPT; 
*
0077C:  MOVFF  EE3,2B1
00780:  MOVFF  EE2,2B0
.................... 	EWRPT = address; 
00784:  MOVFF  2AF,EE3
00788:  MOVFF  2AE,EE2
.................... 	return oldVal; 
0078C:  MOVLB  2
0078E:  MOVFF  2B0,01
00792:  MOVFF  2B1,02
00796:  MOVLB  0
00798:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        PTR_BASE MACSetReadPtr(PTR_BASE Address) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           Address: Address to seek to 
....................  * 
....................  * Output:          WORD: Old ERDPT value 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI write pointer is updated.  All calls to 
....................  *					MACPut() and MACPutArray() will use this new value. 
....................  * 
....................  * Note:			None 
....................  *****************************************************************************/ 
.................... PTR_BASE MACSetReadPtr(PTR_BASE address) 
.................... { 
.................... 	WORD oldVal; 
....................  
.................... 	oldVal = ERDPT; 
*
007CC:  MOVFF  F7B,2B1
007D0:  MOVFF  F7A,2B0
.................... 	ERDPT = address; 
007D4:  MOVFF  2AF,F7B
007D8:  MOVFF  2AE,F7A
.................... 	return oldVal; 
007DC:  MOVLB  2
007DE:  MOVFF  2B0,01
007E2:  MOVFF  2B1,02
007E6:  MOVLB  0
007E8:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcRxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset	- Number of bytes beyond the beginning of the 
....................  *							Ethernet data (first byte after the type field) 
....................  *							where the checksum should begin 
....................  *					len		- Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by RFC 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcRxChecksum(WORD offset, WORD len) 
.................... { 
.................... 	WORD temp; 
.................... 	WORD RDSave; 
....................  
.................... 	// Add the offset requested by firmware plus the Ethernet header 
.................... 	temp = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
02D66:  MOVLW  14
02D68:  ADDWF  x7D,W
02D6A:  MOVLB  1
02D6C:  MOVWF  x9C
02D6E:  MOVLW  00
02D70:  MOVLB  0
02D72:  ADDWFC x7E,W
02D74:  MOVLB  1
02D76:  MOVWF  x9D
02D78:  MOVF   x94,W
02D7A:  ADDWF  x9C,W
02D7C:  MOVWF  x98
02D7E:  MOVF   x95,W
02D80:  ADDWFC x9D,W
02D82:  MOVWF  x99
.................... 	if(temp > RXSTOP)		// Adjust value if a wrap is needed 
02D84:  MOVF   x99,W
02D86:  SUBLW  14
02D88:  BC    2D9C
02D8A:  XORLW  FF
02D8C:  BNZ   2D94
02D8E:  MOVF   x98,W
02D90:  SUBLW  09
02D92:  BC    2D9C
.................... 	{ 
.................... 		temp -= RXSIZE; 
02D94:  MOVLW  0A
02D96:  SUBWF  x98,F
02D98:  MOVLW  15
02D9A:  SUBWFB x99,F
.................... 	} 
....................  
.................... 	RDSave = ERDPT; 
02D9C:  MOVFF  F7B,19B
02DA0:  MOVFF  F7A,19A
.................... 	ERDPT = temp; 
02DA4:  MOVFF  199,F7B
02DA8:  MOVFF  198,F7A
.................... 	temp = CalcIPBufferChecksum(len); 
02DAC:  MOVFF  197,2A0
02DB0:  MOVFF  196,29F
02DB4:  MOVLB  0
02DB6:  CALL   165E
02DBA:  MOVFF  02,199
02DBE:  MOVFF  01,198
.................... 	ERDPT = RDSave; 
02DC2:  MOVFF  19B,F7B
02DC6:  MOVFF  19A,F7A
....................  
.................... 	return temp; 
02DCA:  MOVLB  1
02DCC:  MOVFF  198,01
02DD0:  MOVFF  199,02
02DD4:  MOVLB  0
02DD6:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    Read buffer pointer set to starting of checksum data 
....................  * 
....................  * Input:           len: Total number of bytes to calculate the checksum over. 
....................  *						 The first byte included in the checksum is the byte 
....................  *						 pointed to by ERDPT, which is updated by calls to 
....................  *						 MACGet(), MACSetRxBuffer(), MACSetTxBuffer(), etc. 
....................  * 
....................  * Output:          16-bit checksum as defined by RFC 793 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself.  The MAC has a hardware DMA module 
....................  *					which can calculate the checksum faster than software, so 
....................  *					this function replaces the CaclIPBufferChecksum() function 
....................  *					defined in the helpers.c file.  Through the use of 
....................  *					preprocessor defines, this replacement is automatic. 
....................  * 
....................  * Note:            This function works either in the RX buffer area or the TX 
....................  *					buffer area.  No validation is done on the len parameter. 
....................  *****************************************************************************/ 
.................... /* 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
.................... 	WORD_VAL temp; 
....................  
.................... 	// Take care of special cases which the DMA cannot be used for 
.................... 	if(len == 0u) 
.................... 	{ 
.................... 		return 0xFFFF; 
.................... 	} 
.................... 	else if(len == 1u) 
.................... 	{ 
.................... 		return ~((WORD)MACGet()); 
.................... 	} 
....................  
....................  
.................... 	// Set the DMA starting address to the RAM read pointer value 
....................     temp.Val = ERDPT; 
....................     EDMAST = temp.Val; 
....................  
.................... 	// See if we are calculating a checksum within the RX buffer (where 
.................... 	// wrapping rules apply) or TX/unused area (where wrapping rules are 
.................... 	// not applied) 
.................... #if RXSTART == 0 
.................... 	if(temp.Val <= RXSTOP) 
.................... #else 
.................... 	if(temp.Val >= RXSTART && temp.Val <= RXSTOP) 
.................... #endif 
.................... 	{ 
.................... 		// Calculate the DMA ending address given the starting address and len 
.................... 		// parameter.  The DMA will follow the receive buffer wrapping boundary. 
.................... 		temp.Val += len-1; 
.................... 		if(temp.Val > RXSTOP) 
.................... 		{ 
.................... 			temp.Val -= RXSIZE; 
.................... 		} 
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 		temp.Val += len-1; 
.................... 	} 
....................  
.................... 	// Write the DMA end address 
....................     EDMAND = temp.Val; 
....................  
.................... 	// Begin the DMA checksum calculation and wait until it is finished 
....................     ECON1bits.CSUMEN = 1; 
....................     ECON1bits.DMAST = 1; 
....................     while(ECON1bits.DMAST); 
....................  
.................... 	// Return the resulting good stuff 
.................... 	return (((WORD)EDMACSL)<<8) | EDMACSH; 
.................... } 
.................... */ 
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    Read buffer pointer set to starting of checksum data 
....................  * 
....................  * Input:           len: Total number of bytes to calculate the checksum over. 
....................  *						 The first byte included in the checksum is the byte 
....................  *						 pointed to by ERDPT, which is updated by calls to 
....................  *						 MACSetReadPtr(), MACGet(), MACGetArray(), 
....................  *						 MACGetHeader(), etc. 
....................  * 
....................  * Output:          16-bit checksum as defined by RFC 793 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself 
....................  * 
....................  * Note:            This function works either in the RX buffer area or the TX 
....................  *					buffer area.  No validation is done on the len parameter. 
....................  *****************************************************************************/ 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
.................... 	WORD Start; 
.................... 	DWORD_VAL Checksum = {0x00000000ul}; 
*
0165E:  MOVLB  2
01660:  CLRF   xA3
01662:  CLRF   xA4
01664:  CLRF   xA5
01666:  CLRF   xA6
.................... 	WORD ChunkLen; 
.................... 	BYTE DataBuffer[20];	// Must be an even size 
.................... 	WORD *DataPtr; 
....................  
.................... 	// Save the read pointer starting address 
.................... 	Start = ERDPT; 
01668:  MOVFF  F7B,2A2
0166C:  MOVFF  F7A,2A1
....................  
.................... 	while(len) 
01670:  MOVF   x9F,W
01672:  IORWF  xA0,W
01674:  BZ    1720
.................... 	{ 
.................... 		// Obtain a chunk of data (less SPI overhead compared 
.................... 		// to requesting one byte at a time) 
.................... 		ChunkLen = len > sizeof(DataBuffer) ? sizeof(DataBuffer) : len; 
01676:  MOVF   xA0,F
01678:  BNZ   1680
0167A:  MOVF   x9F,W
0167C:  SUBLW  14
0167E:  BC    1686
01680:  CLRF   03
01682:  MOVLW  14
01684:  BRA    168C
01686:  MOVFF  2A0,03
0168A:  MOVF   x9F,W
0168C:  MOVWF  xA7
0168E:  MOVFF  03,2A8
.................... 		MACGetArray(DataBuffer, ChunkLen); 
01692:  MOVLW  02
01694:  MOVWF  xC0
01696:  MOVLW  A9
01698:  MOVWF  xBF
0169A:  MOVFF  2A8,2C2
0169E:  MOVFF  2A7,2C1
016A2:  MOVLB  0
016A4:  CALL   07EA
....................  
.................... 		len -= ChunkLen; 
016A8:  MOVLB  2
016AA:  MOVF   xA7,W
016AC:  SUBWF  x9F,F
016AE:  MOVF   xA8,W
016B0:  SUBWFB xA0,F
....................  
.................... 		// Take care of a last odd numbered data byte 
.................... 		if(((WORD_VAL*)&ChunkLen)->bits.b0) 
016B2:  MOVLW  02
016B4:  MOVWF  xC0
016B6:  MOVLW  A7
016B8:  MOVWF  FE9
016BA:  MOVFF  2C0,FEA
016BE:  BTFSS  FEF.0
016C0:  BRA    16D6
.................... 		{ 
.................... 			DataBuffer[ChunkLen] = 0x00; 
016C2:  MOVLW  A9
016C4:  ADDWF  xA7,W
016C6:  MOVWF  FE9
016C8:  MOVLW  02
016CA:  ADDWFC xA8,W
016CC:  MOVWF  FEA
016CE:  CLRF   FEF
.................... 			ChunkLen++; 
016D0:  INCF   xA7,F
016D2:  BTFSC  FD8.2
016D4:  INCF   xA8,F
.................... 		} 
....................  
.................... 		// Calculate the checksum over this chunk 
.................... 		DataPtr = (WORD*)&DataBuffer[0]; 
016D6:  MOVLW  02
016D8:  MOVWF  xC0
016DA:  MOVLW  A9
016DC:  MOVFF  2C0,2BE
016E0:  MOVWF  xBD
.................... 		while(ChunkLen) 
016E2:  MOVF   xA7,W
016E4:  IORWF  xA8,W
016E6:  BZ    171E
.................... 		{ 
.................... 			Checksum.Val += *DataPtr++; 
016E8:  MOVFF  2BE,03
016EC:  MOVFF  2BD,00
016F0:  MOVLW  02
016F2:  ADDWF  xBD,F
016F4:  BTFSC  FD8.0
016F6:  INCF   xBE,F
016F8:  MOVFF  00,FE9
016FC:  MOVFF  03,FEA
01700:  MOVFF  FEC,03
01704:  MOVF   FED,F
01706:  MOVF   FEF,W
01708:  ADDWF  xA3,F
0170A:  MOVF   03,W
0170C:  ADDWFC xA4,F
0170E:  MOVLW  00
01710:  ADDWFC xA5,F
01712:  ADDWFC xA6,F
.................... 			ChunkLen -= 2; 
01714:  MOVLW  02
01716:  SUBWF  xA7,F
01718:  MOVLW  00
0171A:  SUBWFB xA8,F
0171C:  BRA    16E2
.................... 		} 
0171E:  BRA    1670
.................... 	} 
....................  
.................... 	// Restore old read pointer location 
.................... 	ERDPT = Start; 
01720:  MOVFF  2A2,F7B
01724:  MOVFF  2A1,F7A
....................  
.................... 	// Do an end-around carry (one's complement arrithmatic) 
.................... 	Checksum.Val = (DWORD)Checksum.w[0] + (DWORD)Checksum.w[1]; 
01728:  CLRF   xC2
0172A:  CLRF   xC1
0172C:  MOVFF  2A4,2C0
01730:  MOVFF  2A3,2BF
01734:  MOVFF  2A5,00
01738:  MOVFF  2A6,01
0173C:  CLRF   02
0173E:  CLRF   03
01740:  MOVF   xA5,W
01742:  ADDWF  xA3,W
01744:  MOVWF  xA3
01746:  MOVF   xA6,W
01748:  ADDWFC xA4,W
0174A:  MOVWF  xA4
0174C:  MOVF   02,W
0174E:  ADDWFC xC1,W
01750:  MOVWF  xA5
01752:  MOVF   03,W
01754:  ADDWFC xC2,W
01756:  MOVWF  xA6
....................  
.................... 	// Do another end-around carry in case if the prior add 
.................... 	// caused a carry out 
.................... 	Checksum.w[0] += Checksum.w[1]; 
01758:  MOVF   xA5,W
0175A:  ADDWF  xA3,F
0175C:  MOVF   xA6,W
0175E:  ADDWFC xA4,F
....................  
.................... 	// Return the resulting checksum 
.................... 	return ~Checksum.w[0]; 
01760:  MOVFF  2A4,03
01764:  COMF   03,F
01766:  MOVF   xA3,W
01768:  XORLW  FF
0176A:  MOVWF  01
0176C:  MOVFF  03,02
01770:  MOVLB  0
01772:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACMemCopyAsync(PTR_BASE destAddr, PTR_BASE sourceAddr, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           destAddr:	Destination address in the Ethernet memory to 
....................  *								copy to.  If (PTR_BASE)-1 is specified, the  
....................  *								current EWRPT value will be used instead. 
....................  *					sourceAddr:	Source address to read from.  If (PTR_BASE)-1 is 
....................  *                              specified, the current ERDPT value will be used 
....................  *                              instead. 
....................  *					len:		Number of bytes to copy 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Bytes are asynchrnously transfered within the buffer.  Call 
....................  *					MACIsMemCopyDone() to see when the transfer is complete. 
....................  * 
....................  * Note:            If a prior transfer is already in progress prior to 
....................  *					calling this function, this function will block until it 
....................  *					can start this transfer. 
....................  *****************************************************************************/ 
.................... void MACMemCopyAsync(PTR_BASE destAddr, PTR_BASE sourceAddr, WORD len) 
*
0084C:  MOVLB  2
0084E:  BCF    xB8.0
00850:  BCF    xB8.1
.................... { 
.................... 	WORD_VAL ReadSave, WriteSave; 
.................... 	BOOL UpdateWritePointer = FALSE; 
.................... 	BOOL UpdateReadPointer = FALSE; 
....................  
.................... 	if(destAddr == (PTR_BASE)-1) 
00852:  INCFSZ xAE,W
00854:  BRA    0864
00856:  INCFSZ xAF,W
00858:  BRA    0864
.................... 	{ 
.................... 		UpdateWritePointer = TRUE; 
0085A:  BSF    xB8.0
.................... 		destAddr = EWRPT; 
0085C:  MOVFF  EE3,2AF
00860:  MOVFF  EE2,2AE
.................... 	} 
.................... 	if(sourceAddr == (PTR_BASE)-1) 
00864:  INCFSZ xB0,W
00866:  BRA    0876
00868:  INCFSZ xB1,W
0086A:  BRA    0876
.................... 	{ 
.................... 		UpdateReadPointer = TRUE; 
0086C:  BSF    xB8.1
.................... 		sourceAddr = ERDPT; 
0086E:  MOVFF  F7B,2B1
00872:  MOVFF  F7A,2B0
.................... 	} 
....................  
.................... 	// Handle special conditions where len == 0 or len == 1 
.................... 	// The DMA module is not capable of handling those corner cases 
.................... 	if(len <= 1u) 
00876:  MOVF   xB3,F
00878:  BNZ   08DC
0087A:  MOVF   xB2,W
0087C:  SUBLW  01
0087E:  BNC   08DC
.................... 	{ 
.................... 		ReadSave.Val = ERDPT; 
00880:  MOVFF  F7B,2B5
00884:  MOVFF  F7A,2B4
.................... 		WriteSave.Val = EWRPT; 
00888:  MOVFF  EE3,2B7
0088C:  MOVFF  EE2,2B6
.................... 		ERDPT = sourceAddr; 
00890:  MOVFF  2B1,F7B
00894:  MOVFF  2B0,F7A
.................... 		EWRPT = destAddr; 
00898:  MOVFF  2AF,EE3
0089C:  MOVFF  2AE,EE2
.................... 		while(len--) 
008A0:  MOVFF  2B3,03
008A4:  MOVF   xB2,W
008A6:  BTFSC  FD8.2
008A8:  DECF   xB3,F
008AA:  DECF   xB2,F
008AC:  IORWF  03,W
008AE:  BZ    08C2
.................... 			MACPut(MACGet()); 
008B0:  MOVLB  0
008B2:  RCALL  0846
008B4:  MOVFF  01,2B9
008B8:  MOVFF  01,2C2
008BC:  RCALL  05A0
008BE:  MOVLB  2
008C0:  BRA    08A0
.................... 		if(!UpdateReadPointer) 
008C2:  BTFSC  xB8.1
008C4:  BRA    08CE
.................... 		{ 
.................... 			ERDPT = ReadSave.Val; 
008C6:  MOVFF  2B5,F7B
008CA:  MOVFF  2B4,F7A
.................... 		} 
.................... 		if(!UpdateWritePointer) 
008CE:  BTFSC  xB8.0
008D0:  BRA    08DA
.................... 		{ 
.................... 			EWRPT = WriteSave.Val; 
008D2:  MOVFF  2B7,EE3
008D6:  MOVFF  2B6,EE2
.................... 		} 
.................... 	} 
008DA:  BRA    098A
.................... 	else 
.................... 	{ 
.................... 		if(UpdateWritePointer) 
008DC:  BTFSS  xB8.0
008DE:  BRA    08F4
.................... 		{ 
.................... 			WriteSave.Val = destAddr + len; 
008E0:  MOVF   xB2,W
008E2:  ADDWF  xAE,W
008E4:  MOVWF  xB6
008E6:  MOVF   xB3,W
008E8:  ADDWFC xAF,W
008EA:  MOVWF  xB7
.................... 			EWRPT = WriteSave.Val; 
008EC:  MOVFF  2B7,EE3
008F0:  MOVFF  2B6,EE2
.................... 		} 
.................... 		len += sourceAddr - 1; 
008F4:  MOVLW  01
008F6:  SUBWF  xB0,W
008F8:  MOVWF  00
008FA:  MOVLW  00
008FC:  SUBWFB xB1,W
008FE:  MOVWF  03
00900:  MOVF   00,W
00902:  ADDWF  xB2,F
00904:  MOVF   03,W
00906:  ADDWFC xB3,F
.................... 		while(ECON1bits.DMAST); 
00908:  BTFSC  FD2.5
0090A:  BRA    0908
.................... 		EDMAST = sourceAddr; 
0090C:  MOVFF  2B1,EF1
00910:  MOVFF  2B0,EF0
.................... 		EDMADST = destAddr; 
00914:  MOVFF  2AF,EF5
00918:  MOVFF  2AE,EF4
.................... 		if((sourceAddr <= RXSTOP) && (len > RXSTOP)) //&& (sourceAddr >= RXSTART)) 
0091C:  MOVF   xB1,W
0091E:  SUBLW  15
00920:  BNC   0942
00922:  BNZ   092A
00924:  MOVF   xB0,W
00926:  SUBLW  09
00928:  BNC   0942
0092A:  MOVF   xB3,W
0092C:  SUBLW  14
0092E:  BC    0942
00930:  XORLW  FF
00932:  BNZ   093A
00934:  MOVF   xB2,W
00936:  SUBLW  09
00938:  BC    0942
.................... 			len -= RXSIZE; 
0093A:  MOVLW  0A
0093C:  SUBWF  xB2,F
0093E:  MOVLW  15
00940:  SUBWFB xB3,F
.................... 		EDMAND = len; 
00942:  MOVFF  2B3,EF3
00946:  MOVFF  2B2,EF2
.................... 		ECON1bits.CSUMEN = 0; 
0094A:  BCF    FD2.4
.................... 		ECON1bits.DMAST = 1; 
0094C:  BSF    FD2.5
.................... 		while(ECON1bits.DMAST);			// DMA requires that you must not access EDATA while DMA active 
0094E:  BTFSC  FD2.5
00950:  BRA    094E
....................  
.................... 		if(UpdateReadPointer) 
00952:  BTFSS  xB8.1
00954:  BRA    098A
.................... 		{ 
.................... 			len++; 
00956:  INCF   xB2,F
00958:  BTFSC  FD8.2
0095A:  INCF   xB3,F
.................... 			if((sourceAddr <= RXSTOP) && (len > RXSTOP)) //&& (sourceAddr >= RXSTART)) 
0095C:  MOVF   xB1,W
0095E:  SUBLW  15
00960:  BNC   0982
00962:  BNZ   096A
00964:  MOVF   xB0,W
00966:  SUBLW  09
00968:  BNC   0982
0096A:  MOVF   xB3,W
0096C:  SUBLW  14
0096E:  BC    0982
00970:  XORLW  FF
00972:  BNZ   097A
00974:  MOVF   xB2,W
00976:  SUBLW  09
00978:  BC    0982
.................... 				len -= RXSIZE; 
0097A:  MOVLW  0A
0097C:  SUBWF  xB2,F
0097E:  MOVLW  15
00980:  SUBWFB xB3,F
.................... 			ERDPT = len; 
00982:  MOVFF  2B3,F7B
00986:  MOVFF  2B2,F7A
.................... 		} 
.................... 	} 
0098A:  MOVLB  0
0098C:  RETURN 0
.................... } 
....................  
.................... /* 
.................... void MACMemCopyAsync(WORD destAddr, WORD sourceAddr, WORD len) 
.................... { 
.................... 	WORD_VAL ReadSave, WriteSave; 
.................... 	BOOL UpdateWritePointer = FALSE; 
.................... 	BOOL UpdateReadPointer = FALSE; 
....................  
.................... 	if(((WORD_VAL*)&destAddr)->bits.b15) 
.................... 	{ 
.................... 		UpdateWritePointer = TRUE; 
.................... 		destAddr = EWRPT; 
.................... 	} 
.................... 	if(((WORD_VAL*)&sourceAddr)->bits.b15) 
.................... 	{ 
.................... 		UpdateReadPointer = TRUE; 
.................... 		sourceAddr = ERDPT; 
.................... 	} 
....................  
.................... 	ReadSave.Val = ERDPT; 
.................... 	WriteSave.Val = EWRPT; 
.................... 	ERDPT = sourceAddr; 
.................... 	EWRPT = destAddr; 
.................... 	while(len--) 
.................... 	{ 
.................... 		MACPut(MACGet()); 
.................... 	} 
....................  
.................... 	if(!UpdateReadPointer) 
.................... 	{ 
.................... 		ERDPT = ReadSave.Val; 
.................... 	} 
.................... 	if(!UpdateWritePointer) 
.................... 	{ 
.................... 		EWRPT = WriteSave.Val; 
.................... 	} 
.................... } 
.................... */ 
....................  
.................... BOOL MACIsMemCopyDone(void) 
.................... { 
.................... 	return !ECON1bits.DMAST; 
0098E:  MOVLW  00
00990:  BTFSS  FD2.5
00992:  MOVLW  01
00994:  MOVWF  01
00996:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE MACGet() 
....................  * 
....................  * PreCondition:    ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Byte read from the Ethernet's buffer RAM 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACGet returns the byte pointed to by ERDPT and 
....................  *					increments ERDPT so MACGet() can be called again.  The 
....................  *					increment will follow the receive buffer wrapping boundary. 
....................  * 
....................  * Note:            For better performance, implement this function as a macro: 
....................  *					#define MACGet()	(EDATA) 
....................  *****************************************************************************/ 
.................... BYTE MACGet() 
.................... { 
.................... 	#if defined(HI_TECH_C) 
.................... 		asm("movff	0xF61, _errataTempL");	// movff EDATA, errataTempL 
.................... 		return errataTempL; 
.................... 	#else 
.................... 		return EDATA; 
*
00846:  MOVF   F61,W
00848:  MOVWF  01
.................... 	#endif 
0084A:  RETURN 0
.................... }//end MACGet 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           *val: Pointer to storage location 
....................  *					len:  Number of bytes to read from the data buffer. 
....................  * 
....................  * Output:          Byte(s) of data read from the data buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Reads several sequential bytes from the data buffer 
....................  *					and places them into local memory.  ERDPT is incremented 
....................  *					after each byte, following the same rules as MACGet(). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetArray(BYTE *val, WORD len) 
.................... { 
....................     WORD w; 
....................  
....................     w = len; 
*
007EA:  MOVFF  2C2,2C4
007EE:  MOVFF  2C1,2C3
.................... 	if(val) 
007F2:  MOVLB  2
007F4:  MOVF   xBF,W
007F6:  IORWF  xC0,W
007F8:  BZ    0824
.................... 	{ 
.................... 	    while(w--) 
007FA:  MOVFF  2C4,03
007FE:  MOVF   xC3,W
00800:  BTFSC  FD8.2
00802:  DECF   xC4,F
00804:  DECF   xC3,F
00806:  IORWF  03,W
00808:  BZ    0822
.................... 	    { 
.................... 			#if defined(HI_TECH_C) 
.................... 				asm("movff	0xF61, _errataTempL");	// movff EDATA, errataTempL 
.................... 				*val++ = errataTempL; 
.................... 			#else 
.................... 				*val++ = EDATA; 
0080A:  MOVFF  2C0,03
0080E:  MOVF   xBF,W
00810:  INCF   xBF,F
00812:  BTFSC  FD8.2
00814:  INCF   xC0,F
00816:  MOVWF  FE9
00818:  MOVFF  03,FEA
0081C:  MOVFF  F61,FEF
.................... 			#endif 
00820:  BRA    07FA
.................... 	    } 
.................... 	} 
00822:  BRA    083A
.................... 	else 
.................... 	{ 
.................... 		while(w--) 
00824:  MOVFF  2C4,03
00828:  MOVF   xC3,W
0082A:  BTFSC  FD8.2
0082C:  DECF   xC4,F
0082E:  DECF   xC3,F
00830:  IORWF  03,W
00832:  BZ    083A
.................... 		{ 
.................... 			#if defined(HI_TECH_C) 
.................... 			{ 
.................... 				asm("movff	0xF61, _errataTempL");	// movff EDATA, errataTempL 
.................... 			} 
.................... 			#else 
.................... 			{	 
.................... 				volatile BYTE i = EDATA; 
00834:  MOVFF  F61,2C5
.................... 			} 
.................... 			#endif 
00838:  BRA    0824
.................... 		} 
.................... 	} 
....................  
.................... 	return len; 
0083A:  MOVFF  2C1,01
0083E:  MOVFF  2C2,02
00842:  MOVLB  0
00844:  RETURN 0
.................... }//end MACGetArray 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPut(BYTE val) 
....................  * 
....................  * PreCondition:    EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           Byte to write into the Ethernet buffer memory 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes to the EDATA register, which will indirectly 
.................... *					increment EWRPTH:EWRPTL. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPut(BYTE val) 
.................... { 
.................... 	// Note:  Due to a PIC18F97J60 bug, you must use the MOVFF instruction to 
.................... 	// write to EDATA or else the read pointer (ERDPT) will inadvertently 
.................... 	// increment. 
.................... 	#if defined(HI_TECH_C) 
.................... 		errataTempL = val; 
.................... 		asm("movff	_errataTempL, 0xF61");	// movff errataTempL, EDATA 
.................... 	#else 
.................... 		PRODL = val; 
*
005A0:  MOVFF  2C2,FF3
.................... 		_asm movff	PRODL, EDATA _endasm 
005A4:  MOVFF  FF3,F61
.................... 	#endif 
005A8:  RETURN 0
.................... }//end MACPut 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPutArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           *val: Pointer to source of bytes to copy. 
....................  *					len:  Number of bytes to write to the data buffer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPutArray writes several sequential bytes to the 
....................  *					Ethernet buffer RAM.  It performs faster than multiple MACPut() 
....................  *					calls.  EWRPT is incremented by len. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPutArray(BYTE *val, WORD len) 
.................... { 
....................     while(len--) 
*
0079A:  MOVLB  2
0079C:  MOVFF  2C6,03
007A0:  MOVF   xC5,W
007A2:  BTFSC  FD8.2
007A4:  DECF   xC6,F
007A6:  DECF   xC5,F
007A8:  IORWF  03,W
007AA:  BZ    07C8
.................... 	{ 
.................... 		// Note:  Due to a PIC18F97J60 bug, you must use the MOVFF instruction to 
.................... 		// write to EDATA or else the read pointer (ERDPT) will inadvertently 
.................... 		// increment. 
.................... 		#if defined(HI_TECH_C) 
.................... 			errataTempL = *val++; 
.................... 			asm("movff	_errataTempL, 0xF61");	// movff errataTempL, EDATA 
.................... 		#else 
.................... 			PRODL = *val++; 
007AC:  MOVFF  2C4,03
007B0:  MOVF   xC3,W
007B2:  INCF   xC3,F
007B4:  BTFSC  FD8.2
007B6:  INCF   xC4,F
007B8:  MOVWF  FE9
007BA:  MOVFF  03,FEA
007BE:  MOVFF  FEF,FF3
.................... 			_asm movff	PRODL, EDATA _endasm 
007C2:  MOVFF  FF3,F61
.................... 		#endif 
007C6:  BRA    079C
.................... 	} 
007C8:  MOVLB  0
007CA:  RETURN 0
.................... }//end MACPutArray 
....................  
.................... void MACPutROMArray(ROM BYTE *val, WORD len) 
.................... { 
....................     while(len--) 
.................... 	{ 
.................... 		// Note:  Due to a PIC18F97J60 bug, you must use the MOVFF instruction to 
.................... 		// write to EDATA or else the read pointer (ERDPT) will inadvertently 
.................... 		// increment. 
.................... 		#if defined(HI_TECH_C) 
.................... 			errataTempL = *val++; 
.................... 			asm("movff	_errataTempL, 0xF61");	// movff errataTempL, EDATA 
.................... 		#else 
.................... 			PRODL = *val++; 
.................... 			_asm movff	PRODL, EDATA _endasm 
.................... 		#endif 
.................... 	} 
.................... }//end MACPutROMArray 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        ReadPHYReg 
....................  * 
....................  * PreCondition:    Ethernet module must be enabled (ECON1.ETHEN = 1). 
....................  * 
....................  * Input:           Address of the PHY register to read from. 
....................  * 
....................  * Output:          16 bits of data read from the PHY register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadPHYReg performs an MII read operation.  While in 
....................  *					progress, it simply polls the MII BUSY bit wasting time 
....................  *					(10.24us). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PHYREG ReadPHYReg(BYTE Register) 
.................... { 
.................... 	PHYREG Result; 
....................  
.................... 	// Set the right address and start the register read operation 
....................     MIREGADR = Register; Nop(); 
....................     MICMD = MICMD_MIIRD; Nop(); 
....................  
.................... 	// Loop to wait until the PHY register has been read through the MII 
.................... 	// This requires 10.24us 
....................     while(MISTATbits.BUSY); 
....................  
.................... 	// Stop reading 
....................     MICMD = 0x00; Nop(); 
....................  
.................... 	// Obtain results and return 
....................     Result.VAL.v[0] = MIRDL; 
....................     Nop(); 
....................     Result.VAL.v[1] = MIRDH; 
....................  
.................... 	return Result; 
.................... }//end ReadPHYReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WritePHYReg 
....................  * 
....................  * PreCondition:    Ethernet module must be enabled (ECON1.ETHEN = 1). 
....................  * 
....................  * Input:           Address of the PHY register to write to. 
....................  *					16 bits of data to write to PHY register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        WritePHYReg performs an MII write operation.  While in 
....................  *					progress, it simply polls the MII BUSY bit wasting time 
....................  *					(10.24us). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void WritePHYReg(BYTE Register, WORD Data) 
.................... { 
.................... 	BYTE GIESave; 
....................  
.................... 	// Write the register address 
.................... 	MIREGADR = Register; 
*
005AA:  MOVFF  16F,EB4
....................  
.................... 	// Write the data through the MIIM interface 
.................... 	// Order is important: write low byte first, high byte last 
.................... 	// 
.................... 	// Due to a silicon problem, you cannot access any register with LSb address 
.................... 	// bits of 0x16 between your write to MIWRL and MIWRH or else the value in 
.................... 	// MIWRL will be corrupted.  This inline assembly prevents this by copying 
.................... 	// the value to PRODH:PRODL first, which is at fixed locations of 
.................... 	// 0xFF4:0xFF3.  These addresses have LSb address bits of 0x14 and 0x13. 
.................... 	// Interrupts must be disabled to prevent arbitrary ISR code from accessing 
.................... 	// memory with LSb bits of 0x16 and corrupting the MIWRL value. 
.................... 	#if defined(HI_TECH_C) 
.................... 		errataTempL = ((BYTE*)&Data)[0]; 
.................... 		errataTempH = ((BYTE*)&Data)[1]; 
.................... 		GIESave = INTCON & 0xC0;		// Save GIEH and GIEL bits 
.................... 		INTCON &= 0x3F;					// Clear INTCONbits.GIEH and INTCONbits.GIEL 
.................... 		asm("movff	_errataTempL, 0xEB6");	// movff errataTempL, MIWRL 
.................... 		asm("nop"); 
.................... 		asm("movff	_errataTempH, 0xEB7");	// movff errataTempH, MIWRH 
.................... 	#else 
.................... 		PRODL = ((BYTE*)&Data)[0]; 
005AE:  MOVFF  170,FF3
.................... 		PRODH = ((BYTE*)&Data)[1]; 
005B2:  MOVFF  171,FF4
.................... 		GIESave = INTCON & 0xC0;		// Save GIEH and GIEL bits 
005B6:  MOVF   FF2,W
005B8:  ANDLW  C0
005BA:  MOVLB  1
005BC:  MOVWF  x72
.................... 		INTCON &= 0x3F;					// Clear INTCONbits.GIEH and INTCONbits.GIEL 
005BE:  MOVLW  3F
005C0:  ANDWF  FF2,F
.................... 		_asm 
.................... 		movff	PRODL, MIWRL 
005C2:  MOVFF  FF3,EB6
005C6:  NOP   
.................... 		nop 
.................... 		movff	PRODH, MIWRH 
005C8:  MOVFF  FF4,EB7
.................... 		_endasm 
.................... 	#endif 
.................... 	INTCON |= GIESave;				// Restore GIEH and GIEL value 
005CC:  MOVF   x72,W
005CE:  IORWF  FF2,F
....................  
.................... 	// Wait until the PHY register has been written 
.................... 	// This operation requires 10.24us 
....................     while(MISTATbits.BUSY); 
005D0:  MOVLB  E
005D2:  BTFSC  x8A.0
005D4:  BRA    05D2
005D6:  MOVLB  0
005D8:  RETURN 0
.................... }//end WritePHYReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerDown(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerDown disables the Ethernet module. 
....................  *					All MAC and PHY registers should not be accessed. 
....................  * 
....................  * Note:            Normally, this function would be called before putting the 
....................  *					PIC to sleep.  If a packet is being transmitted while this 
....................  *					function is called, this function will block until it is 
....................  *					it complete. If anything is being received, it will be 
....................  *					completed. 
....................  * 
....................  *					The Ethernet module will continue to draw significant 
....................  *					power in sleep mode if this function is not called first. 
....................  *****************************************************************************/ 
.................... void MACPowerDown(void) 
.................... { 
.................... 	// Disable packet reception 
.................... 	ECON1bits.RXEN = 0; 
....................  
.................... 	// Make sure any last packet which was in-progress when RXEN was cleared 
.................... 	// is completed 
.................... 	while(ESTATbits.RXBUSY); 
....................  
.................... 	// If a packet is being transmitted, wait for it to finish 
.................... 	while(ECON1bits.TXRTS); 
....................  
.................... 	// Disable the Ethernet module 
.................... 	ECON2bits.ETHEN = 0; 
.................... }//end MACPowerDown 
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerUp(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerUp returns the Ethernet module back to normal operation 
....................  *					after a previous call to MACPowerDown().  Calling this 
....................  *					function when already powered up will have no effect. 
....................  * 
....................  * Note:            If a link partner is present, it will take 10s of 
....................  *					milliseconds before a new link will be established after 
....................  *					waking up.  While not linked, packets which are 
....................  *					transmitted will most likely be lost.  MACIsLinked() can 
....................  *					be called to determine if a link is established. 
....................  *****************************************************************************/ 
.................... void MACPowerUp(void) 
.................... { 
.................... 	// Power up the Ethernet module 
.................... 	ECON2bits.ETHEN = 1; 
....................  
.................... 	// Wait for PHY to become ready 
.................... 	while(!ESTATbits.PHYRDY) 
....................  
.................... 	// Enable packet reception 
.................... 	ECON1bits.RXEN = 1; 
.................... }//end MACPowerUp 
....................  
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void SetRXHashTableEntry(MAC_ADDR DestMACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           DestMACAddr: 6 byte group destination MAC address to allow  
....................  *								 through the Hash Table Filter.  If DestMACAddr  
....................  *								 is set to 00-00-00-00-00-00, then the hash  
....................  *								 table will be cleared of all entries and the  
....................  *								 filter will be disabled. 
....................  * 
....................  * Output:          Sets the appropriate bit in the EHT* registers to allow  
....................  *					packets sent to DestMACAddr to be received and enables the  
....................  *					Hash Table receive filter (if not already). 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Calculates a CRC-32 using polynomial 0x4C11DB7 and then,  
....................  *					using bits 28:23 of the CRC, sets the appropriate bit in  
....................  *					the EHT0-EHT7 registers. 
....................  * 
....................  * Note:            This code is commented out to save code space on systems  
....................  *					that do not need this function.  Change the  
....................  *					"#if STACK_USE_ZEROCONF_MDNS_SD" line to "#if 1" to  
....................  *					uncomment it, assuming you aren't using the Zeroconf module,  
....................  *					which requires mutlicast support and enables this function  
....................  *					automatically. 
....................  * 
....................  *					There is no way to individually unset destination MAC  
....................  *					addresses from the hash table since it is possible to have  
....................  *					a hash collision and therefore multiple MAC addresses  
....................  *					relying on the same hash table bit.  The stack would have  
....................  *					to individually store each 6 byte MAC address to support  
....................  *					this feature, which would waste a lot of RAM and be  
....................  *					unnecessary in most applications.  As a simple compromise,  
....................  *					you can call SetRXHashTableEntry() using a  
....................  *					00-00-00-00-00-00 destination MAC address, which will clear  
....................  *					the entire hash table and disable the hash table filter.   
....................  *					This will allow you to then re-add the necessary  
....................  *					destination address(es). 
....................  * 
....................  *					This function is intended to be used when  
....................  *					ERXFCONbits.ANDOR == 0 (OR). 
....................  *****************************************************************************/ 
.................... #if defined(STACK_USE_ZEROCONF_MDNS_SD) 
.................... void SetRXHashTableEntry(MAC_ADDR DestMACAddr) 
.................... { 
.................... 	DWORD_VAL CRC = {0xFFFFFFFF}; 
.................... 	BYTE *HTRegister; 
.................... 	BYTE i, j; 
....................  
.................... 	if((DestMACAddr.v[0] | DestMACAddr.v[1] | DestMACAddr.v[2] | DestMACAddr.v[3] | DestMACAddr.v[4] | DestMACAddr.v[5]) == 0x00u) 
.................... 	{ 
.................... 		// Disable the Hash Table receive filter and clear the hash table 
.................... 		ERXFCONbits.HTEN = 0; 
.................... 		EHT0 = 0x00; 
.................... 		EHT1 = 0x00; 
.................... 		EHT2 = 0x00; 
.................... 		EHT3 = 0x00; 
.................... 		EHT4 = 0x00; 
.................... 		EHT5 = 0x00; 
.................... 		EHT6 = 0x00; 
.................... 		EHT7 = 0x00; 
....................  
.................... 		return; 
.................... 	} 
....................  
....................  
.................... 	// Calculate a CRC-32 over the 6 byte MAC address 
.................... 	// using polynomial 0x4C11DB7 
.................... 	for(i = 0; i < sizeof(MAC_ADDR); i++) 
.................... 	{ 
.................... 		BYTE  crcnext; 
....................  
.................... 		// shift in 8 bits 
.................... 		for(j = 0; j < 8; j++) 
.................... 		{ 
.................... 			crcnext = 0; 
.................... 			if(((BYTE_VAL*)&(CRC.v[3]))->bits.b7) 
.................... 				crcnext = 1; 
.................... 			crcnext ^= (((BYTE_VAL*)&DestMACAddr.v[i])->bits.b0); 
....................  
.................... 			CRC.Val <<= 1; 
.................... 			if(crcnext) 
.................... 				CRC.Val ^= 0x4C11DB7; 
.................... 			// next bit 
.................... 			DestMACAddr.v[i] >>= 1; 
.................... 		} 
.................... 	} 
....................  
.................... 	// CRC-32 calculated, now extract bits 28:23 
.................... 	// Bits 25:23 define where within the Hash Table byte the bit needs to be set 
.................... 	// Bits 28:26 define which of the 8 Hash Table bytes that bits 25:23 apply to 
.................... 	i = CRC.v[3] & 0x1F; 
.................... 	HTRegister = (i >> 2) + &EHT0; 
.................... 	i = (i << 1) & 0x06; 
.................... 	((BYTE_VAL*)&i)->bits.b0 = ((BYTE_VAL*)&CRC.v[2])->bits.b7; 
....................  
.................... 	// Set the proper bit in the Hash Table 
.................... 	*HTRegister |= 1<<i; 
....................  
.................... 	// Ensure that the Hash Table receive filter is enabled 
.................... 	ERXFCONbits.HTEN = 1; 
.................... } 
.................... #endif 
....................  
....................  
....................  
.................... #endif //#if (defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60)) || defined(HI_TECH_C) 
....................  
.................... #elif defined(WF_CS_TRIS) 
....................       #include "WF_Config.c" 
....................       #if defined(WF_USE_SCAN_FUNCTIONS) 
....................          #include "WFScan.c" 
....................       #endif 
....................       #if defined(WF_USE_POWER_SAVE_FUNCTIONS) 
....................          #include "WFPowerSave.c" 
....................       #else 
....................          BOOL GetAppPowerSaveMode(void) {return(TRUE);} 
....................       #endif 
....................       #if defined(WF_USE_TX_POWER_CONTROL_FUNCTIONS) 
....................          #include "WFTxPower.c" 
....................       #endif 
....................       #include "WF_Spi.c" 
....................       #include "WF_Eint.c" 
....................       #include "WFConnectionProfile.c" 
....................       #include "WFConnectionAlgorithm.c" 
....................       #include "WFConnectionManager.c" 
....................       #include "WFEventHandler.c" 
....................       #include "WFInit.c" 
....................      #if defined(MRF24WG) 
....................       #include "WFDriverCom_24G.c" 
....................       #include "WFDriverRaw_24G.c" 
....................       #include "WFMac_24G.c" 
....................       #include "WFMgmtMsg_24G.c" 
....................       #include "WFParamMsg_24G.c"      
....................      #else 
....................       #include "WFDriverCom.c" 
....................       #include "WFDriverRaw.c" 
....................       #include "WFMac.c" 
....................       #include "WFMgmtMsg.c" 
....................       #include "WFParamMsg.c" 
....................      #endif 
.................... #elif defined(ENC_CS_TRIS) 
....................    #include "tcpip\ENC28J60.c" 
.................... #elif defined(ENC100_INTERFACE_MODE) 
....................    #include "ENCX24J600.c" 
....................    #define PHYREG WORD 
.................... #elif defined(__PIC32MX__) && defined(_ETH) 
....................    // extra includes for PIC32MX with embedded ETH Controller 
.................... #else 
....................    #error No Ethernet/WiFi controller defined in HardwareProfile.h.  Defines for an ENC28J60, ENC424J600/624J600, or ZeroG ZG2100 must be present. 
.................... #endif 
.................... #include "IP.c" 
.................... /********************************************************************* 
....................  * 
....................  *  Internet Protocol (IP) Version 4 Communications Layer 
....................  *  Module for Microchip TCP/IP Stack 
....................  *   -Provides a transport for TCP, UDP, and ICMP messages 
....................  *	 -Reference: RFC 791 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.c 
....................  * Dependencies:    Network Layer interface (ENC28J60.c, ETH97J60.c,  
....................  *					ENCX24J600.c or WFMac.c) 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder		8/31/04	Beta Rev 0.9 (See version.log for detail) 
....................  * Howard Schlunder		1/5/06	Improved DMA checksum efficiency 
....................  * Darren Rook			9/21/06	Corrected IPHeaderLen not being  
....................  * 								initialized when NON_MCHP_MAC defined. 
....................  ********************************************************************/ 
.................... #define __IP_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... // This is left shifted by 4.  Actual value is 0x04. 
.................... #define IPv4                (0x40u) 
.................... #define IP_VERSION          IPv4 
....................  
.................... // IHL (Internet Header Length) is # of DWORDs in a header. 
.................... // Since, we do not support options, our IP header length will be 
.................... // minimum i.e. 20 bytes : IHL = 20 / 4 = 5. 
.................... #define IP_IHL              (0x05) 
....................  
.................... #define IP_SERVICE_NW_CTRL  (0x07) 
.................... #define IP_SERVICE_IN_CTRL  (0x06) 
.................... #define IP_SERVICE_ECP      (0x05) 
.................... #define IP_SERVICE_OVR      (0x04) 
.................... #define IP_SERVICE_FLASH    (0x03) 
.................... #define IP_SERVICE_IMM      (0x02) 
.................... #define IP_SERVICE_PRIOR    (0x01) 
.................... #define IP_SERVICE_ROUTINE  (0x00) 
....................  
.................... #define IP_SERVICE_N_DELAY  (0x00) 
.................... #define IP_SERCICE_L_DELAY  (0x08) 
.................... #define IP_SERVICE_N_THRPT  (0x00) 
.................... #define IP_SERVICE_H_THRPT  (0x10) 
.................... #define IP_SERVICE_N_RELIB  (0x00) 
.................... #define IP_SERVICE_H_RELIB  (0x20) 
....................  
.................... #define IP_SERVICE          (IP_SERVICE_ROUTINE | IP_SERVICE_N_DELAY) 
....................  
.................... #if defined(STACK_USE_ZEROCONF_MDNS_SD) 
....................   #define MY_IP_TTL           (255)  // Time-To-Live in hops  
....................   // IP TTL is set to 255 for Multicast DNS compatibility. See mDNS-draft-08, section 4. 
.................... #else 
....................   #define MY_IP_TTL           (100)  // Time-To-Live in hops 
.................... #endif 
....................  
....................  
....................  
.................... static WORD _Identifier = 0; 
.................... static BYTE IPHeaderLen; 
....................  
....................  
.................... static void SwapIPHeader(IP_HEADER* h); 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len) 
.................... { 
....................     WORD_VAL    CalcChecksum; 
....................     IP_HEADER   header; 
....................  
.................... #if defined(NON_MCHP_MAC) 
....................     WORD_VAL    ReceivedChecksum; 
....................     WORD        checksums[2]; 
....................     BYTE        optionsLen; 
.................... 	#define MAX_OPTIONS_LEN     (40u)            // As per RFC 791. 
....................     BYTE        options[MAX_OPTIONS_LEN]; 
.................... #endif 
....................  
....................     // Read IP header. 
....................     MACGetArray((BYTE*)&header, sizeof(header)); 
*
02E1A:  MOVLW  01
02E1C:  MOVLB  1
02E1E:  MOVWF  x95
02E20:  MOVLW  80
02E22:  MOVWF  x94
02E24:  MOVFF  195,2C0
02E28:  MOVFF  FE8,2BF
02E2C:  MOVLB  2
02E2E:  CLRF   xC2
02E30:  MOVLW  14
02E32:  MOVWF  xC1
02E34:  MOVLB  0
02E36:  CALL   07EA
....................  
....................     // Make sure that this is an IPv4 packet. 
....................     if((header.VersionIHL & 0xf0) != IP_VERSION) 
02E3A:  MOVLB  1
02E3C:  MOVF   x80,W
02E3E:  ANDLW  F0
02E40:  SUBLW  40
02E42:  BZ    2E4A
....................     	return FALSE; 
02E44:  MOVLW  00
02E46:  MOVWF  01
02E48:  BRA    2F18
....................  
.................... 	// Throw this packet away if it is a fragment.   
.................... 	// We don't have enough RAM for IP fragment reconstruction. 
.................... 	if(header.FragmentInfo & 0xFF1F) 
02E4A:  MOVF   x86,W
02E4C:  ANDLW  1F
02E4E:  MOVWF  00
02E50:  MOVFF  187,03
02E54:  MOVF   00,W
02E56:  IORWF  x87,W
02E58:  BZ    2E60
.................... 		return FALSE; 
02E5A:  MOVLW  00
02E5C:  MOVWF  01
02E5E:  BRA    2F18
....................  
.................... 	IPHeaderLen = (header.VersionIHL & 0x0f) << 2; 
02E60:  MOVF   x80,W
02E62:  ANDLW  0F
02E64:  MOVWF  00
02E66:  RLCF   00,W
02E68:  MOVLB  0
02E6A:  MOVWF  x84
02E6C:  RLCF   x84,F
02E6E:  MOVLW  FC
02E70:  ANDWF  x84,F
....................  
.................... #if !defined(NON_MCHP_MAC) 
.................... 	// Validate the IP header.  If it is correct, the checksum  
.................... 	// will come out to 0x0000 (because the header contains a  
.................... 	// precomputed checksum).  A corrupt header will have a  
.................... 	// nonzero checksum. 
.................... 	CalcChecksum.Val = MACCalcRxChecksum(0, IPHeaderLen); 
02E72:  MOVLB  1
02E74:  CLRF   x95
02E76:  CLRF   x94
02E78:  CLRF   x97
02E7A:  MOVFF  84,196
02E7E:  MOVLB  0
02E80:  RCALL  2D66
02E82:  MOVFF  02,17F
02E86:  MOVFF  01,17E
....................  
.................... 	// Seek to the end of the IP header 
.................... 	MACSetReadPtrInRx(IPHeaderLen); 
02E8A:  MOVLB  1
02E8C:  CLRF   xCA
02E8E:  MOVFF  84,1C9
02E92:  MOVLB  0
02E94:  RCALL  2DD8
....................  
....................     if(CalcChecksum.Val) 
02E96:  MOVLB  1
02E98:  MOVF   x7E,W
02E9A:  IORWF  x7F,W
02E9C:  BZ    2EA4
.................... #else 
....................     // Calculate options length in this header, if there is any. 
....................     // IHL is in terms of numbers of 32-bit DWORDs; i.e. actual 
....................     // length is 4 times IHL. 
....................     optionsLen = IPHeaderLen - sizeof(header); 
....................  
....................     // If there is any option(s), read it so that we can include them 
....................     // in checksum calculation. 
....................     if ( optionsLen > MAX_OPTIONS_LEN ) 
....................         return FALSE; 
....................  
....................     if ( optionsLen > 0u ) 
....................         MACGetArray(options, optionsLen); 
....................  
....................     // Save header checksum; clear it and recalculate it ourselves. 
....................     ReceivedChecksum.Val = header.HeaderChecksum; 
....................     header.HeaderChecksum = 0; 
....................  
....................     // Calculate checksum of header including options bytes. 
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&header, sizeof(header)); 
....................  
....................     // Calculate Options checksum too, if they are present. 
....................     if ( optionsLen > 0u ) 
....................         checksums[1] = ~CalcIPChecksum((BYTE*)options, optionsLen); 
....................     else 
....................         checksums[1] = 0; 
....................  
....................     CalcChecksum.Val  = CalcIPChecksum((BYTE*)checksums, 
....................                                             2 * sizeof(WORD)); 
....................  
....................     // Make sure that checksum is correct 
....................     if ( ReceivedChecksum.Val != CalcChecksum.Val ) 
.................... #endif 
....................     { 
....................         // Bad packet. The function caller will be notified by means of the FALSE  
....................         // return value and it should discard the packet. 
....................         return FALSE; 
02E9E:  MOVLW  00
02EA0:  MOVWF  01
02EA2:  BRA    2F18
....................     } 
....................  
....................     // Network to host conversion. 
....................     SwapIPHeader(&header); 
02EA4:  MOVLW  01
02EA6:  MOVLB  2
02EA8:  MOVWF  xB9
02EAA:  MOVLW  80
02EAC:  MOVWF  xB8
02EAE:  MOVLB  0
02EB0:  CALL   142E
....................  
....................     // If caller is intrested, return destination IP address 
....................     // as seen in this IP header. 
....................     if ( localIP ) 
02EB4:  MOVLB  1
02EB6:  MOVF   x76,W
02EB8:  IORWF  x77,W
02EBA:  BZ    2ED4
....................         localIP->Val    = header.DestAddress.Val; 
02EBC:  MOVFF  176,FE9
02EC0:  MOVFF  177,FEA
02EC4:  MOVFF  190,FEF
02EC8:  MOVFF  191,FEC
02ECC:  MOVFF  192,FEC
02ED0:  MOVFF  193,FEC
....................  
....................     remote->IPAddr.Val  = header.SourceAddress.Val; 
02ED4:  MOVFF  178,FE9
02ED8:  MOVF   x79,W
02EDA:  MOVWF  FEA
02EDC:  MOVFF  18C,FEF
02EE0:  MOVFF  18D,FEC
02EE4:  MOVFF  18E,FEC
02EE8:  MOVFF  18F,FEC
....................     *protocol           = header.Protocol; 
02EEC:  MOVFF  17A,FE9
02EF0:  MOVFF  17B,FEA
02EF4:  MOVFF  189,FEF
....................     *len 				= header.TotalLength - IPHeaderLen; 
02EF8:  MOVFF  17C,FE9
02EFC:  MOVFF  17D,FEA
02F00:  MOVLB  0
02F02:  MOVF   x84,W
02F04:  MOVLB  1
02F06:  SUBWF  x82,W
02F08:  MOVWF  00
02F0A:  MOVLW  00
02F0C:  SUBWFB x83,W
02F0E:  MOVFF  00,FEF
02F12:  MOVWF  FEC
....................  
....................     return TRUE; 
02F14:  MOVLW  01
02F16:  MOVWF  01
02F18:  MOVLB  0
02F1A:  GOTO   4A54 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function: WORD IPPutHeader(NODE_INFO *remote, 
....................  *           				  BYTE protocol, 
....................  *                			  WORD len) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           *remote     - Destination node address 
....................  *                  protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          (WORD)0 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  ********************************************************************/ 
.................... WORD IPPutHeader(NODE_INFO *remote, 
....................                  BYTE protocol, 
....................                  WORD len) 
.................... { 
....................     IP_HEADER   header; 
....................      
....................     IPHeaderLen = sizeof(IP_HEADER); 
*
01576:  MOVLW  14
01578:  MOVWF  x84
....................  
....................     header.VersionIHL       = IP_VERSION | IP_IHL; 
0157A:  MOVLW  45
0157C:  MOVLB  2
0157E:  MOVWF  xA4
....................     header.TypeOfService    = IP_SERVICE; 
01580:  CLRF   xA5
....................     header.TotalLength      = sizeof(header) + len; 
01582:  MOVLW  14
01584:  ADDWF  xA2,W
01586:  MOVWF  xA6
01588:  MOVLW  00
0158A:  ADDWFC xA3,W
0158C:  MOVWF  xA7
....................     header.Identification   = ++_Identifier; 
0158E:  MOVLB  0
01590:  INCF   x82,F
01592:  BTFSC  FD8.2
01594:  INCF   x83,F
01596:  MOVFF  83,2A9
0159A:  MOVFF  82,2A8
....................     header.FragmentInfo     = 0; 
0159E:  MOVLB  2
015A0:  CLRF   xAB
015A2:  CLRF   xAA
....................     header.TimeToLive       = MY_IP_TTL; 
015A4:  MOVLW  64
015A6:  MOVWF  xAC
....................     header.Protocol         = protocol; 
015A8:  MOVFF  2A1,2AD
....................     header.HeaderChecksum   = 0; 
015AC:  CLRF   xAF
015AE:  CLRF   xAE
.................... 	header.SourceAddress 	= AppConfig.MyIPAddr; 
015B0:  MOVFF  2D,2B3
015B4:  MOVFF  2C,2B2
015B8:  MOVFF  2B,2B1
015BC:  MOVFF  2A,2B0
....................  
....................     header.DestAddress.Val = remote->IPAddr.Val; 
015C0:  MOVFF  29F,FE9
015C4:  MOVFF  2A0,FEA
015C8:  MOVFF  FEF,2B4
015CC:  MOVFF  FEC,2B5
015D0:  MOVFF  FEC,2B6
015D4:  MOVFF  FEC,2B7
....................  
....................     SwapIPHeader(&header); 
015D8:  MOVLW  02
015DA:  MOVWF  xB9
015DC:  MOVLW  A4
015DE:  MOVWF  xB8
015E0:  MOVLB  0
015E2:  RCALL  142E
....................  
....................     header.HeaderChecksum   = CalcIPChecksum((BYTE*)&header, sizeof(header)); 
015E4:  MOVLW  02
015E6:  MOVLB  2
015E8:  MOVWF  xB9
015EA:  MOVLW  A4
015EC:  MOVWF  xB8
015EE:  MOVFF  2B9,2BB
015F2:  MOVWF  xBA
015F4:  CLRF   xBD
015F6:  MOVLW  14
015F8:  MOVWF  xBC
015FA:  MOVLB  0
015FC:  RCALL  1346
015FE:  MOVFF  02,2AF
01602:  MOVFF  01,2AE
....................  
....................     MACPutHeader(&remote->MACAddr, MAC_IP, (sizeof(header)+len)); 
01606:  MOVLW  04
01608:  MOVLB  2
0160A:  ADDWF  x9F,W
0160C:  MOVWF  01
0160E:  MOVLW  00
01610:  ADDWFC xA0,W
01612:  MOVWF  03
01614:  MOVFF  01,2B8
01618:  MOVWF  xB9
0161A:  MOVLW  14
0161C:  ADDWF  xA2,W
0161E:  MOVWF  xBA
01620:  MOVLW  00
01622:  ADDWFC xA3,W
01624:  MOVWF  xBB
01626:  MOVFF  03,2BD
0162A:  MOVFF  01,2BC
0162E:  CLRF   xBE
01630:  MOVWF  xC0
01632:  MOVFF  2BA,2BF
01636:  MOVLB  0
01638:  RCALL  1508
....................     MACPutArray((BYTE*)&header, sizeof(header)); 
0163A:  MOVLW  02
0163C:  MOVLB  2
0163E:  MOVWF  xB9
01640:  MOVLW  A4
01642:  MOVWF  xB8
01644:  MOVFF  2B9,2C4
01648:  MOVWF  xC3
0164A:  CLRF   xC6
0164C:  MOVLW  14
0164E:  MOVWF  xC5
01650:  MOVLB  0
01652:  CALL   079A
....................  
....................     return 0x0000; 
01656:  MOVLW  00
01658:  MOVWF  01
0165A:  MOVWF  02
0165C:  RETURN 0
....................  
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by  
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset  
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset)  
.................... { 
.................... 	MACSetReadPtrInRx(Offset+IPHeaderLen); 
*
03008:  MOVF   x84,W
0300A:  MOVLB  1
0300C:  ADDWF  xC5,W
0300E:  MOVWF  xC7
03010:  MOVLW  00
03012:  ADDWFC xC6,W
03014:  MOVWF  xC8
03016:  MOVWF  xCA
03018:  MOVFF  1C7,1C9
0301C:  MOVLB  0
0301E:  RCALL  2DD8
03020:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... static void SwapIPHeader(IP_HEADER* h) 
.................... { 
....................     h->TotalLength      = swaps(h->TotalLength); 
*
0142E:  MOVLW  02
01430:  MOVLB  2
01432:  ADDWF  xB8,W
01434:  MOVWF  01
01436:  MOVLW  00
01438:  ADDWFC xB9,W
0143A:  MOVWF  03
0143C:  MOVFF  01,2BA
01440:  MOVWF  xBB
01442:  MOVLW  02
01444:  ADDWF  xB8,W
01446:  MOVWF  FE9
01448:  MOVLW  00
0144A:  ADDWFC xB9,W
0144C:  MOVWF  FEA
0144E:  MOVFF  FEC,2BD
01452:  MOVF   FED,F
01454:  MOVFF  FEF,2BC
01458:  MOVFF  2BD,2BF
0145C:  MOVFF  2BC,2BE
01460:  MOVLB  0
01462:  RCALL  0F92
01464:  MOVFF  2BB,FEA
01468:  MOVFF  2BA,FE9
0146C:  MOVFF  02,FEC
01470:  MOVF   FED,F
01472:  MOVFF  01,FEF
....................     h->Identification   = swaps(h->Identification); 
01476:  MOVLW  04
01478:  MOVLB  2
0147A:  ADDWF  xB8,W
0147C:  MOVWF  01
0147E:  MOVLW  00
01480:  ADDWFC xB9,W
01482:  MOVWF  03
01484:  MOVFF  01,2BA
01488:  MOVWF  xBB
0148A:  MOVLW  04
0148C:  ADDWF  xB8,W
0148E:  MOVWF  FE9
01490:  MOVLW  00
01492:  ADDWFC xB9,W
01494:  MOVWF  FEA
01496:  MOVFF  FEC,2BD
0149A:  MOVF   FED,F
0149C:  MOVFF  FEF,2BC
014A0:  MOVFF  2BD,2BF
014A4:  MOVFF  2BC,2BE
014A8:  MOVLB  0
014AA:  RCALL  0F92
014AC:  MOVFF  2BB,FEA
014B0:  MOVFF  2BA,FE9
014B4:  MOVFF  02,FEC
014B8:  MOVF   FED,F
014BA:  MOVFF  01,FEF
....................     h->HeaderChecksum   = swaps(h->HeaderChecksum); 
014BE:  MOVLW  0A
014C0:  MOVLB  2
014C2:  ADDWF  xB8,W
014C4:  MOVWF  01
014C6:  MOVLW  00
014C8:  ADDWFC xB9,W
014CA:  MOVWF  03
014CC:  MOVFF  01,2BA
014D0:  MOVWF  xBB
014D2:  MOVLW  0A
014D4:  ADDWF  xB8,W
014D6:  MOVWF  FE9
014D8:  MOVLW  00
014DA:  ADDWFC xB9,W
014DC:  MOVWF  FEA
014DE:  MOVFF  FEC,2BD
014E2:  MOVF   FED,F
014E4:  MOVFF  FEF,2BC
014E8:  MOVFF  2BD,2BF
014EC:  MOVFF  2BC,2BE
014F0:  MOVLB  0
014F2:  RCALL  0F92
014F4:  MOVFF  2BB,FEA
014F8:  MOVFF  2BA,FE9
014FC:  MOVFF  02,FEC
01500:  MOVF   FED,F
01502:  MOVFF  01,FEF
01506:  RETURN 0
.................... } 
....................  
.................... #include "ARP.c" 
.................... /********************************************************************* 
....................  * 
....................  *   Address Resolution Protocol (ARP) Client and Server 
....................  *  Module for Microchip TCP/IP Stack 
....................  *    -Provides IP address to Ethernet MAC address translation 
....................  *    -Reference: RFC 826 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.c 
....................  * Dependencies:    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  ARP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder      8/17/06   Combined ARP.c and ARPTsk.c into ARP.c;  
....................  *                        rewrote some of it to look more linear 
....................  * Darren Rook/CCS      Added call to GratArpReset() if using STACK_USE_CCS_GRATUITOUS_ARP 
....................  ********************************************************************/ 
.................... #define __ARP_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Constants and Variables 
....................   ***************************************************************************/ 
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... //#define ARP_OPERATION_REQ       0x01u      // Operation code indicating an ARP Request 
.................... //#define ARP_OPERATION_RESP      0x02u      // Operation code indicating an ARP Response 
....................  
.................... #define HW_ETHERNET             (0x0001u)   // ARP Hardware type as defined by IEEE 802.3 
.................... #define ARP_IP                  (0x0800u)   // ARP IP packet type as defined by IEEE 802.3 
.................... #endif 
....................  
.................... #ifdef STACK_CLIENT_MODE 
.................... static NODE_INFO Cache;                  // Cache for one ARP response 
.................... #endif 
....................  
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... #define MAX_REG_APPS            2           // MAX num allowed registrations of Modules/Apps 
.................... static struct arp_app_callbacks reg_apps[MAX_REG_APPS]; // Call-Backs storage for MAX of two Modules/Apps 
.................... /* 
.................... // ARP packet structure 
.................... typedef struct __attribute__((aligned(2), packed)) 
.................... { 
....................     WORD        HardwareType; 
....................     WORD        Protocol; 
....................     BYTE        MACAddrLen; 
....................     BYTE        ProtocolLen; 
....................     WORD        Operation; 
....................     MAC_ADDR    SenderMACAddr; 
....................     IP_ADDR     SenderIPAddr; 
....................     MAC_ADDR    TargetMACAddr; 
....................     IP_ADDR     TargetIPAddr; 
.................... } ARP_PACKET; 
.................... */ 
.................... #endif 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Helper Function Prototypes 
....................   ***************************************************************************/ 
....................  
.................... static BOOL ARPPut(ARP_PACKET* packet); 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Function Implementations 
....................   ***************************************************************************/ 
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... /************ User Application APIs ****************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    CHAR ARPRegisterCallbacks(struct arp_app_callbacks *app) 
....................  
....................   Summary: 
....................    Registering callback with ARP module to get notified about certian events. 
....................     
....................   Description: 
....................      This function allows end user application to register with callbacks, which 
....................     will be called by ARP module to give notification to user-application about  
....................     events occurred at ARP layer. For ex: when a ARP-packet is received, which is 
....................     conflicting with our own pair of addresses (MAC-Address and IP-address). 
....................     This is an extension for zeroconf protocol implementation (ZeroconfLL.c) 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    app - ARP-Application callbacks structure supplied by user-application  
....................      
....................   Returns: 
....................     id > 0 - Returns non-negative value that represents the id of registration 
....................              The same id needs to be used in de-registration 
....................     -1     - When registered applications exceed MAX_REG_APPS and there is no 
....................              free slot for registration 
....................   
....................   ***************************************************************************/ 
.................... CHAR ARPRegisterCallbacks(struct arp_app_callbacks *app) 
.................... { 
....................     BYTE i; 
....................     for(i=0; i<MAX_REG_APPS; i++) 
....................     { 
....................         if(!reg_apps[i].used) 
....................         { 
....................             reg_apps[i].ARPPkt_notify = app->ARPPkt_notify; 
....................             reg_apps[i].used = 1; 
....................             return (i+1); // Return Code. Should be used in deregister. 
....................         } 
....................     } 
....................     return -1; // No space for registration 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL ARPDeRegisterCallbacks(CHAR reg_id) 
....................  
....................   Summary: 
....................    De-Registering callbacks with ARP module that are registered previously. 
....................     
....................   Description: 
....................      This function allows end user-application to de-register with callbacks,  
....................     which were registered previously. 
....................     This is called by user-application, when its no longer interested in  
....................     notifications from ARP-Module. This allows the other application to get  
....................     registered with ARP-module.    
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    reg_id - Registration-id returned in ARPRegisterCallbacks call 
....................      
....................   Returns: 
....................     TRUE  - On success 
....................     FALSE - Failure to indicate invalid reg_id   
....................   ***************************************************************************/  
.................... BOOL ARPDeRegisterCallbacks(CHAR reg_id) 
.................... { 
....................     if(reg_id <= 0 || reg_id > MAX_REG_APPS) 
....................         return FALSE; 
....................  
....................     reg_apps[reg_id-1].used = 0; // To indicate free slot for registration 
....................    return TRUE; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ARPProcessRxPkt(ARP_PACKET* packet) 
....................  
....................   Summary: 
....................    Processes Received-ARP packet (ARP request/Reply). 
....................     
....................   Description: 
....................      This function is to pass-on the ARP-packet to registered application, 
....................     with the notification of Rx-ARP packet.  
....................  
....................   Precondition: 
....................    ARP packet is received completely from MAC 
....................  
....................   Parameters: 
....................    packet - Rx packet to be processed      
....................  
....................   Returns: 
....................     None    
....................   ***************************************************************************/ 
.................... void ARPProcessRxPkt(ARP_PACKET* packet) 
.................... { 
....................     BYTE pass_on = 0; // Flag to indicate whether need to be forwarded 
....................     BYTE i; 
....................  
....................     // Probing Stage 
....................     if(AppConfig.MyIPAddr.Val == 0x00) 
....................     { 
....................         pass_on = 1; // Pass to Registered-Application for further processing         
....................     } 
....................     else if(AppConfig.MyIPAddr.Val) 
....................     { 
....................         /* Late-conflict */ 
....................         if(packet->SenderIPAddr.Val == AppConfig.MyIPAddr.Val) 
....................         { 
....................             pass_on = 1; 
....................         } 
....................     } 
....................     if(pass_on) 
....................     { 
....................      
....................         for(i =0; i< MAX_REG_APPS; i++) 
....................         { 
....................             if(reg_apps[i].used) 
....................             { 
....................                 reg_apps[i].ARPPkt_notify(packet->SenderIPAddr.Val, 
....................                                       packet->TargetIPAddr.Val, 
....................                                       &packet->SenderMACAddr, 
....................                                       &packet->TargetMACAddr, 
....................                                       packet->Operation);                 
....................             } 
....................         } 
....................     } 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ARPSendPkt(IP_ADDR* SrcIPAddr, IP_ADDR* DestIPAddr, int op_req ) 
....................  
....................   Summary: 
....................    Transmits an ARP request/Reply initated by Application or external module. 
....................     
....................   Description: 
....................      This function transmits and ARP request/reply to determine the hardware 
....................      address of a given IP address (or) Announce self-address to all nodes in 
....................     network. Extended for zeroconf protocol.  
....................  
....................   Precondition: 
....................    ARP packet is ready in the MAC buffer. 
....................  
....................   Parameters: 
....................    SrcIPAddr - The Source IP-address  
....................     DestIPAddr - The Destination IP-Address 
....................     op_req     - Operation Request (ARP_REQ/ARP_RESP) 
....................  
....................   Returns: 
....................     TRUE - The ARP packet was generated properly 
....................      FALSE - Not possible return value 
....................  
....................   Remarks: 
....................      This API is to give control over AR-packet to external modules.  
....................   ***************************************************************************/ 
.................... BOOL ARPSendPkt(DWORD SrcIPAddr, DWORD DestIPAddr, BYTE op_req ) 
.................... { 
....................     ARP_PACKET packet; 
....................  
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... #define KS_ARP_IP_MULTICAST_HACK y 
.................... #ifdef KS_ARP_IP_MULTICAST_HACK 
....................    DWORD_VAL *DestAddr = (DWORD_VAL *)&DestIPAddr; 
....................    if ((DestAddr->v[0] >= 224) &&(DestAddr->v[0] <= 239)) { 
....................       // "Resolve" the IP to MAC address mapping for 
....................       // IP multicast address range from 224.0.0.0 to 239.255.255.255 
....................     
....................       Cache.MACAddr.v[0] = 0x01; 
....................       Cache.MACAddr.v[1] = 0x00; 
....................       Cache.MACAddr.v[2] = 0x5E; 
....................       Cache.MACAddr.v[3] = 0x7f & DestAddr->v[1]; 
....................       Cache.MACAddr.v[4] = DestAddr->v[2]; 
....................       Cache.MACAddr.v[5] = DestAddr->v[3]; 
....................     
....................       Cache.IPAddr.Val = DestAddr->Val; 
....................     
....................       return TRUE; 
....................    } 
.................... #endif 
.................... #endif 
....................  
....................     packet.Operation = op_req; 
....................    packet.TargetMACAddr.v[0]   = 0xff; 
....................    packet.TargetMACAddr.v[1]   = 0xff; 
....................    packet.TargetMACAddr.v[2]   = 0xff; 
....................    packet.TargetMACAddr.v[3]   = 0xff; 
....................    packet.TargetMACAddr.v[4]   = 0xff; 
....................    packet.TargetMACAddr.v[5]   = 0xff; 
....................  
....................     packet.TargetIPAddr.Val   = DestIPAddr; 
....................     packet.SenderIPAddr.Val = SrcIPAddr; 
....................  
....................     return ( ARPPut(&packet) ); 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static BOOL ARPPut(ARP_PACKET* packet) 
....................  
....................   Description: 
....................    Writes an ARP packet to the MAC. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    packet - A pointer to an ARP_PACKET structure with correct operation 
....................             and target preconfigured. 
....................  
....................   Return Values: 
....................      TRUE - The ARP packet was generated properly 
....................      FALSE - Not a possible return value 
....................   ***************************************************************************/ 
.................... static BOOL ARPPut(ARP_PACKET* packet) 
.................... { 
....................    while(!MACIsTxReady()); 
*
01FA0:  CALL   0E7E
01FA4:  MOVF   01,F
01FA6:  BZ    1FA0
....................    MACSetWritePtr(BASE_TX_ADDR); 
01FA8:  MOVLW  15
01FAA:  MOVLB  2
01FAC:  MOVWF  xAF
01FAE:  MOVLW  0B
01FB0:  MOVWF  xAE
01FB2:  MOVLB  0
01FB4:  CALL   077C
....................     
....................  
....................     packet->HardwareType  = HW_ETHERNET; 
01FB8:  MOVLB  1
01FBA:  MOVFF  199,FE9
01FBE:  MOVFF  19A,FEA
01FC2:  CLRF   FEC
01FC4:  MOVF   FED,F
01FC6:  MOVLW  01
01FC8:  MOVWF  FEF
....................     packet->Protocol      = ARP_IP; 
01FCA:  MOVLW  02
01FCC:  ADDWF  x99,W
01FCE:  MOVWF  FE9
01FD0:  MOVLW  00
01FD2:  ADDWFC x9A,W
01FD4:  MOVWF  FEA
01FD6:  MOVLW  08
01FD8:  MOVWF  FEC
01FDA:  MOVF   FED,F
01FDC:  CLRF   FEF
....................     packet->MACAddrLen    = sizeof(MAC_ADDR); 
01FDE:  MOVLW  04
01FE0:  ADDWF  x99,W
01FE2:  MOVWF  FE9
01FE4:  MOVLW  00
01FE6:  ADDWFC x9A,W
01FE8:  MOVWF  FEA
01FEA:  MOVLW  06
01FEC:  MOVWF  FEF
....................     packet->ProtocolLen   = sizeof(IP_ADDR); 
01FEE:  MOVLW  05
01FF0:  ADDWF  x99,W
01FF2:  MOVWF  FE9
01FF4:  MOVLW  00
01FF6:  ADDWFC x9A,W
01FF8:  MOVWF  FEA
01FFA:  MOVLW  04
01FFC:  MOVWF  FEF
.................... //    packet->SenderMACAddr = AppConfig.MyMACAddr;   // HI-TECH PICC-18 compiler can't handle this statement, use memcpy() as a workaround 
....................    memcpy(&packet->SenderMACAddr, (void*)&AppConfig.MyMACAddr, sizeof(packet->SenderMACAddr)); 
01FFE:  MOVLW  08
02000:  ADDWF  x99,W
02002:  MOVWF  01
02004:  MOVLW  00
02006:  ADDWFC x9A,W
02008:  MOVWF  03
0200A:  MOVFF  01,19B
0200E:  MOVWF  x9C
02010:  CLRF   x9E
02012:  MOVLW  57
02014:  MOVFF  03,FEA
02018:  MOVFF  01,FE9
0201C:  MOVFF  19E,FE2
02020:  MOVWF  FE1
02022:  MOVLW  06
02024:  MOVWF  01
02026:  MOVFF  FE6,FEE
0202A:  DECFSZ 01,F
0202C:  BRA    2026
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................     //packet->SenderIPAddr  = AppConfig.MyIPAddr; /* Removed for ZCLL, SenderIPAddr should be filled in */ 
.................... #else 
....................     packet->SenderIPAddr  = AppConfig.MyIPAddr; 
0202E:  MOVLW  0E
02030:  ADDWF  x99,W
02032:  MOVWF  FE9
02034:  MOVLW  00
02036:  ADDWFC x9A,W
02038:  MOVWF  FEA
0203A:  MOVFF  2A,FEF
0203E:  MOVFF  2B,FEC
02042:  MOVFF  2C,FEC
02046:  MOVFF  2D,FEC
.................... #endif 
....................  
....................     SwapARPPacket(packet); 
0204A:  MOVFF  19A,19C
0204E:  MOVFF  199,19B
02052:  MOVLB  0
02054:  RCALL  1EC6
....................  
....................     MACPutHeader(&packet->TargetMACAddr, MAC_ARP, sizeof(*packet)); 
02056:  MOVLW  12
02058:  MOVLB  1
0205A:  ADDWF  x99,W
0205C:  MOVWF  01
0205E:  MOVLW  00
02060:  ADDWFC x9A,W
02062:  MOVWF  03
02064:  MOVFF  01,19B
02068:  MOVWF  x9C
0206A:  MOVFF  FE8,2BD
0206E:  MOVFF  01,2BC
02072:  MOVLW  06
02074:  MOVLB  2
02076:  MOVWF  xBE
02078:  CLRF   xC0
0207A:  MOVLW  1C
0207C:  MOVWF  xBF
0207E:  MOVLB  0
02080:  CALL   1508
....................     MACPutArray((BYTE*)packet, sizeof(*packet)); 
02084:  MOVFF  19A,2C4
02088:  MOVFF  199,2C3
0208C:  MOVLB  2
0208E:  CLRF   xC6
02090:  MOVLW  1C
02092:  MOVWF  xC5
02094:  MOVLB  0
02096:  CALL   079A
....................     MACFlush(); 
0209A:  CALL   0E5A
....................     
....................    return TRUE; 
0209E:  MOVLW  01
020A0:  MOVWF  01
020A2:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ARPInit(void) 
....................  
....................   Summary: 
....................    Initializes the ARP module. 
....................     
....................   Description: 
....................      Initializes the ARP module.  Call this function once at boot to  
....................      invalidate the cached lookup. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................      None 
....................    
....................   Remarks: 
....................      This function is only required when the stack is a client, and therefore 
....................      is only enabled when STACK_CLIENT_MODE is enabled. 
....................   ***************************************************************************/ 
.................... #ifdef STACK_CLIENT_MODE 
.................... void ARPInit(void) 
.................... { 
....................     Cache.MACAddr.v[0] = 0xff; 
*
006A8:  SETF   x89
....................     Cache.MACAddr.v[1] = 0xff; 
006AA:  SETF   x8A
....................     Cache.MACAddr.v[2] = 0xff; 
006AC:  SETF   x8B
....................     Cache.MACAddr.v[3] = 0xff; 
006AE:  SETF   x8C
....................     Cache.MACAddr.v[4] = 0xff; 
006B0:  SETF   x8D
....................     Cache.MACAddr.v[5] = 0xff; 
006B2:  SETF   x8E
....................  
....................    Cache.IPAddr.Val = 0xfffffffful; 
006B4:  SETF   x88
006B6:  SETF   x87
006B8:  SETF   x86
006BA:  SETF   x85
006BC:  GOTO   0DF6 (RETURN)
.................... } 
.................... #endif 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL ARPProcess(void) 
....................  
....................   Summary: 
....................    Processes an incoming ARP packet. 
....................     
....................   Description: 
....................      Retrieves an ARP packet from the MAC buffer and determines if it is a 
....................      response to our request (in which case the ARP is resolved) or if it 
....................      is a request requiring our response (in which case we transmit one.) 
....................  
....................   Precondition: 
....................    ARP packet is ready in the MAC buffer. 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Return Values: 
....................      TRUE - All processing of this ARP packet is complete.  Do not call  
....................            again until a new ARP packet is waiting in the RX buffer. 
....................      FALSE - This function must be called again.  More time is needed to  
....................            send an ARP response. 
....................   ***************************************************************************/ 
.................... BOOL ARPProcess(void) 
.................... { 
....................    ARP_PACKET packet; 
....................    static NODE_INFO Target; 
....................     #if defined(STACK_USE_AUTO_IP) 
....................         BYTE i; 
....................     #endif 
....................    static enum 
....................    { 
....................        SM_ARP_IDLE = 0, 
....................        SM_ARP_REPLY 
....................    } smARP = SM_ARP_IDLE; 
....................  
....................     switch(smARP) 
*
02C18:  MOVLW  00
02C1A:  BTFSC  x68.1
02C1C:  MOVLW  01
02C1E:  XORLW  00
02C20:  BZ    2C2A
02C22:  XORLW  01
02C24:  BTFSC  FD8.2
02C26:  BRA    2D0A
02C28:  BRA    2D5A
....................     { 
....................        case SM_ARP_IDLE: 
....................          // Obtain the incoming ARP packet 
....................           MACGetArray((BYTE*)&packet, sizeof(packet));       
02C2A:  MOVLW  01
02C2C:  MOVLB  1
02C2E:  MOVWF  x93
02C30:  MOVLW  76
02C32:  MOVWF  x92
02C34:  MOVFF  193,2C0
02C38:  MOVFF  FE8,2BF
02C3C:  MOVLB  2
02C3E:  CLRF   xC2
02C40:  MOVLW  1C
02C42:  MOVWF  xC1
02C44:  MOVLB  0
02C46:  CALL   07EA
....................           MACDiscardRx(); 
02C4A:  RCALL  2AC4
....................           SwapARPPacket(&packet); 
02C4C:  MOVLW  01
02C4E:  MOVLB  1
02C50:  MOVWF  x9C
02C52:  MOVLW  76
02C54:  MOVWF  x9B
02C56:  MOVLB  0
02C58:  CALL   1EC6
....................        
....................          // Validate the ARP packet 
....................           if ( packet.HardwareType != HW_ETHERNET     || 
....................                packet.MACAddrLen != sizeof(MAC_ADDR)  || 
....................                packet.ProtocolLen != sizeof(IP_ADDR) ) 
02C5C:  MOVLB  1
02C5E:  DECFSZ x76,W
02C60:  BRA    2C72
02C62:  MOVF   x77,F
02C64:  BNZ   2C72
02C66:  MOVF   x7A,W
02C68:  SUBLW  06
02C6A:  BNZ   2C72
02C6C:  MOVF   x7B,W
02C6E:  SUBLW  04
02C70:  BZ    2C78
....................           { 
....................                return TRUE; 
02C72:  MOVLW  01
02C74:  MOVWF  01
02C76:  BRA    2D60
....................           } 
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................          ARPProcessRxPkt(&packet); 
.................... #endif 
....................  
.................... #ifdef STACK_USE_AUTO_IP 
....................             if (packet.SenderIPAddr.Val == AppConfig.MyIPAddr.Val) 
....................             { 
....................                 AutoIPConflict(0); 
....................                 return TRUE;                 
....................             } 
.................... #endif 
.................... #ifdef STACK_USE_CCS_GRATUITOUS_ARP 
.................... GratArpReset(); 
.................... #endif 
....................          // Handle incoming ARP responses 
.................... #ifdef STACK_CLIENT_MODE 
....................          if(packet.Operation == ARP_OPERATION_RESP) 
02C78:  MOVF   x7C,W
02C7A:  SUBLW  02
02C7C:  BNZ   2CB2
02C7E:  MOVF   x7D,F
02C80:  BNZ   2CB2
....................          { 
.................... /*                #if defined(STACK_USE_AUTO_IP) 
....................                 for (i = 0; i < NETWORK_INTERFACES; i++) 
....................                     if (AutoIPConfigIsInProgress(i)) 
....................                         AutoIPConflict(i); 
....................                 #endif*/ 
....................             Cache.MACAddr = packet.SenderMACAddr; 
02C82:  CLRF   FEA
02C84:  MOVLW  89
02C86:  MOVWF  FE9
02C88:  MOVLW  01
02C8A:  MOVWF  FE2
02C8C:  MOVLW  7E
02C8E:  MOVWF  FE1
02C90:  MOVLW  06
02C92:  MOVWF  01
02C94:  MOVFF  FE6,FEE
02C98:  DECFSZ 01,F
02C9A:  BRA    2C94
....................             Cache.IPAddr = packet.SenderIPAddr; 
02C9C:  MOVFF  187,88
02CA0:  MOVFF  186,87
02CA4:  MOVFF  185,86
02CA8:  MOVFF  184,85
....................             return TRUE; 
02CAC:  MOVLW  01
02CAE:  MOVWF  01
02CB0:  BRA    2D60
....................          } 
.................... #endif 
....................  
....................          // Handle incoming ARP requests for our MAC address 
....................          if(packet.Operation == ARP_OPERATION_REQ) 
02CB2:  DECFSZ x7C,W
02CB4:  BRA    2D08
02CB6:  MOVF   x7D,F
02CB8:  BNZ   2D08
....................          { 
....................             if(packet.TargetIPAddr.Val != AppConfig.MyIPAddr.Val) 
02CBA:  MOVF   2A,W
02CBC:  SUBWF  x8E,W
02CBE:  BNZ   2CD2
02CC0:  MOVF   2B,W
02CC2:  SUBWF  x8F,W
02CC4:  BNZ   2CD2
02CC6:  MOVF   2C,W
02CC8:  SUBWF  x90,W
02CCA:  BNZ   2CD2
02CCC:  MOVF   2D,W
02CCE:  SUBWF  x91,W
02CD0:  BZ    2CD8
....................             { 
....................                return TRUE; 
02CD2:  MOVLW  01
02CD4:  MOVWF  01
02CD6:  BRA    2D60
....................             } 
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................                                /* Fix for Loop-Back suppression: 
....................                                 * For ZCLL-Claim packets, host should not respond. 
....................                                 * Check Sender's MAC-address with own MAC-address and  
....................                                 * if it is matched, response will not be sent back. This 
....................                                 * was leading to flooding of ARP-answeres */ 
....................                                 if(!memcmp (&packet.SenderMACAddr, &AppConfig.MyMACAddr, 6)) 
....................                                 { 
....................                                      putsUART("Loopback answer suppressed \r\n"); 
....................                                      return TRUE; 
....................                                 } 
.................... #endif 
....................                 #if defined(STACK_USE_AUTO_IP) 
....................                 for (i = 0; i < NETWORK_INTERFACES; i++) 
....................                     if (AutoIPConfigIsInProgress(i)) 
....................                     { 
....................                         AutoIPConflict(i); 
....................                         return TRUE; 
....................                     }              
....................                 #endif 
....................             Target.IPAddr = packet.SenderIPAddr; 
02CD8:  MOVFF  187,92
02CDC:  MOVFF  186,91
02CE0:  MOVFF  185,90
02CE4:  MOVFF  184,8F
....................             Target.MACAddr = packet.SenderMACAddr; 
02CE8:  CLRF   FEA
02CEA:  MOVLW  93
02CEC:  MOVWF  FE9
02CEE:  MOVLW  01
02CF0:  MOVWF  FE2
02CF2:  MOVLW  7E
02CF4:  MOVWF  FE1
02CF6:  MOVLW  06
02CF8:  MOVWF  01
02CFA:  MOVFF  FE6,FEE
02CFE:  DECFSZ 01,F
02D00:  BRA    2CFA
....................  
....................             smARP = SM_ARP_REPLY; 
02D02:  MOVLB  0
02D04:  BSF    x68.1
02D06:  MOVLB  1
02D08:  MOVLB  0
....................          } 
....................          // Do not break.  If we get down here, we need to send a reply.    
....................  
....................        case SM_ARP_REPLY: 
....................            packet.Operation      = ARP_OPERATION_RESP; 
02D0A:  MOVLB  1
02D0C:  CLRF   x7D
02D0E:  MOVLW  02
02D10:  MOVWF  x7C
....................             #if defined(STACK_USE_AUTO_IP) 
....................             if (AutoIPIsConfigured(0)) 
....................             { 
....................                 packet.TargetMACAddr.v[0] = 0xFF; 
....................                 packet.TargetMACAddr.v[1] = 0xFF; 
....................                 packet.TargetMACAddr.v[2] = 0xFF; 
....................                 packet.TargetMACAddr.v[3] = 0xFF; 
....................                 packet.TargetMACAddr.v[4] = 0xFF; 
....................                 packet.TargetMACAddr.v[5] = 0xFF; 
....................             } 
....................             else 
....................             #endif 
....................                packet.TargetMACAddr   = Target.MACAddr; 
02D12:  MOVLW  01
02D14:  MOVWF  FEA
02D16:  MOVLW  88
02D18:  MOVWF  FE9
02D1A:  CLRF   FE2
02D1C:  MOVLW  93
02D1E:  MOVWF  FE1
02D20:  MOVLW  06
02D22:  MOVWF  01
02D24:  MOVFF  FE6,FEE
02D28:  DECFSZ 01,F
02D2A:  BRA    2D24
....................            packet.TargetIPAddr      = Target.IPAddr; 
02D2C:  MOVFF  92,191
02D30:  MOVFF  91,190
02D34:  MOVFF  90,18F
02D38:  MOVFF  8F,18E
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................             packet.SenderIPAddr      = AppConfig.MyIPAddr; 
.................... #endif 
....................  
....................          // Send an ARP response to a previously received request 
....................          if(!ARPPut(&packet)) 
02D3C:  MOVLW  01
02D3E:  MOVWF  x9A
02D40:  MOVLW  76
02D42:  MOVWF  x99
02D44:  MOVLB  0
02D46:  CALL   1FA0
02D4A:  MOVF   01,F
02D4C:  BNZ   2D58
....................          { 
....................               return FALSE; 
02D4E:  MOVLW  00
02D50:  MOVWF  01
02D52:  MOVLB  1
02D54:  BRA    2D60
02D56:  MOVLB  0
....................          } 
....................  
....................          // Begin listening for ARP requests again 
....................          smARP = SM_ARP_IDLE; 
02D58:  BCF    x68.1
....................            break; 
....................    } 
....................  
....................     return TRUE; 
02D5A:  MOVLW  01
02D5C:  MOVWF  01
02D5E:  MOVLB  1
02D60:  MOVLB  0
02D62:  GOTO   4B2C (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ARPResolve(IP_ADDR* IPAddr) 
....................  
....................   Summary: 
....................    Transmits an ARP request to resolve an IP address. 
....................     
....................   Description: 
....................      This function transmits and ARP request to determine the hardware 
....................      address of a given IP address. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    IPAddr - The IP address to be resolved.  The address must be specified  
....................           in network byte order (big endian). 
....................  
....................   Returns: 
....................      None 
....................  
....................   Remarks: 
....................      This function is only required when the stack is a client, and therefore 
....................      is only enabled when STACK_CLIENT_MODE is enabled. 
....................  
....................    To retrieve the ARP query result, call the ARPIsResolved() function. 
....................   ***************************************************************************/ 
.................... #ifdef STACK_CLIENT_MODE 
.................... void ARPResolve(IP_ADDR* IPAddr) 
.................... { 
....................     ARP_PACKET packet; 
....................  
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... #define KS_ARP_IP_MULTICAST_HACK y 
.................... #ifdef KS_ARP_IP_MULTICAST_HACK 
....................     if ((IPAddr->v[0] >= 224) &&(IPAddr->v[0] <= 239)) 
....................     { 
....................       // "Resolve" the IP to MAC address mapping for 
....................       // IP multicast address range from 224.0.0.0 to 239.255.255.255 
....................  
....................       Cache.MACAddr.v[0] = 0x01; 
....................       Cache.MACAddr.v[1] = 0x00; 
....................       Cache.MACAddr.v[2] = 0x5E; 
....................       Cache.MACAddr.v[3] = 0x7f & IPAddr->v[1]; 
....................       Cache.MACAddr.v[4] = IPAddr->v[2]; 
....................       Cache.MACAddr.v[5] = IPAddr->v[3]; 
....................  
....................       Cache.IPAddr.Val = IPAddr->Val; 
....................  
....................       return; 
....................    } 
.................... #endif 
.................... #endif 
....................  
....................    packet.Operation            = ARP_OPERATION_REQ; 
*
020A4:  MOVLB  1
020A6:  CLRF   x84
020A8:  MOVLW  01
020AA:  MOVWF  x83
....................    packet.TargetMACAddr.v[0]   = 0xff; 
020AC:  SETF   x8F
....................    packet.TargetMACAddr.v[1]   = 0xff; 
020AE:  SETF   x90
....................    packet.TargetMACAddr.v[2]   = 0xff; 
020B0:  SETF   x91
....................    packet.TargetMACAddr.v[3]   = 0xff; 
020B2:  SETF   x92
....................    packet.TargetMACAddr.v[4]   = 0xff; 
020B4:  SETF   x93
....................    packet.TargetMACAddr.v[5]   = 0xff; 
020B6:  SETF   x94
....................  
....................  
....................     // ARP query either the IP address directly (on our subnet), or do an ARP query for our Gateway if off of our subnet 
....................    packet.TargetIPAddr         = ((AppConfig.MyIPAddr.Val ^ IPAddr->Val) & AppConfig.MyMask.Val) ? AppConfig.MyGateway : *IPAddr; 
020B8:  MOVFF  17B,FE9
020BC:  MOVFF  17C,FEA
020C0:  MOVFF  FEF,00
020C4:  MOVFF  FEC,01
020C8:  MOVFF  FEC,02
020CC:  MOVFF  FEC,03
020D0:  MOVF   00,W
020D2:  XORWF  2A,W
020D4:  MOVWF  x99
020D6:  MOVF   01,W
020D8:  XORWF  2B,W
020DA:  MOVWF  x9A
020DC:  MOVF   02,W
020DE:  XORWF  2C,W
020E0:  MOVWF  x9B
020E2:  MOVF   03,W
020E4:  XORWF  2D,W
020E6:  MOVWF  x9C
020E8:  MOVF   x99,W
020EA:  ANDWF  2E,W
020EC:  MOVWF  00
020EE:  MOVF   x9A,W
020F0:  ANDWF  2F,W
020F2:  MOVWF  01
020F4:  MOVF   x9B,W
020F6:  ANDWF  30,W
020F8:  MOVWF  02
020FA:  MOVF   x9C,W
020FC:  ANDWF  31,W
020FE:  MOVWF  03
02100:  MOVF   00,F
02102:  BNZ   2110
02104:  MOVF   01,F
02106:  BNZ   2110
02108:  MOVF   02,F
0210A:  BNZ   2110
0210C:  MOVF   03,F
0210E:  BZ    2122
02110:  MOVFF  32,00
02114:  MOVFF  33,01
02118:  MOVFF  34,02
0211C:  MOVFF  35,03
02120:  BRA    213A
02122:  MOVFF  17B,FE9
02126:  MOVFF  17C,FEA
0212A:  MOVFF  FEF,00
0212E:  MOVFF  FEC,01
02132:  MOVFF  FEC,02
02136:  MOVFF  FEC,03
0213A:  MOVFF  00,195
0213E:  MOVFF  01,196
02142:  MOVFF  02,197
02146:  MOVFF  03,198
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................    packet.SenderIPAddr         = AppConfig.MyIPAddr; 
.................... #endif 
....................  
....................     ARPPut(&packet); 
0214A:  MOVLW  01
0214C:  MOVWF  x9A
0214E:  MOVLW  7D
02150:  MOVWF  x99
02152:  MOVLB  0
02154:  RCALL  1FA0
02156:  GOTO   2738 (RETURN)
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL ARPIsResolved(IP_ADDR* IPAddr, MAC_ADDR* MACAddr) 
....................  
....................   Summary: 
....................    Determines if an ARP request has been resolved yet. 
....................     
....................   Description: 
....................      This function checks if an ARP request has been resolved yet, and if 
....................      so, stores the resolved MAC address in the pointer provided. 
....................  
....................   Precondition: 
....................    ARP packet is ready in the MAC buffer. 
....................  
....................   Parameters: 
....................    IPAddr - The IP address to be resolved.  This must match the IP address  
....................           provided to the ARPResolve() function call. 
....................    MACAddr - A buffer to store the corresponding MAC address retrieved from  
....................           the ARP query. 
....................  
....................   Return Values: 
....................      TRUE - The IP address has been resolved and MACAddr MAC address field 
....................          indicates the response. 
....................      FALSE -   The IP address is not yet resolved.  Try calling ARPIsResolved()  
....................          again at a later time.  If you don't get a response after a  
....................          application specific timeout period, you may want to call  
....................          ARPResolve() again to transmit another ARP query (in case if the  
....................          original query or response was lost on the network).  If you never  
....................          receive an ARP response, this may indicate that the IP address  
....................          isn't in use. 
....................  
....................   Remarks: 
....................      This function is only required when the stack is a client, and therefore 
....................      is only enabled when STACK_CLIENT_MODE is enabled. 
....................   ***************************************************************************/ 
.................... #ifdef STACK_CLIENT_MODE 
.................... BOOL ARPIsResolved(IP_ADDR* IPAddr, MAC_ADDR* MACAddr) 
.................... { 
....................     if((Cache.IPAddr.Val == IPAddr->Val) ||  
....................      ((Cache.IPAddr.Val == AppConfig.MyGateway.Val) && ((AppConfig.MyIPAddr.Val ^ IPAddr->Val) & AppConfig.MyMask.Val))) 
0215A:  MOVLB  1
0215C:  MOVFF  17B,FE9
02160:  MOVFF  17C,FEA
02164:  MOVFF  FEF,00
02168:  MOVFF  FEC,01
0216C:  MOVFF  FEC,02
02170:  MOVFF  FEC,03
02174:  MOVF   00,W
02176:  MOVLB  0
02178:  SUBWF  x85,W
0217A:  BNZ   218E
0217C:  MOVF   01,W
0217E:  SUBWF  x86,W
02180:  BNZ   218E
02182:  MOVF   02,W
02184:  SUBWF  x87,W
02186:  BNZ   218E
02188:  MOVF   03,W
0218A:  SUBWF  x88,W
0218C:  BZ    221A
0218E:  MOVF   32,W
02190:  SUBWF  x85,W
02192:  BNZ   2242
02194:  MOVF   33,W
02196:  SUBWF  x86,W
02198:  BNZ   2242
0219A:  MOVF   34,W
0219C:  SUBWF  x87,W
0219E:  BNZ   2242
021A0:  MOVF   35,W
021A2:  SUBWF  x88,W
021A4:  BNZ   2242
021A6:  MOVLB  1
021A8:  MOVFF  17B,FE9
021AC:  MOVFF  17C,FEA
021B0:  MOVFF  FEF,00
021B4:  MOVFF  FEC,01
021B8:  MOVFF  FEC,02
021BC:  MOVFF  FEC,03
021C0:  MOVF   00,W
021C2:  XORWF  2A,W
021C4:  MOVWF  x7F
021C6:  MOVF   01,W
021C8:  XORWF  2B,W
021CA:  MOVWF  x80
021CC:  MOVF   02,W
021CE:  XORWF  2C,W
021D0:  MOVWF  x81
021D2:  MOVF   03,W
021D4:  XORWF  2D,W
021D6:  MOVWF  x82
021D8:  MOVF   x7F,W
021DA:  ANDWF  2E,W
021DC:  MOVWF  00
021DE:  MOVF   x80,W
021E0:  ANDWF  2F,W
021E2:  MOVWF  01
021E4:  MOVF   x81,W
021E6:  ANDWF  30,W
021E8:  MOVWF  02
021EA:  MOVF   x82,W
021EC:  ANDWF  31,W
021EE:  MOVWF  03
021F0:  MOVF   00,F
021F2:  BTFSC  FD8.2
021F4:  BRA    21FA
021F6:  MOVLB  0
021F8:  BRA    221A
021FA:  MOVF   01,F
021FC:  BTFSC  FD8.2
021FE:  BRA    2204
02200:  MOVLB  0
02202:  BRA    221A
02204:  MOVF   02,F
02206:  BTFSC  FD8.2
02208:  BRA    220E
0220A:  MOVLB  0
0220C:  BRA    221A
0220E:  MOVF   03,F
02210:  BTFSS  FD8.2
02212:  BRA    2218
02214:  MOVLB  0
02216:  BRA    2242
02218:  MOVLB  0
....................     { 
....................         *MACAddr = Cache.MACAddr; 
0221A:  MOVFF  17E,03
0221E:  MOVLB  1
02220:  MOVFF  17D,FE9
02224:  MOVFF  17E,FEA
02228:  CLRF   FE2
0222A:  MOVLW  89
0222C:  MOVWF  FE1
0222E:  MOVLW  06
02230:  MOVWF  01
02232:  MOVFF  FE6,FEE
02236:  DECFSZ 01,F
02238:  BRA    2232
....................         return TRUE; 
0223A:  MOVLW  01
0223C:  MOVWF  01
0223E:  BRA    2248
02240:  MOVLB  0
....................     } 
....................     return FALSE; 
02242:  MOVLW  00
02244:  MOVWF  01
02246:  MOVLB  1
02248:  MOVLB  0
0224A:  GOTO   2752 (RETURN)
.................... } 
.................... #endif 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void SwapARPPacket(ARP_PACKET* p) 
....................  
....................   Description: 
....................      Swaps endian-ness of header information in an ARP packet. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    p - The ARP packet to be swapped 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... void SwapARPPacket(ARP_PACKET* p) 
.................... { 
....................     p->HardwareType     = swaps(p->HardwareType); 
*
01EC6:  MOVLB  1
01EC8:  MOVFF  19B,01
01ECC:  MOVFF  19C,03
01ED0:  MOVFF  19B,19D
01ED4:  MOVFF  19C,19E
01ED8:  MOVFF  19B,FE9
01EDC:  MOVFF  19C,FEA
01EE0:  MOVFF  FEC,1A0
01EE4:  MOVF   FED,F
01EE6:  MOVFF  FEF,19F
01EEA:  MOVFF  1A0,2BF
01EEE:  MOVFF  19F,2BE
01EF2:  MOVLB  0
01EF4:  CALL   0F92
01EF8:  MOVFF  19E,FEA
01EFC:  MOVFF  19D,FE9
01F00:  MOVFF  02,FEC
01F04:  MOVF   FED,F
01F06:  MOVFF  01,FEF
....................     p->Protocol         = swaps(p->Protocol); 
01F0A:  MOVLW  02
01F0C:  MOVLB  1
01F0E:  ADDWF  x9B,W
01F10:  MOVWF  01
01F12:  MOVLW  00
01F14:  ADDWFC x9C,W
01F16:  MOVWF  03
01F18:  MOVFF  01,19D
01F1C:  MOVWF  x9E
01F1E:  MOVLW  02
01F20:  ADDWF  x9B,W
01F22:  MOVWF  FE9
01F24:  MOVLW  00
01F26:  ADDWFC x9C,W
01F28:  MOVWF  FEA
01F2A:  MOVFF  FEC,1A0
01F2E:  MOVF   FED,F
01F30:  MOVFF  FEF,19F
01F34:  MOVFF  1A0,2BF
01F38:  MOVFF  19F,2BE
01F3C:  MOVLB  0
01F3E:  CALL   0F92
01F42:  MOVFF  19E,FEA
01F46:  MOVFF  19D,FE9
01F4A:  MOVFF  02,FEC
01F4E:  MOVF   FED,F
01F50:  MOVFF  01,FEF
....................     p->Operation        = swaps(p->Operation); 
01F54:  MOVLW  06
01F56:  MOVLB  1
01F58:  ADDWF  x9B,W
01F5A:  MOVWF  01
01F5C:  MOVLW  00
01F5E:  ADDWFC x9C,W
01F60:  MOVWF  03
01F62:  MOVFF  01,19D
01F66:  MOVWF  x9E
01F68:  MOVLW  06
01F6A:  ADDWF  x9B,W
01F6C:  MOVWF  FE9
01F6E:  MOVLW  00
01F70:  ADDWFC x9C,W
01F72:  MOVWF  FEA
01F74:  MOVFF  FEC,1A0
01F78:  MOVF   FED,F
01F7A:  MOVFF  FEF,19F
01F7E:  MOVFF  1A0,2BF
01F82:  MOVFF  19F,2BE
01F86:  MOVLB  0
01F88:  CALL   0F92
01F8C:  MOVFF  19E,FEA
01F90:  MOVFF  19D,FE9
01F94:  MOVFF  02,FEC
01F98:  MOVF   FED,F
01F9A:  MOVFF  01,FEF
01F9E:  RETURN 0
.................... } 
....................  
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) 
....................    #include "ICMP.c" 
.................... /********************************************************************* 
....................  * 
....................  *  Internet Control Message Protocol (ICMP) Server 
....................  *  Module for Microchip TCP/IP Stack 
....................  *   -Provides "ping" diagnostics 
....................  *	 -Reference: RFC 792 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.c 
....................  * Dependencies:    IP, ARP 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    	Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		03/16/07	Original 
....................  ********************************************************************/ 
.................... #define __ICMP_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................  
.................... #if defined(STACK_USE_ICMP_CLIENT) 
....................  
.................... // ICMP Timeout Value 
.................... #define ICMP_TIMEOUT	(4ul*TICK_SECOND) 
....................  
.................... // ICMP Packet Structure 
.................... typedef struct 
.................... { 
.................... 	BYTE vType; 
.................... 	BYTE vCode; 
.................... 	WORD wChecksum; 
.................... 	WORD wIdentifier; 
.................... 	WORD wSequenceNumber; 
.................... 	WORD wData; 
.................... } ICMP_PACKET; 
....................  
.................... // ICMP Sequence Number 
.................... static WORD wICMPSequenceNumber; 
.................... // ICMP tick timer variable 
.................... static DWORD ICMPTimer; 
....................  
.................... // ICMP Flag structure 
.................... static struct 
.................... { 
.................... 	unsigned char bICMPInUse:1;         // Indicates that the ICMP Client is in use 
.................... 	unsigned char bReplyValid:1;        // Indicates that a correct Ping response to one of our pings was received 
.................... 	unsigned char bRemoteHostIsROM:1;   // Indicates that a remote host name was passed as a ROM pointer argument 
.................... } ICMPFlags = {0x00}; 
....................  
.................... // ICMP Static Variables 
.................... static union 
.................... { 
.................... 	union 
.................... 	{ 
.................... 		ROM BYTE *szROM; 
.................... 		BYTE *szRAM; 
.................... 	} RemoteHost; 
.................... 	NODE_INFO ICMPRemote; 
.................... } StaticVars; 
....................  
.................... // ICMP State Machine Enumeration 
.................... static enum 
.................... { 
.................... 	SM_IDLE = 0, 
.................... 	SM_DNS_SEND_QUERY, 
.................... 	SM_DNS_GET_RESPONSE, 
.................... 	SM_ARP_SEND_QUERY, 
.................... 	SM_ARP_GET_RESPONSE, 
.................... 	SM_ICMP_SEND_ECHO_REQUEST, 
.................... 	SM_ICMP_GET_ECHO_RESPONSE 
.................... } ICMPState; 
....................  
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPProcess(void) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           *remote: Pointer to a NODE_INFO structure of the  
....................  *					ping requester 
....................  *					len: Count of how many bytes the ping header and  
....................  *					payload are in this IP packet 
....................  * 
....................  * Output:          Generates an echo reply, if requested 
....................  *					Validates and sets ICMPFlags.bReplyValid if a  
....................  *					correct ping response to one of ours is received. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPProcess(NODE_INFO *remote, WORD len) 
.................... { 
.................... 	DWORD_VAL dwVal; 
....................  
....................     // Obtain the ICMP header Type, Code, and Checksum fields 
....................     MACGetArray((BYTE*)&dwVal, sizeof(dwVal)); 
*
02F1E:  MOVLW  01
02F20:  MOVLB  1
02F22:  MOVWF  x7F
02F24:  MOVLW  7A
02F26:  MOVWF  x7E
02F28:  MOVFF  17F,2C0
02F2C:  MOVFF  FE8,2BF
02F30:  MOVLB  2
02F32:  CLRF   xC2
02F34:  MOVLW  04
02F36:  MOVWF  xC1
02F38:  MOVLB  0
02F3A:  CALL   07EA
.................... 	 
.................... 	// See if this is an ICMP echo (ping) request 
.................... 	if(dwVal.w[0] == 0x0008u) 
02F3E:  MOVLB  1
02F40:  MOVF   x7A,W
02F42:  SUBLW  08
02F44:  BNZ   3002
02F46:  MOVF   x7B,F
02F48:  BNZ   3002
.................... 	{ 
.................... 		// Validate the checksum using the Microchip MAC's DMA module 
.................... 		// The checksum data includes the precomputed checksum in the  
.................... 		// header, so a valid packet will always have a checksum of  
.................... 		// 0x0000 if the packet is not disturbed. 
.................... 		if(MACCalcRxChecksum(0+sizeof(IP_HEADER), len)) 
02F4A:  CLRF   x95
02F4C:  MOVLW  14
02F4E:  MOVWF  x94
02F50:  MOVFF  179,197
02F54:  MOVFF  178,196
02F58:  MOVLB  0
02F5A:  RCALL  2D66
02F5C:  MOVF   01,W
02F5E:  IORWF  02,W
02F60:  BZ    2F64
.................... 			return; 
02F62:  BRA    3000
.................... 	 
.................... 		// Calculate new Type, Code, and Checksum values 
.................... 		dwVal.v[0] = 0x00;	// Type: 0 (ICMP echo/ping reply) 
02F64:  MOVLB  1
02F66:  CLRF   x7A
.................... 		dwVal.v[2] += 8;	// Subtract 0x0800 from the checksum 
02F68:  MOVLW  08
02F6A:  ADDWF  x7C,F
.................... 		if(dwVal.v[2] < 8u) 
02F6C:  MOVF   x7C,W
02F6E:  SUBLW  07
02F70:  BNC   2F7A
.................... 		{ 
.................... 			dwVal.v[3]++; 
02F72:  INCF   x7D,F
.................... 			if(dwVal.v[3] == 0u) 
02F74:  MOVF   x7D,F
02F76:  BNZ   2F7A
.................... 				dwVal.v[2]++; 
02F78:  INCF   x7C,F
.................... 		} 
.................... 	 
.................... 	    // Wait for TX hardware to become available (finish transmitting  
.................... 	    // any previous packet) 
.................... 	    while(!IPIsTxReady()); 
02F7A:  MOVLB  0
02F7C:  CALL   0E7E
02F80:  MOVF   01,F
02F82:  BZ    2F7C
....................  
.................... 		// Position the write pointer for the next IPPutHeader operation 
.................... 		// NOTE: do not put this before the IPIsTxReady() call for WF compatbility 
.................... 	    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER)); 
02F84:  MOVLW  15
02F86:  MOVLB  2
02F88:  MOVWF  xAF
02F8A:  MOVLW  19
02F8C:  MOVWF  xAE
02F8E:  MOVLB  0
02F90:  CALL   077C
....................         	 
.................... 		// Create IP header in TX memory 
.................... 		IPPutHeader(remote, IP_PROT_ICMP, len); 
02F94:  MOVFF  177,2A0
02F98:  MOVFF  176,29F
02F9C:  MOVLW  01
02F9E:  MOVLB  2
02FA0:  MOVWF  xA1
02FA2:  MOVFF  179,2A3
02FA6:  MOVFF  178,2A2
02FAA:  MOVLB  0
02FAC:  CALL   1576
.................... 	 
.................... 		// Copy ICMP response into the TX memory 
.................... 		MACPutArray((BYTE*)&dwVal, sizeof(dwVal)); 
02FB0:  MOVLW  01
02FB2:  MOVLB  1
02FB4:  MOVWF  x7F
02FB6:  MOVLW  7A
02FB8:  MOVWF  x7E
02FBA:  MOVFF  17F,2C4
02FBE:  MOVFF  FE8,2C3
02FC2:  MOVLB  2
02FC4:  CLRF   xC6
02FC6:  MOVLW  04
02FC8:  MOVWF  xC5
02FCA:  MOVLB  0
02FCC:  CALL   079A
.................... 		MACMemCopyAsync(-1, -1, len-4); 
02FD0:  MOVLW  04
02FD2:  MOVLB  1
02FD4:  SUBWF  x78,W
02FD6:  MOVWF  x7E
02FD8:  MOVLW  00
02FDA:  SUBWFB x79,W
02FDC:  MOVWF  x7F
02FDE:  MOVLB  2
02FE0:  SETF   xAF
02FE2:  SETF   xAE
02FE4:  SETF   xB1
02FE6:  SETF   xB0
02FE8:  MOVWF  xB3
02FEA:  MOVFF  17E,2B2
02FEE:  MOVLB  0
02FF0:  CALL   084C
.................... 		while(!MACIsMemCopyDone()); 
02FF4:  CALL   098E
02FF8:  MOVF   01,F
02FFA:  BZ    2FF4
.................... 	 
.................... 		// Transmit the echo reply packet 
.................... 	    MACFlush(); 
02FFC:  CALL   0E5A
03000:  MOVLB  1
.................... 	} 
.................... #if defined(STACK_USE_ICMP_CLIENT) 
03002:  MOVLB  0
03004:  GOTO   4AFE (RETURN)
.................... 	else if(dwVal.w[0] == 0x0000u)	// See if this an ICMP Echo reply to our request 
.................... 	{ 
.................... 		// Get the sequence number and identifier fields 
.................... 		MACGetArray((BYTE*)&dwVal, sizeof(dwVal)); 
.................... 		 
.................... 		// See if the identifier matches the one we sent 
.................... 		if(dwVal.w[0] != 0xEFBE)	 
.................... 			return; 
.................... 	 
.................... 		if(dwVal.w[1] != wICMPSequenceNumber) 
.................... 			return; 
....................  
.................... 		// Validate the ICMP checksum field 
.................... 	    IPSetRxBuffer(0); 
.................... 		if(CalcIPBufferChecksum(sizeof(ICMP_PACKET)))	// Two bytes of payload were sent in the echo request 
.................... 			return; 
.................... 		 
.................... 		// Flag that we received the response and stop the timer ticking 
.................... 		ICMPFlags.bReplyValid = 1; 
.................... 		ICMPTimer = TickGet() - ICMPTimer; 
.................... 	} 
.................... #endif 
.................... } 
....................  
.................... #if defined(STACK_USE_ICMP_CLIENT) 
.................... /********************************************************************* 
....................  * Function:        void ICMPSendPing(DWORD dwRemoteIP) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() returned TRUE 
....................  * 
....................  * Input:           dwRemoteIP: IP Address to ping.  Must be stored  
....................  *								big endian.  Ex. 192.168.0.1 should be 
....................  *								passed as 0x0100A8C0. 
....................  * 
....................  * Output:          Begins the process of transmitting an ICMP echo  
....................  *					request.  This normally involves an ARP  
....................  *					resolution procedure first. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPSendPing(DWORD dwRemoteIP) 
.................... { 
.................... 	ICMPFlags.bReplyValid = 0; 
.................... 	ICMPTimer = TickGet(); 
.................... 	StaticVars.ICMPRemote.IPAddr.Val = dwRemoteIP; 
.................... 	ICMPState = SM_ARP_SEND_QUERY; 
.................... } 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... /********************************************************************* 
....................  * Function:        void ICMPSendPingToHost (BYTE * szRemoteHost) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() returned TRUE 
....................  * 
....................  * Input:           szRemoteHost: Host name to ping.  Must be stored  
....................  *								  in RAM if being called by PIC18. 
....................  *								  Ex. www.microchip.com 
....................  * 
....................  * Output:          Begins the process of transmitting an ICMP echo  
....................  *					request.  This normally involves an ARP  
....................  *					resolution procedure first. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPSendPingToHost(BYTE * szRemoteHost) 
.................... { 
.................... 	ICMPFlags.bReplyValid = 0; 
.................... 	ICMPTimer = TickGet(); 
.................... 	ICMPFlags.bRemoteHostIsROM = 0; 
.................... 	StaticVars.RemoteHost.szRAM = szRemoteHost; 
.................... 	ICMPState = SM_DNS_SEND_QUERY; 
.................... } 
....................  
.................... #if defined(__18CXX) 
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPSendPingToHostROM (ROM BYTE * szRemoteHost) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() returned TRUE 
....................  * 
....................  * Input:           szRemoteHost: Host name to ping.  Must be stored  
....................  *								  in ROM. Should only be called by PIC18. 
....................  *								  Ex. www.microchip.com 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Begins the process of transmitting an ICMP echo  
....................  *					request.  This normally involves an ARP  
....................  *					resolution procedure first. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPSendPingToHostROM(ROM BYTE * szRemoteHost) 
.................... { 
.................... 	ICMPFlags.bReplyValid = 0; 
.................... 	ICMPTimer = TickGet(); 
.................... 	ICMPFlags.bRemoteHostIsROM = 1; 
.................... 	StaticVars.RemoteHost.szROM = szRemoteHost; 
.................... 	ICMPState = SM_DNS_SEND_QUERY; 
.................... } 
....................  
.................... #endif 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        LONG ICMPGetReply(void) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() returned TRUE and ICMPSendPing()  
....................  *					was called 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          -3: Could not resolve hostname (DNS timeout or  
....................  *			    	    hostname invalid) 
....................  *					-2: No response received yet 
....................  *					-1: Operation timed out (longer than ICMP_TIMEOUT)  
....................  *						has elapsed. 
....................  *					>=0: Number of TICKs that elapsed between  
....................  *						 initial ICMP transmission and reception of  
....................  *						 a valid echo. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... LONG ICMPGetReply(void) 
.................... { 
.................... 	ICMP_PACKET ICMPPacket; 
....................  
.................... 	switch(ICMPState) 
.................... 	{ 
.................... #if defined(STACK_USE_DNS) 
.................... 		case SM_DNS_SEND_QUERY: 
.................... 			// Obtain DNS module ownership 
.................... 			if(!DNSBeginUsage()) 
.................... 				break; 
.................... 			 
.................... 			// Send DNS query 
.................... 			if(ICMPFlags.bRemoteHostIsROM) 
.................... 				DNSResolveROM(StaticVars.RemoteHost.szROM, DNS_TYPE_A); 
.................... 			else 
.................... 				DNSResolve(StaticVars.RemoteHost.szRAM, DNS_TYPE_A); 
.................... 			 
.................... 			ICMPState = SM_DNS_GET_RESPONSE; 
.................... 			break; 
.................... 				 
.................... 		case SM_DNS_GET_RESPONSE: 
.................... 			// See if DNS is done, and if so, get the remote IP address 
.................... 			if(!DNSIsResolved(&StaticVars.ICMPRemote.IPAddr)) 
.................... 				break; 
.................... 			 
.................... 			// Free the DNS module 
.................... 			DNSEndUsage(); 
.................... 			 
.................... 			// Return error code if the DNS query failed 
.................... 			if(StaticVars.ICMPRemote.IPAddr.Val == 0x00000000ul) 
.................... 			{ 
.................... 				ICMPState = SM_IDLE; 
.................... 				return -3; 
.................... 			} 
....................  
.................... 			ICMPState = SM_ARP_SEND_QUERY;	 
.................... 			// No break;	 
.................... #endif 
....................  
.................... 		case SM_ARP_SEND_QUERY: 
.................... 			ARPResolve(&StaticVars.ICMPRemote.IPAddr); 
.................... 			ICMPState = SM_ARP_GET_RESPONSE; 
.................... 			break; 
.................... 			 
.................... 		case SM_ARP_GET_RESPONSE: 
.................... 			// See if the ARP reponse was successfully received 
.................... 			if(!ARPIsResolved(&StaticVars.ICMPRemote.IPAddr, &StaticVars.ICMPRemote.MACAddr)) 
.................... 				break; 
.................... 			 
.................... 			ICMPState = SM_ICMP_SEND_ECHO_REQUEST; 
.................... 			// No break;  
.................... 		 
.................... 		case SM_ICMP_SEND_ECHO_REQUEST: 
.................... 		    if(!IPIsTxReady()) 
.................... 		    	break; 
....................  
.................... 			// Set up the ping packet 
.................... 			ICMPPacket.vType = 0x08;	// 0x08: Echo (ping) request 
.................... 			ICMPPacket.vCode = 0x00; 
.................... 			ICMPPacket.wChecksum = 0x0000; 
.................... 			ICMPPacket.wIdentifier = 0xEFBE; 
.................... 			wICMPSequenceNumber++;  
.................... 			ICMPPacket.wSequenceNumber = wICMPSequenceNumber; 
.................... 			ICMPPacket.wData = 0x2860; 
.................... 			ICMPPacket.wChecksum = CalcIPChecksum((BYTE*)&ICMPPacket, sizeof(ICMPPacket)); 
.................... 		 
.................... 			// Record the current time.  This will be used as a basis for  
.................... 			// finding the echo response time, which exludes the ARP and DNS  
.................... 			// steps 
.................... 			ICMPTimer = TickGet(); 
....................  
.................... 			// Position the write pointer for the next IPPutHeader operation 
.................... 		    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER)); 
.................... 		 
.................... 			// Create IP header in TX memory 
.................... 			IPPutHeader(&StaticVars.ICMPRemote, IP_PROT_ICMP, sizeof(ICMPPacket)); 
.................... 			MACPutArray((BYTE*)&ICMPPacket, sizeof(ICMPPacket)); 
.................... 			MACFlush(); 
....................  
.................... 			// Echo sent, advance state 
.................... 			ICMPState = SM_ICMP_GET_ECHO_RESPONSE; 
.................... 			break; 
....................  
.................... 		case SM_ICMP_GET_ECHO_RESPONSE: 
.................... 			// See if the echo was successfully received 
.................... 			if(ICMPFlags.bReplyValid) 
.................... 				return (LONG)ICMPTimer; 
.................... 		 
.................... 			break; 
.................... 		 
.................... 		// SM_IDLE or illegal/impossible state: 
.................... 		default: 
.................... 			return -1; 
.................... 	} 
....................  
.................... 	// See if the DNS/ARP/echo request timed out 
.................... 	if(TickGet() - ICMPTimer > ICMP_TIMEOUT) 
.................... 	{ 
.................... 		// Free DNS module if we have it in use 
.................... 		#if defined(STACK_USE_DNS) 
.................... 			if(ICMPState == SM_DNS_GET_RESPONSE) 
.................... 				DNSEndUsage(); 
.................... 		#endif 
.................... 		 
.................... 		// Stop ICMP echo test and return error to caller 
.................... 		ICMPState = SM_IDLE; 
.................... 		return -1; 
.................... 	} 
....................  
.................... 	// Still working.  No response to report yet. 
.................... 	return -2; 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPBeginUsage(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: You have successfully gained ownership of  
....................  *						  the ICMP client module and can now use the  
....................  *						  ICMPSendPing() and ICMPGetReply() functions. 
....................  *					FALSE: Some other application is using the ICMP  
....................  *						   client module.  Calling ICMPSendPing()  
....................  *						   will corrupt the other application's ping  
....................  *						   result. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Claims ownership of the ICMP module. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPBeginUsage(void) 
.................... { 
.................... 	if(ICMPFlags.bICMPInUse) 
.................... 		return FALSE; 
....................  
.................... 	ICMPFlags.bICMPInUse = TRUE; 
.................... 	return TRUE; 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPEndUsage(void) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() was called by you and it  
....................  *					returned TRUE. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Your ownership of the ICMP module is released.   
....................  *					You can no longer use ICMPSendPing(). 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Gives up ownership of the ICMP module. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPEndUsage(void) 
.................... { 
.................... 	ICMPFlags.bICMPInUse = FALSE; 
.................... } 
....................  
.................... #endif //#if defined(STACK_USE_ICMP_CLIENT) 
....................  
.................... #endif //#if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP) 
....................    #include "UDP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) 
....................    #include "DHCP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_SERVER) 
....................    #include "DHCPs.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS_SERVER) 
....................    #include "DNSs.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
....................    #include "TCP.c" 
.................... /********************************************************************* 
....................  * 
....................  *   Transmission Control Protocol (TCP) Communications Layer 
....................  *  Module for Microchip TCP/IP Stack 
....................  *    -Provides reliable, handshaked transport of application stream  
....................  *    oriented data with flow control 
....................  *    -Reference: RFC 793 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCP.c 
....................  * Dependencies:    IP, Tick, Ethernet/WiFi (ENC28J60.c, ETH97J60.c,  
....................  *               ENCX24J600.c, or WFMac.c), ARP (optional),  
....................  *               DNS (optional) 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date       Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01     Original        (Rev 1.0) 
....................  * Howard Schlunder      12/11/06   Changed almost everything to  
....................  *                           better meet RFC 793. 
....................  * Darren Rook          04/14/11 Changed TCP_SOCKET_COUNT to use TCP_CONFIGURATION. 
....................  ********************************************************************/ 
.................... #define __TCP_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_TCP) 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Configuration Parameters 
....................   ***************************************************************************/ 
....................  
.................... // Starting port for client sockets 
.................... #define LOCAL_PORT_START_NUMBER (1024u) 
.................... // End port for client sockets 
.................... #define LOCAL_PORT_END_NUMBER   (5000u) 
....................  
.................... // For debugging only.  Normal applications should never enable these 
.................... //#define DEBUG_GENERATE_TX_LOSS      62257 
.................... //#define DEBUG_GENERATE_RX_LOSS      64225 
....................  
.................... // A lot of pointer dereference code can be removed if you  
.................... // locally copy TCBStubs to an absolute memory location. 
.................... // If you define TCP_OPTIMIZE_FOR_SIZE, local caching will  
.................... // occur and will substantially decrease the entire TCP ROM  
.................... // footprint (up to 35%).  If you leave TCP_OPTIMIZE_FOR_SIZE  
.................... // undefined, the local caching will be disabled.  On PIC18  
.................... // products, this will improve TCP performance/throughput by  
.................... // approximately 15%. 
.................... #define TCP_OPTIMIZE_FOR_SIZE 
....................  
.................... // For smallest size and best throughput, TCP_OPTIMIZE_FOR_SIZE  
.................... // should always be enabled on PIC24/dsPIC products.  On PIC32  
.................... // products there is very little difference and depnds on compiler  
.................... // optimization level 
.................... #if defined(__C30__) && !defined(TCP_OPTIMIZE_FOR_SIZE) 
....................    #define TCP_OPTIMIZE_FOR_SIZE 
.................... #elif defined(__C32__) && defined(TCP_OPTIMIZE_FOR_SIZE) 
....................    #undef TCP_OPTIMIZE_FOR_SIZE 
.................... #endif 
....................  
.................... // TCP Maximum Segment Size for TX.  The TX maximum segment size is actually  
.................... // govered by the remote node's MSS option advirtised during connection  
.................... // establishment.  However, if the remote node specifies an unhandlably large  
.................... // MSS (ex: > Ethernet MTU), this define sets a hard limit so that we don't  
.................... // cause any TX buffer overflows.  If the remote node does not advirtise a MSS  
.................... // option, all TX segments are fixed at 536 bytes maximum. 
.................... #define TCP_MAX_SEG_SIZE_TX         (1460u) 
....................  
.................... // TCP Maximum Segment Size for RX.  This value is advirtised during connection  
.................... // establishment and the remote node should obey it.  This should be set to 536  
.................... // to avoid IP layer fragmentation from causing packet loss.  However, raising  
.................... // its value can enhance performance at the (small) risk of introducing  
.................... // incompatibility with certain special remote nodes (ex: ones connected via a  
.................... // slow dial up modem). 
.................... #define TCP_MAX_SEG_SIZE_RX         (536u) 
....................  
.................... // TCP Timeout and retransmit numbers 
.................... #define TCP_START_TIMEOUT_VAL      ((DWORD)TICK_SECOND*1)   // Timeout to retransmit unacked data 
.................... #define TCP_DELAYED_ACK_TIMEOUT      ((DWORD)TICK_SECOND/10)   // Timeout for delayed-acknowledgement algorithm 
.................... #define TCP_FIN_WAIT_2_TIMEOUT      ((DWORD)TICK_SECOND*5)   // Timeout for FIN WAIT 2 state 
.................... #define TCP_KEEP_ALIVE_TIMEOUT      ((DWORD)TICK_SECOND*10)   // Timeout for keep-alive messages when no traffic is sent 
.................... #define TCP_CLOSE_WAIT_TIMEOUT      ((DWORD)TICK_SECOND/5)   // Timeout for the CLOSE_WAIT state 
.................... #define TCP_MAX_RETRIES             (5u)               // Maximum number of retransmission attempts 
.................... #define TCP_MAX_UNACKED_KEEP_ALIVES   (6u)               // Maximum number of keep-alive messages that can be sent without receiving a response before automatically closing the connection 
.................... #define TCP_MAX_SYN_RETRIES         (2u)   // Smaller than all other retries to reduce SYN flood DoS duration 
....................  
.................... #define TCP_AUTO_TRANSMIT_TIMEOUT_VAL   (TICK_SECOND/25ull)   // Timeout before automatically transmitting unflushed data 
.................... #define TCP_WINDOW_UPDATE_TIMEOUT_VAL   (TICK_SECOND/5ull)   // Timeout before automatically transmitting a window update due to a TCPGet() or TCPGetArray() function call 
....................  
.................... #define TCP_SYN_QUEUE_MAX_ENTRIES   (3u)                // Number of TCP RX SYN packets to save if they cannot be serviced immediately 
.................... #define TCP_SYN_QUEUE_TIMEOUT      ((DWORD)TICK_SECOND*3)   // Timeout for when SYN queue entries are deleted if unserviceable 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    TCP Header Data Types 
....................   ***************************************************************************/ 
....................  
.................... #define FIN     (0x01)      // FIN Flag as defined in RFC 
.................... #define SYN     (0x02)      // SYN Flag as defined in RFC 
.................... #define RST     (0x04)      // Reset Flag as defined in RFC 
.................... #define PSH     (0x08)      // Push Flag as defined in RFC 
.................... #define ACK     (0x10)      // Acknowledge Flag as defined in RFC 
.................... #define URG     (0x20)      // Urgent Flag as defined in RFC 
....................  
.................... // TCP Header Data Structure 
.................... typedef struct 
.................... { 
....................    WORD    SourcePort;      // Local port number 
....................    WORD    DestPort;      // Remote port number 
....................    DWORD   SeqNumber;      // Local sequence number 
....................    DWORD   AckNumber;      // Acknowledging remote sequence number 
....................  
....................    struct 
....................    { 
....................       unsigned char Reserved3      : 4; 
....................       unsigned char Val            : 4; 
....................    } DataOffset;         // Data offset flags nibble 
....................  
....................    union 
....................    { 
....................       struct 
....................       { 
....................          unsigned char flagFIN    : 1; 
....................          unsigned char flagSYN    : 1; 
....................          unsigned char flagRST    : 1; 
....................          unsigned char flagPSH    : 1; 
....................          unsigned char flagACK    : 1; 
....................          unsigned char flagURG    : 1; 
....................          unsigned char Reserved2  : 2; 
....................       } bits; 
....................       BYTE byte; 
....................    } Flags;            // TCP Flags as defined in RFC 
....................  
....................    WORD    Window;         // Local free RX buffer window 
....................    WORD    Checksum;      // Data payload checksum 
....................    WORD    UrgentPointer;   // Urgent pointer 
.................... } TCP_HEADER; 
....................  
.................... #define TCP_OPTIONS_END_OF_LIST     (0x00u)      // End of List TCP Option Flag 
.................... #define TCP_OPTIONS_NO_OP           (0x01u)      // No Op TCP Option 
.................... #define TCP_OPTIONS_MAX_SEG_SIZE    (0x02u)      // Maximum segment size TCP flag 
.................... typedef struct 
.................... { 
....................    BYTE        Kind;                     // Type of option 
....................    BYTE        Length;                     // Length 
....................    WORD_VAL    MaxSegSize;                  // Maximum segment size 
.................... } TCP_OPTIONS;                           // TCP Options data structure                      
....................  
.................... // Structure containing all the important elements of an incomming  
.................... // SYN packet in order to establish a connection at a future time  
.................... // if all sockets on the listening port are already connected to  
.................... // someone 
.................... typedef struct  
.................... { 
....................    NODE_INFO   niSourceAddress;// Remote IP address and MAC address 
....................    WORD      wSourcePort;   // Remote TCP port number that the response SYN needs to be sent to 
....................    DWORD      dwSourceSEQ;   // Remote TCP SEQuence number that must be ACKnowledged when we send our response SYN 
....................    WORD      wDestPort;      // Local TCP port which the original SYN was destined for 
....................    WORD      wTimestamp;      // Timer to expire old SYN packets that can't be serviced at all 
.................... } TCP_SYN_QUEUE; 
....................  
....................  
.................... #if defined(STACK_CLIENT_MODE) 
.................... static WORD NextPort __attribute__((persistent));   // Tracking variable for next local client port number 
.................... #endif 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    TCB Definitions 
....................   ***************************************************************************/ 
....................  
.................... // Determines the number of defined TCP sockets 
.................... //#define TCP_SOCKET_COUNT   (sizeof(TCPSocketInitializer)/sizeof(TCPSocketInitializer[0])) 
.................... #define TCP_SOCKET_COUNT   TCP_CONFIGURATION    //ccs changed 
....................  
.................... #if defined(HI_TECH_C) 
....................    // The initializer forces this large array out of the bss section  
....................    // so we can link correctly. 
....................    #pragma psect bigdata=TCB_uRAM_BIG 
....................    #pragma psect data=TCB_uRAM 
....................    static TCB_STUB TCBStubs[TCP_SOCKET_COUNT] = {'\0'};    
....................    #pragma psect data=ordinary_data_sect 
....................    #pragma psect bigdata=ordinary_data_sect_big 
.................... #else 
....................    // The TCB array is very large.  With the C18 compiler, one must  
....................    // modify the linker script to make an array that spans more than  
....................    // one memory bank.  To do this, make the necessary changes to your  
....................    // processor's linker script (.lkr).  Here is an example showing  
....................    // gpr11 and 128 bytes of gpr12 being combined into one 384 byte  
....................    // block used exclusively by the TCB_uRAM data section: 
....................    // ... 
....................    // //DATABANK   NAME=gpr11      START=0xB00          END=0xBFF 
....................    // //DATABANK   NAME=gpr12      START=0xC00          END=0xCFF 
....................    // DATABANK   NAME=gpr11b     START=0xB00          END=0xC7F           PROTECTED 
....................    // DATABANK   NAME=gpr12      START=0xC80          END=0xCFF 
....................    // ... 
....................    // SECTION    NAME=TCB_uRAM    RAM=gpr11b 
....................    // ... 
....................    #if defined(__18CXX) && !defined(HI_TECH_C)    
....................       #pragma udata TCB_uRAM 
....................    #endif 
....................    static TCB_STUB TCBStubs[TCP_SOCKET_COUNT]; 
....................    #if defined(__18CXX) && !defined(HI_TECH_C)    
....................       #pragma udata               // Return to any other RAM section 
....................    #endif 
.................... #endif 
....................  
.................... static TCB MyTCB;                           // Currently loaded TCB 
.................... static TCP_SOCKET hCurrentTCP = INVALID_SOCKET;      // Current TCP socket 
.................... #if TCP_SYN_QUEUE_MAX_ENTRIES 
....................    #if defined(__18CXX) && !defined(HI_TECH_C)    
....................       #pragma udata SYN_QUEUE_RAM_SECT 
....................    #endif 
....................    static TCP_SYN_QUEUE SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES];   // Array of saved incoming SYN requests that need to be serviced later 
....................    #if defined(__18CXX) && !defined(HI_TECH_C)    
....................       #pragma udata 
....................    #endif 
.................... #endif 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Function Prototypes 
....................   ***************************************************************************/ 
....................  
.................... static void TCPRAMCopy(PTR_BASE wDest, BYTE vDestType, PTR_BASE wSource, BYTE vSourceType, WORD wLength); 
....................  
.................... #if defined(__18CXX) 
....................    static void TCPRAMCopyROM(PTR_BASE wDest, BYTE wDestType, ROM BYTE* wSource, WORD wLength); 
.................... #else 
....................    #define TCPRAMCopyROM(a,b,c,d)   TCPRAMCopy(a,b,c,TCP_PIC_RAM,d) 
.................... #endif 
....................  
.................... static void SendTCP(BYTE vTCPFlags, BYTE vSendFlags); 
.................... static void HandleTCPSeg(TCP_HEADER* h, WORD len); 
.................... static BOOL FindMatchingTCPSocket(TCP_HEADER* h, NODE_INFO* remote); 
.................... static void SwapTCPHeader(TCP_HEADER* header); 
.................... static void CloseSocket(void); 
.................... static void SyncTCB(void); 
....................  
.................... #if defined(WF_CS_TRIS) 
.................... UINT16 WFGetTCBSize(void); 
.................... #endif 
....................  
.................... // Indicates if this packet is a retransmission (no reset) or a new packet (reset required) 
.................... #define SENDTCP_RESET_TIMERS   0x01 
.................... // Instead of transmitting normal data, a garbage octet is transmitted according to RFC 1122 section 4.2.3.6 
.................... #define SENDTCP_KEEP_ALIVE      0x02 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    TCB Optimization Configuration 
....................   ***************************************************************************/ 
....................  
.................... #if defined(TCP_OPTIMIZE_FOR_SIZE) 
....................    static TCB_STUB MyTCBStub; 
....................     
....................    // Flushes MyTCBStub cache and loads up the specified TCB_STUB. 
....................    // Does nothing on cache hit. 
....................    static void SyncTCBStub(TCP_SOCKET hTCP) 
....................    { 
....................       if(hCurrentTCP == hTCP) 
*
006DC:  MOVLB  2
006DE:  MOVF   x76,W
006E0:  MOVLB  0
006E2:  SUBWF  xDE,W
006E4:  BNZ   06E8
....................          return; 
006E6:  BRA    077A
....................     
....................       if(hCurrentTCP != INVALID_SOCKET) 
006E8:  MOVF   xDE,W
006EA:  SUBLW  FE
006EC:  BZ    072A
....................       { 
....................          // Save the current TCB stub 
....................          memcpy((void*)&TCBStubs[hCurrentTCP], (void*)&MyTCBStub, sizeof(MyTCBStub)); 
006EE:  MOVF   xDE,W
006F0:  MULLW  1C
006F2:  MOVF   FF3,W
006F4:  CLRF   03
006F6:  ADDLW  9B
006F8:  MOVWF  01
006FA:  MOVLW  00
006FC:  ADDWFC 03,F
006FE:  MOVFF  01,277
00702:  MOVLB  2
00704:  MOVFF  03,278
00708:  MOVLW  01
0070A:  MOVWF  x7A
0070C:  MOVLW  1B
0070E:  MOVFF  03,FEA
00712:  MOVFF  01,FE9
00716:  MOVFF  27A,FE2
0071A:  MOVWF  FE1
0071C:  MOVLW  1C
0071E:  MOVWF  01
00720:  MOVFF  FE6,FEE
00724:  DECFSZ 01,F
00726:  BRA    0720
00728:  MOVLB  0
....................       } 
....................     
....................       hCurrentTCP = hTCP; 
0072A:  MOVFF  276,DE
....................     
....................       if(hTCP == INVALID_SOCKET) 
0072E:  MOVLB  2
00730:  MOVF   x76,W
00732:  SUBLW  FE
00734:  BNZ   073C
....................          return; 
00736:  MOVLB  0
00738:  BRA    077A
0073A:  MOVLB  2
....................     
....................       // Load up the new TCB stub 
....................       memcpy((void*)&MyTCBStub, (void*)&TCBStubs[hTCP], sizeof(MyTCBStub)); 
0073C:  MOVLW  01
0073E:  MOVWF  x78
00740:  MOVLW  1B
00742:  MOVWF  x77
00744:  MOVF   x76,W
00746:  MULLW  1C
00748:  MOVF   FF3,W
0074A:  CLRF   03
0074C:  ADDLW  9B
0074E:  MOVWF  01
00750:  MOVLW  00
00752:  ADDWFC 03,F
00754:  MOVFF  01,279
00758:  MOVFF  03,27A
0075C:  MOVFF  278,FEA
00760:  MOVFF  277,FE9
00764:  MOVFF  03,FE2
00768:  MOVFF  01,FE1
0076C:  MOVLW  1C
0076E:  MOVWF  01
00770:  MOVFF  FE6,FEE
00774:  DECFSZ 01,F
00776:  BRA    0770
00778:  MOVLB  0
0077A:  RETURN 0
....................    } 
.................... #else 
....................    // Flushes MyTCBStub cache and loads up the specified TCB_STUB. 
....................    // Does nothing on cache hit. 
....................    #define SyncTCBStub(a)   hCurrentTCP = (a) 
....................    // Alias to current TCP stub. 
....................    #define MyTCBStub      TCBStubs[hCurrentTCP] 
.................... #endif 
....................  
....................  
....................  
.................... // Flushes MyTCB cache and loads up the specified TCB. 
.................... // Does nothing on cache hit. 
.................... static void SyncTCB(void) 
.................... { 
....................    static TCP_SOCKET hLastTCB = INVALID_SOCKET; 
....................     
....................    if(hLastTCB == hCurrentTCP) 
*
00A7E:  MOVF   xDE,W
00A80:  MOVLB  1
00A82:  SUBWF  x37,W
00A84:  BNZ   0A88
....................       return; 
00A86:  BRA    0B4E
....................  
....................    if(hLastTCB != INVALID_SOCKET) 
00A88:  MOVF   x37,W
00A8A:  SUBLW  FE
00A8C:  BZ    0B0A
....................    { 
....................       // Save the current TCB 
....................       TCPRAMCopy(TCBStubs[hLastTCB].bufferTxStart - sizeof(MyTCB), TCBStubs[hLastTCB].vMemoryMedium, (PTR_BASE)&MyTCB, TCP_PIC_RAM, sizeof(MyTCB)); 
00A8E:  MOVF   x37,W
00A90:  MULLW  1C
00A92:  MOVF   FF3,W
00A94:  MOVLB  2
00A96:  CLRF   xA0
00A98:  MOVWF  x9F
00A9A:  MOVLW  9B
00A9C:  ADDWF  x9F,W
00A9E:  MOVWF  FE9
00AA0:  MOVLW  00
00AA2:  ADDWFC xA0,W
00AA4:  MOVWF  FEA
00AA6:  MOVFF  FEC,2A2
00AAA:  MOVF   FED,F
00AAC:  MOVFF  FEF,2A1
00AB0:  MOVLW  27
00AB2:  SUBWF  xA1,F
00AB4:  MOVLW  00
00AB6:  SUBWFB xA2,F
00AB8:  MOVLB  1
00ABA:  MOVF   x37,W
00ABC:  MULLW  1C
00ABE:  MOVF   FF3,W
00AC0:  MOVLB  2
00AC2:  CLRF   xA4
00AC4:  MOVWF  xA3
00AC6:  MOVLW  1B
00AC8:  ADDWF  xA3,W
00ACA:  MOVWF  01
00ACC:  MOVLW  00
00ACE:  ADDWFC xA4,W
00AD0:  MOVWF  03
00AD2:  MOVF   01,W
00AD4:  ADDLW  9B
00AD6:  MOVWF  FE9
00AD8:  MOVLW  00
00ADA:  ADDWFC 03,W
00ADC:  MOVWF  FEA
00ADE:  MOVFF  FEF,2A3
00AE2:  CLRF   xA5
00AE4:  MOVLW  B7
00AE6:  MOVWF  xA4
00AE8:  MOVFF  2A2,2A7
00AEC:  MOVFF  2A1,2A6
00AF0:  MOVFF  2A3,2A8
00AF4:  MOVFF  2A5,2AA
00AF8:  MOVWF  xA9
00AFA:  MOVLW  01
00AFC:  MOVWF  xAB
00AFE:  CLRF   xAD
00B00:  MOVLW  27
00B02:  MOVWF  xAC
00B04:  MOVLB  0
00B06:  RCALL  0998
00B08:  MOVLB  1
....................    } 
....................  
....................    // Load up the new TCB 
....................    hLastTCB = hCurrentTCP; 
00B0A:  MOVFF  DE,137
....................    TCPRAMCopy((PTR_BASE)&MyTCB, TCP_PIC_RAM, MyTCBStub.bufferTxStart - sizeof(MyTCB), MyTCBStub.vMemoryMedium, sizeof(MyTCB)); 
00B0E:  MOVLB  2
00B10:  CLRF   xA0
00B12:  MOVLW  B7
00B14:  MOVWF  x9F
00B16:  MOVLW  27
00B18:  MOVLB  1
00B1A:  SUBWF  x1B,W
00B1C:  MOVLB  2
00B1E:  MOVWF  xA1
00B20:  MOVLW  00
00B22:  MOVLB  1
00B24:  SUBWFB x1C,W
00B26:  MOVLB  2
00B28:  MOVWF  xA2
00B2A:  MOVFF  2A0,2A7
00B2E:  MOVFF  29F,2A6
00B32:  MOVLW  01
00B34:  MOVWF  xA8
00B36:  MOVFF  2A2,2AA
00B3A:  MOVFF  2A1,2A9
00B3E:  MOVFF  136,2AB
00B42:  CLRF   xAD
00B44:  MOVLW  27
00B46:  MOVWF  xAC
00B48:  MOVLB  0
00B4A:  RCALL  0998
00B4C:  MOVLB  1
00B4E:  MOVLB  0
00B50:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPInit(void) 
....................  
....................   Summary: 
....................    Initializes the TCP module. 
....................  
....................   Description: 
....................    Initializes the TCP module.  This function sets up the TCP buffers 
....................    in memory and initializes each socket to the CLOSED state.  If 
....................    insufficient memory was allocated for the TCP sockets, the function 
....................    will hang here to be captured by the debugger. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................      None 
....................       
....................   Remarks: 
....................    This function is called only one during lifetime of the application. 
....................   ***************************************************************************/ 
.................... void TCPInit(void) 
*
00C1E:  MOVLW  1A
00C20:  MOVLB  1
00C22:  MOVWF  x78
00C24:  MOVLW  FC
00C26:  MOVWF  x77
.................... { 
....................    BYTE i; 
....................    BYTE vSocketsAllocated; 
....................    WORD wTXSize, wRXSize; 
....................    PTR_BASE ptrBaseAddress; 
....................    BYTE vMedium; 
....................    #if TCP_ETH_RAM_SIZE > 0 
....................    WORD wCurrentETHAddress = TCP_ETH_RAM_BASE_ADDRESS; 
....................    #endif 
....................    #if TCP_PIC_RAM_SIZE > 0 
....................    PTR_BASE ptrCurrentPICAddress = TCP_PIC_RAM_BASE_ADDRESS; 
....................    #endif 
....................    #if TCP_SPI_RAM_SIZE > 0 
....................    WORD wCurrentSPIAddress = TCP_SPI_RAM_BASE_ADDRESS; 
....................    #endif 
....................  
....................    #if defined(STACK_CLIENT_MODE) 
....................       // Initialize NextPort to a random value if it is zero (such as after  
....................       // reset on a PIC32 or PIC18 when the static memory initializer is  
....................       // used).  By starting with a random number, we decrease the risk of  
....................       // reusing a port number that was previously used if the user power  
....................       // cycles the device. 
....................       if(NextPort == 0u) 
00C28:  MOVLB  0
00C2A:  MOVF   x99,F
00C2C:  BNZ   0C4C
00C2E:  MOVF   x9A,F
00C30:  BNZ   0C4C
....................          NextPort = (((WORD)GenerateRandomDWORD()) & 0x07FFu) + LOCAL_PORT_START_NUMBER; 
00C32:  RCALL  045C
00C34:  MOVFF  01,17A
00C38:  MOVLW  07
00C3A:  MOVLB  1
00C3C:  ANDWF  x7A,F
00C3E:  MOVFF  00,99
00C42:  MOVLW  04
00C44:  MOVLB  1
00C46:  ADDWF  x7A,W
00C48:  MOVLB  0
00C4A:  MOVWF  x9A
....................    #endif 
....................  
....................  
....................    // Mark all SYN Queue entries as invalid by zeroing the memory 
....................    #if TCP_SYN_QUEUE_MAX_ENTRIES 
....................       memset((void*)SYNQueue, 0x00, sizeof(SYNQueue)); 
00C4C:  MOVLB  1
00C4E:  CLRF   x7A
00C50:  MOVLW  DF
00C52:  MOVWF  x79
00C54:  MOVFF  17A,FEA
00C58:  MOVWF  FE9
00C5A:  CLRF   00
00C5C:  CLRF   02
00C5E:  MOVLW  3C
00C60:  MOVWF  01
00C62:  MOVLB  0
00C64:  BRA    06C0
....................    #endif 
....................     
....................    // Allocate all socket FIFO addresses 
....................    vSocketsAllocated = 0; 
00C66:  MOVLB  1
00C68:  CLRF   x6F
....................    for(i = 0; i < TCP_SOCKET_COUNT; i++) 
00C6A:  CLRF   x6E
00C6C:  MOVF   x6E,F
00C6E:  BTFSS  FD8.2
00C70:  BRA    0DBA
....................    { 
....................       // Generate all needed sockets of each type (TCP_PURPOSE_*) 
....................       SyncTCBStub(i); 
00C72:  MOVFF  16E,276
00C76:  MOVLB  0
00C78:  RCALL  06DC
....................     
....................       vMedium = TCPSocketInitializer[i].vMemoryMedium; 
00C7A:  MOVLB  1
00C7C:  MOVF   x6E,W
00C7E:  MULLW  06
00C80:  MOVF   FF3,W
00C82:  CLRF   x7A
00C84:  MOVWF  x79
00C86:  MOVLW  01
00C88:  ADDWF  x79,W
00C8A:  MOVWF  01
00C8C:  MOVLW  00
00C8E:  ADDWFC x7A,W
00C90:  MOVWF  03
00C92:  MOVF   01,W
00C94:  ADDLW  24
00C96:  MOVWF  FE9
00C98:  MOVLW  00
00C9A:  ADDWFC 03,W
00C9C:  MOVWF  FEA
00C9E:  MOVFF  FEF,176
....................       wTXSize = TCPSocketInitializer[i].wTXBufferSize; 
00CA2:  MOVF   x6E,W
00CA4:  MULLW  06
00CA6:  MOVF   FF3,W
00CA8:  CLRF   x7A
00CAA:  MOVWF  x79
00CAC:  MOVLW  02
00CAE:  ADDWF  x79,W
00CB0:  MOVWF  01
00CB2:  MOVLW  00
00CB4:  ADDWFC x7A,W
00CB6:  MOVWF  03
00CB8:  MOVF   01,W
00CBA:  ADDLW  24
00CBC:  MOVWF  FE9
00CBE:  MOVLW  00
00CC0:  ADDWFC 03,W
00CC2:  MOVWF  FEA
00CC4:  MOVFF  FEC,171
00CC8:  MOVF   FED,F
00CCA:  MOVFF  FEF,170
....................       wRXSize = TCPSocketInitializer[i].wRXBufferSize; 
00CCE:  MOVF   x6E,W
00CD0:  MULLW  06
00CD2:  MOVF   FF3,W
00CD4:  CLRF   x7A
00CD6:  MOVWF  x79
00CD8:  MOVLW  04
00CDA:  ADDWF  x79,W
00CDC:  MOVWF  01
00CDE:  MOVLW  00
00CE0:  ADDWFC x7A,W
00CE2:  MOVWF  03
00CE4:  MOVF   01,W
00CE6:  ADDLW  24
00CE8:  MOVWF  FE9
00CEA:  MOVLW  00
00CEC:  ADDWFC 03,W
00CEE:  MOVWF  FEA
00CF0:  MOVFF  FEC,173
00CF4:  MOVF   FED,F
00CF6:  MOVFF  FEF,172
....................     
....................       switch(vMedium) 
00CFA:  MOVF   x76,W
00CFC:  XORLW  00
00CFE:  MOVLB  0
00D00:  BZ    0D04
00D02:  BRA    0D52
....................       { 
....................          #if TCP_ETH_RAM_SIZE > 0 
....................          case TCP_ETH_RAM: 
....................             ptrBaseAddress = wCurrentETHAddress; 
00D04:  MOVFF  178,175
00D08:  MOVFF  177,174
....................             wCurrentETHAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1; 
00D0C:  MOVLW  27
00D0E:  MOVLB  1
00D10:  ADDWF  x70,W
00D12:  MOVWF  x79
00D14:  MOVLW  00
00D16:  ADDWFC x71,W
00D18:  MOVWF  x7A
00D1A:  MOVLW  01
00D1C:  ADDWF  x79,F
00D1E:  MOVLW  00
00D20:  ADDWFC x7A,F
00D22:  MOVF   x72,W
00D24:  ADDWF  x79,F
00D26:  MOVF   x73,W
00D28:  ADDWFC x7A,F
00D2A:  MOVLW  01
00D2C:  ADDWF  x79,W
00D2E:  MOVWF  01
00D30:  MOVLW  00
00D32:  ADDWFC x7A,W
00D34:  MOVWF  03
00D36:  MOVF   01,W
00D38:  ADDWF  x77,F
00D3A:  MOVF   03,W
00D3C:  ADDWFC x78,F
....................             // Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us. 
....................             // If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in TCPIPConfig.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken. 
.................... #if defined(WF_CS_TRIS) 
....................             while(wCurrentETHAddress > TCP_ETH_RAM_BASE_ADDRESS + WFGetTCBSize()/*TCP_ETH_RAM_SIZE*/); 
.................... #else 
....................             while(wCurrentETHAddress > TCP_ETH_RAM_BASE_ADDRESS + TCP_ETH_RAM_SIZE); 
00D3E:  MOVF   x78,W
00D40:  SUBLW  1E
00D42:  BC    0D4E
00D44:  XORLW  FF
00D46:  BNZ   0D3E
00D48:  MOVF   x77,W
00D4A:  SUBLW  FC
00D4C:  BNC   0D3E
.................... #endif 
....................             break; 
00D4E:  BRA    0D56
00D50:  MOVLB  0
....................          #endif 
....................              
....................          #if TCP_PIC_RAM_SIZE > 0 
....................          case TCP_PIC_RAM: 
....................             ptrBaseAddress = ptrCurrentPICAddress; 
....................             ptrCurrentPICAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1; 
....................             // Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us. 
....................             // If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in TCPIPConfig.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken. 
....................             while(ptrCurrentPICAddress > TCP_PIC_RAM_BASE_ADDRESS + TCP_PIC_RAM_SIZE); 
....................             break; 
....................          #endif 
....................              
....................          #if TCP_SPI_RAM_SIZE > 0 
....................          case TCP_SPI_RAM: 
....................             ptrBaseAddress = wCurrentSPIAddress; 
....................             wCurrentSPIAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1; 
....................             // Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us. 
....................             // If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in TCPIPConfig.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken. 
....................             while(wCurrentSPIAddress > TCP_SPI_RAM_BASE_ADDRESS + TCP_SPI_RAM_SIZE); 
....................             break; 
....................          #endif 
....................           
....................          default: 
....................             while(1); // Undefined allocation medium.  Go fix your TCPIPConfig.h TCP memory allocations. 
00D52:  BRA    0D52
00D54:  MOVLB  1
....................       } 
....................     
....................       MyTCBStub.vMemoryMedium = vMedium; 
00D56:  MOVFF  176,136
....................       MyTCBStub.bufferTxStart   = ptrBaseAddress + sizeof(TCB); 
00D5A:  MOVLW  27
00D5C:  ADDWF  x74,W
00D5E:  MOVWF  x1B
00D60:  MOVLW  00
00D62:  ADDWFC x75,W
00D64:  MOVWF  x1C
....................       MyTCBStub.bufferRxStart   = MyTCBStub.bufferTxStart + wTXSize + 1; 
00D66:  MOVF   x70,W
00D68:  ADDWF  x1B,W
00D6A:  MOVWF  x79
00D6C:  MOVF   x71,W
00D6E:  ADDWFC x1C,W
00D70:  MOVWF  x7A
00D72:  MOVLW  01
00D74:  ADDWF  x79,W
00D76:  MOVWF  x1D
00D78:  MOVLW  00
00D7A:  ADDWFC x7A,W
00D7C:  MOVWF  x1E
....................       MyTCBStub.bufferEnd      = MyTCBStub.bufferRxStart + wRXSize; 
00D7E:  MOVF   x72,W
00D80:  ADDWF  x1D,W
00D82:  MOVWF  x1F
00D84:  MOVF   x73,W
00D86:  ADDWFC x1E,W
00D88:  MOVWF  x20
....................       MyTCBStub.smState      = TCP_CLOSED; 
00D8A:  MOVLW  0D
00D8C:  MOVWF  x31
....................       MyTCBStub.Flags.bServer   = FALSE; 
00D8E:  BCF    x32.3
....................       #if defined(STACK_USE_SSL) 
....................       MyTCBStub.sslStubID = SSL_INVALID_ID; 
....................       #endif       
....................  
....................       SyncTCB(); 
00D90:  MOVLB  0
00D92:  RCALL  0A7E
....................       MyTCB.vSocketPurpose = TCPSocketInitializer[i].vSocketPurpose; 
00D94:  MOVLB  1
00D96:  MOVF   x6E,W
00D98:  MULLW  06
00D9A:  MOVF   FF3,W
00D9C:  CLRF   x7A
00D9E:  MOVWF  x79
00DA0:  MOVLW  24
00DA2:  ADDWF  x79,W
00DA4:  MOVWF  FE9
00DA6:  MOVLW  00
00DA8:  ADDWFC x7A,W
00DAA:  MOVWF  FEA
00DAC:  MOVFF  FEF,DD
....................       CloseSocket(); 
00DB0:  MOVLB  0
00DB2:  RCALL  0B52
00DB4:  MOVLB  1
00DB6:  INCF   x6E,F
00DB8:  BRA    0C6C
....................    } 
00DBA:  MOVLB  0
00DBC:  GOTO   0DF8 (RETURN)
.................... } 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Connection Management Functions 
....................   ***************************************************************************/ 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    TCP_SOCKET TCPOpen(DWORD dwRemoteHost, BYTE vRemoteHostType, WORD wPort, BYTE vSocketPurpose) 
....................      
....................   Summary: 
....................     Opens a TCP socket for listening or as a client. 
....................  
....................   Description: 
....................     Provides a unified method for opening TCP sockets. This function can 
....................     open both client and server sockets. For client sockets, it can accept 
....................     a host name string to query in DNS, an IP address as a string, an IP 
....................     address in binary form, or a previously resolved NODE_INFO structure 
....................     containing the remote IP address and associated MAC address. When a 
....................     host name or IP address only is provided, the TCP module will 
....................     internally perform the necessary DNS and/or ARP resolution steps before 
....................     reporting that the TCP socket is connected (via a call to 
....................     TCPISConnected returning TRUE). Server sockets ignore this destination 
....................     parameter and listen only on the indicated port. 
....................      
....................     The vSocketPurpose field allows sockets to be opened with varying 
....................     buffer size parameters and memory storage mediums. This field 
....................     corresponds to pre-defined sockets allocated in the 
....................     TCPSocketInitializer[] array in TCPIPConfig.h. The TCPIPConfig.h file 
....................     can be edited using the TCP/IP Configuration Wizard. 
....................      
....................     Sockets are statically allocated on boot, but can be claimed with this 
....................     \function and freed using TCPDisconnect or TCPClose (for client 
....................     sockets). Server sockets can be freed using TCPClose only (calls to 
....................     TCPDisconnect will return server sockets to the listening state, 
....................     allowing reuse). 
....................  
....................   Conditions: 
....................     TCP is initialized. 
....................  
....................   Input: 
....................     dwRemoteHost -     For client sockets only. Provide a pointer to a 
....................                        null\-terminated string of the remote host name (ex\: 
....................                        "www.microchip.com" or "192.168.1.123"), a literal 
....................                        destination IP address (ex\: 0x7B01A8C0 or an IP_ADDR 
....................                        data type), or a pointer to a NODE_INFO structure 
....................                        with the remote IP address and remote node or gateway 
....................                        MAC address specified. If a string is provided, note 
....................                        that it must be statically allocated in memory and 
....................                        cannot be modified or deallocated until 
....................                        TCPIsConnected returns TRUE.<p />This parameter is 
....................                        ignored for server sockets. 
....................     vRemoteHostType -  Any one of the following flags to identify the 
....................                        meaning of the dwRemoteHost parameter\: 
....................                        * TCP_OPEN_SERVER &#45; Open a server socket and 
....................                          ignore the dwRemoteHost parameter. 
....................                        * TCP_OPEN_RAM_HOST &#45; Open a client socket and 
....................                          connect it to a remote host who's name is stored as a 
....................                          null terminated string in a RAM array. Ex\: 
....................                          "www.microchip.com" or "192.168.0.123" (BYTE&#42; 
....................                          type) 
....................                        * TCP_OPEN_ROM_HOST &#45; Open a client socket and 
....................                          connect it to a remote host who's name is stored as a 
....................                          null terminated string in a literal string or ROM 
....................                          array. Ex\: "www.microchip.com" or "192.168.0.123" 
....................                          (ROM BYTE&#42; type) 
....................                        * TCP_OPEN_IP_ADDRESS &#45; Open a client socket and 
....................                          connect it to a remote IP address. Ex\: 0x7B01A8C0 
....................                          for 192.168.1.123 (DWORD type). Note that the byte 
....................                          ordering is big endian. 
....................                        * TCP_OPEN_NODE_INFO &#45; Open a client socket and 
....................                          connect it to a remote IP and MAC addresses pair 
....................                          stored in a NODE_INFO structure. dwRemoteHost must be 
....................                          a pointer to the NODE_INFO structure. This option is 
....................                          provided for backwards compatibility with 
....................                          applications built against prior stack versions that 
....................                          only implemented the TCPConnect() function. It can 
....................                          also be used to skip DNS and ARP resolution steps if 
....................                          connecting to a remote node which you've already 
....................                          connected to and have cached addresses for. 
....................     wPort -            TCP port to listen on or connect to\: 
....................                        * Client sockets &#45; the remote TCP port to which a 
....................                          connection should be made. The local port for client 
....................                          sockets will be automatically picked by the TCP 
....................                          module. 
....................                        * Server sockets &#45; the local TCP port on which to 
....................                          listen for connections. 
....................     vSocketPurpose -   Any of the TCP_PURPOSE_* constants defined in 
....................                        TCPIPConfig.h or the TCPIPConfig utility (see 
....................                        TCPSocketInitializer[] array). 
....................  
....................   Return Values: 
....................     INVALID_SOCKET -  No sockets of the specified type were available to be 
....................                       opened. 
....................     Otherwise -       A TCP_SOCKET handle. Save this handle and use it when 
....................                       calling all other TCP APIs. 
....................  
....................   Remarks: 
....................     This function replaces the old TCPConnect and TCPListen functions. 
....................      
....................     If TCP_OPEN_RAM_HOST or TCP_OPEN_ROM_HOST are used for the destination 
....................     type, the DNS client module must also be enabled (STACK_USE_DNS must be 
....................     defined in TCPIPConfig.h). 
....................  
....................   Example: 
....................     \ \  
....................     <code> 
....................     // Open a server socket 
....................     skt = TCPOpen(NULL, TCP_OPEN_SERVER, HTTP_PORT, TCP_PURPOSE_HTTP_SERVER); 
....................      
....................     // Open a client socket to www.microchip.com 
....................     // The double cast here prevents compiler warnings 
....................     skt = TCPOpen((DWORD)(PTR_BASE)"www.microchip.com", 
....................                     TCP_OPEN_ROM_HOST, 80, TCP_PURPOSE_DEFAULT); 
....................      
....................     // Reopen a client socket without repeating DNS or ARP 
....................     SOCKET_INFO cache = TCPGetSocketInfo(skt);  // Call with the old socket 
....................     skt = TCPOpen((DWORD)(PTR_BASE)&amp;cache.remote, TCP_OPEN_NODE_INFO, 
....................                     cache.remotePort.Val, TCP_PURPOSE_DEFAULT); 
....................     </code>                                                     
....................   *****************************************************************************/ 
.................... TCP_SOCKET TCPOpen(DWORD dwRemoteHost, BYTE vRemoteHostType, WORD wPort, BYTE vSocketPurpose) 
.................... { 
....................    TCP_SOCKET hTCP; 
....................  
....................    // Find an available socket that matches the specified socket type 
....................    for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++) 
*
04B60:  MOVLB  2
04B62:  CLRF   x72
04B64:  MOVF   x72,F
04B66:  BTFSS  FD8.2
04B68:  BRA    4D32
....................    { 
....................       SyncTCBStub(hTCP); 
04B6A:  MOVFF  272,276
04B6E:  MOVLB  0
04B70:  CALL   06DC
....................  
....................       // Sockets that are in use will be in a non-closed state 
....................       if(MyTCBStub.smState != TCP_CLOSED) 
04B74:  MOVLB  1
04B76:  MOVF   x31,W
04B78:  SUBLW  0D
04B7A:  BZ    4B7E
....................          continue; 
04B7C:  BRA    4D2C
....................  
....................       SyncTCB(); 
04B7E:  MOVLB  0
04B80:  CALL   0A7E
....................  
....................       // See if this socket matches the desired type 
....................       if(MyTCB.vSocketPurpose != vSocketPurpose) 
04B84:  MOVLB  2
04B86:  MOVF   x71,W
04B88:  MOVLB  0
04B8A:  SUBWF  xDD,W
04B8C:  BZ    4B94
....................          continue; 
04B8E:  MOVLB  1
04B90:  BRA    4D2C
04B92:  MOVLB  0
....................  
....................       // Start out assuming worst case Maximum Segment Size (changes when MSS  
....................       // option is received from remote node) 
....................       MyTCB.wRemoteMSS = 536; 
04B94:  MOVLW  02
04B96:  MOVWF  xDB
04B98:  MOVLW  18
04B9A:  MOVWF  xDA
....................  
....................       // See if this is a server socket 
....................       if(vRemoteHostType == TCP_OPEN_SERVER) 
04B9C:  MOVLB  2
04B9E:  MOVF   x6E,F
04BA0:  BNZ   4BBE
....................       { 
....................          MyTCB.localPort.Val = wPort; 
04BA2:  MOVFF  270,C8
04BA6:  MOVFF  26F,C7
....................          MyTCBStub.Flags.bServer = TRUE; 
04BAA:  MOVLB  1
04BAC:  BSF    x32.3
....................          MyTCBStub.smState = TCP_LISTEN; 
04BAE:  MOVLW  04
04BB0:  MOVWF  x31
....................          MyTCBStub.remoteHash.Val = wPort; 
04BB2:  MOVFF  270,135
04BB6:  MOVFF  26F,134
....................          #if defined(STACK_USE_SSL_SERVER) 
....................          MyTCB.localSSLPort.Val = 0; 
....................          #endif 
....................       } 
04BBA:  BRA    4D22
04BBC:  MOVLB  2
....................       // Handle all the client mode socket types 
....................       else 
....................       { 
....................          #if defined(STACK_CLIENT_MODE) 
....................          { 
....................             // Each new socket that is opened by this node, gets the  
....................             // next sequential local port number. 
....................             if(NextPort < LOCAL_PORT_START_NUMBER || NextPort > LOCAL_PORT_END_NUMBER) 
04BBE:  MOVLB  0
04BC0:  MOVF   x9A,W
04BC2:  SUBLW  03
04BC4:  BC    4BD6
04BC6:  MOVF   x9A,W
04BC8:  SUBLW  12
04BCA:  BC    4BDC
04BCC:  XORLW  FF
04BCE:  BNZ   4BD6
04BD0:  MOVF   x99,W
04BD2:  SUBLW  88
04BD4:  BC    4BDC
....................                NextPort = LOCAL_PORT_START_NUMBER; 
04BD6:  MOVLW  04
04BD8:  MOVWF  x9A
04BDA:  CLRF   x99
....................              
....................             // Set the non-zero TCB fields 
....................             MyTCB.localPort.Val = NextPort++; 
04BDC:  MOVFF  9A,03
04BE0:  MOVF   x99,W
04BE2:  INCF   x99,F
04BE4:  BTFSC  FD8.2
04BE6:  INCF   x9A,F
04BE8:  MOVWF  xC7
04BEA:  MOVFF  03,C8
....................             MyTCB.remotePort.Val = wPort; 
04BEE:  MOVFF  270,C6
04BF2:  MOVFF  26F,C5
....................     
....................             // Flag to start the DNS, ARP, SYN processes 
....................             MyTCBStub.eventTime = TickGet(); 
04BF6:  CALL   0E34
04BFA:  MOVFF  03,12C
04BFE:  MOVFF  02,12B
04C02:  MOVFF  01,12A
04C06:  MOVFF  00,129
....................             MyTCBStub.Flags.bTimerEnabled = 1; 
04C0A:  MOVLB  1
04C0C:  BSF    x32.4
....................     
....................             switch(vRemoteHostType) 
04C0E:  MOVLB  2
04C10:  MOVF   x6E,W
04C12:  XORLW  03
04C14:  MOVLB  0
04C16:  BZ    4C1E
04C18:  XORLW  07
04C1A:  BZ    4C9E
04C1C:  BRA    4D20
....................             { 
....................                #if defined(STACK_USE_DNS) 
....................                case TCP_OPEN_RAM_HOST: 
....................                case TCP_OPEN_ROM_HOST: 
....................                   MyTCB.remote.dwRemoteHost = dwRemoteHost; 
....................                   MyTCB.flags.bRemoteHostIsROM = (vRemoteHostType == TCP_OPEN_ROM_HOST); 
....................                   MyTCBStub.smState = TCP_GET_DNS_MODULE; 
....................                   break; 
....................                #endif 
....................        
....................                case TCP_OPEN_IP_ADDRESS: 
....................                   // dwRemoteHost is a literal IP address.  This  
....................                   // doesn't need DNS and can skip directly to the  
....................                   // Gateway ARPing step. 
....................                   MyTCBStub.remoteHash.Val = (((DWORD_VAL*)&dwRemoteHost)->w[1]+((DWORD_VAL*)&dwRemoteHost)->w[0] + wPort) ^ MyTCB.localPort.Val; 
04C1E:  MOVLW  02
04C20:  MOVLB  2
04C22:  MOVWF  x74
04C24:  MOVLW  6A
04C26:  MOVWF  x73
04C28:  MOVLW  02
04C2A:  ADDWF  x73,W
04C2C:  MOVWF  FE9
04C2E:  MOVLW  00
04C30:  ADDWFC x74,W
04C32:  MOVWF  FEA
04C34:  MOVFF  FEC,276
04C38:  MOVF   FED,F
04C3A:  MOVFF  FEF,275
04C3E:  MOVLW  02
04C40:  MOVWF  x78
04C42:  MOVLW  6A
04C44:  MOVWF  FE9
04C46:  MOVFF  278,FEA
04C4A:  MOVFF  FEC,03
04C4E:  MOVF   FED,F
04C50:  MOVF   FEF,W
04C52:  ADDWF  x75,F
04C54:  MOVF   03,W
04C56:  ADDWFC x76,F
04C58:  MOVF   x6F,W
04C5A:  ADDWF  x75,F
04C5C:  MOVF   x70,W
04C5E:  ADDWFC x76,F
04C60:  MOVF   x75,W
04C62:  MOVLB  0
04C64:  XORWF  xC7,W
04C66:  MOVLB  1
04C68:  MOVWF  x34
04C6A:  MOVLB  2
04C6C:  MOVF   x76,W
04C6E:  MOVLB  0
04C70:  XORWF  xC8,W
04C72:  MOVLB  1
04C74:  MOVWF  x35
....................                   MyTCB.remote.niRemoteMACIP.IPAddr.Val = dwRemoteHost; 
04C76:  MOVFF  26D,D0
04C7A:  MOVFF  26C,CF
04C7E:  MOVFF  26B,CE
04C82:  MOVFF  26A,CD
....................                   MyTCB.retryCount = 0; 
04C86:  MOVLB  0
04C88:  CLRF   xDC
....................                   MyTCB.retryInterval = (TICK_SECOND/4)/256; 
04C8A:  CLRF   xBA
04C8C:  CLRF   xB9
04C8E:  CLRF   xB8
04C90:  MOVLW  27
04C92:  MOVWF  xB7
....................                   MyTCBStub.smState = TCP_GATEWAY_SEND_ARP; 
04C94:  MOVLW  02
04C96:  MOVLB  1
04C98:  MOVWF  x31
....................                   break; 
04C9A:  MOVLB  0
04C9C:  BRA    4D20
....................        
....................                case TCP_OPEN_NODE_INFO: 
....................                   MyTCBStub.remoteHash.Val = (((NODE_INFO*)(PTR_BASE)dwRemoteHost)->IPAddr.w[1]+((NODE_INFO*)(PTR_BASE)dwRemoteHost)->IPAddr.w[0] + wPort) ^ MyTCB.localPort.Val; 
04C9E:  MOVLW  02
04CA0:  MOVLB  2
04CA2:  ADDWF  x6A,W
04CA4:  MOVWF  FE9
04CA6:  MOVLW  00
04CA8:  ADDWFC x6B,W
04CAA:  MOVWF  FEA
04CAC:  MOVFF  FEC,274
04CB0:  MOVF   FED,F
04CB2:  MOVFF  FEF,273
04CB6:  MOVFF  26A,FE9
04CBA:  MOVFF  26B,FEA
04CBE:  MOVFF  FEC,03
04CC2:  MOVF   FED,F
04CC4:  MOVF   FEF,W
04CC6:  ADDWF  x73,F
04CC8:  MOVF   03,W
04CCA:  ADDWFC x74,F
04CCC:  MOVF   x6F,W
04CCE:  ADDWF  x73,F
04CD0:  MOVF   x70,W
04CD2:  ADDWFC x74,F
04CD4:  MOVF   x73,W
04CD6:  MOVLB  0
04CD8:  XORWF  xC7,W
04CDA:  MOVLB  1
04CDC:  MOVWF  x34
04CDE:  MOVLB  2
04CE0:  MOVF   x74,W
04CE2:  MOVLB  0
04CE4:  XORWF  xC8,W
04CE6:  MOVLB  1
04CE8:  MOVWF  x35
....................                   memcpy((void*)(BYTE*)&MyTCB.remote, (void*)(BYTE*)(PTR_BASE)dwRemoteHost, sizeof(NODE_INFO)); 
04CEA:  MOVLB  2
04CEC:  CLRF   x74
04CEE:  MOVLW  CD
04CF0:  MOVFF  274,FEA
04CF4:  MOVWF  FE9
04CF6:  MOVFF  26B,FE2
04CFA:  MOVFF  26A,FE1
04CFE:  MOVLW  0A
04D00:  MOVWF  01
04D02:  MOVFF  FE6,FEE
04D06:  DECFSZ 01,F
04D08:  BRA    4D02
....................                   MyTCBStub.smState = TCP_SYN_SENT; 
04D0A:  MOVLW  05
04D0C:  MOVLB  1
04D0E:  MOVWF  x31
....................                   SendTCP(SYN, SENDTCP_RESET_TIMERS); 
04D10:  MOVLW  02
04D12:  MOVLB  2
04D14:  MOVWF  x75
04D16:  MOVLW  01
04D18:  MOVWF  x76
04D1A:  MOVLB  0
04D1C:  CALL   1774
....................                   break; 
04D20:  MOVLB  1
....................             } 
....................          }       
....................          #else 
....................          { 
....................             return INVALID_SOCKET; 
....................          }    
....................          #endif 
....................       } 
....................        
....................       return hTCP;       
04D22:  MOVLB  2
04D24:  MOVFF  272,01
04D28:  BRA    4D36
04D2A:  MOVLB  1
04D2C:  MOVLB  2
04D2E:  INCF   x72,F
04D30:  BRA    4B64
....................    } 
....................  
....................    // If there is no socket available, return error. 
....................    return INVALID_SOCKET; 
04D32:  MOVLW  FE
04D34:  MOVWF  01
04D36:  MOVLB  0
04D38:  GOTO   5354 (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPWasReset(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Self-clearing semaphore inidicating socket reset. 
....................  
....................   Description: 
....................    This function is a self-clearing semaphore indicating whether or not 
....................    a socket has been disconnected since the previous call.  This function 
....................    works for all possible disconnections: a call to TCPDisconnect, a FIN  
....................    from the remote node, or an acknowledgement timeout caused by the loss 
....................    of a network link.  It also returns TRUE after the first call to TCPInit. 
....................    Applications should use this function to reset their state machines. 
....................     
....................    This function was added due to the possibility of an error when relying 
....................    on TCPIsConnected returing FALSE to check for a condition requiring a 
....................    state machine reset.  If a socket is closed (due to a FIN ACK) and then 
....................    immediately reopened (due to a the arrival of a new SYN) in the same 
....................    cycle of the stack, calls to TCPIsConnected by the application will  
....................    never return FALSE even though the socket has been disconnected.  This  
....................    can cause errors for protocols such as HTTP in which a client will  
....................    immediately open a new connection upon closing of a prior one.  Relying 
....................    on this function instead allows applications to trap those conditions  
....................    and properly reset their internal state for the new connection. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Return Values: 
....................      TRUE - The socket has been disconnected since the previous call. 
....................      FALSE - The socket has not been disconnected since the previous call. 
....................   ***************************************************************************/ 
.................... BOOL TCPWasReset(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return TRUE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    if(MyTCBStub.Flags.bSocketReset) 
....................    { 
....................       MyTCBStub.Flags.bSocketReset = 0; 
....................       return TRUE; 
....................    }    
....................     
....................    return FALSE; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPIsConnected(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines if a socket has an established connection. 
....................  
....................   Description: 
....................    This function determines if a socket has an established connection to  
....................    a remote node.  Call this function after calling TCPOpen to determine  
....................    when the connection is set up and ready for use.  This function was  
....................    historically used to check for disconnections, but TCPWasReset is now a 
....................    more appropriate solution.  
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Return Values: 
....................      TRUE - The socket has an established connection to a remote node. 
....................      FALSE - The socket is not currently connected. 
....................  
....................   Remarks: 
....................    A socket is said to be connected only if it is in the TCP_ESTABLISHED 
....................    state.  Sockets in the process of opening or closing will return FALSE. 
....................   ***************************************************************************/ 
.................... BOOL TCPIsConnected(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
04B32:  MOVLB  2
04B34:  MOVF   x6A,W
04B36:  SUBLW  00
04B38:  BC    4B40
....................     { 
....................         return FALSE; 
04B3A:  MOVLW  00
04B3C:  MOVWF  01
04B3E:  BRA    4B5C
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
04B40:  MOVFF  26A,276
04B44:  MOVLB  0
04B46:  CALL   06DC
....................    return (MyTCBStub.smState == TCP_ESTABLISHED); 
04B4A:  MOVLB  1
04B4C:  MOVF   x31,W
04B4E:  SUBLW  07
04B50:  BZ    4B56
04B52:  MOVLW  00
04B54:  BRA    4B58
04B56:  MOVLW  01
04B58:  MOVWF  01
04B5A:  MOVLB  2
04B5C:  MOVLB  0
04B5E:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPDisconnect(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Disconnects an open socket. 
....................  
....................   Description: 
....................    This function closes a connection to a remote node by sending a FIN (if  
....................    currently connected). 
....................     
....................    The function can be called a second time to force a socket closed by  
....................    sending a RST packet.  This is useful when the application knows that  
....................    the remote node will not send an ACK (if it has crashed or lost its link), 
....................    or when the application needs to reuse the socket immediately regardless 
....................    of whether or not the remote node would like to transmit more data before 
....................    closing. 
....................     
....................    For client mode sockets, upon return, the hTCP handle is relinquished to  
....................    the TCP/IP stack and must no longer be used by the application (except for  
....................    an immediate subsequent call to TCPDisconnect() to force a RST  
....................    transmission, if needed).   
....................     
....................    For server mode sockets, upon return, the hTCP handle is NOT relinquished  
....................    to the TCP/IP stack.  After closing, the socket returns to the listening  
....................    state allowing future connection requests to be serviced.  This leaves the  
....................    hTCP handle in a valid state and must be retained for future operations on  
....................    the socket.  If you want to close the server and relinquish the socket back  
....................    to the TCP/IP stack, call the TCPClose() API instead of TCPDisconnect(). 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    hTCP - Handle of the socket to disconnect. 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    If the socket is using SSL, a CLOSE_NOTIFY record will be transmitted 
....................    first to allow the SSL session to be resumed at a later time. 
....................   ***************************************************************************/ 
.................... void TCPDisconnect(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
01DCC:  MOVLB  2
01DCE:  MOVF   x6A,W
01DD0:  SUBLW  00
01DD2:  BC    1DD6
....................     { 
....................         return; 
01DD4:  BRA    1EC2
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
01DD6:  MOVFF  26A,276
01DDA:  MOVLB  0
01DDC:  CALL   06DC
....................  
....................    // Delete all data in the RX FIFO 
....................    // In this stack's API, the application TCP handle is  
....................    // immediately invalid after calling this function, so there  
....................    // is no longer any way to receive data from the TCP RX FIFO,  
....................    // even though the data is still there.  Leaving the data there  
....................    // could interfere with the remote node sending us a FIN if our 
....................    // RX window is zero 
....................    MyTCBStub.rxTail = MyTCBStub.rxHead; 
01DE0:  MOVFF  126,128
01DE4:  MOVFF  125,127
....................  
....................    switch(MyTCBStub.smState) 
01DE8:  MOVLB  1
01DEA:  MOVF   x31,W
01DEC:  XORLW  00
01DEE:  MOVLB  0
01DF0:  BZ    1E1C
01DF2:  XORLW  02
01DF4:  BZ    1E1C
01DF6:  XORLW  01
01DF8:  BZ    1E1C
01DFA:  XORLW  06
01DFC:  BZ    1E1C
01DFE:  XORLW  03
01E00:  BZ    1E22
01E02:  XORLW  01
01E04:  BZ    1E22
01E06:  XORLW  0C
01E08:  BZ    1E64
01E0A:  XORLW  05
01E0C:  BZ    1EA6
01E0E:  XORLW  06
01E10:  BZ    1EB0
01E12:  XORLW  01
01E14:  BZ    1EB0
01E16:  XORLW  05
01E18:  BZ    1EB0
01E1A:  BRA    1EB0
....................    { 
....................       #if defined(STACK_CLIENT_MODE) && defined(STACK_USE_DNS) 
....................       case TCP_DNS_RESOLVE: 
....................          DNSEndUsage();   // Release the DNS module, since the user is aborting 
....................          CloseSocket(); 
....................          break; 
....................       #endif 
....................  
....................       case TCP_GET_DNS_MODULE: 
....................       case TCP_GATEWAY_SEND_ARP: 
....................       case TCP_GATEWAY_GET_ARP: 
....................       case TCP_SYN_SENT: 
....................          CloseSocket(); 
01E1C:  CALL   0B52
....................          break; 
01E20:  BRA    1EC0
....................  
....................       case TCP_SYN_RECEIVED: 
....................       case TCP_ESTABLISHED: 
....................          #if defined(STACK_USE_SSL) 
....................          // When disconnecting SSL sockets, send a close_notify so we can resume later 
....................          if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................          { 
....................             // Flush pending data and send close_notify 
....................             SSLTxRecord(hTCP, MyTCBStub.sslStubID, SSL_APPLICATION); 
....................             SSLTxMessage(hTCP, MyTCBStub.sslStubID, SSL_ALERT_CLOSE_NOTIFY); 
....................          } 
....................          #endif 
....................  
....................          // Send the FIN.  This is done in a loop to ensure that if we have  
....................          // more data wating in the TX FIFO than can be sent in a single  
....................          // packet (due to the remote Max Segment Size packet size limit),  
....................          // we will keep generating more packets until either all data gets  
....................          // transmitted or the remote node's receive window fills up. 
....................          do 
....................          { 
....................             SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS); 
01E22:  MOVLW  11
01E24:  MOVLB  2
01E26:  MOVWF  x75
01E28:  MOVLW  01
01E2A:  MOVWF  x76
01E2C:  MOVLB  0
01E2E:  RCALL  1774
....................             if(MyTCB.remoteWindow == 0u) 
01E30:  MOVF   xC9,F
01E32:  BNZ   1E3A
01E34:  MOVF   xCA,F
01E36:  BNZ   1E3A
....................                break; 
01E38:  BRA    1E5A
....................          } while(MyTCBStub.txHead != MyTCB.txUnackedTail); 
01E3A:  MOVF   xC3,W
01E3C:  MOVLB  1
01E3E:  SUBWF  x21,W
01E40:  BTFSC  FD8.2
01E42:  BRA    1E48
01E44:  MOVLB  0
01E46:  BRA    1E22
01E48:  MOVLB  0
01E4A:  MOVF   xC4,W
01E4C:  MOVLB  1
01E4E:  SUBWF  x22,W
01E50:  BTFSC  FD8.2
01E52:  BRA    1E58
01E54:  MOVLB  0
01E56:  BRA    1E22
01E58:  MOVLB  0
....................           
....................          MyTCBStub.smState = TCP_FIN_WAIT_1; 
01E5A:  MOVLW  08
01E5C:  MOVLB  1
01E5E:  MOVWF  x31
....................          break; 
01E60:  MOVLB  0
01E62:  BRA    1EC0
....................  
....................       case TCP_CLOSE_WAIT: 
....................          // Send the FIN.  This is done in a loop to ensure that if we have  
....................          // more data wating in the TX FIFO than can be sent in a single  
....................          // packet (due to the remote Max Segment Size packet size limit),  
....................          // we will keep generating more packets until either all data gets  
....................          // transmitted or the remote node's receive window fills up. 
....................          do 
....................          { 
....................             SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS); 
01E64:  MOVLW  11
01E66:  MOVLB  2
01E68:  MOVWF  x75
01E6A:  MOVLW  01
01E6C:  MOVWF  x76
01E6E:  MOVLB  0
01E70:  RCALL  1774
....................             if(MyTCB.remoteWindow == 0u) 
01E72:  MOVF   xC9,F
01E74:  BNZ   1E7C
01E76:  MOVF   xCA,F
01E78:  BNZ   1E7C
....................                break; 
01E7A:  BRA    1E9C
....................          } while(MyTCBStub.txHead != MyTCB.txUnackedTail); 
01E7C:  MOVF   xC3,W
01E7E:  MOVLB  1
01E80:  SUBWF  x21,W
01E82:  BTFSC  FD8.2
01E84:  BRA    1E8A
01E86:  MOVLB  0
01E88:  BRA    1E64
01E8A:  MOVLB  0
01E8C:  MOVF   xC4,W
01E8E:  MOVLB  1
01E90:  SUBWF  x22,W
01E92:  BTFSC  FD8.2
01E94:  BRA    1E9A
01E96:  MOVLB  0
01E98:  BRA    1E64
01E9A:  MOVLB  0
....................  
....................          MyTCBStub.smState = TCP_LAST_ACK; 
01E9C:  MOVLW  0C
01E9E:  MOVLB  1
01EA0:  MOVWF  x31
....................          break; 
01EA2:  MOVLB  0
01EA4:  BRA    1EC0
....................           
....................       // These states are all already closed or don't need explicit disconnecting -- they will disconnect by themselves after a while 
....................       //case TCP_CLOSED: 
....................       //case TCP_LISTEN: 
....................       //case TCP_CLOSING: 
....................       //case TCP_TIME_WAIT: 
....................       //   return; 
....................  
....................       case TCP_CLOSED_BUT_RESERVED: 
....................          MyTCBStub.smState = TCP_CLOSED; 
01EA6:  MOVLW  0D
01EA8:  MOVLB  1
01EAA:  MOVWF  x31
....................          break; 
01EAC:  MOVLB  0
01EAE:  BRA    1EC0
....................  
....................       // These states will close themselves after some delay, however,  
....................       // this is handled so that the user can call TCPDisconnect()  
....................       // twice to immediately close a socket (using an RST) without  
....................       // having to get an ACK back from the remote node.  This is  
....................       // great for instance when the application determines that  
....................       // the remote node has been physically disconnected and  
....................       // already knows that no ACK will be returned.  Alternatively,  
....................       // if the application needs to immediately reuse the socket  
....................       // regardless of what the other node's state is in (half open). 
....................       case TCP_FIN_WAIT_1: 
....................       case TCP_FIN_WAIT_2: 
....................       case TCP_LAST_ACK: 
....................       default: 
....................          SendTCP(RST | ACK, 0); 
01EB0:  MOVLW  14
01EB2:  MOVLB  2
01EB4:  MOVWF  x75
01EB6:  CLRF   x76
01EB8:  MOVLB  0
01EBA:  RCALL  1774
....................          CloseSocket(); 
01EBC:  CALL   0B52
....................          break; 
01EC0:  MOVLB  2
....................    } 
01EC2:  MOVLB  0
01EC4:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPClose(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Disconnects an open socket and destroys the socket handle, including server  
....................    mode socket handles. 
....................  
....................   Description: 
....................    Disconnects an open socket and destroys the socket handle, including server  
....................    mode socket handles.  This function performs identically to the  
....................    TCPDisconnect() function, except that both client and server mode socket  
....................    handles are relinquished to the TCP/IP stack upon return. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    hTCP - Handle to the socket to disconnect and close. 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... void TCPClose(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    MyTCBStub.Flags.bServer = FALSE; 
....................    TCPDisconnect(hTCP); 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    SOCKET_INFO* TCPGetRemoteInfo(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Obtains information about a currently open socket. 
....................  
....................   Description: 
....................    Returns the SOCKET_INFO structure associated with this socket.  This  
....................    contains the NODE_INFO structure with IP and MAC address (or gateway 
....................    MAC) and the remote port. 
....................  
....................   Precondition: 
....................    TCP is initialized and the socket is connected. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    The SOCKET_INFO structure associated with this socket.  This structure is  
....................    allocated statically by the function and is valid only until the next  
....................    time TCPGetRemoteInfo() is called. 
....................   ***************************************************************************/ 
.................... SOCKET_INFO* TCPGetRemoteInfo(TCP_SOCKET hTCP) 
.................... { 
....................    static SOCKET_INFO   RemoteInfo; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    SyncTCB(); 
....................    memcpy((void*)&RemoteInfo.remote, (void*)&MyTCB.remote, sizeof(NODE_INFO)); 
....................    RemoteInfo.remotePort.Val = MyTCB.remotePort.Val; 
....................  
....................    return &RemoteInfo; 
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Transmit Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPFlush(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Immediately transmits all pending TX data. 
....................  
....................   Description: 
....................    This function immediately transmits all pending TX data with a PSH  
....................    flag.  If this function is not called, data will automatically be sent 
....................    when either a) the TX buffer is half full or b) the  
....................    TCP_AUTO_TRANSMIT_TIMEOUT_VAL (default: 40ms) has elapsed. 
....................  
....................   Precondition: 
....................    TCP is initialized and the socket is connected. 
....................  
....................   Parameters: 
....................    hTCP - The socket whose data is to be transmitted. 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    SSL application data is automatically flushed, so this function has  
....................    no effect for SSL sockets. 
....................   ***************************************************************************/ 
.................... void TCPFlush(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
05016:  MOVLB  2
05018:  MOVF   x74,W
0501A:  SUBLW  00
0501C:  BC    5020
....................     { 
....................         return; 
0501E:  BRA    5054
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
05020:  MOVFF  274,276
05024:  MOVLB  0
05026:  CALL   06DC
....................    SyncTCB(); 
0502A:  CALL   0A7E
....................  
....................    // NOTE: Pending SSL data will NOT be transferred here 
....................  
....................    if(MyTCBStub.txHead != MyTCB.txUnackedTail) 
0502E:  MOVF   xC3,W
05030:  MOVLB  1
05032:  SUBWF  x21,W
05034:  BNZ   5040
05036:  MOVLB  0
05038:  MOVF   xC4,W
0503A:  MOVLB  1
0503C:  SUBWF  x22,W
0503E:  BZ    5052
....................    { 
....................       // Send the TCP segment with all unacked bytes 
....................       SendTCP(ACK, SENDTCP_RESET_TIMERS); 
05040:  MOVLW  10
05042:  MOVLB  2
05044:  MOVWF  x75
05046:  MOVLW  01
05048:  MOVWF  x76
0504A:  MOVLB  0
0504C:  CALL   1774
05050:  MOVLB  1
05052:  MOVLB  2
....................    } 
05054:  MOVLB  0
05056:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPIsPutReady(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines how much free space is available in the TCP TX buffer. 
....................  
....................   Description: 
....................    Call this function to determine how many bytes can be written to the  
....................    TCP TX buffer.  If this function returns zero, the application must  
....................    return to the main stack loop before continuing in order to transmit 
....................    more data. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    The number of bytes available to be written in the TCP TX buffer. 
....................   ***************************************************************************/ 
.................... WORD TCPIsPutReady(TCP_SOCKET hTCP) 
.................... { 
....................    BYTE i; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
04E6C:  MOVLB  2
04E6E:  MOVF   x74,W
04E70:  SUBLW  00
04E72:  BC    4E7C
....................     { 
....................         return 0; 
04E74:  MOVLW  00
04E76:  MOVWF  01
04E78:  MOVWF  02
04E7A:  BRA    4F16
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
04E7C:  MOVFF  274,276
04E80:  MOVLB  0
04E82:  CALL   06DC
....................  
....................    i = MyTCBStub.smState; 
04E86:  MOVFF  131,275
....................  
....................    // Unconnected sockets shouldn't be transmitting anything. 
....................    if(!( (i == (BYTE)TCP_ESTABLISHED) || (i == (BYTE)TCP_CLOSE_WAIT) )) 
04E8A:  MOVLB  2
04E8C:  MOVF   x75,W
04E8E:  SUBLW  07
04E90:  BZ    4EA0
04E92:  MOVF   x75,W
04E94:  SUBLW  0B
04E96:  BZ    4EA0
....................       return 0; 
04E98:  MOVLW  00
04E9A:  MOVWF  01
04E9C:  MOVWF  02
04E9E:  BRA    4F16
....................  
....................    // Calculate the free space in this socket's TX FIFO 
....................    #if defined(STACK_USE_SSL) 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    {// Use sslTxHead as the head pointer when SSL is active 
....................       WORD rem; 
....................        
....................       // Find out raw free space 
....................       if(MyTCBStub.sslTxHead >= MyTCBStub.txTail) 
....................          rem = (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.sslTxHead - MyTCBStub.txTail); 
....................       else 
....................          rem = MyTCBStub.txTail - MyTCBStub.sslTxHead - 1; 
....................           
....................       // Reserve space for a new MAC and header 
....................       if(rem > 22u) 
....................          return rem - 22; 
....................       else 
....................          return 0; 
....................    } 
....................    #endif 
....................     
....................    if(MyTCBStub.txHead >= MyTCBStub.txTail) 
04EA0:  MOVLB  1
04EA2:  MOVF   x24,W
04EA4:  SUBWF  x22,W
04EA6:  BNC   4EF2
04EA8:  BNZ   4EB0
04EAA:  MOVF   x23,W
04EAC:  SUBWF  x21,W
04EAE:  BNC   4EF2
....................       return (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.txHead - MyTCBStub.txTail); 
04EB0:  MOVF   x1B,W
04EB2:  SUBWF  x1D,W
04EB4:  MOVLB  2
04EB6:  MOVWF  x76
04EB8:  MOVLB  1
04EBA:  MOVF   x1C,W
04EBC:  SUBWFB x1E,W
04EBE:  MOVLB  2
04EC0:  MOVWF  x77
04EC2:  MOVLW  01
04EC4:  SUBWF  x76,F
04EC6:  MOVLW  00
04EC8:  SUBWFB x77,F
04ECA:  MOVLB  1
04ECC:  MOVF   x23,W
04ECE:  SUBWF  x21,W
04ED0:  MOVWF  00
04ED2:  MOVF   x24,W
04ED4:  SUBWFB x22,W
04ED6:  MOVWF  03
04ED8:  MOVF   00,W
04EDA:  MOVLB  2
04EDC:  SUBWF  x76,W
04EDE:  MOVWF  00
04EE0:  MOVF   03,W
04EE2:  SUBWFB x77,W
04EE4:  MOVWF  03
04EE6:  MOVFF  00,01
04EEA:  MOVWF  02
04EEC:  BRA    4F16
04EEE:  BRA    4F16
04EF0:  MOVLB  1
....................    else 
....................       return MyTCBStub.txTail - MyTCBStub.txHead - 1; 
04EF2:  MOVF   x21,W
04EF4:  SUBWF  x23,W
04EF6:  MOVLB  2
04EF8:  MOVWF  x76
04EFA:  MOVLB  1
04EFC:  MOVF   x22,W
04EFE:  SUBWFB x24,W
04F00:  MOVLB  2
04F02:  MOVWF  x77
04F04:  MOVLW  01
04F06:  SUBWF  x76,W
04F08:  MOVWF  00
04F0A:  MOVLW  00
04F0C:  SUBWFB x77,W
04F0E:  MOVWF  03
04F10:  MOVFF  00,01
04F14:  MOVWF  02
04F16:  MOVLB  0
04F18:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPPut(TCP_SOCKET hTCP, BYTE byte) 
....................  
....................   Description: 
....................    Writes a single byte to a TCP socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    byte - The byte to write. 
....................  
....................   Return Values: 
....................    TRUE - The byte was written to the transmit buffer. 
....................    FALSE - The transmit buffer was full, or the socket is not connected. 
....................   ***************************************************************************/ 
.................... BOOL TCPPut(TCP_SOCKET hTCP, BYTE byte) 
.................... { 
....................    WORD wFreeTXSpace; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
05058:  MOVLB  2
0505A:  MOVF   x70,W
0505C:  SUBLW  00
0505E:  BC    5066
....................     { 
....................         return 0; 
05060:  MOVLW  00
05062:  MOVWF  01
05064:  BRA    5172
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
05066:  MOVFF  270,276
0506A:  MOVLB  0
0506C:  CALL   06DC
....................  
....................    wFreeTXSpace = TCPIsPutReady(hTCP); 
05070:  MOVFF  270,274
05074:  RCALL  4E6C
05076:  MOVFF  02,273
0507A:  MOVFF  01,272
....................    if(wFreeTXSpace == 0u) 
0507E:  MOVLB  2
05080:  MOVF   x72,F
05082:  BNZ   5090
05084:  MOVF   x73,F
05086:  BNZ   5090
....................       return FALSE; 
05088:  MOVLW  00
0508A:  MOVWF  01
0508C:  BRA    5172
0508E:  BRA    50A2
....................    else if(wFreeTXSpace == 1u) // About to run out of space, lets transmit so the remote node might send an ACK back faster 
05090:  DECFSZ x72,W
05092:  BRA    50A2
05094:  MOVF   x73,F
05096:  BNZ   50A2
....................       TCPFlush(hTCP);    
05098:  MOVFF  270,274
0509C:  MOVLB  0
0509E:  RCALL  5016
050A0:  MOVLB  2
....................  
....................    // Send all current bytes if we are crossing half full 
....................    // This is required to improve performance with the delayed  
....................    // acknowledgement algorithm 
....................    if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1))) 
050A2:  MOVLB  1
050A4:  BTFSC  x33.0
050A6:  BRA    50EC
050A8:  MOVF   x1B,W
050AA:  SUBWF  x1D,W
050AC:  MOVLB  2
050AE:  MOVWF  x74
050B0:  MOVLB  1
050B2:  MOVF   x1C,W
050B4:  SUBWFB x1E,W
050B6:  MOVLB  2
050B8:  MOVWF  x75
050BA:  BCF    FD8.0
050BC:  RRCF   x75,W
050BE:  MOVWF  03
050C0:  RRCF   x74,W
050C2:  MOVWF  02
050C4:  MOVWF  01
050C6:  MOVF   x73,W
050C8:  SUBWF  03,W
050CA:  BTFSC  FD8.0
050CC:  BRA    50D2
050CE:  MOVLB  1
050D0:  BRA    50EC
050D2:  BNZ   50E0
050D4:  MOVF   x72,W
050D6:  SUBWF  01,W
050D8:  BTFSC  FD8.0
050DA:  BRA    50E0
050DC:  MOVLB  1
050DE:  BRA    50EC
....................    { 
....................       TCPFlush(hTCP);    
050E0:  MOVFF  270,274
050E4:  MOVLB  0
050E6:  RCALL  5016
....................       MyTCBStub.Flags.bHalfFullFlush = TRUE; 
050E8:  MOVLB  1
050EA:  BSF    x33.0
....................    } 
....................  
....................    #if defined(STACK_USE_SSL) 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    { 
....................       TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte)); 
....................       if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    else 
....................    { 
....................       TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte)); 
....................       if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    #else 
....................    TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte)); 
050EC:  MOVLW  02
050EE:  MOVLB  2
050F0:  MOVWF  x75
050F2:  MOVLW  71
050F4:  MOVWF  x74
050F6:  MOVFF  122,2A7
050FA:  MOVFF  121,2A6
050FE:  MOVFF  136,2A8
05102:  MOVFF  275,2AA
05106:  MOVWF  xA9
05108:  MOVLW  01
0510A:  MOVWF  xAB
0510C:  CLRF   xAD
0510E:  MOVWF  xAC
05110:  MOVLB  0
05112:  CALL   0998
....................    if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart) 
05116:  MOVLB  1
05118:  INCF   x21,F
0511A:  BTFSC  FD8.2
0511C:  INCF   x22,F
0511E:  MOVF   x1E,W
05120:  SUBWF  x22,W
05122:  BNC   5134
05124:  BNZ   512C
05126:  MOVF   x1D,W
05128:  SUBWF  x21,W
0512A:  BNC   5134
....................       MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
0512C:  MOVFF  11C,122
05130:  MOVFF  11B,121
....................    #endif 
....................     
....................  
....................    // Send the last byte as a separate packet (likely will make the remote node send back ACK faster) 
....................    if(wFreeTXSpace == 1u) 
05134:  MOVLB  2
05136:  DECFSZ x72,W
05138:  BRA    5148
0513A:  MOVF   x73,F
0513C:  BNZ   5148
....................    { 
....................       TCPFlush(hTCP); 
0513E:  MOVFF  270,274
05142:  MOVLB  0
05144:  RCALL  5016
....................    } 
05146:  BRA    516C
....................    // If not already enabled, start a timer so this data will  
....................    // eventually get sent even if the application doens't call 
....................    // TCPFlush() 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
05148:  MOVLB  1
0514A:  BTFSC  x32.5
0514C:  BRA    516A
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
0514E:  BSF    x32.5
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull; 
05150:  MOVLB  0
05152:  CALL   0EB8
05156:  MOVLW  06
05158:  MOVLB  2
0515A:  ADDWF  00,W
0515C:  MOVLB  1
0515E:  MOVWF  x2D
05160:  MOVLW  00
05162:  MOVLB  2
05164:  ADDWFC 01,W
05166:  MOVLB  1
05168:  MOVWF  x2E
0516A:  MOVLB  0
....................    } 
....................  
....................    return TRUE; 
0516C:  MOVLW  01
0516E:  MOVWF  01
05170:  MOVLB  2
05172:  MOVLB  0
05174:  GOTO   5182 (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPPutArray(TCP_SOCKET hTCP, BYTE* data, WORD len) 
....................  
....................   Description: 
....................    Writes an array from RAM to a TCP socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    data - Pointer to the array to be written. 
....................    len  - Number of bytes to be written. 
....................  
....................   Returns: 
....................    The number of bytes written to the socket.  If less than len, the 
....................    buffer became full or the socket is not conected. 
....................   ***************************************************************************/ 
.................... WORD TCPPutArray(TCP_SOCKET hTCP, BYTE* data, WORD len) 
.................... { 
....................    WORD wActualLen; 
....................    WORD wFreeTXSpace; 
....................    WORD wRightLen = 0; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    wFreeTXSpace = TCPIsPutReady(hTCP); 
....................    if(wFreeTXSpace == 0u) 
....................    { 
....................       TCPFlush(hTCP); 
....................       return 0; 
....................    } 
....................  
....................    wActualLen = wFreeTXSpace; 
....................    if(wFreeTXSpace > len) 
....................       wActualLen = len; 
....................  
....................    // Send all current bytes if we are crossing half full 
....................    // This is required to improve performance with the delayed  
....................    // acknowledgement algorithm 
....................    if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1))) 
....................    { 
....................       TCPFlush(hTCP);    
....................       MyTCBStub.Flags.bHalfFullFlush = TRUE; 
....................    } 
....................     
....................    #if defined(STACK_USE_SSL) 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    { 
....................       // See if we need a two part put 
....................       if(MyTCBStub.sslTxHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................       { 
....................          wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead; 
....................          TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen); 
....................          data += wRightLen; 
....................          wActualLen -= wRightLen; 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................       } 
....................     
....................       TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen); 
....................       MyTCBStub.sslTxHead += wActualLen; 
....................    } 
....................    else 
....................    { 
....................       // See if we need a two part put 
....................       if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................       { 
....................          wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead; 
....................          TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen); 
....................          data += wRightLen; 
....................          wActualLen -= wRightLen; 
....................          MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................       } 
....................     
....................       TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen); 
....................       MyTCBStub.txHead += wActualLen; 
....................    } 
....................    #else 
....................    // See if we need a two part put 
....................    if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................    { 
....................       wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead; 
....................       TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen); 
....................       data += wRightLen; 
....................       wActualLen -= wRightLen; 
....................       MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................    } 
....................  
....................    TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen); 
....................    MyTCBStub.txHead += wActualLen; 
....................    #endif 
....................  
....................    // Send these bytes right now if we are out of TX buffer space 
....................    if(wFreeTXSpace <= len) 
....................    { 
....................       TCPFlush(hTCP); 
....................    } 
....................    // If not already enabled, start a timer so this data will  
....................    // eventually get sent even if the application doens't call 
....................    // TCPFlush() 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull; 
....................    } 
....................  
....................    return wActualLen + wRightLen; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPPutROMArray(TCP_SOCKET hTCP, ROM BYTE* data, WORD len) 
....................  
....................   Description: 
....................    Writes an array from ROM to a TCP socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    data - Pointer to the array to be written. 
....................    len  - Number of bytes to be written. 
....................  
....................   Returns: 
....................    The number of bytes written to the socket.  If less than len, the 
....................    buffer became full or the socket is not conected. 
....................  
....................   Remarks: 
....................    This function is aliased to TCPPutArray on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... WORD TCPPutROMArray(TCP_SOCKET hTCP, ROM BYTE* data, WORD len) 
.................... { 
....................    WORD wActualLen; 
....................    WORD wFreeTXSpace; 
....................    WORD wRightLen = 0; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    wFreeTXSpace = TCPIsPutReady(hTCP); 
....................    if(wFreeTXSpace == 0u) 
....................    { 
....................       TCPFlush(hTCP); 
....................       return 0; 
....................    } 
....................  
....................    // Send all current bytes if we are crossing half full 
....................    // This is required to improve performance with the delayed  
....................    // acknowledgement algorithm 
....................    if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1))) 
....................    { 
....................       TCPFlush(hTCP);    
....................       MyTCBStub.Flags.bHalfFullFlush = TRUE; 
....................    } 
....................     
....................    wActualLen = wFreeTXSpace; 
....................    if(wFreeTXSpace > len) 
....................       wActualLen = len; 
....................     
....................    #if defined(STACK_USE_SSL) 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    { 
....................       // See if we need a two part put 
....................       if(MyTCBStub.sslTxHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................       { 
....................          wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead; 
....................          TCPRAMCopyROM(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, data, wRightLen); 
....................          data += wRightLen; 
....................          wActualLen -= wRightLen; 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................       } 
....................     
....................       TCPRAMCopyROM(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, data, wActualLen); 
....................       MyTCBStub.sslTxHead += wActualLen; 
....................    } 
....................    else 
....................    { 
....................       // See if we need a two part put 
....................       if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................       { 
....................          wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead; 
....................          TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wRightLen); 
....................          data += wRightLen; 
....................          wActualLen -= wRightLen; 
....................          MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................       } 
....................     
....................       TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wActualLen); 
....................       MyTCBStub.txHead += wActualLen; 
....................    } 
....................    #else 
....................    // See if we need a two part put 
....................    if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................    { 
....................       wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead; 
....................       TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wRightLen); 
....................       data += wRightLen; 
....................       wActualLen -= wRightLen; 
....................       MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................    } 
....................  
....................    TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wActualLen); 
....................    MyTCBStub.txHead += wActualLen; 
....................    #endif 
....................  
....................    // Send these bytes right now if we are out of TX buffer space 
....................    if(wFreeTXSpace <= len) 
....................    { 
....................       TCPFlush(hTCP); 
....................    } 
....................    // If not already enabled, start a timer so this data will  
....................    // eventually get sent even if the application doens't call 
....................    // TCPFlush() 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull; 
....................    } 
....................  
....................    return wActualLen + wRightLen; 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE* TCPPutString(TCP_SOCKET hTCP, BYTE* data) 
....................  
....................   Description: 
....................    Writes a null-terminated string from RAM to a TCP socket.  The  
....................    null-terminator is not copied to the socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    data - Pointer to the string to be written. 
....................  
....................   Returns: 
....................    Pointer to the byte following the last byte written to the socket.  If 
....................    this pointer does not dereference to a NUL byte, the buffer became full 
....................    or the socket is not connected. 
....................  
....................   Remarks: 
....................    The return value of this function differs from that of TCPPutArray.  To 
....................    write long strings in a single state, initialize the *data pointer to the 
....................    first byte, then call this function repeatedly (breaking to the main  
....................    stack loop after each call) until the return value dereferences to a NUL 
....................    byte.  Save the return value as the new starting *data pointer otherwise. 
....................   ***************************************************************************/ 
.................... BYTE* TCPPutString(TCP_SOCKET hTCP, BYTE* data) 
.................... { 
....................    return data + TCPPutArray(hTCP, data, strlen((char*)data)); 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE* TCPPutROMString(TCP_SOCKET hTCP, ROM BYTE* data) 
....................  
....................   Description: 
....................    Writes a null-terminated string from ROM to a TCP socket.  The  
....................    null-terminator is not copied to the socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    data - Pointer to the string to be written. 
....................  
....................   Returns: 
....................    Pointer to the byte following the last byte written to the socket.  If 
....................    this pointer does not dereference to a NUL byte, the buffer became full 
....................    or the socket is not connected. 
....................  
....................   Remarks: 
....................    The return value of this function differs from that of TCPPutArray.  To 
....................    write long strings in a single state, initialize the *data pointer to the 
....................    first byte, then call this function repeatedly (breaking to the main  
....................    stack loop after each call) until the return value dereferences to a NUL 
....................    byte.  Save the return value as the new starting *data pointer otherwise. 
....................     
....................    This function is aliased to TCPPutString on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... ROM BYTE* TCPPutROMString(TCP_SOCKET hTCP, ROM BYTE* data) 
.................... { 
....................    return data + TCPPutROMArray(hTCP, data, strlenpgm((ROM char*)data)); 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPGetTxFIFOFull(TCP_SOCKET hTCP) 
....................  
....................   Description: 
....................    Determines how many bytes are pending in the TCP TX FIFO. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    Number of bytes pending to be flushed in the TCP TX FIFO. 
....................   ***************************************************************************/ 
.................... WORD TCPGetTxFIFOFull(TCP_SOCKET hTCP) 
.................... { 
....................    WORD wDataLen; 
....................    WORD wFIFOSize; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    // Calculate total usable FIFO size 
....................    wFIFOSize = MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1; 
....................  
....................    // Find out how many data bytes are free in the TX FIFO 
....................    wDataLen = TCPIsPutReady(hTCP); 
....................  
....................    return wFIFOSize - wDataLen; 
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Receive Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPDiscard(TCP_SOCKET hTCP) 
....................  
....................   Description: 
....................    Discards any pending data in the TCP RX FIFO. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket whose RX FIFO is to be cleared. 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... void TCPDiscard(TCP_SOCKET hTCP) 
.................... { 
....................    if(TCPIsGetReady(hTCP)) 
....................    { 
....................       SyncTCBStub(hTCP); 
....................     
....................       // Delete all data in the RX buffer 
....................       MyTCBStub.rxTail = MyTCBStub.rxHead; 
....................     
....................       // Send a Window update message to the remote node 
....................       SendTCP(ACK, SENDTCP_RESET_TIMERS); 
....................    } 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void WORD TCPIsGetReady(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines how many bytes can be read from the TCP RX buffer. 
....................  
....................   Description: 
....................    Call this function to determine how many bytes can be read from the  
....................    TCP RX buffer.  If this function returns zero, the application must  
....................    return to the main stack loop before continuing in order to wait for 
....................    more data to arrive. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    The number of bytes available to be read from the TCP RX buffer. 
....................   ***************************************************************************/ 
.................... WORD TCPIsGetReady(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
04D3C:  MOVLB  2
04D3E:  MOVF   x6F,W
04D40:  SUBLW  00
04D42:  BC    4D4C
....................     { 
....................         return 0; 
04D44:  MOVLW  00
04D46:  MOVWF  01
04D48:  MOVWF  02
04D4A:  BRA    4DB8
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
04D4C:  MOVFF  26F,276
04D50:  MOVLB  0
04D52:  CALL   06DC
....................        
....................    if(MyTCBStub.rxHead >= MyTCBStub.rxTail) 
04D56:  MOVLB  1
04D58:  MOVF   x28,W
04D5A:  SUBWF  x26,W
04D5C:  BNC   4D80
04D5E:  BNZ   4D66
04D60:  MOVF   x27,W
04D62:  SUBWF  x25,W
04D64:  BNC   4D80
....................       return MyTCBStub.rxHead - MyTCBStub.rxTail; 
04D66:  MOVF   x27,W
04D68:  SUBWF  x25,W
04D6A:  MOVWF  00
04D6C:  MOVF   x28,W
04D6E:  SUBWFB x26,W
04D70:  MOVWF  03
04D72:  MOVFF  00,01
04D76:  MOVWF  02
04D78:  MOVLB  2
04D7A:  BRA    4DB8
04D7C:  BRA    4DB8
04D7E:  MOVLB  1
....................    else 
....................       return (MyTCBStub.bufferEnd - MyTCBStub.rxTail + 1) + (MyTCBStub.rxHead - MyTCBStub.bufferRxStart); 
04D80:  MOVF   x27,W
04D82:  SUBWF  x1F,W
04D84:  MOVLB  2
04D86:  MOVWF  x70
04D88:  MOVLB  1
04D8A:  MOVF   x28,W
04D8C:  SUBWFB x20,W
04D8E:  MOVLB  2
04D90:  MOVWF  x71
04D92:  MOVLW  01
04D94:  ADDWF  x70,F
04D96:  MOVLW  00
04D98:  ADDWFC x71,F
04D9A:  MOVLB  1
04D9C:  MOVF   x1D,W
04D9E:  SUBWF  x25,W
04DA0:  MOVWF  00
04DA2:  MOVF   x1E,W
04DA4:  SUBWFB x26,W
04DA6:  MOVWF  03
04DA8:  MOVF   00,W
04DAA:  MOVLB  2
04DAC:  ADDWF  x70,W
04DAE:  MOVWF  01
04DB0:  MOVF   x71,W
04DB2:  ADDWFC 03,F
04DB4:  MOVFF  03,02
04DB8:  MOVLB  0
04DBA:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPGet(TCP_SOCKET hTCP, BYTE* byte) 
....................  
....................   Description: 
....................    Retrieves a single byte to a TCP socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket from which to read. 
....................    byte - Pointer to location in which the read byte should be stored. 
....................  
....................   Return Values: 
....................    TRUE - A byte was read from the buffer. 
....................    FALSE - The buffer was empty, or the socket is not connected. 
....................   ***************************************************************************/ 
.................... BOOL TCPGet(TCP_SOCKET hTCP, BYTE* byte) 
.................... { 
....................    WORD wGetReadyCount; 
....................  
....................    // See if there is any data which can be read 
....................    wGetReadyCount = TCPIsGetReady(hTCP); 
04DBC:  MOVFF  26A,26F
04DC0:  RCALL  4D3C
04DC2:  MOVFF  02,26E
04DC6:  MOVFF  01,26D
....................    if(wGetReadyCount == 0u) 
04DCA:  MOVLB  2
04DCC:  MOVF   x6D,F
04DCE:  BNZ   4DDA
04DD0:  MOVF   x6E,F
04DD2:  BNZ   4DDA
....................       return FALSE; 
04DD4:  MOVLW  00
04DD6:  MOVWF  01
04DD8:  BRA    4E66
....................  
....................    SyncTCBStub(hTCP); 
04DDA:  MOVFF  26A,276
04DDE:  MOVLB  0
04DE0:  CALL   06DC
....................     
....................    if(byte) 
04DE4:  MOVLB  2
04DE6:  MOVF   x6B,W
04DE8:  IORWF  x6C,W
04DEA:  BZ    4E10
....................       TCPRAMCopy((PTR_BASE)byte, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, 1); 
04DEC:  MOVFF  26C,2A7
04DF0:  MOVFF  26B,2A6
04DF4:  MOVLW  01
04DF6:  MOVWF  xA8
04DF8:  MOVFF  128,2AA
04DFC:  MOVFF  127,2A9
04E00:  MOVFF  136,2AB
04E04:  CLRF   xAD
04E06:  MOVWF  xAC
04E08:  MOVLB  0
04E0A:  CALL   0998
04E0E:  MOVLB  2
....................    if(++MyTCBStub.rxTail > MyTCBStub.bufferEnd) 
04E10:  MOVLB  1
04E12:  INCF   x27,F
04E14:  BTFSC  FD8.2
04E16:  INCF   x28,F
04E18:  MOVF   x20,W
04E1A:  SUBWF  x28,W
04E1C:  BNC   4E2E
04E1E:  BNZ   4E26
04E20:  MOVF   x27,W
04E22:  SUBWF  x1F,W
04E24:  BC    4E2E
....................       MyTCBStub.rxTail = MyTCBStub.bufferRxStart; 
04E26:  MOVFF  11E,128
04E2A:  MOVFF  11D,127
....................  
....................    // Send a window update if we've run out of data 
....................    if(wGetReadyCount == 1u) 
04E2E:  MOVLB  2
04E30:  DECFSZ x6D,W
04E32:  BRA    4E3E
04E34:  MOVF   x6E,F
04E36:  BNZ   4E3E
....................    { 
....................       MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
04E38:  MOVLB  1
04E3A:  BSF    x33.2
....................    } 
04E3C:  BRA    4E60
....................    // If not already enabled, start a timer so a window  
....................    // update will get sent to the remote node at some point 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
04E3E:  MOVLB  1
04E40:  BTFSC  x32.5
04E42:  BRA    4E60
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
04E44:  BSF    x32.5
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_WINDOW_UPDATE_TIMEOUT_VAL/256ull; 
04E46:  MOVLB  0
04E48:  CALL   0EB8
04E4C:  MOVLW  1F
04E4E:  MOVLB  2
04E50:  ADDWF  00,W
04E52:  MOVLB  1
04E54:  MOVWF  x2D
04E56:  MOVLW  00
04E58:  MOVLB  2
04E5A:  ADDWFC 01,W
04E5C:  MOVLB  1
04E5E:  MOVWF  x2E
....................    } 
....................  
....................  
....................    return TRUE; 
04E60:  MOVLW  01
04E62:  MOVWF  01
04E64:  MOVLB  2
04E66:  MOVLB  0
04E68:  GOTO   53EC (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPGetArray(TCP_SOCKET hTCP, BYTE* buffer, WORD len) 
....................  
....................   Description: 
....................    Reads an array of data bytes from a TCP socket's receive FIFO.  The data  
....................    is removed from the FIFO in the process. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket from which data is to be read. 
....................    buffer - Pointer to the array to store data that was read. 
....................    len  - Number of bytes to be read. 
....................  
....................   Returns: 
....................    The number of bytes read from the socket.  If less than len, the 
....................    RX FIFO buffer became empty or the socket is not conected. 
....................   ***************************************************************************/ 
.................... WORD TCPGetArray(TCP_SOCKET hTCP, BYTE* buffer, WORD len) 
.................... { 
....................    WORD wGetReadyCount; 
....................    WORD RightLen = 0; 
....................  
....................    // See if there is any data which can be read 
....................    wGetReadyCount = TCPIsGetReady(hTCP); 
....................    if(wGetReadyCount == 0u) 
....................       return 0x0000u; 
....................  
....................    SyncTCBStub(hTCP); 
....................  
....................    // Make sure we don't try to read more data than is available 
....................    if(len > wGetReadyCount) 
....................       len = wGetReadyCount; 
....................  
....................    // See if we need a two part get 
....................    if(MyTCBStub.rxTail + len > MyTCBStub.bufferEnd) 
....................    { 
....................       RightLen = MyTCBStub.bufferEnd - MyTCBStub.rxTail + 1; 
....................       if(buffer) 
....................       { 
....................          TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, RightLen); 
....................          buffer += RightLen; 
....................       } 
....................       len -= RightLen; 
....................       MyTCBStub.rxTail = MyTCBStub.bufferRxStart; 
....................    } 
....................  
....................    if(buffer) 
....................       TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, len); 
....................    MyTCBStub.rxTail += len; 
....................    len += RightLen; 
....................  
....................    // Send a window update if we've run low on data 
....................    if(wGetReadyCount - len <= len) 
....................    { 
....................       MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
....................    } 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
....................    // If not already enabled, start a timer so a window  
....................    // update will get sent to the remote node at some point 
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_WINDOW_UPDATE_TIMEOUT_VAL/256ull; 
....................    } 
....................  
....................    return len; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPGetRxFIFOFree(TCP_SOCKET hTCP) 
....................  
....................   Description: 
....................    Determines how many bytes are free in the RX FIFO. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    The number of bytes free in the TCP RX FIFO.  If zero, no additional  
....................    data can be received until the application removes some data using one 
....................    of the TCPGet family functions. 
....................   ***************************************************************************/ 
.................... WORD TCPGetRxFIFOFree(TCP_SOCKET hTCP) 
.................... { 
....................    WORD wDataLen; 
....................    WORD wFIFOSize; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    // Calculate total usable FIFO size 
....................    wFIFOSize = MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart; 
....................  
....................    #if defined(STACK_USE_SSL) 
....................    { 
....................       PTR_BASE SSLtemp = MyTCBStub.rxHead; 
....................  
....................       // Move SSL pointer to determine full buffer size 
....................       if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................          MyTCBStub.rxHead = MyTCBStub.sslRxHead; 
....................  
....................       // Find out how many data bytes are actually in the RX FIFO 
....................       wDataLen = TCPIsGetReady(hTCP); 
....................        
....................       // Move SSL pointer back to proper location (if we changed it) 
....................       MyTCBStub.rxHead = SSLtemp; 
....................    } 
....................    #else 
....................    { 
....................       // Find out how many data bytes are actually in the RX FIFO 
....................       wDataLen = TCPIsGetReady(hTCP); 
....................    } 
....................    #endif 
....................     
....................    // Perform the calculation    
....................    return wFIFOSize - wDataLen; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPPeekArray(TCP_SOCKET hTCP, BYTE *vBuffer, WORD wLen, WORD wStart) 
....................  
....................   Summary: 
....................      Reads a specified number of data bytes from the TCP RX FIFO without  
....................      removing them from the buffer. 
....................  
....................   Description: 
....................    Reads a specified number of data bytes from the TCP RX FIFO without  
....................      removing them from the buffer.  No TCP control actions are taken as a  
....................      result of this function (ex: no window update is sent to the remote node). 
....................       
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to peak from (read without removing from stream). 
....................    vBuffer - Destination to write the peeked data bytes. 
....................    wLen - Length of bytes to peak from the RX FIFO and copy to vBuffer. 
....................    wStart - Zero-indexed starting position within the FIFO to start peeking  
....................       from. 
....................  
....................   Return Values: 
....................    Number of bytes actually peeked from the stream and copied to vBuffer.   
....................    This value can be less than wLen if wStart + wLen is greater than the  
....................    deepest possible character in the RX FIFO. 
....................  
....................   Remarks: 
....................      None 
....................   ***************************************************************************/ 
.................... WORD TCPPeekArray(TCP_SOCKET hTCP, BYTE *vBuffer, WORD wLen, WORD wStart) 
.................... { 
....................    PTR_BASE ptrRead; 
....................    WORD w; 
....................    WORD wBytesUntilWrap; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT || wLen == 0) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    // Find out how many bytes are in the RX FIFO and decrease read length  
....................    // if the start offset + read length is beyond the end of the FIFO 
....................    w = TCPIsGetReady(hTCP); 
....................    if(wStart + wLen > w) 
....................       wLen = w - wStart; 
....................  
....................    // Find the read start location 
....................    ptrRead = MyTCBStub.rxTail + wStart; 
....................    if(ptrRead > MyTCBStub.bufferEnd) 
....................       ptrRead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................  
....................    // Calculate how many bytes can be read in a single go 
....................    wBytesUntilWrap = MyTCBStub.bufferEnd - ptrRead + 1; 
....................    if(wLen <= wBytesUntilWrap) 
....................    { 
....................       // Read all at once 
....................       TCPRAMCopy((PTR_BASE)vBuffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, wLen); 
....................    } 
....................    else 
....................    { 
....................       // Read all bytes up to the wrap position and then read remaining bytes  
....................       // at the start of the buffer 
....................       TCPRAMCopy((PTR_BASE)vBuffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, wBytesUntilWrap); 
....................       TCPRAMCopy((PTR_BASE)vBuffer+wBytesUntilWrap, TCP_PIC_RAM, MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, wLen - wBytesUntilWrap); 
....................    } 
....................     
....................    return wLen; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE TCPPeek(TCP_SOCKET hTCP, WORD wStart) 
....................  
....................   Summary: 
....................      Peaks at one byte in the TCP RX FIFO without removing it from the buffer. 
....................  
....................   Description: 
....................    Peaks at one byte in the TCP RX FIFO without removing it from the buffer. 
....................       
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to peak from (read without removing from stream). 
....................    wStart - Zero-indexed starting position within the FIFO to peek from. 
....................  
....................   Return Values: 
....................    Byte peeked from the RX FIFO.  If there is no data in the buffer or an  
....................    illegal wStart starting offset is given, then an indeterminate value is  
....................    returned.  The caller must ensure that valid parameters are passed to avoid  
....................    (i.e ensure that TCPIsGetReady() returns a number that is less than wStart  
....................    before calling TCPPeek()). 
....................  
....................   Remarks: 
....................      Use the TCPPeekArray() function to read more than one byte.  It will  
....................      perform better than calling TCPPeek() in a loop. 
....................   ***************************************************************************/ 
.................... BYTE TCPPeek(TCP_SOCKET hTCP, WORD wStart) 
.................... { 
....................    BYTE i; 
....................     
....................    TCPPeekArray(hTCP, &i, 1, wStart); 
....................    return i; 
.................... } 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Search Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPFindArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen,  
....................                   WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
....................  
....................   Summary: 
....................      Searches for a string in the TCP RX buffer. 
....................  
....................   Description: 
....................    This function finds the first occurrance of an array of bytes in the 
....................    TCP RX buffer.  It can be used by an application to abstract searches  
....................    out of their own application code.  For increased efficiency, the  
....................    function is capable of limiting the scope of search to a specific 
....................    range of bytes.  It can also perform a case-insensitive search if 
....................    required. 
....................     
....................    For example, if the buffer contains "I love PIC MCUs!" and the search 
....................    array is "love" with a length of 4, a value of 2 will be returned. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to search within. 
....................    cFindArray - The array of bytes to find in the buffer. 
....................    wLen - Length of cFindArray. 
....................    wStart - Zero-indexed starting position within the buffer. 
....................    wSearchLen - Length from wStart to search in the buffer. 
....................    bTextCompare - TRUE for case-insensitive text search, FALSE for binary search 
....................  
....................   Return Values: 
....................    0xFFFF - Search array not found 
....................    Otherwise - Zero-indexed position of the first occurrance 
....................  
....................   Remarks: 
....................    Since this function usually must transfer data from external storage 
....................    to internal RAM for comparison, its performance degrades significantly 
....................    when the buffer is full and the array is not found.  For better  
....................    performance, try to search for characters that are expected to exist or 
....................    limit the scope of the search as much as possible.  The HTTP2 module,  
....................    for example, uses this function to parse headers.  However, it searches  
....................    for newlines, then the separating colon, then reads the header name to  
....................    RAM for final comparison.  This has proven to be significantly faster   
....................    than searching for full header name strings outright. 
....................   ***************************************************************************/ 
.................... WORD TCPFindArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
.................... { 
....................    PTR_BASE ptrRead; 
....................    WORD wDataLen; 
....................    WORD wBytesUntilWrap; 
....................    PTR_BASE ptrLocation; 
....................    WORD wLenStart; 
....................    BYTE *cFindArrayStart; 
....................    BYTE i, j, k; 
....................    BOOL isFinding; 
....................    BYTE buffer[32]; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT || wLen == 0) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    // Find out how many bytes are in the RX FIFO and return  
....................    // immediately if we won't possibly find a match 
....................    wDataLen = TCPIsGetReady(hTCP) - wStart; 
....................    if(wDataLen < wLen) 
....................       return 0xFFFFu; 
....................    if(wSearchLen && (wDataLen > wSearchLen)) 
....................       wDataLen = wSearchLen; 
....................  
....................    ptrLocation = MyTCBStub.rxTail + wStart; 
....................    if(ptrLocation > MyTCBStub.bufferEnd) 
....................       ptrLocation -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................    ptrRead = ptrLocation; 
....................    wBytesUntilWrap = MyTCBStub.bufferEnd - ptrLocation + 1; 
....................    ptrLocation = wStart; 
....................    wLenStart = wLen; 
....................    cFindArrayStart = cFindArray; 
....................    j = *cFindArray++; 
....................    isFinding = FALSE; 
....................    if(bTextCompare) 
....................    { 
....................       if(j >= 'a' && j <= 'z') 
....................          j += 'A'-'a'; 
....................    } 
....................  
....................    // Search for the array 
....................    while(1) 
....................    { 
....................       // Figure out how big of a chunk to read 
....................       k = sizeof(buffer); 
....................       if(k > wBytesUntilWrap) 
....................          k = wBytesUntilWrap; 
....................       if((WORD)k > wDataLen) 
....................          k = wDataLen; 
....................  
....................       // Read a chunk of data into the buffer 
....................       TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, (WORD)k); 
....................       ptrRead += k; 
....................       wBytesUntilWrap -= k; 
....................  
....................       if(wBytesUntilWrap == 0u) 
....................       { 
....................          ptrRead = MyTCBStub.bufferRxStart; 
....................          wBytesUntilWrap = 0xFFFFu; 
....................       } 
....................  
....................       // Convert everything to uppercase 
....................       if(bTextCompare) 
....................       { 
....................          for(i = 0; i < k; i++) 
....................          { 
....................             if(buffer[i] >= 'a' && buffer[i] <= 'z') 
....................                buffer[i] += 'A'-'a'; 
....................  
....................             if(j == buffer[i]) 
....................             { 
....................                if(--wLen == 0u) 
....................                   return ptrLocation-wLenStart + i + 1; 
....................                j = *cFindArray++; 
....................                isFinding = TRUE; 
....................                if(j >= 'a' && j <= 'z') 
....................                   j += 'A'-'a'; 
....................             } 
....................             else 
....................             { 
....................                wLen = wLenStart; 
....................                if(isFinding) 
....................                { 
....................                   cFindArray = cFindArrayStart; 
....................                   j = *cFindArray++; 
....................                   if(j >= 'a' && j <= 'z') 
....................                      j += 'A'-'a'; 
....................                   isFinding = FALSE; 
....................                } 
....................             } 
....................          } 
....................       } 
....................       else   // Compare as is 
....................       { 
....................          for(i = 0; i < k; i++) 
....................          { 
....................             if(j == buffer[i]) 
....................             { 
....................                if(--wLen == 0u) 
....................                   return ptrLocation-wLenStart + i + 1; 
....................                j = *cFindArray++; 
....................                isFinding = TRUE; 
....................             } 
....................             else 
....................             { 
....................                wLen = wLenStart; 
....................                if(isFinding) 
....................                { 
....................                   cFindArray = cFindArrayStart; 
....................                   j = *cFindArray++; 
....................                   isFinding = FALSE; 
....................                } 
....................             } 
....................          } 
....................       } 
....................  
....................       // Check to see if it is impossible to find a match 
....................       wDataLen -= k; 
....................       if(wDataLen < wLen) 
....................          return 0xFFFFu; 
....................  
....................       ptrLocation += k; 
....................    } 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPFindROMArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen,  
....................                   WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
....................  
....................   Summary: 
....................      Searches for a ROM string in the TCP RX buffer. 
....................  
....................   Description: 
....................    This function finds the first occurrance of an array of bytes in the 
....................    TCP RX buffer.  It can be used by an application to abstract searches  
....................    out of their own application code.  For increased efficiency, the  
....................    function is capable of limiting the scope of search to a specific 
....................    range of bytes.  It can also perform a case-insensitive search if 
....................    required. 
....................     
....................    For example, if the buffer contains "I love PIC MCUs!" and the search 
....................    array is "love" with a length of 4, a value of 2 will be returned. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to search within. 
....................    cFindArray - The array of bytes to find in the buffer. 
....................    wLen - Length of cFindArray. 
....................    wStart - Zero-indexed starting position within the buffer. 
....................    wSearchLen - Length from wStart to search in the buffer. 
....................    bTextCompare - TRUE for case-insensitive text search, FALSE for binary search 
....................  
....................   Return Values: 
....................    0xFFFF - Search array not found 
....................    Otherwise - Zero-indexed position of the first occurrance 
....................  
....................   Remarks: 
....................    Since this function usually must transfer data from external storage 
....................    to internal RAM for comparison, its performance degrades significantly 
....................    when the buffer is full and the array is not found.  For better  
....................    performance, try to search for characters that are expected to exist or 
....................    limit the scope of the search as much as possible.  The HTTP2 module,  
....................    for example, uses this function to parse headers.  However, it searches  
....................    for newlines, then the separating colon, then reads the header name to  
....................    RAM for final comparison.  This has proven to be significantly faster   
....................    than searching for full header name strings outright. 
....................     
....................    This function is aliased to TCPFindArrayEx on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... WORD TCPFindROMArrayEx(TCP_SOCKET hTCP, ROM BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
.................... { 
....................    PTR_BASE ptrRead; 
....................    WORD wDataLen; 
....................    WORD wBytesUntilWrap; 
....................    PTR_BASE ptrLocation; 
....................    WORD wLenStart; 
....................    ROM BYTE *cFindArrayStart; 
....................    BYTE i, j, k; 
....................    BOOL isFinding; 
....................    BYTE buffer[32]; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT || wLen == 0) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    // Find out how many bytes are in the RX FIFO and return  
....................    // immediately if we won't possibly find a match 
....................    wDataLen = TCPIsGetReady(hTCP) - wStart; 
....................    if(wDataLen < wLen) 
....................       return 0xFFFFu; 
....................    if(wSearchLen && (wDataLen > wSearchLen)) 
....................       wDataLen = wSearchLen; 
....................  
....................    ptrLocation = MyTCBStub.rxTail + wStart; 
....................    if(ptrLocation > MyTCBStub.bufferEnd) 
....................       ptrLocation -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................    ptrRead = ptrLocation; 
....................    wBytesUntilWrap = MyTCBStub.bufferEnd - ptrLocation + 1; 
....................    ptrLocation = wStart; 
....................    wLenStart = wLen; 
....................    cFindArrayStart = cFindArray; 
....................    j = *cFindArray++; 
....................    isFinding = FALSE; 
....................    if(bTextCompare) 
....................    { 
....................       if(j >= 'a' && j <= 'z') 
....................          j += 'A'-'a'; 
....................    } 
....................  
....................    // Search for the array 
....................    while(1) 
....................    { 
....................       // Figure out how big of a chunk to read 
....................       k = sizeof(buffer); 
....................       if(k > wBytesUntilWrap) 
....................          k = wBytesUntilWrap; 
....................       if((WORD)k > wDataLen) 
....................          k = wDataLen; 
....................  
....................       // Read a chunk of data into the buffer 
....................       TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, (WORD)k); 
....................       ptrRead += k; 
....................       wBytesUntilWrap -= k; 
....................  
....................       if(wBytesUntilWrap == 0u) 
....................       { 
....................          ptrRead = MyTCBStub.bufferRxStart; 
....................          wBytesUntilWrap = 0xFFFFu; 
....................       } 
....................  
....................       // Convert everything to uppercase 
....................       if(bTextCompare) 
....................       { 
....................          for(i = 0; i < k; i++) 
....................          { 
....................             if(buffer[i] >= 'a' && buffer[i] <= 'z') 
....................                buffer[i] += 'A'-'a'; 
....................  
....................             if(j == buffer[i]) 
....................             { 
....................                if(--wLen == 0u) 
....................                   return ptrLocation-wLenStart + i + 1; 
....................                j = *cFindArray++; 
....................                isFinding = TRUE; 
....................                if(j >= 'a' && j <= 'z') 
....................                   j += 'A'-'a'; 
....................             } 
....................             else 
....................             { 
....................                wLen = wLenStart; 
....................                if(isFinding) 
....................                { 
....................                   cFindArray = cFindArrayStart; 
....................                   j = *cFindArray++; 
....................                   if(j >= 'a' && j <= 'z') 
....................                      j += 'A'-'a'; 
....................                   isFinding = FALSE; 
....................                } 
....................             } 
....................          } 
....................       } 
....................       else   // Compare as is 
....................       { 
....................          for(i = 0; i < k; i++) 
....................          { 
....................             if(j == buffer[i]) 
....................             { 
....................                if(--wLen == 0u) 
....................                   return ptrLocation-wLenStart + i + 1; 
....................                j = *cFindArray++; 
....................                isFinding = TRUE; 
....................             } 
....................             else 
....................             { 
....................                wLen = wLenStart; 
....................                if(isFinding) 
....................                { 
....................                   cFindArray = cFindArrayStart; 
....................                   j = *cFindArray++; 
....................                   isFinding = FALSE; 
....................                } 
....................             } 
....................          } 
....................       } 
....................  
....................       // Check to see if it is impossible to find a match 
....................       wDataLen -= k; 
....................       if(wDataLen < wLen) 
....................          return 0xFFFFu; 
....................  
....................       ptrLocation += k; 
....................    } 
.................... } 
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPFindEx(TCP_SOCKET hTCP, BYTE cFind, 
....................                   WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
....................  
....................   Summary: 
....................      Searches for a byte in the TCP RX buffer. 
....................  
....................   Description: 
....................    This function finds the first occurrance of a byte in the TCP RX 
....................    buffer.  It can be used by an application to abstract searches  
....................    out of their own application code.  For increased efficiency, the  
....................    function is capable of limiting the scope of search to a specific 
....................    range of bytes.  It can also perform a case-insensitive search if 
....................    required. 
....................     
....................    For example, if the buffer contains "I love PIC MCUs!" and the cFind 
....................    byte is ' ', a value of 1 will be returned. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to search within. 
....................    cFind - The byte to find in the buffer. 
....................    wStart - Zero-indexed starting position within the buffer. 
....................    wSearchLen - Length from wStart to search in the buffer. 
....................    bTextCompare - TRUE for case-insensitive text search, FALSE for binary search 
....................  
....................   Return Values: 
....................    0xFFFF - Search array not found 
....................    Otherwise - Zero-indexed position of the first occurrance 
....................  
....................   Remarks: 
....................    Since this function usually must transfer data from external storage 
....................    to internal RAM for comparison, its performance degrades significantly 
....................    when the buffer is full and the array is not found.  For better  
....................    performance, try to search for characters that are expected to exist or 
....................    limit the scope of the search as much as possible.  The HTTP2 module,  
....................    for example, uses this function to parse headers.  However, it searches  
....................    for newlines, then the separating colon, then reads the header name to  
....................    RAM for final comparison.  This has proven to be significantly faster   
....................    than searching for full header name strings outright. 
....................   ***************************************************************************/ 
.................... WORD TCPFindEx(TCP_SOCKET hTCP, BYTE cFind, WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
.................... { 
....................    return TCPFindArrayEx(hTCP, &cFind, sizeof(cFind), wStart, wSearchLen, bTextCompare); 
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Data Processing Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPTick(void) 
....................  
....................   Summary: 
....................      Performs periodic TCP tasks. 
....................  
....................   Description: 
....................    This function performs any required periodic TCP tasks.  Each  
....................    socket's state machine is checked, and any elapsed timeout periods 
....................    are handled. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... void TCPTick(void) 
.................... { 
....................    TCP_SOCKET hTCP; 
....................    BOOL bRetransmit; 
....................    BOOL bCloseSocket; 
....................    BYTE vFlags; 
....................    WORD w; 
....................  
....................    // Periodically all "not closed" sockets must perform timed operations 
....................    for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++) 
*
0224E:  MOVLB  1
02250:  CLRF   x76
02252:  MOVF   x76,F
02254:  BTFSS  FD8.2
02256:  BRA    293C
....................    { 
....................       SyncTCBStub(hTCP); 
02258:  MOVFF  176,276
0225C:  MOVLB  0
0225E:  CALL   06DC
....................        
....................       // Handle any SSL Processing and Message Transmission 
....................       #if defined(STACK_USE_SSL) 
....................       if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       { 
....................          // Handle any periodic tasks, such as RSA operations 
....................          SSLPeriodic(hTCP, MyTCBStub.sslStubID); 
....................           
....................          // If unsent data is waiting, transmit it as an application record 
....................          if(MyTCBStub.sslTxHead != MyTCBStub.txHead && TCPSSLGetPendingTxSize(hTCP) != 0u) 
....................             SSLTxRecord(hTCP, MyTCBStub.sslStubID, SSL_APPLICATION); 
....................           
....................          // If an SSL message is requested, send it now 
....................          if(MyTCBStub.sslReqMessage != SSL_NO_MESSAGE) 
....................             SSLTxMessage(hTCP, MyTCBStub.sslStubID, MyTCBStub.sslReqMessage); 
....................       } 
....................       #endif 
....................        
....................       vFlags = 0x00; 
02262:  MOVLB  1
02264:  CLRF   x78
....................       bRetransmit = FALSE; 
02266:  BCF    x77.0
....................       bCloseSocket = FALSE; 
02268:  BCF    x77.1
....................  
....................       // Transmit ASAP data if the medium is available 
....................       if(MyTCBStub.Flags.bTXASAP || MyTCBStub.Flags.bTXASAPWithoutTimerReset) 
0226A:  BTFSC  x33.1
0226C:  BRA    2272
0226E:  BTFSS  x33.2
02270:  BRA    2288
....................       { 
....................          if(MACIsTxReady()) 
02272:  MOVLB  0
02274:  CALL   0E7E
02278:  MOVF   01,F
0227A:  BZ    228A
....................          { 
....................             vFlags = ACK; 
0227C:  MOVLW  10
0227E:  MOVLB  1
02280:  MOVWF  x78
....................             bRetransmit = MyTCBStub.Flags.bTXASAPWithoutTimerReset; 
02282:  BCF    x77.0
02284:  BTFSC  x33.2
02286:  BSF    x77.0
02288:  MOVLB  0
....................          } 
....................       } 
....................  
....................       // Perform any needed window updates and data transmissions 
....................       if(MyTCBStub.Flags.bTimer2Enabled) 
0228A:  MOVLB  1
0228C:  BTFSS  x32.5
0228E:  BRA    22BC
....................       { 
....................          // See if the timeout has occured, and we need to send a new window update and pending data 
....................          if((SHORT)(MyTCBStub.eventTime2 - (WORD)TickGetDiv256()) <= (SHORT)0) 
02290:  MOVLB  0
02292:  CALL   0EB8
02296:  MOVF   00,W
02298:  MOVLB  1
0229A:  SUBWF  x2D,W
0229C:  MOVWF  00
0229E:  MOVF   01,W
022A0:  SUBWFB x2E,W
022A2:  MOVWF  03
022A4:  MOVFF  00,17B
022A8:  MOVWF  x7C
022AA:  BTFSC  FE8.7
022AC:  BRA    22B8
022AE:  MOVF   x7C,F
022B0:  BNZ   22BC
022B2:  MOVF   x7B,W
022B4:  SUBLW  00
022B6:  BNC   22BC
....................             vFlags = ACK; 
022B8:  MOVLW  10
022BA:  MOVWF  x78
....................       } 
....................  
....................       // Process Delayed ACKnowledgement timer 
....................       if(MyTCBStub.Flags.bDelayedACKTimerEnabled) 
022BC:  BTFSS  x32.6
022BE:  BRA    22EC
....................       { 
....................          // See if the timeout has occured and delayed ACK needs to be sent 
....................          if((SHORT)(MyTCBStub.OverlappedTimers.delayedACKTime - (WORD)TickGetDiv256()) <= (SHORT)0) 
022C0:  MOVLB  0
022C2:  CALL   0EB8
022C6:  MOVF   00,W
022C8:  MOVLB  1
022CA:  SUBWF  x2F,W
022CC:  MOVWF  00
022CE:  MOVF   01,W
022D0:  SUBWFB x30,W
022D2:  MOVWF  03
022D4:  MOVFF  00,17B
022D8:  MOVWF  x7C
022DA:  BTFSC  FE8.7
022DC:  BRA    22E8
022DE:  MOVF   x7C,F
022E0:  BNZ   22EC
022E2:  MOVF   x7B,W
022E4:  SUBLW  00
022E6:  BNC   22EC
....................             vFlags = ACK; 
022E8:  MOVLW  10
022EA:  MOVWF  x78
....................       } 
....................        
....................       // Process TCP_CLOSE_WAIT timer 
....................       if(MyTCBStub.smState == TCP_CLOSE_WAIT) 
022EC:  MOVF   x31,W
022EE:  SUBLW  0B
022F0:  BNZ   2322
....................       { 
....................          // Automatically close the socket on our end if the application  
....................          // fails to call TCPDisconnect() is a reasonable amount of time. 
....................          if((SHORT)(MyTCBStub.OverlappedTimers.closeWaitTime - (WORD)TickGetDiv256()) <= (SHORT)0) 
022F2:  MOVLB  0
022F4:  CALL   0EB8
022F8:  MOVF   00,W
022FA:  MOVLB  1
022FC:  SUBWF  x2F,W
022FE:  MOVWF  00
02300:  MOVF   01,W
02302:  SUBWFB x30,W
02304:  MOVWF  03
02306:  MOVFF  00,17B
0230A:  MOVWF  x7C
0230C:  BTFSC  FE8.7
0230E:  BRA    231A
02310:  MOVF   x7C,F
02312:  BNZ   2322
02314:  MOVF   x7B,W
02316:  SUBLW  00
02318:  BNC   2322
....................          { 
....................             vFlags = FIN | ACK; 
0231A:  MOVLW  11
0231C:  MOVWF  x78
....................             MyTCBStub.smState = TCP_LAST_ACK; 
0231E:  MOVLW  0C
02320:  MOVWF  x31
....................          } 
....................       } 
....................  
....................       // Process listening server sockets that might have a SYN waiting in the SYNQueue[] 
....................       #if TCP_SYN_QUEUE_MAX_ENTRIES 
....................          if(MyTCBStub.smState == TCP_LISTEN) 
02322:  MOVF   x31,W
02324:  SUBLW  04
02326:  BTFSS  FD8.2
02328:  BRA    25C8
....................          { 
....................             for(w = 0; w < TCP_SYN_QUEUE_MAX_ENTRIES; w++) 
0232A:  CLRF   x7A
0232C:  CLRF   x79
0232E:  MOVF   x7A,F
02330:  BTFSS  FD8.2
02332:  BRA    25C8
02334:  MOVF   x79,W
02336:  SUBLW  02
02338:  BTFSS  FD8.0
0233A:  BRA    25C8
....................             { 
....................                // Abort search if there are no more valid records 
....................                if(SYNQueue[w].wDestPort == 0u) 
0233C:  MOVFF  17A,1AC
02340:  MOVFF  179,1AB
02344:  CLRF   xAE
02346:  MOVLW  14
02348:  MOVWF  xAD
0234A:  MOVLB  0
0234C:  CALL   0EDC
02350:  MOVFF  01,17B
02354:  MOVLW  10
02356:  MOVLB  1
02358:  ADDWF  01,W
0235A:  MOVWF  01
0235C:  MOVLW  00
0235E:  ADDWFC 02,W
02360:  MOVWF  03
02362:  MOVF   01,W
02364:  ADDLW  DF
02366:  MOVWF  FE9
02368:  MOVLW  00
0236A:  ADDWFC 03,W
0236C:  MOVWF  FEA
0236E:  MOVFF  FEC,17C
02372:  MOVF   FED,F
02374:  MOVFF  FEF,17B
02378:  MOVF   x7B,F
0237A:  BNZ   2382
0237C:  MOVF   x7C,F
0237E:  BNZ   2382
....................                   break; 
02380:  BRA    25C8
....................                 
....................                // Stop searching if this SYN queue entry can be used by this socket 
....................                #if defined(STACK_USE_SSL_SERVER) 
....................                if(SYNQueue[w].wDestPort == MyTCBStub.remoteHash.Val || SYNQueue[w].wDestPort == MyTCBStub.sslTxHead) 
....................                #else 
....................                if(SYNQueue[w].wDestPort == MyTCBStub.remoteHash.Val) 
02382:  MOVFF  17A,1AC
02386:  MOVFF  179,1AB
0238A:  CLRF   xAE
0238C:  MOVLW  14
0238E:  MOVWF  xAD
02390:  MOVLB  0
02392:  CALL   0EDC
02396:  MOVFF  01,17B
0239A:  MOVLW  10
0239C:  MOVLB  1
0239E:  ADDWF  01,W
023A0:  MOVWF  01
023A2:  MOVLW  00
023A4:  ADDWFC 02,W
023A6:  MOVWF  03
023A8:  MOVF   01,W
023AA:  ADDLW  DF
023AC:  MOVWF  FE9
023AE:  MOVLW  00
023B0:  ADDWFC 03,W
023B2:  MOVWF  FEA
023B4:  MOVFF  FEC,17C
023B8:  MOVF   FED,F
023BA:  MOVFF  FEF,17B
023BE:  MOVF   x34,W
023C0:  SUBWF  x7B,W
023C2:  BTFSS  FD8.2
023C4:  BRA    25C0
023C6:  MOVF   x35,W
023C8:  SUBWF  x7C,W
023CA:  BTFSS  FD8.2
023CC:  BRA    25C0
....................                #endif 
....................                { 
....................                   // Set up our socket and generate a reponse SYN+ACK packet 
....................                   SyncTCB(); 
023CE:  MOVLB  0
023D0:  CALL   0A7E
....................                    
....................                   #if defined(STACK_USE_SSL_SERVER) 
....................                   // If this matches the SSL port, make sure that can be configured 
....................                   // before continuing.  If not, break and leave this in the queue 
....................                   if(SYNQueue[w].wDestPort == MyTCBStub.sslTxHead && !TCPStartSSLServer(hTCP)) 
....................                      break; 
....................                   #endif 
....................                    
....................                   memcpy((void*)&MyTCB.remote.niRemoteMACIP, (void*)&SYNQueue[w].niSourceAddress, sizeof(NODE_INFO)); 
023D4:  MOVLB  1
023D6:  CLRF   x7C
023D8:  MOVLW  CD
023DA:  MOVWF  x7B
023DC:  MOVFF  17A,1AC
023E0:  MOVFF  179,1AB
023E4:  CLRF   xAE
023E6:  MOVLW  14
023E8:  MOVWF  xAD
023EA:  MOVLB  0
023EC:  CALL   0EDC
023F0:  MOVFF  02,17E
023F4:  MOVFF  01,17D
023F8:  MOVLW  DF
023FA:  MOVLB  1
023FC:  ADDWF  01,W
023FE:  MOVWF  01
02400:  MOVLW  00
02402:  ADDWFC 02,W
02404:  MOVWF  03
02406:  MOVFF  01,17F
0240A:  MOVWF  x80
0240C:  MOVFF  17C,FEA
02410:  MOVFF  17B,FE9
02414:  MOVWF  FE2
02416:  MOVFF  01,FE1
0241A:  MOVLW  0A
0241C:  MOVWF  01
0241E:  MOVFF  FE6,FEE
02422:  DECFSZ 01,F
02424:  BRA    241E
....................                   MyTCB.remotePort.Val = SYNQueue[w].wSourcePort; 
02426:  MOVFF  17A,1AC
0242A:  MOVFF  179,1AB
0242E:  CLRF   xAE
02430:  MOVLW  14
02432:  MOVWF  xAD
02434:  MOVLB  0
02436:  CALL   0EDC
0243A:  MOVFF  01,17B
0243E:  MOVLW  0A
02440:  MOVLB  1
02442:  ADDWF  01,W
02444:  MOVWF  01
02446:  MOVLW  00
02448:  ADDWFC 02,W
0244A:  MOVWF  03
0244C:  MOVF   01,W
0244E:  ADDLW  DF
02450:  MOVWF  FE9
02452:  MOVLW  00
02454:  ADDWFC 03,W
02456:  MOVWF  FEA
02458:  MOVFF  FEC,C6
0245C:  MOVF   FED,F
0245E:  MOVFF  FEF,C5
....................                   MyTCB.RemoteSEQ = SYNQueue[w].dwSourceSEQ + 1; 
02462:  MOVFF  17A,1AC
02466:  MOVFF  179,1AB
0246A:  CLRF   xAE
0246C:  MOVLW  14
0246E:  MOVWF  xAD
02470:  MOVLB  0
02472:  CALL   0EDC
02476:  MOVFF  01,17B
0247A:  MOVLW  0C
0247C:  MOVLB  1
0247E:  ADDWF  01,W
02480:  MOVWF  01
02482:  MOVLW  00
02484:  ADDWFC 02,W
02486:  MOVWF  03
02488:  MOVF   01,W
0248A:  ADDLW  DF
0248C:  MOVWF  FE9
0248E:  MOVLW  00
02490:  ADDWFC 03,W
02492:  MOVWF  FEA
02494:  MOVFF  FEF,17B
02498:  MOVFF  FEC,17C
0249C:  MOVFF  FEC,17D
024A0:  MOVFF  FEC,17E
024A4:  MOVLW  01
024A6:  ADDWF  x7B,W
024A8:  MOVLB  0
024AA:  MOVWF  xBF
024AC:  MOVLW  00
024AE:  MOVLB  1
024B0:  ADDWFC x7C,W
024B2:  MOVLB  0
024B4:  MOVWF  xC0
024B6:  MOVLW  00
024B8:  MOVLB  1
024BA:  ADDWFC x7D,W
024BC:  MOVLB  0
024BE:  MOVWF  xC1
024C0:  MOVLW  00
024C2:  MOVLB  1
024C4:  ADDWFC x7E,W
024C6:  MOVLB  0
024C8:  MOVWF  xC2
....................                   MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1] + MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val; 
024CA:  MOVF   xCD,W
024CC:  ADDWF  xCF,W
024CE:  MOVLB  1
024D0:  MOVWF  x7B
024D2:  MOVLB  0
024D4:  MOVF   xCE,W
024D6:  ADDWFC xD0,W
024D8:  MOVLB  1
024DA:  MOVWF  x7C
024DC:  MOVLB  0
024DE:  MOVF   xC5,W
024E0:  MOVLB  1
024E2:  ADDWF  x7B,F
024E4:  MOVLB  0
024E6:  MOVF   xC6,W
024E8:  MOVLB  1
024EA:  ADDWFC x7C,F
024EC:  MOVF   x7B,W
024EE:  MOVLB  0
024F0:  XORWF  xC7,W
024F2:  MOVLB  1
024F4:  MOVWF  x34
024F6:  MOVF   x7C,W
024F8:  MOVLB  0
024FA:  XORWF  xC8,W
024FC:  MOVLB  1
024FE:  MOVWF  x35
....................                   vFlags = SYN | ACK; 
02500:  MOVLW  12
02502:  MOVWF  x78
....................                   MyTCBStub.smState = TCP_SYN_RECEIVED; 
02504:  MOVLW  06
02506:  MOVWF  x31
....................                    
....................                   // Delete this SYN from the SYNQueue and compact the SYNQueue[] array 
....................                   TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE)); 
02508:  MOVFF  17A,1AC
0250C:  MOVFF  179,1AB
02510:  CLRF   xAE
02512:  MOVLW  14
02514:  MOVWF  xAD
02516:  MOVLB  0
02518:  CALL   0EDC
0251C:  MOVFF  02,03
02520:  MOVF   01,W
02522:  ADDLW  DF
02524:  MOVWF  01
02526:  MOVLW  00
02528:  ADDWFC 03,F
0252A:  MOVFF  01,17B
0252E:  MOVLB  1
02530:  MOVFF  03,17C
02534:  MOVLW  01
02536:  ADDWF  x79,W
02538:  MOVWF  x7D
0253A:  MOVLW  00
0253C:  ADDWFC x7A,W
0253E:  MOVWF  x7E
02540:  MOVWF  xAC
02542:  MOVFF  17D,1AB
02546:  CLRF   xAE
02548:  MOVLW  14
0254A:  MOVWF  xAD
0254C:  MOVLB  0
0254E:  CALL   0EDC
02552:  MOVFF  02,03
02556:  MOVF   01,W
02558:  ADDLW  DF
0255A:  MOVWF  01
0255C:  MOVLW  00
0255E:  ADDWFC 03,F
02560:  MOVFF  01,17D
02564:  MOVLB  1
02566:  MOVFF  03,17E
0256A:  MOVLW  02
0256C:  BSF    FD8.0
0256E:  SUBFWB x79,W
02570:  MOVWF  x7F
02572:  MOVLW  00
02574:  SUBFWB x7A,W
02576:  MOVWF  x80
02578:  MOVWF  xAC
0257A:  MOVFF  17F,1AB
0257E:  CLRF   xAE
02580:  MOVLW  14
02582:  MOVWF  xAD
02584:  MOVLB  0
02586:  CALL   0EDC
0258A:  MOVFF  02,180
0258E:  MOVFF  01,17F
02592:  MOVFF  17C,2A7
02596:  MOVFF  17B,2A6
0259A:  MOVLW  01
0259C:  MOVLB  2
0259E:  MOVWF  xA8
025A0:  MOVFF  17E,2AA
025A4:  MOVFF  17D,2A9
025A8:  MOVWF  xAB
025AA:  MOVFF  02,2AD
025AE:  MOVFF  01,2AC
025B2:  MOVLB  0
025B4:  CALL   0998
....................                   SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort = 0u; 
025B8:  MOVLB  1
025BA:  CLRF   x18
025BC:  CLRF   x17
....................     
....................                   break; 
025BE:  BRA    25C8
....................                } 
025C0:  INCF   x79,F
025C2:  BTFSC  FD8.2
025C4:  INCF   x7A,F
025C6:  BRA    232E
....................             } 
....................          } 
....................       #endif 
....................  
....................       if(vFlags) 
025C8:  MOVF   x78,F
025CA:  BZ    25E8
....................          SendTCP(vFlags, bRetransmit ? 0 : SENDTCP_RESET_TIMERS); 
025CC:  BTFSS  x77.0
025CE:  BRA    25D4
025D0:  MOVLW  00
025D2:  BRA    25D6
025D4:  MOVLW  01
025D6:  MOVWF  x7B
025D8:  MOVFF  178,275
025DC:  MOVFF  FE8,276
025E0:  MOVLB  0
025E2:  CALL   1774
025E6:  MOVLB  1
....................  
....................       // The TCP_CLOSED, TCP_LISTEN, and sometimes the TCP_ESTABLISHED  
....................       // state don't need any timeout events, so see if the timer is enabled 
....................       if(!MyTCBStub.Flags.bTimerEnabled) 
025E8:  BTFSC  x32.4
025EA:  BRA    2698
....................       { 
....................          #if defined(TCP_KEEP_ALIVE_TIMEOUT) 
....................             // Only the established state has any use for keep-alives 
....................             if(MyTCBStub.smState == TCP_ESTABLISHED) 
025EC:  MOVF   x31,W
025EE:  SUBLW  07
025F0:  BNZ   2696
....................             { 
....................                // If timeout has not occured, do not do anything. 
....................                if((LONG)(TickGet() - MyTCBStub.eventTime) < (LONG)0) 
025F2:  MOVLB  0
025F4:  CALL   0E34
025F8:  MOVFF  03,17E
025FC:  MOVFF  02,17D
02600:  MOVFF  01,17C
02604:  MOVFF  00,17B
02608:  MOVLB  1
0260A:  MOVF   x29,W
0260C:  SUBWF  00,W
0260E:  MOVWF  00
02610:  MOVF   x2A,W
02612:  SUBWFB 01,W
02614:  MOVWF  01
02616:  MOVF   x2B,W
02618:  SUBWFB 02,W
0261A:  MOVWF  02
0261C:  MOVF   x2C,W
0261E:  SUBWFB 03,W
02620:  MOVWF  03
02622:  MOVWF  x7E
02624:  MOVFF  02,17D
02628:  MOVFF  01,17C
0262C:  MOVFF  00,17B
02630:  BTFSS  FE8.7
02632:  BRA    2636
....................                   continue; 
02634:  BRA    2938
....................        
....................                // If timeout has occured and the connection appears to be dead (no  
....................                // responses from remote node at all), close the connection so the  
....................                // application doesn't sit around indefinitely with a useless socket  
....................                // that it thinks is still open 
....................                if(MyTCBStub.Flags.vUnackedKeepalives == TCP_MAX_UNACKED_KEEP_ALIVES) 
02636:  MOVF   x32,W
02638:  ANDLW  07
0263A:  SUBLW  06
0263C:  BNZ   2662
....................                { 
....................                   vFlags = MyTCBStub.Flags.bServer; 
0263E:  CLRF   x78
02640:  BTFSC  x32.3
02642:  INCF   x78,F
....................  
....................                   // Force an immediate FIN and RST transmission 
....................                   // Double calling TCPDisconnect() will also place us  
....................                   // back in the listening state immediately if a server socket. 
....................                   TCPDisconnect(hTCP); 
02644:  MOVFF  176,26A
02648:  MOVLB  0
0264A:  CALL   1DCC
....................                   TCPDisconnect(hTCP); 
0264E:  MOVFF  176,26A
02652:  CALL   1DCC
....................                    
....................                   // Prevent client mode sockets from getting reused by other applications.   
....................                   // The application must call TCPDisconnect() with the handle to free this  
....................                   // socket (and the handle associated with it) 
....................                   if(!vFlags) 
02656:  MOVLB  1
02658:  MOVF   x78,F
0265A:  BNZ   2660
....................                      MyTCBStub.smState = TCP_CLOSED_BUT_RESERVED; 
0265C:  MOVLW  0E
0265E:  MOVWF  x31
....................                    
....................                   continue; 
02660:  BRA    2938
....................                } 
....................                 
....................                // Otherwise, if a timeout occured, simply send a keep-alive packet 
....................                SyncTCB(); 
02662:  MOVLB  0
02664:  CALL   0A7E
....................                SendTCP(ACK, SENDTCP_KEEP_ALIVE); 
02668:  MOVLW  10
0266A:  MOVLB  2
0266C:  MOVWF  x75
0266E:  MOVLW  02
02670:  MOVWF  x76
02672:  MOVLB  0
02674:  CALL   1774
....................                MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
02678:  CALL   0E34
0267C:  MOVLW  74
0267E:  MOVLB  1
02680:  ADDWF  00,W
02682:  MOVWF  x29
02684:  MOVLW  35
02686:  ADDWFC 01,W
02688:  MOVWF  x2A
0268A:  MOVLW  06
0268C:  ADDWFC 02,W
0268E:  MOVWF  x2B
02690:  MOVLW  00
02692:  ADDWFC 03,W
02694:  MOVWF  x2C
....................             } 
....................          #endif 
....................          continue; 
02696:  BRA    2938
....................       } 
....................  
....................       // If timeout has not occured, do not do anything. 
....................       if((LONG)(TickGet() - MyTCBStub.eventTime) < (LONG)0) 
02698:  MOVLB  0
0269A:  CALL   0E34
0269E:  MOVFF  03,17E
026A2:  MOVFF  02,17D
026A6:  MOVFF  01,17C
026AA:  MOVFF  00,17B
026AE:  MOVLB  1
026B0:  MOVF   x29,W
026B2:  SUBWF  00,W
026B4:  MOVWF  00
026B6:  MOVF   x2A,W
026B8:  SUBWFB 01,W
026BA:  MOVWF  01
026BC:  MOVF   x2B,W
026BE:  SUBWFB 02,W
026C0:  MOVWF  02
026C2:  MOVF   x2C,W
026C4:  SUBWFB 03,W
026C6:  MOVWF  03
026C8:  MOVWF  x7E
026CA:  MOVFF  02,17D
026CE:  MOVFF  01,17C
026D2:  MOVFF  00,17B
026D6:  BTFSS  FE8.7
026D8:  BRA    26DC
....................          continue; 
026DA:  BRA    2938
....................  
....................       // Load up extended TCB information 
....................       SyncTCB(); 
026DC:  MOVLB  0
026DE:  CALL   0A7E
....................  
....................       // A timeout has occured.  Respond to this timeout condition 
....................       // depending on what state this socket is in. 
....................       switch(MyTCBStub.smState) 
026E2:  MOVLB  1
026E4:  MOVF   x31,W
026E6:  XORLW  02
026E8:  MOVLB  0
026EA:  BZ    2720
026EC:  XORLW  01
026EE:  BZ    2740
026F0:  XORLW  06
026F2:  BZ    27B4
026F4:  XORLW  03
026F6:  BTFSC  FD8.2
026F8:  BRA    27DA
026FA:  XORLW  01
026FC:  BTFSC  FD8.2
026FE:  BRA    2800
02700:  XORLW  0C
02702:  BTFSC  FD8.2
02704:  BRA    2800
02706:  XORLW  03
02708:  BTFSC  FD8.2
0270A:  BRA    281E
0270C:  XORLW  01
0270E:  BTFSC  FD8.2
02710:  BRA    283A
02712:  XORLW  03
02714:  BTFSC  FD8.2
02716:  BRA    2844
02718:  XORLW  06
0271A:  BTFSC  FD8.2
0271C:  BRA    2860
0271E:  BRA    287E
....................       { 
....................          #if defined(STACK_CLIENT_MODE) 
....................          #if defined(STACK_USE_DNS) 
....................          case TCP_GET_DNS_MODULE: 
....................             if(DNSBeginUsage()) 
....................             { 
....................                MyTCBStub.smState = TCP_DNS_RESOLVE; 
....................                if(MyTCB.flags.bRemoteHostIsROM) 
....................                   DNSResolveROM((ROM BYTE*)(ROM_PTR_BASE)MyTCB.remote.dwRemoteHost, DNS_TYPE_A); 
....................                else 
....................                   DNSResolve((BYTE*)(PTR_BASE)MyTCB.remote.dwRemoteHost, DNS_TYPE_A); 
....................             } 
....................             break; 
....................              
....................          case TCP_DNS_RESOLVE: 
....................          { 
....................             IP_ADDR ipResolvedDNSIP; 
....................  
....................             // See if DNS resolution has finished.  Note that if the DNS  
....................             // fails, the &ipResolvedDNSIP will be written with 0x00000000.  
....................             // MyTCB.remote.dwRemoteHost is unioned with  
....................             // MyTCB.remote.niRemoteMACIP.IPAddr, so we can't directly write  
....................             // the DNS result into MyTCB.remote.niRemoteMACIP.IPAddr.  We  
....................             // must copy it over only if the DNS is resolution step was  
....................             // successful. 
....................             if(DNSIsResolved(&ipResolvedDNSIP)) 
....................             { 
....................                if(DNSEndUsage()) 
....................                { 
....................                   MyTCB.remote.niRemoteMACIP.IPAddr.Val = ipResolvedDNSIP.Val; 
....................                   MyTCBStub.smState = TCP_GATEWAY_SEND_ARP; 
....................                   MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1]+MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val; 
....................                   MyTCB.retryCount = 0; 
....................                   MyTCB.retryInterval = (TICK_SECOND/4)/256; 
....................                } 
....................                else 
....................                { 
....................                   MyTCBStub.eventTime = TickGet() + 10*TICK_SECOND; 
....................                   MyTCBStub.smState = TCP_GET_DNS_MODULE; 
....................                } 
....................             } 
....................             break; 
....................          } 
....................          #endif // #if defined(STACK_USE_DNS) 
....................              
....................          case TCP_GATEWAY_SEND_ARP: 
....................             // Obtain the MAC address associated with the server's IP address (either direct MAC address on same subnet, or the MAC address of the Gateway machine) 
....................             MyTCBStub.eventTime2 = (WORD)TickGetDiv256(); 
02720:  CALL   0EB8
02724:  MOVFF  01,12E
02728:  MOVFF  00,12D
....................             ARPResolve(&MyTCB.remote.niRemoteMACIP.IPAddr); 
0272C:  MOVLB  1
0272E:  CLRF   x7C
02730:  MOVLW  CD
02732:  MOVWF  x7B
02734:  MOVLB  0
02736:  BRA    20A4
....................             MyTCBStub.smState = TCP_GATEWAY_GET_ARP; 
02738:  MOVLW  03
0273A:  MOVLB  1
0273C:  MOVWF  x31
....................             break; 
0273E:  BRA    2880
....................  
....................          case TCP_GATEWAY_GET_ARP: 
....................             // Wait for the MAC address to finish being obtained 
....................             if(!ARPIsResolved(&MyTCB.remote.niRemoteMACIP.IPAddr, &MyTCB.remote.niRemoteMACIP.MACAddr)) 
02740:  MOVLB  1
02742:  CLRF   x7C
02744:  MOVLW  CD
02746:  MOVWF  x7B
02748:  CLRF   x7E
0274A:  MOVLW  D1
0274C:  MOVWF  x7D
0274E:  MOVLB  0
02750:  BRA    215A
02752:  MOVF   01,F
02754:  BNZ   27A6
....................             { 
....................                // Time out if too much time is spent in this state 
....................                // Note that this will continuously send out ARP  
....................                // requests for an infinite time if the Gateway  
....................                // never responds 
....................                if((WORD)TickGetDiv256() - MyTCBStub.eventTime2 > (WORD)MyTCB.retryInterval) 
02756:  CALL   0EB8
0275A:  MOVFF  01,17C
0275E:  MOVFF  00,17B
02762:  MOVLB  1
02764:  MOVF   x2D,W
02766:  SUBWF  x7B,F
02768:  MOVF   x2E,W
0276A:  SUBWFB x7C,F
0276C:  MOVLB  0
0276E:  MOVF   xB8,W
02770:  MOVLB  1
02772:  SUBWF  x7C,W
02774:  BNC   27A2
02776:  BNZ   2788
02778:  MOVF   x7B,W
0277A:  MOVLB  0
0277C:  SUBWF  xB7,W
0277E:  BTFSS  FD8.0
02780:  BRA    2786
02782:  MOVLB  1
02784:  BRA    27A2
02786:  MOVLB  1
....................                { 
....................                   // Exponentially increase timeout until we reach 6 attempts then stay constant 
....................                   if(MyTCB.retryCount < 6u) 
02788:  MOVLB  0
0278A:  MOVF   xDC,W
0278C:  SUBLW  05
0278E:  BNC   279C
....................                   { 
....................                      MyTCB.retryCount++; 
02790:  INCF   xDC,F
....................                      MyTCB.retryInterval <<= 1; 
02792:  BCF    FD8.0
02794:  RLCF   xB7,F
02796:  RLCF   xB8,F
02798:  RLCF   xB9,F
0279A:  RLCF   xBA,F
....................                   } 
....................  
....................                   // Retransmit ARP request 
....................                   MyTCBStub.smState = TCP_GATEWAY_SEND_ARP; 
0279C:  MOVLW  02
0279E:  MOVLB  1
027A0:  MOVWF  x31
....................                } 
....................                break; 
027A2:  BRA    2880
027A4:  MOVLB  0
....................             } 
....................              
....................             // Send out SYN connection request to remote node 
....................             // This automatically disables the Timer from  
....................             // continuously firing for this socket 
....................             vFlags = SYN; 
027A6:  MOVLW  02
027A8:  MOVLB  1
027AA:  MOVWF  x78
....................             bRetransmit = FALSE; 
027AC:  BCF    x77.0
....................             MyTCBStub.smState = TCP_SYN_SENT; 
027AE:  MOVLW  05
027B0:  MOVWF  x31
....................             break; 
027B2:  BRA    2880
....................          #endif // #if defined(STACK_CLIENT_MODE) 
....................           
....................          case TCP_SYN_SENT: 
....................             // Keep sending SYN until we hear from remote node. 
....................             // This may be for infinite time, in that case 
....................             // caller must detect it and do something. 
....................             vFlags = SYN; 
027B4:  MOVLW  02
027B6:  MOVLB  1
027B8:  MOVWF  x78
....................             bRetransmit = TRUE; 
027BA:  BSF    x77.0
....................  
....................             // Exponentially increase timeout until we reach TCP_MAX_RETRIES attempts then stay constant 
....................             if(MyTCB.retryCount >= (TCP_MAX_RETRIES - 1)) 
027BC:  MOVLB  0
027BE:  MOVF   xDC,W
027C0:  SUBLW  03
027C2:  BC    27D6
....................             { 
....................                MyTCB.retryCount = TCP_MAX_RETRIES - 1; 
027C4:  MOVLW  04
027C6:  MOVWF  xDC
....................                MyTCB.retryInterval = TCP_START_TIMEOUT_VAL<<(TCP_MAX_RETRIES-1); 
027C8:  CLRF   xBA
027CA:  MOVLW  09
027CC:  MOVWF  xB9
027CE:  MOVLW  EF
027D0:  MOVWF  xB8
027D2:  MOVLW  20
027D4:  MOVWF  xB7
....................             } 
....................             break; 
027D6:  MOVLB  1
027D8:  BRA    2880
....................     
....................          case TCP_SYN_RECEIVED: 
....................             // We must receive ACK before timeout expires. 
....................             // If not, resend SYN+ACK. 
....................             // Abort, if maximum attempts counts are reached. 
....................             if(MyTCB.retryCount < TCP_MAX_SYN_RETRIES) 
027DA:  MOVF   xDC,W
027DC:  SUBLW  01
027DE:  BNC   27EC
....................             { 
....................                vFlags = SYN | ACK; 
027E0:  MOVLW  12
027E2:  MOVLB  1
027E4:  MOVWF  x78
....................                bRetransmit = TRUE; 
027E6:  BSF    x77.0
....................             } 
027E8:  BRA    27FE
027EA:  MOVLB  0
....................             else 
....................             { 
....................                if(MyTCBStub.Flags.bServer) 
027EC:  MOVLB  1
027EE:  BTFSS  x32.3
027F0:  BRA    27FA
....................                { 
....................                   vFlags = RST | ACK; 
027F2:  MOVLW  14
027F4:  MOVWF  x78
....................                   bCloseSocket = TRUE; 
027F6:  BSF    x77.1
....................                } 
027F8:  BRA    27FE
....................                else 
....................                { 
....................                   vFlags = SYN; 
027FA:  MOVLW  02
027FC:  MOVWF  x78
....................                } 
....................             } 
....................             break; 
027FE:  BRA    2880
....................     
....................          case TCP_ESTABLISHED: 
....................          case TCP_CLOSE_WAIT: 
....................             // Retransmit any unacknowledged data 
....................             if(MyTCB.retryCount < TCP_MAX_RETRIES) 
02800:  MOVF   xDC,W
02802:  SUBLW  04
02804:  BNC   2812
....................             { 
....................                vFlags = ACK; 
02806:  MOVLW  10
02808:  MOVLB  1
0280A:  MOVWF  x78
....................                bRetransmit = TRUE; 
0280C:  BSF    x77.0
....................             } 
0280E:  BRA    281C
02810:  MOVLB  0
....................             else 
....................             { 
....................                // No response back for too long, close connection 
....................                // This could happen, for instance, if the communication  
....................                // medium was lost 
....................                MyTCBStub.smState = TCP_FIN_WAIT_1; 
02812:  MOVLW  08
02814:  MOVLB  1
02816:  MOVWF  x31
....................                vFlags = FIN | ACK; 
02818:  MOVLW  11
0281A:  MOVWF  x78
....................             } 
....................             break; 
0281C:  BRA    2880
....................     
....................          case TCP_FIN_WAIT_1: 
....................             if(MyTCB.retryCount < TCP_MAX_RETRIES) 
0281E:  MOVF   xDC,W
02820:  SUBLW  04
02822:  BNC   2830
....................             { 
....................                // Send another FIN 
....................                vFlags = FIN | ACK; 
02824:  MOVLW  11
02826:  MOVLB  1
02828:  MOVWF  x78
....................                bRetransmit = TRUE; 
0282A:  BSF    x77.0
....................             } 
0282C:  BRA    2838
0282E:  MOVLB  0
....................             else 
....................             { 
....................                // Close on our own, we can't seem to communicate  
....................                // with the remote node anymore 
....................                vFlags = RST | ACK; 
02830:  MOVLW  14
02832:  MOVLB  1
02834:  MOVWF  x78
....................                bCloseSocket = TRUE; 
02836:  BSF    x77.1
....................             } 
....................             break; 
02838:  BRA    2880
....................     
....................          case TCP_FIN_WAIT_2: 
....................             // Close on our own, we can't seem to communicate  
....................             // with the remote node anymore 
....................             vFlags = RST | ACK; 
0283A:  MOVLW  14
0283C:  MOVLB  1
0283E:  MOVWF  x78
....................             bCloseSocket = TRUE; 
02840:  BSF    x77.1
....................             break; 
02842:  BRA    2880
....................  
....................          case TCP_CLOSING: 
....................             if(MyTCB.retryCount < TCP_MAX_RETRIES) 
02844:  MOVF   xDC,W
02846:  SUBLW  04
02848:  BNC   2856
....................             { 
....................                // Send another ACK+FIN (the FIN is retransmitted  
....................                // automatically since it hasn't been acknowledged by  
....................                // the remote node yet) 
....................                vFlags = ACK; 
0284A:  MOVLW  10
0284C:  MOVLB  1
0284E:  MOVWF  x78
....................                bRetransmit = TRUE; 
02850:  BSF    x77.0
....................             } 
02852:  BRA    285E
02854:  MOVLB  0
....................             else 
....................             { 
....................                // Close on our own, we can't seem to communicate  
....................                // with the remote node anymore 
....................                vFlags = RST | ACK; 
02856:  MOVLW  14
02858:  MOVLB  1
0285A:  MOVWF  x78
....................                bCloseSocket = TRUE; 
0285C:  BSF    x77.1
....................             } 
....................             break; 
0285E:  BRA    2880
....................     
.................... //         case TCP_TIME_WAIT: 
.................... //            // Wait around for a while (2MSL) and then goto closed state 
.................... //            bCloseSocket = TRUE; 
.................... //            break; 
.................... //          
....................  
....................          case TCP_LAST_ACK: 
....................             // Send some more FINs or close anyway 
....................             if(MyTCB.retryCount < TCP_MAX_RETRIES) 
02860:  MOVF   xDC,W
02862:  SUBLW  04
02864:  BNC   2872
....................             { 
....................                vFlags = FIN | ACK; 
02866:  MOVLW  11
02868:  MOVLB  1
0286A:  MOVWF  x78
....................                bRetransmit = TRUE; 
0286C:  BSF    x77.0
....................             } 
0286E:  BRA    287A
02870:  MOVLB  0
....................             else 
....................             { 
....................                vFlags = RST | ACK; 
02872:  MOVLW  14
02874:  MOVLB  1
02876:  MOVWF  x78
....................                bCloseSocket = TRUE; 
02878:  BSF    x77.1
....................             } 
....................             break; 
0287A:  BRA    2880
0287C:  MOVLB  0
....................           
....................          default: 
....................             break; 
0287E:  MOVLB  1
....................       } 
....................  
....................       if(vFlags) 
02880:  MOVF   x78,F
02882:  BZ    292C
....................       { 
....................          // Transmit all unacknowledged data over again 
....................          if(bRetransmit) 
02884:  BTFSS  x77.0
02886:  BRA    291A
....................          { 
....................             // Set the appropriate retry time 
....................             MyTCB.retryCount++; 
02888:  MOVLB  0
0288A:  INCF   xDC,F
....................             MyTCB.retryInterval <<= 1; 
0288C:  BCF    FD8.0
0288E:  RLCF   xB7,F
02890:  RLCF   xB8,F
02892:  RLCF   xB9,F
02894:  RLCF   xBA,F
....................        
....................             // Calculate how many bytes we have to roll back and retransmit 
....................             w = MyTCB.txUnackedTail - MyTCBStub.txTail; 
02896:  MOVLB  1
02898:  MOVF   x23,W
0289A:  MOVLB  0
0289C:  SUBWF  xC3,W
0289E:  MOVLB  1
028A0:  MOVWF  x79
028A2:  MOVF   x24,W
028A4:  MOVLB  0
028A6:  SUBWFB xC4,W
028A8:  MOVLB  1
028AA:  MOVWF  x7A
....................             if(MyTCB.txUnackedTail < MyTCBStub.txTail) 
028AC:  MOVLB  0
028AE:  MOVF   xC4,W
028B0:  MOVLB  1
028B2:  SUBWF  x24,W
028B4:  BNC   28DC
028B6:  BNZ   28C8
028B8:  MOVF   x23,W
028BA:  MOVLB  0
028BC:  SUBWF  xC3,W
028BE:  BTFSS  FD8.0
028C0:  BRA    28C6
028C2:  MOVLB  1
028C4:  BRA    28DC
028C6:  MOVLB  1
....................                w += MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
028C8:  MOVF   x1B,W
028CA:  SUBWF  x1D,W
028CC:  MOVWF  00
028CE:  MOVF   x1C,W
028D0:  SUBWFB x1E,W
028D2:  MOVWF  03
028D4:  MOVF   00,W
028D6:  ADDWF  x79,F
028D8:  MOVF   03,W
028DA:  ADDWFC x7A,F
....................              
....................             // Perform roll back of local SEQuence counter, remote window  
....................             // adjustment, and cause all unacknowledged data to be  
....................             // retransmitted by moving the unacked tail pointer. 
....................             MyTCB.MySEQ -= w; 
028DC:  MOVF   x79,W
028DE:  MOVLB  0
028E0:  SUBWF  xBB,F
028E2:  MOVLB  1
028E4:  MOVF   x7A,W
028E6:  MOVLB  0
028E8:  SUBWFB xBC,F
028EA:  MOVLW  00
028EC:  SUBWFB xBD,F
028EE:  SUBWFB xBE,F
....................             MyTCB.remoteWindow += w; 
028F0:  MOVLB  1
028F2:  MOVF   x79,W
028F4:  MOVLB  0
028F6:  ADDWF  xC9,F
028F8:  MOVLB  1
028FA:  MOVF   x7A,W
028FC:  MOVLB  0
028FE:  ADDWFC xCA,F
....................             MyTCB.txUnackedTail = MyTCBStub.txTail;       
02900:  MOVFF  124,C4
02904:  MOVFF  123,C3
....................             SendTCP(vFlags, 0); 
02908:  MOVFF  178,275
0290C:  MOVLB  2
0290E:  CLRF   x76
02910:  MOVLB  0
02912:  CALL   1774
....................          } 
02916:  BRA    292A
02918:  MOVLB  1
....................          else 
....................             SendTCP(vFlags, SENDTCP_RESET_TIMERS); 
0291A:  MOVFF  178,275
0291E:  MOVLW  01
02920:  MOVLB  2
02922:  MOVWF  x76
02924:  MOVLB  0
02926:  CALL   1774
0292A:  MOVLB  1
....................  
....................       } 
....................        
....................       if(bCloseSocket) 
0292C:  BTFSS  x77.1
0292E:  BRA    2938
....................          CloseSocket(); 
02930:  MOVLB  0
02932:  CALL   0B52
02936:  MOVLB  1
....................    } 
....................     
....................     
....................    #if TCP_SYN_QUEUE_MAX_ENTRIES 
02938:  INCF   x76,F
0293A:  BRA    2252
....................       // Process SYN Queue entry timeouts 
....................       for(w = 0; w < TCP_SYN_QUEUE_MAX_ENTRIES; w++) 
0293C:  CLRF   x7A
0293E:  CLRF   x79
02940:  MOVF   x7A,F
02942:  BTFSS  FD8.2
02944:  BRA    2ABE
02946:  MOVF   x79,W
02948:  SUBLW  02
0294A:  BTFSS  FD8.0
0294C:  BRA    2ABE
....................       { 
....................          // Abort search if there are no more valid records 
....................          if(SYNQueue[w].wDestPort == 0u) 
0294E:  MOVFF  17A,1AC
02952:  MOVFF  179,1AB
02956:  CLRF   xAE
02958:  MOVLW  14
0295A:  MOVWF  xAD
0295C:  MOVLB  0
0295E:  CALL   0EDC
02962:  MOVFF  01,17B
02966:  MOVLW  10
02968:  MOVLB  1
0296A:  ADDWF  01,W
0296C:  MOVWF  01
0296E:  MOVLW  00
02970:  ADDWFC 02,W
02972:  MOVWF  03
02974:  MOVF   01,W
02976:  ADDLW  DF
02978:  MOVWF  FE9
0297A:  MOVLW  00
0297C:  ADDWFC 03,W
0297E:  MOVWF  FEA
02980:  MOVFF  FEC,17C
02984:  MOVF   FED,F
02986:  MOVFF  FEF,17B
0298A:  MOVF   x7B,F
0298C:  BNZ   2994
0298E:  MOVF   x7C,F
02990:  BNZ   2994
....................             break; 
02992:  BRA    2ABE
....................           
....................          // See if this SYN has timed out 
....................          if((WORD)TickGetDiv256() - SYNQueue[w].wTimestamp > (WORD)(TCP_SYN_QUEUE_TIMEOUT/256ull)) 
02994:  MOVLB  0
02996:  CALL   0EB8
0299A:  MOVFF  01,17C
0299E:  MOVFF  00,17B
029A2:  MOVFF  17A,1AC
029A6:  MOVFF  179,1AB
029AA:  MOVLB  1
029AC:  CLRF   xAE
029AE:  MOVLW  14
029B0:  MOVWF  xAD
029B2:  MOVLB  0
029B4:  CALL   0EDC
029B8:  MOVFF  02,17E
029BC:  MOVFF  01,17D
029C0:  MOVLW  12
029C2:  MOVLB  1
029C4:  ADDWF  01,W
029C6:  MOVWF  01
029C8:  MOVLW  00
029CA:  ADDWFC 02,W
029CC:  MOVWF  03
029CE:  MOVF   01,W
029D0:  ADDLW  DF
029D2:  MOVWF  FE9
029D4:  MOVLW  00
029D6:  ADDWFC 03,W
029D8:  MOVWF  FEA
029DA:  MOVFF  FEC,03
029DE:  MOVF   FED,F
029E0:  MOVF   FEF,W
029E2:  SUBWF  x7B,F
029E4:  MOVF   03,W
029E6:  SUBWFB x7C,F
029E8:  MOVF   x7C,W
029EA:  SUBLW  00
029EC:  BC    2AB6
029EE:  XORLW  FF
029F0:  BNZ   29F8
029F2:  MOVF   x7B,W
029F4:  SUBLW  DC
029F6:  BC    2AB6
....................          { 
....................             // Delete this SYN from the SYNQueue and compact the SYNQueue[] array 
....................             TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE)); 
029F8:  MOVFF  17A,1AC
029FC:  MOVFF  179,1AB
02A00:  CLRF   xAE
02A02:  MOVLW  14
02A04:  MOVWF  xAD
02A06:  MOVLB  0
02A08:  CALL   0EDC
02A0C:  MOVFF  02,03
02A10:  MOVF   01,W
02A12:  ADDLW  DF
02A14:  MOVWF  01
02A16:  MOVLW  00
02A18:  ADDWFC 03,F
02A1A:  MOVFF  01,17B
02A1E:  MOVLB  1
02A20:  MOVFF  03,17C
02A24:  MOVLW  01
02A26:  ADDWF  x79,W
02A28:  MOVWF  x7D
02A2A:  MOVLW  00
02A2C:  ADDWFC x7A,W
02A2E:  MOVWF  x7E
02A30:  MOVWF  xAC
02A32:  MOVFF  17D,1AB
02A36:  CLRF   xAE
02A38:  MOVLW  14
02A3A:  MOVWF  xAD
02A3C:  MOVLB  0
02A3E:  CALL   0EDC
02A42:  MOVFF  02,03
02A46:  MOVF   01,W
02A48:  ADDLW  DF
02A4A:  MOVWF  01
02A4C:  MOVLW  00
02A4E:  ADDWFC 03,F
02A50:  MOVFF  01,17D
02A54:  MOVLB  1
02A56:  MOVFF  03,17E
02A5A:  MOVLW  02
02A5C:  BSF    FD8.0
02A5E:  SUBFWB x79,W
02A60:  MOVWF  x7F
02A62:  MOVLW  00
02A64:  SUBFWB x7A,W
02A66:  MOVWF  x80
02A68:  MOVWF  xAC
02A6A:  MOVFF  17F,1AB
02A6E:  CLRF   xAE
02A70:  MOVLW  14
02A72:  MOVWF  xAD
02A74:  MOVLB  0
02A76:  CALL   0EDC
02A7A:  MOVFF  02,180
02A7E:  MOVFF  01,17F
02A82:  MOVFF  17C,2A7
02A86:  MOVFF  17B,2A6
02A8A:  MOVLW  01
02A8C:  MOVLB  2
02A8E:  MOVWF  xA8
02A90:  MOVFF  17E,2AA
02A94:  MOVFF  17D,2A9
02A98:  MOVWF  xAB
02A9A:  MOVFF  02,2AD
02A9E:  MOVFF  01,2AC
02AA2:  MOVLB  0
02AA4:  CALL   0998
....................             SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort = 0u; 
02AA8:  MOVLB  1
02AAA:  CLRF   x18
02AAC:  CLRF   x17
....................     
....................             // Since we deleted an entry, we need to roll back one  
....................             // index so next loop will process the correct record 
....................             w--;    
02AAE:  MOVF   x79,W
02AB0:  BTFSC  FD8.2
02AB2:  DECF   x7A,F
02AB4:  DECF   x79,F
....................          } 
02AB6:  INCF   x79,F
02AB8:  BTFSC  FD8.2
02ABA:  INCF   x7A,F
02ABC:  BRA    2940
....................       } 
....................    #endif 
02ABE:  MOVLB  0
02AC0:  GOTO   49FC (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPProcess(NODE_INFO* remote, IP_ADDR* localIP, WORD len) 
....................  
....................   Summary: 
....................      Handles incoming TCP segments. 
....................  
....................   Description: 
....................    This function handles incoming TCP segments.  When a segment arrives, it 
....................    is compared to open sockets using a hash of the remote port and IP.   
....................    On a match, the data is passed to HandleTCPSeg for further processing. 
....................  
....................   Precondition: 
....................    TCP is initialized and a TCP segment is ready in the MAC buffer. 
....................  
....................   Parameters: 
....................    remote - Remote NODE_INFO structure 
....................    localIP - This stack's IP address (for header checking) 
....................    len - Total length of the waiting TCP segment 
....................  
....................   Return Values: 
....................    TRUE - the segment was properly handled. 
....................    FALSE - otherwise 
....................   ***************************************************************************/ 
.................... BOOL TCPProcess(NODE_INFO* remote, IP_ADDR* localIP, WORD len) 
.................... { 
....................    TCP_HEADER      TCPHeader; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................    WORD_VAL        checksum1; 
....................    WORD_VAL        checksum2; 
....................    BYTE            optionsSize; 
....................  
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress      = remote->IPAddr; 
*
0487C:  MOVLB  1
0487E:  MOVFF  176,FE9
04882:  MOVFF  177,FEA
04886:  MOVFF  FEF,00
0488A:  MOVFF  FEC,01
0488E:  MOVFF  FEC,02
04892:  MOVFF  FEC,03
04896:  MOVFF  00,190
0489A:  MOVFF  01,191
0489E:  MOVFF  02,192
048A2:  MOVFF  03,193
....................    pseudoHeader.DestAddress        = *localIP; 
048A6:  MOVFF  178,FE9
048AA:  MOVFF  179,FEA
048AE:  MOVFF  FEF,00
048B2:  MOVFF  FEC,01
048B6:  MOVFF  FEC,02
048BA:  MOVFF  FEC,03
048BE:  MOVFF  00,194
048C2:  MOVFF  01,195
048C6:  MOVFF  02,196
048CA:  MOVFF  03,197
....................    pseudoHeader.Zero               = 0x0; 
048CE:  CLRF   x98
....................    pseudoHeader.Protocol           = IP_PROT_TCP; 
048D0:  MOVLW  06
048D2:  MOVWF  x99
....................    pseudoHeader.Length             = len; 
048D4:  MOVFF  17B,19B
048D8:  MOVFF  17A,19A
....................  
....................    SwapPseudoHeader(pseudoHeader); 
048DC:  MOVFF  19B,2BF
048E0:  MOVFF  19A,2BE
048E4:  MOVLB  0
048E6:  CALL   0F92
048EA:  MOVFF  02,19B
048EE:  MOVFF  01,19A
....................  
....................    checksum1.Val = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
048F2:  MOVLW  01
048F4:  MOVLB  1
048F6:  MOVWF  xA2
048F8:  MOVLW  90
048FA:  MOVWF  xA1
048FC:  MOVFF  1A2,2BB
04900:  MOVFF  FE8,2BA
04904:  MOVLB  2
04906:  CLRF   xBD
04908:  MOVLW  0C
0490A:  MOVWF  xBC
0490C:  MOVLB  0
0490E:  CALL   1346
04912:  MOVFF  01,19C
04916:  MOVLB  1
04918:  COMF   x9C,F
0491A:  MOVFF  02,19D
0491E:  COMF   x9D,F
....................  
....................    // Now calculate TCP packet checksum in NIC RAM - should match 
....................    // pesudo header checksum 
....................    checksum2.Val = CalcIPBufferChecksum(len); 
04920:  MOVFF  17B,2A0
04924:  MOVFF  17A,29F
04928:  MOVLB  0
0492A:  CALL   165E
0492E:  MOVFF  02,19F
04932:  MOVFF  01,19E
....................  
....................    // Compare checksums. 
....................    if(checksum1.Val != checksum2.Val) 
04936:  MOVLB  1
04938:  MOVF   x9E,W
0493A:  SUBWF  x9C,W
0493C:  BNZ   4944
0493E:  MOVF   x9F,W
04940:  SUBWF  x9D,W
04942:  BZ    4952
....................    { 
....................       MACDiscardRx(); 
04944:  MOVLB  0
04946:  CALL   2AC4
....................       return TRUE; 
0494A:  MOVLW  01
0494C:  MOVWF  01
0494E:  BRA    49F4
04950:  MOVLB  1
....................    } 
....................  
.................... #if defined(DEBUG_GENERATE_RX_LOSS) 
....................    // Throw RX packets away randomly 
....................    if(LFSRRand() > DEBUG_GENERATE_RX_LOSS) 
....................    { 
....................       MACDiscardRx(); 
....................       return TRUE; 
....................    } 
.................... #endif 
....................  
....................    // Retrieve TCP header. 
....................    IPSetRxBuffer(0); 
04952:  CLRF   xC6
04954:  CLRF   xC5
04956:  MOVLB  0
04958:  CALL   3008
....................    MACGetArray((BYTE*)&TCPHeader, sizeof(TCPHeader)); 
0495C:  MOVLW  01
0495E:  MOVLB  1
04960:  MOVWF  xA2
04962:  MOVLW  7C
04964:  MOVWF  xA1
04966:  MOVFF  1A2,2C0
0496A:  MOVFF  FE8,2BF
0496E:  MOVLB  2
04970:  CLRF   xC2
04972:  MOVLW  14
04974:  MOVWF  xC1
04976:  MOVLB  0
04978:  CALL   07EA
....................    SwapTCPHeader(&TCPHeader); 
0497C:  MOVLW  01
0497E:  MOVLB  2
04980:  MOVWF  xA0
04982:  MOVLW  7C
04984:  MOVWF  x9F
04986:  MOVLB  0
04988:  CALL   112A
....................  
....................  
....................    // Skip over options to retrieve data bytes 
....................    optionsSize = (BYTE)((TCPHeader.DataOffset.Val << 2)- 
....................       sizeof(TCPHeader)); 
0498C:  MOVLB  1
0498E:  SWAPF  x88,W
04990:  ANDLW  0F
04992:  MOVWF  00
04994:  RLCF   00,F
04996:  RLCF   00,F
04998:  MOVLW  FC
0499A:  ANDWF  00,F
0499C:  MOVF   00,W
0499E:  ADDLW  EC
049A0:  MOVWF  xA0
....................    len = len - optionsSize - sizeof(TCPHeader); 
049A2:  MOVF   xA0,W
049A4:  SUBWF  x7A,W
049A6:  MOVWF  xA1
049A8:  MOVLW  00
049AA:  SUBWFB x7B,W
049AC:  MOVWF  xA2
049AE:  MOVLW  14
049B0:  SUBWF  xA1,W
049B2:  MOVWF  x7A
049B4:  MOVLW  00
049B6:  SUBWFB xA2,W
049B8:  MOVWF  x7B
....................  
....................    // Find matching socket. 
....................    if(FindMatchingTCPSocket(&TCPHeader, remote)) 
049BA:  MOVLW  01
049BC:  MOVWF  xA2
049BE:  MOVLW  7C
049C0:  MOVWF  xA1
049C2:  MOVFF  177,1A4
049C6:  MOVFF  176,1A3
049CA:  MOVLB  0
049CC:  GOTO   3022
049D0:  MOVF   01,F
049D2:  BZ    49EC
....................    { 
....................       #if defined(STACK_USE_SSL) 
....................       PTR_BASE prevRxHead; 
....................       // For SSL connections, show HandleTCPSeg() the full data buffer 
....................       prevRxHead = MyTCBStub.rxHead; 
....................       if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................          MyTCBStub.rxHead = MyTCBStub.sslRxHead; 
....................       #endif 
....................        
....................       HandleTCPSeg(&TCPHeader, len); 
049D4:  MOVLW  01
049D6:  MOVLB  1
049D8:  MOVWF  xA2
049DA:  MOVLW  7C
049DC:  MOVWF  xA1
049DE:  MOVFF  17B,1A4
049E2:  MOVFF  17A,1A3
049E6:  MOVLB  0
049E8:  GOTO   374E
....................        
....................       #if defined(STACK_USE_SSL) 
....................       if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       { 
....................          // Restore the buffer state 
....................          MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................          MyTCBStub.rxHead = prevRxHead; 
....................  
....................          // Process the new SSL data, using the currently loaded stub 
....................          TCPSSLHandleIncoming(hCurrentTCP); 
....................       } 
....................       #endif 
....................    } 
.................... //   else 
.................... //   { 
.................... //      // NOTE: RFC 793 specifies that if the socket is closed and a segment  
.................... //      // arrives, we should send back a RST if the RST bit in the incoming  
.................... //      // packet is not set.  Instead, we will just silently ignore such a  
.................... //      // packet since this is what firewalls do on purpose to enhance  
.................... //      // security. 
.................... //      //if(!TCPHeader.Flags.bits.flagRST) 
.................... //      //   SendTCP(RST, SENDTCP_RESET_TIMERS); 
.................... //   } 
....................  
....................    // Finished with this packet, discard it and free the Ethernet RAM for new packets 
....................    MACDiscardRx(); 
049EC:  CALL   2AC4
....................  
....................    return TRUE; 
049F0:  MOVLW  01
049F2:  MOVWF  01
049F4:  GOTO   4B2C (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void SendTCP(BYTE vTCPFlags, BYTE vSendFlags) 
....................  
....................   Summary: 
....................    Transmits a TPC segment. 
....................  
....................   Description: 
....................    This function assembles and transmits a TCP segment, including any  
....................    pending data.  It also supports retransmissions, keep-alives, and  
....................    other packet types. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    vTCPFlags - Additional TCP flags to include 
....................    vSendFlags - Any combinations of SENDTCP_* constants to modify the 
....................              transmit behavior or contents. 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... static void SendTCP(BYTE vTCPFlags, BYTE vSendFlags) 
.................... { 
....................    WORD_VAL        wVal; 
....................    TCP_HEADER      header; 
....................    TCP_OPTIONS     options; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................    WORD          len; 
....................     
....................    SyncTCB(); 
*
01774:  CALL   0A7E
....................  
....................    // FINs must be handled specially 
....................    if(vTCPFlags & FIN) 
01778:  MOVLB  2
0177A:  BTFSS  x75.0
0177C:  BRA    1786
....................    { 
....................       MyTCBStub.Flags.bTXFIN = 1; 
0177E:  MOVLB  1
01780:  BSF    x33.3
....................       vTCPFlags &= ~FIN; 
01782:  MOVLB  2
01784:  BCF    x75.0
....................    } 
....................  
....................    // Status will now be synched, disable automatic future  
....................    // status transmissions 
....................    MyTCBStub.Flags.bTimer2Enabled = 0; 
01786:  MOVLB  1
01788:  BCF    x32.5
....................    MyTCBStub.Flags.bDelayedACKTimerEnabled = 0; 
0178A:  BCF    x32.6
....................    MyTCBStub.Flags.bOneSegmentReceived = 0; 
0178C:  BCF    x32.7
....................    MyTCBStub.Flags.bTXASAP = 0; 
0178E:  BCF    x33.1
....................    MyTCBStub.Flags.bTXASAPWithoutTimerReset = 0; 
01790:  BCF    x33.2
....................    MyTCBStub.Flags.bHalfFullFlush = 0; 
01792:  BCF    x33.0
....................  
....................    //  Make sure that we can write to the MAC transmit area 
....................    while(!IPIsTxReady()); 
01794:  MOVLB  0
01796:  CALL   0E7E
0179A:  MOVF   01,F
0179C:  BZ    1796
....................  
....................    // Put all socket application data in the TX space 
....................    if(vTCPFlags & (SYN | RST)) 
0179E:  MOVLB  2
017A0:  MOVF   x75,W
017A2:  ANDLW  06
017A4:  BZ    17AC
....................    { 
....................       // Don't put any data in SYN and RST messages 
....................       len = 0; 
017A6:  CLRF   x9E
017A8:  CLRF   x9D
....................    } 
017AA:  BRA    1A12
....................    else 
....................    { 
....................       // Begin copying any application data over to the TX space 
....................       if(MyTCBStub.txHead == MyTCB.txUnackedTail) 
017AC:  MOVLB  0
017AE:  MOVF   xC3,W
017B0:  MOVLB  1
017B2:  SUBWF  x21,W
017B4:  BNZ   17C8
017B6:  MOVLB  0
017B8:  MOVF   xC4,W
017BA:  MOVLB  1
017BC:  SUBWF  x22,W
017BE:  BNZ   17C8
....................       { 
....................          // All caught up on data TX, no real data for this packet 
....................          len = 0; 
017C0:  MOVLB  2
017C2:  CLRF   x9E
017C4:  CLRF   x9D
....................       } 
017C6:  BRA    19E2
....................       else if(MyTCBStub.txHead > MyTCB.txUnackedTail) 
017C8:  MOVLB  0
017CA:  MOVF   xC4,W
017CC:  MOVLB  1
017CE:  SUBWF  x22,W
017D0:  BNC   1882
017D2:  BNZ   17E4
017D4:  MOVF   x21,W
017D6:  MOVLB  0
017D8:  SUBWF  xC3,W
017DA:  BTFSS  FD8.0
017DC:  BRA    17E2
017DE:  MOVLB  1
017E0:  BRA    1882
017E2:  MOVLB  1
....................       { 
....................          len = MyTCBStub.txHead - MyTCB.txUnackedTail; 
017E4:  MOVLB  0
017E6:  MOVF   xC3,W
017E8:  MOVLB  1
017EA:  SUBWF  x21,W
017EC:  MOVLB  2
017EE:  MOVWF  x9D
017F0:  MOVLB  0
017F2:  MOVF   xC4,W
017F4:  MOVLB  1
017F6:  SUBWFB x22,W
017F8:  MOVLB  2
017FA:  MOVWF  x9E
....................  
....................          if(len > MyTCB.remoteWindow) 
017FC:  MOVLB  0
017FE:  MOVF   xCA,W
01800:  MOVLB  2
01802:  SUBWF  x9E,W
01804:  BNC   1820
01806:  BNZ   1818
01808:  MOVF   x9D,W
0180A:  MOVLB  0
0180C:  SUBWF  xC9,W
0180E:  BTFSS  FD8.0
01810:  BRA    1816
01812:  MOVLB  2
01814:  BRA    1820
01816:  MOVLB  2
....................             len = MyTCB.remoteWindow; 
01818:  MOVFF  CA,29E
0181C:  MOVFF  C9,29D
....................  
....................          if(len > MyTCB.wRemoteMSS) 
01820:  MOVLB  0
01822:  MOVF   xDB,W
01824:  MOVLB  2
01826:  SUBWF  x9E,W
01828:  BNC   184A
0182A:  BNZ   183C
0182C:  MOVF   x9D,W
0182E:  MOVLB  0
01830:  SUBWF  xDA,W
01832:  BTFSS  FD8.0
01834:  BRA    183A
01836:  MOVLB  2
01838:  BRA    184A
0183A:  MOVLB  2
....................          { 
....................             len = MyTCB.wRemoteMSS; 
0183C:  MOVFF  DB,29E
01840:  MOVFF  DA,29D
....................             MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
01844:  MOVLB  1
01846:  BSF    x33.2
01848:  MOVLB  2
....................          } 
....................  
....................          // Copy application data into the raw TX buffer 
....................          TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER), TCP_ETH_RAM, MyTCB.txUnackedTail, MyTCBStub.vMemoryMedium, len); 
0184A:  MOVLW  15
0184C:  MOVWF  xA7
0184E:  MOVLW  41
01850:  MOVWF  xA6
01852:  CLRF   xA8
01854:  MOVFF  C4,2AA
01858:  MOVFF  C3,2A9
0185C:  MOVFF  136,2AB
01860:  MOVFF  29E,2AD
01864:  MOVFF  29D,2AC
01868:  MOVLB  0
0186A:  CALL   0998
....................          MyTCB.txUnackedTail += len; 
0186E:  MOVLB  2
01870:  MOVF   x9D,W
01872:  MOVLB  0
01874:  ADDWF  xC3,F
01876:  MOVLB  2
01878:  MOVF   x9E,W
0187A:  MOVLB  0
0187C:  ADDWFC xC4,F
....................       } 
0187E:  BRA    19E0
01880:  MOVLB  1
....................       else 
....................       { 
....................          pseudoHeader.Length = MyTCBStub.bufferRxStart - MyTCB.txUnackedTail; 
01882:  MOVLB  0
01884:  MOVF   xC3,W
01886:  MOVLB  1
01888:  SUBWF  x1D,W
0188A:  MOVLB  2
0188C:  MOVWF  x9B
0188E:  MOVLB  0
01890:  MOVF   xC4,W
01892:  MOVLB  1
01894:  SUBWFB x1E,W
01896:  MOVLB  2
01898:  MOVWF  x9C
....................          len = pseudoHeader.Length + MyTCBStub.txHead - MyTCBStub.bufferTxStart; 
0189A:  MOVLB  1
0189C:  MOVF   x21,W
0189E:  MOVLB  2
018A0:  ADDWF  x9B,W
018A2:  MOVWF  x9F
018A4:  MOVLB  1
018A6:  MOVF   x22,W
018A8:  MOVLB  2
018AA:  ADDWFC x9C,W
018AC:  MOVWF  xA0
018AE:  MOVLB  1
018B0:  MOVF   x1B,W
018B2:  MOVLB  2
018B4:  SUBWF  x9F,W
018B6:  MOVWF  x9D
018B8:  MOVLB  1
018BA:  MOVF   x1C,W
018BC:  MOVLB  2
018BE:  SUBWFB xA0,W
018C0:  MOVWF  x9E
....................  
....................          if(len > MyTCB.remoteWindow) 
018C2:  MOVLB  0
018C4:  MOVF   xCA,W
018C6:  MOVLB  2
018C8:  SUBWF  x9E,W
018CA:  BNC   18E6
018CC:  BNZ   18DE
018CE:  MOVF   x9D,W
018D0:  MOVLB  0
018D2:  SUBWF  xC9,W
018D4:  BTFSS  FD8.0
018D6:  BRA    18DC
018D8:  MOVLB  2
018DA:  BRA    18E6
018DC:  MOVLB  2
....................             len = MyTCB.remoteWindow; 
018DE:  MOVFF  CA,29E
018E2:  MOVFF  C9,29D
....................  
....................          if(len > MyTCB.wRemoteMSS) 
018E6:  MOVLB  0
018E8:  MOVF   xDB,W
018EA:  MOVLB  2
018EC:  SUBWF  x9E,W
018EE:  BNC   1910
018F0:  BNZ   1902
018F2:  MOVF   x9D,W
018F4:  MOVLB  0
018F6:  SUBWF  xDA,W
018F8:  BTFSS  FD8.0
018FA:  BRA    1900
018FC:  MOVLB  2
018FE:  BRA    1910
01900:  MOVLB  2
....................          { 
....................             len = MyTCB.wRemoteMSS; 
01902:  MOVFF  DB,29E
01906:  MOVFF  DA,29D
....................             MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
0190A:  MOVLB  1
0190C:  BSF    x33.2
0190E:  MOVLB  2
....................          } 
....................  
....................          if(pseudoHeader.Length > len) 
01910:  MOVF   x9E,W
01912:  SUBWF  x9C,W
01914:  BNC   1926
01916:  BNZ   191E
01918:  MOVF   x9B,W
0191A:  SUBWF  x9D,W
0191C:  BC    1926
....................             pseudoHeader.Length = len; 
0191E:  MOVFF  29E,29C
01922:  MOVFF  29D,29B
....................  
....................          // Copy application data into the raw TX buffer 
....................          TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER), TCP_ETH_RAM, MyTCB.txUnackedTail, MyTCBStub.vMemoryMedium, pseudoHeader.Length); 
01926:  MOVLW  15
01928:  MOVWF  xA7
0192A:  MOVLW  41
0192C:  MOVWF  xA6
0192E:  CLRF   xA8
01930:  MOVFF  C4,2AA
01934:  MOVFF  C3,2A9
01938:  MOVFF  136,2AB
0193C:  MOVFF  29C,2AD
01940:  MOVFF  29B,2AC
01944:  MOVLB  0
01946:  CALL   0998
....................          pseudoHeader.Length = len - pseudoHeader.Length; 
0194A:  MOVLB  2
0194C:  MOVF   x9B,W
0194E:  SUBWF  x9D,W
01950:  MOVWF  x9B
01952:  MOVF   x9C,W
01954:  SUBWFB x9E,W
01956:  MOVWF  x9C
....................     
....................          // Copy any left over chunks of application data over 
....................          if(pseudoHeader.Length) 
01958:  MOVF   x9B,W
0195A:  IORWF  x9C,W
0195C:  BZ    19A4
....................          { 
....................             TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER)+(MyTCBStub.bufferRxStart-MyTCB.txUnackedTail), TCP_ETH_RAM, MyTCBStub.bufferTxStart, MyTCBStub.vMemoryMedium, pseudoHeader.Length); 
0195E:  MOVLB  0
01960:  MOVF   xC3,W
01962:  MOVLB  1
01964:  SUBWF  x1D,W
01966:  MOVWF  00
01968:  MOVLB  0
0196A:  MOVF   xC4,W
0196C:  MOVLB  1
0196E:  SUBWFB x1E,W
01970:  MOVWF  03
01972:  MOVF   00,W
01974:  ADDLW  41
01976:  MOVLB  2
01978:  MOVWF  x9F
0197A:  MOVLW  15
0197C:  ADDWFC 03,W
0197E:  MOVWF  xA0
01980:  MOVWF  xA7
01982:  MOVFF  29F,2A6
01986:  CLRF   xA8
01988:  MOVFF  11C,2AA
0198C:  MOVFF  11B,2A9
01990:  MOVFF  136,2AB
01994:  MOVFF  29C,2AD
01998:  MOVFF  29B,2AC
0199C:  MOVLB  0
0199E:  CALL   0998
019A2:  MOVLB  2
....................          } 
....................  
....................          MyTCB.txUnackedTail += len; 
019A4:  MOVF   x9D,W
019A6:  MOVLB  0
019A8:  ADDWF  xC3,F
019AA:  MOVLB  2
019AC:  MOVF   x9E,W
019AE:  MOVLB  0
019B0:  ADDWFC xC4,F
....................          if(MyTCB.txUnackedTail >= MyTCBStub.bufferRxStart) 
019B2:  MOVLB  1
019B4:  MOVF   x1E,W
019B6:  MOVLB  0
019B8:  SUBWF  xC4,W
019BA:  BNC   19E0
019BC:  BNZ   19C8
019BE:  MOVLB  1
019C0:  MOVF   x1D,W
019C2:  MOVLB  0
019C4:  SUBWF  xC3,W
019C6:  BNC   19E0
....................             MyTCB.txUnackedTail -= MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart; 
019C8:  MOVLB  1
019CA:  MOVF   x1B,W
019CC:  SUBWF  x1D,W
019CE:  MOVWF  00
019D0:  MOVF   x1C,W
019D2:  SUBWFB x1E,W
019D4:  MOVWF  03
019D6:  MOVF   00,W
019D8:  MOVLB  0
019DA:  SUBWF  xC3,F
019DC:  MOVF   03,W
019DE:  SUBWFB xC4,F
019E0:  MOVLB  2
....................       } 
....................  
....................       // If we are to transmit a FIN, make sure we can put one in this packet 
....................       if(MyTCBStub.Flags.bTXFIN) 
019E2:  MOVLB  1
019E4:  BTFSS  x33.3
019E6:  BRA    1A14
....................       { 
....................          if((len != MyTCB.remoteWindow) && (len != MyTCB.wRemoteMSS)) 
019E8:  MOVLB  0
019EA:  MOVF   xC9,W
019EC:  MOVLB  2
019EE:  SUBWF  x9D,W
019F0:  BNZ   19FC
019F2:  MOVLB  0
019F4:  MOVF   xCA,W
019F6:  MOVLB  2
019F8:  SUBWF  x9E,W
019FA:  BZ    1A12
019FC:  MOVLB  0
019FE:  MOVF   xDA,W
01A00:  MOVLB  2
01A02:  SUBWF  x9D,W
01A04:  BNZ   1A10
01A06:  MOVLB  0
01A08:  MOVF   xDB,W
01A0A:  MOVLB  2
01A0C:  SUBWF  x9E,W
01A0E:  BZ    1A12
....................             vTCPFlags |= FIN; 
01A10:  BSF    x75.0
01A12:  MOVLB  1
....................       } 
....................    } 
....................  
....................    // Ensure that all packets with data of some kind are  
....................    // retransmitted by TCPTick() until acknowledged 
....................    // Pure ACK packets with no data are not ACKed back in TCP 
....................    if(len || (vTCPFlags & (SYN | FIN))) 
01A14:  MOVLB  2
01A16:  MOVF   x9D,W
01A18:  IORWF  x9E,W
01A1A:  BNZ   1A22
01A1C:  MOVF   x75,W
01A1E:  ANDLW  03
01A20:  BZ    1A8A
....................    { 
....................       // Transmitting data, update remote window variable to reflect smaller  
....................       // window. 
....................       MyTCB.remoteWindow -= len; 
01A22:  MOVF   x9D,W
01A24:  MOVLB  0
01A26:  SUBWF  xC9,F
01A28:  MOVLB  2
01A2A:  MOVF   x9E,W
01A2C:  MOVLB  0
01A2E:  SUBWFB xCA,F
....................  
....................       // Push (PSH) all data for enhanced responsiveness on  
....................       // the remote end, especially with GUIs 
....................       if(len) 
01A30:  MOVLB  2
01A32:  MOVF   x9D,W
01A34:  IORWF  x9E,W
01A36:  BZ    1A3A
....................          vTCPFlags |= PSH; 
01A38:  BSF    x75.3
....................  
....................       if(vSendFlags & SENDTCP_RESET_TIMERS) 
01A3A:  BTFSS  x76.0
01A3C:  BRA    1A50
....................       { 
....................          MyTCB.retryCount = 0; 
01A3E:  MOVLB  0
01A40:  CLRF   xDC
....................          MyTCB.retryInterval = TCP_START_TIMEOUT_VAL; 
01A42:  CLRF   xBA
01A44:  CLRF   xB9
01A46:  MOVLW  9E
01A48:  MOVWF  xB8
01A4A:  MOVLW  F2
01A4C:  MOVWF  xB7
01A4E:  MOVLB  2
....................       }    
....................  
....................       MyTCBStub.eventTime = TickGet() + MyTCB.retryInterval; 
01A50:  MOVLB  0
01A52:  CALL   0E34
01A56:  MOVF   xB7,W
01A58:  MOVLB  2
01A5A:  ADDWF  00,W
01A5C:  MOVLB  1
01A5E:  MOVWF  x29
01A60:  MOVLB  0
01A62:  MOVF   xB8,W
01A64:  MOVLB  2
01A66:  ADDWFC 01,W
01A68:  MOVLB  1
01A6A:  MOVWF  x2A
01A6C:  MOVLB  0
01A6E:  MOVF   xB9,W
01A70:  MOVLB  2
01A72:  ADDWFC 02,W
01A74:  MOVLB  1
01A76:  MOVWF  x2B
01A78:  MOVLB  0
01A7A:  MOVF   xBA,W
01A7C:  MOVLB  2
01A7E:  ADDWFC 03,W
01A80:  MOVLB  1
01A82:  MOVWF  x2C
....................       MyTCBStub.Flags.bTimerEnabled = 1; 
01A84:  BSF    x32.4
....................    } 
01A86:  BRA    1B0C
01A88:  MOVLB  2
....................    else if(vSendFlags & SENDTCP_KEEP_ALIVE) 
01A8A:  BTFSS  x76.1
01A8C:  BRA    1AB8
....................    { 
....................       // Increment Keep Alive TX counter to handle disconnection if not response is returned 
....................       MyTCBStub.Flags.vUnackedKeepalives++; 
01A8E:  MOVLB  1
01A90:  MOVF   x32,W
01A92:  ADDLW  01
01A94:  ANDLW  07
01A96:  MOVWF  00
01A98:  MOVLW  F8
01A9A:  ANDWF  x32,W
01A9C:  IORWF  00,W
01A9E:  MOVWF  x32
....................        
....................       // Generate a dummy byte 
....................       MyTCB.MySEQ -= 1; 
01AA0:  MOVLW  01
01AA2:  MOVLB  0
01AA4:  SUBWF  xBB,F
01AA6:  MOVLW  00
01AA8:  SUBWFB xBC,F
01AAA:  SUBWFB xBD,F
01AAC:  SUBWFB xBE,F
....................       len = 1; 
01AAE:  MOVLB  2
01AB0:  CLRF   x9E
01AB2:  MOVLW  01
01AB4:  MOVWF  x9D
....................    } 
01AB6:  BRA    1B0E
....................    else if(MyTCBStub.Flags.bTimerEnabled)  
01AB8:  MOVLB  1
01ABA:  BTFSS  x32.4
01ABC:  BRA    1B0C
....................    { 
....................       // If we have data to transmit, but the remote RX window is zero,  
....................       // so we aren't transmitting any right now then make sure to not  
....................       // extend the retry counter or timer.  This will stall our TX  
....................       // with a periodic ACK sent to the remote node. 
....................       if(!(vSendFlags & SENDTCP_RESET_TIMERS)) 
01ABE:  MOVLB  2
01AC0:  BTFSC  x76.0
01AC2:  BRA    1AD8
....................       { 
....................          // Roll back retry counters since we can't send anything,  
....................          // but only if we incremented it in the first place 
....................          if(MyTCB.retryCount) 
01AC4:  MOVLB  0
01AC6:  MOVF   xDC,F
01AC8:  BZ    1AD6
....................          { 
....................             MyTCB.retryCount--; 
01ACA:  DECF   xDC,F
....................             MyTCB.retryInterval >>= 1; 
01ACC:  BCF    FD8.0
01ACE:  RRCF   xBA,F
01AD0:  RRCF   xB9,F
01AD2:  RRCF   xB8,F
01AD4:  RRCF   xB7,F
01AD6:  MOVLB  2
....................          } 
....................       } 
....................     
....................       MyTCBStub.eventTime = TickGet() + MyTCB.retryInterval; 
01AD8:  MOVLB  0
01ADA:  CALL   0E34
01ADE:  MOVF   xB7,W
01AE0:  MOVLB  2
01AE2:  ADDWF  00,W
01AE4:  MOVLB  1
01AE6:  MOVWF  x29
01AE8:  MOVLB  0
01AEA:  MOVF   xB8,W
01AEC:  MOVLB  2
01AEE:  ADDWFC 01,W
01AF0:  MOVLB  1
01AF2:  MOVWF  x2A
01AF4:  MOVLB  0
01AF6:  MOVF   xB9,W
01AF8:  MOVLB  2
01AFA:  ADDWFC 02,W
01AFC:  MOVLB  1
01AFE:  MOVWF  x2B
01B00:  MOVLB  0
01B02:  MOVF   xBA,W
01B04:  MOVLB  2
01B06:  ADDWFC 03,W
01B08:  MOVLB  1
01B0A:  MOVWF  x2C
01B0C:  MOVLB  2
....................    } 
....................     
....................  
....................    header.SourcePort         = MyTCB.localPort.Val; 
01B0E:  MOVFF  C8,27A
01B12:  MOVFF  C7,279
....................    header.DestPort            = MyTCB.remotePort.Val; 
01B16:  MOVFF  C6,27C
01B1A:  MOVFF  C5,27B
....................    header.SeqNumber         = MyTCB.MySEQ; 
01B1E:  MOVFF  BE,280
01B22:  MOVFF  BD,27F
01B26:  MOVFF  BC,27E
01B2A:  MOVFF  BB,27D
....................    header.AckNumber         = MyTCB.RemoteSEQ; 
01B2E:  MOVFF  C2,284
01B32:  MOVFF  C1,283
01B36:  MOVFF  C0,282
01B3A:  MOVFF  BF,281
....................    header.Flags.bits.Reserved2   = 0; 
01B3E:  MOVLW  3F
01B40:  ANDWF  x86,W
01B42:  MOVWF  x86
....................    header.DataOffset.Reserved3   = 0; 
01B44:  MOVLW  F0
01B46:  ANDWF  x85,W
01B48:  MOVWF  x85
....................    header.Flags.byte         = vTCPFlags; 
01B4A:  MOVFF  275,286
....................    header.UrgentPointer        = 0; 
01B4E:  CLRF   x8C
01B50:  CLRF   x8B
....................  
....................    // Update our send sequence number and ensure retransmissions  
....................    // of SYNs and FINs use the right sequence number 
....................    MyTCB.MySEQ += (DWORD)len; 
01B52:  MOVFF  29E,01
01B56:  CLRF   02
01B58:  CLRF   03
01B5A:  MOVF   x9D,W
01B5C:  MOVLB  0
01B5E:  ADDWF  xBB,F
01B60:  MOVF   01,W
01B62:  ADDWFC xBC,F
01B64:  MOVF   02,W
01B66:  ADDWFC xBD,F
01B68:  MOVF   03,W
01B6A:  ADDWFC xBE,F
....................    if(vTCPFlags & SYN) 
01B6C:  MOVLB  2
01B6E:  BTFSS  x75.1
01B70:  BRA    1BAE
....................    { 
....................       // SEG.ACK needs to be zero for the first SYN packet for compatibility  
....................       // with certain paranoid TCP/IP stacks, even though the ACK flag isn't  
....................       // set (indicating that the AckNumber field is unused). 
....................       if(!(vTCPFlags & ACK)) 
01B72:  BTFSC  x75.4
01B74:  BRA    1B7E
....................          header.AckNumber = 0x00000000; 
01B76:  CLRF   x84
01B78:  CLRF   x83
01B7A:  CLRF   x82
01B7C:  CLRF   x81
....................  
....................       if(MyTCB.flags.bSYNSent) 
01B7E:  MOVLB  0
01B80:  BTFSS  xD9.1
01B82:  BRA    1B9A
....................          header.SeqNumber--; 
01B84:  MOVLW  FF
01B86:  MOVLB  2
01B88:  ADDWF  x7D,F
01B8A:  BTFSS  FD8.0
01B8C:  ADDWF  x7E,F
01B8E:  BTFSS  FD8.0
01B90:  ADDWF  x7F,F
01B92:  BTFSS  FD8.0
01B94:  ADDWF  x80,F
01B96:  BRA    1BAE
01B98:  MOVLB  0
....................       else 
....................       { 
....................          MyTCB.MySEQ++; 
01B9A:  MOVLW  01
01B9C:  ADDWF  xBB,F
01B9E:  BTFSC  FD8.0
01BA0:  INCF   xBC,F
01BA2:  BTFSC  FD8.2
01BA4:  INCF   xBD,F
01BA6:  BTFSC  FD8.2
01BA8:  INCF   xBE,F
....................          MyTCB.flags.bSYNSent = 1; 
01BAA:  BSF    xD9.1
01BAC:  MOVLB  2
....................       } 
....................    } 
....................    if(vTCPFlags & FIN) 
01BAE:  BTFSS  x75.0
01BB0:  BRA    1BB8
....................    { 
....................         MyTCB.flags.bFINSent = 1;   // do not advance the seq no for FIN! 
01BB2:  MOVLB  0
01BB4:  BSF    xD9.0
01BB6:  MOVLB  2
....................    } 
....................  
....................    // Calculate the amount of free space in the RX buffer area of this socket 
....................    if(MyTCBStub.rxHead >= MyTCBStub.rxTail) 
01BB8:  MOVLB  1
01BBA:  MOVF   x28,W
01BBC:  SUBWF  x26,W
01BBE:  BNC   1BFA
01BC0:  BNZ   1BC8
01BC2:  MOVF   x27,W
01BC4:  SUBWF  x25,W
01BC6:  BNC   1BFA
....................       header.Window = (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart) - (MyTCBStub.rxHead - MyTCBStub.rxTail); 
01BC8:  MOVF   x1D,W
01BCA:  SUBWF  x1F,W
01BCC:  MOVLB  2
01BCE:  MOVWF  x9F
01BD0:  MOVLB  1
01BD2:  MOVF   x1E,W
01BD4:  SUBWFB x20,W
01BD6:  MOVLB  2
01BD8:  MOVWF  xA0
01BDA:  MOVLB  1
01BDC:  MOVF   x27,W
01BDE:  SUBWF  x25,W
01BE0:  MOVWF  00
01BE2:  MOVF   x28,W
01BE4:  SUBWFB x26,W
01BE6:  MOVWF  03
01BE8:  MOVF   00,W
01BEA:  MOVLB  2
01BEC:  SUBWF  x9F,W
01BEE:  MOVWF  x87
01BF0:  MOVF   03,W
01BF2:  SUBWFB xA0,W
01BF4:  MOVWF  x88
01BF6:  BRA    1C18
01BF8:  MOVLB  1
....................    else 
....................       header.Window = MyTCBStub.rxTail - MyTCBStub.rxHead - 1; 
01BFA:  MOVF   x25,W
01BFC:  SUBWF  x27,W
01BFE:  MOVLB  2
01C00:  MOVWF  x9F
01C02:  MOVLB  1
01C04:  MOVF   x26,W
01C06:  SUBWFB x28,W
01C08:  MOVLB  2
01C0A:  MOVWF  xA0
01C0C:  MOVLW  01
01C0E:  SUBWF  x9F,W
01C10:  MOVWF  x87
01C12:  MOVLW  00
01C14:  SUBWFB xA0,W
01C16:  MOVWF  x88
....................  
....................    // Calculate the amount of free space in the MAC RX buffer area and adjust window if needed 
....................    wVal.Val = MACGetFreeRxSize(); 
01C18:  MOVLB  0
01C1A:  GOTO   0EFE
01C1E:  MOVFF  02,278
01C22:  MOVFF  01,277
....................    if(wVal.Val < 64) 
01C26:  MOVLB  2
01C28:  MOVF   x78,F
01C2A:  BNZ   1C38
01C2C:  MOVF   x77,W
01C2E:  SUBLW  3F
01C30:  BNC   1C38
....................     { 
....................       wVal.Val = 0; 
01C32:  CLRF   x78
01C34:  CLRF   x77
....................     } 
01C36:  BRA    1C40
....................     else 
....................     { 
....................       wVal.Val -= 64; 
01C38:  MOVLW  40
01C3A:  SUBWF  x77,F
01C3C:  MOVLW  00
01C3E:  SUBWFB x78,F
....................     } 
....................    // Force the remote node to throttle back if we are running low on general RX buffer space 
....................    if(header.Window > wVal.Val) 
01C40:  MOVF   x78,W
01C42:  SUBWF  x88,W
01C44:  BNC   1C56
01C46:  BNZ   1C4E
01C48:  MOVF   x87,W
01C4A:  SUBWF  x77,W
01C4C:  BC    1C56
....................       header.Window = wVal.Val; 
01C4E:  MOVFF  278,288
01C52:  MOVFF  277,287
....................  
....................    SwapTCPHeader(&header); 
01C56:  MOVLW  02
01C58:  MOVWF  xA0
01C5A:  MOVLW  79
01C5C:  MOVWF  x9F
01C5E:  MOVLB  0
01C60:  CALL   112A
....................  
....................  
....................    len += sizeof(header); 
01C64:  MOVLW  14
01C66:  MOVLB  2
01C68:  ADDWF  x9D,F
01C6A:  MOVLW  00
01C6C:  ADDWFC x9E,F
....................    header.DataOffset.Val   = sizeof(header) >> 2; 
01C6E:  MOVLW  0F
01C70:  ANDWF  x85,W
01C72:  IORLW  50
01C74:  MOVWF  x85
....................  
....................    // Insert the MSS (Maximum Segment Size) TCP option if this is SYN packet 
....................    if(vTCPFlags & SYN) 
01C76:  BTFSS  x75.1
01C78:  BRA    1CA8
....................    { 
....................       len += sizeof(options); 
01C7A:  MOVLW  04
01C7C:  ADDWF  x9D,F
01C7E:  MOVLW  00
01C80:  ADDWFC x9E,F
....................       options.Kind = TCP_OPTIONS_MAX_SEG_SIZE; 
01C82:  MOVLW  02
01C84:  MOVWF  x8D
....................       options.Length = 0x04; 
01C86:  MOVLW  04
01C88:  MOVWF  x8E
....................  
....................       // Load MSS and swap to big endian 
....................       options.MaxSegSize.Val = (((TCP_MAX_SEG_SIZE_RX)&0x00FF)<<8) | (((TCP_MAX_SEG_SIZE_RX)&0xFF00)>>8); 
01C8A:  MOVLW  18
01C8C:  MOVWF  x90
01C8E:  MOVLW  02
01C90:  MOVWF  x8F
....................  
....................      #if defined(__PCD__)  //__PCD__ __PCH__ __CCS__ bug 
....................       unsigned int8 scr8; 
....................       scr8 = header.DataOffset.Val; 
....................       scr8 += sizeof(options) >> 2; 
....................       header.DataOffset.Val = scr8; 
....................      #else  //standard code 
....................       header.DataOffset.Val   += sizeof(options) >> 2; 
01C92:  SWAPF  x85,W
01C94:  ANDLW  0F
01C96:  ADDLW  01
01C98:  MOVWF  00
01C9A:  SWAPF  00,W
01C9C:  ANDLW  F0
01C9E:  MOVWF  00
01CA0:  MOVLW  0F
01CA2:  ANDWF  x85,W
01CA4:  IORWF  00,W
01CA6:  MOVWF  x85
....................      #endif 
....................    } 
....................  
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress   = AppConfig.MyIPAddr; 
01CA8:  MOVFF  2D,294
01CAC:  MOVFF  2C,293
01CB0:  MOVFF  2B,292
01CB4:  MOVFF  2A,291
....................    pseudoHeader.DestAddress    = MyTCB.remote.niRemoteMACIP.IPAddr; 
01CB8:  MOVFF  D0,298
01CBC:  MOVFF  CF,297
01CC0:  MOVFF  CE,296
01CC4:  MOVFF  CD,295
....................    pseudoHeader.Zero           = 0x0; 
01CC8:  CLRF   x99
....................    pseudoHeader.Protocol       = IP_PROT_TCP; 
01CCA:  MOVLW  06
01CCC:  MOVWF  x9A
....................    pseudoHeader.Length         = len; 
01CCE:  MOVFF  29E,29C
01CD2:  MOVFF  29D,29B
....................    SwapPseudoHeader(pseudoHeader); 
01CD6:  MOVFF  29C,2BF
01CDA:  MOVFF  29B,2BE
01CDE:  MOVLB  0
01CE0:  CALL   0F92
01CE4:  MOVFF  02,29C
01CE8:  MOVFF  01,29B
....................    header.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader, sizeof(pseudoHeader)); 
01CEC:  MOVLW  02
01CEE:  MOVLB  2
01CF0:  MOVWF  xA0
01CF2:  MOVLW  91
01CF4:  MOVWF  x9F
01CF6:  MOVFF  2A0,2BB
01CFA:  MOVWF  xBA
01CFC:  CLRF   xBD
01CFE:  MOVLW  0C
01D00:  MOVWF  xBC
01D02:  MOVLB  0
01D04:  CALL   1346
01D08:  MOVFF  01,289
01D0C:  MOVLB  2
01D0E:  COMF   x89,F
01D10:  MOVFF  02,28A
01D14:  COMF   x8A,F
....................  
....................    // Write IP header 
....................    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER)); 
01D16:  MOVLW  15
01D18:  MOVWF  xAF
01D1A:  MOVLW  19
01D1C:  MOVWF  xAE
01D1E:  MOVLB  0
01D20:  CALL   077C
....................    IPPutHeader(&MyTCB.remote.niRemoteMACIP, IP_PROT_TCP, len); 
01D24:  MOVLB  2
01D26:  CLRF   xA0
01D28:  MOVLW  CD
01D2A:  MOVWF  x9F
01D2C:  MOVLW  06
01D2E:  MOVWF  xA1
01D30:  MOVFF  29E,2A3
01D34:  MOVFF  29D,2A2
01D38:  MOVLB  0
01D3A:  RCALL  1576
....................    MACPutArray((BYTE*)&header, sizeof(header)); 
01D3C:  MOVLW  02
01D3E:  MOVLB  2
01D40:  MOVWF  xA0
01D42:  MOVLW  79
01D44:  MOVWF  x9F
01D46:  MOVFF  2A0,2C4
01D4A:  MOVWF  xC3
01D4C:  CLRF   xC6
01D4E:  MOVLW  14
01D50:  MOVWF  xC5
01D52:  MOVLB  0
01D54:  CALL   079A
....................    if(vTCPFlags & SYN) 
01D58:  MOVLB  2
01D5A:  BTFSS  x75.1
01D5C:  BRA    1D7A
....................       MACPutArray((BYTE*)&options, sizeof(options)); 
01D5E:  MOVLW  02
01D60:  MOVWF  xA0
01D62:  MOVLW  8D
01D64:  MOVWF  x9F
01D66:  MOVFF  2A0,2C4
01D6A:  MOVWF  xC3
01D6C:  CLRF   xC6
01D6E:  MOVLW  04
01D70:  MOVWF  xC5
01D72:  MOVLB  0
01D74:  CALL   079A
01D78:  MOVLB  2
....................  
....................    // Update the TCP checksum 
....................    MACSetReadPtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER)); 
01D7A:  MOVLW  15
01D7C:  MOVWF  xAF
01D7E:  MOVLW  2D
01D80:  MOVWF  xAE
01D82:  MOVLB  0
01D84:  CALL   07CC
....................    wVal.Val = CalcIPBufferChecksum(len); 
01D88:  MOVFF  29E,2A0
01D8C:  MOVFF  29D,29F
01D90:  RCALL  165E
01D92:  MOVFF  02,278
01D96:  MOVFF  01,277
.................... #if defined(DEBUG_GENERATE_TX_LOSS) 
....................    // Damage TCP checksums on TX packets randomly 
....................    if(LFSRRand() > DEBUG_GENERATE_TX_LOSS) 
....................    { 
....................       wVal.Val++; 
....................    } 
.................... #endif 
....................    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER) + 16); 
01D9A:  MOVLW  15
01D9C:  MOVLB  2
01D9E:  MOVWF  xAF
01DA0:  MOVLW  3D
01DA2:  MOVWF  xAE
01DA4:  MOVLB  0
01DA6:  CALL   077C
....................    MACPutArray((BYTE*)&wVal, sizeof(WORD)); 
01DAA:  MOVLW  02
01DAC:  MOVLB  2
01DAE:  MOVWF  xA0
01DB0:  MOVLW  77
01DB2:  MOVWF  x9F
01DB4:  MOVFF  2A0,2C4
01DB8:  MOVWF  xC3
01DBA:  CLRF   xC6
01DBC:  MOVLW  02
01DBE:  MOVWF  xC5
01DC0:  MOVLB  0
01DC2:  CALL   079A
....................  
....................    // Physically start the packet transmission over the network 
....................    MACFlush(); 
01DC6:  CALL   0E5A
01DCA:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static BOOL FindMatchingTCPSocket(TCP_HEADER* h, NODE_INFO* remote) 
....................  
....................   Summary: 
....................    Finds a suitable socket for a TCP segment. 
....................  
....................   Description: 
....................    This function searches through the sockets and attempts to match one with 
....................    a given TCP header and NODE_INFO structure.  If a socket is found, its  
....................    index is saved in hCurrentTCP and the associated MyTCBStub and MyTCB are 
....................    loaded. Otherwise, INVALID_SOCKET is placed in hCurrentTCP. 
....................     
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    h - TCP header to be matched against 
....................    remote - The remote node who sent this header 
....................  
....................   Return Values: 
....................    TRUE - A match was found and is loaded in hCurrentTCP 
....................    FALSE - No suitable socket was found and hCurrentTCP is INVALID_SOCKET 
....................   ***************************************************************************/ 
.................... static BOOL FindMatchingTCPSocket(TCP_HEADER* h, NODE_INFO* remote) 
.................... { 
....................    TCP_SOCKET hTCP; 
....................    TCP_SOCKET partialMatch; 
....................    WORD hash; 
....................  
....................    // Prevent connections on invalid port 0 
....................    if(h->DestPort == 0u) 
*
03022:  MOVLW  02
03024:  MOVLB  1
03026:  ADDWF  xA1,W
03028:  MOVWF  FE9
0302A:  MOVLW  00
0302C:  ADDWFC xA2,W
0302E:  MOVWF  FEA
03030:  MOVFF  FEC,1AC
03034:  MOVF   FED,F
03036:  MOVFF  FEF,1AB
0303A:  MOVF   xAB,F
0303C:  BNZ   3048
0303E:  MOVF   xAC,F
03040:  BNZ   3048
....................       return FALSE; 
03042:  MOVLW  00
03044:  MOVWF  01
03046:  BRA    3628
....................  
....................    partialMatch = INVALID_SOCKET; 
03048:  MOVLW  FE
0304A:  MOVWF  xA6
....................    hash = (remote->IPAddr.w[1]+remote->IPAddr.w[0] + h->SourcePort) ^ h->DestPort; 
0304C:  MOVLW  02
0304E:  ADDWF  xA3,W
03050:  MOVWF  FE9
03052:  MOVLW  00
03054:  ADDWFC xA4,W
03056:  MOVWF  FEA
03058:  MOVFF  FEC,1AC
0305C:  MOVF   FED,F
0305E:  MOVFF  FEF,1AB
03062:  MOVFF  1A3,FE9
03066:  MOVFF  1A4,FEA
0306A:  MOVFF  FEC,03
0306E:  MOVF   FED,F
03070:  MOVF   FEF,W
03072:  ADDWF  xAB,F
03074:  MOVF   03,W
03076:  ADDWFC xAC,F
03078:  MOVFF  1A1,FE9
0307C:  MOVFF  1A2,FEA
03080:  MOVFF  FEC,03
03084:  MOVF   FED,F
03086:  MOVF   FEF,W
03088:  ADDWF  xAB,F
0308A:  MOVF   03,W
0308C:  ADDWFC xAC,F
0308E:  MOVLW  02
03090:  ADDWF  xA1,W
03092:  MOVWF  FE9
03094:  MOVLW  00
03096:  ADDWFC xA2,W
03098:  MOVWF  FEA
0309A:  MOVFF  FEC,03
0309E:  MOVF   FED,F
030A0:  MOVF   FEF,W
030A2:  XORWF  xAB,W
030A4:  MOVWF  xA7
030A6:  MOVF   03,W
030A8:  XORWF  xAC,W
030AA:  MOVWF  xA8
....................  
....................    // Loop through all sockets looking for a socket that is expecting this  
....................    // packet or can handle it. 
....................    for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++ ) 
030AC:  CLRF   xA5
030AE:  MOVF   xA5,F
030B0:  BTFSS  FD8.2
030B2:  BRA    31A6
....................    { 
....................       SyncTCBStub(hTCP); 
030B4:  MOVFF  1A5,276
030B8:  MOVLB  0
030BA:  CALL   06DC
....................  
....................       if(MyTCBStub.smState == TCP_CLOSED) 
030BE:  MOVLB  1
030C0:  MOVF   x31,W
030C2:  SUBLW  0D
030C4:  BNZ   30CA
....................       { 
....................          continue; 
030C6:  BRA    31A2
....................       } 
030C8:  BRA    3104
....................       else if(MyTCBStub.smState == TCP_LISTEN) 
030CA:  MOVF   x31,W
030CC:  SUBLW  04
030CE:  BNZ   30F6
....................       {// For listening ports, check if this is the correct port 
....................          if(MyTCBStub.remoteHash.Val == h->DestPort) 
030D0:  MOVLW  02
030D2:  ADDWF  xA1,W
030D4:  MOVWF  FE9
030D6:  MOVLW  00
030D8:  ADDWFC xA2,W
030DA:  MOVWF  FEA
030DC:  MOVFF  FEC,03
030E0:  MOVF   FED,F
030E2:  MOVF   FEF,W
030E4:  SUBWF  x34,W
030E6:  BNZ   30F2
030E8:  MOVF   03,W
030EA:  SUBWF  x35,W
030EC:  BNZ   30F2
....................             partialMatch = hTCP; 
030EE:  MOVFF  1A5,1A6
....................           
....................          #if defined(STACK_USE_SSL_SERVER) 
....................          // Check the SSL port as well for SSL Servers 
....................          // 0 is defined as an invalid port number 
....................          if(MyTCBStub.sslTxHead == h->DestPort) 
....................             partialMatch = hTCP; 
....................          #endif 
....................           
....................          continue; 
030F2:  BRA    31A2
....................       } 
030F4:  BRA    3104
....................       else if(MyTCBStub.remoteHash.Val != hash) 
030F6:  MOVF   xA7,W
030F8:  SUBWF  x34,W
030FA:  BNZ   3102
030FC:  MOVF   xA8,W
030FE:  SUBWF  x35,W
03100:  BZ    3104
....................       {// Ignore if the hash doesn't match 
....................          continue; 
03102:  BRA    31A2
....................       } 
....................  
....................       SyncTCB(); 
03104:  MOVLB  0
03106:  CALL   0A7E
....................       if(   h->DestPort == MyTCB.localPort.Val && 
....................          h->SourcePort == MyTCB.remotePort.Val && 
....................          remote->IPAddr.Val == MyTCB.remote.niRemoteMACIP.IPAddr.Val) 
0310A:  MOVLW  02
0310C:  MOVLB  1
0310E:  ADDWF  xA1,W
03110:  MOVWF  FE9
03112:  MOVLW  00
03114:  ADDWFC xA2,W
03116:  MOVWF  FEA
03118:  MOVFF  FEC,1AC
0311C:  MOVF   FED,F
0311E:  MOVFF  FEF,1AB
03122:  MOVLB  0
03124:  MOVF   xC7,W
03126:  MOVLB  1
03128:  SUBWF  xAB,W
0312A:  BNZ   31A2
0312C:  MOVLB  0
0312E:  MOVF   xC8,W
03130:  MOVLB  1
03132:  SUBWF  xAC,W
03134:  BNZ   31A2
03136:  MOVFF  1A1,FE9
0313A:  MOVFF  1A2,FEA
0313E:  MOVFF  FEC,1AC
03142:  MOVF   FED,F
03144:  MOVFF  FEF,1AB
03148:  MOVLB  0
0314A:  MOVF   xC5,W
0314C:  MOVLB  1
0314E:  SUBWF  xAB,W
03150:  BNZ   31A2
03152:  MOVLB  0
03154:  MOVF   xC6,W
03156:  MOVLB  1
03158:  SUBWF  xAC,W
0315A:  BNZ   31A2
0315C:  MOVFF  1A3,FE9
03160:  MOVFF  1A4,FEA
03164:  MOVFF  FEF,1AB
03168:  MOVFF  FEC,1AC
0316C:  MOVFF  FEC,1AD
03170:  MOVFF  FEC,1AE
03174:  MOVLB  0
03176:  MOVF   xCD,W
03178:  MOVLB  1
0317A:  SUBWF  xAB,W
0317C:  BNZ   31A2
0317E:  MOVLB  0
03180:  MOVF   xCE,W
03182:  MOVLB  1
03184:  SUBWF  xAC,W
03186:  BNZ   31A2
03188:  MOVLB  0
0318A:  MOVF   xCF,W
0318C:  MOVLB  1
0318E:  SUBWF  xAD,W
03190:  BNZ   31A2
03192:  MOVLB  0
03194:  MOVF   xD0,W
03196:  MOVLB  1
03198:  SUBWF  xAE,W
0319A:  BNZ   31A2
....................       { 
....................          return TRUE; 
0319C:  MOVLW  01
0319E:  MOVWF  01
031A0:  BRA    3628
....................       } 
031A2:  INCF   xA5,F
031A4:  BRA    30AE
....................    } 
....................  
....................  
....................    // If there is a partial match, then a listening socket is currently  
....................    // available.  Set up the extended TCB with the info needed  
....................    // to establish a connection and return this socket to the  
....................    // caller. 
....................    if(partialMatch != INVALID_SOCKET) 
031A6:  MOVF   xA6,W
031A8:  SUBLW  FE
031AA:  BZ    321E
....................    { 
....................       SyncTCBStub(partialMatch); 
031AC:  MOVFF  1A6,276
031B0:  MOVLB  0
031B2:  CALL   06DC
....................       SyncTCB(); 
031B6:  CALL   0A7E
....................     
....................       // For SSL ports, begin the SSL Handshake 
....................       #if defined(STACK_USE_SSL_SERVER) 
....................       if(MyTCBStub.sslTxHead == h->DestPort) 
....................       { 
....................          // Try to start an SSL session.  If no stubs are available, 
....................          // we can't service this request right now, so ignore it. 
....................          if(!TCPStartSSLServer(partialMatch)) 
....................             partialMatch = INVALID_SOCKET; 
....................       } 
....................       #endif 
....................     
....................       // Make sure the above check didn't fail (this is unfortunately  
....................       // redundant for non-SSL sockets).  Otherwise, fall out to below 
....................       // and add to the SYN queue. 
....................       if(partialMatch != INVALID_SOCKET) 
031BA:  MOVLB  1
031BC:  MOVF   xA6,W
031BE:  SUBLW  FE
031C0:  BZ    321E
....................       { 
....................          MyTCBStub.remoteHash.Val = hash; 
031C2:  MOVFF  1A8,135
031C6:  MOVFF  1A7,134
....................        
....................          memcpy((void*)&MyTCB.remote, (void*)remote, sizeof(NODE_INFO)); 
031CA:  CLRF   xAC
031CC:  MOVLW  CD
031CE:  MOVFF  1AC,FEA
031D2:  MOVWF  FE9
031D4:  MOVFF  1A4,FE2
031D8:  MOVFF  1A3,FE1
031DC:  MOVLW  0A
031DE:  MOVWF  01
031E0:  MOVFF  FE6,FEE
031E4:  DECFSZ 01,F
031E6:  BRA    31E0
....................          MyTCB.remotePort.Val = h->SourcePort; 
031E8:  MOVFF  1A1,FE9
031EC:  MOVFF  1A2,FEA
031F0:  MOVFF  FEC,C6
031F4:  MOVF   FED,F
031F6:  MOVFF  FEF,C5
....................          MyTCB.localPort.Val = h->DestPort; 
031FA:  MOVLW  02
031FC:  ADDWF  xA1,W
031FE:  MOVWF  FE9
03200:  MOVLW  00
03202:  ADDWFC xA2,W
03204:  MOVWF  FEA
03206:  MOVFF  FEC,C8
0320A:  MOVF   FED,F
0320C:  MOVFF  FEF,C7
....................          MyTCB.txUnackedTail   = MyTCBStub.bufferTxStart; 
03210:  MOVFF  11C,C4
03214:  MOVFF  11B,C3
....................        
....................          // All done, and we have a match 
....................          return TRUE; 
03218:  MOVLW  01
0321A:  MOVWF  01
0321C:  BRA    3628
....................       } 
....................    } 
....................  
....................    // No available sockets are listening on this port.  (Or, for 
....................    // SSL requests, perhaps no SSL sessions were available.  However, 
....................    // there may be a server socket which is currently busy but  
....................    // could handle this packet, so we should check. 
....................    #if TCP_SYN_QUEUE_MAX_ENTRIES 
....................    { 
....................       WORD wQueueInsertPos; 
....................        
....................       // See if this is a SYN packet 
....................       if(!h->Flags.bits.flagSYN) 
0321E:  MOVLW  0D
03220:  ADDWF  xA1,W
03222:  MOVWF  FE9
03224:  MOVLW  00
03226:  ADDWFC xA2,W
03228:  MOVWF  FEA
0322A:  BTFSC  FEF.1
0322C:  BRA    3234
....................          return FALSE; 
0322E:  MOVLW  00
03230:  MOVWF  01
03232:  BRA    3628
....................  
....................       // See if there is space in our SYN queue 
....................       if(SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort) 
03234:  MOVF   x17,W
03236:  IORWF  x18,W
03238:  BZ    3240
....................          return FALSE; 
0323A:  MOVLW  00
0323C:  MOVWF  01
0323E:  BRA    3628
....................        
....................       // See if we have this SYN already in our SYN queue. 
....................       // If not already in the queue, find out where we  
....................       // should insert this SYN to the queue 
....................       for(wQueueInsertPos = 0; wQueueInsertPos < TCP_SYN_QUEUE_MAX_ENTRIES; wQueueInsertPos++) 
03240:  CLRF   xAA
03242:  CLRF   xA9
03244:  MOVF   xAA,F
03246:  BTFSS  FD8.2
03248:  BRA    3416
0324A:  MOVF   xA9,W
0324C:  SUBLW  02
0324E:  BTFSS  FD8.0
03250:  BRA    3416
....................       { 
....................          // Exit loop if we found a free record 
....................          if(SYNQueue[wQueueInsertPos].wDestPort == 0u) 
03252:  MOVFF  1AA,1AC
03256:  MOVFF  1A9,1AB
0325A:  CLRF   xAE
0325C:  MOVLW  14
0325E:  MOVWF  xAD
03260:  MOVLB  0
03262:  CALL   0EDC
03266:  MOVFF  01,1AB
0326A:  MOVLW  10
0326C:  MOVLB  1
0326E:  ADDWF  01,W
03270:  MOVWF  01
03272:  MOVLW  00
03274:  ADDWFC 02,W
03276:  MOVWF  03
03278:  MOVF   01,W
0327A:  ADDLW  DF
0327C:  MOVWF  FE9
0327E:  MOVLW  00
03280:  ADDWFC 03,W
03282:  MOVWF  FEA
03284:  MOVFF  FEC,1AC
03288:  MOVF   FED,F
0328A:  MOVFF  FEF,1AB
0328E:  MOVF   xAB,F
03290:  BNZ   3298
03292:  MOVF   xAC,F
03294:  BNZ   3298
....................             break; 
03296:  BRA    3416
....................  
....................          // Check if this SYN packet is already in the SYN queue 
....................          if(SYNQueue[wQueueInsertPos].wDestPort != h->DestPort) 
03298:  MOVFF  1AA,1AC
0329C:  MOVFF  1A9,1AB
032A0:  CLRF   xAE
032A2:  MOVLW  14
032A4:  MOVWF  xAD
032A6:  MOVLB  0
032A8:  CALL   0EDC
032AC:  MOVFF  01,1AB
032B0:  MOVLW  10
032B2:  MOVLB  1
032B4:  ADDWF  01,W
032B6:  MOVWF  01
032B8:  MOVLW  00
032BA:  ADDWFC 02,W
032BC:  MOVWF  03
032BE:  MOVF   01,W
032C0:  ADDLW  DF
032C2:  MOVWF  FE9
032C4:  MOVLW  00
032C6:  ADDWFC 03,W
032C8:  MOVWF  FEA
032CA:  MOVFF  FEC,1AC
032CE:  MOVF   FED,F
032D0:  MOVFF  FEF,1AB
032D4:  MOVLW  02
032D6:  ADDWF  xA1,W
032D8:  MOVWF  FE9
032DA:  MOVLW  00
032DC:  ADDWFC xA2,W
032DE:  MOVWF  FEA
032E0:  MOVFF  FEC,03
032E4:  MOVF   FED,F
032E6:  MOVF   FEF,W
032E8:  SUBWF  xAB,W
032EA:  BNZ   32F2
032EC:  MOVF   03,W
032EE:  SUBWF  xAC,W
032F0:  BZ    32F4
....................             continue; 
032F2:  BRA    340E
....................          if(SYNQueue[wQueueInsertPos].wSourcePort != h->SourcePort) 
032F4:  MOVFF  1AA,1AC
032F8:  MOVFF  1A9,1AB
032FC:  CLRF   xAE
032FE:  MOVLW  14
03300:  MOVWF  xAD
03302:  MOVLB  0
03304:  CALL   0EDC
03308:  MOVFF  01,1AB
0330C:  MOVLW  0A
0330E:  MOVLB  1
03310:  ADDWF  01,W
03312:  MOVWF  01
03314:  MOVLW  00
03316:  ADDWFC 02,W
03318:  MOVWF  03
0331A:  MOVF   01,W
0331C:  ADDLW  DF
0331E:  MOVWF  FE9
03320:  MOVLW  00
03322:  ADDWFC 03,W
03324:  MOVWF  FEA
03326:  MOVFF  FEC,1AC
0332A:  MOVF   FED,F
0332C:  MOVFF  FEF,1AB
03330:  MOVFF  1A1,FE9
03334:  MOVFF  1A2,FEA
03338:  MOVFF  FEC,03
0333C:  MOVF   FED,F
0333E:  MOVF   FEF,W
03340:  SUBWF  xAB,W
03342:  BNZ   334A
03344:  MOVF   03,W
03346:  SUBWF  xAC,W
03348:  BZ    334C
....................             continue; 
0334A:  BRA    340E
....................          if(SYNQueue[wQueueInsertPos].niSourceAddress.IPAddr.Val != remote->IPAddr.Val) 
0334C:  MOVFF  1AA,1AC
03350:  MOVFF  1A9,1AB
03354:  CLRF   xAE
03356:  MOVLW  14
03358:  MOVWF  xAD
0335A:  MOVLB  0
0335C:  CALL   0EDC
03360:  MOVFF  02,1AC
03364:  MOVFF  01,1AB
03368:  MOVLW  DF
0336A:  MOVLB  1
0336C:  ADDWF  01,W
0336E:  MOVWF  FE9
03370:  MOVLW  00
03372:  ADDWFC 02,W
03374:  MOVWF  FEA
03376:  MOVFF  FEF,1AD
0337A:  MOVFF  FEC,1AE
0337E:  MOVFF  FEC,1AF
03382:  MOVFF  FEC,1B0
03386:  MOVFF  1A3,FE9
0338A:  MOVFF  1A4,FEA
0338E:  MOVFF  FEF,00
03392:  MOVFF  FEC,01
03396:  MOVFF  FEC,02
0339A:  MOVFF  FEC,03
0339E:  MOVF   00,W
033A0:  SUBWF  xAD,W
033A2:  BNZ   33B6
033A4:  MOVF   01,W
033A6:  SUBWF  xAE,W
033A8:  BNZ   33B6
033AA:  MOVF   02,W
033AC:  SUBWF  xAF,W
033AE:  BNZ   33B6
033B0:  MOVF   03,W
033B2:  SUBWF  xB0,W
033B4:  BZ    33B8
....................             continue; 
033B6:  BRA    340E
....................  
....................          // SYN matches SYN queue entry.  Update timestamp and do nothing. 
....................          SYNQueue[wQueueInsertPos].wTimestamp = TickGetDiv256(); 
033B8:  MOVFF  1AA,1AC
033BC:  MOVFF  1A9,1AB
033C0:  CLRF   xAE
033C2:  MOVLW  14
033C4:  MOVWF  xAD
033C6:  MOVLB  0
033C8:  CALL   0EDC
033CC:  MOVFF  01,1AB
033D0:  MOVLW  12
033D2:  MOVLB  1
033D4:  ADDWF  01,W
033D6:  MOVWF  01
033D8:  MOVLW  00
033DA:  ADDWFC 02,W
033DC:  MOVWF  03
033DE:  MOVF   01,W
033E0:  ADDLW  DF
033E2:  MOVWF  01
033E4:  MOVLW  00
033E6:  ADDWFC 03,F
033E8:  MOVFF  01,1AB
033EC:  MOVFF  03,1AC
033F0:  MOVLB  0
033F2:  CALL   0EB8
033F6:  MOVFF  1AC,FEA
033FA:  MOVFF  1AB,FE9
033FE:  MOVFF  00,FEF
03402:  MOVFF  01,FEC
....................          return FALSE; 
03406:  MOVLW  00
03408:  MOVWF  01
0340A:  MOVLB  1
0340C:  BRA    3628
0340E:  INCF   xA9,F
03410:  BTFSC  FD8.2
03412:  INCF   xAA,F
03414:  BRA    3244
....................       } 
....................        
....................       // Check to see if we have any server sockets which  
....................       // are currently connected, but could handle this SYN  
....................       // request at a later time if the client disconnects. 
....................       for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++) 
03416:  CLRF   xA5
03418:  MOVF   xA5,F
0341A:  BTFSS  FD8.2
0341C:  BRA    3624
....................       { 
....................          SyncTCBStub(hTCP); 
0341E:  MOVFF  1A5,276
03422:  MOVLB  0
03424:  CALL   06DC
....................          if(!MyTCBStub.Flags.bServer) 
03428:  MOVLB  1
0342A:  BTFSC  x32.3
0342C:  BRA    3430
....................             continue; 
0342E:  BRA    3620
....................  
....................          SyncTCB(); 
03430:  MOVLB  0
03432:  CALL   0A7E
....................          #if defined(STACK_USE_SSL_SERVER) 
....................          if((MyTCB.localPort.Val != h->DestPort) && (MyTCB.localSSLPort.Val != h->DestPort)) 
....................          #else 
....................          if(MyTCB.localPort.Val != h->DestPort) 
03436:  MOVLW  02
03438:  MOVLB  1
0343A:  ADDWF  xA1,W
0343C:  MOVWF  FE9
0343E:  MOVLW  00
03440:  ADDWFC xA2,W
03442:  MOVWF  FEA
03444:  MOVFF  FEC,03
03448:  MOVF   FED,F
0344A:  MOVF   FEF,W
0344C:  MOVLB  0
0344E:  SUBWF  xC7,W
03450:  BNZ   3458
03452:  MOVF   03,W
03454:  SUBWF  xC8,W
03456:  BZ    345E
....................          #endif 
....................             continue; 
03458:  MOVLB  1
0345A:  BRA    3620
0345C:  MOVLB  0
....................  
....................          // Generate the SYN queue entry 
....................          memcpy((void*)&SYNQueue[wQueueInsertPos].niSourceAddress, (void*)remote, sizeof(NODE_INFO)); 
0345E:  MOVFF  1AA,1AC
03462:  MOVFF  1A9,1AB
03466:  MOVLB  1
03468:  CLRF   xAE
0346A:  MOVLW  14
0346C:  MOVWF  xAD
0346E:  MOVLB  0
03470:  CALL   0EDC
03474:  MOVFF  02,1AC
03478:  MOVFF  01,1AB
0347C:  MOVLW  DF
0347E:  MOVLB  1
03480:  ADDWF  01,W
03482:  MOVWF  01
03484:  MOVLW  00
03486:  ADDWFC 02,W
03488:  MOVWF  03
0348A:  MOVFF  01,1AD
0348E:  MOVWF  xAE
03490:  MOVWF  FEA
03492:  MOVFF  01,FE9
03496:  MOVFF  1A4,FE2
0349A:  MOVFF  1A3,FE1
0349E:  MOVLW  0A
034A0:  MOVWF  01
034A2:  MOVFF  FE6,FEE
034A6:  DECFSZ 01,F
034A8:  BRA    34A2
....................          SYNQueue[wQueueInsertPos].wSourcePort = h->SourcePort; 
034AA:  MOVFF  1AA,1AC
034AE:  MOVFF  1A9,1AB
034B2:  CLRF   xAE
034B4:  MOVLW  14
034B6:  MOVWF  xAD
034B8:  MOVLB  0
034BA:  CALL   0EDC
034BE:  MOVFF  01,1AB
034C2:  MOVLW  0A
034C4:  MOVLB  1
034C6:  ADDWF  01,W
034C8:  MOVWF  01
034CA:  MOVLW  00
034CC:  ADDWFC 02,W
034CE:  MOVWF  03
034D0:  MOVF   01,W
034D2:  ADDLW  DF
034D4:  MOVWF  01
034D6:  MOVLW  00
034D8:  ADDWFC 03,F
034DA:  MOVFF  03,1AC
034DE:  MOVFF  1A1,FE9
034E2:  MOVFF  1A2,FEA
034E6:  MOVFF  FEC,03
034EA:  MOVF   FED,F
034EC:  MOVFF  FEF,1AD
034F0:  MOVFF  1AC,FEA
034F4:  MOVFF  01,FE9
034F8:  MOVFF  03,FEC
034FC:  MOVF   FED,F
034FE:  MOVFF  1AD,FEF
....................          SYNQueue[wQueueInsertPos].dwSourceSEQ = h->SeqNumber; 
03502:  MOVFF  1AA,1AC
03506:  MOVFF  1A9,1AB
0350A:  CLRF   xAE
0350C:  MOVLW  14
0350E:  MOVWF  xAD
03510:  MOVLB  0
03512:  CALL   0EDC
03516:  MOVFF  01,1AB
0351A:  MOVLW  0C
0351C:  MOVLB  1
0351E:  ADDWF  01,W
03520:  MOVWF  01
03522:  MOVLW  00
03524:  ADDWFC 02,W
03526:  MOVWF  03
03528:  MOVF   01,W
0352A:  ADDLW  DF
0352C:  MOVWF  01
0352E:  MOVLW  00
03530:  ADDWFC 03,F
03532:  MOVFF  01,1AB
03536:  MOVFF  03,1AC
0353A:  MOVLW  04
0353C:  ADDWF  xA1,W
0353E:  MOVWF  FE9
03540:  MOVLW  00
03542:  ADDWFC xA2,W
03544:  MOVWF  FEA
03546:  MOVFF  FEF,00
0354A:  MOVFF  FEC,01
0354E:  MOVFF  FEC,02
03552:  MOVFF  FEC,03
03556:  MOVFF  1AC,FEA
0355A:  MOVFF  1AB,FE9
0355E:  MOVFF  00,FEF
03562:  MOVFF  01,FEC
03566:  MOVFF  02,FEC
0356A:  MOVFF  03,FEC
....................          SYNQueue[wQueueInsertPos].wDestPort = h->DestPort; 
0356E:  MOVFF  1AA,1AC
03572:  MOVFF  1A9,1AB
03576:  CLRF   xAE
03578:  MOVLW  14
0357A:  MOVWF  xAD
0357C:  MOVLB  0
0357E:  CALL   0EDC
03582:  MOVFF  01,1AB
03586:  MOVLW  10
03588:  MOVLB  1
0358A:  ADDWF  01,W
0358C:  MOVWF  01
0358E:  MOVLW  00
03590:  ADDWFC 02,W
03592:  MOVWF  03
03594:  MOVF   01,W
03596:  ADDLW  DF
03598:  MOVWF  01
0359A:  MOVLW  00
0359C:  ADDWFC 03,F
0359E:  MOVFF  03,1AC
035A2:  MOVLW  02
035A4:  ADDWF  xA1,W
035A6:  MOVWF  FE9
035A8:  MOVLW  00
035AA:  ADDWFC xA2,W
035AC:  MOVWF  FEA
035AE:  MOVFF  FEC,03
035B2:  MOVF   FED,F
035B4:  MOVFF  FEF,1AD
035B8:  MOVFF  1AC,FEA
035BC:  MOVFF  01,FE9
035C0:  MOVFF  03,FEC
035C4:  MOVF   FED,F
035C6:  MOVFF  1AD,FEF
....................          SYNQueue[wQueueInsertPos].wTimestamp = TickGetDiv256(); 
035CA:  MOVFF  1AA,1AC
035CE:  MOVFF  1A9,1AB
035D2:  CLRF   xAE
035D4:  MOVLW  14
035D6:  MOVWF  xAD
035D8:  MOVLB  0
035DA:  CALL   0EDC
035DE:  MOVFF  01,1AB
035E2:  MOVLW  12
035E4:  MOVLB  1
035E6:  ADDWF  01,W
035E8:  MOVWF  01
035EA:  MOVLW  00
035EC:  ADDWFC 02,W
035EE:  MOVWF  03
035F0:  MOVF   01,W
035F2:  ADDLW  DF
035F4:  MOVWF  01
035F6:  MOVLW  00
035F8:  ADDWFC 03,F
035FA:  MOVFF  01,1AB
035FE:  MOVFF  03,1AC
03602:  MOVLB  0
03604:  CALL   0EB8
03608:  MOVFF  1AC,FEA
0360C:  MOVFF  1AB,FE9
03610:  MOVFF  00,FEF
03614:  MOVFF  01,FEC
....................  
....................          return FALSE; 
03618:  MOVLW  00
0361A:  MOVWF  01
0361C:  MOVLB  1
0361E:  BRA    3628
03620:  INCF   xA5,F
03622:  BRA    3418
....................       } 
....................    } 
....................    #endif 
....................        
....................    return FALSE; 
03624:  MOVLW  00
03626:  MOVWF  01
03628:  MOVLB  0
0362A:  GOTO   49D0 (RETURN)
....................  
.................... } 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void SwapTCPHeader(TCP_HEADER* header) 
....................  
....................   Summary: 
....................    Swaps endian-ness of a TCP header. 
....................  
....................   Description: 
....................    This function swaps the endian-ness of a given TCP header for comparison. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    header - The TCP header that is to be swapped 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... static void SwapTCPHeader(TCP_HEADER* header) 
.................... { 
....................    header->SourcePort      = swaps(header->SourcePort); 
*
0112A:  MOVLB  2
0112C:  MOVFF  29F,01
01130:  MOVFF  2A0,03
01134:  MOVFF  29F,2A1
01138:  MOVFF  2A0,2A2
0113C:  MOVFF  29F,FE9
01140:  MOVFF  2A0,FEA
01144:  MOVFF  FEC,2A4
01148:  MOVF   FED,F
0114A:  MOVFF  FEF,2A3
0114E:  MOVFF  2A4,2BF
01152:  MOVFF  2A3,2BE
01156:  MOVLB  0
01158:  RCALL  0F92
0115A:  MOVFF  2A2,FEA
0115E:  MOVFF  2A1,FE9
01162:  MOVFF  02,FEC
01166:  MOVF   FED,F
01168:  MOVFF  01,FEF
....................    header->DestPort        = swaps(header->DestPort); 
0116C:  MOVLW  02
0116E:  MOVLB  2
01170:  ADDWF  x9F,W
01172:  MOVWF  01
01174:  MOVLW  00
01176:  ADDWFC xA0,W
01178:  MOVWF  03
0117A:  MOVFF  01,2A1
0117E:  MOVWF  xA2
01180:  MOVLW  02
01182:  ADDWF  x9F,W
01184:  MOVWF  FE9
01186:  MOVLW  00
01188:  ADDWFC xA0,W
0118A:  MOVWF  FEA
0118C:  MOVFF  FEC,2A4
01190:  MOVF   FED,F
01192:  MOVFF  FEF,2A3
01196:  MOVFF  2A4,2BF
0119A:  MOVFF  2A3,2BE
0119E:  MOVLB  0
011A0:  RCALL  0F92
011A2:  MOVFF  2A2,FEA
011A6:  MOVFF  2A1,FE9
011AA:  MOVFF  02,FEC
011AE:  MOVF   FED,F
011B0:  MOVFF  01,FEF
....................    header->SeqNumber       = swapl(header->SeqNumber); 
011B4:  MOVLW  04
011B6:  MOVLB  2
011B8:  ADDWF  x9F,W
011BA:  MOVWF  01
011BC:  MOVLW  00
011BE:  ADDWFC xA0,W
011C0:  MOVWF  03
011C2:  MOVFF  01,2A1
011C6:  MOVWF  xA2
011C8:  MOVLW  04
011CA:  ADDWF  x9F,W
011CC:  MOVWF  FE9
011CE:  MOVLW  00
011D0:  ADDWFC xA0,W
011D2:  MOVWF  FEA
011D4:  MOVFF  FEF,2A3
011D8:  MOVFF  FEC,2A4
011DC:  MOVFF  FEC,2A5
011E0:  MOVFF  FEC,2A6
011E4:  MOVFF  2A6,2AA
011E8:  MOVFF  2A5,2A9
011EC:  MOVFF  2A4,2A8
011F0:  MOVFF  2A3,2A7
011F4:  MOVLB  0
011F6:  RCALL  0FB4
011F8:  MOVFF  2A2,FEA
011FC:  MOVFF  2A1,FE9
01200:  MOVFF  00,FEF
01204:  MOVFF  01,FEC
01208:  MOVFF  02,FEC
0120C:  MOVFF  03,FEC
....................    header->AckNumber       = swapl(header->AckNumber); 
01210:  MOVLW  08
01212:  MOVLB  2
01214:  ADDWF  x9F,W
01216:  MOVWF  01
01218:  MOVLW  00
0121A:  ADDWFC xA0,W
0121C:  MOVWF  03
0121E:  MOVFF  01,2A1
01222:  MOVWF  xA2
01224:  MOVLW  08
01226:  ADDWF  x9F,W
01228:  MOVWF  FE9
0122A:  MOVLW  00
0122C:  ADDWFC xA0,W
0122E:  MOVWF  FEA
01230:  MOVFF  FEF,2A3
01234:  MOVFF  FEC,2A4
01238:  MOVFF  FEC,2A5
0123C:  MOVFF  FEC,2A6
01240:  MOVFF  2A6,2AA
01244:  MOVFF  2A5,2A9
01248:  MOVFF  2A4,2A8
0124C:  MOVFF  2A3,2A7
01250:  MOVLB  0
01252:  RCALL  0FB4
01254:  MOVFF  2A2,FEA
01258:  MOVFF  2A1,FE9
0125C:  MOVFF  00,FEF
01260:  MOVFF  01,FEC
01264:  MOVFF  02,FEC
01268:  MOVFF  03,FEC
....................    header->Window          = swaps(header->Window); 
0126C:  MOVLW  0E
0126E:  MOVLB  2
01270:  ADDWF  x9F,W
01272:  MOVWF  01
01274:  MOVLW  00
01276:  ADDWFC xA0,W
01278:  MOVWF  03
0127A:  MOVFF  01,2A1
0127E:  MOVWF  xA2
01280:  MOVLW  0E
01282:  ADDWF  x9F,W
01284:  MOVWF  FE9
01286:  MOVLW  00
01288:  ADDWFC xA0,W
0128A:  MOVWF  FEA
0128C:  MOVFF  FEC,2A4
01290:  MOVF   FED,F
01292:  MOVFF  FEF,2A3
01296:  MOVFF  2A4,2BF
0129A:  MOVFF  2A3,2BE
0129E:  MOVLB  0
012A0:  RCALL  0F92
012A2:  MOVFF  2A2,FEA
012A6:  MOVFF  2A1,FE9
012AA:  MOVFF  02,FEC
012AE:  MOVF   FED,F
012B0:  MOVFF  01,FEF
....................    header->Checksum        = swaps(header->Checksum); 
012B4:  MOVLW  10
012B6:  MOVLB  2
012B8:  ADDWF  x9F,W
012BA:  MOVWF  01
012BC:  MOVLW  00
012BE:  ADDWFC xA0,W
012C0:  MOVWF  03
012C2:  MOVFF  01,2A1
012C6:  MOVWF  xA2
012C8:  MOVLW  10
012CA:  ADDWF  x9F,W
012CC:  MOVWF  FE9
012CE:  MOVLW  00
012D0:  ADDWFC xA0,W
012D2:  MOVWF  FEA
012D4:  MOVFF  FEC,2A4
012D8:  MOVF   FED,F
012DA:  MOVFF  FEF,2A3
012DE:  MOVFF  2A4,2BF
012E2:  MOVFF  2A3,2BE
012E6:  MOVLB  0
012E8:  RCALL  0F92
012EA:  MOVFF  2A2,FEA
012EE:  MOVFF  2A1,FE9
012F2:  MOVFF  02,FEC
012F6:  MOVF   FED,F
012F8:  MOVFF  01,FEF
....................    header->UrgentPointer   = swaps(header->UrgentPointer); 
012FC:  MOVLW  12
012FE:  MOVLB  2
01300:  ADDWF  x9F,W
01302:  MOVWF  01
01304:  MOVLW  00
01306:  ADDWFC xA0,W
01308:  MOVWF  03
0130A:  MOVFF  01,2A1
0130E:  MOVWF  xA2
01310:  MOVLW  12
01312:  ADDWF  x9F,W
01314:  MOVWF  FE9
01316:  MOVLW  00
01318:  ADDWFC xA0,W
0131A:  MOVWF  FEA
0131C:  MOVFF  FEC,2A4
01320:  MOVF   FED,F
01322:  MOVFF  FEF,2A3
01326:  MOVFF  2A4,2BF
0132A:  MOVFF  2A3,2BE
0132E:  MOVLB  0
01330:  RCALL  0F92
01332:  MOVFF  2A2,FEA
01336:  MOVFF  2A1,FE9
0133A:  MOVFF  02,FEC
0133E:  MOVF   FED,F
01340:  MOVFF  01,FEF
01344:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void CloseSocket(void) 
....................  
....................   Summary: 
....................    Closes a TCP socket. 
....................  
....................   Description: 
....................    This function closes a TCP socket.  All socket state information is  
....................    reset, and any buffered bytes are discarded.  The socket is no longer 
....................    accessible by the application after this point. 
....................  
....................   Precondition: 
....................    The TCPStub corresponding to the socket to be closed is synced. 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... static void CloseSocket(void) 
.................... { 
....................    SyncTCB(); 
*
00B52:  RCALL  0A7E
....................  
....................    MyTCBStub.remoteHash.Val = MyTCB.localPort.Val; 
00B54:  MOVFF  C8,135
00B58:  MOVFF  C7,134
....................    MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
00B5C:  MOVFF  11C,122
00B60:  MOVFF  11B,121
....................    MyTCBStub.txTail = MyTCBStub.bufferTxStart; 
00B64:  MOVFF  11C,124
00B68:  MOVFF  11B,123
....................    MyTCBStub.rxHead = MyTCBStub.bufferRxStart; 
00B6C:  MOVFF  11E,126
00B70:  MOVFF  11D,125
....................    MyTCBStub.rxTail = MyTCBStub.bufferRxStart; 
00B74:  MOVFF  11E,128
00B78:  MOVFF  11D,127
....................    MyTCBStub.smState = MyTCBStub.Flags.bServer ? TCP_LISTEN : TCP_CLOSED; 
00B7C:  MOVLB  1
00B7E:  BTFSS  x32.3
00B80:  BRA    0B86
00B82:  MOVLW  04
00B84:  BRA    0B88
00B86:  MOVLW  0D
00B88:  MOVWF  x31
....................    MyTCBStub.Flags.vUnackedKeepalives = 0; 
00B8A:  MOVLW  F8
00B8C:  ANDWF  x32,W
00B8E:  MOVWF  x32
....................    MyTCBStub.Flags.bTimerEnabled = 0; 
00B90:  BCF    x32.4
....................    MyTCBStub.Flags.bTimer2Enabled = 0; 
00B92:  BCF    x32.5
....................    MyTCBStub.Flags.bDelayedACKTimerEnabled = 0; 
00B94:  BCF    x32.6
....................    MyTCBStub.Flags.bOneSegmentReceived = 0; 
00B96:  BCF    x32.7
....................    MyTCBStub.Flags.bHalfFullFlush = 0; 
00B98:  BCF    x33.0
....................    MyTCBStub.Flags.bTXASAP = 0; 
00B9A:  BCF    x33.1
....................    MyTCBStub.Flags.bTXASAPWithoutTimerReset = 0; 
00B9C:  BCF    x33.2
....................    MyTCBStub.Flags.bTXFIN = 0; 
00B9E:  BCF    x33.3
....................    MyTCBStub.Flags.bSocketReset = 1; 
00BA0:  BSF    x33.4
....................  
....................    #if defined(STACK_USE_SSL) 
....................    // If SSL is active, then we need to close it 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    { 
....................       SSLTerminate(MyTCBStub.sslStubID); 
....................       MyTCBStub.sslStubID = SSL_INVALID_ID; 
....................  
....................       // Swap the SSL port and local port back to proper values 
....................       MyTCBStub.remoteHash.Val = MyTCB.localSSLPort.Val; 
....................       MyTCB.localSSLPort.Val = MyTCB.localPort.Val; 
....................       MyTCB.localPort.Val = MyTCBStub.remoteHash.Val; 
....................    } 
....................  
....................    // Reset the SSL buffer pointers 
....................    MyTCBStub.sslRxHead = MyTCBStub.bufferRxStart; 
....................    MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    #endif 
....................     
....................    #if defined(STACK_USE_SSL_SERVER) 
....................    MyTCBStub.sslTxHead = MyTCB.localSSLPort.Val; 
....................    #endif 
....................  
....................    MyTCB.flags.bFINSent = 0; 
00BA2:  MOVLB  0
00BA4:  BCF    xD9.0
....................    MyTCB.flags.bSYNSent = 0; 
00BA6:  BCF    xD9.1
....................    MyTCB.flags.bRXNoneACKed1 = 0; 
00BA8:  BCF    xD9.3
....................    MyTCB.flags.bRXNoneACKed2 = 0; 
00BAA:  BCF    xD9.4
....................    MyTCB.txUnackedTail = MyTCBStub.bufferTxStart; 
00BAC:  MOVFF  11C,C4
00BB0:  MOVFF  11B,C3
....................    ((DWORD_VAL*)(&MyTCB.MySEQ))->w[0] = LFSRRand(); 
00BB4:  MOVLB  2
00BB6:  CLRF   x6C
00BB8:  MOVLW  BB
00BBA:  MOVWF  x6B
00BBC:  MOVWF  01
00BBE:  MOVFF  26C,03
00BC2:  MOVWF  x6D
00BC4:  MOVFF  26C,26E
00BC8:  MOVLB  0
00BCA:  CALL   035C
00BCE:  MOVFF  26E,FEA
00BD2:  MOVFF  26D,FE9
00BD6:  MOVFF  02,FEC
00BDA:  MOVF   FED,F
00BDC:  MOVFF  01,FEF
....................    ((DWORD_VAL*)(&MyTCB.MySEQ))->w[1] = LFSRRand(); 
00BE0:  MOVLB  2
00BE2:  CLRF   x6C
00BE4:  MOVLW  BB
00BE6:  MOVWF  x6B
00BE8:  MOVLW  02
00BEA:  ADDWF  x6B,W
00BEC:  MOVWF  01
00BEE:  MOVLW  00
00BF0:  ADDWFC x6C,W
00BF2:  MOVWF  03
00BF4:  MOVFF  01,26D
00BF8:  MOVWF  x6E
00BFA:  MOVLB  0
00BFC:  CALL   035C
00C00:  MOVFF  26E,FEA
00C04:  MOVFF  26D,FE9
00C08:  MOVFF  02,FEC
00C0C:  MOVF   FED,F
00C0E:  MOVFF  01,FEF
....................    MyTCB.sHoleSize = -1; 
00C12:  SETF   xD8
00C14:  SETF   xD7
....................    MyTCB.remoteWindow = 1; 
00C16:  CLRF   xCA
00C18:  MOVLW  01
00C1A:  MOVWF  xC9
00C1C:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static WORD GetMaxSegSizeOption(void) 
....................  
....................   Summary: 
....................    Obtains the Maximum Segment Size (MSS) TCP Option out of the TCP header  
....................    for the current socket. 
....................  
....................   Description: 
....................    Parses the current TCP packet header and extracts the Maximum Segment Size  
....................    option.   
....................  
....................   Precondition: 
....................    Must be called while a TCP packet is present and being processed via  
....................    HandleTCPSeg() and only if the the TCP SYN flag is set. 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................    Maximum segment size option value.  If illegal or not present, a failsafe  
....................    value of 536 is returned.  If the option is larger than the  
....................    TCP_MAX_SEG_SIZE_TX upper limit, then TCP_MAX_SEG_SIZE_TX is returned. 
....................  
....................   Remarks: 
....................    The internal MAC Read Pointer is moved but not restored. 
....................   ***************************************************************************/ 
.................... static WORD GetMaxSegSizeOption(void) 
.................... { 
....................    BYTE vOptionsBytes; 
....................    BYTE vOption; 
....................    WORD wMSS; 
....................  
....................    // Find out how many options bytes are in this packet. 
....................    IPSetRxBuffer(2+2+4+4);   // Seek to data offset field, skipping Source port (2), Destination port (2), Sequence number (4), and Acknowledgement number (4) 
*
0362E:  MOVLB  1
03630:  CLRF   xC6
03632:  MOVLW  0C
03634:  MOVWF  xC5
03636:  MOVLB  0
03638:  RCALL  3008
....................    vOptionsBytes = MACGet(); 
0363A:  CALL   0846
0363E:  MOVFF  01,1C1
....................    vOptionsBytes = ((vOptionsBytes&0xF0)>>2) - sizeof(TCP_HEADER); 
03642:  MOVLB  1
03644:  MOVF   xC1,W
03646:  ANDLW  F0
03648:  MOVWF  00
0364A:  RRCF   00,F
0364C:  RRCF   00,F
0364E:  MOVLW  3F
03650:  ANDWF  00,F
03652:  MOVF   00,W
03654:  ADDLW  EC
03656:  MOVWF  xC1
....................  
....................    // Return minimum Maximum Segment Size value of 536 bytes if none are  
....................    // present 
....................    if(vOptionsBytes == 0u) 
03658:  MOVF   xC1,F
0365A:  BNZ   3666
....................       return 536; 
0365C:  MOVLW  18
0365E:  MOVWF  01
03660:  MOVLW  02
03662:  MOVWF  02
03664:  BRA    374A
....................        
....................    // Seek to beginning of options 
....................    MACGetArray(NULL, 7); 
03666:  MOVLB  2
03668:  CLRF   xC0
0366A:  CLRF   xBF
0366C:  CLRF   xC2
0366E:  MOVLW  07
03670:  MOVWF  xC1
03672:  MOVLB  0
03674:  CALL   07EA
....................  
....................    // Search for the Maximum Segment Size option    
....................    while(vOptionsBytes--) 
03678:  MOVLB  1
0367A:  MOVF   xC1,W
0367C:  DECF   xC1,F
0367E:  XORLW  00
03680:  BTFSC  FD8.2
03682:  BRA    3742
....................    { 
....................       vOption = MACGet(); 
03684:  MOVLB  0
03686:  CALL   0846
0368A:  MOVFF  01,1C2
....................        
....................       if(vOption == 0u)   // End of Options list 
0368E:  MOVLB  1
03690:  MOVF   xC2,F
03692:  BNZ   3696
....................          break; 
03694:  BRA    3742
....................        
....................       if(vOption == 1u)   // NOP option 
03696:  DECFSZ xC2,W
03698:  BRA    369C
....................          continue; 
0369A:  BRA    367A
....................           
....................       if(vOption == 2u)   // Maximum Segment Size option 
0369C:  MOVF   xC2,W
0369E:  SUBLW  02
036A0:  BNZ   370C
....................       { 
....................          if(vOptionsBytes < 3u) 
036A2:  MOVF   xC1,W
036A4:  SUBLW  02
036A6:  BNC   36AA
....................             break; 
036A8:  BRA    3742
....................  
....................          wMSS = 0; 
036AA:  CLRF   xC4
036AC:  CLRF   xC3
....................              
....................          // Get option length 
....................          vOption = MACGet(); 
036AE:  MOVLB  0
036B0:  CALL   0846
036B4:  MOVFF  01,1C2
....................          if(vOption == 4u) 
036B8:  MOVLB  1
036BA:  MOVF   xC2,W
036BC:  SUBLW  04
036BE:  BNZ   36D4
....................          {// Retrieve MSS and swap value to little endian 
....................             ((BYTE*)&wMSS)[1] = MACGet(); 
036C0:  MOVLB  0
036C2:  CALL   0846
036C6:  MOVFF  01,1C4
....................             ((BYTE*)&wMSS)[0] = MACGet(); 
036CA:  CALL   0846
036CE:  MOVFF  01,1C3
036D2:  MOVLB  1
....................          } 
....................           
....................          if(wMSS < 536u) 
036D4:  MOVF   xC4,W
036D6:  SUBLW  02
036D8:  BNC   36E4
036DA:  BNZ   36E2
036DC:  MOVF   xC3,W
036DE:  SUBLW  17
036E0:  BNC   36E4
....................             break; 
036E2:  BRA    3742
....................          if(wMSS > TCP_MAX_SEG_SIZE_TX) 
036E4:  MOVF   xC4,W
036E6:  SUBLW  04
036E8:  BC    3700
036EA:  XORLW  FF
036EC:  BNZ   36F4
036EE:  MOVF   xC3,W
036F0:  SUBLW  B4
036F2:  BC    3700
....................             return TCP_MAX_SEG_SIZE_TX; 
036F4:  MOVLW  B4
036F6:  MOVWF  01
036F8:  MOVLW  05
036FA:  MOVWF  02
036FC:  BRA    374A
036FE:  BRA    370A
....................          else  
....................             return wMSS; 
03700:  MOVFF  1C3,01
03704:  MOVFF  1C4,02
03708:  BRA    374A
....................       } 
0370A:  BRA    3740
....................       else 
....................       { // Assume this is a multi byte option and throw it way 
....................          if(vOptionsBytes < 2u) 
0370C:  MOVF   xC1,W
0370E:  SUBLW  01
03710:  BNC   3714
....................             break; 
03712:  BRA    3742
....................          vOption = MACGet(); 
03714:  MOVLB  0
03716:  CALL   0846
0371A:  MOVFF  01,1C2
....................          if(vOptionsBytes < vOption) 
0371E:  MOVLB  1
03720:  MOVF   xC2,W
03722:  SUBWF  xC1,W
03724:  BC    3728
....................             break; 
03726:  BRA    3742
....................          MACGetArray(NULL, vOption); 
03728:  MOVLB  2
0372A:  CLRF   xC0
0372C:  CLRF   xBF
0372E:  CLRF   xC2
03730:  MOVFF  1C2,2C1
03734:  MOVLB  0
03736:  CALL   07EA
....................          vOptionsBytes -= vOption; 
0373A:  MOVLB  1
0373C:  MOVF   xC2,W
0373E:  SUBWF  xC1,F
....................       } 
03740:  BRA    367A
....................        
....................    } 
....................     
....................    // Did not find MSS option, return worst case default 
....................    return 536; 
03742:  MOVLW  18
03744:  MOVWF  01
03746:  MOVLW  02
03748:  MOVWF  02
0374A:  MOVLB  0
0374C:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void HandleTCPSeg(TCP_HEADER* h, WORD len) 
....................  
....................   Summary: 
....................    Processes an incoming TCP segment. 
....................  
....................   Description: 
....................    Once an incoming segment has been matched to a socket, this function 
....................    performs the necessary processing with the data.  Depending on the  
....................    segment and the state, this may include copying data to the TCP buffer, 
....................    re-assembling out-of order packets, continuing an initialization or  
....................    closing handshake, or closing the socket altogether. 
....................  
....................   Precondition: 
....................    TCP is initialized and the current TCP stub is already synced. 
....................  
....................   Parameters: 
....................    h - The TCP header for this packet 
....................    len - The total buffer length of this segment 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... static void HandleTCPSeg(TCP_HEADER* h, WORD len) 
.................... { 
....................    DWORD dwTemp; 
....................    PTR_BASE wTemp; 
....................    LONG lMissingBytes; 
....................    WORD wMissingBytes; 
....................    WORD wFreeSpace; 
....................    BYTE localHeaderFlags; 
....................    DWORD localAckNumber; 
....................    DWORD localSeqNumber; 
....................    WORD wSegmentLength; 
....................    BOOL bSegmentAcceptable; 
....................    WORD wNewWindow; 
....................  
....................  
....................    // Cache a few variables in local RAM.   
....................    // PIC18s take a fair amount of code and execution time to  
....................    // dereference pointers frequently. 
....................    localHeaderFlags = h->Flags.byte; 
0374E:  MOVLW  0D
03750:  MOVLB  1
03752:  ADDWF  xA1,W
03754:  MOVWF  FE9
03756:  MOVLW  00
03758:  ADDWFC xA2,W
0375A:  MOVWF  FEA
0375C:  MOVFF  FEF,1B3
....................    localAckNumber = h->AckNumber; 
03760:  MOVLW  08
03762:  ADDWF  xA1,W
03764:  MOVWF  FE9
03766:  MOVLW  00
03768:  ADDWFC xA2,W
0376A:  MOVWF  FEA
0376C:  MOVFF  FEF,1B4
03770:  MOVFF  FEC,1B5
03774:  MOVFF  FEC,1B6
03778:  MOVFF  FEC,1B7
....................    localSeqNumber = h->SeqNumber; 
0377C:  MOVLW  04
0377E:  ADDWF  xA1,W
03780:  MOVWF  FE9
03782:  MOVLW  00
03784:  ADDWFC xA2,W
03786:  MOVWF  FEA
03788:  MOVFF  FEF,1B8
0378C:  MOVFF  FEC,1B9
03790:  MOVFF  FEC,1BA
03794:  MOVFF  FEC,1BB
....................  
....................    // We received a packet, reset the keep alive timer and count 
....................    #if defined(TCP_KEEP_ALIVE_TIMEOUT) 
....................       MyTCBStub.Flags.vUnackedKeepalives = 0; 
03798:  MOVLW  F8
0379A:  ANDWF  x32,W
0379C:  MOVWF  x32
....................       if(!MyTCBStub.Flags.bTimerEnabled) 
0379E:  BTFSC  x32.4
037A0:  BRA    37C2
....................          MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
037A2:  MOVLB  0
037A4:  CALL   0E34
037A8:  MOVLW  74
037AA:  MOVLB  1
037AC:  ADDWF  00,W
037AE:  MOVWF  x29
037B0:  MOVLW  35
037B2:  ADDWFC 01,W
037B4:  MOVWF  x2A
037B6:  MOVLW  06
037B8:  ADDWFC 02,W
037BA:  MOVWF  x2B
037BC:  MOVLW  00
037BE:  ADDWFC 03,W
037C0:  MOVWF  x2C
....................    #endif 
....................  
....................    // Handle TCP_LISTEN and TCP_SYN_SENT states 
....................    // Both of these states will return, so code following this  
....................    // state machine need not check explicitly for these two  
....................    // states. 
....................    switch(MyTCBStub.smState) 
037C2:  MOVF   x31,W
037C4:  XORLW  04
037C6:  MOVLB  0
037C8:  BZ    37D0
037CA:  XORLW  01
037CC:  BZ    3868
037CE:  BRA    3992
....................    { 
....................       case TCP_LISTEN: 
....................          // First: check RST flag 
....................          if(localHeaderFlags & RST) 
037D0:  MOVLB  1
037D2:  BTFSS  xB3.2
037D4:  BRA    37E2
....................          { 
....................             CloseSocket();   // Unbind remote IP address/port info 
037D6:  MOVLB  0
037D8:  CALL   0B52
....................             return; 
037DC:  GOTO   4874
037E0:  MOVLB  1
....................          } 
....................  
....................          // Second: check ACK flag, which would be invalid 
....................          if(localHeaderFlags & ACK) 
037E2:  BTFSS  xB3.4
037E4:  BRA    380E
....................          { 
....................             // Use a believable sequence number and reset the remote node 
....................             MyTCB.MySEQ = localAckNumber; 
037E6:  MOVFF  1B7,BE
037EA:  MOVFF  1B6,BD
037EE:  MOVFF  1B5,BC
037F2:  MOVFF  1B4,BB
....................             SendTCP(RST, 0); 
037F6:  MOVLW  04
037F8:  MOVLB  2
037FA:  MOVWF  x75
037FC:  CLRF   x76
037FE:  MOVLB  0
03800:  CALL   1774
....................             CloseSocket();   // Unbind remote IP address/port info 
03804:  CALL   0B52
....................             return; 
03808:  GOTO   4874
0380C:  MOVLB  1
....................          } 
....................  
....................          // Third: check for SYN flag, which is what we're looking for 
....................          if(localHeaderFlags & SYN) 
0380E:  BTFSS  xB3.1
03810:  BRA    385A
....................          { 
....................             // We now have a sequence number for the remote node 
....................             MyTCB.RemoteSEQ = localSeqNumber + 1; 
03812:  MOVLW  01
03814:  ADDWF  xB8,W
03816:  MOVLB  0
03818:  MOVWF  xBF
0381A:  MOVLW  00
0381C:  MOVLB  1
0381E:  ADDWFC xB9,W
03820:  MOVLB  0
03822:  MOVWF  xC0
03824:  MOVLW  00
03826:  MOVLB  1
03828:  ADDWFC xBA,W
0382A:  MOVLB  0
0382C:  MOVWF  xC1
0382E:  MOVLW  00
03830:  MOVLB  1
03832:  ADDWFC xBB,W
03834:  MOVLB  0
03836:  MOVWF  xC2
....................  
....................             // Get MSS option 
....................             MyTCB.wRemoteMSS = GetMaxSegSizeOption(); 
03838:  RCALL  362E
0383A:  MOVFF  02,DB
0383E:  MOVFF  01,DA
....................  
....................             // Set Initial Send Sequence (ISS) number 
....................             // Nothing to do on this step... ISS already set in CloseSocket() 
....................              
....................             // Respond with SYN + ACK 
....................             SendTCP(SYN | ACK, SENDTCP_RESET_TIMERS); 
03842:  MOVLW  12
03844:  MOVLB  2
03846:  MOVWF  x75
03848:  MOVLW  01
0384A:  MOVWF  x76
0384C:  MOVLB  0
0384E:  CALL   1774
....................             MyTCBStub.smState = TCP_SYN_RECEIVED; 
03852:  MOVLW  06
03854:  MOVLB  1
03856:  MOVWF  x31
....................          } 
03858:  BRA    3862
....................          else 
....................          { 
....................             CloseSocket();   // Unbind remote IP address/port info 
0385A:  MOVLB  0
0385C:  CALL   0B52
03860:  MOVLB  1
....................          } 
....................  
....................          // Fourth: check for other text and control 
....................          // Nothing to do since we don't support this 
....................          return; 
03862:  MOVLB  0
03864:  GOTO   4874
....................  
....................       case TCP_SYN_SENT: 
....................          // Second: check the RST bit 
....................          // This is out of order because this stack has no API for  
....................          // notifying the application that the connection seems to  
....................          // be failing.  Instead, the application must time out and  
....................          // the stack will just keep trying in the mean time. 
....................          if(localHeaderFlags & RST) 
03868:  MOVLB  1
0386A:  BTFSS  xB3.2
0386C:  BRA    3876
....................             return; 
0386E:  MOVLB  0
03870:  GOTO   4874
03874:  MOVLB  1
....................  
....................          // First: check ACK bit 
....................          if(localHeaderFlags & ACK) 
03876:  BTFSS  xB3.4
03878:  BRA    38E8
....................          { 
....................             if(localAckNumber != MyTCB.MySEQ) 
0387A:  MOVLB  0
0387C:  MOVF   xBB,W
0387E:  MOVLB  1
03880:  SUBWF  xB4,W
03882:  BNZ   38A2
03884:  MOVLB  0
03886:  MOVF   xBC,W
03888:  MOVLB  1
0388A:  SUBWF  xB5,W
0388C:  BNZ   38A2
0388E:  MOVLB  0
03890:  MOVF   xBD,W
03892:  MOVLB  1
03894:  SUBWF  xB6,W
03896:  BNZ   38A2
03898:  MOVLB  0
0389A:  MOVF   xBE,W
0389C:  MOVLB  1
0389E:  SUBWF  xB7,W
038A0:  BZ    38E8
....................             { 
....................                // Send a RST packet with SEQ = SEG.ACK, but retain our SEQ  
....................                // number for arivial of any other SYN+ACK packets 
....................                localSeqNumber = MyTCB.MySEQ;   // Save our original SEQ number 
038A2:  MOVFF  BE,1BB
038A6:  MOVFF  BD,1BA
038AA:  MOVFF  BC,1B9
038AE:  MOVFF  BB,1B8
....................                MyTCB.MySEQ = localAckNumber;   // Set SEQ = SEG.ACK 
038B2:  MOVFF  1B7,BE
038B6:  MOVFF  1B6,BD
038BA:  MOVFF  1B5,BC
038BE:  MOVFF  1B4,BB
....................                SendTCP(RST, SENDTCP_RESET_TIMERS);      // Send the RST 
038C2:  MOVLW  04
038C4:  MOVLB  2
038C6:  MOVWF  x75
038C8:  MOVLW  01
038CA:  MOVWF  x76
038CC:  MOVLB  0
038CE:  CALL   1774
....................                MyTCB.MySEQ = localSeqNumber;   // Restore original SEQ number 
038D2:  MOVFF  1BB,BE
038D6:  MOVFF  1BA,BD
038DA:  MOVFF  1B9,BC
038DE:  MOVFF  1B8,BB
....................                return; 
038E2:  GOTO   4874
038E6:  MOVLB  1
....................             } 
....................          } 
....................  
....................          // Third: check the security and precedence 
....................          // No such feature in this stack.  We want to accept all connections. 
....................  
....................          // Fourth: check the SYN bit 
....................          if(localHeaderFlags & SYN) 
038E8:  BTFSS  xB3.1
038EA:  BRA    398C
....................          { 
....................             // We now have an initial sequence number and window size 
....................             MyTCB.RemoteSEQ = localSeqNumber + 1; 
038EC:  MOVLW  01
038EE:  ADDWF  xB8,W
038F0:  MOVLB  0
038F2:  MOVWF  xBF
038F4:  MOVLW  00
038F6:  MOVLB  1
038F8:  ADDWFC xB9,W
038FA:  MOVLB  0
038FC:  MOVWF  xC0
038FE:  MOVLW  00
03900:  MOVLB  1
03902:  ADDWFC xBA,W
03904:  MOVLB  0
03906:  MOVWF  xC1
03908:  MOVLW  00
0390A:  MOVLB  1
0390C:  ADDWFC xBB,W
0390E:  MOVLB  0
03910:  MOVWF  xC2
....................             MyTCB.remoteWindow = h->Window; 
03912:  MOVLW  0E
03914:  MOVLB  1
03916:  ADDWF  xA1,W
03918:  MOVWF  FE9
0391A:  MOVLW  00
0391C:  ADDWFC xA2,W
0391E:  MOVWF  FEA
03920:  MOVFF  FEC,CA
03924:  MOVF   FED,F
03926:  MOVFF  FEF,C9
....................  
....................             // Get MSS option 
....................             MyTCB.wRemoteMSS = GetMaxSegSizeOption(); 
0392A:  MOVLB  0
0392C:  RCALL  362E
0392E:  MOVFF  02,DB
03932:  MOVFF  01,DA
....................  
....................             if(localHeaderFlags & ACK) 
03936:  MOVLB  1
03938:  BTFSS  xB3.4
0393A:  BRA    3976
....................             { 
....................                SendTCP(ACK, SENDTCP_RESET_TIMERS); 
0393C:  MOVLW  10
0393E:  MOVLB  2
03940:  MOVWF  x75
03942:  MOVLW  01
03944:  MOVWF  x76
03946:  MOVLB  0
03948:  CALL   1774
....................                MyTCBStub.smState = TCP_ESTABLISHED; 
0394C:  MOVLW  07
0394E:  MOVLB  1
03950:  MOVWF  x31
....................                // Set up keep-alive timer 
....................                #if defined(TCP_KEEP_ALIVE_TIMEOUT) 
....................                   MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
03952:  MOVLB  0
03954:  CALL   0E34
03958:  MOVLW  74
0395A:  MOVLB  1
0395C:  ADDWF  00,W
0395E:  MOVWF  x29
03960:  MOVLW  35
03962:  ADDWFC 01,W
03964:  MOVWF  x2A
03966:  MOVLW  06
03968:  ADDWFC 02,W
0396A:  MOVWF  x2B
0396C:  MOVLW  00
0396E:  ADDWFC 03,W
03970:  MOVWF  x2C
....................                #endif 
....................                MyTCBStub.Flags.bTimerEnabled = 0; 
03972:  BCF    x32.4
....................             } 
03974:  BRA    398C
....................             else 
....................             { 
....................                SendTCP(SYN | ACK, SENDTCP_RESET_TIMERS); 
03976:  MOVLW  12
03978:  MOVLB  2
0397A:  MOVWF  x75
0397C:  MOVLW  01
0397E:  MOVWF  x76
03980:  MOVLB  0
03982:  CALL   1774
....................                MyTCBStub.smState = TCP_SYN_RECEIVED; 
03986:  MOVLW  06
03988:  MOVLB  1
0398A:  MOVWF  x31
....................             } 
....................          } 
....................  
....................          // Fifth: drop the segment if neither SYN or RST is set 
....................          return; 
0398C:  MOVLB  0
0398E:  GOTO   4874
....................  
....................       default: 
....................          break; 
....................    } 
....................  
....................    // 
....................    // First: check the sequence number 
....................    // 
....................    wSegmentLength = len; 
03992:  MOVFF  1A4,1BD
03996:  MOVFF  1A3,1BC
....................    if(localHeaderFlags & FIN) 
0399A:  MOVLB  1
0399C:  BTFSS  xB3.0
0399E:  BRA    39A6
....................       wSegmentLength++; 
039A0:  INCF   xBC,F
039A2:  BTFSC  FD8.2
039A4:  INCF   xBD,F
....................    if(localHeaderFlags & SYN) 
039A6:  BTFSS  xB3.1
039A8:  BRA    39B0
....................       wSegmentLength++; 
039AA:  INCF   xBC,F
039AC:  BTFSC  FD8.2
039AE:  INCF   xBD,F
....................  
....................    // Calculate the RX FIFO space 
....................    if(MyTCBStub.rxHead >= MyTCBStub.rxTail) 
039B0:  MOVF   x28,W
039B2:  SUBWF  x26,W
039B4:  BNC   39E4
039B6:  BNZ   39BE
039B8:  MOVF   x27,W
039BA:  SUBWF  x25,W
039BC:  BNC   39E4
....................       wFreeSpace = (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart) - (MyTCBStub.rxHead - MyTCBStub.rxTail); 
039BE:  MOVF   x1D,W
039C0:  SUBWF  x1F,W
039C2:  MOVWF  xC1
039C4:  MOVF   x1E,W
039C6:  SUBWFB x20,W
039C8:  MOVWF  xC2
039CA:  MOVF   x27,W
039CC:  SUBWF  x25,W
039CE:  MOVWF  00
039D0:  MOVF   x28,W
039D2:  SUBWFB x26,W
039D4:  MOVWF  03
039D6:  MOVF   00,W
039D8:  SUBWF  xC1,W
039DA:  MOVWF  xB1
039DC:  MOVF   03,W
039DE:  SUBWFB xC2,W
039E0:  MOVWF  xB2
039E2:  BRA    39FC
....................    else 
....................       wFreeSpace = MyTCBStub.rxTail - MyTCBStub.rxHead - 1; 
039E4:  MOVF   x25,W
039E6:  SUBWF  x27,W
039E8:  MOVWF  xC1
039EA:  MOVF   x26,W
039EC:  SUBWFB x28,W
039EE:  MOVWF  xC2
039F0:  MOVLW  01
039F2:  SUBWF  xC1,W
039F4:  MOVWF  xB1
039F6:  MOVLW  00
039F8:  SUBWFB xC2,W
039FA:  MOVWF  xB2
....................  
....................    // Calculate the number of bytes ahead of our head pointer this segment skips 
....................    lMissingBytes = localSeqNumber - MyTCB.RemoteSEQ; 
039FC:  MOVLB  0
039FE:  MOVF   xBF,W
03A00:  MOVLB  1
03A02:  SUBWF  xB8,W
03A04:  MOVWF  00
03A06:  MOVLB  0
03A08:  MOVF   xC0,W
03A0A:  MOVLB  1
03A0C:  SUBWFB xB9,W
03A0E:  MOVWF  01
03A10:  MOVLB  0
03A12:  MOVF   xC1,W
03A14:  MOVLB  1
03A16:  SUBWFB xBA,W
03A18:  MOVWF  02
03A1A:  MOVLB  0
03A1C:  MOVF   xC2,W
03A1E:  MOVLB  1
03A20:  SUBWFB xBB,W
03A22:  MOVWF  xAE
03A24:  MOVFF  02,1AD
03A28:  MOVFF  01,1AC
03A2C:  MOVFF  00,1AB
....................    wMissingBytes = (WORD)lMissingBytes; 
03A30:  MOVFF  1AC,1B0
03A34:  MOVFF  1AB,1AF
....................     
....................    // Run TCP acceptability tests to verify that this packet has a valid sequence number 
....................    bSegmentAcceptable = FALSE; 
03A38:  BCF    xBE.0
....................    if(wSegmentLength) 
03A3A:  MOVF   xBC,W
03A3C:  IORWF  xBD,W
03A3E:  BTFSC  FD8.2
03A40:  BRA    3B44
....................    { 
....................       // Check to see if we have free space, and if so, if any of the data falls within the freespace 
....................       if(wFreeSpace) 
03A42:  MOVF   xB1,W
03A44:  IORWF  xB2,W
03A46:  BTFSC  FD8.2
03A48:  BRA    3B42
....................       { 
....................          // RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND 
....................          if((lMissingBytes >= (LONG)0) && (wFreeSpace > (DWORD)lMissingBytes)) 
03A4A:  BTFSC  xAE.7
03A4C:  BRA    3A68
03A4E:  MOVF   xAE,F
03A50:  BNZ   3A68
03A52:  MOVF   xAD,F
03A54:  BNZ   3A68
03A56:  MOVF   xAC,W
03A58:  SUBWF  xB2,W
03A5A:  BNC   3A68
03A5C:  BNZ   3A64
03A5E:  MOVF   xB1,W
03A60:  SUBWF  xAB,W
03A62:  BC    3A68
....................             bSegmentAcceptable = TRUE; 
03A64:  BSF    xBE.0
03A66:  BRA    3AEE
....................          else 
....................          { 
....................             // RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND 
....................             if((lMissingBytes + (LONG)wSegmentLength > (LONG)0) && (lMissingBytes <= (LONG)(SHORT)(wFreeSpace - wSegmentLength))) 
03A68:  MOVFF  1BC,00
03A6C:  MOVFF  1BD,01
03A70:  CLRF   02
03A72:  CLRF   03
03A74:  MOVF   xBC,W
03A76:  ADDWF  xAB,W
03A78:  MOVWF  xC1
03A7A:  MOVF   xBD,W
03A7C:  ADDWFC xAC,W
03A7E:  MOVWF  xC2
03A80:  MOVF   02,W
03A82:  ADDWFC xAD,W
03A84:  MOVWF  xC3
03A86:  MOVF   03,W
03A88:  ADDWFC xAE,W
03A8A:  MOVWF  xC4
03A8C:  BTFSC  FE8.7
03A8E:  BRA    3AEE
03A90:  MOVF   xC4,F
03A92:  BNZ   3AA2
03A94:  MOVF   xC3,F
03A96:  BNZ   3AA2
03A98:  MOVF   xC2,F
03A9A:  BNZ   3AA2
03A9C:  MOVF   xC1,W
03A9E:  SUBLW  00
03AA0:  BC    3AEE
03AA2:  MOVF   xBC,W
03AA4:  SUBWF  xB1,W
03AA6:  MOVWF  00
03AA8:  MOVF   xBD,W
03AAA:  SUBWFB xB2,W
03AAC:  MOVWF  03
03AAE:  MOVF   00,W
03AB0:  MOVFF  03,01
03AB4:  CLRF   02
03AB6:  CLRF   03
03AB8:  BTFSS  01.7
03ABA:  BRA    3AC0
03ABC:  DECF   02,F
03ABE:  DECF   03,F
03AC0:  BTFSS  xAE.7
03AC2:  BRA    3ACA
03AC4:  BTFSS  03.7
03AC6:  BRA    3AEC
03AC8:  BRA    3ACE
03ACA:  BTFSC  03.7
03ACC:  BRA    3AEE
03ACE:  MOVF   xAE,W
03AD0:  SUBWF  03,W
03AD2:  BNC   3AEE
03AD4:  BNZ   3AEC
03AD6:  MOVF   xAD,W
03AD8:  SUBWF  02,W
03ADA:  BNC   3AEE
03ADC:  BNZ   3AEC
03ADE:  MOVF   xAC,W
03AE0:  SUBWF  01,W
03AE2:  BNC   3AEE
03AE4:  BNZ   3AEC
03AE6:  MOVF   xAB,W
03AE8:  SUBWF  00,W
03AEA:  BNC   3AEE
....................                bSegmentAcceptable = TRUE; 
03AEC:  BSF    xBE.0
....................          } 
....................           
....................          if((lMissingBytes < (LONG)wFreeSpace) && ((SHORT)wMissingBytes + (SHORT)wSegmentLength > (SHORT)0)) 
03AEE:  MOVFF  1B1,00
03AF2:  MOVFF  1B2,01
03AF6:  CLRF   02
03AF8:  CLRF   03
03AFA:  BTFSS  xAE.7
03AFC:  BRA    3B04
03AFE:  BTFSS  03.7
03B00:  BRA    3B26
03B02:  BRA    3B08
03B04:  BTFSC  03.7
03B06:  BRA    3B42
03B08:  MOVF   xAE,W
03B0A:  SUBWF  03,W
03B0C:  BNC   3B42
03B0E:  BNZ   3B26
03B10:  MOVF   xAD,W
03B12:  SUBWF  02,W
03B14:  BNC   3B42
03B16:  BNZ   3B26
03B18:  MOVF   xAC,W
03B1A:  SUBWF  01,W
03B1C:  BNC   3B42
03B1E:  BNZ   3B26
03B20:  MOVF   00,W
03B22:  SUBWF  xAB,W
03B24:  BC    3B42
03B26:  MOVF   xBC,W
03B28:  ADDWF  xAF,W
03B2A:  MOVWF  xC1
03B2C:  MOVF   xBD,W
03B2E:  ADDWFC xB0,W
03B30:  MOVWF  xC2
03B32:  BTFSC  FE8.7
03B34:  BRA    3B42
03B36:  MOVF   xC2,F
03B38:  BNZ   3B40
03B3A:  MOVF   xC1,W
03B3C:  SUBLW  00
03B3E:  BC    3B42
....................             bSegmentAcceptable = TRUE; 
03B40:  BSF    xBE.0
....................       } 
....................       // Segments with data are not acceptable if we have no free space 
....................    } 
03B42:  BRA    3B74
....................    else 
....................    { 
....................       // Zero length packets are acceptable if they fall within our free space window 
....................       // SEG.SEQ = RCV.NXT 
....................       if(lMissingBytes == 0) 
03B44:  MOVF   xAB,F
03B46:  BNZ   3B58
03B48:  MOVF   xAC,F
03B4A:  BNZ   3B58
03B4C:  MOVF   xAD,F
03B4E:  BNZ   3B58
03B50:  MOVF   xAE,F
03B52:  BNZ   3B58
....................       { 
....................          bSegmentAcceptable = TRUE; 
03B54:  BSF    xBE.0
....................       } 
03B56:  BRA    3B74
....................       else 
....................       { 
....................          // RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND 
....................          if((lMissingBytes >= (LONG)0) && (wFreeSpace > (DWORD)lMissingBytes)) 
03B58:  BTFSC  xAE.7
03B5A:  BRA    3B74
03B5C:  MOVF   xAE,F
03B5E:  BNZ   3B74
03B60:  MOVF   xAD,F
03B62:  BNZ   3B74
03B64:  MOVF   xAC,W
03B66:  SUBWF  xB2,W
03B68:  BNC   3B74
03B6A:  BNZ   3B72
03B6C:  MOVF   xB1,W
03B6E:  SUBWF  xAB,W
03B70:  BC    3B74
....................             bSegmentAcceptable = TRUE; 
03B72:  BSF    xBE.0
....................       } 
....................    } 
....................     
....................    if(!bSegmentAcceptable) 
03B74:  BTFSC  xBE.0
03B76:  BRA    3B96
....................    { 
....................       // Unacceptable segment, drop it and respond appropriately 
....................       if(!(localHeaderFlags & RST))  
03B78:  BTFSC  xB3.2
03B7A:  BRA    3B8E
....................          SendTCP(ACK, SENDTCP_RESET_TIMERS); 
03B7C:  MOVLW  10
03B7E:  MOVLB  2
03B80:  MOVWF  x75
03B82:  MOVLW  01
03B84:  MOVWF  x76
03B86:  MOVLB  0
03B88:  CALL   1774
03B8C:  MOVLB  1
....................       return; 
03B8E:  MOVLB  0
03B90:  GOTO   4874
03B94:  MOVLB  1
....................    } 
....................  
....................  
....................    // 
....................    // Second: check the RST bit 
....................    // 
....................    // 
....................    // Fourth: check the SYN bit 
....................    // 
....................    // Note, that since the third step is not implemented, we can  
....................    // combine this second and fourth step into a single operation. 
....................    if(localHeaderFlags & (RST | SYN)) 
03B96:  MOVF   xB3,W
03B98:  ANDLW  06
03B9A:  BZ    3BA8
....................    { 
....................       CloseSocket(); 
03B9C:  MOVLB  0
03B9E:  CALL   0B52
....................       return; 
03BA2:  GOTO   4874
03BA6:  MOVLB  1
....................    } 
....................  
....................    // 
....................    // Third: check the security and precedence 
....................    // 
....................    // Feature not supported.  Let's process this segment. 
....................  
....................    // 
....................    // Fifth: check the ACK bit 
....................    // 
....................    if(!(localHeaderFlags & ACK)) 
03BA8:  BTFSC  xB3.4
03BAA:  BRA    3BB4
....................       return; 
03BAC:  MOVLB  0
03BAE:  GOTO   4874
03BB2:  MOVLB  1
....................  
....................    switch(MyTCBStub.smState) 
03BB4:  MOVF   x31,W
03BB6:  XORLW  06
03BB8:  MOVLB  0
03BBA:  BZ    3BD8
03BBC:  XORLW  01
03BBE:  BZ    3C4A
03BC0:  XORLW  0F
03BC2:  BZ    3C4A
03BC4:  XORLW  01
03BC6:  BZ    3C4A
03BC8:  XORLW  02
03BCA:  BZ    3C4A
03BCC:  XORLW  01
03BCE:  BZ    3C4A
03BD0:  XORLW  06
03BD2:  BTFSC  FD8.2
03BD4:  BRA    41A2
03BD6:  BRA    41EC
....................    { 
....................       case TCP_SYN_RECEIVED: 
....................          if(localAckNumber != MyTCB.MySEQ) 
03BD8:  MOVF   xBB,W
03BDA:  MOVLB  1
03BDC:  SUBWF  xB4,W
03BDE:  BNZ   3BFE
03BE0:  MOVLB  0
03BE2:  MOVF   xBC,W
03BE4:  MOVLB  1
03BE6:  SUBWF  xB5,W
03BE8:  BNZ   3BFE
03BEA:  MOVLB  0
03BEC:  MOVF   xBD,W
03BEE:  MOVLB  1
03BF0:  SUBWF  xB6,W
03BF2:  BNZ   3BFE
03BF4:  MOVLB  0
03BF6:  MOVF   xBE,W
03BF8:  MOVLB  1
03BFA:  SUBWF  xB7,W
03BFC:  BZ    3C44
....................          { 
....................             // Send a RST packet with SEQ = SEG.ACK, but retain our SEQ  
....................             // number for arivial of any other correct packets 
....................             localSeqNumber = MyTCB.MySEQ;   // Save our original SEQ number 
03BFE:  MOVFF  BE,1BB
03C02:  MOVFF  BD,1BA
03C06:  MOVFF  BC,1B9
03C0A:  MOVFF  BB,1B8
....................             MyTCB.MySEQ = localAckNumber;   // Set SEQ = SEG.ACK 
03C0E:  MOVFF  1B7,BE
03C12:  MOVFF  1B6,BD
03C16:  MOVFF  1B5,BC
03C1A:  MOVFF  1B4,BB
....................             SendTCP(RST, SENDTCP_RESET_TIMERS);      // Send the RST 
03C1E:  MOVLW  04
03C20:  MOVLB  2
03C22:  MOVWF  x75
03C24:  MOVLW  01
03C26:  MOVWF  x76
03C28:  MOVLB  0
03C2A:  CALL   1774
....................             MyTCB.MySEQ = localSeqNumber;   // Restore original SEQ number 
03C2E:  MOVFF  1BB,BE
03C32:  MOVFF  1BA,BD
03C36:  MOVFF  1B9,BC
03C3A:  MOVFF  1B8,BB
....................             return; 
03C3E:  GOTO   4874
03C42:  MOVLB  1
....................          } 
....................          MyTCBStub.smState = TCP_ESTABLISHED; 
03C44:  MOVLW  07
03C46:  MOVWF  x31
03C48:  MOVLB  0
....................          // No break 
....................  
....................       case TCP_ESTABLISHED: 
....................       case TCP_FIN_WAIT_1: 
....................       case TCP_FIN_WAIT_2: 
....................       case TCP_CLOSE_WAIT: 
....................       case TCP_CLOSING: 
....................          // Calculate what the highest possible SEQ number in our TX FIFO is 
....................          wTemp = MyTCBStub.txHead - MyTCB.txUnackedTail; 
03C4A:  MOVF   xC3,W
03C4C:  MOVLB  1
03C4E:  SUBWF  x21,W
03C50:  MOVWF  xA9
03C52:  MOVLB  0
03C54:  MOVF   xC4,W
03C56:  MOVLB  1
03C58:  SUBWFB x22,W
03C5A:  MOVWF  xAA
....................          if((SHORT)wTemp < (SHORT)0) 
03C5C:  BTFSS  xAA.7
03C5E:  BRA    3C74
....................             wTemp += MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
03C60:  MOVF   x1B,W
03C62:  SUBWF  x1D,W
03C64:  MOVWF  00
03C66:  MOVF   x1C,W
03C68:  SUBWFB x1E,W
03C6A:  MOVWF  03
03C6C:  MOVF   00,W
03C6E:  ADDWF  xA9,F
03C70:  MOVF   03,W
03C72:  ADDWFC xAA,F
....................          dwTemp = MyTCB.MySEQ + (DWORD)wTemp; 
03C74:  CLRF   02
03C76:  CLRF   03
03C78:  MOVF   xA9,W
03C7A:  MOVLB  0
03C7C:  ADDWF  xBB,W
03C7E:  MOVLB  1
03C80:  MOVWF  xA5
03C82:  MOVF   xAA,W
03C84:  MOVLB  0
03C86:  ADDWFC xBC,W
03C88:  MOVLB  1
03C8A:  MOVWF  xA6
03C8C:  MOVF   02,W
03C8E:  MOVLB  0
03C90:  ADDWFC xBD,W
03C92:  MOVLB  1
03C94:  MOVWF  xA7
03C96:  MOVF   03,W
03C98:  MOVLB  0
03C9A:  ADDWFC xBE,W
03C9C:  MOVLB  1
03C9E:  MOVWF  xA8
....................  
....................          // Drop the packet if it ACKs something we haven't sent 
....................             dwTemp = (LONG)localAckNumber - (LONG)dwTemp; 
03CA0:  MOVF   xA5,W
03CA2:  SUBWF  xB4,W
03CA4:  MOVWF  00
03CA6:  MOVF   xA6,W
03CA8:  SUBWFB xB5,W
03CAA:  MOVWF  01
03CAC:  MOVF   xA7,W
03CAE:  SUBWFB xB6,W
03CB0:  MOVWF  02
03CB2:  MOVF   xA8,W
03CB4:  SUBWFB xB7,W
03CB6:  MOVWF  xA8
03CB8:  MOVFF  02,1A7
03CBC:  MOVFF  01,1A6
03CC0:  MOVFF  00,1A5
....................             if((LONG)dwTemp > 0) 
03CC4:  BTFSC  xA8.7
03CC6:  BRA    3D2C
03CC8:  MOVF   xA8,F
03CCA:  BNZ   3CDA
03CCC:  MOVF   xA7,F
03CCE:  BNZ   3CDA
03CD0:  MOVF   xA6,F
03CD2:  BNZ   3CDA
03CD4:  MOVF   xA5,W
03CD6:  SUBLW  00
03CD8:  BC    3D2C
....................             {   // acknowledged more than we've sent?? 
....................                 if(!MyTCB.flags.bFINSent || dwTemp != 1) 
03CDA:  MOVLB  0
03CDC:  BTFSS  xD9.0
03CDE:  BRA    3D06
03CE0:  MOVLB  1
03CE2:  DECFSZ xA5,W
03CE4:  BRA    3CE8
03CE6:  BRA    3CEC
03CE8:  MOVLB  0
03CEA:  BRA    3D06
03CEC:  MOVF   xA6,F
03CEE:  BTFSC  FD8.2
03CF0:  BRA    3CF6
03CF2:  MOVLB  0
03CF4:  BRA    3D06
03CF6:  MOVF   xA7,F
03CF8:  BTFSC  FD8.2
03CFA:  BRA    3D00
03CFC:  MOVLB  0
03CFE:  BRA    3D06
03D00:  MOVF   xA8,F
03D02:  BZ    3D1C
03D04:  MOVLB  0
....................                 { 
....................                     SendTCP(ACK, 0); 
03D06:  MOVLW  10
03D08:  MOVLB  2
03D0A:  MOVWF  x75
03D0C:  CLRF   x76
03D0E:  MOVLB  0
03D10:  CALL   1774
....................                     return; 
03D14:  GOTO   4874
....................                 } 
03D18:  BRA    3D2E
03D1A:  MOVLB  1
....................                 else 
....................                 { 
....................                     localAckNumber--;   // since we don't count the FIN anyway 
03D1C:  MOVLW  FF
03D1E:  ADDWF  xB4,F
03D20:  BTFSS  FD8.0
03D22:  ADDWF  xB5,F
03D24:  BTFSS  FD8.0
03D26:  ADDWF  xB6,F
03D28:  BTFSS  FD8.0
03D2A:  ADDWF  xB7,F
03D2C:  MOVLB  0
....................                 } 
....................             } 
....................  
....................          // Throw away all ACKnowledged TX data: 
....................          // Calculate what the last acknowledged sequence number was (ignoring any FINs we sent) 
....................          dwTemp = MyTCB.MySEQ - (LONG)(SHORT)(MyTCB.txUnackedTail - MyTCBStub.txTail); 
03D2E:  MOVLB  1
03D30:  MOVF   x23,W
03D32:  MOVLB  0
03D34:  SUBWF  xC3,W
03D36:  MOVWF  00
03D38:  MOVLB  1
03D3A:  MOVF   x24,W
03D3C:  MOVLB  0
03D3E:  SUBWFB xC4,W
03D40:  MOVWF  03
03D42:  MOVF   00,W
03D44:  MOVFF  03,01
03D48:  CLRF   02
03D4A:  CLRF   03
03D4C:  BTFSS  01.7
03D4E:  BRA    3D54
03D50:  DECF   02,F
03D52:  DECF   03,F
03D54:  MOVF   00,W
03D56:  SUBWF  xBB,W
03D58:  MOVWF  00
03D5A:  MOVF   01,W
03D5C:  SUBWFB xBC,W
03D5E:  MOVWF  01
03D60:  MOVF   02,W
03D62:  SUBWFB xBD,W
03D64:  MOVWF  02
03D66:  MOVF   03,W
03D68:  SUBWFB xBE,W
03D6A:  MOVFF  FE8,1A8
03D6E:  MOVFF  02,1A7
03D72:  MOVFF  01,1A6
03D76:  MOVFF  00,1A5
....................          if(MyTCB.txUnackedTail < MyTCBStub.txTail) 
03D7A:  MOVF   xC4,W
03D7C:  MOVLB  1
03D7E:  SUBWF  x24,W
03D80:  BNC   3DAE
03D82:  BNZ   3D94
03D84:  MOVF   x23,W
03D86:  MOVLB  0
03D88:  SUBWF  xC3,W
03D8A:  BTFSS  FD8.0
03D8C:  BRA    3D92
03D8E:  MOVLB  1
03D90:  BRA    3DAE
03D92:  MOVLB  1
....................             dwTemp -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
03D94:  MOVF   x1B,W
03D96:  SUBWF  x1D,W
03D98:  MOVWF  00
03D9A:  MOVF   x1C,W
03D9C:  SUBWFB x1E,W
03D9E:  MOVWF  03
03DA0:  MOVF   00,W
03DA2:  SUBWF  xA5,F
03DA4:  MOVF   03,W
03DA6:  SUBWFB xA6,F
03DA8:  MOVLW  00
03DAA:  SUBWFB xA7,F
03DAC:  SUBWFB xA8,F
....................     
....................          // Calcluate how many bytes were ACKed with this packet 
....................          dwTemp = localAckNumber - dwTemp; 
03DAE:  MOVF   xA5,W
03DB0:  SUBWF  xB4,W
03DB2:  MOVWF  xA5
03DB4:  MOVF   xA6,W
03DB6:  SUBWFB xB5,W
03DB8:  MOVWF  xA6
03DBA:  MOVF   xA7,W
03DBC:  SUBWFB xB6,W
03DBE:  MOVWF  xA7
03DC0:  MOVF   xA8,W
03DC2:  SUBWFB xB7,W
03DC4:  MOVWF  xA8
....................          if(((LONG)(dwTemp) > (LONG)0) && (dwTemp <= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart)) 
03DC6:  BTFSC  xA8.7
03DC8:  BRA    3F2E
03DCA:  MOVF   xA8,F
03DCC:  BNZ   3DDE
03DCE:  MOVF   xA7,F
03DD0:  BNZ   3DDE
03DD2:  MOVF   xA6,F
03DD4:  BNZ   3DDE
03DD6:  MOVF   xA5,W
03DD8:  SUBLW  00
03DDA:  BTFSC  FD8.0
03DDC:  BRA    3F2E
03DDE:  MOVF   x1B,W
03DE0:  SUBWF  x1D,W
03DE2:  MOVWF  00
03DE4:  MOVF   x1C,W
03DE6:  SUBWFB x1E,W
03DE8:  MOVWF  03
03DEA:  MOVFF  00,01
03DEE:  MOVF   xA8,F
03DF0:  BTFSS  FD8.2
03DF2:  BRA    3F2E
03DF4:  MOVF   xA7,F
03DF6:  BTFSS  FD8.2
03DF8:  BRA    3F2E
03DFA:  MOVF   xA6,W
03DFC:  SUBWF  03,W
03DFE:  BTFSS  FD8.0
03E00:  BRA    3F2E
03E02:  BNZ   3E0C
03E04:  MOVF   xA5,W
03E06:  SUBWF  01,W
03E08:  BTFSS  FD8.0
03E0A:  BRA    3F2E
....................          { 
....................             MyTCB.flags.bRXNoneACKed1 = 0; 
03E0C:  MOVLB  0
03E0E:  BCF    xD9.3
....................             MyTCB.flags.bRXNoneACKed2 = 0; 
03E10:  BCF    xD9.4
....................             MyTCBStub.Flags.bHalfFullFlush = FALSE; 
03E12:  MOVLB  1
03E14:  BCF    x33.0
....................     
....................             // Bytes ACKed, free up the TX FIFO space 
....................             wTemp = MyTCBStub.txTail; 
03E16:  MOVFF  124,1AA
03E1A:  MOVFF  123,1A9
....................             MyTCBStub.txTail += dwTemp; 
03E1E:  MOVF   xA5,W
03E20:  ADDWF  x23,F
03E22:  MOVF   xA6,W
03E24:  ADDWFC x24,F
....................             if(MyTCB.txUnackedTail >= wTemp) 
03E26:  MOVF   xAA,W
03E28:  MOVLB  0
03E2A:  SUBWF  xC4,W
03E2C:  BNC   3E86
03E2E:  BNZ   3E3A
03E30:  MOVLB  1
03E32:  MOVF   xA9,W
03E34:  MOVLB  0
03E36:  SUBWF  xC3,W
03E38:  BNC   3E86
....................             { 
....................                if(MyTCB.txUnackedTail < MyTCBStub.txTail) 
03E3A:  MOVF   xC4,W
03E3C:  MOVLB  1
03E3E:  SUBWF  x24,W
03E40:  BNC   3E82
03E42:  BNZ   3E54
03E44:  MOVF   x23,W
03E46:  MOVLB  0
03E48:  SUBWF  xC3,W
03E4A:  BTFSS  FD8.0
03E4C:  BRA    3E52
03E4E:  MOVLB  1
03E50:  BRA    3E82
03E52:  MOVLB  1
....................                { 
....................                   MyTCB.MySEQ += MyTCBStub.txTail - MyTCB.txUnackedTail; 
03E54:  MOVLB  0
03E56:  MOVF   xC3,W
03E58:  MOVLB  1
03E5A:  SUBWF  x23,W
03E5C:  MOVWF  00
03E5E:  MOVLB  0
03E60:  MOVF   xC4,W
03E62:  MOVLB  1
03E64:  SUBWFB x24,W
03E66:  MOVWF  03
03E68:  MOVF   00,W
03E6A:  MOVLB  0
03E6C:  ADDWF  xBB,F
03E6E:  MOVF   03,W
03E70:  ADDWFC xBC,F
03E72:  MOVLW  00
03E74:  ADDWFC xBD,F
03E76:  ADDWFC xBE,F
....................                   MyTCB.txUnackedTail = MyTCBStub.txTail; 
03E78:  MOVFF  124,C4
03E7C:  MOVFF  123,C3
03E80:  MOVLB  1
....................                } 
....................             } 
03E82:  BRA    3EDC
03E84:  MOVLB  0
....................             else 
....................             { 
....................                wTemp = MyTCB.txUnackedTail + (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart); 
03E86:  MOVLB  1
03E88:  MOVF   x1B,W
03E8A:  SUBWF  x1D,W
03E8C:  MOVWF  00
03E8E:  MOVF   x1C,W
03E90:  SUBWFB x1E,W
03E92:  MOVWF  03
03E94:  MOVF   00,W
03E96:  MOVLB  0
03E98:  ADDWF  xC3,W
03E9A:  MOVLB  1
03E9C:  MOVWF  xA9
03E9E:  MOVF   03,W
03EA0:  MOVLB  0
03EA2:  ADDWFC xC4,W
03EA4:  MOVLB  1
03EA6:  MOVWF  xAA
....................                if(wTemp < MyTCBStub.txTail) 
03EA8:  MOVF   xAA,W
03EAA:  SUBWF  x24,W
03EAC:  BNC   3EDC
03EAE:  BNZ   3EB6
03EB0:  MOVF   x23,W
03EB2:  SUBWF  xA9,W
03EB4:  BC    3EDC
....................                { 
....................                   MyTCB.MySEQ += MyTCBStub.txTail - wTemp; 
03EB6:  MOVF   xA9,W
03EB8:  SUBWF  x23,W
03EBA:  MOVWF  00
03EBC:  MOVF   xAA,W
03EBE:  SUBWFB x24,W
03EC0:  MOVWF  03
03EC2:  MOVF   00,W
03EC4:  MOVLB  0
03EC6:  ADDWF  xBB,F
03EC8:  MOVF   03,W
03ECA:  ADDWFC xBC,F
03ECC:  MOVLW  00
03ECE:  ADDWFC xBD,F
03ED0:  ADDWFC xBE,F
....................                   MyTCB.txUnackedTail = MyTCBStub.txTail; 
03ED2:  MOVFF  124,C4
03ED6:  MOVFF  123,C3
03EDA:  MOVLB  1
....................                } 
....................             } 
....................             if(MyTCBStub.txTail >= MyTCBStub.bufferRxStart) 
03EDC:  MOVF   x1E,W
03EDE:  SUBWF  x24,W
03EE0:  BNC   3EFE
03EE2:  BNZ   3EEA
03EE4:  MOVF   x1D,W
03EE6:  SUBWF  x23,W
03EE8:  BNC   3EFE
....................                MyTCBStub.txTail -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
03EEA:  MOVF   x1B,W
03EEC:  SUBWF  x1D,W
03EEE:  MOVWF  00
03EF0:  MOVF   x1C,W
03EF2:  SUBWFB x1E,W
03EF4:  MOVWF  03
03EF6:  MOVF   00,W
03EF8:  SUBWF  x23,F
03EFA:  MOVF   03,W
03EFC:  SUBWFB x24,F
....................             if(MyTCB.txUnackedTail >= MyTCBStub.bufferRxStart) 
03EFE:  MOVF   x1E,W
03F00:  MOVLB  0
03F02:  SUBWF  xC4,W
03F04:  BNC   3F2A
03F06:  BNZ   3F12
03F08:  MOVLB  1
03F0A:  MOVF   x1D,W
03F0C:  MOVLB  0
03F0E:  SUBWF  xC3,W
03F10:  BNC   3F2A
....................                MyTCB.txUnackedTail -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
03F12:  MOVLB  1
03F14:  MOVF   x1B,W
03F16:  SUBWF  x1D,W
03F18:  MOVWF  00
03F1A:  MOVF   x1C,W
03F1C:  SUBWFB x1E,W
03F1E:  MOVWF  03
03F20:  MOVF   00,W
03F22:  MOVLB  0
03F24:  SUBWF  xC3,F
03F26:  MOVF   03,W
03F28:  SUBWFB xC4,F
....................          } 
03F2A:  BRA    4008
03F2C:  MOVLB  1
....................          else 
....................          { 
....................             // See if we have outstanding TX data that is waiting for an ACK 
....................             if(MyTCBStub.txTail != MyTCB.txUnackedTail) 
03F2E:  MOVLB  0
03F30:  MOVF   xC3,W
03F32:  MOVLB  1
03F34:  SUBWF  x23,W
03F36:  BNZ   3F42
03F38:  MOVLB  0
03F3A:  MOVF   xC4,W
03F3C:  MOVLB  1
03F3E:  SUBWF  x24,W
03F40:  BZ    400A
....................             { 
....................                if(MyTCB.flags.bRXNoneACKed1) 
03F42:  MOVLB  0
03F44:  BTFSS  xD9.3
03F46:  BRA    4006
....................                { 
....................                   if(MyTCB.flags.bRXNoneACKed2) 
03F48:  BTFSS  xD9.4
03F4A:  BRA    4004
....................                   { 
....................                      // Set up to perform a fast retransmission 
....................                      // Roll back unacknowledged TX tail pointer to cause retransmit to occur 
....................                      MyTCB.MySEQ -= (LONG)(SHORT)(MyTCB.txUnackedTail - MyTCBStub.txTail); 
03F4C:  MOVLB  1
03F4E:  MOVF   x23,W
03F50:  MOVLB  0
03F52:  SUBWF  xC3,W
03F54:  MOVWF  00
03F56:  MOVLB  1
03F58:  MOVF   x24,W
03F5A:  MOVLB  0
03F5C:  SUBWFB xC4,W
03F5E:  MOVWF  03
03F60:  MOVF   00,W
03F62:  MOVFF  03,01
03F66:  CLRF   02
03F68:  CLRF   03
03F6A:  BTFSS  01.7
03F6C:  BRA    3F72
03F6E:  DECF   02,F
03F70:  DECF   03,F
03F72:  MOVF   00,W
03F74:  SUBWF  xBB,W
03F76:  MOVWF  00
03F78:  MOVF   01,W
03F7A:  SUBWFB xBC,W
03F7C:  MOVWF  01
03F7E:  MOVF   02,W
03F80:  SUBWFB xBD,W
03F82:  MOVWF  02
03F84:  MOVF   03,W
03F86:  SUBWFB xBE,W
03F88:  MOVWF  xBE
03F8A:  MOVFF  02,BD
03F8E:  MOVFF  01,BC
03F92:  MOVFF  00,BB
....................                      if(MyTCB.txUnackedTail < MyTCBStub.txTail) 
03F96:  MOVF   xC4,W
03F98:  MOVLB  1
03F9A:  SUBWF  x24,W
03F9C:  BNC   3FF8
03F9E:  BNZ   3FB0
03FA0:  MOVF   x23,W
03FA2:  MOVLB  0
03FA4:  SUBWF  xC3,W
03FA6:  BTFSS  FD8.0
03FA8:  BRA    3FAE
03FAA:  MOVLB  1
03FAC:  BRA    3FF8
03FAE:  MOVLB  1
....................                         MyTCB.MySEQ -= (LONG)(SHORT)(MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart); 
03FB0:  MOVF   x1B,W
03FB2:  SUBWF  x1D,W
03FB4:  MOVWF  00
03FB6:  MOVF   x1C,W
03FB8:  SUBWFB x1E,W
03FBA:  MOVWF  03
03FBC:  MOVF   00,W
03FBE:  MOVFF  03,01
03FC2:  CLRF   02
03FC4:  CLRF   03
03FC6:  BTFSS  01.7
03FC8:  BRA    3FCE
03FCA:  DECF   02,F
03FCC:  DECF   03,F
03FCE:  MOVF   00,W
03FD0:  MOVLB  0
03FD2:  SUBWF  xBB,W
03FD4:  MOVWF  00
03FD6:  MOVF   01,W
03FD8:  SUBWFB xBC,W
03FDA:  MOVWF  01
03FDC:  MOVF   02,W
03FDE:  SUBWFB xBD,W
03FE0:  MOVWF  02
03FE2:  MOVF   03,W
03FE4:  SUBWFB xBE,W
03FE6:  MOVWF  03
03FE8:  MOVWF  xBE
03FEA:  MOVFF  02,BD
03FEE:  MOVFF  01,BC
03FF2:  MOVFF  00,BB
03FF6:  MOVLB  1
....................                      MyTCB.txUnackedTail = MyTCBStub.txTail; 
03FF8:  MOVFF  124,C4
03FFC:  MOVFF  123,C3
....................                      MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
04000:  BSF    x33.2
04002:  MOVLB  0
....................                   } 
....................                   MyTCB.flags.bRXNoneACKed2 = 1; 
04004:  BSF    xD9.4
....................                } 
....................                MyTCB.flags.bRXNoneACKed1 = 1; 
04006:  BSF    xD9.3
04008:  MOVLB  1
....................             } 
....................          } 
....................  
....................          // No need to keep our retransmit timer going if we have nothing that needs ACKing anymore 
....................          if(MyTCBStub.txTail == MyTCBStub.txHead) 
0400A:  MOVF   x21,W
0400C:  SUBWF  x23,W
0400E:  BNZ   406E
04010:  MOVF   x22,W
04012:  SUBWF  x24,W
04014:  BNZ   406E
....................          { 
....................             // Make sure there isn't a "FIN byte in our TX FIFO" 
....................             if(MyTCBStub.Flags.bTXFIN == 0u) 
04016:  BTFSC  x33.3
04018:  BRA    403E
....................             { 
....................                // Convert retransmission timer to keep-alive timer 
....................                #if defined(TCP_KEEP_ALIVE_TIMEOUT) 
....................                   MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
0401A:  MOVLB  0
0401C:  CALL   0E34
04020:  MOVLW  74
04022:  MOVLB  1
04024:  ADDWF  00,W
04026:  MOVWF  x29
04028:  MOVLW  35
0402A:  ADDWFC 01,W
0402C:  MOVWF  x2A
0402E:  MOVLW  06
04030:  ADDWFC 02,W
04032:  MOVWF  x2B
04034:  MOVLW  00
04036:  ADDWFC 03,W
04038:  MOVWF  x2C
....................                #endif 
....................                MyTCBStub.Flags.bTimerEnabled = 0; 
0403A:  BCF    x32.4
....................             } 
0403C:  BRA    406E
....................             else 
....................             { 
....................                // "Throw away" FIN byte from our TX FIFO if it has been ACKed 
....................                if((MyTCB.MySEQ == localAckNumber) && MyTCB.flags.bFINSent) 
0403E:  MOVF   xB4,W
04040:  MOVLB  0
04042:  SUBWF  xBB,W
04044:  BNZ   4070
04046:  MOVLB  1
04048:  MOVF   xB5,W
0404A:  MOVLB  0
0404C:  SUBWF  xBC,W
0404E:  BNZ   4070
04050:  MOVLB  1
04052:  MOVF   xB6,W
04054:  MOVLB  0
04056:  SUBWF  xBD,W
04058:  BNZ   4070
0405A:  MOVLB  1
0405C:  MOVF   xB7,W
0405E:  MOVLB  0
04060:  SUBWF  xBE,W
04062:  BNZ   4070
04064:  BTFSS  xD9.0
04066:  BRA    4070
....................                { 
....................                   MyTCBStub.Flags.bTimerEnabled = 0; 
04068:  MOVLB  1
0406A:  BCF    x32.4
....................                   MyTCBStub.Flags.bTXFIN = 0; 
0406C:  BCF    x33.3
0406E:  MOVLB  0
....................                } 
....................             } 
....................          } 
....................  
....................          // The window size advirtised in this packet is adjusted to account  
....................          // for any bytes that we have transmitted but haven't been ACKed yet  
....................          // by this segment. 
....................          wNewWindow = h->Window - ((WORD)(MyTCB.MySEQ - localAckNumber)); 
04070:  MOVLW  0E
04072:  MOVLB  1
04074:  ADDWF  xA1,W
04076:  MOVWF  FE9
04078:  MOVLW  00
0407A:  ADDWFC xA2,W
0407C:  MOVWF  FEA
0407E:  MOVFF  FEC,1C2
04082:  MOVF   FED,F
04084:  MOVFF  FEF,1C1
04088:  MOVF   xB4,W
0408A:  MOVLB  0
0408C:  SUBWF  xBB,W
0408E:  MOVWF  00
04090:  MOVLB  1
04092:  MOVF   xB5,W
04094:  MOVLB  0
04096:  SUBWFB xBC,W
04098:  MOVWF  01
0409A:  MOVLB  1
0409C:  MOVF   xB6,W
0409E:  MOVLB  0
040A0:  SUBWFB xBD,W
040A2:  MOVLB  1
040A4:  MOVF   xB7,W
040A6:  MOVLB  0
040A8:  SUBWFB xBE,W
040AA:  MOVF   00,W
040AC:  MOVLB  1
040AE:  SUBWF  xC1,W
040B0:  MOVWF  xBF
040B2:  MOVF   01,W
040B4:  SUBWFB xC2,W
040B6:  MOVWF  xC0
....................  
....................          // Update the local stored copy of the RemoteWindow. 
....................          // If previously we had a zero window, and now we don't, then  
....................          // immediately send whatever was pending. 
....................          if((MyTCB.remoteWindow == 0u) && wNewWindow) 
040B8:  MOVLB  0
040BA:  MOVF   xC9,F
040BC:  BNZ   40D4
040BE:  MOVF   xCA,F
040C0:  BNZ   40D4
040C2:  MOVLB  1
040C4:  MOVF   xBF,W
040C6:  IORWF  xC0,W
040C8:  BTFSS  FD8.2
040CA:  BRA    40D0
040CC:  MOVLB  0
040CE:  BRA    40D4
....................             MyTCBStub.Flags.bTXASAP = 1; 
040D0:  BSF    x33.1
040D2:  MOVLB  0
....................          MyTCB.remoteWindow = wNewWindow; 
040D4:  MOVFF  1C0,CA
040D8:  MOVFF  1BF,C9
....................  
....................          // A couple of states must do all of the TCP_ESTABLISHED stuff, but also a little more 
....................          if(MyTCBStub.smState == TCP_FIN_WAIT_1) 
040DC:  MOVLB  1
040DE:  MOVF   x31,W
040E0:  SUBLW  08
040E2:  BNZ   4138
....................          { 
....................             // Check to see if our FIN has been ACKnowledged 
....................             if((MyTCB.MySEQ == localAckNumber) && MyTCB.flags.bFINSent) 
040E4:  MOVF   xB4,W
040E6:  MOVLB  0
040E8:  SUBWF  xBB,W
040EA:  BNZ   4134
040EC:  MOVLB  1
040EE:  MOVF   xB5,W
040F0:  MOVLB  0
040F2:  SUBWF  xBC,W
040F4:  BNZ   4134
040F6:  MOVLB  1
040F8:  MOVF   xB6,W
040FA:  MOVLB  0
040FC:  SUBWF  xBD,W
040FE:  BNZ   4134
04100:  MOVLB  1
04102:  MOVF   xB7,W
04104:  MOVLB  0
04106:  SUBWF  xBE,W
04108:  BNZ   4134
0410A:  BTFSS  xD9.0
0410C:  BRA    4134
....................             { 
....................                // Reset our timer for forced closure if the remote node  
....................                // doesn't send us a FIN in a timely manner. 
....................                MyTCBStub.eventTime = TickGet() + TCP_FIN_WAIT_2_TIMEOUT; 
0410E:  CALL   0E34
04112:  MOVLW  BA
04114:  MOVLB  1
04116:  ADDWF  00,W
04118:  MOVWF  x29
0411A:  MOVLW  1A
0411C:  ADDWFC 01,W
0411E:  MOVWF  x2A
04120:  MOVLW  03
04122:  ADDWFC 02,W
04124:  MOVWF  x2B
04126:  MOVLW  00
04128:  ADDWFC 03,W
0412A:  MOVWF  x2C
....................                MyTCBStub.Flags.bTimerEnabled = 1; 
0412C:  BSF    x32.4
....................                MyTCBStub.smState = TCP_FIN_WAIT_2; 
0412E:  MOVLW  09
04130:  MOVWF  x31
04132:  MOVLB  0
....................             } 
....................          } 
04134:  BRA    419E
04136:  MOVLB  1
....................          else if(MyTCBStub.smState == TCP_FIN_WAIT_2) 
04138:  MOVF   x31,W
0413A:  SUBLW  09
0413C:  BNZ   416C
....................          { 
....................             // RFC noncompliance: 
....................             // The remote node should not keep sending us data  
....................             // indefinitely after we send a FIN to it.   
....................             // However, some bad stacks may still keep sending  
....................             // us data indefinitely after ACKing our FIN.  To  
....................             // prevent this from locking up our socket, let's  
....................             // send a RST right now and close forcefully on  
....................             // our side. 
....................             if(!(localHeaderFlags & FIN)) 
0413E:  BTFSC  xB3.0
04140:  BRA    416A
....................             { 
....................                MyTCB.MySEQ = localAckNumber;   // Set SEQ = SEG.ACK 
04142:  MOVFF  1B7,BE
04146:  MOVFF  1B6,BD
0414A:  MOVFF  1B5,BC
0414E:  MOVFF  1B4,BB
....................                SendTCP(RST | ACK, 0); 
04152:  MOVLW  14
04154:  MOVLB  2
04156:  MOVWF  x75
04158:  CLRF   x76
0415A:  MOVLB  0
0415C:  CALL   1774
....................                CloseSocket(); 
04160:  CALL   0B52
....................                return; 
04164:  GOTO   4874
04168:  MOVLB  1
....................             } 
....................          } 
0416A:  BRA    41A0
....................          else if(MyTCBStub.smState == TCP_CLOSING) 
0416C:  MOVF   x31,W
0416E:  SUBLW  0A
04170:  BNZ   41A0
....................          { 
....................             // Check to see if our FIN has been ACKnowledged 
....................             if(MyTCB.MySEQ == localAckNumber) 
04172:  MOVF   xB4,W
04174:  MOVLB  0
04176:  SUBWF  xBB,W
04178:  BNZ   419C
0417A:  MOVLB  1
0417C:  MOVF   xB5,W
0417E:  MOVLB  0
04180:  SUBWF  xBC,W
04182:  BNZ   419C
04184:  MOVLB  1
04186:  MOVF   xB6,W
04188:  MOVLB  0
0418A:  SUBWF  xBD,W
0418C:  BNZ   419C
0418E:  MOVLB  1
04190:  MOVF   xB7,W
04192:  MOVLB  0
04194:  SUBWF  xBE,W
04196:  BNZ   419C
....................             { 
....................                // RFC not recommended: We should be going to  
....................                // the TCP_TIME_WAIT state right here and  
....................                // starting a 2MSL timer, but since we have so  
....................                // few precious sockets, we can't afford to  
....................                // leave a socket waiting around doing nothing  
....................                // for a long time.  If the remote node does  
....................                // not recieve this ACK, it'll have to figure  
....................                // out on it's own that the connection is now  
....................                // closed. 
....................                CloseSocket(); 
04198:  CALL   0B52
....................             } 
....................  
....................             return; 
0419C:  BRA    4874
0419E:  MOVLB  1
....................          } 
....................  
....................          break; 
041A0:  BRA    41EE
....................  
....................       case TCP_LAST_ACK: 
....................          // Check to see if our FIN has been ACKnowledged 
....................          if(MyTCB.MySEQ + 1 == localAckNumber) 
041A2:  MOVLW  01
041A4:  ADDWF  xBB,W
041A6:  MOVLB  1
041A8:  MOVWF  xC1
041AA:  MOVLW  00
041AC:  MOVLB  0
041AE:  ADDWFC xBC,W
041B0:  MOVLB  1
041B2:  MOVWF  xC2
041B4:  MOVLW  00
041B6:  MOVLB  0
041B8:  ADDWFC xBD,W
041BA:  MOVLB  1
041BC:  MOVWF  xC3
041BE:  MOVLW  00
041C0:  MOVLB  0
041C2:  ADDWFC xBE,W
041C4:  MOVLB  1
041C6:  MOVWF  xC4
041C8:  MOVF   xB4,W
041CA:  SUBWF  xC1,W
041CC:  BNZ   41E8
041CE:  MOVF   xB5,W
041D0:  SUBWF  xC2,W
041D2:  BNZ   41E8
041D4:  MOVF   xB6,W
041D6:  SUBWF  xC3,W
041D8:  BNZ   41E8
041DA:  MOVF   xB7,W
041DC:  SUBWF  xC4,W
041DE:  BNZ   41E8
....................             CloseSocket(); 
041E0:  MOVLB  0
041E2:  CALL   0B52
041E6:  MOVLB  1
....................          return; 
041E8:  MOVLB  0
041EA:  BRA    4874
....................  
.................... //      case TCP_TIME_WAIT: 
.................... //         // Nothing is supposed to arrive here.  If it does, reset the quiet timer. 
.................... //         SendTCP(ACK, SENDTCP_RESET_TIMERS); 
.................... //         return; 
....................  
....................       default: 
....................          break; 
041EC:  MOVLB  1
....................    } 
....................  
....................    // 
....................    // Sixth: Check the URG bit 
....................    // 
....................    // Urgent packets are not supported in this stack, so we 
....................    // will throw them away instead 
....................    if(localHeaderFlags & URG) 
041EE:  BTFSS  xB3.5
041F0:  BRA    41F8
....................       return; 
041F2:  MOVLB  0
041F4:  BRA    4874
041F6:  MOVLB  1
....................  
....................    // 
....................    // Seventh: Process the segment text 
....................    // 
....................    // Throw data away if in a state that doesn't accept data 
....................    if(MyTCBStub.smState == TCP_CLOSE_WAIT) 
041F8:  MOVF   x31,W
041FA:  SUBLW  0B
041FC:  BNZ   4204
....................       return; 
041FE:  MOVLB  0
04200:  BRA    4874
04202:  MOVLB  1
....................    if(MyTCBStub.smState == TCP_CLOSING) 
04204:  MOVF   x31,W
04206:  SUBLW  0A
04208:  BNZ   4210
....................       return; 
0420A:  MOVLB  0
0420C:  BRA    4874
0420E:  MOVLB  1
....................    if(MyTCBStub.smState == TCP_LAST_ACK) 
04210:  MOVF   x31,W
04212:  SUBLW  0C
04214:  BNZ   421C
....................       return; 
04216:  MOVLB  0
04218:  BRA    4874
0421A:  MOVLB  1
.................... //   if(MyTCBStub.smState == TCP_TIME_WAIT) 
.................... //      return; 
....................  
....................    // Copy any valid segment data into our RX FIFO, if any 
....................    if(len) 
0421C:  MOVF   xA3,W
0421E:  IORWF  xA4,W
04220:  BTFSC  FD8.2
04222:  BRA    46EE
....................    { 
....................       // See if there are bytes we must skip 
....................       if((SHORT)wMissingBytes <= 0) 
04224:  BTFSC  xB0.7
04226:  BRA    4236
04228:  MOVF   xB0,F
0422A:  BTFSS  FD8.2
0422C:  BRA    4416
0422E:  MOVF   xAF,W
04230:  SUBLW  00
04232:  BTFSS  FD8.0
04234:  BRA    4416
....................       { 
....................          // Position packet read pointer to start of useful data area. 
....................          IPSetRxBuffer((h->DataOffset.Val << 2) - wMissingBytes); 
04236:  MOVLW  0C
04238:  ADDWF  xA1,W
0423A:  MOVWF  FE9
0423C:  MOVLW  00
0423E:  ADDWFC xA2,W
04240:  MOVWF  FEA
04242:  MOVFF  FEF,00
04246:  SWAPF  00,W
04248:  ANDLW  0F
0424A:  MOVWF  00
0424C:  RLCF   00,F
0424E:  RLCF   00,F
04250:  MOVLW  FC
04252:  ANDWF  00,F
04254:  MOVF   00,W
04256:  BSF    FD8.0
04258:  SUBFWB xAF,W
0425A:  MOVWF  xC1
0425C:  MOVLW  00
0425E:  SUBFWB xB0,W
04260:  MOVWF  xC2
04262:  MOVWF  xC6
04264:  MOVFF  1C1,1C5
04268:  MOVLB  0
0426A:  CALL   3008
....................          len += wMissingBytes;       
0426E:  MOVLB  1
04270:  MOVF   xAF,W
04272:  ADDWF  xA3,F
04274:  MOVF   xB0,W
04276:  ADDWFC xA4,F
....................     
....................          // Truncate packets that would overflow our TCP RX FIFO 
....................          // and request a retransmit by sending a duplicate ACK 
....................          if(len > wFreeSpace) 
04278:  MOVF   xB2,W
0427A:  SUBWF  xA4,W
0427C:  BNC   428E
0427E:  BNZ   4286
04280:  MOVF   xA3,W
04282:  SUBWF  xB1,W
04284:  BC    428E
....................             len = wFreeSpace; 
04286:  MOVFF  1B2,1A4
0428A:  MOVFF  1B1,1A3
....................     
....................          MyTCB.RemoteSEQ += (DWORD)len; 
0428E:  MOVFF  1A4,01
04292:  CLRF   02
04294:  CLRF   03
04296:  MOVF   xA3,W
04298:  MOVLB  0
0429A:  ADDWF  xBF,F
0429C:  MOVF   01,W
0429E:  ADDWFC xC0,F
042A0:  MOVF   02,W
042A2:  ADDWFC xC1,F
042A4:  MOVF   03,W
042A6:  ADDWFC xC2,F
....................        
....................          // Copy the application data from the packet into the socket RX FIFO 
....................          // See if we need a two part copy (spans bufferEnd->bufferRxStart) 
....................          if(MyTCBStub.rxHead + len > MyTCBStub.bufferEnd) 
042A8:  MOVLB  1
042AA:  MOVF   xA3,W
042AC:  ADDWF  x25,W
042AE:  MOVWF  xC1
042B0:  MOVF   xA4,W
042B2:  ADDWFC x26,W
042B4:  MOVWF  xC2
042B6:  MOVF   x20,W
042B8:  SUBWF  xC2,W
042BA:  BNC   4348
042BC:  BNZ   42C4
042BE:  MOVF   xC1,W
042C0:  SUBWF  x1F,W
042C2:  BC    4348
....................          { 
....................             wTemp = MyTCBStub.bufferEnd - MyTCBStub.rxHead + 1; 
042C4:  MOVF   x25,W
042C6:  SUBWF  x1F,W
042C8:  MOVWF  xC1
042CA:  MOVF   x26,W
042CC:  SUBWFB x20,W
042CE:  MOVWF  xC2
042D0:  MOVLW  01
042D2:  ADDWF  xC1,W
042D4:  MOVWF  xA9
042D6:  MOVLW  00
042D8:  ADDWFC xC2,W
042DA:  MOVWF  xAA
....................             TCPRAMCopy(MyTCBStub.rxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, wTemp); 
042DC:  MOVFF  126,2A7
042E0:  MOVFF  125,2A6
042E4:  MOVFF  136,2A8
042E8:  MOVLB  2
042EA:  SETF   xAA
042EC:  SETF   xA9
042EE:  CLRF   xAB
042F0:  MOVFF  1AA,2AD
042F4:  MOVFF  1A9,2AC
042F8:  MOVLB  0
042FA:  CALL   0998
....................             TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len - wTemp); 
042FE:  MOVLB  1
04300:  MOVF   xA9,W
04302:  SUBWF  xA3,W
04304:  MOVWF  xC1
04306:  MOVF   xAA,W
04308:  SUBWFB xA4,W
0430A:  MOVWF  xC2
0430C:  MOVFF  11E,2A7
04310:  MOVFF  11D,2A6
04314:  MOVFF  136,2A8
04318:  MOVLB  2
0431A:  SETF   xAA
0431C:  SETF   xA9
0431E:  CLRF   xAB
04320:  MOVWF  xAD
04322:  MOVFF  1C1,2AC
04326:  MOVLB  0
04328:  CALL   0998
....................             MyTCBStub.rxHead = MyTCBStub.bufferRxStart + (len - wTemp); 
0432C:  MOVLB  1
0432E:  MOVF   xA9,W
04330:  SUBWF  xA3,W
04332:  MOVWF  00
04334:  MOVF   xAA,W
04336:  SUBWFB xA4,W
04338:  MOVWF  03
0433A:  MOVF   00,W
0433C:  ADDWF  x1D,W
0433E:  MOVWF  x25
04340:  MOVF   03,W
04342:  ADDWFC x1E,W
04344:  MOVWF  x26
....................          } 
04346:  BRA    4374
....................          else 
....................          { 
....................             TCPRAMCopy(MyTCBStub.rxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len); 
04348:  MOVFF  126,2A7
0434C:  MOVFF  125,2A6
04350:  MOVFF  136,2A8
04354:  MOVLB  2
04356:  SETF   xAA
04358:  SETF   xA9
0435A:  CLRF   xAB
0435C:  MOVFF  1A4,2AD
04360:  MOVFF  1A3,2AC
04364:  MOVLB  0
04366:  CALL   0998
....................             MyTCBStub.rxHead += len; 
0436A:  MOVLB  1
0436C:  MOVF   xA3,W
0436E:  ADDWF  x25,F
04370:  MOVF   xA4,W
04372:  ADDWFC x26,F
....................          } 
....................        
....................          // See if we have a hole and other data waiting already in the RX FIFO 
....................          if(MyTCB.sHoleSize != -1) 
04374:  MOVLB  0
04376:  INCFSZ xD7,W
04378:  BRA    4380
0437A:  INCFSZ xD8,W
0437C:  BRA    4380
0437E:  BRA    4412
....................          { 
....................             MyTCB.sHoleSize -= len; 
04380:  MOVLB  1
04382:  MOVF   xA3,W
04384:  MOVLB  0
04386:  SUBWF  xD7,F
04388:  MOVLB  1
0438A:  MOVF   xA4,W
0438C:  MOVLB  0
0438E:  SUBWFB xD8,F
....................             wTemp = MyTCB.wFutureDataSize + MyTCB.sHoleSize; 
04390:  MOVF   xD7,W
04392:  ADDWF  xCB,W
04394:  MOVWF  01
04396:  MOVF   xD8,W
04398:  ADDWFC xCC,W
0439A:  MOVFF  01,1A9
0439E:  MOVLB  1
043A0:  MOVWF  xAA
....................        
....................             // See if we just closed up a hole, and if so, advance head pointer 
....................             if((SHORT)wTemp < (SHORT)0) 
043A2:  BTFSS  xAA.7
043A4:  BRA    43AE
....................             { 
....................                MyTCB.sHoleSize = -1; 
043A6:  MOVLB  0
043A8:  SETF   xD8
043AA:  SETF   xD7
....................             } 
043AC:  BRA    4412
....................             else if(MyTCB.sHoleSize <= 0) 
043AE:  MOVLB  0
043B0:  BTFSC  xD8.7
043B2:  BRA    43BE
043B4:  MOVF   xD8,F
043B6:  BNZ   4412
043B8:  MOVF   xD7,W
043BA:  SUBLW  00
043BC:  BNC   4412
....................             { 
....................                MyTCB.RemoteSEQ += wTemp; 
043BE:  MOVLB  1
043C0:  MOVF   xA9,W
043C2:  MOVLB  0
043C4:  ADDWF  xBF,F
043C6:  MOVLB  1
043C8:  MOVF   xAA,W
043CA:  MOVLB  0
043CC:  ADDWFC xC0,F
043CE:  MOVLW  00
043D0:  ADDWFC xC1,F
043D2:  ADDWFC xC2,F
....................                MyTCBStub.rxHead += wTemp; 
043D4:  MOVLB  1
043D6:  MOVF   xA9,W
043D8:  ADDWF  x25,F
043DA:  MOVF   xAA,W
043DC:  ADDWFC x26,F
....................                if(MyTCBStub.rxHead > MyTCBStub.bufferEnd) 
043DE:  MOVF   x20,W
043E0:  SUBWF  x26,W
043E2:  BNC   440C
043E4:  BNZ   43EC
043E6:  MOVF   x25,W
043E8:  SUBWF  x1F,W
043EA:  BC    440C
....................                   MyTCBStub.rxHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;                      
043EC:  MOVF   x1D,W
043EE:  SUBWF  x1F,W
043F0:  MOVWF  xC1
043F2:  MOVF   x1E,W
043F4:  SUBWFB x20,W
043F6:  MOVWF  xC2
043F8:  MOVLW  01
043FA:  ADDWF  xC1,W
043FC:  MOVWF  01
043FE:  MOVLW  00
04400:  ADDWFC xC2,W
04402:  MOVWF  03
04404:  MOVF   01,W
04406:  SUBWF  x25,F
04408:  MOVF   03,W
0440A:  SUBWFB x26,F
....................                MyTCB.sHoleSize = -1; 
0440C:  MOVLB  0
0440E:  SETF   xD8
04410:  SETF   xD7
....................             } 
....................          } 
....................       } // This packet is out of order or we lost a packet, see if we can generate a hole to accomodate it 
04412:  BRA    46EC
04414:  MOVLB  1
....................       else if((SHORT)wMissingBytes > 0) 
04416:  BTFSC  xB0.7
04418:  BRA    46EE
0441A:  MOVF   xB0,F
0441C:  BNZ   4426
0441E:  MOVF   xAF,W
04420:  SUBLW  00
04422:  BTFSC  FD8.0
04424:  BRA    46EE
....................       { 
....................          // Truncate packets that would overflow our TCP RX FIFO 
....................          if(len + wMissingBytes > wFreeSpace) 
04426:  MOVF   xAF,W
04428:  ADDWF  xA3,W
0442A:  MOVWF  xC1
0442C:  MOVF   xB0,W
0442E:  ADDWFC xA4,W
04430:  MOVWF  xC2
04432:  MOVF   xB2,W
04434:  SUBWF  xC2,W
04436:  BNC   444C
04438:  BNZ   4440
0443A:  MOVF   xC1,W
0443C:  SUBWF  xB1,W
0443E:  BC    444C
....................             len = wFreeSpace - wMissingBytes; 
04440:  MOVF   xAF,W
04442:  SUBWF  xB1,W
04444:  MOVWF  xA3
04446:  MOVF   xB0,W
04448:  SUBWFB xB2,W
0444A:  MOVWF  xA4
....................        
....................          // Position packet read pointer to start of useful data area. 
....................          IPSetRxBuffer(h->DataOffset.Val << 2); 
0444C:  MOVLW  0C
0444E:  ADDWF  xA1,W
04450:  MOVWF  FE9
04452:  MOVLW  00
04454:  ADDWFC xA2,W
04456:  MOVWF  FEA
04458:  MOVFF  FEF,00
0445C:  SWAPF  00,W
0445E:  ANDLW  0F
04460:  MOVWF  00
04462:  RLCF   00,W
04464:  MOVWF  xC1
04466:  RLCF   xC1,F
04468:  MOVLW  FC
0446A:  ANDWF  xC1,F
0446C:  CLRF   xC6
0446E:  MOVFF  1C1,1C5
04472:  MOVLB  0
04474:  CALL   3008
....................     
....................          // See if we need a two part copy (spans bufferEnd->bufferRxStart) 
....................          if(MyTCBStub.rxHead + wMissingBytes + len > MyTCBStub.bufferEnd) 
04478:  MOVLB  1
0447A:  MOVF   xAF,W
0447C:  ADDWF  x25,W
0447E:  MOVWF  xC1
04480:  MOVF   xB0,W
04482:  ADDWFC x26,W
04484:  MOVWF  xC2
04486:  MOVF   xA3,W
04488:  ADDWF  xC1,F
0448A:  MOVF   xA4,W
0448C:  ADDWFC xC2,F
0448E:  MOVF   x20,W
04490:  SUBWF  xC2,W
04492:  BNC   4572
04494:  BNZ   449C
04496:  MOVF   xC1,W
04498:  SUBWF  x1F,W
0449A:  BC    4572
....................          { 
....................             // Calculate number of data bytes to copy before wraparound 
....................             wTemp = MyTCBStub.bufferEnd - MyTCBStub.rxHead + 1 - wMissingBytes; 
0449C:  MOVF   x25,W
0449E:  SUBWF  x1F,W
044A0:  MOVWF  xC1
044A2:  MOVF   x26,W
044A4:  SUBWFB x20,W
044A6:  MOVWF  xC2
044A8:  MOVLW  01
044AA:  ADDWF  xC1,F
044AC:  MOVLW  00
044AE:  ADDWFC xC2,F
044B0:  MOVF   xAF,W
044B2:  SUBWF  xC1,W
044B4:  MOVWF  xA9
044B6:  MOVF   xB0,W
044B8:  SUBWFB xC2,W
044BA:  MOVWF  xAA
....................             if((SHORT)wTemp >= 0) 
044BC:  BTFSC  xAA.7
044BE:  BRA    4520
....................             { 
....................                TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, wTemp); 
044C0:  MOVF   xAF,W
044C2:  ADDWF  x25,W
044C4:  MOVWF  xC1
044C6:  MOVF   xB0,W
044C8:  ADDWFC x26,W
044CA:  MOVWF  xC2
044CC:  MOVFF  FE8,2A7
044D0:  MOVFF  1C1,2A6
044D4:  MOVFF  136,2A8
044D8:  MOVLB  2
044DA:  SETF   xAA
044DC:  SETF   xA9
044DE:  CLRF   xAB
044E0:  MOVFF  1AA,2AD
044E4:  MOVFF  1A9,2AC
044E8:  MOVLB  0
044EA:  CALL   0998
....................                TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len - wTemp); 
044EE:  MOVLB  1
044F0:  MOVF   xA9,W
044F2:  SUBWF  xA3,W
044F4:  MOVWF  xC1
044F6:  MOVF   xAA,W
044F8:  SUBWFB xA4,W
044FA:  MOVWF  xC2
044FC:  MOVFF  11E,2A7
04500:  MOVFF  11D,2A6
04504:  MOVFF  136,2A8
04508:  MOVLB  2
0450A:  SETF   xAA
0450C:  SETF   xA9
0450E:  CLRF   xAB
04510:  MOVWF  xAD
04512:  MOVFF  1C1,2AC
04516:  MOVLB  0
04518:  CALL   0998
....................             } 
0451C:  BRA    456E
0451E:  MOVLB  1
....................             else 
....................             { 
....................                TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes - (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1), MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len); 
04520:  MOVF   xAF,W
04522:  ADDWF  x25,W
04524:  MOVWF  xC1
04526:  MOVF   xB0,W
04528:  ADDWFC x26,W
0452A:  MOVWF  xC2
0452C:  MOVF   x1D,W
0452E:  SUBWF  x1F,W
04530:  MOVWF  xC3
04532:  MOVF   x1E,W
04534:  SUBWFB x20,W
04536:  MOVWF  xC4
04538:  MOVLW  01
0453A:  ADDWF  xC3,W
0453C:  MOVWF  01
0453E:  MOVLW  00
04540:  ADDWFC xC4,W
04542:  MOVWF  03
04544:  MOVF   01,W
04546:  SUBWF  xC1,F
04548:  MOVF   03,W
0454A:  SUBWFB xC2,F
0454C:  MOVFF  1C2,2A7
04550:  MOVFF  1C1,2A6
04554:  MOVFF  136,2A8
04558:  MOVLB  2
0455A:  SETF   xAA
0455C:  SETF   xA9
0455E:  CLRF   xAB
04560:  MOVFF  1A4,2AD
04564:  MOVFF  1A3,2AC
04568:  MOVLB  0
0456A:  CALL   0998
....................             } 
....................          } 
0456E:  BRA    45A0
04570:  MOVLB  1
....................          else 
....................          { 
....................             TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len); 
04572:  MOVF   xAF,W
04574:  ADDWF  x25,W
04576:  MOVWF  xC1
04578:  MOVF   xB0,W
0457A:  ADDWFC x26,W
0457C:  MOVWF  xC2
0457E:  MOVFF  FE8,2A7
04582:  MOVFF  1C1,2A6
04586:  MOVFF  136,2A8
0458A:  MOVLB  2
0458C:  SETF   xAA
0458E:  SETF   xA9
04590:  CLRF   xAB
04592:  MOVFF  1A4,2AD
04596:  MOVFF  1A3,2AC
0459A:  MOVLB  0
0459C:  CALL   0998
....................          } 
....................        
....................          // Record the hole is here 
....................          if(MyTCB.sHoleSize == -1) 
045A0:  INCFSZ xD7,W
045A2:  BRA    45BA
045A4:  INCFSZ xD8,W
045A6:  BRA    45BA
....................          { 
....................             MyTCB.sHoleSize = wMissingBytes; 
045A8:  MOVFF  1B0,D8
045AC:  MOVFF  1AF,D7
....................             MyTCB.wFutureDataSize = len; 
045B0:  MOVFF  1A4,CC
045B4:  MOVFF  1A3,CB
....................          } 
045B8:  BRA    46EC
....................          else 
....................          { 
....................             // We already have a hole, see if we can shrink the hole  
....................             // or extend the future data size 
....................             if(wMissingBytes < (WORD)MyTCB.sHoleSize) 
045BA:  MOVLB  1
045BC:  MOVF   xB0,W
045BE:  MOVLB  0
045C0:  SUBWF  xD8,W
045C2:  BNC   4666
045C4:  BNZ   45D6
045C6:  MOVF   xD7,W
045C8:  MOVLB  1
045CA:  SUBWF  xAF,W
045CC:  BTFSS  FD8.0
045CE:  BRA    45D4
045D0:  MOVLB  0
045D2:  BRA    4666
045D4:  MOVLB  0
....................             { 
....................                if((wMissingBytes + len > (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize) || (wMissingBytes + len < (WORD)MyTCB.sHoleSize)) 
045D6:  MOVLB  1
045D8:  MOVF   xA3,W
045DA:  ADDWF  xAF,W
045DC:  MOVWF  xC1
045DE:  MOVF   xA4,W
045E0:  ADDWFC xB0,W
045E2:  MOVWF  xC2
045E4:  MOVLB  0
045E6:  MOVF   xCB,W
045E8:  ADDWF  xD7,W
045EA:  MOVWF  01
045EC:  MOVF   xCC,W
045EE:  ADDWFC xD8,W
045F0:  MOVWF  03
045F2:  MOVF   03,W
045F4:  MOVLB  1
045F6:  SUBWF  xC2,W
045F8:  BNC   4602
045FA:  BNZ   462A
045FC:  MOVF   xC1,W
045FE:  SUBWF  01,W
04600:  BNC   462A
04602:  MOVF   xA3,W
04604:  ADDWF  xAF,W
04606:  MOVWF  xC1
04608:  MOVF   xA4,W
0460A:  ADDWFC xB0,W
0460C:  MOVWF  xC2
0460E:  MOVLB  0
04610:  SUBWF  xD8,W
04612:  BNC   4636
04614:  BTFSC  FD8.2
04616:  BRA    461C
04618:  MOVLB  1
0461A:  BRA    462A
0461C:  MOVF   xD7,W
0461E:  MOVLB  1
04620:  SUBWF  xC1,W
04622:  BTFSS  FD8.0
04624:  BRA    462A
04626:  MOVLB  0
04628:  BRA    4636
....................                   MyTCB.wFutureDataSize = len; 
0462A:  MOVFF  1A4,CC
0462E:  MOVFF  1A3,CB
04632:  BRA    465C
04634:  MOVLB  0
....................                else 
....................                   MyTCB.wFutureDataSize = (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize - wMissingBytes; 
04636:  MOVF   xCB,W
04638:  ADDWF  xD7,W
0463A:  MOVLB  1
0463C:  MOVWF  xC1
0463E:  MOVLB  0
04640:  MOVF   xCC,W
04642:  ADDWFC xD8,W
04644:  MOVLB  1
04646:  MOVWF  xC2
04648:  MOVF   xAF,W
0464A:  SUBWF  xC1,W
0464C:  MOVLB  0
0464E:  MOVWF  xCB
04650:  MOVLB  1
04652:  MOVF   xB0,W
04654:  SUBWFB xC2,W
04656:  MOVLB  0
04658:  MOVWF  xCC
0465A:  MOVLB  1
....................                MyTCB.sHoleSize = wMissingBytes; 
0465C:  MOVFF  1B0,D8
04660:  MOVFF  1AF,D7
....................             } 
04664:  BRA    46EE
....................             else if(wMissingBytes + len > (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize) 
04666:  MOVLB  1
04668:  MOVF   xA3,W
0466A:  ADDWF  xAF,W
0466C:  MOVWF  xC1
0466E:  MOVF   xA4,W
04670:  ADDWFC xB0,W
04672:  MOVWF  xC2
04674:  MOVLB  0
04676:  MOVF   xCB,W
04678:  ADDWF  xD7,W
0467A:  MOVWF  01
0467C:  MOVF   xCC,W
0467E:  ADDWFC xD8,W
04680:  MOVWF  03
04682:  MOVF   03,W
04684:  MOVLB  1
04686:  SUBWF  xC2,W
04688:  BNC   46EE
0468A:  BNZ   4692
0468C:  MOVF   xC1,W
0468E:  SUBWF  01,W
04690:  BC    46EE
....................             { 
....................                // Make sure that there isn't a second hole between  
....................                // our future data and this TCP segment's future data 
....................                if(wMissingBytes <= (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize) 
04692:  MOVLB  0
04694:  MOVF   xCB,W
04696:  ADDWF  xD7,W
04698:  MOVWF  01
0469A:  MOVF   xCC,W
0469C:  ADDWFC xD8,W
0469E:  MOVWF  03
046A0:  MOVF   01,W
046A2:  MOVLB  1
046A4:  MOVF   xB0,W
046A6:  SUBWF  03,W
046A8:  BNC   46EE
046AA:  BNZ   46B2
046AC:  MOVF   xAF,W
046AE:  SUBWF  01,W
046B0:  BNC   46EE
....................                   MyTCB.wFutureDataSize += wMissingBytes + len - (WORD)MyTCB.sHoleSize - MyTCB.wFutureDataSize; 
046B2:  MOVF   xA3,W
046B4:  ADDWF  xAF,W
046B6:  MOVWF  xC1
046B8:  MOVF   xA4,W
046BA:  ADDWFC xB0,W
046BC:  MOVWF  xC2
046BE:  MOVLB  0
046C0:  MOVF   xD7,W
046C2:  MOVLB  1
046C4:  SUBWF  xC1,F
046C6:  MOVLB  0
046C8:  MOVF   xD8,W
046CA:  MOVLB  1
046CC:  SUBWFB xC2,F
046CE:  MOVLB  0
046D0:  MOVF   xCB,W
046D2:  MOVLB  1
046D4:  SUBWF  xC1,W
046D6:  MOVWF  00
046D8:  MOVLB  0
046DA:  MOVF   xCC,W
046DC:  MOVLB  1
046DE:  SUBWFB xC2,W
046E0:  MOVWF  03
046E2:  MOVF   00,W
046E4:  MOVLB  0
046E6:  ADDWF  xCB,F
046E8:  MOVF   03,W
046EA:  ADDWFC xCC,F
046EC:  MOVLB  1
....................             } 
....................              
....................          } 
....................       } 
....................    } 
....................  
....................    // Send back an ACK of the data (+SYN | FIN) we just received,  
....................    // if any.  To minimize bandwidth waste, we are implementing  
....................    // the delayed acknowledgement algorithm here, only sending  
....................    // back an immediate ACK if this is the second segment received.   
....................    // Otherwise, a 200ms timer will cause the ACK to be transmitted. 
....................    if(wSegmentLength) 
046EE:  MOVF   xBC,W
046F0:  IORWF  xBD,W
046F2:  BZ    473A
....................    { 
....................       // For non-established sockets, let's delete all data in  
....................       // the RX buffer immediately after receiving it.  This is  
....................       // not really how TCP was intended to operate since a  
....................       // socket cannot receive any response after it sends a FIN, 
....................       // but our TCP application API doesn't readily accomodate 
....................       // receiving data after calling TCPDisconnect(), which  
....................       // invalidates the application TCP handle.  By deleting all  
....................       // data, we'll ensure that the RX window is nonzero and  
....................       // the remote node will be able to send us a FIN response,  
....................       // which needs an RX window of at least 1. 
....................       if(MyTCBStub.smState != TCP_ESTABLISHED) 
046F4:  MOVF   x31,W
046F6:  SUBLW  07
046F8:  BZ    4702
....................          MyTCBStub.rxTail = MyTCBStub.rxHead; 
046FA:  MOVFF  126,128
046FE:  MOVFF  125,127
....................  
....................       if(MyTCBStub.Flags.bOneSegmentReceived) 
04702:  BTFSS  x32.7
04704:  BRA    471E
....................       { 
....................          SendTCP(ACK, SENDTCP_RESET_TIMERS); 
04706:  MOVLW  10
04708:  MOVLB  2
0470A:  MOVWF  x75
0470C:  MOVLW  01
0470E:  MOVWF  x76
04710:  MOVLB  0
04712:  CALL   1774
....................          SyncTCB(); 
04716:  CALL   0A7E
....................          // bOneSegmentReceived is cleared in SendTCP(), so no need here 
....................       } 
0471A:  BRA    473C
0471C:  MOVLB  1
....................       else 
....................       { 
....................          MyTCBStub.Flags.bOneSegmentReceived = TRUE;    
0471E:  BSF    x32.7
....................        
....................          // Do not send an ACK immediately back.  Instead, we will  
....................          // perform delayed acknowledgements.  To do this, we will  
....................          // just start a timer 
....................          if(!MyTCBStub.Flags.bDelayedACKTimerEnabled) 
04720:  BTFSC  x32.6
04722:  BRA    473A
....................          { 
....................             MyTCBStub.Flags.bDelayedACKTimerEnabled = 1; 
04724:  BSF    x32.6
....................             MyTCBStub.OverlappedTimers.delayedACKTime = (WORD)TickGetDiv256() + (WORD)((TCP_DELAYED_ACK_TIMEOUT)>>8); 
04726:  MOVLB  0
04728:  CALL   0EB8
0472C:  MOVLW  0F
0472E:  MOVLB  1
04730:  ADDWF  00,W
04732:  MOVWF  x2F
04734:  MOVLW  00
04736:  ADDWFC 01,W
04738:  MOVWF  x30
0473A:  MOVLB  0
....................          } 
....................       } 
....................    } 
....................  
....................    // 
....................    // Eighth: check the FIN bit 
....................    // 
....................    if(localHeaderFlags & FIN) 
0473C:  MOVLB  1
0473E:  BTFSS  xB3.0
04740:  BRA    4876
....................    { 
....................       // Note: Since we don't have a good means of storing "FIN bytes"  
....................       // in our TCP RX FIFO, we must ensure that FINs are processed  
....................       // in-order. 
....................       if(MyTCB.RemoteSEQ + 1 == localSeqNumber + (DWORD)wSegmentLength) 
04742:  MOVLW  01
04744:  MOVLB  0
04746:  ADDWF  xBF,W
04748:  MOVLB  1
0474A:  MOVWF  xC1
0474C:  MOVLW  00
0474E:  MOVLB  0
04750:  ADDWFC xC0,W
04752:  MOVLB  1
04754:  MOVWF  xC2
04756:  MOVLW  00
04758:  MOVLB  0
0475A:  ADDWFC xC1,W
0475C:  MOVLB  1
0475E:  MOVWF  xC3
04760:  MOVLW  00
04762:  MOVLB  0
04764:  ADDWFC xC2,W
04766:  MOVLB  1
04768:  MOVWF  xC4
0476A:  MOVFF  1BC,00
0476E:  MOVFF  1BD,01
04772:  CLRF   02
04774:  CLRF   03
04776:  MOVF   xB8,W
04778:  ADDWF  00,F
0477A:  MOVF   xB9,W
0477C:  ADDWFC 01,F
0477E:  MOVF   xBA,W
04780:  ADDWFC 02,F
04782:  MOVF   xBB,W
04784:  ADDWFC 03,F
04786:  MOVF   00,W
04788:  SUBWF  xC1,W
0478A:  BTFSS  FD8.2
0478C:  BRA    4876
0478E:  MOVF   01,W
04790:  SUBWF  xC2,W
04792:  BTFSS  FD8.2
04794:  BRA    4876
04796:  MOVF   02,W
04798:  SUBWF  xC3,W
0479A:  BTFSS  FD8.2
0479C:  BRA    4876
0479E:  MOVF   03,W
047A0:  SUBWF  xC4,W
047A2:  BTFSS  FD8.2
047A4:  BRA    4876
....................       { 
....................          // FINs are treated as one byte of data for ACK sequencing 
....................          MyTCB.RemoteSEQ++; 
047A6:  MOVLW  01
047A8:  MOVLB  0
047AA:  ADDWF  xBF,F
047AC:  BTFSC  FD8.0
047AE:  INCF   xC0,F
047B0:  BTFSC  FD8.2
047B2:  INCF   xC1,F
047B4:  BTFSC  FD8.2
047B6:  INCF   xC2,F
....................           
....................          switch(MyTCBStub.smState) 
047B8:  MOVLB  1
047BA:  MOVF   x31,W
047BC:  XORLW  06
047BE:  MOVLB  0
047C0:  BZ    47D0
047C2:  XORLW  01
047C4:  BZ    47E8
047C6:  XORLW  0F
047C8:  BZ    4804
047CA:  XORLW  01
047CC:  BZ    484E
047CE:  BRA    4862
....................          { 
....................             case TCP_SYN_RECEIVED: 
....................                // RFC in exact: Our API has no need for the user  
....................                // to explicitly close a socket that never really  
....................                // got opened fully in the first place, so just  
....................                // transmit a FIN automatically and jump to  
....................                // TCP_LAST_ACK 
....................                MyTCBStub.smState = TCP_LAST_ACK; 
047D0:  MOVLW  0C
047D2:  MOVLB  1
047D4:  MOVWF  x31
....................                SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS); 
047D6:  MOVLW  11
047D8:  MOVLB  2
047DA:  MOVWF  x75
047DC:  MOVLW  01
047DE:  MOVWF  x76
047E0:  MOVLB  0
047E2:  CALL   1774
....................                return; 
047E6:  BRA    4874
....................  
....................             case TCP_ESTABLISHED: 
....................                // Go to TCP_CLOSE_WAIT state 
....................                MyTCBStub.smState = TCP_CLOSE_WAIT; 
047E8:  MOVLW  0B
047EA:  MOVLB  1
047EC:  MOVWF  x31
....................                 
....................                // For legacy applications that don't call  
....................                // TCPDisconnect() as needed and expect the TCP/IP  
....................                // Stack to automatically close sockets when the  
....................                // remote node sends a FIN, let's start a timer so  
....................                // that we will eventually close the socket automatically 
....................                MyTCBStub.OverlappedTimers.closeWaitTime = (WORD)TickGetDiv256() + (WORD)((TCP_CLOSE_WAIT_TIMEOUT)>>8); 
047EE:  MOVLB  0
047F0:  CALL   0EB8
047F4:  MOVLW  1F
047F6:  MOVLB  1
047F8:  ADDWF  00,W
047FA:  MOVWF  x2F
047FC:  MOVLW  00
047FE:  ADDWFC 01,W
04800:  MOVWF  x30
....................                break; 
04802:  BRA    4864
....................     
....................             case TCP_FIN_WAIT_1: 
....................                if(MyTCB.MySEQ == localAckNumber) 
04804:  MOVLB  1
04806:  MOVF   xB4,W
04808:  MOVLB  0
0480A:  SUBWF  xBB,W
0480C:  BNZ   4842
0480E:  MOVLB  1
04810:  MOVF   xB5,W
04812:  MOVLB  0
04814:  SUBWF  xBC,W
04816:  BNZ   4842
04818:  MOVLB  1
0481A:  MOVF   xB6,W
0481C:  MOVLB  0
0481E:  SUBWF  xBD,W
04820:  BNZ   4842
04822:  MOVLB  1
04824:  MOVF   xB7,W
04826:  MOVLB  0
04828:  SUBWF  xBE,W
0482A:  BNZ   4842
....................                { 
....................                   // RFC not recommended: We should be going to  
....................                   // the TCP_TIME_WAIT state right here and  
....................                   // starting a 2MSL timer, but since we have so  
....................                   // few precious sockets, we can't afford to  
....................                   // leave a socket waiting around doing nothing  
....................                   // for a long time.  If the remote node does  
....................                   // not recieve this ACK, it'll have to figure  
....................                   // out on it's own that the connection is now  
....................                   // closed. 
....................                   SendTCP(ACK, 0); 
0482C:  MOVLW  10
0482E:  MOVLB  2
04830:  MOVWF  x75
04832:  CLRF   x76
04834:  MOVLB  0
04836:  CALL   1774
....................                   CloseSocket(); 
0483A:  CALL   0B52
....................                   return; 
0483E:  BRA    4874
....................                } 
04840:  BRA    484A
....................                else 
....................                { 
....................                   MyTCBStub.smState = TCP_CLOSING; 
04842:  MOVLW  0A
04844:  MOVLB  1
04846:  MOVWF  x31
04848:  MOVLB  0
....................                } 
....................                break; 
0484A:  MOVLB  1
0484C:  BRA    4864
....................     
....................             case TCP_FIN_WAIT_2: 
....................                // RFC not recommended: We should be going to  
....................                // the TCP_TIME_WAIT state right here and  
....................                // starting a 2MSL timer, but since we have so  
....................                // few precious sockets, we can't afford to  
....................                // leave a socket waiting around doing nothing  
....................                // for a long time.  If the remote node does  
....................                // not recieve this ACK, it'll have to figure  
....................                // out on it's own that the connection is now  
....................                // closed. 
....................                SendTCP(ACK, 0); 
0484E:  MOVLW  10
04850:  MOVLB  2
04852:  MOVWF  x75
04854:  CLRF   x76
04856:  MOVLB  0
04858:  CALL   1774
....................                CloseSocket(); 
0485C:  CALL   0B52
....................                return; 
04860:  BRA    4874
....................  
....................             default: 
....................                break; 
04862:  MOVLB  1
....................          } 
....................  
....................          // Acknowledge receipt of FIN 
....................          SendTCP(ACK, SENDTCP_RESET_TIMERS); 
04864:  MOVLW  10
04866:  MOVLB  2
04868:  MOVWF  x75
0486A:  MOVLW  01
0486C:  MOVWF  x76
0486E:  MOVLB  0
04870:  CALL   1774
04874:  MOVLB  1
....................       } 
....................    } 
04876:  MOVLB  0
04878:  GOTO   49EC (RETURN)
.................... } 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Buffer Management Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPAdjustFIFOSize(TCP_SOCKET hTCP, WORD wMinRXSize,  
....................                      WORD wMinTXSize, BYTE vFlags) 
....................  
....................   Summary: 
....................    Adjusts the relative sizes of the RX and TX buffers. 
....................  
....................   Description: 
....................    This function can be used to adjust the relative sizes of the RX and 
....................    TX FIFO depending on the immediate needs of an application.  Since a  
....................    larger FIFO can allow more data to be sent in a given packet, adjusting  
....................    the relative sizes on the fly can allow for optimal transmission speed  
....................    for one-sided application protocols.  For example, HTTP typically  
....................    begins by receiving large amounts of data from the client, then switches 
....................    to serving large amounts of data back.  Adjusting the FIFO at these  
....................    points can increase performance substantially.  Once the FIFO is 
....................    adjusted, a window update is sent. 
....................     
....................    If neither or both of TCP_ADJUST_GIVE_REST_TO_TX and  
....................    TCP_ADJUST_GIVE_REST_TO_RX are set, the function distributes the 
....................    remaining space equally. 
....................     
....................    Received data can be preserved as long as the buffer is expanding and  
....................    has not wrapped. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP      - The socket to be adjusted 
....................    wMinRXSize   - Minimum number of byte for the RX FIFO 
....................    wMinTXSize    - Minimum number of bytes for the RX FIFO 
....................    vFlags      - Any combination of TCP_ADJUST_GIVE_REST_TO_RX,  
....................               TCP_ADJUST_GIVE_REST_TO_TX, TCP_ADJUST_PRESERVE_RX. 
....................               TCP_ADJUST_PRESERVE_TX is not currently supported. 
....................  
....................   Return Values: 
....................    TRUE - The FIFOs were adjusted successfully 
....................    FALSE - Minimum RX, Minimum TX, or flags couldn't be accommodated and 
....................          therefore the socket was left unchanged. 
....................  
....................   Side Effects: 
....................    Any unacknowledged or untransmitted data in the TX FIFO is always 
....................    deleted. 
....................  
....................   Remarks: 
....................    At least one byte must always be allocated to the RX buffer so that 
....................    a FIN can be received.  The function automatically corrects for this. 
....................   ***************************************************************************/ 
.................... BOOL TCPAdjustFIFOSize(TCP_SOCKET hTCP, WORD wMinRXSize, WORD wMinTXSize, BYTE vFlags) 
.................... { 
....................    PTR_BASE ptrTemp, ptrHead; 
....................    WORD wTXAllocation; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    // Load up info on this socket 
....................    SyncTCBStub(hTCP); 
....................  
....................    // RX has to be at least 1 byte to receive SYN and FIN bytes  
....................    // from the remote node, even if they aren't stored in the RX FIFO 
....................    if(wMinRXSize == 0u) 
....................       wMinRXSize = 1; 
....................        
....................    // SSL connections need to be able to send or receive at least  
....................    // a full Alert record, MAC, and FIN 
....................    #if defined(STACK_USE_SSL) 
....................    if(TCPIsSSL(hTCP) && wMinRXSize < 25u) 
....................       wMinRXSize = 25; 
....................    if(TCPIsSSL(hTCP) && wMinTXSize < 25u) 
....................       wMinTXSize = 25; 
....................    #endif 
....................     
....................    // Make sure space is available for minimums 
....................    ptrTemp = MyTCBStub.bufferEnd - MyTCBStub.bufferTxStart - 1; 
....................    if(wMinRXSize + wMinTXSize > ptrTemp) 
....................       return FALSE; 
....................  
....................    SyncTCB(); 
....................  
....................    // Set both allocation flags if none set 
....................    if(!(vFlags & (TCP_ADJUST_GIVE_REST_TO_TX | TCP_ADJUST_GIVE_REST_TO_RX))) 
....................       vFlags |= TCP_ADJUST_GIVE_REST_TO_TX | TCP_ADJUST_GIVE_REST_TO_RX; 
....................        
....................  
....................    // Allocate minimums 
....................    wTXAllocation = wMinTXSize; 
....................    ptrTemp -= wMinRXSize + wMinTXSize; 
....................  
....................    // Allocate extra 
....................    if(vFlags & TCP_ADJUST_GIVE_REST_TO_TX) 
....................    { 
....................       if(vFlags & TCP_ADJUST_GIVE_REST_TO_RX) 
....................       { 
....................          // Do a 50%/50% split with any odd byte always going to the RX FIFO 
....................          wTXAllocation += ptrTemp>>1; 
....................       } 
....................       else 
....................       { 
....................          wTXAllocation += ptrTemp; 
....................       } 
....................    } 
....................  
....................    // Calculate new bufferRxStart pointer 
....................    ptrTemp = MyTCBStub.bufferTxStart + wTXAllocation + 1; 
....................  
....................    // Find the head pointer to use 
....................    ptrHead = MyTCBStub.rxHead; 
....................    #if defined(STACK_USE_SSL) 
....................    if(TCPIsSSL(hTCP)) 
....................       ptrHead = MyTCBStub.sslRxHead; 
....................    #endif 
....................     
....................    // If there's out-of-order data pending, adjust the head pointer to compensate 
....................    if(MyTCB.sHoleSize != -1) 
....................    { 
....................       ptrHead += MyTCB.sHoleSize + MyTCB.wFutureDataSize; 
....................       if(ptrHead > MyTCBStub.bufferEnd) 
....................          ptrHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................    } 
....................  
....................    // Determine if resizing will lose any RX data 
....................    if(MyTCBStub.rxTail < ptrHead) 
....................    { 
....................       if(ptrTemp > MyTCBStub.rxTail) 
....................       { 
....................          if(vFlags & TCP_ADJUST_PRESERVE_RX) 
....................             return FALSE; 
....................          else 
....................          { 
....................             MyTCBStub.rxTail = ptrTemp; 
....................             MyTCBStub.rxHead = ptrTemp; 
....................  
....................             #if defined(STACK_USE_SSL) 
....................             MyTCBStub.sslRxHead = ptrTemp; 
....................             #endif 
....................          } 
....................       } 
....................    } 
....................    else if(MyTCBStub.rxTail > ptrHead) 
....................    { 
....................       if(ptrTemp > MyTCBStub.bufferRxStart) 
....................       { 
....................          if(vFlags & TCP_ADJUST_PRESERVE_RX) 
....................             return FALSE; 
....................          else 
....................          { 
....................             MyTCBStub.rxTail = ptrTemp; 
....................             MyTCBStub.rxHead = ptrTemp; 
....................              
....................             #if defined(STACK_USE_SSL) 
....................             MyTCBStub.sslRxHead = ptrTemp; 
....................             #endif 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       // No data to preserve, but we may need to move  
....................       // the pointers to stay in the RX space 
....................       MyTCBStub.rxTail = ptrTemp; 
....................       MyTCBStub.rxHead = ptrTemp; 
....................        
....................       #if defined(STACK_USE_SSL) 
....................       MyTCBStub.sslRxHead = ptrTemp; 
....................       #endif 
....................    } 
....................     
....................    // If we need to preserve data that wrapped in the ring, we must copy 
....................    if(ptrHead < MyTCBStub.rxTail && (vFlags & TCP_ADJUST_PRESERVE_RX)) 
....................    { 
....................       TCPRAMCopy(ptrTemp, MyTCBStub.vMemoryMedium,  
....................          MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, 
....................          ptrHead - MyTCBStub.bufferRxStart); 
....................  
....................       // Move the pointers if they were in front of the tail 
....................       #if defined(STACK_USE_SSL) 
....................       if(TCPIsSSL(hTCP) && MyTCBStub.sslRxHead < MyTCBStub.rxTail) 
....................          MyTCBStub.sslRxHead -= MyTCBStub.bufferRxStart - ptrTemp; 
....................       #endif 
....................       if(MyTCBStub.rxHead < MyTCBStub.rxTail) 
....................          MyTCBStub.rxHead -= MyTCBStub.bufferRxStart - ptrTemp; 
....................    } 
....................     
....................    // Move the RX buffer pointer - it's the one that divides the two 
....................    MyTCBStub.bufferRxStart = ptrTemp; 
....................  
....................    // Empty the TX buffer 
....................    MyTCB.txUnackedTail = MyTCBStub.bufferTxStart; 
....................    MyTCBStub.txTail = MyTCBStub.bufferTxStart; 
....................    MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................     
....................    #if defined(STACK_USE_SSL) 
....................    if(TCPIsSSL(hTCP)) 
....................       MyTCBStub.sslTxHead = MyTCBStub.txHead + 5; 
....................    #endif 
....................     
....................    // Send a window update to notify remote node of change 
....................    if(MyTCBStub.smState == TCP_ESTABLISHED) 
....................       SendTCP(ACK, SENDTCP_RESET_TIMERS); 
....................  
....................    return TRUE; 
....................  
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void TCPRAMCopy(PTR_BASE ptrDest, BYTE vDestType, PTR_BASE ptrSource,  
....................                      BYTE vSourceType, WORD wLength) 
....................  
....................   Summary: 
....................    Copies data to/from various memory mediums. 
....................  
....................   Description: 
....................    This function copies data between memory mediums (PIC RAM, SPI 
....................    RAM, and Ethernet buffer RAM). 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    ptrDest      - Address to write to 
....................    vDestType   - Destination meidum (TCP_PIC_RAM, TCP_ETH_RAM, TCP_SPI_RAM) 
....................    ptrSource   - Address to copy from 
....................    vSourceType - Source medium (TCP_PIC_RAM, TCP_ETH_RAM, or TCP_SPI_RAM) 
....................    wLength      - Number of bytes to copy 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    Copying to a destination region that overlaps with the source address  
....................    is supported only if the destination start address is at a lower memory  
....................    address (closer to 0x0000) than the source pointer.  However, if they do  
....................    overlap there must be at least 4 bytes of non-overlap to ensure correct  
....................    results due to hardware DMA requirements. 
....................   ***************************************************************************/ 
.................... static void TCPRAMCopy(PTR_BASE ptrDest, BYTE vDestType, PTR_BASE ptrSource, BYTE vSourceType, WORD wLength) 
.................... { 
....................    #if defined(SPIRAM_CS_TRIS) 
....................    BYTE vBuffer[16]; 
....................    WORD w; 
....................    #endif 
....................        
....................    switch(vSourceType) 
*
00998:  MOVLB  2
0099A:  MOVF   xAB,W
0099C:  XORLW  01
0099E:  MOVLB  0
009A0:  BZ    09A8
009A2:  XORLW  01
009A4:  BZ    0A1A
009A6:  BRA    0A7C
....................    { 
....................       case TCP_PIC_RAM: 
....................          switch(vDestType) 
009A8:  MOVLB  2
009AA:  MOVF   xA8,W
009AC:  XORLW  01
009AE:  MOVLB  0
009B0:  BZ    09B8
009B2:  XORLW  01
009B4:  BZ    09EA
009B6:  BRA    0A18
....................          { 
....................             case TCP_PIC_RAM: 
....................                memcpy((void*)(BYTE*)ptrDest, (void*)(BYTE*)ptrSource, wLength); 
009B8:  MOVFF  2A7,FEA
009BC:  MOVFF  2A6,FE9
009C0:  MOVFF  2AA,FE2
009C4:  MOVFF  2A9,FE1
009C8:  MOVFF  2AD,02
009CC:  MOVFF  2AC,01
009D0:  MOVF   01,F
009D2:  BZ    09D8
009D4:  INCF   02,F
009D6:  BRA    09DC
009D8:  MOVF   02,F
009DA:  BZ    09E8
009DC:  MOVFF  FE6,FEE
009E0:  DECFSZ 01,F
009E2:  BRA    09DC
009E4:  DECFSZ 02,F
009E6:  BRA    09DC
....................                break; 
009E8:  BRA    0A18
....................     
....................             case TCP_ETH_RAM: 
....................                if(ptrDest!=(PTR_BASE)-1) 
009EA:  MOVLB  2
009EC:  INCFSZ xA6,W
009EE:  BRA    09F6
009F0:  INCFSZ xA7,W
009F2:  BRA    09F6
009F4:  BRA    0A04
....................                   MACSetWritePtr(ptrDest); 
009F6:  MOVFF  2A7,2AF
009FA:  MOVFF  2A6,2AE
009FE:  MOVLB  0
00A00:  RCALL  077C
00A02:  MOVLB  2
....................                MACPutArray((BYTE*)ptrSource, wLength); 
00A04:  MOVFF  2AA,2C4
00A08:  MOVFF  2A9,2C3
00A0C:  MOVFF  2AD,2C6
00A10:  MOVFF  2AC,2C5
00A14:  MOVLB  0
00A16:  RCALL  079A
....................                break; 
....................     
....................             #if defined(SPIRAM_CS_TRIS) 
....................             case TCP_SPI_RAM: 
....................                SPIRAMPutArray(ptrDest, (BYTE*)ptrSource, wLength); 
....................                break; 
....................             #endif 
....................          } 
....................          break; 
00A18:  BRA    0A7C
....................     
....................       case TCP_ETH_RAM: 
....................          switch(vDestType) 
00A1A:  MOVLB  2
00A1C:  MOVF   xA8,W
00A1E:  XORLW  01
00A20:  MOVLB  0
00A22:  BZ    0A2A
00A24:  XORLW  01
00A26:  BZ    0A5A
00A28:  BRA    0A7A
....................          { 
....................             case TCP_PIC_RAM: 
....................                if(ptrSource!=(PTR_BASE)-1) 
00A2A:  MOVLB  2
00A2C:  INCFSZ xA9,W
00A2E:  BRA    0A36
00A30:  INCFSZ xAA,W
00A32:  BRA    0A36
00A34:  BRA    0A44
....................                   MACSetReadPtr(ptrSource); 
00A36:  MOVFF  2AA,2AF
00A3A:  MOVFF  2A9,2AE
00A3E:  MOVLB  0
00A40:  RCALL  07CC
00A42:  MOVLB  2
....................                MACGetArray((BYTE*)ptrDest, wLength); 
00A44:  MOVFF  2A7,2C0
00A48:  MOVFF  2A6,2BF
00A4C:  MOVFF  2AD,2C2
00A50:  MOVFF  2AC,2C1
00A54:  MOVLB  0
00A56:  RCALL  07EA
....................                break; 
00A58:  BRA    0A7A
....................     
....................             case TCP_ETH_RAM: 
....................                MACMemCopyAsync(ptrDest, ptrSource, wLength); 
00A5A:  MOVFF  2A7,2AF
00A5E:  MOVFF  2A6,2AE
00A62:  MOVFF  2AA,2B1
00A66:  MOVFF  2A9,2B0
00A6A:  MOVFF  2AD,2B3
00A6E:  MOVFF  2AC,2B2
00A72:  RCALL  084C
....................                while(!MACIsMemCopyDone()); 
00A74:  RCALL  098E
00A76:  MOVF   01,F
00A78:  BZ    0A74
....................                break; 
....................     
....................             #if defined(SPIRAM_CS_TRIS) 
....................             case TCP_SPI_RAM: 
....................                if(ptrSource!=(PTR_BASE)-1) 
....................                   MACSetReadPtr(ptrSource); 
....................                w = sizeof(vBuffer); 
....................                while(wLength) 
....................                { 
....................                   if(w > wLength) 
....................                      w = wLength; 
....................                    
....................                   // Read and write a chunk    
....................                   MACGetArray(vBuffer, w); 
....................                   SPIRAMPutArray(ptrDest, vBuffer, w); 
....................                   ptrDest += w; 
....................                   wLength -= w; 
....................                } 
....................                break; 
....................             #endif 
....................          } 
....................          break; 
00A7A:  BRA    0A7C
....................     
....................       #if defined(SPIRAM_CS_TRIS) 
....................       case TCP_SPI_RAM: 
....................          switch(vDestType) 
....................          { 
....................             case TCP_PIC_RAM: 
....................                SPIRAMGetArray(ptrSource, (BYTE*)ptrDest, wLength); 
....................                break; 
....................     
....................             case TCP_ETH_RAM: 
....................                if(ptrDest!=(PTR_BASE)-1) 
....................                   MACSetWritePtr(ptrDest); 
....................                w = sizeof(vBuffer); 
....................                while(wLength) 
....................                { 
....................                   if(w > wLength) 
....................                      w = wLength; 
....................                    
....................                   // Read and write a chunk    
....................                   SPIRAMGetArray(ptrSource, vBuffer, w); 
....................                   ptrSource += w; 
....................                   MACPutArray(vBuffer, w); 
....................                   wLength -= w; 
....................                } 
....................                break; 
....................     
....................             case TCP_SPI_RAM: 
....................                // Copy all of the data over in chunks 
....................                w = sizeof(vBuffer); 
....................                while(wLength) 
....................                { 
....................                   if(w > wLength) 
....................                      w = wLength; 
....................                       
....................                   SPIRAMGetArray(ptrSource, vBuffer, w); 
....................                   SPIRAMPutArray(ptrDest, vBuffer, w); 
....................                   ptrSource += w; 
....................                   ptrDest += w; 
....................                   wLength -= w; 
....................                } 
....................                break; 
....................          } 
....................          break; 
....................       #endif          
....................    } 
00A7C:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void TCPRAMCopyROM(PTR_BASE wDest, BYTE wDestType, ROM BYTE* wSource,  
....................                         WORD wLength) 
....................  
....................   Summary: 
....................    Copies data to/from various memory mediums. 
....................  
....................   Description: 
....................    This function copies data between memory mediums (PIC RAM, SPI 
....................    RAM, and Ethernet buffer RAM).  This function is to be used when  
....................    copying from ROM. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    wDest      - Address to write to 
....................    wDestType   - Destination meidum (TCP_PIC_RAM, TCP_ETH_RAM, TCP_SPI_RAM) 
....................    wSource      - Address to copy from 
....................    wLength      - Number of bytes to copy 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    Copying to a destination region that overlaps with the source address  
....................    is supported only if the destination start address is at a lower memory  
....................    address (closer to 0x0000) than the source pointer. 
....................     
....................    This function is aliased to TCPRAMCopy on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... static void TCPRAMCopyROM(PTR_BASE wDest, BYTE wDestType, ROM BYTE* wSource, WORD wLength) 
.................... { 
....................    BYTE vBuffer[16]; 
....................    WORD w; 
....................     
....................    switch(wDestType) 
....................    { 
....................       case TCP_PIC_RAM: 
....................          memcpypgm2ram((void*)(BYTE*)wDest, (ROM void*)wSource, wLength); 
....................          break; 
....................     
....................       case TCP_ETH_RAM: 
....................          if(wDest!=(PTR_BASE)-1) 
....................             MACSetWritePtr(wDest); 
....................          w = sizeof(vBuffer); 
....................          while(wLength) 
....................          { 
....................             if(w > wLength) 
....................                w = wLength; 
....................              
....................             // Read and write a chunk    
....................             memcpypgm2ram(vBuffer, (ROM void*)wSource, w); 
....................             MACPutArray(vBuffer, w); 
....................             wSource += w; 
....................             wLength -= w; 
....................          } 
....................          break; 
....................     
....................       #if defined(SPIRAM_CS_TRIS) 
....................       case TCP_SPI_RAM: 
....................          w = sizeof(vBuffer); 
....................          while(wLength) 
....................          { 
....................             if(w > wLength) 
....................                w = wLength; 
....................              
....................             // Read and write a chunk    
....................             memcpypgm2ram(vBuffer, (ROM void*)wSource, w); 
....................             SPIRAMPutArray(wDest, vBuffer, w); 
....................             wDest += w; 
....................             wSource += w; 
....................             wLength -= w; 
....................          } 
....................          break; 
....................       #endif 
....................    } 
.................... } 
.................... #endif 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    SSL Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPStartSSLClient(TCP_SOCKET hTCP, BYTE* host) 
....................  
....................   Summary: 
....................    Begins an SSL client session. 
....................  
....................   Description: 
....................    This function escalates the current connection to an SSL secured  
....................    connection by initiating an SSL client handshake. 
....................  
....................   Precondition: 
....................    TCP is initialized and hTCP is already connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to secure 
....................    host      - Expected host name on certificate (currently ignored) 
....................  
....................   Return Values: 
....................    TRUE       - an SSL connection was initiated 
....................    FALSE       - Insufficient SSL resources (stubs) were available 
....................  
....................   Remarks: 
....................    The host parameter is currently ignored and is not validated. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL_CLIENT) 
.................... BOOL TCPStartSSLClient(TCP_SOCKET hTCP, BYTE* host) 
.................... { 
....................    BYTE i; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    // Make sure SSL is not established already 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       return FALSE; 
....................     
....................    // Try to start the session 
....................    MyTCBStub.sslStubID = SSLStartSession(hTCP, NULL, 0); 
....................     
....................    // Make sure a session stub was obtained 
....................    if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................       return FALSE; 
....................  
....................    // Mark connection as handshaking and return 
....................    MyTCBStub.sslReqMessage = SSL_CLIENT_HELLO; 
....................    MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................    MyTCBStub.sslTxHead = MyTCBStub.txHead; 
....................    MyTCBStub.Flags.bSSLHandshaking = 1; 
....................    for(i = 0; i < 5u; i++) 
....................    {// Skip first 5 bytes in TX for the record header 
....................       if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    return TRUE; 
.................... } 
.................... #endif // SSL Client 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPStartSSLClientEx(TCP_SOCKET hTCP, BYTE* host, BYTE * buffer, BYTE suppDataType) 
....................  
....................   Summary: 
....................    Begins an SSL client session. 
....................  
....................   Description: 
....................    This function escalates the current connection to an SSL secured  
....................    connection by initiating an SSL client handshake. 
....................  
....................   Precondition: 
....................    TCP is initialized and hTCP is already connected. 
....................  
....................   Parameters: 
....................    hTCP         - TCP connection to secure 
....................    host         - Expected host name on certificate (currently ignored) 
....................    buffer         - Buffer for supplementary data return 
....................    suppDataType    - Type of supplementary data to copy 
....................  
....................   Return Values: 
....................    TRUE       - an SSL connection was initiated 
....................    FALSE       - Insufficient SSL resources (stubs) were available 
....................  
....................   Remarks: 
....................    The host parameter is currently ignored and is not validated. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL_CLIENT) 
.................... BOOL TCPStartSSLClientEx(TCP_SOCKET hTCP, BYTE* host, void * buffer, BYTE suppDataType) 
.................... { 
....................    BYTE i; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    // Make sure SSL is not established already 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       return FALSE; 
....................     
....................    // Try to start the session 
....................    MyTCBStub.sslStubID = SSLStartSession(hTCP, buffer, suppDataType); 
....................     
....................    // Make sure a session stub was obtained 
....................    if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................       return FALSE; 
....................  
....................    // Mark connection as handshaking and return 
....................    MyTCBStub.sslReqMessage = SSL_CLIENT_HELLO; 
....................    MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................    MyTCBStub.sslTxHead = MyTCBStub.txHead; 
....................    MyTCBStub.Flags.bSSLHandshaking = 1; 
....................    for(i = 0; i < 5u; i++) 
....................    {// Skip first 5 bytes in TX for the record header 
....................       if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    return TRUE; 
.................... } 
.................... #endif // SSL Client 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPStartSSLServer(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Begins an SSL server session. 
....................  
....................   Description: 
....................    This function sets up an SSL server session when a new connection is 
....................    established on an SSL port. 
....................  
....................   Precondition: 
....................    TCP is initialized and hTCP is already connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to secure 
....................  
....................   Return Values: 
....................    TRUE      - an SSL connection was initiated 
....................    FALSE      - Insufficient SSL resources (stubs) were available 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL_SERVER) 
.................... BOOL TCPStartSSLServer(TCP_SOCKET hTCP) 
.................... { 
....................    BYTE i; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    SyncTCB(); 
....................     
....................    // Make sure SSL is not established already 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       return TRUE; 
....................     
....................    // Try to start the session 
....................    MyTCBStub.sslStubID = SSLStartSession(hTCP, NULL, 0); 
....................     
....................    // Make sure a session stub was obtained 
....................    if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................       return FALSE; 
....................  
....................    // Swap the localPort and localSSLPort 
....................    MyTCBStub.remoteHash.Val = MyTCB.localPort.Val; 
....................    MyTCB.localPort.Val = MyTCB.localSSLPort.Val; 
....................    MyTCB.localSSLPort.Val = MyTCBStub.remoteHash.Val;    
....................  
....................    // Mark connection as handshaking and return 
....................    MyTCBStub.sslReqMessage = SSL_NO_MESSAGE; 
....................    MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................    MyTCBStub.sslTxHead = MyTCBStub.txHead; 
....................    MyTCBStub.Flags.bSSLHandshaking = 1; 
....................    for(i = 0; i < 5u; i++) 
....................    {// Skip first 5 bytes in TX for the record header 
....................       if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    return TRUE; 
.................... } 
.................... #endif // SSL Client 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPAddSSLListener(TCP_SOCKET hTCP, WORD port) 
....................  
....................   Summary: 
....................    Listens for SSL connection on a specific port. 
....................  
....................   Description: 
....................    This function adds an additional listening port to a TCP connection.   
....................    Connections made on this alternate port will be secured via SSL. 
....................  
....................   Precondition: 
....................    TCP is initialized and hTCP is listening. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to secure 
....................    port      - SSL port to listen on 
....................  
....................   Return Values: 
....................    TRUE      - SSL port was added. 
....................    FALSE      - The socket was not a listening socket. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL_SERVER) 
.................... BOOL TCPAddSSLListener(TCP_SOCKET hTCP, WORD port) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    if(MyTCBStub.smState != TCP_LISTEN) 
....................       return FALSE; 
....................     
....................    SyncTCB(); 
....................     
....................    MyTCB.localSSLPort.Val = port; 
....................    MyTCBStub.sslTxHead = port; 
....................  
....................    return TRUE; 
.................... } 
.................... #endif // SSL Server 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPRequestSSLMessage(TCP_SOCKET hTCP, BYTE msg) 
....................  
....................   Summary: 
....................    Requests an SSL message to be transmitted. 
....................  
....................   Description: 
....................    This function is called to request that a specific SSL message be 
....................    transmitted.  This message should only be called by the SSL module. 
....................     
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to use 
....................    msg         - One of the SSL_MESSAGE types to transmit. 
....................  
....................   Return Values: 
....................    TRUE      - The message was requested. 
....................    FALSE      - Another message is already pending transmission. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... BOOL TCPRequestSSLMessage(TCP_SOCKET hTCP, BYTE msg) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    if(msg == SSL_NO_MESSAGE || MyTCBStub.sslReqMessage == SSL_NO_MESSAGE) 
....................    { 
....................       MyTCBStub.sslReqMessage = msg; 
....................       return TRUE; 
....................    } 
....................     
....................    return FALSE; 
.................... } 
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPSSLIsHandshaking(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines if an SSL session is still handshaking. 
....................  
....................   Description: 
....................    Call this function after calling TCPStartSSLClient until FALSE is 
....................    returned.  Then your application may continue with its normal data 
....................    transfer (which is now secured). 
....................     
....................   Precondition: 
....................    TCP is initialized and hTCP is connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to check 
....................  
....................   Return Values: 
....................    TRUE      - SSL handshake is still progressing 
....................    FALSE      - SSL handshake has completed 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... BOOL TCPSSLIsHandshaking(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    return MyTCBStub.Flags.bSSLHandshaking;    
.................... } 
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPIsSSL(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines if a TCP connection is secured with SSL. 
....................  
....................   Description: 
....................    Call this function to determine whether or not a TCP connection is  
....................    secured with SSL. 
....................     
....................   Precondition: 
....................    TCP is initialized and hTCP is connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to check 
....................  
....................   Return Values: 
....................    TRUE      - Connection is secured via SSL 
....................    FALSE      - Connection is not secured 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... BOOL TCPIsSSL(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................       return FALSE; 
....................     
....................    return TRUE; 
.................... } 
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLHandshakeComplete(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Clears the SSL handshake flag. 
....................  
....................   Description: 
....................    This function clears the flag indicating that an SSL handshake is 
....................    complete. 
....................     
....................   Precondition: 
....................    TCP is initialized and hTCP is connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to set 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLHandshakeComplete(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    MyTCBStub.Flags.bSSLHandshaking = 0; 
.................... } 
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLDecryptMAC(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, WORD len) 
....................  
....................   Summary: 
....................    Decrypts and MACs data arriving via SSL. 
....................  
....................   Description: 
....................    This function decrypts data in the TCP buffer and calculates the MAC over 
....................    the data.  All data is left in the exact same location in the TCP buffer. 
....................    It is called to help process incoming SSL records. 
....................     
....................   Precondition: 
....................    TCP is initialized, hTCP is connected, and ctx's Sbox is loaded. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to decrypt in 
....................    ctx         - ARCFOUR encryption context to use 
....................    len       - Number of bytes to crypt 
....................    inPlace      - TRUE to write back in place, FALSE to write at end of 
....................                currently visible data. 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLDecryptMAC(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, WORD len) 
.................... { 
....................    PTR_BASE wSrc, wDest, wBlockLen, wTemp; 
....................    BYTE buffer[32]; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    // Set up the pointers 
....................    SyncTCBStub(hTCP); 
....................    wSrc = MyTCBStub.rxTail; 
....................    wDest = wSrc; 
....................     
....................    // Handle 32 bytes at a time 
....................    while(len) 
....................    { 
....................       // Determine how many bytes we can read 
....................       wBlockLen = sizeof(buffer); 
....................       if(wBlockLen > len) // Don't do more than we should 
....................          wBlockLen = len; 
....................        
....................       // Read those bytes to a buffer 
....................       if(wSrc + wBlockLen > MyTCBStub.bufferEnd) 
....................       {// Two part read 
....................          wTemp = MyTCBStub.bufferEnd - wSrc + 1; 
....................          TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, wSrc, MyTCBStub.vMemoryMedium, wTemp); 
....................          TCPRAMCopy((PTR_BASE)buffer+wTemp, TCP_PIC_RAM, MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, wBlockLen - wTemp); 
....................          wSrc = MyTCBStub.bufferRxStart + wBlockLen - wTemp; 
....................       } 
....................       else 
....................       { 
....................          TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, wSrc, MyTCBStub.vMemoryMedium, wBlockLen); 
....................          wSrc += wBlockLen; 
....................       } 
....................        
....................       // Decrypt and hash 
....................       ARCFOURCrypt(ctx, buffer, wBlockLen); 
....................       SSLMACAdd(buffer, wBlockLen); 
....................        
....................       // Write decrypted bytes back 
....................       if(wDest + wBlockLen > MyTCBStub.bufferEnd) 
....................       {// Two part write 
....................          wTemp = MyTCBStub.bufferEnd - wDest + 1; 
....................          TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, wTemp); 
....................          TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer+wTemp, TCP_PIC_RAM, wBlockLen - wTemp); 
....................          wDest = MyTCBStub.bufferRxStart + wBlockLen - wTemp; 
....................       } 
....................       else 
....................       { 
....................          TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, wBlockLen); 
....................          wDest += wBlockLen; 
....................       } 
....................        
....................       // Update the length remaining 
....................       len -= wBlockLen; 
....................    } 
.................... }    
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLInPlaceMACEncrypt(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx,  
....................                            BYTE* MACSecret, WORD len) 
....................  
....................   Summary: 
....................    Encrypts and MACs data in place in the TCP TX buffer. 
....................  
....................   Description: 
....................    This function encrypts data in the TCP buffer while calcuating a MAC.   
....................    When encryption is finished, the MAC is appended to the buffer and  
....................    the record will be ready to transmit. 
....................     
....................   Precondition: 
....................    TCP is initialized, hTCP is connected, and ctx's Sbox is loaded. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to encrypt in 
....................    ctx         - ARCFOUR encryption context to use 
....................    MACSecret   - MAC encryption secret to use 
....................    len       - Number of bytes to crypt 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLInPlaceMACEncrypt(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, BYTE* MACSecret, WORD len) 
.................... { 
....................    PTR_BASE pos; 
....................    WORD blockLen; 
....................    BYTE buffer[32]; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    // Set up the pointers 
....................    SyncTCBStub(hTCP); 
....................    pos = MyTCBStub.txHead; 
....................    for(blockLen = 0; blockLen < 5u; blockLen++) 
....................    {// Skips first 5 bytes for the header 
....................       if(++pos >= MyTCBStub.bufferRxStart) 
....................          pos = MyTCBStub.bufferTxStart; 
....................    } 
....................     
....................    // Handle 32 bytes at a time 
....................    while(len) 
....................    { 
....................       // Determine how many bytes we can read 
....................       blockLen = sizeof(buffer); 
....................       if(blockLen > len) // Don't do more than we should 
....................          blockLen = len; 
....................       if(blockLen > MyTCBStub.bufferRxStart - pos) // Don't pass the end 
....................          blockLen = MyTCBStub.bufferRxStart - pos; 
....................        
....................       // Read those bytes to a buffer 
....................       TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, pos, MyTCBStub.vMemoryMedium, blockLen); 
....................        
....................       // Hash and encrypt 
....................       SSLMACAdd(buffer, blockLen); 
....................       ARCFOURCrypt(ctx, buffer, blockLen); 
....................        
....................       // Put them back 
....................       TCPRAMCopy(pos, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, blockLen); 
....................        
....................       // Update the pointers 
....................       pos += blockLen; 
....................       len -= blockLen; 
....................       if(pos >= MyTCBStub.bufferRxStart) 
....................          pos = MyTCBStub.bufferTxStart; 
....................    } 
....................     
....................    // Calculate and add the MAC 
....................    SSLMACCalc(MACSecret, buffer); 
....................    ARCFOURCrypt(ctx, buffer, 16); 
....................  
....................    // Write the MAC to the TX FIFO 
....................    // Can't use TCPPutArray here because TCPIsPutReady() saves 16 bytes for the MAC 
....................    // TCPPut* functions use this to prevent writing too much data.  Therefore, the 
....................    // functionality is duplicated here. 
....................     
....................    len = 16; 
....................    blockLen = 0; 
....................    // See if we need a two part put 
....................    if(MyTCBStub.sslTxHead + len >= MyTCBStub.bufferRxStart) 
....................    { 
....................       blockLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead; 
....................       TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, blockLen); 
....................       len -= blockLen; 
....................       MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................     
....................    TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&buffer[blockLen], TCP_PIC_RAM, len); 
....................    MyTCBStub.sslTxHead += len; 
....................  
.................... }    
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLPutRecordHeader(TCP_SOCKET hTCP, BYTE* hdr, BOOL recDone) 
....................  
....................   Summary: 
....................    Writes an SSL record header and sends an SSL record. 
....................  
....................   Description: 
....................    This function writes an SSL record header to the pending TCP SSL data,  
....................    then indicates that the data is ready to be sent by moving the txHead 
....................    pointer. 
....................     
....................    If the record is complete, set recDone to TRUE.  The sslTxHead  
....................    pointer will be moved forward 5 bytes to leave space for a future  
....................    record header.  If the record is only partially sent, use FALSE and 
....................    to leave the pointer where it is so that more data can be added 
....................    to the record.  Partial records can only be used for the  
....................    SERVER_CERTIFICATE handshake message. 
....................     
....................   Precondition: 
....................    TCP is initialized, and hTCP is connected with an active SSL session. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to write the header and transmit with 
....................    hdr         - Record header (5 bytes) to send or NULL to just  
....................               move the pointerctx 
....................    recDone      - TRUE if the record is done, FALSE otherwise 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLPutRecordHeader(TCP_SOCKET hTCP, BYTE* hdr, BOOL recDone) 
.................... { 
....................    BYTE i; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    // Set up the pointers 
....................    SyncTCBStub(hTCP); 
....................     
....................    // Write the header if needed 
....................    if(hdr) 
....................    {// This is a new record, so insert the header 
....................       for(i = 0; i < 5u; i++) 
....................       { 
....................          TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)hdr+i, TCP_PIC_RAM, sizeof(BYTE)); 
....................          if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart) 
....................             MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................       } 
....................    } 
....................     
....................    // Move the txHead pointer to indicate what data is ready 
....................    // Also, flush just the header, then all the data.  This shotguns two  
....................    // packets down the line, therefore causing immediate ACKs by the  
....................    // remote node.  Reconnect handshakes are as much as 60% faster now. 
....................    TCPFlush(hTCP); 
....................    MyTCBStub.txHead = MyTCBStub.sslTxHead; 
....................    TCPFlush(hTCP); 
....................     
....................    // If this record is done, move the sslTxHead forward 
....................    // to accomodate the next record header 
....................    if(recDone) 
....................    { 
....................       for(i = 0; i < 5u; i++) 
....................       {// Skip first 5 bytes in TX for the record header 
....................          if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................             MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................       } 
....................    } 
.................... }    
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPSSLGetPendingTxSize(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines how many bytes are pending for a future SSL record. 
....................  
....................   Description: 
....................    This function determines how many bytes are pending for a future SSL 
....................    record. 
....................     
....................   Precondition: 
....................    TCP is initialized, and hTCP is connected with an active SSL connection. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to check 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... WORD TCPSSLGetPendingTxSize(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    // Non-SSL connections have no pending SSL data 
....................    //if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................    //   return 0; 
....................           
....................    // Determine how many bytes are waiting to be written in this record 
....................    if(MyTCBStub.sslTxHead > MyTCBStub.txHead) 
....................       return MyTCBStub.sslTxHead - MyTCBStub.txHead - 5; 
....................    else 
....................       return (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.txHead - MyTCBStub.sslTxHead - 1) - 5; 
.................... } 
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLHandleIncoming(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Hands newly arrive TCP data to the SSL module for processing. 
....................  
....................   Description: 
....................    This function processes incoming TCP data as an SSL record and  
....................    performs any necessary repositioning and decrypting. 
....................     
....................   Precondition: 
....................    TCP is initialized, and hTCP is connected with an active SSL session. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to handle incoming data on 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLHandleIncoming(TCP_SOCKET hTCP) 
.................... { 
....................    PTR_BASE prevRxTail, nextRxHead, startRxTail, wSrc, wDest; 
....................    WORD wToMove, wLen, wSSLBytesThatPoofed, wDecryptedBytes; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    // Sync the stub 
....................    SyncTCBStub(hTCP); 
....................  
....................    // If new data is waiting 
....................    if(MyTCBStub.sslRxHead != MyTCBStub.rxHead) 
....................    { 
....................       // Reconfigure pointers for SSL use 
....................       prevRxTail = MyTCBStub.rxTail; 
....................       nextRxHead = MyTCBStub.rxHead; 
....................       MyTCBStub.rxTail = MyTCBStub.rxHead; 
....................       MyTCBStub.rxHead = MyTCBStub.sslRxHead; 
....................        
....................       do 
....................       { 
....................          startRxTail = MyTCBStub.rxTail; 
....................  
....................          // Handle incoming data.  This function performs deframing of the  
....................          // SSL records, decryption, and MAC verification. 
....................          wSSLBytesThatPoofed = TCPIsGetReady(hTCP); 
....................          wDecryptedBytes = SSLRxRecord(hTCP, MyTCBStub.sslStubID); 
....................          wSSLBytesThatPoofed -= TCPIsGetReady(hTCP); 
....................  
....................          // Now need to move data to fill the SSL header/MAC/padding hole,  
....................          // if there is one 
....................          if(wSSLBytesThatPoofed) 
....................          {    
....................             // Sync the TCP so we can see if there is a TCP hole 
....................             SyncTCB(); 
....................  
....................             // Calculate how big the SSL hole is 
....................             if(MyTCB.sHoleSize == -1) 
....................             {// Just need to move pending SSL data 
....................                wToMove = TCPIsGetReady(hTCP); 
....................             } 
....................             else 
....................             {// A TCP hole exists, so move all data 
....................                wToMove = TCPIsGetReady(hTCP) + MyTCB.sHoleSize + MyTCB.wFutureDataSize; 
....................             } 
....................              
....................             // Start with the destination as the startRxTail and source as current rxTail 
....................             wDest = startRxTail; 
....................             wSrc = MyTCBStub.rxTail; 
....................              
....................             // If data exists between the end of the buffer and  
....................             // the destination, then move it forward 
....................             if(wSrc > wDest) 
....................             { 
....................                wLen = MyTCBStub.bufferEnd - wSrc + 1; 
....................                if(wLen > wToMove) 
....................                   wLen = wToMove; 
....................                TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium,  
....................                         wSrc, MyTCBStub.vMemoryMedium, wLen); 
....................                wDest += wLen; 
....................                wSrc = MyTCBStub.bufferRxStart; 
....................                wToMove -= wLen; 
....................             } 
....................              
....................             // If data remains to be moved, fill in to end of buffer 
....................             if(wToMove) 
....................             { 
....................                wLen = MyTCBStub.bufferEnd - wDest + 1; 
....................                if(wLen > wToMove) 
....................                   wLen = wToMove; 
....................                TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium,  
....................                         wSrc, MyTCBStub.vMemoryMedium, wLen); 
....................                wDest = MyTCBStub.bufferRxStart; 
....................                wSrc += wLen; 
....................                wToMove -= wLen; 
....................             } 
....................              
....................             // If data still remains, copy from from front + len to front 
....................             if(wToMove) 
....................             { 
....................                TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, 
....................                         wSrc, MyTCBStub.vMemoryMedium, wToMove); 
....................             } 
....................  
....................             // Since bytes poofed, we need to move the head pointers  
....................             // backwards by an equal amount. 
....................             MyTCBStub.rxHead -= wSSLBytesThatPoofed; 
....................             if(MyTCBStub.rxHead < MyTCBStub.bufferRxStart) 
....................                MyTCBStub.rxHead += MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................             MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................          } 
....................              
....................          // Move tail pointer forward by the number of decrypted bytes ready  
....................          // for the application (but not poofed bytes) 
....................          MyTCBStub.rxTail = startRxTail + wDecryptedBytes; 
....................          if(MyTCBStub.rxTail > MyTCBStub.bufferEnd) 
....................             MyTCBStub.rxTail -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................          nextRxHead += wDecryptedBytes; 
....................           
....................          // Loop until SSLRxRecord() runs out of data and stops doing  
....................          // anything 
....................       } while(wSSLBytesThatPoofed || (startRxTail != MyTCBStub.rxTail)); 
....................  
....................       // Restore TCP buffer pointers to point to the decrypted application data  
....................       // only 
....................       if(nextRxHead > MyTCBStub.bufferEnd) 
....................          nextRxHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................       MyTCBStub.rxTail = prevRxTail; 
....................       MyTCBStub.rxHead = nextRxHead; 
....................    } 
.................... }    
.................... #endif 
....................  
....................  
.................... #endif //#if defined(STACK_USE_TCP) 
....................  
....................     
....................    void TCPTouch(TCP_SOCKET s) 
....................    { 
....................       SyncTCBStub(s); 
....................       if(MyTCBStub.smState == TCP_ESTABLISHED) 
....................       { 
....................          MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
....................          SyncTCB(); 
....................       } 
....................    } 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
....................    #include "_DNS.c" //ccs had to rename this driver to not conflict an s7600 driver in the default include path - a bug in the compiler 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS) 
....................    #include "MPFS.c" 
.................... #endif 
....................  
.................... #if (defined(STACK_USE_HTTP2) || defined(STACK_USE_HTTP2_SERVER)) && !defined(__HTTP2_C) 
....................     #include "HTTP2.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_HTTP) || defined(STACK_USE_HTTP_SERVER) 
....................     #include "HTTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP1_SERVER) 
....................    #include "ccs_HTTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    #include "ccs_HTTP2.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP) && !defined(__SMTP_C) 
....................    #include "smtp.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SMTP) 
....................    #include "ccs_SMTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
....................    #include "SNTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    #include "ccs_SNTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TWITTER) 
....................    #include "ccs_twitter.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
....................    #include "TFTPc.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_TFTP_SERVER) 
....................    #include "ccs_TFTPs.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) && !defined(__ANNOUNCE_C) 
....................    #include "Announce.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
....................    #include "MPFS2.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_GRATUITOUS_ARP) 
....................    #include "ccs_gratarp.c" 
.................... #endif 
....................  
.................... #if defined(__18CXX) 
....................    #include "p18cxxx.c" 
.................... // CCS PCH C Compiler to Microchip C18 Compiler compatability layer. 
....................  
.................... #ifndef __P18CXXXX_C__ 
.................... #define __P18CXXXX_C__ 
....................  
.................... #include "p18cxxx.h" 
.................... // CCS PCH C Compiler to Microchip C18 Compiler compatability layer. 
....................  
.................... #ifndef __P18CXXXX_H__ 
.................... #define __P18CXXXX_H__ 
....................  
.................... #ifndef __18CXX 
.................... #define __18CXX 
.................... #endif 
....................  
.................... //#zero_local_ram 
.................... #zero_ram 
....................  
....................  
.................... #device PASS_STRINGS=IN_RAM 
.................... #device CONST=READ_ONLY 
....................  
.................... #case 
.................... #type signed 
.................... #type short=16 int=16 long=32 
....................  
.................... #define _asm #asm 
.................... #define _endasm #endasm 
....................  
.................... /* usualy 
.................... #define GetSystemClock()      getenv("CLOCK") 
.................... #define GetInstructionClock()   (GetSystemClock()/4) 
.................... #define GetPeripheralClock()   (unsigned int32)GetInstructionClock() 
.................... */ 
....................  
.................... #if getenv("DEVICE") == "PIC18F97J60" 
....................  #define __18F97J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F96J65" 
....................  #define __18F96J65) 
.................... #elif getenv("DEVICE") == "PIC18F96J60" 
....................  #define __18F96J60 
.................... #elif getenv("DEVICE") == "PIC18F87J60" 
....................  #define __18F87J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J60" 
....................  #define __18F86J60 
.................... #elif getenv("DEVICE") == "PIC18F67J60" 
....................  #define __18F67J60 
....................  #include "PIC18F67J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F66J65" 
....................  #define __18F66J65 
.................... #elif getenv("DEVICE") == "PIC18F66J60" 
....................  #define __18F66J60 
.................... #elif getenv("DEVICE") == "PIC18F67K22" 
....................  #define __18F67K22 
....................  #include "PIC18F67K22_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F4620" 
....................  #define __18F4620 
....................  #include "PIC18F4620_registers.h" 
.................... #else 
....................    #error Do this for your chip 
.................... #endif 
....................  
.................... #if defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) 
....................    #reserve 0xE80:0xEFF 
....................    #reserve 0xF00:0xFFF 
.................... #endif 
....................  
.................... #if defined(TRUE) 
....................    #undef TRUE 
.................... #endif 
....................  
.................... #if defined(FALSE) 
....................    #undef FALSE 
.................... #endif 
....................  
.................... #if defined(BYTE) 
....................    #undef BYTE 
.................... #endif 
....................  
....................       #define Reset()            reset_cpu() 
....................         #define far 
....................         #define ClrWdt()         restart_wdt() 
....................       #define Nop()            delay_cycles(1)       
....................  
.................... #define __CCS__ 
....................  
.................... //signed int8 memcmppgm2ram(void * s1, rom char *s2, unsigned int8 n); 
.................... signed int8 strcmppgm2ram(char *s1, __ADDRESS__ s2); 
.................... char *strchrpgm(__ADDRESS__ s, unsigned int8 c); 
.................... char *strstrrampgm(char *s1, __ADDRESS__ s2); 
.................... unsigned int8 strlenpgm(__ADDRESS__ s); 
.................... void memcpypgm2ram(unsigned int8 *d, __ADDRESS__ s, unsigned int16 n); 
.................... //char* strupr(char *s);   now in string.h 
.................... void strcpypgm2ram(char *d, __ADDRESS__ s); 
.................... #endif 
....................  
.................... /* STRING.H already has this exact function 
.................... signed int8 memcmppgm2ram(void * s1, rom char *s2, unsigned int8 n) 
.................... { 
....................   #if 1 
....................    char *su1; 
....................    rom char *su2; 
....................     
....................    for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
....................    { 
....................       if(*su1!=*su2) 
....................          return ((*su1<*su2)?-1:+1); 
....................    } 
....................    return 0; 
....................   #else 
....................    #error///warning memcmppgm2ram disabled 
....................   #endif 
.................... }*/ 
....................  
.................... #if 0 //this is in string.h and helpers.c 
.................... char* strupr(char *s) 
.................... { 
....................    char *p; 
....................     
....................    p=s; 
....................     
....................    while(*p) 
....................    { 
....................       *p = toupper(*p++); 
....................    } 
....................    return(s); 
.................... } 
.................... #endif 
....................  
.................... void memcpypgm2ram(unsigned int8 *d, __ADDRESS__ s, unsigned int16 n) 
.................... { 
....................    //printf("ROM_0x%LX-to-0x%LX ", d, s); 
....................   #if (getenv("PROGRAM_MEMORY") > 0x10000) 
....................    #warning temporary ccs bug fix 
....................    s |= 0x10000; 
....................   #endif 
....................    read_program_memory(s, d, n); 
.................... } 
....................  
.................... void strcpypgm2ram(char *d, __ADDRESS__ s) 
.................... { 
....................    char c; 
....................    do 
....................    { 
....................       memcpypgm2ram(&c, s++, 1); 
....................       *d++ = c; 
....................    } while(c); 
.................... } 
....................  
.................... #if 0 
.................... signed int8 strcmppgm2ram(char *s1, rom char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... char *strchrpgm(rom char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
....................  
.................... char *strstrrampgm(char *s1, rom char *s2) 
.................... { 
....................    char *s; 
....................    rom char *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... unsigned int8 strlenpgm(rom char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
.................... #endif   //if 0 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... int1 DHCPBoundOrDisabled(void) 
.................... { 
....................   #if defined(STACK_USE_DHCP_CLIENT) 
....................    return(!DHCPIsEnabled(0) || DHCPIsBound(0)); 
....................   #else 
....................    return(TRUE); 
....................   #endif 
.................... } 
....................  
.................... int1 IsLinked(void) 
.................... { 
....................   #if STACK_USE_WIFI && defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    if (AppConfig.networkType == WF_ADHOC) 
....................    { 
....................       return(MACIsLinked() && g_WifiAdhocIsConn); 
....................    } 
....................   #endif 
....................     
....................    return(MACIsLinked() && DHCPBoundOrDisabled()); 
.................... } 
....................  
.................... #if defined(STACK_USE_MPFS) 
.................... MPFS _MpfsEofLoc; 
....................  
.................... unsigned int16 MPFSGetBytes(unsigned int8 *pDest, unsigned int16 n) 
.................... { 
....................    unsigned int16 ret = 0; 
....................    unsigned int16 i; 
....................    unsigned int8 *p; 
....................    int1 escaped = FALSE; 
....................     
....................    p = pDest; 
....................     
....................    debug_mpfs2(debug_putc, "\r\nMPFSGetBytes() START %LX ", _currentHandle); 
....................     
....................    while(n) 
....................    { 
....................       HTTP_INTERRUPT_TASKS(); 
....................        
....................       debug_mpfs2(debug_putc, "n=%LX ", n); 
....................        
....................       _MpfsEofLoc = _currentHandle; 
....................      #if defined(MPFS_USE_SPI_FLASH) 
....................       SPIFlashReadArray(_currentHandle, pDest, n); 
....................      #else 
....................       memcpypgm2ram(pDest, _currentHandle, n); //__ccs__ change because MPFS isn't rom pointer 
....................      #endif 
....................  
....................       _currentHandle += n; 
....................  
....................       //debug_array("START", pDest, n); 
....................  
....................       i = n; 
....................       n = 0; 
....................        
....................       while(i--) 
....................       { 
....................          _MpfsEofLoc++; 
....................          if (escaped || (*pDest == MPFS_DLE)) 
....................          { 
....................             if (!escaped) 
....................             { 
....................                n++; 
....................             } 
....................              
....................             if (escaped || i) 
....................             { 
....................                if (!escaped) 
....................                { 
....................                   debug_mpfs2(debug_putc, "! "); 
....................                   memmove(pDest, pDest+1, i); 
....................                   _MpfsEofLoc++; 
....................                   i--; 
....................                } 
....................                ret++; 
....................                escaped = FALSE; 
....................             } 
....................             else 
....................             { 
....................                escaped = TRUE; 
....................                pDest--; //counter pDest++ below, since we need to start saving new bytes here 
....................             } 
....................          } 
....................          else if(*pDest == MPFS_ETX) 
....................          { 
....................             _MpfsEofLoc--; 
....................             debug_mpfs2(debug_putc, "EOF %LX ", _MpfsEofLoc); 
....................             _currentHandle = MPFS_INVALID; 
....................             n = 0; 
....................             break; 
....................          } 
....................          else 
....................          { 
....................             ret++; 
....................          } 
....................          pDest++; 
....................       } 
....................    } 
....................    //debug_array("STOP", p, ret);    
....................  
....................    return(ret); 
.................... } 
.................... #ENDIF 
....................  
.................... #if STACK_USE_WIFI 
....................  
.................... //extern int1 g_WifiTempDisFlag; 
.................... //extern TICK g_WifiTempDisTick; 
.................... //extern int1 g_wifiConnected; 
.................... extern int1 g_WifiConnectFail; 
....................  
.................... // see StackTsk2.h for documentation 
.................... #if 0 
.................... int1 MyWFisConnected(void) 
.................... { 
....................    int1 ret = FALSE; 
....................  
....................   #if defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    if (AppConfig.networkType == WF_ADHOC) 
....................    { 
....................       if ( 
....................             g_WifiAdhocIsConn && 
....................             ((TickGet() - g_WifiAdhocTickConn) > WIFI_ADHOC_CONNECTION_TIMER) 
....................          ) 
....................       { 
....................          g_WifiAdhocIsConn = FALSE; 
....................       } 
....................       return(g_WifiAdhocIsConn); 
....................    } 
....................   #endif 
....................  
....................    if (g_wifiConnected) 
....................    { 
....................       ret = TRUE; 
....................    } 
....................    else if (!g_WifiConnectFail) 
....................    { 
....................       if (g_WifiTempDisFlag) 
....................       { 
....................          if ((TickGet() - g_WifiTempDisTick) < ((TICK)5*TICKS_PER_SECOND)) 
....................          { 
....................             ret = TRUE; 
....................          } 
....................          else 
....................          { 
....................             g_WifiTempDisFlag = FALSE; 
....................          } 
....................       } 
....................    } 
....................  
....................    return(ret); 
.................... } 
.................... #endif 
....................  
.................... unsigned int8 g_connectionProfileID = 0xFF;  //used to communicate with the connection profile on the WiFi module 
....................  
.................... unsigned int8 WIFI_channelList[16]; 
.................... unsigned int8 WIFI_numChannelsInList; 
.................... unsigned int8 WIFI_region; 
....................  
.................... // this option will force the connection profile to be closed and reopened 
.................... // if we do not get a connection within this time.  might fix an errata that 
.................... // says WPA/WPA2 will lockup instead of sending an event. 
.................... #define WIFI_FORCE_RECONNECT_TICK   (TICK)(TICKS_PER_SECOND * 120)  //might be too short for WPA/WPA2 phrase 
....................  
.................... #ifndef wifi_debug 
.................... #define wifi_debug(a,b,c,d,e,f,g,h,i) 
.................... #endif 
....................  
.................... // this was based off of WF_Connect() in Microchip's demo application. 
.................... void WIFIConnectTask(void) 
.................... { 
....................    #if !defined(APP_GENERIC_SCRATCH) 
....................       char WIFIConnectTask_Scratch[6]; 
....................    #else 
....................       #define WIFIConnectTask_Scratch  APP_GENERIC_SCRATCH 
....................    #endif 
....................     
....................   #if defined(WIFI_FORCE_RECONNECT_TICK) 
....................    static TICK fTick; 
....................   #endif 
....................  
....................   #if defined(LED_CONNECTION_ON) || defined(LED_ACTIVITY_ON) 
....................    static TICK l; 
....................    // if you have both LED_CONNECTION_ON and LED_ACTIVITY_ON (2 WIFI LEDs),  
....................    //    then one LED is used for flickering on traffic and another is used to  
....................    //    show connection state. 
....................    // if you only have LED_CONNECTION_ON (only 1 WIFI LED), then WIFI  
....................    //    connection status and wifi traffic flickering is shared on the same 
....................    //    LED. 
....................    // this routine below handles the traffic led flickering.  the LED was 
....................    //    turned off in the TCP/IP stack, this routine turns it back on every 
....................    //    200ms. 
....................    if ((TickGet() - l) >= TICKS_PER_SECOND/5) 
....................    { 
....................       l = TickGet(); 
....................        
....................      #if defined(LED_ACTIVITY_ON) 
....................       LED_ACTIVITY_OFF(); 
....................      #else 
....................       if (IsLinked()) 
....................       { 
....................          LED_CONNECTION_ON(); 
....................       } 
....................       else 
....................       { 
....................          LED_CONNECTION_OFF(); 
....................       } 
....................      #endif 
....................    } 
....................   #endif 
....................  
....................   #if defined(LED_CONNECTION_ON) && defined(LED_ACTIVITY_ON) 
....................    // handle the connection status LED if you have 2 WIFI LEDs. 
....................    if (IsLinked()) 
....................    { 
....................       LED_CONNECTION_ON(); 
....................    } 
....................    else 
....................    { 
....................       LED_CONNECTION_OFF(); 
....................    } 
....................   #endif 
....................  
....................   #if STACK_USE_WIFI && defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    if (AppConfig.networkType == WF_ADHOC) 
....................    { 
....................       if ( 
....................             g_WifiAdhocIsConn && 
....................             ((TickGet() - g_WifiAdhocTickConn) > WIFI_ADHOC_CONNECTION_TIMER) 
....................          ) 
....................       { 
....................          g_WifiAdhocIsConn = FALSE; 
....................       } 
....................    } 
....................   #endif 
....................  
....................   #if defined(WIFI_FORCE_RECONNECT_TICK) 
....................    if ( 
....................          (AppConfig.networkType != WF_ADHOC) && 
....................          (g_connectionProfileID != 0xFF) 
....................       ) 
....................    { 
....................       if (IsLinked()) 
....................       { 
....................          fTick = TickGet(); 
....................       } 
....................       else if ((TickGet() - fTick) > WIFI_FORCE_RECONNECT_TICK) 
....................       { 
....................         #if defined(STACK_IS_CCS_EXAMPLE) 
....................          fprintf(STREAM_UI, "\r\nLong WIFI connection timeout, reseting module"); 
....................         #endif 
....................          delay_ms(200); 
....................          MACInit(); 
....................          delay_ms(200); 
....................          g_connectionProfileID = 0xFF; 
....................         #if defined(WIFI_EXTRA_LINK_STATUS) 
....................          g_LastWifiEvent = 20; 
....................         #endif 
....................       } 
....................    } 
....................   #endif 
....................  
....................    if (g_connectionProfileID == 0xFF) 
....................    { 
....................       g_WifiConnectFail = FALSE; 
....................        
....................       WF_CPCreate(&g_connectionProfileID); 
....................        
....................       if (g_connectionProfileID != 0xFF) 
....................       { 
....................         #if defined(WIFI_GET_VERSION_INFO) 
....................          WF_GetDeviceInfo(&WIFI_GET_VERSION_INFO); 
....................         #endif 
....................  
....................          g_WifiConnectFail = TRUE; 
....................  
....................          WF_CPSetSsid(g_connectionProfileID,  
....................                     AppConfig.MySSID,  
....................                     AppConfig.SsidLength); 
....................           
....................          memset(WIFIConnectTask_Scratch, 0xFF, 6); 
....................          WF_CPSetBssid(g_connectionProfileID, WIFIConnectTask_Scratch); 
....................  
....................          WF_CPSetNetworkType(g_connectionProfileID, AppConfig.networkType); 
....................           
....................          if(AppConfig.networkType == WF_ADHOC) 
....................          { 
....................             WF_CPSetAdHocBehavior(g_connectionProfileID, AppConfig.adhocBehavior); 
....................          } 
....................  
....................          WF_CASetScanType(MY_DEFAULT_SCAN_TYPE);   // was WF_ACTIVE_SCAN 
....................  
....................          WF_CASetChannelList(WIFI_channelList, WIFI_numChannelsInList); //was AppConfig.channelList, AppConfig.numChannelsInList 
....................  
....................          WF_SetRegionalDomain(WIFI_region);  //was AppConfig.region 
....................           
....................          WF_CASetListRetryCount(MY_DEFAULT_LIST_RETRY_COUNT);  // was WF_RETRY_FOREVER 
....................           
....................          WF_CASetEventNotificationAction(MY_DEFAULT_EVENT_NOTIFICATION_LIST); // was WF_NOTIFY_ALL_EVENTS 
....................           
....................          WF_CASetBeaconTimeout(MY_DEFAULT_BEACON_TIMEOUT); 
....................  
....................          WF_CASetBeaconTimeoutAction(WF_ATTEMPT_TO_RECONNECT); 
....................           
....................          WF_CASetDeauthAction(WF_ATTEMPT_TO_RECONNECT); 
....................  
....................        #if defined(DERIVE_KEY_FROM_PASSPHRASE_IN_HOST) 
....................            if (AppConfig.SecurityMode == WF_SECURITY_WPA_WITH_PASS_PHRASE 
....................                || AppConfig.SecurityMode == WF_SECURITY_WPA2_WITH_PASS_PHRASE 
....................                || AppConfig.SecurityMode == WF_SECURITY_WPA_AUTO_WITH_PASS_PHRASE) { 
....................                WF_ConvPassphrase2Key(AppConfig.SecurityKeyLength, AppConfig.SecurityKey, 
....................                    AppConfig.SsidLength, AppConfig.MySSID); 
....................                AppConfig.SecurityMode--; 
....................                AppConfig.SecurityKeyLength = 32; 
....................            } 
....................        #if defined (MRF24WG) 
....................            else if (AppConfig.SecurityMode == WF_SECURITY_WPS_PUSH_BUTTON 
....................                        || AppConfig.SecurityMode == WF_SECURITY_WPS_PIN) { 
....................                WF_YieldPassphrase2Host();     
....................            } 
....................        #endif    /* defined (MRF24WG) */ 
....................        #endif    /* defined(DERIVE_KEY_FROM_PASSPHRASE_IN_HOST) */ 
....................  
....................          WF_CPSetSecurity(g_connectionProfileID, 
....................                         AppConfig.SecurityMode, 
....................                         0, //AppConfig.WepKeyIndex, //AppConfig.WepKeyIndex,   /* only used if WEP enabled */ 
....................                         AppConfig.SecurityKey, 
....................                         AppConfig.SecurityKeyLength);       
....................   
....................       #if (MY_DEFAULT_WIFI_SECURITY_WEP_KEYTYPE!=WF_SECURITY_WEP_SHAREDKEY) 
....................         #if !defined(MRF24WG) 
....................          if (gRFModuleVer1209orLater) 
....................         #endif 
....................          { 
....................             // If WEP security is used, set WEP Key Type.  The default WEP Key Type is Shared Key. 
....................             if ((AppConfig.SecurityMode == WF_SECURITY_WEP_40) || (AppConfig.SecurityMode == WF_SECURITY_WEP_104)) 
....................             { 
....................                 WF_CPSetWepKeyType(g_connectionProfileID, MY_DEFAULT_WIFI_SECURITY_WEP_KEYTYPE); 
....................             } 
....................          } 
....................         #endif 
....................  
....................        #ifndef WF_FORCE_NO_PS_POLL 
....................        #if MY_DEFAULT_PS_POLL == WF_ENABLED 
....................            WF_PsPollEnable(TRUE); 
....................        #if !defined(MRF24WG)  
....................            if (gRFModuleVer1209orLater) 
....................                WFEnableDeferredPowerSave(); 
....................        #endif    // !defined(MRF24WG) 
....................        #else     // MY_DEFAULT_PS_POLL != WF_ENABLED 
....................            WF_PsPollDisable(); 
....................        #endif    // MY_DEFAULT_PS_POLL == WF_ENABLED 
....................     
....................        #ifdef WF_AGGRESSIVE_PS 
....................        #if !defined(MRF24WG) 
....................            if (gRFModuleVer1209orLater) 
....................                WFEnableAggressivePowerSave(); 
....................        #endif 
....................        #endif 
....................        #endif 
....................       } 
....................    } 
....................  
....................    if(g_WifiConnectFail) 
....................    { 
....................       wifi_debug(debug_putc, "Start WiFi Connect PROF=%u\r\n", g_connectionProfileID); 
....................       
....................      #if defined(STACK_IS_CCS_EXAMPLE) 
....................       fprintf(STREAM_UI, "\r\nStart WiFi Connect"); 
....................      #endif 
....................       
....................      #if defined(WIFI_FORCE_RECONNECT_TICK) 
....................       fTick = TickGet(); 
....................      #endif 
....................  
....................      #if defined(WF_FORCE_NO_PS_POLL) 
....................       WF_CCS_PsPollDisable(); 
....................      #endif 
....................     
....................       WF_CMConnect(g_connectionProfileID); 
....................    } 
....................     
....................    g_WifiConnectFail = 0; 
.................... } 
....................  
.................... void LinkTraffic(int1 isTx) 
.................... { 
....................   #if defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    if (!isTx && (AppConfig.networkType == WF_ADHOC)) 
....................    { 
....................       g_WifiAdhocIsConn = TRUE; 
....................       g_WifiAdhocTickConn = TickGet(); 
....................    } 
....................   #endif 
....................  
....................    // these LEDs are desribed in WIFIConnectTask() 
....................   #if defined(LED_ACTIVITY_ON) 
....................    LED_ACTIVITY_ON(); 
....................   #elif defined(LED_CONNECTION_ON) 
....................    LED_CONNECTION_OFF(); 
....................   #endif 
.................... } 
....................  
....................  
.................... #if defined(WF_FORCE_NO_PS_POLL) 
.................... #if defined(WF_USE_POWER_SAVE_FUNCTIONS) 
....................    #error dont use both at the same time 
.................... #endif 
.................... typedef struct pwrModeRequestStruct 
.................... { 
....................     UINT8 mode; 
....................     UINT8 wake; 
....................     UINT8 rcvDtims; 
....................     UINT8 reserved;            /* pad byte */ 
.................... } tWFPwrModeReq; 
....................  
.................... static void SendPowerModeMsg(tWFPwrModeReq *p_powerMode) 
.................... { 
....................     UINT8 hdr[2]; 
....................      
....................     hdr[0] = WF_MGMT_REQUEST_TYPE; 
....................     hdr[1] = WF_SET_POWER_MODE_SUBTYPE; 
....................  
....................     SendMgmtMsg(hdr, 
....................                 sizeof(hdr), 
....................                (UINT8 *)p_powerMode, 
....................                sizeof(tWFPwrModeReq)); 
....................  
....................     /* wait for mgmt response, free buffer after it comes in (no data to read) */ 
....................    WaitForMgmtResponse(WF_SET_POWER_MODE_SUBTYPE, FREE_MGMT_BUFFER); 
....................      
.................... }  
....................  
.................... void WF_CCS_PsPollDisable(void) 
.................... { 
....................    tWFPwrModeReq   pwrModeReq; 
....................      
....................     pwrModeReq.mode     = 1;  //PS_POLL_DISABLED; 
....................     pwrModeReq.wake     = 1; 
....................     pwrModeReq.rcvDtims = 1; 
....................     SendPowerModeMsg(&pwrModeReq); 
....................  
....................     //SetPowerSaveState(WF_PS_OFF); //not really needed, sets a global for their statemachine 
....................  
....................     WFConfigureLowPowerMode(WF_LOW_POWER_MODE_OFF);  
.................... } 
.................... #endif   //WF_FORCE_NO_PS_POLL 
....................  
.................... #endif //STACK_USE_WIFI 
....................  
.................... #if defined(__DO_DEBUG_MPFS2) 
.................... void debug_array(char *str, char *p, unsigned int16 n) 
.................... { 
....................    char c; 
....................    debug_mpfs2(debug_putc, "\r\n%s %LX ", str, n); 
....................    while(n--) 
....................    { 
....................       c = *p++; 
....................       if ((c >= ' ') && (c <= '}')) 
....................       { 
....................          debug_mpfs2(debug_putc, "%c", c); 
....................       } 
....................       else 
....................       { 
....................          debug_mpfs2(debug_putc, "+%X", c); 
....................       } 
....................    } 
....................    debug_mpfs2(debug_putc, " "); 
.................... } 
.................... #else 
.................... #define debug_array(str, p, n) 
.................... #endif 
....................  
.................... // if you call TickGet() from an ISR, this may be a lock-up condition. 
.................... // this is a morph of GetTickCopy() and TickUpdate() that works from an ISR. 
.................... // only works on PIC18. 
.................... #if defined(__PCH__) 
.................... TICK TickGetSafe(void) 
.................... { 
....................    BYTE myTickReading[6]; 
....................    do 
....................    { 
....................       if(INTCONbits.TMR0IF) 
....................       { 
....................          dwInternalTicks++; 
....................          INTCONbits.TMR0IF = 0; 
....................       } 
....................       myTickReading[0] = TMR0L; 
....................       myTickReading[1] = TMR0H; 
....................       *((DWORD*)&myTickReading[2]) = dwInternalTicks; 
....................    } while(INTCONbits.TMR0IF); 
....................     
....................    return *((DWORD*)&myTickReading[0]); 
.................... } 
.................... #endif 
....................  
.................... // this used to be called GenerateRandomBYTE() in an older CCS port of Helpers.c 
.................... BYTE GenerateRandomByteFromTimers(void) 
.................... { 
....................    BYTE rand; 
....................     
....................   #if getenv("TIMER0") && !defined(__PCD__) 
....................    rand+=get_timer0(); 
....................   #endif 
....................    
....................   #if getenv("TIMER1") 
....................    rand+=get_timer1(); 
....................   #endif 
....................    
....................   #if getenv("TIMER2") 
....................    rand+=get_timer2(); 
....................   #endif 
....................    
....................   #if getenv("TIMER3") 
....................    rand+=get_timer3(); 
....................   #endif 
....................    
....................   #if getenv("TIMER4") 
....................    rand+=get_timer4(); 
....................   #endif 
....................    
....................   #if getenv("TIMER5") 
....................    rand+=get_timer5(); 
....................   #endif 
....................    
....................    return(rand); 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................    Assigns the MAC address of the unit. 
....................    This is removed when using WIFI, so it will use the MAC address of the 
....................    WIFI module.  You can still override the MAC address of the WIFI module 
....................    if you remove the conditional compilation option. 
.................... */ 
.................... void MACAddrInit(void) 
.................... { 
....................   #if !STACK_USE_WIFI 
....................    MY_MAC_BYTE1=0; 
*
002CE:  CLRF   57
....................    MY_MAC_BYTE2=2; 
002D0:  MOVLW  02
002D2:  MOVWF  58
....................    MY_MAC_BYTE3=3; 
002D4:  MOVLW  03
002D6:  MOVWF  59
....................    MY_MAC_BYTE4=4; 
002D8:  MOVLW  04
002DA:  MOVWF  5A
....................    MY_MAC_BYTE5=5; 
002DC:  MOVLW  05
002DE:  MOVWF  5B
....................    MY_MAC_BYTE6=7; 
002E0:  MOVLW  07
002E2:  MOVWF  5C
....................   #endif 
002E4:  GOTO   0326 (RETURN)
.................... } 
....................  
.................... void IPAddrInit(void)  
.................... { 
....................    //IP address of this unit 
....................    MY_IP_BYTE1=192; 
002E8:  MOVLW  C0
002EA:  MOVWF  2A
....................    MY_IP_BYTE2=168; 
002EC:  MOVLW  A8
002EE:  MOVWF  2B
....................    MY_IP_BYTE3=0; 
002F0:  CLRF   2C
....................    MY_IP_BYTE4=7; 
002F2:  MOVLW  07
002F4:  MOVWF  2D
....................  
....................    //network gateway 
....................    MY_GATE_BYTE1=192; 
002F6:  MOVLW  C0
002F8:  MOVWF  32
....................    MY_GATE_BYTE2=168; 
002FA:  MOVLW  A8
002FC:  MOVWF  33
....................    MY_GATE_BYTE3=0; 
002FE:  CLRF   34
....................    MY_GATE_BYTE4=1; 
00300:  MOVLW  01
00302:  MOVWF  35
....................  
....................    //subnet mask 
....................    MY_MASK_BYTE1=255; 
00304:  SETF   2E
....................    MY_MASK_BYTE2=255; 
00306:  SETF   2F
....................    MY_MASK_BYTE3=255; 
00308:  SETF   30
....................    MY_MASK_BYTE4=0; 
0030A:  CLRF   31
....................    
....................   #if defined(STACK_USE_DNS) 
0030C:  GOTO   0328 (RETURN)
....................    AppConfig.PrimaryDNSServer.v[0] = 192; 
....................    AppConfig.PrimaryDNSServer.v[1] = 168; 
....................    AppConfig.PrimaryDNSServer.v[2] = 100; 
....................    AppConfig.PrimaryDNSServer.v[3] = 1; 
....................   #endif 
.................... } 
....................  
.................... char ExampleIPDatagram[] = { 
....................    0x45, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
....................    0x64, 0x11, 0x2A, 0x9D, 0x0A, 0x0B, 0x0C, 0x0D, 
....................    0x0A, 0x0B, 0x0C, 0x0E 
.................... }; 
....................  
.................... char ExampleUDPPacket[] = { 
....................    0x04, 0x00, 0x04, 0x01, 0x00, 0x0C, 0x00, 0x00, 
....................    0x01, 0x02, 0x03, 0x04 
.................... }; 
....................  
.................... void MACToString(char *str, MAC_ADDR *mac) 
.................... { 
....................    sprintf(str, "%X:%X:%X:%X:%X:%X", mac->v[0], mac->v[1], mac->v[2], mac->v[3], mac->v[4], mac->v[5]); 
.................... } 
....................  
.................... void IPToString(char *str, IP_ADDR *ip) 
.................... { 
....................    sprintf(str, "%u.%u.%u.%u", ip->v[0], ip->v[1], ip->v[2], ip->v[3]); 
.................... } 
....................  
.................... /****************************************************************************** 
....................  * If using the newest stack, options for WiFi should be set in WF_Config.h 
....................  *****************************************************************************/ 
.................... #if STACK_USE_WIFI 
....................  
.................... #include "tcpip/StackTsk2.c" 
....................  
.................... #if !STACK_USE_CCS_INI 
.................... // initialize WIFI settings using harcoded values 
.................... void WIFI_Init(void) 
.................... { 
....................    unsigned int8 chans[] = MY_DEFAULT_CHANNEL_LIST; 
....................     
....................    g_connectionProfileID = 0xFF; 
....................     
....................    WIFI_numChannelsInList = sizeof(chans); 
....................    memcpy(WIFI_channelList, chans, WIFI_numChannelsInList); 
....................    WIFI_region = MY_DEFAULT_REGION; 
....................  
....................    // If MAC address is all zero's, then set it to the default MAC address. 
....................    // If the MAC address is the default MAC address, the stack will then use 
....................    // MAC internal to the WIFI module. 
....................    MAC_ADDR blankMac; 
....................    memset(&blankMac, 0x00, sizeof(MAC_ADDR)); 
....................    if (memcmp(&AppConfig.MyMACAddr, &blankMac, sizeof(MAC_ADDR)) == 0) 
....................    { 
....................       memcpy(&AppConfig.MyMACAddr, &MchpDefaultMacAddress, sizeof(MAC_ADDR)); 
....................    } 
....................     
....................    // Load the default SSID Name 
....................    strcpy(AppConfig.MySSID, MY_DEFAULT_SSID_NAME); 
....................    AppConfig.SsidLength = strlen(AppConfig.MySSID); 
....................  
....................    AppConfig.SecurityMode = MY_DEFAULT_WIFI_SECURITY_MODE; 
....................    AppConfig.WepKeyIndex  = MY_DEFAULT_WEP_KEY_INDEX; 
....................    
....................   #if (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_OPEN) 
....................       memset(AppConfig.SecurityKey, 0x00, sizeof(AppConfig.SecurityKey)); 
....................  
....................   #elif MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WEP_40 
....................       strcpy(AppConfig.SecurityKey, MY_DEFAULT_WEP_KEYS_40); 
....................  
....................   #elif MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WEP_104 
....................     strcpy(AppConfig.SecurityKey, MY_DEFAULT_WEP_KEYS_104); 
....................      
....................   #elif (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA_WITH_KEY)       || \ 
....................         (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA2_WITH_KEY)      || \ 
....................         (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA_AUTO_WITH_KEY) 
....................     strcpy(AppConfig.SecurityKey, MY_DEFAULT_PSK); 
....................  
....................   #elif (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA_WITH_PASS_PHRASE)     || \ 
....................         (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA2_WITH_PASS_PHRASE)    || \ 
....................         (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA_AUTO_WITH_PASS_PHRASE) 
....................       strcpy(AppConfig.SecurityKey, MY_DEFAULT_PSK_PHRASE); 
....................  
....................   #else  
....................       #error No security defined 
....................   #endif 
....................      
....................     AppConfig.networkType = MY_DEFAULT_NETWORK_TYPE; 
....................     AppConfig.adhocBehavior = MY_DEFAULT_ADHOC_BEHAVIOR; 
....................      
....................     AppConfig.SecurityKeyLength = strlen(AppConfig.SecurityKey); 
.................... } 
.................... #else  
.................... #define WIFI_Init()  g_connectionProfileID = 0xFF  //taken care of by CCS_INI 
.................... #endif   //!STACK_USE_CCS_INI 
.................... #endif   //!WIFI 
....................  
.................... void Init(void) 
.................... { 
....................    init_user_io(); 
*
00322:  BRA    025C
....................   
....................    MACAddrInit(); //used by CCS TCP/IP examples 
00324:  BRA    02CE
....................     
....................    IPAddrInit();  //used by CCS TCP/IP examples 
00326:  BRA    02E8
....................     
....................    TickInit(); 
00328:  BRA    0310
....................     
....................     
....................   #if STACK_USE_WIFI 
....................    delay_ms(50); //let the tick get a value for seeding rand 
....................    srand(TickGet() * get_timer0()); //seed random value for channel 
....................    WIFI_Init(); 
....................   #endif 
....................     
....................   #if defined(__PCH__) 
....................    enable_interrupts(GLOBAL); //used by TICK and WIFI 
0032A:  MOVLW  C0
0032C:  IORWF  FF2,F
....................   #else 
....................    enable_interrupts(INTR_GLOBAL); 
....................   #endif 
....................  
....................   #if STACK_USE_CCS_INI 
0032E:  GOTO   570E (RETURN)
....................    EEInit(); 
....................  
....................    //printf("\r\n\nMAGIC RD = %X\r\n\n", EERead8(EE_MAGIC)); 
....................  
....................    if (EERead8(EE_MAGIC) != DEF_MAGIC) 
....................    { 
....................       printf(UserPutc, "\r\n\nResetting EEPROM...\r\n\n"); 
....................       EEPROMToDefaults(); 
....................    } 
....................  
....................    EELoadSettings();    
....................    
....................    UIInit(); 
....................   #endif 
.................... } 
....................  
.................... #if STACK_USE_CCS_INI 
....................    #include "ee.c" 
....................    #include "ccsui.c" 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... #int_addrerr FAST 
.................... void IsrAdrerr(void) 
.................... { 
....................    int16 w[16]; 
....................    int16 h,l; 
....................    int32 val; 
....................   #asm 
....................    POP.S 
....................    POP h; 
....................    POP l; 
....................   #endasm 
....................     
....................    w[0] = WREG0; 
....................    w[1] = WREG1; 
....................    w[2] = WREG2; 
....................    w[3] = WREG3; 
....................    w[4] = WREG4; 
....................    w[5] = WREG5; 
....................    w[6] = WREG6; 
....................    w[7] = WREG7; 
....................    w[8] = WREG8; 
....................    w[9] = WREG9; 
....................    w[10] = WREG10; 
....................    w[11] = WREG11; 
....................    w[12] = WREG12; 
....................    w[13] = WREG13; 
....................    w[14] = WREG14; 
....................    w[15] = WREG15; 
....................     
....................     
....................    h &= 0x00FF; 
....................     
....................    val = make32(h, l); 
....................    val -= 2; 
....................     
....................    // this address might be off by 2 bytes 
....................     
....................    printf("\r\n\nADDRESS FAULT 0x%LX ", val); 
....................    for (l=0;l<16;l++) 
....................    { 
....................       printf("W%U:%LX ", l, w[l]); 
....................    } 
....................    printf("\r\n"); 
....................  
....................    while(TRUE); 
.................... } 
.................... #int_stackerr 
.................... void IsrStackerr(void) 
.................... { 
....................    printf("\r\n\n*** STACKERR ***\r\n\n"); 
....................    for(;;) {} 
.................... } 
.................... #endif 
....................  
....................  
.................... // one general purpose TCP socket 
.................... TCPSocketInitializer_t TCPSocketInitializer[TCP_CONFIGURATION] = 
.................... { 
....................     {TCP_PURPOSE_DEFAULT, TCP_ETH_RAM, 500, 500} 
.................... }; 
....................  
.................... #define MY_HTTP_SOCKET  80 
....................  
.................... unsigned int8 HTTPSocket=INVALID_SOCKET; 
....................  
.................... /*void LCDTask(void)  
.................... { 
....................    static enum {LCD_INIT=0, LCD_NO_MAC, LCD_NO_DHCP, LCD_NO_WEB_INIT, LCD_NO_WEB, LCD_IDLE} state=0; 
....................  
....................    switch(state)  
....................    { 
....................       case LCD_INIT: 
....................          printf(lcd_putc, "\fWebserver\n\rNo MAC Link"); 
....................          state = LCD_NO_MAC; 
....................          LED_OFF(USER_LED1); 
....................          break; 
....................           
....................       case LCD_NO_MAC: 
....................          if (MACIsLinked()) 
....................          { 
....................            #if defined(STACK_USE_DHCP) 
....................             if (!DHCPIsEnabled(0)) 
....................            #else 
....................             if (1) 
....................            #endif 
....................             { 
....................                state = LCD_NO_WEB_INIT; 
....................             } 
....................             else 
....................             { 
....................                printf(lcd_putc, "\fWebserver\n\rDHCP Not Bound"); 
....................                state = LCD_NO_DHCP; 
....................             } 
....................          } 
....................          break; 
....................  
....................    #if defined(STACK_USE_DHCP) 
....................      case LCD_NO_DHCP: 
....................          if (!MACIsLinked()) 
....................          { 
....................             state = LCD_INIT; 
....................             break; 
....................          } 
....................          if (DHCPIsBound(0)) 
....................          { 
....................             state = LCD_NO_WEB_INIT; 
....................             LED_ON(USER_LED1); 
....................          } 
....................          break; 
....................    #endif 
....................     
....................       case LCD_NO_WEB_INIT: 
....................             printf(lcd_putc, "\fWebserver Idle\n\r%u.%u.%u.%u", MY_IP_BYTE1, MY_IP_BYTE2, 
....................                MY_IP_BYTE3, MY_IP_BYTE4); 
....................             state = LCD_NO_WEB; 
....................             break; 
....................              
....................       case LCD_NO_WEB: 
....................          if ( 
....................                !MACIsLinked()  
....................               #if defined(STACK_USE_DHCP) 
....................                || (DHCPIsEnabled(0) && !DHCPIsBound(0)) 
....................               #endif 
....................             ) 
....................          { 
....................             state = LCD_INIT; 
....................          } 
....................          if ((HTTPSocket!=INVALID_SOCKET) && TCPIsConnected(HTTPSocket)) 
....................          { 
....................             SyncTCBStub(HTTPSocket); 
....................             SyncTCB(); 
....................              
....................             printf(lcd_putc,"\fConnected to\n\r%u.%u.%u.%u", MyTCB.remote.niRemoteMACIP.IPAddr.v[0], 
....................                      MyTCB.remote.niRemoteMACIP.IPAddr.v[1], 
....................                      MyTCB.remote.niRemoteMACIP.IPAddr.v[2], 
....................                      MyTCB.remote.niRemoteMACIP.IPAddr.v[3] 
....................                    ); 
....................             state = LCD_IDLE; 
....................          } 
....................          break; 
....................  
....................       case LCD_IDLE: 
....................          if ( 
....................                !MACIsLinked() 
....................               #if defined(STACK_USE_DHCP) 
....................                || (DHCPIsEnabled(0) && !DHCPIsBound(0)) 
....................               #endif 
....................             ) 
....................          { 
....................             state = LCD_INIT; 
....................          } 
....................          if (!TCPIsConnected(HTTPSocket)) 
....................          { 
....................             state = LCD_NO_WEB_INIT; 
....................          } 
....................          break; 
....................    } 
.................... }*/ 
....................  
.................... void HTTPPut(char c) { 
....................    TCPPut(HTTPSocket, c); 
*
05178:  MOVFF  166,270
0517C:  MOVFF  26F,271
05180:  BRA    5058
05182:  RETURN 0
.................... } 
....................  
.................... void HTTPTask(void) { 
....................    static enum {HTTP_ST_CONNECT=0, HTTP_ST_WAIT_CONNECT=1, HTTP_ST_GET=2, 
....................       HTTP_ST_PUT=3, HTTP_ST_DISCONNECT=4} state=0; 
....................    static TICK timeout_counter; 
....................    static char lc, lc2; 
....................    char c; 
....................    char content[250]; 
....................    unsigned int8 a0; 
....................   #if defined(SECONDARY_ADC_CHANNEL) 
....................    unsigned int8 a1; 
....................   #endif 
....................  
....................    if (HTTPSocket==INVALID_SOCKET) 
*
052AE:  MOVLB  1
052B0:  MOVF   x66,W
052B2:  SUBLW  FE
052B4:  BNZ   52BA
....................       state=HTTP_ST_CONNECT; 
052B6:  CLRF   x67
052B8:  BRA    5326
....................    else if (!TCPIsConnected(HTTPSocket)) 
052BA:  MOVFF  166,26A
052BE:  MOVLB  0
052C0:  RCALL  4B32
052C2:  MOVF   01,F
052C4:  BNZ   52D0
....................       state=HTTP_ST_WAIT_CONNECT; 
052C6:  MOVLW  01
052C8:  MOVLB  1
052CA:  MOVWF  x67
052CC:  BRA    5326
052CE:  MOVLB  0
....................    else if (TickGetDiff(TickGet(), timeout_counter) > TICKS_PER_SECOND*60) 
052D0:  CALL   0E34
052D4:  MOVFF  03,26D
052D8:  MOVFF  02,26C
052DC:  MOVFF  01,26B
052E0:  MOVFF  00,26A
052E4:  MOVLB  1
052E6:  MOVF   x68,W
052E8:  MOVLB  2
052EA:  SUBWF  x6A,F
052EC:  MOVLB  1
052EE:  MOVF   x69,W
052F0:  MOVLB  2
052F2:  SUBWFB x6B,F
052F4:  MOVLB  1
052F6:  MOVF   x6A,W
052F8:  MOVLB  2
052FA:  SUBWFB x6C,F
052FC:  MOVLB  1
052FE:  MOVF   x6B,W
05300:  MOVLB  2
05302:  SUBWFB x6D,F
05304:  BNZ   5320
05306:  MOVF   x6C,W
05308:  SUBLW  24
0530A:  BC    5328
0530C:  XORLW  FF
0530E:  BNZ   5320
05310:  MOVF   x6B,W
05312:  SUBLW  3F
05314:  BC    5328
05316:  XORLW  FF
05318:  BNZ   5320
0531A:  MOVF   x6A,W
0531C:  SUBLW  B8
0531E:  BC    5328
....................       state=HTTP_ST_DISCONNECT; 
05320:  MOVLW  04
05322:  MOVLB  1
05324:  MOVWF  x67
05326:  MOVLB  2
....................  
....................    switch(state) { 
05328:  MOVLB  1
0532A:  MOVF   x67,W
0532C:  ADDLW  FB
0532E:  BTFSC  FD8.0
05330:  BRA    55F2
05332:  ADDLW  05
05334:  MOVLB  0
05336:  GOTO   55F8
....................       case HTTP_ST_CONNECT: 
....................          HTTPSocket=TCPListen(MY_HTTP_SOCKET); 
0533A:  MOVLB  2
0533C:  CLRF   x6D
0533E:  CLRF   x6C
05340:  CLRF   x6B
05342:  CLRF   x6A
05344:  CLRF   x6E
05346:  CLRF   x70
05348:  MOVLW  50
0534A:  MOVWF  x6F
0534C:  MOVLW  09
0534E:  MOVWF  x71
05350:  MOVLB  0
05352:  BRA    4B60
05354:  MOVFF  01,166
....................          if (HTTPSocket!=INVALID_SOCKET) { 
05358:  MOVLB  1
0535A:  MOVF   x66,W
0535C:  SUBLW  FE
0535E:  BZ    5390
....................             printf("\r\nHTTP: Listening"); 
05360:  MOVLW  BE
05362:  MOVWF  FF6
05364:  MOVLW  00
05366:  MOVWF  FF7
05368:  MOVLW  00
0536A:  MOVWF  FF8
0536C:  MOVLB  0
0536E:  CALL   0332
....................             state=HTTP_ST_WAIT_CONNECT; 
05372:  MOVLW  01
05374:  MOVLB  1
05376:  MOVWF  x67
....................             timeout_counter=TickGet(); 
05378:  MOVLB  0
0537A:  CALL   0E34
0537E:  MOVFF  03,16B
05382:  MOVFF  02,16A
05386:  MOVFF  01,169
0538A:  MOVFF  00,168
0538E:  MOVLB  1
....................          } 
....................          break; 
05390:  BRA    55F2
....................  
....................       case HTTP_ST_WAIT_CONNECT: 
....................          timeout_counter=TickGet(); 
05392:  CALL   0E34
05396:  MOVFF  03,16B
0539A:  MOVFF  02,16A
0539E:  MOVFF  01,169
053A2:  MOVFF  00,168
....................          if (TCPIsConnected(HTTPSocket)) { 
053A6:  MOVFF  166,26A
053AA:  CALL   4B32
053AE:  MOVF   01,F
053B0:  BZ    53CA
....................             state=HTTP_ST_GET; 
053B2:  MOVLW  02
053B4:  MOVLB  1
053B6:  MOVWF  x67
....................             printf("\r\nHTTP: Connected"); 
053B8:  MOVLW  D0
053BA:  MOVWF  FF6
053BC:  MOVLW  00
053BE:  MOVWF  FF7
053C0:  MOVLW  00
053C2:  MOVWF  FF8
053C4:  MOVLB  0
053C6:  CALL   0332
....................          } 
....................          break; 
053CA:  MOVLB  1
053CC:  BRA    55F2
....................  
....................       case HTTP_ST_GET: 
....................          if (TCPIsGetReady(HTTPSocket)) { 
053CE:  MOVFF  166,26F
053D2:  RCALL  4D3C
053D4:  MOVF   01,W
053D6:  IORWF  02,W
053D8:  BZ    5422
....................             while (TCPGet(HTTPSocket, &c)) { 
053DA:  MOVFF  166,26A
053DE:  MOVLW  01
053E0:  MOVLB  2
053E2:  MOVWF  x6C
053E4:  MOVLW  6E
053E6:  MOVWF  x6B
053E8:  MOVLB  0
053EA:  BRA    4DBC
053EC:  MOVF   01,F
053EE:  BZ    5422
....................                if ( (c=='\n') && (lc2=='\n') ) { 
053F0:  MOVLB  1
053F2:  MOVF   x6E,W
053F4:  SUBLW  0A
053F6:  BNZ   5416
053F8:  MOVF   x6D,W
053FA:  SUBLW  0A
053FC:  BNZ   5416
....................                   state=HTTP_ST_PUT; 
053FE:  MOVLW  03
05400:  MOVWF  x67
....................                   printf("\r\nHTTP: Got Page Request"); 
05402:  MOVLW  E2
05404:  MOVWF  FF6
05406:  MOVLW  00
05408:  MOVWF  FF7
0540A:  MOVLW  00
0540C:  MOVWF  FF8
0540E:  MOVLB  0
05410:  CALL   0332
05414:  MOVLB  1
....................                } 
....................                lc2=lc; 
05416:  MOVFF  16C,16D
....................                lc=c; 
0541A:  MOVFF  16E,16C
0541E:  MOVLB  0
05420:  BRA    53DA
....................             } 
....................          } 
....................          break; 
05422:  MOVLB  1
05424:  BRA    55F2
....................  
....................       case HTTP_ST_PUT: 
....................          if (TCPIsPutReady(HTTPSocket)) { 
05426:  MOVFF  166,274
0542A:  RCALL  4E6C
0542C:  MOVF   01,W
0542E:  IORWF  02,W
05430:  BTFSC  FD8.2
05432:  BRA    55BC
....................             printf("\r\nHTTP: Putting Page Response"); 
05434:  MOVLW  FC
05436:  MOVWF  FF6
05438:  MOVLW  00
0543A:  MOVWF  FF7
0543C:  MOVLW  00
0543E:  MOVWF  FF8
05440:  CALL   0332
....................             a0=read_adc(); 
05444:  BSF    FC2.1
05446:  BTFSC  FC2.1
05448:  BRA    5446
0544A:  MOVFF  FC4,269
....................            #if defined(SECONDARY_ADC_CHANNEL) 
....................             set_adc_channel(SECONDARY_ADC_CHANNEL); 
....................             delay_us(20); 
....................             a1=read_adc(); 
....................             set_adc_channel(STANDARD_ADC_CHANNEL); 
....................            #endif 
....................             sprintf(content, "<HTML><HEAD><TITLE>PICNET</TITLE></HEAD><BODY><H1>HELLO</H1>"); 
0544E:  MOVLW  01
05450:  MOVLB  1
05452:  MOVWF  x65
05454:  MOVLW  6F
05456:  MOVWF  x64
05458:  MOVLW  1A
0545A:  MOVWF  FF6
0545C:  MOVLW  01
0545E:  MOVWF  FF7
05460:  MOVLW  00
05462:  MOVWF  FF8
05464:  MOVLB  0
05466:  RCALL  4F3C
....................             sprintf(&content[0]+strlen(content),"<P>%s = 0x%X", STANDARD_ADC_STRING, a0); 
05468:  MOVLW  01
0546A:  MOVLB  2
0546C:  MOVWF  x6B
0546E:  MOVLW  6F
05470:  MOVWF  x6A
05472:  MOVLB  0
05474:  RCALL  4F64
05476:  MOVLW  6F
05478:  ADDWF  01,W
0547A:  MOVLB  2
0547C:  MOVWF  x6A
0547E:  MOVLW  01
05480:  MOVWF  x6B
05482:  BTFSC  FD8.0
05484:  INCF   x6B,F
05486:  MOVFF  26B,165
0548A:  MOVFF  26A,164
0548E:  MOVLW  58
05490:  MOVWF  FF6
05492:  MOVLW  01
05494:  MOVWF  FF7
05496:  MOVLW  00
05498:  MOVWF  FF8
0549A:  MOVLW  03
0549C:  MOVWF  x6C
0549E:  MOVLB  0
054A0:  RCALL  4F9E
054A2:  MOVLW  66
054A4:  MOVWF  FF6
054A6:  MOVLW  01
054A8:  MOVWF  FF7
054AA:  MOVLW  00
054AC:  MOVWF  FF8
054AE:  RCALL  4F3C
054B0:  MOVLW  5D
054B2:  MOVWF  FF6
054B4:  MOVLW  01
054B6:  MOVWF  FF7
054B8:  MOVLW  00
054BA:  MOVWF  FF8
054BC:  MOVLW  05
054BE:  MOVLB  2
054C0:  MOVWF  x6C
054C2:  MOVLB  0
054C4:  RCALL  4F9E
054C6:  MOVFF  269,26C
054CA:  MOVLW  37
054CC:  MOVLB  2
054CE:  MOVWF  x6D
054D0:  MOVLB  0
054D2:  BRA    4FCE
....................            #if defined(SECONDARY_ADC_CHANNEL) 
....................             sprintf(&content[0]+strlen(content),"<BR>%s = 0x%X", SECONDARY_ADC_STRING, a1); 
....................            #endif 
....................             sprintf(&content[0]+strlen(content),"</BODY></HTML>"); 
054D4:  MOVLW  01
054D6:  MOVLB  2
054D8:  MOVWF  x6B
054DA:  MOVLW  6F
054DC:  MOVWF  x6A
054DE:  MOVLB  0
054E0:  RCALL  4F64
054E2:  MOVLW  6F
054E4:  ADDWF  01,W
054E6:  MOVLB  2
054E8:  MOVWF  x6A
054EA:  MOVLW  01
054EC:  MOVWF  x6B
054EE:  BTFSC  FD8.0
054F0:  INCF   x6B,F
054F2:  MOVFF  26B,165
054F6:  MOVFF  26A,164
054FA:  MOVLW  6A
054FC:  MOVWF  FF6
054FE:  MOVLW  01
05500:  MOVWF  FF7
05502:  MOVLW  00
05504:  MOVWF  FF8
05506:  MOVLB  0
05508:  RCALL  4F3C
....................             printf(HTTPPut, "HTTP/1.1 200 OK\r\n"); 
0550A:  MOVLW  7A
0550C:  MOVWF  FF6
0550E:  MOVLW  01
05510:  MOVWF  FF7
05512:  MOVLW  00
05514:  MOVWF  FF8
05516:  RCALL  5184
....................             printf(HTTPPut, "Content-Type: text/html\r\n"); 
05518:  MOVLW  8C
0551A:  MOVWF  FF6
0551C:  MOVLW  01
0551E:  MOVWF  FF7
05520:  MOVLW  00
05522:  MOVWF  FF8
05524:  RCALL  5184
....................             printf(HTTPPut, "Content-Length: %u\r\n",strlen(content)); 
05526:  MOVLW  01
05528:  MOVLB  2
0552A:  MOVWF  x6B
0552C:  MOVLW  6F
0552E:  MOVWF  x6A
05530:  MOVLB  0
05532:  RCALL  4F64
05534:  MOVFF  01,26A
05538:  MOVLW  A6
0553A:  MOVWF  FF6
0553C:  MOVLW  01
0553E:  MOVWF  FF7
05540:  MOVLW  00
05542:  MOVWF  FF8
05544:  MOVLW  10
05546:  MOVLB  2
05548:  MOVWF  x6B
0554A:  MOVLB  0
0554C:  BRA    51AC
0554E:  MOVFF  26A,26B
05552:  MOVLW  1B
05554:  MOVLB  2
05556:  MOVWF  x6C
05558:  MOVLB  0
0555A:  BRA    520A
0555C:  MOVLW  0D
0555E:  MOVLB  2
05560:  MOVWF  x6F
05562:  MOVLB  0
05564:  RCALL  5178
05566:  MOVLW  0A
05568:  MOVLB  2
0556A:  MOVWF  x6F
0556C:  MOVLB  0
0556E:  RCALL  5178
....................             printf(HTTPPut, "\r\n"); 
05570:  MOVLW  0D
05572:  MOVLB  2
05574:  MOVWF  x6F
05576:  MOVLB  0
05578:  RCALL  5178
0557A:  MOVLW  0A
0557C:  MOVLB  2
0557E:  MOVWF  x6F
05580:  MOVLB  0
05582:  RCALL  5178
....................             printf(HTTPPut, "%s", content); 
05584:  MOVLW  01
05586:  MOVWF  FEA
05588:  MOVLW  6F
0558A:  MOVWF  FE9
0558C:  BRA    5288
....................             printf("\r\nHTTP: Flushing..."); 
0558E:  MOVLW  BC
05590:  MOVWF  FF6
05592:  MOVLW  01
05594:  MOVWF  FF7
05596:  MOVLW  00
05598:  MOVWF  FF8
0559A:  CALL   0332
....................             TCPFlush(HTTPSocket); 
0559E:  MOVFF  166,274
055A2:  RCALL  5016
....................             printf("\r\nHTTP: Flushed!"); 
055A4:  MOVLW  D0
055A6:  MOVWF  FF6
055A8:  MOVLW  01
055AA:  MOVWF  FF7
055AC:  MOVLW  00
055AE:  MOVWF  FF8
055B0:  CALL   0332
....................             state=HTTP_ST_GET; 
055B4:  MOVLW  02
055B6:  MOVLB  1
055B8:  MOVWF  x67
055BA:  MOVLB  0
....................          } 
....................          break; 
055BC:  MOVLB  1
055BE:  BRA    55F2
....................  
....................       case HTTP_ST_DISCONNECT: 
....................          if (TCPIsPutReady(HTTPSocket)) { 
055C0:  MOVFF  166,274
055C4:  RCALL  4E6C
055C6:  MOVF   01,W
055C8:  IORWF  02,W
055CA:  BZ    55EC
....................             printf("\r\nHTTP: Force Disconnect"); 
055CC:  MOVLW  E2
055CE:  MOVWF  FF6
055D0:  MOVLW  01
055D2:  MOVWF  FF7
055D4:  MOVLW  00
055D6:  MOVWF  FF8
055D8:  CALL   0332
....................             TCPDisconnect(HTTPSocket); 
055DC:  MOVFF  166,26A
055E0:  CALL   1DCC
....................             state=HTTP_ST_WAIT_CONNECT; 
055E4:  MOVLW  01
055E6:  MOVLB  1
055E8:  MOVWF  x67
055EA:  MOVLB  0
....................          } 
....................          break; 
055EC:  MOVLB  1
055EE:  BRA    55F2
055F0:  MOVLB  1
....................    } 
055F2:  MOVLB  0
055F4:  GOTO   572A (RETURN)
.................... } 
....................  
.................... void main(void)  
*
0562C:  CLRF   FF8
0562E:  BCF    FD0.7
05630:  BSF    07.7
05632:  MOVLW  7E
05634:  MOVWF  00
05636:  MOVLW  0F
05638:  MOVWF  01
0563A:  MOVLW  02
0563C:  MOVWF  FE9
0563E:  MOVLW  00
05640:  MOVWF  FEA
05642:  CLRF   FEE
05644:  DECFSZ 00,F
05646:  BRA    5642
05648:  DECFSZ 01,F
0564A:  BRA    5642
0564C:  CLRF   17
0564E:  BSF    F7E.3
05650:  MOVLW  3C
05652:  MOVWF  FAF
05654:  MOVLW  04
05656:  MOVWF  F7F
05658:  MOVLW  A6
0565A:  MOVWF  FAC
0565C:  MOVLW  90
0565E:  MOVWF  FAB
05660:  BCF    x68.0
05662:  MOVLW  41
05664:  MOVWF  x6C
05666:  MOVLW  FE
05668:  MOVWF  x6B
0566A:  MOVLW  9F
0566C:  MOVWF  x6A
0566E:  MOVLW  9E
05670:  MOVWF  x69
05672:  CLRF   x74
05674:  CLRF   x73
05676:  CLRF   x72
05678:  CLRF   x71
0567A:  CLRF   x83
0567C:  CLRF   x82
0567E:  BCF    x68.1
05680:  MOVLW  FE
05682:  MOVWF  xDE
05684:  MOVLB  1
05686:  MOVWF  x37
05688:  CLRF   x65
0568A:  CLRF   x64
0568C:  MOVWF  x66
0568E:  CLRF   x67
05690:  MOVF   FC1,W
05692:  ANDLW  C0
05694:  MOVWF  FC1
05696:  MOVLW  07
05698:  MOVWF  FB4
0569A:  BRA    56CA
0569C:  DATA 04,01
0569E:  DATA 44,45
056A0:  DATA 00,00
056A2:  DATA 20,04
056A4:  DATA C0,00
056A6:  DATA 18,80
056A8:  DATA 64,11
056AA:  DATA 2A,9D
056AC:  DATA 0A,0B
056AE:  DATA 0C,0D
056B0:  DATA 0A,0B
056B2:  DATA 0C,0E
056B4:  DATA 04,00
056B6:  DATA 04,01
056B8:  DATA 00,0C
056BA:  DATA 00,00
056BC:  DATA 01,02
056BE:  DATA 03,04
056C0:  DATA 06,00
056C2:  DATA 24,09
056C4:  DATA 00,F4
056C6:  DATA 01,F4
056C8:  DATA 01,00
056CA:  MOVLW  00
056CC:  MOVWF  FF8
056CE:  MOVLW  56
056D0:  MOVWF  FF7
056D2:  MOVLW  9C
056D4:  MOVWF  FF6
056D6:  TBLRD*+
056D8:  MOVF   FF5,W
056DA:  MOVWF  00
056DC:  XORLW  00
056DE:  BZ    5706
056E0:  TBLRD*+
056E2:  MOVF   FF5,W
056E4:  MOVWF  01
056E6:  BTFSC  FE8.7
056E8:  BRA    56F4
056EA:  ANDLW  0F
056EC:  MOVWF  FEA
056EE:  TBLRD*+
056F0:  MOVFF  FF5,FE9
056F4:  BTFSC  01.6
056F6:  TBLRD*+
056F8:  BTFSS  01.6
056FA:  TBLRD*+
056FC:  MOVFF  FF5,FEE
05700:  DCFSNZ 00,F
05702:  BRA    56D6
05704:  BRA    56F8
05706:  CLRF   FF8
.................... { 
....................    Init(); 
05708:  MOVLB  0
0570A:  GOTO   0322
....................     
....................    printf("\r\n\nCCS TCP/IP TUTORIAL, EXAMPLE 14 (HTTP SERVER)\r\n"); 
0570E:  MOVLW  FC
05710:  MOVWF  FF6
05712:  MOVLW  01
05714:  MOVWF  FF7
05716:  MOVLW  00
05718:  MOVWF  FF8
0571A:  CALL   0332
....................  
....................    //lcd_init(); 
....................  
....................    //printf(lcd_putc, "\fInit Stack..."); 
....................  
....................    StackInit(); 
0571E:  GOTO   0DC0
....................     
....................   #if STACK_USE_WIFI 
....................    WIFIConnectTask(); 
....................   #endif 
....................  
....................    while(TRUE)  
....................    { 
....................       restart_wdt(); 
05722:  CLRWDT
....................  
....................       //LCDTask(); 
....................  
....................       StackTask(); 
05724:  GOTO   49F8
....................  
....................      #if STACK_USE_WIFI 
....................       WIFIConnectTask();   //uses hardcoded ap/router info 
....................  
....................       //don't attempt anything else TCP/IP related if not connected. 
....................       if (!MyWFisConnected()) 
....................          continue; 
....................      #endif 
....................        
....................       HTTPTask(); 
05728:  BRA    52AE
0572A:  BRA    5722
....................    } 
.................... } 
0572C:  SLEEP 

Configuration Fuses:
   Word  1: F4A0   NOWDT STVREN NOXINST NODEBUG NOPROTECT
   Word  2: FF05   H4_SW PRIMARY NOFCMEN NOIESO WDT32768
   Word  3: F7F8   ETHLED
