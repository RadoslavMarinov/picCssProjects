CCS PCH C Compiler, Version 5.015, 5967               11-май-14 19:22

               Filename:   D:\Projects\PIC18F4620_ENC28J60\CCS\ex13\ex13.lst

               ROM used:   33342 bytes (51%)
                           Largest free fragment is 32190
               RAM used:   580 (15%) at main() level
                           748 (19%) worst case
               Stack used: 11 locations (9 in main + 2 for interrupts)
               Stack size: 31

*
00000:  GOTO   810E
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  00,0E
0003C:  MOVFF  01,0F
00040:  MOVFF  02,10
00044:  MOVFF  03,11
00048:  BTFSS  FF2.5
0004A:  GOTO   0054
0004E:  BTFSC  FF2.2
00050:  GOTO   00B4
00054:  MOVFF  0E,00
00058:  MOVFF  0F,01
0005C:  MOVFF  10,02
00060:  MOVFF  11,03
00064:  MOVFF  0C,FE9
00068:  MOVFF  07,FEA
0006C:  BSF    07.7
0006E:  MOVFF  08,FE1
00072:  MOVFF  09,FE2
00076:  MOVFF  0A,FD9
0007A:  MOVFF  0B,FDA
0007E:  MOVFF  12,FF3
00082:  MOVFF  13,FF4
00086:  MOVFF  14,FFA
0008A:  MOVF   04,W
0008C:  MOVFF  06,FE0
00090:  MOVFF  05,FD8
00094:  RETFIE 0
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // ex13.c - Example 13 from the Embedded Internet/Embedded Ethernet tutorial 
.................... // 
.................... // A TCP example, where the PIC acts as a TCP client.  Connects to a PC running 
.................... // the CCS provided example program TCPSERVER.EXE.  TCPSERVER.EXE listens to 
.................... // port 1000 for TCP connections. 
.................... // 
.................... // NOTE: You MUST change the code in ServerAddrInit() to specify the IP address 
.................... //       of the PC running TCPSERVER.EXE 
.................... // 
.................... // NOTE: Change the code in IPAddrInit() to your desired IP address, which 
.................... //       is based on your network. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // force enabling of LCD library.  if hardware doesn't have LCD hardware, 
.................... // then it will use RS232/Serial for lcd_putc(). 
.................... #define STACK_USE_PICDEM_LCD 1 
....................  
.................... #define STACK_USE_ICMP_SERVER 
.................... #define STACK_USE_TCP 
.................... #define STACK_USE_DNS 
....................  
.................... // configure TCP stack to tell it how much space to save in NIC RAM for 
.................... // TCP packets - used to retry packet if it gets no ACK. 
.................... // we are using default TCPSocketInitializer[] in TCPIPConfig.h, which 
.................... // has one socket requiring 250 bytes tx and 250 bytes rx. 
.................... // it also needs around ~50 more bytes per socket on top of the tx and rx 
.................... // reserved bytes. 
.................... //CHECK TCPIPConfig.h for information on TCP Sockets. 
.................... #define TCP_ETH_RAM_SIZE   550 
....................  
.................... // this is the IP address of the PC running the TCPSERVER.EXE software. 
.................... // if you have a valid DNS server, this can be a hostname. 
.................... #define MY_DEST_SERVER  "192.168.100.145" 
....................  
.................... #include "ccstcpip.h" 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // ccstcpip.h - Common code shared among all Embedded Internet/Embedded 
.................... // Ethernet tutorial book examples. 
.................... // 
.................... // If you are using a CCS Embedded Ethernet Board (labeled PICENS, which 
.................... // has an MCP ENC28J60) then define STACK_USE_CCS_PICENS to TRUE. 
.................... // 
.................... // If you are using a CCS Embedded Internet Board (labeled PICNET, which 
.................... // has a Realtek RTL8019AS and a 56K Modem) then define STACK_USE_CCS_PICNET 
.................... // to TRUE. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // 10/25/06 
.................... //  - Added STACK_USE_CCS_PICEEC 
.................... //  - ExamplePacket[] UDP header length fixed 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #define STACK_USE_CCS_EWLWIFIB      0 //18f67k22 + mrf24wb0m 
.................... #define STACK_USE_CCS_EWLWIFIG      0 //18f67k22 + mrf24wg0m 
.................... #define STACK_USE_CCS_PICEEC        0 //18f67j60 
.................... #define STACK_USE_CCS_PICENS        1 //18f4620 + enc28j60 
.................... #define STACK_USE_PIC24FJGA110_ENC28     0 //explorer 16, PIC24FJ256GA110, ENC28J60.  unfortunately with this combinatin you cannot use ENC28J60 and 25LC256 at same time 
.................... #define STACK_USE_PIC24FJGA010_ENC28     0 //explorer 16, PIC24FJ128GA010, ENC28J60. 
.................... #define STACK_USE_CCS_EWL5V_REV5    0 //ezWebLynx 5V (REV5), 18f67k22 + enc28j60 
.................... #define STACK_USE_CCS_EWL3V         0 //ezWebLynx 3V, 18f67j60 
.................... //#define STACK_USE_CCS_PICNET        0 //18f6722 + realtek 
....................  
.................... #define STACK_IS_CCS_EXAMPLE 
....................  
.................... /* not working right now 
.................... #define STACK_USE_CCS_PICNET        0 //18f6722 + realtek 
.................... #define STACK_USE_CCS_EWL5V         0 //ezWebLynx 5V 
.................... #define STACK_USE_CCS_EWL5V_REV2    0 //ezWebLynx 5V (REV2) 
.................... */ 
....................  
.................... #if STACK_USE_CCS_EWLWIFIB || STACK_USE_CCS_EWLWIFIG 
....................    #define WF_DEBUG  
....................    #define STACK_USE_WIFI 1 
....................    #if STACK_USE_CCS_EWLWIFIG 
....................       #define MRF24WG 
....................    #endif 
.................... #else 
....................    #define STACK_USE_WIFI 0 
.................... #endif 
....................  
.................... #define LCD_EXTENDED_NEWLINE  //configuration for lcd.c driver/library 
....................   
.................... #if STACK_USE_CCS_EWLWIFIB || STACK_USE_CCS_EWLWIFIG 
....................    #include <18F67K22.h> 
....................    #device HIGH_INTS = TRUE 
....................    #include "tcpip\p18cxxx.h" 
....................     
....................    #reserve 0xF16:0xFFF   //SFR 
....................    #use delay(clock=64M, XTAL=16M) 
....................     
....................    //took out fuses 12/13/11 
....................    //#fuses HSH 
....................    //#fuses PLLEN 
....................    //#fuses MCLR 
....................     
....................    #use rs232(baud=9600, uart1, stream=STREAM_UI, errors) 
....................  
....................    #define wf_debug_printf printf 
....................    void wf_debug_putc(char c) {putc(c);} 
....................  
....................    void lcd_putc(char c) 
....................    { 
....................      #if STACK_USE_PICDEM_LCD 
....................        if (c == '\f') 
....................          printf("\r\n\n"); 
....................        else 
....................          putc(c); 
....................      #endif 
....................    } 
....................    #define lcd_init() 
....................    #ifndef STACK_USE_PICDEM_LCD 
....................       #define STACK_USE_PICDEM_LCD 0   // no hardware LCD support 
....................    #endif 
....................      
....................    #define LED_ON       output_high 
....................    #define LED_OFF      output_low 
....................    #define USER_LED1    PIN_G3                 //input1 
....................    #define USER_LED2    PIN_G4                 //input2 
....................    #define USER_LED3    PIN_F3                 //input3 
....................    #define STANDARD_ADC_STRING  "AN9" 
....................    #define STANDARD_ADC_CHANNEL 9              //input4 
....................    #define BUTTON1_PRESSED() (input(PIN_F5))   //input5 
....................    #define BUTTON2_PRESSED() (input(PIN_A5))   //input6 
....................  
....................    // more gpio / hardware definitions hiding in HardwareProfile.h 
....................  
....................    // macros used by CCS's WIFIConnectTask() 
....................    #define LED_WIFI  PIN_E0 
....................    #define LED_CONNECTION_ON()   output_drive(LED_WIFI);   output_high(LED_WIFI) 
....................    #define LED_CONNECTION_OFF()   output_drive(LED_WIFI);   output_low(LED_WIFI) 
....................     
....................    void init_user_io(void) 
....................    { 
....................       setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_2); 
....................       setup_adc_ports(sAN9); 
....................       set_adc_channel(STANDARD_ADC_CHANNEL); 
....................        
....................       output_drive(USER_LED1); 
....................       output_drive(USER_LED2); 
....................       output_float(PIN_G4); 
....................       output_float(PIN_G3); 
....................       LED_OFF(USER_LED1); 
....................       LED_OFF(USER_LED2); 
....................       LED_CONNECTION_OFF(); 
....................    } 
....................           
....................    #define __AT45DB_D__ 
....................    #define FLASH_SELECT PIN_D2 
....................    #define FLASH_CLOCK  PIN_D6 
....................    #define FLASH_DI     PIN_D4 
....................    #define FLASH_DO     PIN_D5 
....................    #define FLASH_BUFFER_SIZE    264 
....................    #define FLASH_BUFFER_COUNT   4096 
....................    #include "at45db.c"  
....................        
....................    #define __SPIFLASH_H    //prevent spiflash.h from being loaded/used 
....................    #define SPIFlashReadArray(dwAddress, pData, wLen)  ext_flash_read(dwAddress, pData, wLen) 
....................    #define SPIFlashInit()                             init_ext_flash() 
....................    #define SPIFlashBeginWrite(addy)                   ext_flash_startWrite(addy) 
....................    #define SPIFlashWrite(d)                           ext_flash_continuousWrite(d) 
....................    #define SPIFlashStopWrite()                        ext_flash_flushWrites() 
....................    #define SPIFlashWriteBytes(dwAddress, pData, wLen) ext_flash_writeBytes(dwAddress, pData, wLen) 
....................     
....................    // if you want TCP/IP settings saved to internal EEPROM, then comment 
....................    // out the next few lines: 
....................    #define EEInit SPIFlashInit 
....................    #define EEReadBytes(dst, src, len)  SPIFlashReadArray(src, dst, len) 
....................    #define EEWriteBytes(dst, src, len) SPIFlashWriteBytes(dst, src, len) 
....................     
.................... #elif STACK_USE_PIC24FJGA010_ENC28 
....................    #include <24FJ128GA010.h> 
....................    //#device ICD=TRUE 
....................    #device ADC=8 
....................    #include "tcpip\p24fxxxx.h"   //C30 to CCS compatability layer 
....................    #use delay(clock=32MHz) 
....................    #fuses PR_PLL, XT                 //cw2 
....................    #fuses NOWDT, NOJTAG             //cw1 
....................     
....................    //pin_f13 = rts 
....................    //pin_f12 = cts 
....................    #use rs232(baud=9600, uart2, stream=STREAM_UI, errors) 
....................     
....................    #define BUTTON1_PRESSED()  (!input(PIN_D6))  //marked S3 on PCB 
....................    #define USER_LED1    PIN_A0   //marked D3 on PCB 
....................    #define USER_LED2    PIN_A1   //marked D4 on PCB 
....................    #define USER_LED3    PIN_A2   //marked D5 on PCB 
....................    #define LED_ON       output_high 
....................    #define LED_OFF      output_low 
....................    #define STANDARD_ADC_STRING  "AN5" 
....................    #define STANDARD_ADC_CHANNEL 5   //rb5/an5 
....................         
....................    #define LCD_ENABLE_PIN  PIN_D4 
....................    #define LCD_RS_PIN      PIN_B15 
....................    #define LCD_RW_PIN      PIN_D5 
....................    #define LCD_DATA4       PIN_E4 
....................    #define LCD_DATA5       PIN_E5 
....................    #define LCD_DATA6       PIN_E6 
....................    #define LCD_DATA7       PIN_E7 
....................     
....................    #ifndef STACK_USE_PICDEM_LCD 
....................       #define STACK_USE_PICDEM_LCD 1 
....................    #endif 
....................    #if STACK_USE_PICDEM_LCD 
....................       #include "lcd.c"    
....................    #endif 
....................    
....................    #define ENC_CS_IO       LATDbits.LATD14 
....................    #define ENC_CS_TRIS     TRISDbits.TRISD14 
....................    #define ENC_RST_IO      LATDbits.LATD15 
....................    #define ENC_RST_TRIS    TRISDbits.TRISD15 
....................    #define ENC_SPI_IF         IFS0bits.SPI1IF 
....................    #define ENC_SPICON1        SPI1CON1 
....................    #define ENC_SPICON2        SPI1CON2 
....................    #define ENC_SPISTAT        SPI1STAT 
....................    #define ENC_SSPBUF         SPI1BUF 
....................    #define ENC_SPICON1bits    SPI1CON1bits 
....................    #define ENC_SPICON2bits    SPI1CON2bits 
....................    #define ENC_SPISTATbits    SPI1STATbits 
....................    //!INT pin is RE9/INT2 
....................  
....................    void init_user_io(void)  
....................    { 
....................       setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_2); 
....................       setup_adc_ports(sAN5); 
....................       set_adc_channel(STANDARD_ADC_CHANNEL); 
....................        
....................       output_drive(USER_LED1); 
....................       output_drive(USER_LED2); 
....................       output_drive(USER_LED3); 
....................       LED_OFF(USER_LED1); 
....................       LED_OFF(USER_LED2); 
....................       LED_OFF(USER_LED3); 
....................    } 
....................    // 25LC256 
.................... //#define debug_ee  printf 
.................... //void debug_ee_putc(char c) {putc(c);} 
....................    #define EEPROM_SELECT PIN_D12 
....................    #define EEPROM_CLK    PIN_G6 
....................    #define EEPROM_DI     PIN_G7 
....................    #define EEPROM_DO     PIN_G8 
....................    #include "25lc256.c" 
....................     
....................    #define __SPIFLASH_H    //prevent spiflash.h from being loaded/used 
....................    #define SPIFlashReadArray(dwAddress, pData, wLen)  read_ext_eeprom_bytes(pData, dwAddress, wLen) 
....................    #define SPIFlashInit()                             init_ext_eeprom() 
....................    EEPROM_ADDRESS g_SpiFlashCurrWrite; 
....................    #define SPIFlashBeginWrite(addy)                   g_SpiFlashCurrWrite=addy 
....................    #define SPIFlashWrite(d)                           write_ext_eeprom(g_SpiFlashCurrWrite++, d) 
....................    #define SPIFlashStopWrite() 
....................    #define SPIFlashWriteBytes(dwAddress, pData, wLen) write_ext_eeprom_bytes(dwAddress, pData, wLen) 
....................     
....................    // if you want TCP/IP settings saved to internal EEPROM, then comment 
....................    // out the next few lines: 
....................    #define EEInit SPIFlashInit 
....................    #define EEReadBytes(dst, src, len)  SPIFlashReadArray(src, dst, len) 
....................    #define EEWriteBytes(dst, src, len) SPIFlashWriteBytes(dst, src, len); SPIFlashStopWrite() 
....................     
....................     
.................... #elif STACK_USE_PIC24FJGA110_ENC28 
....................    #include <24FJ256GA110.h> 
....................    //#device ICD=TRUE 
....................    #device ADC=8 
....................    #include "tcpip\p24fxxxx.h" 
....................    #use delay(clock=32MHz) 
....................    #fuses PR_PLL, XT                 //cw2 
....................    #fuses NOWDT, NOJTAG, ICSP2      //cw1 
....................     
....................    #pin_select U2TX=PIN_F5 
....................    #pin_select U2RX=PIN_F4 
....................    //pin_f13 = rts 
....................    //pin_f12 = cts 
....................    #use rs232(baud=9600, uart2, stream=STREAM_UI, errors) 
....................     
....................    #define BUTTON1_PRESSED()  (!input(PIN_D6))  //marked S3 on PCB 
....................    #define USER_LED1    PIN_A0   //marked D3 on PCB 
....................    #define USER_LED2    PIN_A1   //marked D4 on PCB 
....................    #define USER_LED3    PIN_A2   //marked D5 on PCB 
....................    #define LED_ON       output_high 
....................    #define LED_OFF      output_low 
....................    #define STANDARD_ADC_STRING  "AN5" 
....................    #define STANDARD_ADC_CHANNEL 5   //rb5/an5 
....................         
....................    #define LCD_ENABLE_PIN  PIN_D4 
....................    #define LCD_RS_PIN      PIN_B15 
....................    #define LCD_RW_PIN      PIN_D5 
....................    #define LCD_DATA4       PIN_E4 
....................    #define LCD_DATA5       PIN_E5 
....................    #define LCD_DATA6       PIN_E6 
....................    #define LCD_DATA7       PIN_E7 
....................     
....................    #ifndef STACK_USE_PICDEM_LCD 
....................       #define STACK_USE_PICDEM_LCD 1 
....................    #endif 
....................    #if STACK_USE_PICDEM_LCD 
....................       #include "lcd.c"    
....................    #endif 
....................    
....................    // When using 24FJ256GA110, due to an errata with SPI1 we must use SPI2. 
....................    // so when inserting the ENC28J60 PICTail into the Explorer 16, insert 
....................    // it into the second slot.  The definitions below are for the second 
....................    // slot. 
....................    //ENC28J60 INT is mapped to RA15, but not used by software 
....................    #pin_select SDO2=PIN_G8 
....................    #pin_select SDI2=PIN_G7 
....................    #pin_select SCK2OUT=PIN_G6 
....................    #define ENC_CS_IO       LATFbits.LATF12    
....................    #define ENC_CS_TRIS     TRISFbits.TRISF12 
....................    #define ENC_RST_IO      LATFbits.LATF13 
....................    #define ENC_RST_TRIS    TRISFbits.TRISF13 
....................    #define ENC_SPI_IF         IFS2bits.SPI2IF 
....................    #define ENC_SPICON1        SPI2CON1 
....................    #define ENC_SPICON2        SPI2CON2 
....................    #define ENC_SPISTAT        SPI2STAT 
....................    #define ENC_SSPBUF         SPI2BUF 
....................    #define ENC_SPICON1bits    SPI2CON1bits 
....................    #define ENC_SPICON2bits    SPI2CON2bits 
....................    #define ENC_SPISTATbits    SPI2STATbits 
....................  
....................    void init_user_io(void)  
....................    { 
....................       setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_2); 
....................       setup_adc_ports(sAN5); 
....................       set_adc_channel(STANDARD_ADC_CHANNEL); 
....................        
....................       output_drive(USER_LED1); 
....................       output_drive(USER_LED2); 
....................       output_drive(USER_LED3); 
....................       LED_OFF(USER_LED1); 
....................       LED_OFF(USER_LED2); 
....................       LED_OFF(USER_LED3); 
....................    } 
....................  
.................... #elif STACK_USE_CCS_PICEEC 
....................    #include <18F67J60.h> 
....................    #include "tcpip\p18cxxx.h" 
....................    #reserve 0xE80:0xEFF   //SFR 
....................    #reserve 0xF00:0xFFF   //SFR 
....................    #use delay(clock=41666667) 
....................    #fuses NOWDT, NODEBUG, H4_SW, NOIESO, NOFCMEN, PRIMARY, ETHLED 
....................     
....................    #use rs232(baud=9600, uart1, stream=STREAM_UI, errors) 
....................        
....................    //#include "tcpip/elcd.c" //removed, use standard lcd.c that has #define'able pins 
....................    #define BUTTON1_PRESSED()  (!input(PIN_A4)) 
....................    #define USER_LED1    PIN_B3 
....................    #define USER_LED2    PIN_B4 
....................    #define USER_LED3    PIN_B5 
....................    #define LED_ON       output_low 
....................    #define LED_OFF      output_high 
....................    #define STANDARD_ADC_STRING  "AN2" 
....................    #define STANDARD_ADC_CHANNEL 2 
....................  
....................    #define LCD_ENABLE_PIN  PIN_F3 
....................    #define LCD_RS_PIN      PIN_F1 
....................    #define LCD_RW_PIN      PIN_F2 
....................    #define LCD_DATA4       PIN_F4 
....................    #define LCD_DATA5       PIN_F5 
....................    #define LCD_DATA6       PIN_F6 
....................    #define LCD_DATA7       PIN_F7 
....................     
....................    #ifndef STACK_USE_PICDEM_LCD 
....................       #define STACK_USE_PICDEM_LCD 1 
....................    #endif 
....................    #if STACK_USE_PICDEM_LCD 
....................       #include "lcd.c" 
....................    #endif 
....................     
....................    void init_user_io(void)  
....................    { 
....................       setup_oscillator(OSC_PLL_5_DIV_3 | OSC_NORMAL); 
....................       restart_wdt(); 
....................       delay_ms(144); 
....................       restart_wdt(); 
....................        
....................       setup_adc(ADC_CLOCK_INTERNAL); 
....................       setup_adc_ports(AN0_TO_AN2); 
....................       set_adc_channel(STANDARD_ADC_CHANNEL); 
....................        
....................       setup_comparator(NC_NC_NC_NC); 
....................        
....................       output_drive(PIN_A1);   //ethernet led 
....................       output_drive(PIN_A0);   //ethernet led 
....................        
....................       output_drive(USER_LED1); 
....................       output_drive(USER_LED2); 
....................       output_drive(USER_LED3); 
....................       LED_OFF(USER_LED1); 
....................       LED_OFF(USER_LED2); 
....................       LED_OFF(USER_LED3); 
....................    } 
....................     
....................    #define EEPROM_SELECT   PIN_C1  //o 
....................    #define EEPROM_DI       PIN_C5  //o 
....................    #define EEPROM_DO       PIN_C4  //i 
....................    #define EEPROM_CLK      PIN_C3  //o 
....................    #define EEPROM_USE_SPI  1 
....................    #include "AT25256.C" 
....................  
....................    #define __SPIFLASH_H    //prevent spiflash.h from being loaded/used 
....................    #define SPIFlashReadArray(dwAddress, pData, wLen)  read_ext_eeprom_buf(dwAddress, pData, wLen) 
....................    #define SPIFlashInit()                             init_ext_eeprom() 
....................    EEPROM_ADDRESS g_SpiFlashCurrWrite; 
....................    #define SPIFlashBeginWrite(addy)                   g_SpiFlashCurrWrite=addy 
....................    #define SPIFlashWrite(d)                           write_ext_eeprom(g_SpiFlashCurrWrite++, d) 
....................    #define SPIFlashStopWrite() 
....................    #define SPIFlashWriteBytes(dwAddress, pData, wLen) write_ext_eeprom_buf(dwAddress, pData, wLen) 
....................     
....................    // if you want TCP/IP settings saved to internal EEPROM, then comment 
....................    // out the next few lines: 
....................    #define EEInit SPIFlashInit 
....................    #define EEReadBytes(dst, src, len)  SPIFlashReadArray(src, dst, len) 
....................    #define EEWriteBytes(dst, src, len) SPIFlashWriteBytes(dst, src, len); SPIFlashStopWrite() 
....................  
.................... #elif STACK_USE_CCS_PICENS 
....................    #include <18F4620.h> 
.................... //////////// Standard Header file for the PIC18F4620 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4620 
*
000BA:  DATA 0A,0D
000BC:  DATA 53,4F
000BE:  DATA 43,4B
000C0:  DATA 45,54
000C2:  DATA 20,41
000C4:  DATA 43,54
000C6:  DATA 49,56
000C8:  DATA 45,00
000CA:  DATA 42,55
000CC:  DATA 54,54
000CE:  DATA 4F,4E
000D0:  DATA 20,43
000D2:  DATA 3D,25
000D4:  DATA 55,00
000D6:  DATA 0C,43
000D8:  DATA 4F,4E
000DA:  DATA 4E,45
000DC:  DATA 43,54
000DE:  DATA 49,4E
000E0:  DATA 47,20
000E2:  DATA 54,4F
000E4:  DATA 0A,0D
000E6:  DATA 25,73
000E8:  DATA 00,00
000EA:  DATA 0C,53
000EC:  DATA 4F,43
000EE:  DATA 4B,45
000F0:  DATA 54,20
000F2:  DATA 45,52
000F4:  DATA 52,4F
000F6:  DATA 52,00
000F8:  DATA 0C,43
000FA:  DATA 4F,4E
000FC:  DATA 4E,45
000FE:  DATA 43,54
00100:  DATA 45,44
00102:  DATA 20,54
00104:  DATA 4F,0A
00106:  DATA 0D,25
00108:  DATA 73,00
0010A:  DATA 0C,44
0010C:  DATA 49,53
0010E:  DATA 43,4F
00110:  DATA 4E,4E
00112:  DATA 45,43
00114:  DATA 54,45
00116:  DATA 44,00
00118:  DATA 0C,44
0011A:  DATA 49,53
0011C:  DATA 43,4F
0011E:  DATA 4E,4E
00120:  DATA 45,43
00122:  DATA 54,20
00124:  DATA 46,52
00126:  DATA 4F,4D
00128:  DATA 0A,0D
0012A:  DATA 25,73
0012C:  DATA 00,00
0012E:  DATA 0D,0A
00130:  DATA 0A,43
00132:  DATA 43,53
00134:  DATA 20,54
00136:  DATA 43,50
00138:  DATA 2F,49
0013A:  DATA 50,20
0013C:  DATA 54,55
0013E:  DATA 54,4F
00140:  DATA 52,49
00142:  DATA 41,4C
00144:  DATA 2C,20
00146:  DATA 45,58
00148:  DATA 41,4D
0014A:  DATA 50,4C
0014C:  DATA 45,20
0014E:  DATA 31,33
00150:  DATA 20,28
00152:  DATA 54,43
00154:  DATA 50,20
00156:  DATA 43,4C
00158:  DATA 49,45
0015A:  DATA 4E,54
0015C:  DATA 29,0D
0015E:  DATA 0A,00
00160:  DATA 0C,43
00162:  DATA 43,53
00164:  DATA 20,54
00166:  DATA 43,50
00168:  DATA 20,54
0016A:  DATA 55,54
0016C:  DATA 4F,52
0016E:  DATA 49,41
00170:  DATA 4C,0A
00172:  DATA 0D,49
00174:  DATA 4E,49
00176:  DATA 54,00
*
0023E:  TBLRD*+
00240:  MOVF   FF5,F
00242:  BZ    025E
00244:  MOVFF  FF6,244
00248:  MOVFF  FF7,245
0024C:  MOVF   FF5,W
0024E:  BTFSS  F9E.4
00250:  BRA    024E
00252:  MOVWF  FAD
00254:  MOVFF  244,FF6
00258:  MOVFF  245,FF7
0025C:  BRA    023E
0025E:  GOTO   8224 (RETURN)
*
0055C:  TBLRD*+
0055E:  MOVF   FF5,F
00560:  BZ    057A
00562:  MOVFF  FF6,25F
00566:  MOVFF  FF7,260
0056A:  MOVFF  FF5,261
0056E:  RCALL  04AC
00570:  MOVFF  25F,FF6
00574:  MOVFF  260,FF7
00578:  BRA    055C
0057A:  RETURN 0
*
00CB0:  TSTFSZ 01
00CB2:  BRA    0CBA
00CB4:  TSTFSZ 02
00CB6:  BRA    0CBC
00CB8:  BRA    0CC8
00CBA:  INCF   02,F
00CBC:  MOVFF  00,FEE
00CC0:  DECFSZ 01,F
00CC2:  BRA    0CBC
00CC4:  DECFSZ 02,F
00CC6:  BRA    0CBC
00CC8:  RETURN 0
*
01712:  MOVLB  2
01714:  MOVF   x81,W
01716:  MULWF  x83
01718:  MOVFF  FF3,01
0171C:  MOVFF  FF4,00
01720:  MULWF  x84
01722:  MOVF   FF3,W
01724:  ADDWF  00,F
01726:  MOVF   x82,W
01728:  MULWF  x83
0172A:  MOVF   FF3,W
0172C:  ADDWFC 00,W
0172E:  MOVWF  02
01730:  MOVLB  0
01732:  RETURN 0
*
02A70:  MOVFF  282,01
02A74:  MOVFF  281,00
02A78:  TSTFSZ 00
02A7A:  INCF   01,F
02A7C:  TBLRD*+
02A7E:  MOVFF  FF5,FEE
02A82:  DECFSZ 00,F
02A84:  BRA    2A7C
02A86:  DECFSZ 01,F
02A88:  BRA    2A7C
02A8A:  CLRF   FF8
02A8C:  RETURN 0
*
0431A:  MOVFF  FF2,0D
0431E:  BCF    FF2.7
04320:  ADDWF  FE8,W
04322:  CLRF   FF7
04324:  RLCF   FF7,F
04326:  ADDLW  3F
04328:  MOVWF  FF6
0432A:  MOVLW  43
0432C:  ADDWFC FF7,F
0432E:  TBLRD*-
04330:  MOVF   FF5,W
04332:  MOVWF  FFA
04334:  TBLRD*
04336:  MOVF   FF5,W
04338:  BTFSC  0D.7
0433A:  BSF    FF2.7
0433C:  MOVWF  FF9
0433E:  DATA 6A,3B
04340:  DATA 72,3B
04342:  DATA A4,3B
04344:  DATA 26,3C
04346:  DATA 74,3C
04348:  DATA 74,3D
0434A:  DATA 86,42
0434C:  DATA 54,42
*
0766E:  TBLRD*+
07670:  MOVFF  FF6,24A
07674:  MOVFF  FF7,24B
07678:  MOVFF  FF5,261
0767C:  CALL   04AC
07680:  MOVFF  24A,FF6
07684:  MOVFF  24B,FF7
07688:  MOVLB  2
0768A:  DECFSZ x49,F
0768C:  BRA    7690
0768E:  BRA    7694
07690:  MOVLB  0
07692:  BRA    766E
07694:  MOVLB  0
07696:  RETURN 0
07698:  MOVF   FEF,F
0769A:  BZ    76BC
0769C:  MOVFF  FEA,24A
076A0:  MOVFF  FE9,249
076A4:  MOVFF  FEF,261
076A8:  CALL   04AC
076AC:  MOVFF  24A,FEA
076B0:  MOVFF  249,FE9
076B4:  INCF   FE9,F
076B6:  BTFSC  FD8.2
076B8:  INCF   FEA,F
076BA:  BRA    7698
076BC:  RETURN 0
*
078C2:  MOVFF  FF2,0D
078C6:  BCF    FF2.7
078C8:  ADDWF  FE8,W
078CA:  CLRF   FF7
078CC:  RLCF   FF7,F
078CE:  ADDLW  E7
078D0:  MOVWF  FF6
078D2:  MOVLW  78
078D4:  ADDWFC FF7,F
078D6:  TBLRD*-
078D8:  MOVF   FF5,W
078DA:  MOVWF  FFA
078DC:  TBLRD*
078DE:  MOVF   FF5,W
078E0:  BTFSC  0D.7
078E2:  BSF    FF2.7
078E4:  MOVWF  FF9
078E6:  DATA 7E,77
078E8:  DATA 7E,77
078EA:  DATA A8,77
078EC:  DATA 20,78
*
07AFA:  MOVFF  22B,FEA
07AFE:  MOVFF  22A,FE9
07B02:  MOVLB  2
07B04:  MOVFF  263,FEF
07B08:  INCF   FE9,F
07B0A:  BTFSC  FD8.2
07B0C:  INCF   FEA,F
07B0E:  CLRF   FEF
07B10:  INCF   x2A,F
07B12:  BTFSC  FD8.2
07B14:  INCF   x2B,F
07B16:  MOVLB  0
07B18:  RETURN 0
07B1A:  TBLRD*+
07B1C:  MOVFF  FF6,261
07B20:  MOVFF  FF7,262
07B24:  MOVFF  FF5,263
07B28:  RCALL  7AFA
07B2A:  MOVFF  261,FF6
07B2E:  MOVFF  262,FF7
07B32:  MOVLB  2
07B34:  DECFSZ x60,F
07B36:  BRA    7B3A
07B38:  BRA    7B3E
07B3A:  MOVLB  0
07B3C:  BRA    7B1A
07B3E:  MOVLB  0
07B40:  GOTO   7EAA (RETURN)
07B44:  MOVLB  2
07B46:  MOVF   x63,W
07B48:  CLRF   01
07B4A:  SUBWF  x62,W
07B4C:  BC    7B54
07B4E:  MOVFF  262,00
07B52:  BRA    7B6C
07B54:  CLRF   00
07B56:  MOVLW  08
07B58:  MOVWF  x64
07B5A:  RLCF   x62,F
07B5C:  RLCF   00,F
07B5E:  MOVF   x63,W
07B60:  SUBWF  00,W
07B62:  BTFSC  FD8.0
07B64:  MOVWF  00
07B66:  RLCF   01,F
07B68:  DECFSZ x64,F
07B6A:  BRA    7B5A
07B6C:  MOVLB  0
07B6E:  RETURN 0
07B70:  MOVF   01,W
07B72:  MOVFF  260,262
07B76:  MOVLW  64
07B78:  MOVLB  2
07B7A:  MOVWF  x63
07B7C:  MOVLB  0
07B7E:  RCALL  7B44
07B80:  MOVFF  00,260
07B84:  MOVF   01,W
07B86:  MOVLW  30
07B88:  BNZ   7B9A
07B8A:  MOVLB  2
07B8C:  BTFSS  x61.1
07B8E:  BRA    7BAE
07B90:  BTFSC  x61.3
07B92:  BRA    7BAE
07B94:  BTFSC  x61.4
07B96:  MOVLW  20
07B98:  BRA    7BA2
07B9A:  MOVLB  2
07B9C:  BCF    x61.3
07B9E:  BCF    x61.4
07BA0:  BSF    x61.0
07BA2:  ADDWF  01,F
07BA4:  MOVFF  01,263
07BA8:  MOVLB  0
07BAA:  RCALL  7AFA
07BAC:  MOVLB  2
07BAE:  MOVFF  260,262
07BB2:  MOVLW  0A
07BB4:  MOVWF  x63
07BB6:  MOVLB  0
07BB8:  RCALL  7B44
07BBA:  MOVFF  00,260
07BBE:  MOVF   01,W
07BC0:  MOVLW  30
07BC2:  BNZ   7BD4
07BC4:  MOVLB  2
07BC6:  BTFSC  x61.3
07BC8:  BRA    7BDE
07BCA:  BTFSS  x61.0
07BCC:  BRA    7BDE
07BCE:  BTFSC  x61.4
07BD0:  MOVLW  20
07BD2:  MOVLB  0
07BD4:  ADDWF  01,F
07BD6:  MOVFF  01,263
07BDA:  RCALL  7AFA
07BDC:  MOVLB  2
07BDE:  MOVLW  30
07BE0:  ADDWF  x60,F
07BE2:  MOVFF  260,263
07BE6:  MOVLB  0
07BE8:  RCALL  7AFA
07BEA:  GOTO   7EB8 (RETURN)
*
080E0:  MOVFF  FF2,0D
080E4:  BCF    FF2.7
080E6:  ADDWF  FE8,W
080E8:  CLRF   FF7
080EA:  RLCF   FF7,F
080EC:  ADDLW  05
080EE:  MOVWF  FF6
080F0:  MOVLW  81
080F2:  ADDWFC FF7,F
080F4:  TBLRD*-
080F6:  MOVF   FF5,W
080F8:  MOVWF  FFA
080FA:  TBLRD*
080FC:  MOVF   FF5,W
080FE:  BTFSC  0D.7
08100:  BSF    FF2.7
08102:  MOVWF  FF9
08104:  DATA 22,7F
08106:  DATA A2,7F
08108:  DATA 14,80
0810A:  DATA 58,80
0810C:  DATA CA,80
....................  
.................... #list 
....................  
....................    #include "tcpip\p18cxxx.h" 
.................... // CCS PCH C Compiler to Microchip C18 Compiler compatability layer. 
....................  
.................... #ifndef __P18CXXXX_H__ 
.................... #define __P18CXXXX_H__ 
....................  
.................... #ifndef __18CXX 
.................... #define __18CXX 
.................... #endif 
....................  
.................... //#zero_local_ram 
.................... #zero_ram 
....................  
....................  
.................... #device PASS_STRINGS=IN_RAM 
.................... #device CONST=READ_ONLY 
....................  
.................... #case 
.................... #type signed 
.................... #type short=16 int=16 long=32 
....................  
.................... #define _asm #asm 
.................... #define _endasm #endasm 
....................  
.................... /* usualy 
.................... #define GetSystemClock()      getenv("CLOCK") 
.................... #define GetInstructionClock()   (GetSystemClock()/4) 
.................... #define GetPeripheralClock()   (unsigned int32)GetInstructionClock() 
.................... */ 
....................  
.................... #if getenv("DEVICE") == "PIC18F97J60" 
....................  #define __18F97J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F96J65" 
....................  #define __18F96J65) 
.................... #elif getenv("DEVICE") == "PIC18F96J60" 
....................  #define __18F96J60 
.................... #elif getenv("DEVICE") == "PIC18F87J60" 
....................  #define __18F87J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J60" 
....................  #define __18F86J60 
.................... #elif getenv("DEVICE") == "PIC18F67J60" 
....................  #define __18F67J60 
....................  #include "PIC18F67J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F66J65" 
....................  #define __18F66J65 
.................... #elif getenv("DEVICE") == "PIC18F66J60" 
....................  #define __18F66J60 
.................... #elif getenv("DEVICE") == "PIC18F67K22" 
....................  #define __18F67K22 
....................  #include "PIC18F67K22_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F4620" 
....................  #define __18F4620 
....................  #include "PIC18F4620_registers.h" 
.................... #byte TOSU = 0xFFF 
....................  
.................... #byte TOSH = 0xFFE 
....................  
.................... #byte TOSL = 0xFFD 
....................  
.................... struct STKPTRBITS { 
....................    unsigned int STKPTR0:1; 
....................    unsigned int STKPTR1:1; 
....................    unsigned int STKPTR2:1; 
....................    unsigned int STKPTR3:1; 
....................    unsigned int STKPTR4:1; 
....................    unsigned int :1; 
....................    unsigned int STKUNF:1; 
....................    unsigned int STKFUL:1; 
.................... } STKPTRbits; 
.................... #byte STKPTRbits = 0xFFC 
.................... #byte STKPTR = 0xFFC 
....................  
.................... #byte PCLATU = 0xFFB 
....................  
.................... #byte PCLATH = 0xFFA 
....................  
.................... #byte PCL = 0xFF9 
....................  
.................... struct TBLPTRUBITS { 
....................    unsigned int TBLPTRU0:1; 
....................    unsigned int TBLPTRU1:1; 
....................    unsigned int TBLPTRU2:1; 
....................    unsigned int TBLPTRU3:1; 
....................    unsigned int TBLPTRU4:1; 
....................    unsigned int ACSS:1; 
.................... } TBLPTRUbits; 
.................... #byte TBLPTRUbits = 0xFF8 
.................... #byte TBLPTRU = 0xFF8 
....................  
.................... #byte TBLPTRH = 0xFF7 
....................  
.................... #byte TBLPTRL = 0xFF6 
....................  
.................... #byte TABLAT = 0xFF5 
....................  
.................... #byte PRODH = 0xFF4 
....................  
.................... #byte PRODL = 0xFF3 
....................  
.................... struct INTCONBITS { 
....................    unsigned int RBIF:1; 
....................    unsigned int INT0IF:1; 
....................    unsigned int TMR0IF:1; 
....................    unsigned int RBIE:1; 
....................    unsigned int INT0IE:1; 
....................    unsigned int TMR0IE:1; 
....................    unsigned int PEIE_GIEL:1; 
....................    unsigned int GIE_GIEH:1; 
.................... } INTCONbits; 
.................... #byte INTCONbits = 0xFF2 
.................... #byte INTCON = 0xFF2 
....................  
.................... struct INTCON2BITS { 
....................    unsigned int RBIP:1; 
....................    unsigned int :1; 
....................    unsigned int TMR0IP:1; 
....................    unsigned int :1; 
....................    unsigned int INTEDG4:1; 
....................    unsigned int INTEDG5:1; 
....................    unsigned int INTEDG6:1; 
....................    unsigned int RBPU:1; 
.................... } INTCON2bits; 
.................... #byte INTCON2bits = 0xFF1 
.................... #byte INTCON2 = 0xFF1 
....................  
.................... struct INTCON3BITS { 
....................    unsigned int INT1IF:1; 
....................    unsigned int INT2IF:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IE:1; 
....................    unsigned int INT2IE:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IP:1; 
....................    unsigned int INT2IP:1; 
.................... } INTCON3bits; 
.................... #byte INTCON3bits = 0xFF0 
.................... #byte INTCON3 = 0xFF0 
....................  
.................... #byte INDF0 = 0xFEF 
....................  
.................... #byte POSTINC0 = 0xFEE 
....................  
.................... #byte POSTDEC0 = 0xFED 
....................  
.................... #byte PREINC0 = 0xFEC 
....................  
.................... #byte PLUSW0 = 0xFEB 
....................  
.................... #byte FSR0H = 0xFEA 
....................  
.................... #byte FSR0L = 0xFE9 
....................  
.................... #byte WREG = 0xFE8 
....................  
.................... #byte INDF1 = 0xFE7 
....................  
.................... #byte POSTINC1 = 0xFE6 
....................  
.................... #byte POSTDEC1 = 0xFE5 
....................  
.................... #byte PREINC1 = 0xFE4 
....................  
.................... #byte PLUSW1 = 0xFE3 
....................  
.................... #byte FSR1H = 0xFE2 
....................  
.................... #byte FSR1L = 0xFE1 
....................  
.................... #byte BSR = 0xFE0 
....................  
.................... #byte INDF2 = 0xFDF 
....................  
.................... #byte POSTINC2 = 0xFDE 
....................  
.................... #byte POSTDEC2 = 0xFDD 
....................  
.................... #byte PREINC2 = 0xFDC 
....................  
.................... #byte PLUSW2 = 0xFDB 
....................  
.................... #byte FSR2H = 0xFDA 
....................  
.................... #byte FSR2L = 0xFD9 
....................  
.................... struct STATUSBITS { 
....................    unsigned int C:1; 
....................    unsigned int DC:1; 
....................    unsigned int Z:1; 
....................    unsigned int OV:1; 
....................    unsigned int N:1; 
.................... } STATUSbits; 
.................... #byte STATUSbits = 0xFD8 
.................... #byte STATUS = 0xFD8 
....................  
.................... #byte TMR0H = 0xFD7 
....................  
.................... #byte TMR0L = 0xFD6 
....................  
.................... struct T0CONBITS { 
....................    unsigned int T0PS0:1; 
....................    unsigned int T0PS1:1; 
....................    unsigned int T0PS2:1; 
....................    unsigned int PSA:1; 
....................    unsigned int T0SE:1; 
....................    unsigned int T0CS:1; 
....................    unsigned int T08BIT:1; 
....................    unsigned int TMR0ON:1; 
.................... } T0CONbits; 
.................... #byte T0CONbits = 0xFD5 
.................... #byte T0CON = 0xFD5 
....................  
.................... struct OSCCONBITS { 
....................    unsigned int SCS0:1; 
....................    unsigned int SCS1:1; 
....................    unsigned int IOFS:1; 
....................    unsigned int OSTS:1; 
....................    unsigned int IRCF4:1; 
....................    unsigned int IRCF5:1; 
....................    unsigned int IRCF6:1; 
....................    unsigned int IDLEN:1; 
.................... } OSCCONbits; 
.................... #byte OSCCONbits = 0xFD3 
.................... #byte OSCCON = 0xFD3 
....................  
.................... struct HLVDCONBITS { 
....................    unsigned int HLVDL0:1; 
....................    unsigned int HLVDL1:1; 
....................    unsigned int HLVDL2:1; 
....................    unsigned int HLVDL3:1; 
....................    unsigned int HLVDEN:1; 
....................    unsigned int IVRST:1; 
....................    unsigned int :1; 
....................    unsigned int VDIRMAG:1; 
.................... } HLVDCONbits; 
.................... #byte HLVDCONbits = 0xFD2 
.................... #byte HLVDCON = 0xFD2 
....................  
.................... struct WDTCONBITS { 
....................    unsigned int SWDTEN:1; 
.................... } WDTCONbits; 
.................... #byte WDTCONbits = 0xFD1 
.................... #byte WDTCON = 0xFD1 
....................  
.................... struct RCONBITS { 
....................    unsigned int BOR:1; 
....................    unsigned int POR:1; 
....................    unsigned int PD:1; 
....................    unsigned int TO:1; 
....................    unsigned int RI:1; 
....................    unsigned int :1; 
....................    unsigned int SBOREN:1; 
....................    unsigned int IPEN:1; 
.................... } RCONbits; 
.................... #byte RCONbits = 0xFD0 
.................... #byte RCON = 0xFD0 
....................  
.................... #byte TMR1H = 0xFCF 
....................  
.................... #byte TMR1L = 0xFCE 
....................  
.................... struct T1CONBITS { 
....................    unsigned int TMR1ON:1; 
....................    unsigned int TMR1CS:1; 
....................    unsigned int T1SYNC:1; 
....................    unsigned int T1OSCEN:1; 
....................    unsigned int T1CKPS4:1; 
....................    unsigned int T1CKPS5:1; 
....................    unsigned int T1RUN:1; 
....................    unsigned int RD16:1; 
.................... } T1CONbits; 
.................... #byte T1CONbits = 0xFCD 
.................... #byte T1CON = 0xFCD 
....................  
.................... #byte TMR2 = 0xFCC 
....................  
.................... #byte PR2 = 0xFCB 
....................  
.................... struct T2CONBITS { 
....................    unsigned int T2CKPS0:1; 
....................    unsigned int T2CKPS1:1; 
....................    unsigned int TMR2ON:1; 
....................    unsigned int TOUTPS:4; 
.................... } T2CONbits; 
.................... #byte T2CONbits = 0xFCA 
.................... #byte T2CON = 0xFCA 
....................  
.................... #byte SSPBUF = 0xFC9 
....................  
.................... #byte SSPADD = 0xFC8 
....................  
.................... struct SSPSTATBITS { 
....................    unsigned int BF:1; 
....................    unsigned int UA:1; 
....................    unsigned int R:1; 
....................    unsigned int S:1; 
....................    unsigned int P:1; 
....................    unsigned int D:1; 
....................    unsigned int CKE:1; 
....................    unsigned int SMP:1; 
.................... } SSPSTATbits; 
.................... #byte SSPSTATbits = 0xFC7 
.................... #byte SSPSTAT = 0xFC7 
....................  
.................... struct SSPCON1BITS { 
....................    unsigned int SSPM0:1; 
....................    unsigned int SSPM1:1; 
....................    unsigned int SSPM2:1; 
....................    unsigned int SSPM3:1; 
....................    unsigned int CKP:1; 
....................    unsigned int SSPEN:1; 
....................    unsigned int SSPOV:1; 
....................    unsigned int WCOL:1; 
.................... } SSPCON1bits; 
.................... #byte SSPCON1bits = 0xFC6 
.................... #byte SSPCON1 = 0xFC6 
....................  
.................... struct SSPCON2BITS { 
....................    unsigned int SEN:1; 
....................    unsigned int RSEN:1; 
....................    unsigned int PEN:1; 
....................    unsigned int RCEN:1; 
....................    unsigned int ACKEN:1; 
....................    unsigned int ACKDT:1; 
....................    unsigned int ACKSTAT:1; 
....................    unsigned int GCEN:1; 
.................... } SSPCON2bits; 
.................... #byte SSPCON2bits = 0xFC5 
.................... #byte SSPCON2 = 0xFC5 
....................  
.................... #byte ADRESH = 0xFC4 
....................  
.................... #byte ADRESL = 0xFC3 
....................  
.................... struct ADCON0BITS { 
....................    unsigned int ADON:1; 
....................    unsigned int GO:1; 
....................    unsigned int CHS:4; 
.................... } ADCON0bits; 
.................... #byte ADCON0bits = 0xFC2 
.................... #byte ADCON0 = 0xFC2 
....................  
.................... struct ADCON1BITS { 
....................    unsigned int PCFG0:1; 
....................    unsigned int PCFG1:1; 
....................    unsigned int PCFG2:1; 
....................    unsigned int PCFG3:1; 
....................    unsigned int VCFG4:1; 
....................    unsigned int VCFG1:1; 
.................... } ADCON1bits; 
.................... #byte ADCON1bits = 0xFC1 
.................... #byte ADCON1 = 0xFC1 
....................  
.................... struct ADCON2BITS { 
....................    unsigned int ADCS0:1; 
....................    unsigned int ADCS1:1; 
....................    unsigned int ADCS2:1; 
....................    unsigned int ACQT3:1; 
....................    unsigned int ACQT4:1; 
....................    unsigned int ACQT2:1; 
....................    unsigned int :1; 
....................    unsigned int ADFM:1; 
.................... } ADCON2bits; 
.................... #byte ADCON2bits = 0xFC0 
.................... #byte ADCON2 = 0xFC0 
....................  
.................... #byte CCPR1H = 0xFBF 
....................  
.................... #byte CCPR1L = 0xFBE 
....................  
.................... struct CCP1CONBITS { 
....................    unsigned int CCP1M0:1; 
....................    unsigned int CCP1M1:1; 
....................    unsigned int CCP1M2:1; 
....................    unsigned int CCP1M3:1; 
....................    unsigned int DC1B4:1; 
....................    unsigned int DC1B5:1; 
....................    unsigned int P1M6:1; 
....................    unsigned int P1M1:1; 
.................... } CCP1CONbits; 
.................... #byte CCP1CONbits = 0xFBD 
.................... #byte CCP1CON = 0xFBD 
....................  
.................... #byte CCPR2H = 0xFBC 
....................  
.................... #byte CCPR2L = 0xFBB 
....................  
.................... struct CCP2CONBITS { 
....................    unsigned int CCP2M0:1; 
....................    unsigned int CCP2M1:1; 
....................    unsigned int CCP2M2:1; 
....................    unsigned int CCP2M3:1; 
....................    unsigned int DC2B4:1; 
....................    unsigned int DC2B1:1; 
.................... } CCP2CONbits; 
.................... #byte CCP2CONbits = 0xFBA 
.................... #byte CCP2CON = 0xFBA 
....................  
.................... struct BAUDCONBITS { 
....................    unsigned int ABDEN:1; 
....................    unsigned int WUE:1; 
....................    unsigned int :1; 
....................    unsigned int BRG1:1; 
....................    unsigned int TXCKP:1; 
....................    unsigned int RXDTP:1; 
....................    unsigned int RCIDL:1; 
....................    unsigned int ABDOVF:1; 
.................... } BAUDCONbits; 
.................... #byte BAUDCONbits = 0xFB8 
.................... #byte BAUDCON = 0xFB8 
....................  
.................... struct PWM1CONBITS { 
....................    unsigned int PDC0:1; 
....................    unsigned int PDC1:1; 
....................    unsigned int PDC2:1; 
....................    unsigned int PDC3:1; 
....................    unsigned int PDC4:1; 
....................    unsigned int PDC5:1; 
....................    unsigned int PDC6:1; 
....................    unsigned int PRSEN:1; 
.................... } PWM1CONbits; 
.................... #byte PWM1CONbits = 0xFB7 
.................... #byte PWM1CON = 0xFB7 
....................  
.................... struct ECCP1ASBITS { 
....................    unsigned int PSSBD0:1; 
....................    unsigned int PSSBD1:1; 
....................    unsigned int PSSAC2:1; 
....................    unsigned int PSSAC3:1; 
....................    unsigned int ECCPAS4:1; 
....................    unsigned int ECCPAS5:1; 
....................    unsigned int ECCPAS6:1; 
....................    unsigned int ECCPASE:1; 
.................... } ECCP1ASbits; 
.................... #byte ECCP1ASbits = 0xFB6 
.................... #byte ECCP1AS = 0xFB6 
....................  
.................... struct CVRCONBITS { 
....................    unsigned int CVR0:1; 
....................    unsigned int CVR1:1; 
....................    unsigned int CVR2:1; 
....................    unsigned int CVR3:1; 
....................    unsigned int CVRSS:1; 
....................    unsigned int CVRR:1; 
....................    unsigned int CVROE:1; 
....................    unsigned int CVREN:1; 
.................... } CVRCONbits; 
.................... #byte CVRCONbits = 0xFB5 
.................... #byte CVRCON = 0xFB5 
....................  
.................... struct CMCONBITS { 
....................    unsigned int CM0:1; 
....................    unsigned int CM1:1; 
....................    unsigned int CM2:1; 
....................    unsigned int CIS:1; 
....................    unsigned int C1INV:1; 
....................    unsigned int C2INV:1; 
....................    unsigned int C1OUT:1; 
....................    unsigned int C2OUT:1; 
.................... } CMCONbits; 
.................... #byte CMCONbits = 0xFB4 
.................... #byte CMCON = 0xFB4 
....................  
.................... #byte TMR3H = 0xFB3 
....................  
.................... #byte TMR3L = 0xFB2 
....................  
.................... struct T3CONBITS { 
....................    unsigned int TMR3ON:1; 
....................    unsigned int TMR3CS:1; 
....................    unsigned int T3SYNC:1; 
....................    unsigned int T3CCP3:1; 
....................    unsigned int T3CKPS4:1; 
....................    unsigned int T3CKPS5:1; 
....................    unsigned int T3CCP6:1; 
....................    unsigned int RD16:1; 
.................... } T3CONbits; 
.................... #byte T3CONbits = 0xFB1 
.................... #byte T3CON = 0xFB1 
....................  
.................... #byte SPBRGH = 0xFB0 
....................  
.................... #byte SPBRG = 0xFAF 
....................  
.................... #byte RCREG = 0xFAE 
....................  
.................... #byte TXREG = 0xFAD 
....................  
.................... struct TXSTABITS { 
....................    unsigned int TX9D:1; 
....................    unsigned int TRMT:1; 
....................    unsigned int BRGH:1; 
....................    unsigned int SENDB:1; 
....................    unsigned int SYNC:1; 
....................    unsigned int TXEN:1; 
....................    unsigned int TX:1; 
....................    unsigned int CSRC:1; 
.................... } TXSTAbits; 
.................... #byte TXSTAbits = 0xFAC 
.................... #byte TXSTA = 0xFAC 
....................  
.................... struct RCSTABITS { 
....................    unsigned int RX9D:1; 
....................    unsigned int OERR:1; 
....................    unsigned int FERR:1; 
....................    unsigned int ADDEN:1; 
....................    unsigned int CREN:1; 
....................    unsigned int SREN:1; 
....................    unsigned int RX:1; 
....................    unsigned int SPEN:1; 
.................... } RCSTAbits; 
.................... #byte RCSTAbits = 0xFAB 
.................... #byte RCSTA = 0xFAB 
....................  
.................... #byte EEADRH = 0xFAA 
....................  
.................... #byte EEADR = 0xFA9 
....................  
.................... #byte EEDATA = 0xFA8 
....................  
.................... #byte EECON2 = 0xFA7 
....................  
.................... struct EECON1BITS { 
....................    unsigned int RD:1; 
....................    unsigned int WR:1; 
....................    unsigned int WREN:1; 
....................    unsigned int WRERR:1; 
....................    unsigned int FREE:1; 
....................    unsigned int :1; 
....................    unsigned int CFGS:1; 
....................    unsigned int EEPGD:1; 
.................... } EECON1bits; 
.................... #byte EECON1bits = 0xFA6 
.................... #byte EECON1 = 0xFA6 
....................  
.................... struct IPR2BITS { 
....................    unsigned int CCP2IP:1; 
....................    unsigned int TMR3IP:1; 
....................    unsigned int HLVDIP:1; 
....................    unsigned int BCLIP:1; 
....................    unsigned int EEIP:1; 
....................    unsigned int :1; 
....................    unsigned int CMIP:1; 
....................    unsigned int OSCFIP:1; 
.................... } IPR2bits; 
.................... #byte IPR2bits = 0xFA2 
.................... #byte IPR2 = 0xFA2 
....................  
.................... struct PIR2BITS { 
....................    unsigned int CCP2IF:1; 
....................    unsigned int TMR3IF:1; 
....................    unsigned int HLVDIF:1; 
....................    unsigned int BCLIF:1; 
....................    unsigned int EEIF:1; 
....................    unsigned int :1; 
....................    unsigned int CMIF:1; 
....................    unsigned int OSCFIF:1; 
.................... } PIR2bits; 
.................... #byte PIR2bits = 0xFA1 
.................... #byte PIR2 = 0xFA1 
....................  
.................... struct PIE2BITS { 
....................    unsigned int CCP2IE:1; 
....................    unsigned int TMR3IE:1; 
....................    unsigned int HLVDIE:1; 
....................    unsigned int BCLIE:1; 
....................    unsigned int EEIE:1; 
....................    unsigned int :1; 
....................    unsigned int CMIE:1; 
....................    unsigned int OSCFIE:1; 
.................... } PIE2bits; 
.................... #byte PIE2bits = 0xFA0 
.................... #byte PIE2 = 0xFA0 
....................  
.................... struct IPR1BITS { 
....................    unsigned int TMR1IP:1; 
....................    unsigned int TMR2IP:1; 
....................    unsigned int CCP1IP:1; 
....................    unsigned int SSPIP:1; 
....................    unsigned int TXIP:1; 
....................    unsigned int RCIP:1; 
....................    unsigned int ADIP:1; 
....................    unsigned int PSPIP:1; 
.................... } IPR1bits; 
.................... #byte IPR1bits = 0xF9F 
.................... #byte IPR1 = 0xF9F 
....................  
.................... struct PIR1BITS { 
....................    unsigned int TMR1IF:1; 
....................    unsigned int TMR2IF:1; 
....................    unsigned int CCP1IF:1; 
....................    unsigned int SSPIF:1; 
....................    unsigned int TXIF:1; 
....................    unsigned int RCIF:1; 
....................    unsigned int ADIF:1; 
....................    unsigned int PSPIF:1; 
.................... } PIR1bits; 
.................... #byte PIR1bits = 0xF9E 
.................... #byte PIR1 = 0xF9E 
....................  
.................... struct PIE1BITS { 
....................    unsigned int TMR1IE:1; 
....................    unsigned int TMR2IE:1; 
....................    unsigned int CCP1IE:1; 
....................    unsigned int SSPIE:1; 
....................    unsigned int TXIE:1; 
....................    unsigned int RCIE:1; 
....................    unsigned int ADIE:1; 
....................    unsigned int PSPIE:1; 
.................... } PIE1bits; 
.................... #byte PIE1bits = 0xF9D 
.................... #byte PIE1 = 0xF9D 
....................  
.................... struct OSCTUNEBITS { 
....................    unsigned int TUN0:1; 
....................    unsigned int TUN1:1; 
....................    unsigned int TUN2:1; 
....................    unsigned int TUN3:1; 
....................    unsigned int TUN4:1; 
....................    unsigned int :1; 
....................    unsigned int PLLEN:1; 
....................    unsigned int INTSRC:1; 
.................... } OSCTUNEbits; 
.................... #byte OSCTUNEbits = 0xF9B 
.................... #byte OSCTUNE = 0xF9B 
....................  
.................... struct TRISEBITS { 
....................    unsigned int TRISE0:1; 
....................    unsigned int TRISE1:1; 
....................    unsigned int TRISE2:1; 
....................    unsigned int :1; 
....................    unsigned int PSPMODE:1; 
....................    unsigned int IBOV:1; 
....................    unsigned int OBF:1; 
....................    unsigned int IBF:1; 
.................... } TRISEbits; 
.................... #byte TRISEbits = 0xF96 
.................... #byte TRISE = 0xF96 
....................  
.................... struct TRISDBITS { 
....................    unsigned int TRISD0:1; 
....................    unsigned int TRISD1:1; 
....................    unsigned int TRISD2:1; 
....................    unsigned int TRISD3:1; 
....................    unsigned int TRISD4:1; 
....................    unsigned int TRISD5:1; 
....................    unsigned int TRISD6:1; 
....................    unsigned int TRISD7:1; 
.................... } TRISDbits; 
.................... #byte TRISDbits = 0xF95 
.................... #byte TRISD = 0xF95 
....................  
.................... struct TRISCBITS { 
....................    unsigned int TRISC0:1; 
....................    unsigned int TRISC1:1; 
....................    unsigned int TRISC2:1; 
....................    unsigned int TRISC3:1; 
....................    unsigned int TRISC4:1; 
....................    unsigned int TRISC5:1; 
....................    unsigned int TRISC6:1; 
....................    unsigned int TRISC7:1; 
.................... } TRISCbits; 
.................... #byte TRISCbits = 0xF94 
.................... #byte TRISC = 0xF94 
....................  
.................... struct TRISBBITS { 
....................    unsigned int TRISB0:1; 
....................    unsigned int TRISB1:1; 
....................    unsigned int TRISB2:1; 
....................    unsigned int TRISB3:1; 
....................    unsigned int TRISB4:1; 
....................    unsigned int TRISB5:1; 
....................    unsigned int TRISB6:1; 
....................    unsigned int TRISB7:1; 
.................... } TRISBbits; 
.................... #byte TRISBbits = 0xF93 
.................... #byte TRISB = 0xF93 
....................  
.................... struct TRISABITS { 
....................    unsigned int TRISA0:1; 
....................    unsigned int TRISA1:1; 
....................    unsigned int TRISA2:1; 
....................    unsigned int TRISA3:1; 
....................    unsigned int TRISA4:1; 
....................    unsigned int TRISA5:1; 
....................    unsigned int TRISA6:1; 
....................    unsigned int TRISA7:1; 
.................... } TRISAbits; 
.................... #byte TRISAbits = 0xF92 
.................... #byte TRISA = 0xF92 
....................  
.................... struct LATEBITS { 
....................    unsigned int LATE0:1; 
....................    unsigned int LATE1:1; 
....................    unsigned int LATE2:1; 
....................    unsigned int LATE3:1; 
....................    unsigned int LATE4:1; 
....................    unsigned int LATE5:1; 
....................    unsigned int LATE6:1; 
....................    unsigned int LATE7:1; 
.................... } LATEbits; 
.................... #byte LATEbits = 0xF8D 
.................... #byte LATE = 0xF8D 
....................  
.................... struct LATDBITS { 
....................    unsigned int LATD0:1; 
....................    unsigned int LATD1:1; 
....................    unsigned int LATD2:1; 
....................    unsigned int LATD3:1; 
....................    unsigned int LATD4:1; 
....................    unsigned int LATD5:1; 
....................    unsigned int LATD6:1; 
....................    unsigned int LATD7:1; 
.................... } LATDbits; 
.................... #byte LATDbits = 0xF8C 
.................... #byte LATD = 0xF8C 
....................  
.................... struct LATCBITS { 
....................    unsigned int LATC0:1; 
....................    unsigned int LATC1:1; 
....................    unsigned int LATC2:1; 
....................    unsigned int LATC3:1; 
....................    unsigned int LATC4:1; 
....................    unsigned int LATC5:1; 
....................    unsigned int LATC6:1; 
....................    unsigned int LATC7:1; 
.................... } LATCbits; 
.................... #byte LATCbits = 0xF8B 
.................... #byte LATC = 0xF8B 
....................  
.................... struct LATBBITS { 
....................    unsigned int LATB0:1; 
....................    unsigned int LATB1:1; 
....................    unsigned int LATB2:1; 
....................    unsigned int LATB3:1; 
....................    unsigned int LATB4:1; 
....................    unsigned int LATB5:1; 
....................    unsigned int LATB6:1; 
....................    unsigned int LATB7:1; 
.................... } LATBbits; 
.................... #byte LATBbits = 0xF8A 
.................... #byte LATB = 0xF8A 
....................  
.................... struct LATABITS { 
....................    unsigned int LATA0:1; 
....................    unsigned int LATA1:1; 
....................    unsigned int LATA2:1; 
....................    unsigned int LATA3:1; 
....................    unsigned int LATA4:1; 
....................    unsigned int LATA5:1; 
....................    unsigned int LATA6:1; 
....................    unsigned int LATA7:1; 
.................... } LATAbits; 
.................... #byte LATAbits = 0xF89 
.................... #byte LATA = 0xF89 
....................  
.................... struct PORTEBITS { 
....................    unsigned int RE0:1; 
....................    unsigned int RE1:1; 
....................    unsigned int RE2:1; 
....................    unsigned int RE3:1; 
....................    unsigned int RE4:1; 
....................    unsigned int RE5:1; 
....................    unsigned int RE6:1; 
....................    unsigned int RE7:1; 
.................... } PORTEbits; 
.................... #byte PORTEbits = 0xF84 
.................... #byte PORTE = 0xF84 
....................  
.................... struct PORTDBITS { 
....................    unsigned int RD0:1; 
....................    unsigned int RD1:1; 
....................    unsigned int RD2:1; 
....................    unsigned int RD3:1; 
....................    unsigned int RD4:1; 
....................    unsigned int RD5:1; 
....................    unsigned int RD6:1; 
....................    unsigned int RD7:1; 
.................... } PORTDbits; 
.................... #byte PORTDbits = 0xF83 
.................... #byte PORTD = 0xF83 
....................  
.................... struct PORTCBITS { 
....................    unsigned int RC0:1; 
....................    unsigned int RC1:1; 
....................    unsigned int RC2:1; 
....................    unsigned int RC3:1; 
....................    unsigned int RC4:1; 
....................    unsigned int RC5:1; 
....................    unsigned int RC6:1; 
....................    unsigned int RC7:1; 
.................... } PORTCbits; 
.................... #byte PORTCbits = 0xF82 
.................... #byte PORTC = 0xF82 
....................  
.................... struct PORTBBITS { 
....................    unsigned int RB0:1; 
....................    unsigned int RB1:1; 
....................    unsigned int RB2:1; 
....................    unsigned int RB3:1; 
....................    unsigned int RB4:1; 
....................    unsigned int RB5:1; 
....................    unsigned int RB6:1; 
....................    unsigned int RB7:1; 
.................... } PORTBbits; 
.................... #byte PORTBbits = 0xF81 
.................... #byte PORTB = 0xF81 
....................  
.................... struct PORTABITS { 
....................    unsigned int RA0:1; 
....................    unsigned int RA1:1; 
....................    unsigned int RA2:1; 
....................    unsigned int RA3:1; 
....................    unsigned int RA4:1; 
....................    unsigned int RA5:1; 
....................    unsigned int RA6:1; 
....................    unsigned int RA7:1; 
.................... } PORTAbits; 
.................... #byte PORTAbits = 0xF80 
.................... #byte PORTA = 0xF80 
....................  
....................  
.................... #else 
....................    #error Do this for your chip 
.................... #endif 
....................  
.................... #if defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) 
....................    #reserve 0xE80:0xEFF 
....................    #reserve 0xF00:0xFFF 
.................... #endif 
....................  
.................... #if defined(TRUE) 
....................    #undef TRUE 
.................... #endif 
....................  
.................... #if defined(FALSE) 
....................    #undef FALSE 
.................... #endif 
....................  
.................... #if defined(BYTE) 
....................    #undef BYTE 
.................... #endif 
....................  
....................       #define Reset()            reset_cpu() 
....................         #define far 
....................         #define ClrWdt()         restart_wdt() 
....................       #define Nop()            delay_cycles(1)       
....................  
.................... #define __CCS__ 
....................  
.................... //signed int8 memcmppgm2ram(void * s1, rom char *s2, unsigned int8 n); 
.................... signed int8 strcmppgm2ram(char *s1, __ADDRESS__ s2); 
.................... char *strchrpgm(__ADDRESS__ s, unsigned int8 c); 
.................... char *strstrrampgm(char *s1, __ADDRESS__ s2); 
.................... unsigned int8 strlenpgm(__ADDRESS__ s); 
.................... void memcpypgm2ram(unsigned int8 *d, __ADDRESS__ s, unsigned int16 n); 
.................... //char* strupr(char *s);   now in string.h 
.................... void strcpypgm2ram(char *d, __ADDRESS__ s); 
.................... #endif 
....................  
....................    #use delay(clock=40000000) 
*
00262:  MOVLW  02
00264:  MOVWF  FEA
00266:  MOVLW  62
00268:  MOVWF  FE9
0026A:  MOVF   FEF,W
0026C:  BZ    028A
0026E:  MOVLW  0C
00270:  MOVWF  01
00272:  CLRF   00
00274:  DECFSZ 00,F
00276:  BRA    0274
00278:  DECFSZ 01,F
0027A:  BRA    0272
0027C:  MOVLW  F7
0027E:  MOVWF  00
00280:  DECFSZ 00,F
00282:  BRA    0280
00284:  BRA    0286
00286:  DECFSZ FEF,F
00288:  BRA    026E
0028A:  RETURN 0
....................    #fuses H4, NOWDT, NOLVP, NODEBUG  
....................     
....................    #use rs232(baud=9600, uart1, stream=STREAM_UI, errors) 
....................        
....................    #define BUTTON1_PRESSED()  (!input(PIN_A4)) 
....................    #define USER_LED1    PIN_A5 
....................    #define USER_LED2    PIN_B4 
....................    #define USER_LED3    PIN_B5 
....................    #define LED_ON       output_low 
....................    #define LED_OFF      output_high 
....................    #define STANDARD_ADC_STRING  "AN0" 
....................    #define STANDARD_ADC_CHANNEL 0 
....................     
....................    #define LCD_ENABLE_PIN  PIN_E2 
....................    #define LCD_RS_PIN      PIN_E0 
....................    #define LCD_RW_PIN      PIN_E1 
....................    #define LCD_DATA4       PIN_D4 
....................    #define LCD_DATA5       PIN_D5 
....................    #define LCD_DATA6       PIN_D6 
....................    #define LCD_DATA7       PIN_D7 
....................     
....................    #ifndef STACK_USE_PICDEM_LCD 
....................       #define STACK_USE_PICDEM_LCD 1 
....................    #endif 
....................    #if STACK_USE_PICDEM_LCD 
....................       #include "lcd.c" 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
0032C:  BSF    F95.4
....................    output_float(LCD_DATA5); 
0032E:  BSF    F95.5
....................    output_float(LCD_DATA6); 
00330:  BSF    F95.6
....................    output_float(LCD_DATA7); 
00332:  BSF    F95.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
00334:  BSF    F8D.1
00336:  BCF    F96.1
....................    delay_cycles(1); 
00338:  NOP   
....................    lcd_output_enable(1); 
0033A:  BSF    F8D.2
0033C:  BCF    F96.2
....................    delay_cycles(1); 
0033E:  NOP   
....................    high = lcd_read_nibble(); 
00340:  RCALL  02D6
00342:  MOVFF  01,26A
....................        
....................    lcd_output_enable(0); 
00346:  BCF    F8D.2
00348:  BCF    F96.2
....................    delay_cycles(1); 
0034A:  NOP   
....................    lcd_output_enable(1); 
0034C:  BSF    F8D.2
0034E:  BCF    F96.2
....................    delay_us(1); 
00350:  MOVLW  02
00352:  MOVWF  00
00354:  DECFSZ 00,F
00356:  BRA    0354
00358:  BRA    035A
0035A:  NOP   
....................    low = lcd_read_nibble(); 
0035C:  RCALL  02D6
0035E:  MOVFF  01,269
....................        
....................    lcd_output_enable(0); 
00362:  BCF    F8D.2
00364:  BCF    F96.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
00366:  BCF    F95.4
....................    output_drive(LCD_DATA5); 
00368:  BCF    F95.5
....................    output_drive(LCD_DATA6); 
0036A:  BCF    F95.6
....................    output_drive(LCD_DATA7); 
0036C:  BCF    F95.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0036E:  MOVLB  2
00370:  SWAPF  x6A,W
00372:  MOVWF  00
00374:  MOVLW  F0
00376:  ANDWF  00,F
00378:  MOVF   00,W
0037A:  IORWF  x69,W
0037C:  MOVWF  01
0037E:  MOVLB  0
00380:  GOTO   0390 (RETURN)
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
002D6:  MOVLB  2
002D8:  CLRF   x6B
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
002DA:  BSF    F95.4
002DC:  MOVLW  00
002DE:  BTFSC  F83.4
002E0:  MOVLW  01
002E2:  IORWF  x6B,F
....................    n |= input(LCD_DATA5) << 1; 
002E4:  BSF    F95.5
002E6:  MOVLW  00
002E8:  BTFSC  F83.5
002EA:  MOVLW  01
002EC:  MOVWF  00
002EE:  BCF    FD8.0
002F0:  RLCF   00,F
002F2:  MOVF   00,W
002F4:  IORWF  x6B,F
....................    n |= input(LCD_DATA6) << 2; 
002F6:  BSF    F95.6
002F8:  MOVLW  00
002FA:  BTFSC  F83.6
002FC:  MOVLW  01
002FE:  MOVWF  00
00300:  RLCF   00,F
00302:  RLCF   00,F
00304:  MOVLW  FC
00306:  ANDWF  00,F
00308:  MOVF   00,W
0030A:  IORWF  x6B,F
....................    n |= input(LCD_DATA7) << 3; 
0030C:  BSF    F95.7
0030E:  MOVLW  00
00310:  BTFSC  F83.7
00312:  MOVLW  01
00314:  MOVWF  00
00316:  RLCF   00,F
00318:  RLCF   00,F
0031A:  RLCF   00,F
0031C:  MOVLW  F8
0031E:  ANDWF  00,F
00320:  MOVF   00,W
00322:  IORWF  x6B,F
....................     
....................    return(n); 
00324:  MOVFF  26B,01
....................   #else 
00328:  MOVLB  0
0032A:  RETURN 0
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0028C:  MOVLB  2
0028E:  BTFSC  x6A.0
00290:  BRA    0296
00292:  BCF    F8C.4
00294:  BRA    0298
00296:  BSF    F8C.4
00298:  BCF    F95.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0029A:  BTFSC  x6A.1
0029C:  BRA    02A2
0029E:  BCF    F8C.5
002A0:  BRA    02A4
002A2:  BSF    F8C.5
002A4:  BCF    F95.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
002A6:  BTFSC  x6A.2
002A8:  BRA    02AE
002AA:  BCF    F8C.6
002AC:  BRA    02B0
002AE:  BSF    F8C.6
002B0:  BCF    F95.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
002B2:  BTFSC  x6A.3
002B4:  BRA    02BA
002B6:  BCF    F8C.7
002B8:  BRA    02BC
002BA:  BSF    F8C.7
002BC:  BCF    F95.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
002BE:  NOP   
....................    lcd_output_enable(1); 
002C0:  BSF    F8D.2
002C2:  BCF    F96.2
....................    delay_us(2); 
002C4:  MOVLW  06
002C6:  MOVWF  00
002C8:  DECFSZ 00,F
002CA:  BRA    02C8
002CC:  NOP   
....................    lcd_output_enable(0); 
002CE:  BCF    F8D.2
002D0:  BCF    F96.2
002D2:  MOVLB  0
002D4:  RETURN 0
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
00384:  BCF    F96.2
....................    lcd_rs_tris(); 
00386:  BCF    F96.0
....................    lcd_rw_tris(); 
00388:  BCF    F96.1
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0038A:  BCF    F8D.0
0038C:  BCF    F96.0
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
0038E:  BRA    032C
00390:  MOVFF  01,269
00394:  MOVLB  2
00396:  BTFSS  01.7
00398:  BRA    039E
0039A:  MOVLB  0
0039C:  BRA    038E
....................    lcd_output_rs(address); 
0039E:  MOVF   x67,F
003A0:  BNZ   03A6
003A2:  BCF    F8D.0
003A4:  BRA    03A8
003A6:  BSF    F8D.0
003A8:  BCF    F96.0
....................    delay_cycles(1); 
003AA:  NOP   
....................    lcd_output_rw(0); 
003AC:  BCF    F8D.1
003AE:  BCF    F96.1
....................    delay_cycles(1); 
003B0:  NOP   
....................    lcd_output_enable(0); 
003B2:  BCF    F8D.2
003B4:  BCF    F96.2
....................    lcd_send_nibble(n >> 4); 
003B6:  SWAPF  x68,W
003B8:  MOVWF  x69
003BA:  MOVLW  0F
003BC:  ANDWF  x69,F
003BE:  MOVFF  269,26A
003C2:  MOVLB  0
003C4:  RCALL  028C
....................    lcd_send_nibble(n & 0xf); 
003C6:  MOVLB  2
003C8:  MOVF   x68,W
003CA:  ANDLW  0F
003CC:  MOVWF  x69
003CE:  MOVWF  x6A
003D0:  MOVLB  0
003D2:  RCALL  028C
003D4:  RETURN 0
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
003D6:  MOVLW  28
003D8:  MOVLB  2
003DA:  MOVWF  x45
003DC:  MOVLW  0C
003DE:  MOVWF  x46
003E0:  MOVLW  01
003E2:  MOVWF  x47
003E4:  MOVLW  06
003E6:  MOVWF  x48
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
003E8:  BCF    F8D.2
003EA:  BCF    F96.2
....................    lcd_output_rs(0); 
003EC:  BCF    F8D.0
003EE:  BCF    F96.0
....................    lcd_output_rw(0); 
003F0:  BCF    F8D.1
003F2:  BCF    F96.1
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
003F4:  BCF    F95.4
....................    output_drive(LCD_DATA5); 
003F6:  BCF    F95.5
....................    output_drive(LCD_DATA6); 
003F8:  BCF    F95.6
....................    output_drive(LCD_DATA7); 
003FA:  BCF    F95.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
003FC:  BCF    F96.2
....................    lcd_rs_tris(); 
003FE:  BCF    F96.0
....................    lcd_rw_tris(); 
00400:  BCF    F96.1
....................  #endif 
....................      
....................    delay_ms(15); 
00402:  MOVLW  0F
00404:  MOVWF  x62
00406:  MOVLB  0
00408:  RCALL  0262
....................    for(i=1;i<=3;++i) 
0040A:  MOVLW  01
0040C:  MOVLB  2
0040E:  MOVWF  x44
00410:  MOVF   x44,W
00412:  SUBLW  03
00414:  BNC   042E
....................    { 
....................        lcd_send_nibble(3); 
00416:  MOVLW  03
00418:  MOVWF  x6A
0041A:  MOVLB  0
0041C:  RCALL  028C
....................        delay_ms(5); 
0041E:  MOVLW  05
00420:  MOVLB  2
00422:  MOVWF  x62
00424:  MOVLB  0
00426:  RCALL  0262
00428:  MOVLB  2
0042A:  INCF   x44,F
0042C:  BRA    0410
....................    } 
....................     
....................    lcd_send_nibble(2); 
0042E:  MOVLW  02
00430:  MOVWF  x6A
00432:  MOVLB  0
00434:  RCALL  028C
....................    delay_ms(5); 
00436:  MOVLW  05
00438:  MOVLB  2
0043A:  MOVWF  x62
0043C:  MOVLB  0
0043E:  RCALL  0262
....................    for(i=0;i<=3;++i) 
00440:  MOVLB  2
00442:  CLRF   x44
00444:  MOVF   x44,W
00446:  SUBLW  03
00448:  BNC   046C
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0044A:  CLRF   03
0044C:  MOVF   x44,W
0044E:  ADDLW  45
00450:  MOVWF  FE9
00452:  MOVLW  02
00454:  ADDWFC 03,W
00456:  MOVWF  FEA
00458:  MOVFF  FEF,249
0045C:  CLRF   x67
0045E:  MOVFF  249,268
00462:  MOVLB  0
00464:  RCALL  0384
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
00466:  MOVLB  2
00468:  INCF   x44,F
0046A:  BRA    0444
....................    g_LcdX = 0; 
0046C:  CLRF   17
....................    g_LcdY = 0; 
0046E:  CLRF   18
....................   #endif 
00470:  MOVLB  0
00472:  GOTO   8228 (RETURN)
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
00476:  MOVLB  2
00478:  DECFSZ x64,W
0047A:  BRA    047E
0047C:  BRA    0484
....................       address=LCD_LINE_TWO; 
0047E:  MOVLW  40
00480:  MOVWF  x65
00482:  BRA    0486
....................    else 
....................       address=0; 
00484:  CLRF   x65
....................       
....................    address+=x-1; 
00486:  MOVLW  01
00488:  SUBWF  x63,W
0048A:  ADDWF  x65,F
....................    lcd_send_byte(0,0x80|address); 
0048C:  MOVF   x65,W
0048E:  IORLW  80
00490:  MOVWF  x66
00492:  CLRF   x67
00494:  MOVWF  x68
00496:  MOVLB  0
00498:  RCALL  0384
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
....................    g_LcdX = x - 1; 
0049A:  MOVLW  01
0049C:  MOVLB  2
0049E:  SUBWF  x63,W
004A0:  MOVWF  17
....................    g_LcdY = y - 1; 
004A2:  MOVLW  01
004A4:  SUBWF  x64,W
004A6:  MOVWF  18
....................   #endif 
004A8:  MOVLB  0
004AA:  RETURN 0
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
004AC:  MOVLB  2
004AE:  MOVF   x61,W
004B0:  XORLW  07
004B2:  MOVLB  0
004B4:  BZ    04C8
004B6:  XORLW  0B
004B8:  BZ    04D6
004BA:  XORLW  01
004BC:  BZ    04F2
004BE:  XORLW  07
004C0:  BZ    0508
004C2:  XORLW  02
004C4:  BZ    0536
004C6:  BRA    0544
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
004C8:  MOVLW  01
004CA:  MOVLB  2
004CC:  MOVWF  x63
004CE:  MOVWF  x64
004D0:  MOVLB  0
004D2:  RCALL  0476
004D4:  BRA    055A
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
004D6:  MOVLB  2
004D8:  CLRF   x67
004DA:  MOVLW  01
004DC:  MOVWF  x68
004DE:  MOVLB  0
004E0:  RCALL  0384
....................                      delay_ms(2); 
004E2:  MOVLW  02
004E4:  MOVLB  2
004E6:  MOVWF  x62
004E8:  MOVLB  0
004EA:  RCALL  0262
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
004EC:  CLRF   17
....................                      g_LcdY = 0; 
004EE:  CLRF   18
....................                     #endif 
....................                      break; 
004F0:  BRA    055A
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
004F2:  MOVLW  01
004F4:  ADDWF  18,W
004F6:  MOVLB  2
004F8:  MOVWF  x62
004FA:  MOVLW  01
004FC:  MOVWF  x63
004FE:  MOVFF  262,264
00502:  MOVLB  0
00504:  RCALL  0476
00506:  BRA    055A
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
00508:  MOVF   17,W
0050A:  INCF   17,F
0050C:  SUBLW  13
0050E:  BNC   0520
....................          { 
....................             lcd_send_byte(1, ' '); 
00510:  MOVLW  01
00512:  MOVLB  2
00514:  MOVWF  x67
00516:  MOVLW  20
00518:  MOVWF  x68
0051A:  MOVLB  0
0051C:  RCALL  0384
0051E:  BRA    0508
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
00520:  MOVLW  02
00522:  ADDWF  18,W
00524:  MOVLB  2
00526:  MOVWF  x62
00528:  MOVLW  01
0052A:  MOVWF  x63
0052C:  MOVFF  262,264
00530:  MOVLB  0
00532:  RCALL  0476
....................          break; 
00534:  BRA    055A
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
00536:  MOVLB  2
00538:  CLRF   x67
0053A:  MOVLW  10
0053C:  MOVWF  x68
0053E:  MOVLB  0
00540:  RCALL  0384
00542:  BRA    055A
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
00544:  MOVF   17,W
00546:  SUBLW  13
00548:  BNC   055A
....................          { 
....................             lcd_send_byte(1, c); 
0054A:  MOVLW  01
0054C:  MOVLB  2
0054E:  MOVWF  x67
00550:  MOVFF  261,268
00554:  MOVLB  0
00556:  RCALL  0384
....................             g_LcdX++; 
00558:  INCF   17,F
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
....................      #endif 
....................    } 
0055A:  RETURN 0
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................    #endif 
....................     
....................    #define ENC_CS_IO       LATDbits.LATD1 
....................    #define ENC_CS_TRIS     TRISDbits.TRISD1 
....................    #define ENC_SCK_TRIS    TRISCbits.TRISC3 
....................    #define ENC_SDO_TRIS    TRISCbits.TRISC5 
....................    #define ENC_SDI_TRIS    TRISCbits.TRISC4 
....................    #define ENC_SPI_IF         PIR1bits.SSPIF 
....................    #define ENC_SPICON1        SSPCON1bits 
....................    #define ENC_SPISTATbits    SSPSTATbits 
....................    #define ENC_SSPBUF         SSPBUF 
....................     
....................    void init_user_io(void)  
....................    { 
....................       setup_adc(ADC_CLOCK_INTERNAL); 
*
00178:  MOVF   FC0,W
0017A:  ANDLW  C0
0017C:  IORLW  07
0017E:  MOVWF  FC0
00180:  BCF    FC0.7
00182:  BSF    FC2.0
....................       setup_adc_ports(AN0); 
00184:  MOVF   FC1,W
00186:  ANDLW  C0
00188:  IORLW  0E
0018A:  MOVWF  FC1
....................       set_adc_channel(STANDARD_ADC_CHANNEL); 
0018C:  MOVLW  00
0018E:  MOVWF  01
00190:  MOVF   FC2,W
00192:  ANDLW  C3
00194:  IORWF  01,W
00196:  MOVWF  FC2
....................        
....................       setup_comparator(NC_NC_NC_NC); 
00198:  MOVLW  07
0019A:  MOVWF  FB4
0019C:  MOVF   F92,W
0019E:  MOVWF  F92
001A0:  MOVLW  20
001A2:  MOVWF  00
001A4:  DECFSZ 00,F
001A6:  BRA    01A4
001A8:  BRA    01AA
001AA:  NOP   
001AC:  MOVF   FB4,W
001AE:  BCF    FA1.6
....................        
....................       output_drive(USER_LED1); 
001B0:  BCF    F92.5
....................       output_drive(USER_LED2); 
001B2:  BCF    F93.4
....................       output_drive(USER_LED3); 
001B4:  BCF    F93.5
....................       LED_OFF(USER_LED1); 
001B6:  BCF    F92.5
001B8:  BSF    F89.5
....................       LED_OFF(USER_LED2); 
001BA:  BCF    F93.4
001BC:  BSF    F8A.4
....................       LED_OFF(USER_LED3); 
001BE:  BCF    F93.5
001C0:  BSF    F8A.5
001C2:  GOTO   0230 (RETURN)
....................    } 
....................     
....................    #define EEPROM_SELECT     PIN_B3 
....................    #define EEPROM_DI         PIN_C5 
....................    #define EEPROM_DO         PIN_C4 
....................    #define EEPROM_CLK        PIN_C3 
....................    #define EEPROM_USE_SPI    1 
....................    #include "AT25256.C" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for an ATMEL25128 or ATMEL25256                         //// 
.................... ////    ATMEL25128 has 16,384 (or 13bits of addressing) locations      //// 
.................... ////    ATMEL25256 has 32,768 words of 8 bits                          //// 
.................... ////                                                                   //// 
.................... ////   Uses software (bit banging on the port pins)                    //// 
.................... ////                                                                   //// 
.................... ////                     Pin Layout                                    //// 
.................... ////   ATMEL EEPROM pin     to      Microchip MCU Pin                  //// 
.................... ////   ----------------             -----------------                  //// 
.................... ////   1 (CS)                       PortB 0                            //// 
.................... ////   2 (SO)                       PortC 4                            //// 
.................... ////   3 (WP)                       +5V                                //// 
.................... ////   4 (GND)                      GND                                //// 
.................... ////   5 (SI)                       PortC 5                            //// 
.................... ////   6 (SCK)                      PortC 3                            //// 
.................... ////   7 (HOLD)                     +5V                                //// 
.................... ////   8 (VCC)                      +5V                                //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the unsigned int8 d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the unsigned int8 d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   b = ext_eerpom_ready();  Returns TRUE if the eeprom is ready    //// 
.................... ////                            to receive opcodes                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef EEPROM_SELECT 
.................... #define EEPROM_SELECT PIN_B0 
.................... #define EEPROM_DI     PIN_C5 
.................... #define EEPROM_DO     PIN_C4 
.................... #define EEPROM_CLK    PIN_C3 
.................... #endif 
....................  
.................... #ifndef EEPROM_ADDRESS 
.................... #define EEPROM_ADDRESS long 
.................... #endif 
....................  
.................... #byte SSPSTAT=0x94 
.................... #byte SSPCON=0x14 
....................  
.................... void init_ext_eeprom() { 
....................    int1 i; 
....................  
....................    output_low(EEPROM_DI); 
....................    output_low(EEPROM_CLK); 
....................    output_high(EEPROM_SELECT);   //at25256 is cs active LOW 
....................    i=input(EEPROM_DO); 
.................... } 
....................  
.................... BOOLEAN ext_eeprom_ready() { 
....................    unsigned int8 cmd[1],i,data; 
....................  
....................    cmd[0] = 0x05;         //rdsr opcode 
....................  
....................    output_low(EEPROM_SELECT); 
....................  
....................    for(i=1;i<=8;++i) { 
....................       output_bit(EEPROM_DI, shift_left(cmd,1,0)); 
....................       output_high(EEPROM_CLK);      //data latches 
....................       output_low(EEPROM_CLK);      //back to idle 
....................    } 
....................  
....................    for(i=1;i<=8;++i) { 
....................         output_high(EEPROM_CLK);      //data latches 
....................         shift_left(&data,1,input(EEPROM_DO)); 
....................         output_low(EEPROM_CLK);              //back to idle 
....................    } 
....................    output_high(EEPROM_SELECT); 
....................    return (!(bit_test(data, 0))); 
.................... } 
....................  
....................  
.................... void write_ext_eeprom(EEPROM_ADDRESS address, unsigned int8 data) { 
....................  
....................    unsigned int8 cmd[4]; 
....................    unsigned int8 i; 
....................    cmd[2]=((address>>8)&(0xFF));   //address msb (16bit addressing) 
....................    cmd[1]=address-cmd[2];      //address lsb 
....................  
....................    do {} while (!(ext_eeprom_ready())); //wait until the eeprom is out of the previous write state, if applicable 
....................  
....................    cmd[0]=0x06; 
....................    output_low(EEPROM_SELECT); //cs is active low 
....................    for(i=1;i<=8;++i) { 
....................       output_bit(EEPROM_DI, shift_left(cmd,1,0)); 
....................       output_high(EEPROM_CLK);      //data latches 
....................       output_low(EEPROM_CLK);      //back to idle 
....................    } 
....................    output_high(EEPROM_SELECT); 
....................  
....................    cmd[0]=data; 
....................    cmd[3]=0x02;      //write opcode 
....................    output_low(EEPROM_SELECT); 
....................    for(i=1;i<=32;++i) { 
....................       output_bit(EEPROM_DI, shift_left(cmd,4,0)); 
....................       output_high(EEPROM_CLK);      //data latches 
....................       output_low(EEPROM_CLK);      //back to idle 
....................    } 
....................  
....................    output_high(EEPROM_SELECT); 
.................... } 
....................  
....................  
.................... unsigned int8 read_ext_eeprom(EEPROM_ADDRESS address) { 
....................    unsigned int8 i,data; 
....................    unsigned int8 cmd[3]; 
....................    cmd[2]=0x03;            //read opcode 
....................    cmd[1]=((address>>8)&(0xFF)); 
....................    cmd[0]=address-cmd[1]; 
....................  
....................    do {} while (!(ext_eeprom_ready())); //wait until the eeprom is out of the previous write state, if applicable 
....................    output_low(EEPROM_SELECT); 
....................    for(i=1;i<=24;++i) { 
....................       output_bit(EEPROM_DI, shift_left(cmd,3,0)); 
....................       output_high(EEPROM_CLK);      //data latches 
....................       output_low(EEPROM_CLK);      //back to idle 
....................    } 
....................  
....................    for(i=1;i<=8;++i) { 
....................         output_high(EEPROM_CLK);      //data latches 
....................         shift_left(&data,1,input(EEPROM_DO)); 
....................         output_low(EEPROM_CLK);              //back to idle 
....................    } 
....................  
....................    output_high(EEPROM_SELECT); 
....................  
....................    return(data); 
.................... } 
....................  
....................     
....................    #define __SPIFLASH_H    //prevent spiflash.h from being loaded/used 
....................    #define SPIFlashReadArray(dwAddress, pData, wLen)  read_ext_eeprom_buf(dwAddress, pData, wLen) 
....................    #define SPIFlashInit()                             init_ext_eeprom() 
....................    EEPROM_ADDRESS g_SpiFlashCurrWrite; 
....................    #define SPIFlashBeginWrite(addy)                   g_SpiFlashCurrWrite=addy 
....................    #define SPIFlashWrite(d)                           write_ext_eeprom(g_SpiFlashCurrWrite++, d) 
....................    #define SPIFlashStopWrite() 
....................    #define SPIFlashWriteBytes(dwAddress, pData, wLen) write_ext_eeprom_buf(dwAddress, pData, wLen) 
....................     
....................    // if you want TCP/IP settings saved to internal EEPROM, then comment 
....................    // out the next few lines: 
....................    #define EEInit SPIFlashInit 
....................    #define EEReadBytes(dst, src, len)  SPIFlashReadArray(src, dst, len) 
....................    #define EEWriteBytes(dst, src, len) SPIFlashWriteBytes(dst, src, len); SPIFlashStopWrite() 
....................  
.................... #elif STACK_USE_CCS_EWL3V 
....................    #include <18F67J60.h> 
....................    #include "tcpip\p18cxxx.h" 
....................    #reserve 0xE80:0xEFF   //SFR 
....................    #reserve 0xF00:0xFFF   //SFR 
....................    #use delay(clock=41666667) 
....................    #fuses NOWDT, NODEBUG, H4_SW, NOIESO, NOFCMEN, PRIMARY, ETHLED 
....................   
....................    #use rs232(baud=9600, uart1, stream=STREAM_UI, errors)  
....................  
....................    void lcd_putc(char c) 
....................    { 
....................      #if STACK_USE_PICDEM_LCD 
....................        if (c == '\f') 
....................          printf("\r\n\n"); 
....................        else 
....................          putc(c); 
....................      #endif 
....................    } 
....................    #define lcd_init() 
....................    #ifndef STACK_USE_PICDEM_LCD 
....................       #define STACK_USE_PICDEM_LCD 0   // no hardware LCD support 
....................    #endif 
....................     
....................    #define LED_ON       output_high 
....................    #define LED_OFF      output_low 
....................    #define USER_LED1    PIN_F1                 //input1 
....................    #define USER_LED2    PIN_F2                 //input2 
....................    #define USER_LED3    PIN_F3                 //input3 
....................    #define STANDARD_ADC_STRING  "AN9" 
....................    #define STANDARD_ADC_CHANNEL 9              //input4 
....................    #define BUTTON1_PRESSED() (input(PIN_F5))   //input5 
....................    #define BUTTON2_PRESSED() (input(PIN_F6))   //input6 
....................  
....................    void init_user_io(void) 
....................    { 
....................       setup_oscillator(OSC_PLL_5_DIV_3 | OSC_NORMAL); 
....................       restart_wdt(); 
....................       delay_ms(144); 
....................       restart_wdt(); 
....................     
....................       setup_adc(ADC_CLOCK_INTERNAL); 
....................       setup_adc_ports(AN0_TO_AN9); 
....................       set_adc_channel(STANDARD_ADC_CHANNEL); 
....................        
....................       setup_comparator(NC_NC_NC_NC); 
....................  
....................       output_drive(USER_LED1); 
....................       output_drive(USER_LED2); 
....................       output_drive(USER_LED3); 
....................       LED_OFF(USER_LED1); 
....................       LED_OFF(USER_LED2); 
....................       LED_OFF(USER_LED3); 
....................    } 
....................      
....................    #define __AT45DB_B__ 
....................    #define FLASH_SELECT PIN_C2 
....................    #define FLASH_CLOCK  PIN_C3 
....................    #define FLASH_DI     PIN_C5 
....................    #define FLASH_DO     PIN_C4 
....................    #define FLASH_BUFFER_SIZE    264     //bytes per page 
....................    #define FLASH_BUFFER_COUNT   4096   //page count 
....................    #include "at45db.c"  
....................        
....................    #define __SPIFLASH_H    //prevent spiflash.h from being loaded/used 
....................    #define SPIFlashReadArray(dwAddress, pData, wLen)  ext_flash_read(dwAddress, pData, wLen) 
....................    #define SPIFlashInit()                             init_ext_flash() 
....................    #define SPIFlashBeginWrite(addy)                   ext_flash_startWrite(addy) 
....................    #define SPIFlashWrite(d)                           ext_flash_continuousWrite(d) 
....................    #define SPIFlashStopWrite()                        ext_flash_flushWrites() 
....................    #define SPIFlashWriteBytes(dwAddress, pData, wLen) ext_flash_writeBytes(dwAddress, pData, wLen) 
....................     
....................    // if you want TCP/IP settings saved to internal EEPROM, then comment 
....................    // out the next few lines: 
....................    #define EEInit SPIFlashInit 
....................    #define EEReadBytes(dst, src, len)  SPIFlashReadArray(src, dst, len) 
....................    #define EEWriteBytes(dst, src, len) SPIFlashWriteBytes(dst, src, len)  
....................     
.................... #elif STACK_USE_CCS_EWL5V_REV5 
....................    #include <18F67K22.h> 
....................    #include "tcpip\p18cxxx.h" 
....................    #reserve 0xF16:0xFFF   //SFR 
....................    #use delay(clock=64M, XTAL=16M) 
....................     
....................    #use rs232(baud=9600, uart1, stream=STREAM_UI, errors) 
....................  
....................    void lcd_putc(char c) 
....................    { 
....................      #if STACK_USE_PICDEM_LCD 
....................        if (c == '\f') 
....................          printf("\r\n\n"); 
....................        else 
....................          putc(c); 
....................      #endif 
....................    } 
....................    #define lcd_init() 
....................    #ifndef STACK_USE_PICDEM_LCD 
....................       #define STACK_USE_PICDEM_LCD 0   // no hardware LCD support 
....................    #endif 
....................      
....................    #define LED_ON       output_high 
....................    #define LED_OFF      output_low 
....................    #define USER_LED1    PIN_G3                 //input1 
....................    #define USER_LED2    PIN_G4                 //input2 
....................    #define USER_LED3    PIN_A2                 //input3 
....................    #define STANDARD_ADC_STRING  "AN3" 
....................    #define STANDARD_ADC_CHANNEL 3              //input4 
....................    #define BUTTON1_PRESSED() (input(PIN_A5))   //input5 
....................    #define BUTTON2_PRESSED() (input(PIN_B5))   //input6 
....................  
....................    #define ENC_CS_IO       LATFbits.LATF2    
....................    #define ENC_CS_TRIS     TRISFbits.TRISF2 
....................    #define ENC_SCK_TRIS    TRISCbits.TRISC3 
....................    #define ENC_SDO_TRIS    TRISCbits.TRISC5 
....................    #define ENC_SDI_TRIS    TRISCbits.TRISC4 
....................    #define ENC_RST_IO      LATDbits.LATD0 
....................    #define ENC_RST_TRIS    TRISDbits.TRISD0 
....................    #define ENC_SPI_IF         PIR1bits.SSP1IF 
....................    #define ENC_SPICON1        SSP1CON1bits   //SPI1CON1 
....................    #define ENC_SPICON2        SPI1CON2 
....................    #define ENC_SPISTAT        SPI1STAT 
....................    #define ENC_SSPBUF         SSP1BUF        //SPI1BUF 
....................    #define ENC_SPICON1bits    SPI1CON1bits 
....................    #define ENC_SPICON2bits    SPI1CON2bits 
....................    #define ENC_SPISTATbits    SSP1STATbits   //SPI1STATbits   
....................  
....................    void init_user_io(void) 
....................    { 
....................       setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_2); 
....................       setup_adc_ports(sAN3); 
....................       set_adc_channel(STANDARD_ADC_CHANNEL); 
....................       output_drive(USER_LED1); 
....................       output_drive(USER_LED2); 
....................       output_drive(USER_LED3); 
....................       LED_OFF(USER_LED1); 
....................       LED_OFF(USER_LED2); 
....................       LED_OFF(USER_LED3); 
....................    } 
....................     
....................    #define __AT45DB_D__ 
....................    #define FLASH_SELECT PIN_F1 
....................    #define FLASH_CLOCK  PIN_D6 
....................    #define FLASH_DO     PIN_D5   //MISO 
....................    #define FLASH_DI     PIN_D4   //MOSI 
....................    #define FLASH_BUFFER_SIZE    264 
....................    #define FLASH_BUFFER_COUNT   4096 
....................    #include "at45db.c" 
....................        
....................    #define __SPIFLASH_H    //prevent spiflash.h from being loaded/used 
....................    #define SPIFlashReadArray(dwAddress, pData, wLen)  ext_flash_read(dwAddress, pData, wLen) 
....................    #define SPIFlashInit()                             init_ext_flash() 
....................    #define SPIFlashBeginWrite(addy)                   ext_flash_startWrite(addy) 
....................    #define SPIFlashWrite(d)                           ext_flash_continuousWrite(d) 
....................    #define SPIFlashStopWrite()                        ext_flash_flushWrites() 
....................    #define SPIFlashWriteBytes(dwAddress, pData, wLen) ext_flash_writeBytes(dwAddress, pData, wLen) 
....................     
....................    // if you want TCP/IP settings saved to internal EEPROM, then comment 
....................    // out the next few lines: 
....................    #define EEInit SPIFlashInit 
....................    #define EEReadBytes(dst, src, len)  SPIFlashReadArray(src, dst, len) 
....................    #define EEWriteBytes(dst, src, len) SPIFlashWriteBytes(dst, src, len) 
....................  
.................... /* currently working on this - not functional */ 
.................... #elif STACK_USE_CCS_PICNET 
....................    #include <18F6722.h> 
....................    #include "tcpip\p18cxxx.h" 
....................    // SFR? 
....................    #use delay (clock=40000000) 
....................    #fuses H4, NOLVP, NOWDT, NODEBUG 
....................     
....................    #use rs232(baud=9600, uart1, stream=STREAM_UI, errors) 
....................  
....................    #define STACK_USE_PICDEM_LCD TRUE 
....................    #define BUTTON1_PRESSED()  (!input(PIN_B0)) 
....................    #define BUTTON2_PRESSED()  (!input(PIN_B1)) 
....................    #define USER_LED1    PIN_B2 
....................    #define USER_LED2    PIN_B4 
....................    #define LED_ON       output_low 
....................    #define LED_OFF      output_high 
....................    #define STANDARD_ADC_STRING  "AN0" 
....................    #define STANDARD_ADC_CHANNEL 0 
....................    #define SECONDARY_ADC_STRING "AN1" 
....................    #define SECONDARY_ADC_CHANNEL 1 
....................     
....................    #define LCD_ENABLE_PIN  PIN_D0 
....................    #define LCD_RS_PIN      PIN_D1 
....................    #define LCD_RW_PIN      PIN_D2 
....................    #define LCD_DATA4       PIN_D4 
....................    #define LCD_DATA5       PIN_D5 
....................    #define LCD_DATA6       PIN_D6 
....................    #define LCD_DATA7       PIN_D7 
....................     
....................    #ifndef STACK_USE_PICDEM_LCD 
....................       #define STACK_USE_PICDEM_LCD 1 
....................    #endif 
....................    #if STACK_USE_PICDEM_LCD 
....................       #include "lcd.c" 
....................    #endif 
....................     
....................    void init_user_io(void) { 
....................       setup_adc(ADC_CLOCK_INTERNAL ); 
....................       setup_adc_ports(ANALOG_AN0_TO_AN1); 
....................       set_adc_channel(STANDARD_ADC_CHANNEL); 
....................       //*0xF92=*0xF92 | 3;            //a0 and a1 input (for ADC) 
....................       //*0xF93=(*0xF93 & 0xEB) | 3;   //B0 and B1 input, B2 and B4 output 
....................       output_drive(USER_LED1); 
....................       output_drive(USER_LED2); 
....................       LED_OFF(USER_LED1); 
....................       LED_OFF(USER_LED2); 
....................    } 
....................  
.................... #else 
....................  #error You need to define your custom hardware 
.................... #endif 
....................  
.................... #ifndef LED_ACTIVITY_BLINK 
.................... #define LED_ACTIVITY_BLINK() 
.................... #endif 
....................  
.................... #if !STACK_USE_PICDEM_LCD 
....................    #define lcd_putc(c) 
....................    #define lcd_init() 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_WIFI 
....................    #define STACK_USE_CCS_GRATUITOUS_ARP 
....................     
....................    #define WIFI_CCS_RESET_ON_MODULE_HANG 
....................     
....................    #define WF_USE_TX_POWER_CONTROL_FUNCTIONS 
....................  
....................    #define WF_FORCE_NO_PS_POLL 
....................      
....................    //#define FORCE_ADHOC_ACTIVATED !input(PIN_G4)     //a certain button press can force ad hoc mode regardless of EE setting 
....................     
....................    #define STACK_USE_DNS_SERVER   //strongly recommended if using ad-hoc mode 
....................    #define STACK_USE_DHCP_SERVER  //strongly recommended if using ad-hoc mode 
.................... #endif 
....................  
.................... #ifndef STACK_USE_CCS_INI 
....................  #define STACK_USE_CCS_INI 0 
....................  #define UITask() 
.................... #endif 
....................  
.................... #if STACK_USE_CCS_INI 
....................    #define STACK_USE_DHCP_CLIENT 
.................... #endif 
....................  
.................... // clock definitions required by Microchip's TCP/IP Stack. 
.................... #if defined(__PCH__) //pic18 
....................    #define GetSystemClock()      getenv("CLOCK") 
....................    #define GetInstructionClock()   (GetSystemClock()/4) 
....................    #define GetPeripheralClock()   (unsigned int32)GetInstructionClock() 
.................... #else //pic24,dspic30,dspic33f 
....................    #define GetSystemClock()       getenv("CLOCK") 
....................    #define GetInstructionClock()  (GetSystemClock()/2) 
....................    #define GetPeripheralClock()   (GetSystemClock()/2) 
.................... #endif 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define MIN(a,b)  ((a > b) ? b : a) 
....................  
.................... #include "tcpip/StackTsk2.h" 
.................... // 'glue' file for using Microchip's TCP/IP stack inside CCS C Compiler without 
.................... // a linker.   
.................... // Also includes some macros/defines for porting older V3 stack to this current 
.................... // stack. 
.................... // Also provides extra routines written by CCS to improve the stack. 
....................  
.................... #ifndef __CCS_STACKTSK2_H__ 
.................... #define __CCS_STACKTSK2_H__ 
....................  
.................... #if !defined(debug_mpfs2) 
....................  #define debug_mpfs2(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) 
.................... #else 
....................  #define __DO_DEBUG_MPFS2 
.................... #endif 
....................  
.................... #if defined(__PCH__) && !defined(__18CXX) 
....................  #define __18CXX 
.................... #endif 
....................  
.................... #define SIZEOF_MAC_HEADER 14 
....................  
.................... // override delay.c/delay.h with CCS compatible code 
.................... #define __DELAY_H 
.................... #define Delay10us(x) delay_us((uint16_t)10*(uint16_t)x) 
.................... #define DelayMs(x)   delay_ms(x) 
....................  
.................... #define __WF_DEBUG_STRINGS_H  //don't include this file 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
07BEE:  MOVFF  260,262
07BF2:  MOVFF  25F,261
07BF6:  MOVFF  262,03
07BFA:  MOVLB  2
07BFC:  MOVFF  261,FE9
07C00:  MOVFF  262,FEA
07C04:  MOVF   FEF,F
07C06:  BZ    7C14
07C08:  INCF   x61,F
07C0A:  BTFSC  FD8.2
07C0C:  INCF   x62,F
07C0E:  MOVLB  0
07C10:  BRA    7BF6
07C12:  MOVLB  2
....................    return(sc - s); 
07C14:  MOVF   x5F,W
07C16:  SUBWF  x61,W
07C18:  MOVWF  00
07C1A:  MOVF   x60,W
07C1C:  SUBWFB x62,W
07C1E:  MOVWF  03
07C20:  MOVFF  00,01
07C24:  MOVLB  0
07C26:  GOTO   7EC6 (RETURN)
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... #ifdef BYTE 
.................... #undef BYTE 
.................... #endif 
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
.................... #include "Compiler.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Compiler and hardware specific definitions 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Compiler.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, PIC24E, dsPIC30F, dsPIC33F,  
....................  *               dsPIC33E, PIC32 
....................  * Compiler:        Microchip C32 v1.00 or higher 
....................  *               Microchip C30 v3.01 or higher 
....................  *               Microchip C18 v3.13 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights  
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and  
....................  * distribute:  
....................  * (i)  the Software when embedded on a Microchip microcontroller or  
....................  *      digital signal controller product ("Device") which is  
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c and  
....................  *      ENC28J60.h ported to a non-Microchip device used in  
....................  *      conjunction with a Microchip ethernet controller for the  
....................  *      sole purpose of interfacing with the ethernet controller.  
....................  * 
....................  * You should refer to the license agreement accompanying this  
....................  * Software for additional information regarding your rights and  
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT  
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT  
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A  
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL  
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR  
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF  
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS  
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER  
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT  
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * 10/03/2006   Original, copied from old Compiler.h 
....................  * 11/07/2007   Reorganized and simplified 
....................  * 03/31/2010   Removed dependency on WORD and DWORD typedefs 
....................  * 04/14/2010   Added defines to uniquely identify each compiler 
....................  ********************************************************************/ 
.................... #ifndef __COMPILER_H 
.................... #define __COMPILER_H 
....................  
.................... // Include proper device header file 
.................... #if defined(__18CXX) && !defined(HI_TECH_C)    
....................    // PIC18 processor with Microchip C18 compiler 
....................     #define COMPILER_MPLAB_C18 
....................     #include <p18cxxx.h> 
.................... // CCS PCH C Compiler to Microchip C18 Compiler compatability layer. 
....................  
.................... #ifndef __P18CXXXX_H__ 
.................... #define __P18CXXXX_H__ 
....................  
.................... #ifndef __18CXX 
.................... #define __18CXX 
.................... #endif 
....................  
.................... //#zero_local_ram 
.................... #zero_ram 
....................  
....................  
.................... #device PASS_STRINGS=IN_RAM 
.................... #device CONST=READ_ONLY 
....................  
.................... #case 
.................... #type signed 
.................... #type short=16 int=16 long=32 
....................  
.................... #define _asm #asm 
.................... #define _endasm #endasm 
....................  
.................... /* usualy 
.................... #define GetSystemClock()      getenv("CLOCK") 
.................... #define GetInstructionClock()   (GetSystemClock()/4) 
.................... #define GetPeripheralClock()   (unsigned int32)GetInstructionClock() 
.................... */ 
....................  
.................... #if getenv("DEVICE") == "PIC18F97J60" 
....................  #define __18F97J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F96J65" 
....................  #define __18F96J65) 
.................... #elif getenv("DEVICE") == "PIC18F96J60" 
....................  #define __18F96J60 
.................... #elif getenv("DEVICE") == "PIC18F87J60" 
....................  #define __18F87J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J60" 
....................  #define __18F86J60 
.................... #elif getenv("DEVICE") == "PIC18F67J60" 
....................  #define __18F67J60 
....................  #include "PIC18F67J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F66J65" 
....................  #define __18F66J65 
.................... #elif getenv("DEVICE") == "PIC18F66J60" 
....................  #define __18F66J60 
.................... #elif getenv("DEVICE") == "PIC18F67K22" 
....................  #define __18F67K22 
....................  #include "PIC18F67K22_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F4620" 
....................  #define __18F4620 
....................  #include "PIC18F4620_registers.h" 
.................... #else 
....................    #error Do this for your chip 
.................... #endif 
....................  
.................... #if defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) 
....................    #reserve 0xE80:0xEFF 
....................    #reserve 0xF00:0xFFF 
.................... #endif 
....................  
.................... #if defined(TRUE) 
....................    #undef TRUE 
.................... #endif 
....................  
.................... #if defined(FALSE) 
....................    #undef FALSE 
.................... #endif 
....................  
.................... #if defined(BYTE) 
....................    #undef BYTE 
.................... #endif 
....................  
....................       #define Reset()            reset_cpu() 
....................         #define far 
....................         #define ClrWdt()         restart_wdt() 
....................       #define Nop()            delay_cycles(1)       
....................  
.................... #define __CCS__ 
....................  
.................... //signed int8 memcmppgm2ram(void * s1, rom char *s2, unsigned int8 n); 
.................... signed int8 strcmppgm2ram(char *s1, __ADDRESS__ s2); 
.................... char *strchrpgm(__ADDRESS__ s, unsigned int8 c); 
.................... char *strstrrampgm(char *s1, __ADDRESS__ s2); 
.................... unsigned int8 strlenpgm(__ADDRESS__ s); 
.................... void memcpypgm2ram(unsigned int8 *d, __ADDRESS__ s, unsigned int16 n); 
.................... //char* strupr(char *s);   now in string.h 
.................... void strcpypgm2ram(char *d, __ADDRESS__ s); 
.................... #endif 
....................  
.................... #elif defined(__PICC18__) && defined(HI_TECH_C)    
....................    // PIC18 processor with (Microchip) HI-TECH PICC-18 compiler 
....................    #if !defined(__18CXX) 
....................       #define __18CXX 
....................    #endif 
....................     #define COMPILER_HITECH_PICC18 
....................    #include <htc.h> 
.................... #elif (defined(__PIC24F__) || defined(__PIC24FK__)) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Fxxxx.h> 
.................... #elif defined(__PIC24H__) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24H processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Hxxxx.h> 
.................... #elif defined(__PIC24E__) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24E processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Exxxx.h> 
.................... #elif defined(__dsPIC33F__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC33F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p33Fxxxx.h> 
.................... #elif defined(__dsPIC33E__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC33E processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p33Exxxx.h> 
.................... #elif defined(__dsPIC30F__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC30F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p30fxxxx.h> 
.................... #elif defined(__C30__)      // Microchip C30 compiler, but targeting "generic-16bit" processor. 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p30sim.h> 
....................    // Define some useful inline assembly functions which are normally in the  
....................    // processor header files, but absent from the generic p30sim.h file. 
....................    #if !defined(Nop) 
....................       #define Nop()    __builtin_nop() 
....................       #define ClrWdt() {__asm__ volatile ("clrwdt");} 
....................       #define Sleep()  {__asm__ volatile ("pwrsav #0");} 
....................       #define Idle()   {__asm__ volatile ("pwrsav #1");} 
....................    #endif 
.................... #elif defined(__PIC32MX__)   // Microchip C32 compiler 
....................    #if !defined(__C32__) 
....................       #define __C32__ 
....................    #endif 
....................     #define COMPILER_MPLAB_C32 
....................    #include <p32xxxx.h> 
....................    #include <plib.h> 
.................... #else 
....................    #error Unknown processor or compiler.  See Compiler.h 
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... // Base RAM and ROM pointer types for given architecture 
.................... #if defined(__PCH__) || defined(__PCD__) 
....................    #define PTR_BASE      unsigned int16 
....................    #define ROM_PTR_BASE   unsigned int32 
.................... #elif defined(__PIC32MX__) 
....................    #define PTR_BASE      unsigned long 
....................    #define ROM_PTR_BASE   unsigned long 
.................... #elif defined(__C30__) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned short 
.................... #elif defined(COMPILER_MPLAB_C18) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned short long 
.................... #elif defined(COMPILER_HITECH_PICC18) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned long 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all except Microchip MPLAB C Compiler for PIC18 MCUs (C18) 
.................... #if !defined(COMPILER_MPLAB_C18) 
....................    #define memcmppgm2ram(a,b,c)   memcmp(a,b,c) 
....................    #define strcmppgm2ram(a,b)      strcmp(a,b) 
....................   #if defined(__PCD__) 
....................    #warning temporary 4.121 fix 
....................    #define memcpypgm2ram(a,b,c)   memcpy(a,b|0x8000,c) 
....................   #else 
....................    #define memcpypgm2ram(a,b,c)   memcpy(a,b,c) 
....................   #endif 
....................    #define strcpypgm2ram(a,b)      strcpy(a,b) 
....................    #define strncpypgm2ram(a,b,c)   strncpy(a,b,c) 
....................    #define strstrrampgm(a,b)      strstr(a,b) 
....................    #define   strlenpgm(a)         strlen(a) 
....................    #define strchrpgm(a,b)         strchr(a,b) 
....................    #define strcatpgm2ram(a,b)      strcat(a,b) 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all 8-bit products 
.................... // (PIC18) 
.................... #if defined(__18CXX) 
....................    #define   __attribute__(a) 
....................  
....................     #define FAR                         far 
....................  
....................    // Microchip C18 specific defines 
....................    #if defined(COMPILER_MPLAB_C18) 
....................        #define ROM                    rom 
....................    #endif 
....................     
....................    // HI TECH PICC-18 specific defines 
....................    #if defined(COMPILER_HITECH_PICC18) 
....................        #define ROM                    const 
....................       #define rom 
....................        #define Nop()                  asm("NOP"); 
....................       #define ClrWdt()            asm("CLRWDT"); 
....................        #define Reset()               asm("RESET"); 
....................    #endif 
....................      
.................... // Definitions that apply to all 16-bit and 32-bit products 
.................... // (PIC24F, PIC24H, dsPIC30F, dsPIC33F, and PIC32) 
.................... #else 
....................    #define   ROM                  const 
....................  
....................    // 16-bit specific defines (PIC24F, PIC24H, dsPIC30F, dsPIC33F) 
....................    #if defined(__C30__) && !defined(__PCD__) 
....................       #define Reset()            asm("reset") 
....................         #define FAR                 __attribute__((far)) 
....................    #endif 
....................  
....................    // 32-bit specific defines (PIC32) 
....................    #if defined(__PIC32MX__) 
....................       #define persistent 
....................       #define far 
....................         #define FAR 
....................       #define Reset()            SoftReset() 
....................       #define ClrWdt()         (WDTCONSET = _WDTCON_WDTCLR_MASK) 
....................  
....................       // MPLAB C Compiler for PIC32 MCUs version 1.04 and below don't have a  
....................       // Nop() function. However, version 1.05 has Nop() declared as _nop(). 
....................       #if !defined(Nop) && (__C32_VERSION__ <= 104) 
....................          #define Nop()            asm("nop") 
....................       #endif 
....................    #endif 
.................... #endif 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "HardwareProfile.h" 
.................... // hardwareprofile.h 
....................  
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #if STACK_USE_CCS_EWLWIFIB || STACK_USE_CCS_EWLWIFIG 
....................  
....................    #bit WF_CS_TRIS1   =     0xF96.1 //E1 
....................    #define WF_CS_TRIS WF_CS_TRIS1 
....................    #bit WF_CS_IO     =  0xF8D.1    //LatE1 
....................    #bit WF_SDI_TRIS  =  0xF94.4    // (TRISCbits.TRISC4) 
....................    #bit WF_SCK_TRIS  =  0xF94.3    // (TRISCbits.TRISC3) 
....................    #bit WF_SDO_TRIS  =  0xF94.5    // (TRISCbits.TRISC5) 
....................    #bit WF_RESET_TRIS=  0xF93.1    //(TRISBbits.TRISB1) 
....................    #bit WF_RESET_IO  =  0xF8A.1     //(LATBbits.LATB1)   
....................    #bit WF_INT_TRIS  =  0xF93.0     // (TRISBbits.TRISB0)  // INT1 
....................    #bit WF_INT_IO    =  0xF81.0   //(PORTBbits.RB0)  
....................    #bit WF_HIBERNATE_TRIS= 0xF93.2  //(TRISBbits.TRISB2)  
....................    #bit   WF_HIBERNATE_IO=  0xF81.2    //(PORTBbits.RB2) 
....................     
....................    #bit WF_INT_EDGE  =  0xFF1.6      //(INTCON2bits.INTEDG0) 
....................    #bit WF_INT_IE    =  0xFF2.4   //(INTCONbits.INT0IE) 
....................    #bit WF_INT_IF    =  0xFF2.1   //(INTCONbits.INT0IF) 
....................    #define WF_SSPBUF  (SSP1BUF) 
....................    #define WF_SPISTAT  (SSP1STATbits) 
....................    #define WF_SPISTATbits SSP1STATbits     //(SSP1STATbits) 
....................    #define WF_SPICON1  (SSP1CON1bits) 
....................    #define WF_SPICON1bits WF_SPICON1    // (SSP1CON1bits) 
....................    #define WF_SPICON2  (SSP1CON2bits) 
....................    #bit WF_SPI_IE    =   0xF9D.3  //(PIE1bits.SSPIE) 
....................    #bit WF_SPI_IP    =   0xF9F.3  //(IPR1bits.SSPIP) 
....................    #bit WF_SPI_IF    =   0xF9E.3  //(PIR1bits.SSPIF) 
....................     
.................... #else 
....................  
.................... //#error define necessary hardware for TCPIP stack 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
.................... /* 
....................    TCPIPConfig.h used by all of CCS's TCP/IP examples. 
....................     
....................    Usually you use a Microchip tool to generate one of these files for 
....................    your projects.  But since we are using this .h for many projects, 
....................    some stuff is conditionally compiled out or commented out, and then 
....................    defined in the application code instead. 
.................... */ 
.................... /********************************************************************* 
....................  * 
....................  *   Microchip TCP/IP Stack Demo Application Configuration Header 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIPConfig.h 
....................  * Dependencies:    Microchip TCP/IP Stack 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.10 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.34 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder      10/04/2006   Original 
....................  * Ken Hesky            07/01/2008  Added ZG2100-specific features 
....................  * SG                   03/25/2009  Added ZGLinkMgrII specific features 
....................  ********************************************************************/ 
.................... #ifndef __TCPIPCONFIG_H 
.................... #define __TCPIPCONFIG_H 
....................  
.................... #include "GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... #ifdef BYTE 
.................... #undef BYTE 
.................... #endif 
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
.................... #include "Compiler.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Compiler and hardware specific definitions 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Compiler.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, PIC24E, dsPIC30F, dsPIC33F,  
....................  *               dsPIC33E, PIC32 
....................  * Compiler:        Microchip C32 v1.00 or higher 
....................  *               Microchip C30 v3.01 or higher 
....................  *               Microchip C18 v3.13 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights  
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and  
....................  * distribute:  
....................  * (i)  the Software when embedded on a Microchip microcontroller or  
....................  *      digital signal controller product ("Device") which is  
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c and  
....................  *      ENC28J60.h ported to a non-Microchip device used in  
....................  *      conjunction with a Microchip ethernet controller for the  
....................  *      sole purpose of interfacing with the ethernet controller.  
....................  * 
....................  * You should refer to the license agreement accompanying this  
....................  * Software for additional information regarding your rights and  
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT  
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT  
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A  
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL  
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR  
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF  
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS  
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER  
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT  
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * 10/03/2006   Original, copied from old Compiler.h 
....................  * 11/07/2007   Reorganized and simplified 
....................  * 03/31/2010   Removed dependency on WORD and DWORD typedefs 
....................  * 04/14/2010   Added defines to uniquely identify each compiler 
....................  ********************************************************************/ 
.................... #ifndef __COMPILER_H 
.................... #define __COMPILER_H 
....................  
.................... // Include proper device header file 
.................... #if defined(__18CXX) && !defined(HI_TECH_C)    
....................    // PIC18 processor with Microchip C18 compiler 
....................     #define COMPILER_MPLAB_C18 
....................     #include <p18cxxx.h> 
.................... #elif defined(__PICC18__) && defined(HI_TECH_C)    
....................    // PIC18 processor with (Microchip) HI-TECH PICC-18 compiler 
....................    #if !defined(__18CXX) 
....................       #define __18CXX 
....................    #endif 
....................     #define COMPILER_HITECH_PICC18 
....................    #include <htc.h> 
.................... #elif (defined(__PIC24F__) || defined(__PIC24FK__)) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Fxxxx.h> 
.................... #elif defined(__PIC24H__) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24H processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Hxxxx.h> 
.................... #elif defined(__PIC24E__) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24E processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Exxxx.h> 
.................... #elif defined(__dsPIC33F__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC33F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p33Fxxxx.h> 
.................... #elif defined(__dsPIC33E__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC33E processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p33Exxxx.h> 
.................... #elif defined(__dsPIC30F__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC30F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p30fxxxx.h> 
.................... #elif defined(__C30__)      // Microchip C30 compiler, but targeting "generic-16bit" processor. 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p30sim.h> 
....................    // Define some useful inline assembly functions which are normally in the  
....................    // processor header files, but absent from the generic p30sim.h file. 
....................    #if !defined(Nop) 
....................       #define Nop()    __builtin_nop() 
....................       #define ClrWdt() {__asm__ volatile ("clrwdt");} 
....................       #define Sleep()  {__asm__ volatile ("pwrsav #0");} 
....................       #define Idle()   {__asm__ volatile ("pwrsav #1");} 
....................    #endif 
.................... #elif defined(__PIC32MX__)   // Microchip C32 compiler 
....................    #if !defined(__C32__) 
....................       #define __C32__ 
....................    #endif 
....................     #define COMPILER_MPLAB_C32 
....................    #include <p32xxxx.h> 
....................    #include <plib.h> 
.................... #else 
....................    #error Unknown processor or compiler.  See Compiler.h 
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... #include <stdlib.h> 
.................... #include <string.h> 
....................  
....................  
.................... // Base RAM and ROM pointer types for given architecture 
.................... #if defined(__PCH__) || defined(__PCD__) 
....................    #define PTR_BASE      unsigned int16 
....................    #define ROM_PTR_BASE   unsigned int32 
.................... #elif defined(__PIC32MX__) 
....................    #define PTR_BASE      unsigned long 
....................    #define ROM_PTR_BASE   unsigned long 
.................... #elif defined(__C30__) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned short 
.................... #elif defined(COMPILER_MPLAB_C18) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned short long 
.................... #elif defined(COMPILER_HITECH_PICC18) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned long 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all except Microchip MPLAB C Compiler for PIC18 MCUs (C18) 
.................... #if !defined(COMPILER_MPLAB_C18) 
....................    #define memcmppgm2ram(a,b,c)   memcmp(a,b,c) 
....................    #define strcmppgm2ram(a,b)      strcmp(a,b) 
....................   #if defined(__PCD__) 
....................    #warning temporary 4.121 fix 
....................    #define memcpypgm2ram(a,b,c)   memcpy(a,b|0x8000,c) 
....................   #else 
....................    #define memcpypgm2ram(a,b,c)   memcpy(a,b,c) 
....................   #endif 
....................    #define strcpypgm2ram(a,b)      strcpy(a,b) 
....................    #define strncpypgm2ram(a,b,c)   strncpy(a,b,c) 
....................    #define strstrrampgm(a,b)      strstr(a,b) 
....................    #define   strlenpgm(a)         strlen(a) 
....................    #define strchrpgm(a,b)         strchr(a,b) 
....................    #define strcatpgm2ram(a,b)      strcat(a,b) 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all 8-bit products 
.................... // (PIC18) 
.................... #if defined(__18CXX) 
....................    #define   __attribute__(a) 
....................  
....................     #define FAR                         far 
....................  
....................    // Microchip C18 specific defines 
....................    #if defined(COMPILER_MPLAB_C18) 
....................        #define ROM                    rom 
....................    #endif 
....................     
....................    // HI TECH PICC-18 specific defines 
....................    #if defined(COMPILER_HITECH_PICC18) 
....................        #define ROM                    const 
....................       #define rom 
....................        #define Nop()                  asm("NOP"); 
....................       #define ClrWdt()            asm("CLRWDT"); 
....................        #define Reset()               asm("RESET"); 
....................    #endif 
....................      
.................... // Definitions that apply to all 16-bit and 32-bit products 
.................... // (PIC24F, PIC24H, dsPIC30F, dsPIC33F, and PIC32) 
.................... #else 
....................    #define   ROM                  const 
....................  
....................    // 16-bit specific defines (PIC24F, PIC24H, dsPIC30F, dsPIC33F) 
....................    #if defined(__C30__) && !defined(__PCD__) 
....................       #define Reset()            asm("reset") 
....................         #define FAR                 __attribute__((far)) 
....................    #endif 
....................  
....................    // 32-bit specific defines (PIC32) 
....................    #if defined(__PIC32MX__) 
....................       #define persistent 
....................       #define far 
....................         #define FAR 
....................       #define Reset()            SoftReset() 
....................       #define ClrWdt()         (WDTCONSET = _WDTCON_WDTCLR_MASK) 
....................  
....................       // MPLAB C Compiler for PIC32 MCUs version 1.04 and below don't have a  
....................       // Nop() function. However, version 1.05 has Nop() declared as _nop(). 
....................       #if !defined(Nop) && (__C32_VERSION__ <= 104) 
....................          #define Nop()            asm("nop") 
....................       #endif 
....................    #endif 
.................... #endif 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... // ======================================================================= 
.................... //   Application Options 
.................... // ======================================================================= 
....................  
.................... /* Application Level Module Selection 
....................  *   Uncomment or comment the following lines to enable or 
....................  *   disabled the following high-level application modules. 
....................  */ 
.................... //#define STACK_USE_UART               // Application demo using UART for IP address display and stack configuration 
.................... //#define STACK_USE_UART2TCP_BRIDGE      // UART to TCP Bridge application example 
.................... //#define STACK_USE_IP_GLEANING 
.................... //#define STACK_USE_ICMP_SERVER         // Ping query and response capability 
.................... //#define STACK_USE_ICMP_CLIENT         // Ping transmission capability 
.................... //#define STACK_USE_HTTP_SERVER         // Old HTTP server 
.................... //#define STACK_USE_HTTP2_SERVER         // New HTTP server with POST, Cookies, Authentication, etc. 
.................... //#define STACK_USE_SSL_SERVER         // SSL server socket support (Requires SW300052) 
.................... //#define STACK_USE_SSL_CLIENT         // SSL client socket support (Requires SW300052) 
.................... //#define STACK_USE_AUTO_IP               // Dynamic link-layer IP address automatic configuration protocol 
.................... //#define STACK_USE_DHCP_CLIENT         // Dynamic Host Configuration Protocol client for obtaining IP address and other parameters 
.................... //#define STACK_USE_DHCP_SERVER         // Single host DHCP server 
.................... //#define STACK_USE_FTP_SERVER         // File Transfer Protocol (old) 
.................... //#define STACK_USE_SMTP_CLIENT         // Simple Mail Transfer Protocol for sending email 
.................... //#define STACK_USE_SNMP_SERVER         // Simple Network Management Protocol v2C Community Agent 
.................... //#define STACK_USE_SNMPV3_SERVER         // Simple Network Management Protocol v3 Agent 
.................... //#define STACK_USE_TFTP_CLIENT         // Trivial File Transfer Protocol client 
.................... //#define STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE   // HTTP Client example in GenericTCPClient.c 
.................... //#define STACK_USE_GENERIC_TCP_SERVER_EXAMPLE   // ToUpper server example in GenericTCPServer.c 
.................... //#define STACK_USE_TELNET_SERVER         // Telnet server 
.................... //#define STACK_USE_ANNOUNCE            // Microchip Embedded Ethernet Device Discoverer server/client 
.................... //#define STACK_USE_DNS               // Domain Name Service Client for resolving hostname strings to IP addresses 
.................... //#define STACK_USE_DNS_SERVER         // Domain Name Service Server for redirection to the local device 
.................... //#define STACK_USE_NBNS               // NetBIOS Name Service Server for repsonding to NBNS hostname broadcast queries 
.................... //#define STACK_USE_REBOOT_SERVER         // Module for resetting this PIC remotely.  Primarily useful for a Bootloader. 
.................... //#define STACK_USE_SNTP_CLIENT         // Simple Network Time Protocol for obtaining current date/time from Internet 
.................... //#define STACK_USE_UDP_PERFORMANCE_TEST   // Module for testing UDP TX performance characteristics.  NOTE: Enabling this will cause a huge amount of UDP broadcast packets to flood your network on the discard port.  Use care when enabling this on production networks, especially with VPNs (could tunnel broadcast traffic across a limited bandwidth connection). 
.................... //#define STACK_USE_TCP_PERFORMANCE_TEST   // Module for testing TCP TX performance characteristics 
.................... //#define STACK_USE_DYNAMICDNS_CLIENT      // Dynamic DNS client updater module 
.................... //#define STACK_USE_BERKELEY_API         // Berekely Sockets APIs are available 
.................... //#define STACK_USE_ZEROCONF_LINK_LOCAL   // Zeroconf IPv4 Link-Local Addressing 
.................... //#define STACK_USE_ZEROCONF_MDNS_SD      // Zeroconf mDNS and mDNS service discovery 
....................  
....................  
.................... // ======================================================================= 
.................... //   Data Storage Options 
.................... // ======================================================================= 
....................  
.................... /* MPFS Configuration 
....................  *   MPFS is automatically included when required for other 
....................  *   applications.  If your custom application requires it 
....................  *   otherwise, uncomment the appropriate selection. 
....................  */ 
.................... //#define STACK_USE_MPFS 
.................... //#define STACK_USE_MPFS2 
....................  
.................... /* MPFS Storage Location 
....................  *   If html pages are stored in internal program memory, 
....................  *   comment both MPFS_USE_EEPROM and MPFS_USE_SPI_FLASH, then 
....................  *   include an MPFS image (.c or .s file) in the project. 
....................  *   If html pages are stored in external memory, uncomment the 
....................  *   appropriate definition. 
....................  * 
....................  *   Supported serial flash parts include the SST25VFxxxB series. 
....................  */ 
.................... //#define MPFS_USE_EEPROM 
.................... //#define MPFS_USE_SPI_FLASH 
....................  
.................... /* EEPROM Addressing Selection 
....................  *   If using the 1Mbit EEPROM, uncomment this line 
....................  */ 
.................... //#define USE_EEPROM_25LC1024 
....................  
.................... /* EEPROM Reserved Area 
....................  *   Number of EEPROM bytes to be reserved before MPFS storage starts. 
....................  *   These bytes host application configurations such as IP Address, 
....................  *   MAC Address, and any other required variables. 
....................  * 
....................  *   For MPFS Classic, this setting must match the Reserved setting 
....................  *    on the Advanced Settings page of the MPFS2 Utility. 
....................  */ 
.................... //#define MPFS_RESERVE_BLOCK            #error do this 
....................  
.................... /* MPFS File Handles 
....................  *   Maximum number of simultaneously open MPFS2 files. 
....................  *   For MPFS Classic, this has no effect. 
....................  */ 
.................... //#define MAX_MPFS_HANDLES            (7ul) 
....................  
....................  
.................... // ======================================================================= 
.................... //   Network Addressing Options 
.................... // ======================================================================= 
....................  
.................... /* Default Network Configuration 
....................  *   These settings are only used if data is not found in EEPROM. 
....................  *   To clear EEPROM, hold BUTTON0, reset the board, and continue 
....................  *   holding until the LEDs flash.  Release, and reset again. 
....................  */ 
.................... #define MY_DEFAULT_HOST_NAME            "CCS_EXAMPLES" 
....................  
.................... /*#define MY_DEFAULT_MAC_BYTE1            (0x00)   // Use the default of 00-04-A3-00-00-00 
.................... #define MY_DEFAULT_MAC_BYTE2            (0x04)   // if using an ENCX24J600, MRF24WB0M, or 
.................... #define MY_DEFAULT_MAC_BYTE3            (0xA3)   // PIC32MX6XX/7XX internal Ethernet  
.................... #define MY_DEFAULT_MAC_BYTE4            (0x00)   // controller and wish to use the  
.................... #define MY_DEFAULT_MAC_BYTE5            (0x00)   // internal factory programmed MAC 
.................... #define MY_DEFAULT_MAC_BYTE6            (0x00)   // address instead. */ 
....................  
.................... #define MY_DEFAULT_MAC_BYTE1            (0x00)   // Use the default of 00-04-A3-00-00-00 
.................... #define MY_DEFAULT_MAC_BYTE2            (0x20)   // if using an ENCX24J600, MRF24WB0M, or 
.................... #define MY_DEFAULT_MAC_BYTE3            (0x30)   // PIC32MX6XX/7XX internal Ethernet  
.................... #define MY_DEFAULT_MAC_BYTE4            (0x40)   // controller and wish to use the  
.................... #define MY_DEFAULT_MAC_BYTE5            (0x50)   // internal factory programmed MAC 
.................... #define MY_DEFAULT_MAC_BYTE6            (0x60)   // address instead. 
....................  
.................... #define MY_DEFAULT_IP_ADDR_BYTE1        (192ul) 
.................... #define MY_DEFAULT_IP_ADDR_BYTE2        (168ul) 
.................... #define MY_DEFAULT_IP_ADDR_BYTE3        (100ul) 
.................... #define MY_DEFAULT_IP_ADDR_BYTE4        (120ul) 
....................  
.................... #define MY_DEFAULT_MASK_BYTE1           (255ul) 
.................... #define MY_DEFAULT_MASK_BYTE2           (255ul) 
.................... #define MY_DEFAULT_MASK_BYTE3           (255ul) 
.................... #define MY_DEFAULT_MASK_BYTE4           (0ul) 
....................  
.................... #define MY_DEFAULT_GATE_BYTE1           (192ul) 
.................... #define MY_DEFAULT_GATE_BYTE2           (168ul) 
.................... #define MY_DEFAULT_GATE_BYTE3           (100ul) 
.................... #define MY_DEFAULT_GATE_BYTE4           (1ul) 
....................  
.................... #define MY_DEFAULT_PRIMARY_DNS_BYTE1   (192ul) 
.................... #define MY_DEFAULT_PRIMARY_DNS_BYTE2   (168ul) 
.................... #define MY_DEFAULT_PRIMARY_DNS_BYTE3   (100ul) 
.................... #define MY_DEFAULT_PRIMARY_DNS_BYTE4   (1ul) 
....................  
.................... #define MY_DEFAULT_SECONDARY_DNS_BYTE1   (0ul) 
.................... #define MY_DEFAULT_SECONDARY_DNS_BYTE2   (0ul) 
.................... #define MY_DEFAULT_SECONDARY_DNS_BYTE3   (0ul) 
.................... #define MY_DEFAULT_SECONDARY_DNS_BYTE4   (0ul) 
....................  
.................... // ======================================================================= 
.................... //   PIC32MX7XX/6XX MAC Layer Options 
.................... //   If not using a PIC32MX7XX/6XX device, ignore this section. 
.................... // ======================================================================= 
.................... /*#define   ETH_CFG_LINK         0      // set to 1 if you need to config the link to specific following parameters 
....................                               // otherwise the default connection will be attempted 
....................                               // depending on the selected PHY 
....................    #define   ETH_CFG_AUTO      1      // use auto negotiation 
....................    #define   ETH_CFG_10         1      // use/advertise 10 Mbps capability 
....................    #define   ETH_CFG_100         1      // use/advertise 100 Mbps capability 
....................    #define   ETH_CFG_HDUPLEX      1      // use/advertise half duplex capability 
....................    #define   ETH_CFG_FDUPLEX      1      // use/advertise full duplex capability 
....................    #define   ETH_CFG_AUTO_MDIX   1      // use/advertise auto MDIX capability 
....................    #define   ETH_CFG_SWAP_MDIX   1      // use swapped MDIX. else normal MDIX 
....................  
.................... #define EMAC_TX_DESCRIPTORS      2      // number of the TX descriptors to be created 
.................... #define EMAC_RX_DESCRIPTORS      8      // number of the RX descriptors and RX buffers to be created 
....................  
.................... #define   EMAC_RX_BUFF_SIZE      1536   // size of a RX buffer. should be multiple of 16 
....................                               // this is the size of all receive buffers processed by the ETHC 
....................                               // The size should be enough to accomodate any network received packet 
....................                               // If the packets are larger, they will have to take multiple RX buffers 
....................                               // The current implementation does not handle this situation right now and the packet is discarded. 
.................... */ 
....................  
.................... // ======================================================================= 
.................... //   Transport Layer Options 
.................... // ======================================================================= 
....................  
.................... /* Transport Layer Configuration 
....................  *   The following low level modules are automatically enabled 
....................  *   based on module selections above.  If your custom module 
....................  *   requires them otherwise, enable them here. 
....................  */ 
.................... //#define STACK_USE_TCP 
.................... //#define STACK_USE_UDP 
....................  
.................... /* Client Mode Configuration 
....................  *   Uncomment following line if this stack will be used in CLIENT 
....................  *   mode.  In CLIENT mode, some functions specific to client operation 
....................  *   are enabled. 
....................  */ 
.................... #define STACK_CLIENT_MODE 
....................  
.................... /* TCP Socket Memory Allocation 
....................  *   TCP needs memory to buffer incoming and outgoing data.  The 
....................  *   amount and medium of storage can be allocated on a per-socket 
....................  *   basis using the example below as a guide. 
....................  */ 
....................    // Allocate how much total RAM (in bytes) you want to allocate 
....................    // for use by your TCP TCBs, RX FIFOs, and TX FIFOs. 
....................   #ifndef TCP_ETH_RAM_SIZE 
....................    #define TCP_ETH_RAM_SIZE                 (8192ul) 
....................   #endif 
....................    #define TCP_PIC_RAM_SIZE                 (0ul) 
....................    #define TCP_SPI_RAM_SIZE                 (0ul) 
....................    #define TCP_SPI_RAM_BASE_ADDRESS         (0x00) 
....................  
....................    // Define names of socket types 
....................    #define TCP_SOCKET_TYPES 
....................       #define TCP_PURPOSE_GENERIC_TCP_CLIENT 0 
....................       #define TCP_PURPOSE_GENERIC_TCP_SERVER 1 
....................       #define TCP_PURPOSE_TELNET 2 
....................       #define TCP_PURPOSE_FTP_COMMAND 3 
....................       #define TCP_PURPOSE_FTP_DATA 4 
....................       #define TCP_PURPOSE_TCP_PERFORMANCE_TX 5 
....................       #define TCP_PURPOSE_TCP_PERFORMANCE_RX 6 
....................       #define TCP_PURPOSE_UART_2_TCP_BRIDGE 7 
....................       #define TCP_PURPOSE_HTTP_SERVER 8 
....................       #define TCP_PURPOSE_DEFAULT 9 
....................       #define TCP_PURPOSE_BERKELEY_SERVER 10 
....................       #define TCP_PURPOSE_BERKELEY_CLIENT 11 
....................    #define END_OF_TCP_SOCKET_TYPES 
....................  
....................    //changed the check here because it was set up for linking, not static compiling 
....................       typedef struct 
....................       { 
....................          BYTE vSocketPurpose; 
....................          BYTE vMemoryMedium; 
....................          WORD wTXBufferSize; 
....................          WORD wRXBufferSize;       
....................       } TCPSocketInitializer_t; 
....................      #if defined(STACK_USE_TCP) && defined(TCP_CONFIGURATION) 
....................       //ccs bug, wouldn't let me extern empty brace 
....................       extern TCPSocketInitializer_t TCPSocketInitializer[TCP_CONFIGURATION]; 
....................      #endif 
....................    #if defined(STACK_USE_TCP) && !defined(TCP_CONFIGURATION) 
....................       // Define what types of sockets are needed, how many of 
....................       // each to include, where their TCB, TX FIFO, and RX FIFO 
....................       // should be stored, and how big the RX and TX FIFOs should 
....................       // be.  Making this initializer bigger or smaller defines 
....................       // how many total TCP sockets are available. 
....................       // 
....................       // Each socket requires up to 56 bytes of PIC RAM and 
....................       // 48+(TX FIFO size)+(RX FIFO size) bytes of TCP_*_RAM each. 
....................       // 
....................       // Note: The RX FIFO must be at least 1 byte in order to 
....................       // receive SYN and FIN messages required by TCP.  The TX 
....................       // FIFO can be zero if desired. 
....................       #define TCP_CONFIGURATION  1 
....................       //REMOVED ROM prefix -Tim 
....................       TCPSocketInitializer_t TCPSocketInitializer[TCP_CONFIGURATION] = 
....................       { 
....................           {TCP_PURPOSE_DEFAULT, TCP_ETH_RAM, 250, 250} 
....................       }; 
....................       #define END_OF_TCP_CONFIGURATION 
....................    #endif  
....................  
.................... #ifndef MAX_HTTP_CONNECTIONS 
....................    #define  MAX_HTTP_CONNECTIONS 1 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
....................    #define MAX_UDP_SOCKETS 7 
.................... #endif    
....................     
.................... /* UDP Socket Configuration 
....................  *   Define the maximum number of available UDP Sockets, and whether 
....................  *   or not to include a checksum on packets being transmitted. 
....................  */ 
.................... //#define MAX_UDP_SOCKETS           
.................... //#define UDP_USE_TX_CHECKSUM      // This slows UDP TX performance by nearly 50%, except when using the ENCX24J600 or PIC32MX6XX/7XX, which have a super fast DMA and incurs virtually no speed pentalty. 
....................  
....................  
.................... /* Berkeley API Sockets Configuration 
....................  *   Note that each Berkeley socket internally uses one TCP or UDP socket 
....................  *   defined by MAX_UDP_SOCKETS and the TCPSocketInitializer[] array. 
....................  *   Therefore, this number MUST be less than or equal to MAX_UDP_SOCKETS + the 
....................  *   number of TCP sockets defined by the TCPSocketInitializer[] array 
....................  *   (i.e. sizeof(TCPSocketInitializer)/sizeof(TCPSocketInitializer[0])). 
....................  *   This define has no effect if STACK_USE_BERKELEY_API is not defined and 
....................  *   Berkeley Sockets are disabled.  Set this value as low as your application 
....................  *   requires to avoid waisting RAM. 
....................  */ 
.................... //#define BSD_SOCKET_COUNT (5u) 
....................  
....................  
.................... // ======================================================================= 
.................... //   Application-Specific Options 
.................... // ======================================================================= 
....................  
.................... // -- HTTP2 Server options ----------------------------------------------- 
....................  
....................    // Maximum numbers of simultaneous HTTP connections allowed. 
....................    // Each connection consumes 2 bytes of RAM and a TCP socket 
....................    //#define MAX_HTTP_CONNECTIONS   (2u) 
....................  
....................    // Optional setting to use PIC RAM instead of Ethernet/Wi-Fi RAM for 
....................    // storing HTTP Connection Context variables (HTTP_CONN structure for each  
....................    // HTTP connection).  Undefining this macro results in the Ethernet/Wi-Fi  
....................    // RAM being used (minimum PIC RAM usage, lower performance).  Defining  
....................    // this macro results in PIC RAM getting used (higher performance, but uses  
....................    // PIC RAM).  This option should not be enabled on PIC18 devices.  The  
....................    // performance increase of having this option defined is only apparent when  
....................    // the HTTP server is servicing multiple connections simultaneously. 
....................    //#define HTTP_SAVE_CONTEXT_IN_PIC_RAM 
....................  
....................    // Indicate what file to serve when no specific one is requested 
....................    //#define HTTP_DEFAULT_FILE      "index.htm" 
....................    //#define HTTPS_DEFAULT_FILE      "index.htm" 
....................    //#define HTTP_DEFAULT_LEN      (10u)      // For buffer overrun protection. 
....................                                     // Set to longest length of above two strings. 
....................  
....................    // Configure MPFS over HTTP updating 
....................    // Comment this line to disable updating via HTTP 
....................    //#define HTTP_MPFS_UPLOAD      "mpfsupload" 
....................    //#define HTTP_MPFS_UPLOAD_REQUIRES_AUTH   // Require password for MPFS uploads 
....................       // Certain firewall and router combinations cause the MPFS2 Utility to fail 
....................       // when uploading.  If this happens, comment out this definition. 
....................  
....................    // Define which HTTP modules to use 
....................    // If not using a specific module, comment it to save resources 
....................    //#define HTTP_USE_POST               // Enable POST support 
....................    //#define HTTP_USE_COOKIES            // Enable cookie support 
....................    //#define HTTP_USE_AUTHENTICATION         // Enable basic authentication support 
....................  
....................    //#define HTTP_NO_AUTH_WITHOUT_SSL      // Uncomment to require SSL before requesting a password 
....................  
....................     // Define the listening port for the HTTP server 
....................      //#define HTTP_PORT               (80u) 
....................     
....................     // Define the listening port for the HTTPS server (if STACK_USE_SSL_SERVER is enabled) 
....................    //#define HTTPS_PORT            (443u) 
....................     
....................     // Define the maximum data length for reading cookie and GET/POST arguments (bytes) 
....................    //#define HTTP_MAX_DATA_LEN      (%HTTP_MAX_DATA_LEN%) 
....................     
....................     // Define the minimum number of bytes free in the TX FIFO before executing callbacks 
....................    //#define HTTP_MIN_CALLBACK_FREE   (16u) 
.................... // -- SSL Options -------------------------------------------------------- 
....................  
....................    //#define MAX_SSL_CONNECTIONS      (2ul)   // Maximum connections via SSL 
....................    //#define MAX_SSL_SESSIONS      (2ul)   // Max # of cached SSL sessions 
....................    //#define MAX_SSL_BUFFERS         (4ul)   // Max # of SSL buffers (2 per socket) 
....................    //#define MAX_SSL_HASHES         (5ul)   // Max # of SSL hashes  (2 per, plus 1 to avoid deadlock) 
....................  
....................    // Bits in SSL RSA key.  This parameter is used for SSL sever 
....................    // connections only.  The only valid value is 512 bits (768 and 1024 
....................    // bits do not work at this time).  Note, however, that SSL client 
....................    // operations do currently work up to 1024 bit RSA key length. 
....................    #define SSL_RSA_KEY_SIZE      (512ul) 
....................  
....................  
.................... // -- Telnet Options ----------------------------------------------------- 
....................  
....................    // Number of simultaneously allowed Telnet sessions.  Note that you 
....................    // must have an equal number of TCP_PURPOSE_TELNET type TCP sockets 
....................    // declared in the TCPSocketInitializer[] array above for multiple 
....................    // connections to work.  If fewer sockets are available than this 
....................    // definition, then the the lesser of the two quantities will be the 
....................    // actual limit. 
....................    //#define MAX_TELNET_CONNECTIONS   (1u) 
....................  
....................    // Default local listening port for the Telnet server.  Port 23 is the 
....................    // protocol default. 
....................    //#define TELNET_PORT            23 
....................  
....................    // Default local listening port for the Telnet server when SSL secured. 
....................    // Port 992 is the telnets protocol default. 
....................    //#define TELNETS_PORT         992 
....................  
....................    // Force all connecting clients to be SSL secured and connected via 
....................    // TELNETS_PORT.  Connections on port TELNET_PORT will be ignored.  If 
....................    // STACK_USE_SSL_SERVER is undefined, this entire setting is ignored 
....................    // (server will accept unsecured connections on TELNET_PORT and won't even 
....................    // listen on TELNETS_PORT). 
....................    //#define TELNET_REJECT_UNSECURED 
....................  
....................    // Default username and password required to login to the Telnet server. 
....................    //#define TELNET_USERNAME         "admin" 
....................    //#define TELNET_PASSWORD         "microchip" 
....................  
....................  
.................... // -- SNMP Options ------------------------------------------------------- 
....................  
....................    // Comment following line if SNMP TRAP support is needed 
....................    //#define SNMP_TRAP_DISABLED 
....................  
....................    //#define SNMP_STACK_USE_V2_TRAP 
....................    #if defined(STACK_USE_SNMPV3_SERVER) 
....................       #define SNMP_V1_V2_TRAP_WITH_SNMPV3 
....................    #endif 
....................  
....................    // This is the maximum length for community string. 
....................    // Application must ensure that this length is observed. 
....................    // SNMP module adds one byte extra after SNMP_COMMUNITY_MAX_LEN 
....................    // for adding '\0' NULL character. 
....................    //#define SNMP_COMMUNITY_MAX_LEN     (8u) 
....................    //#define SNMP_MAX_COMMUNITY_SUPPORT   (3u) 
....................    //#define NOTIFY_COMMUNITY_LEN      (SNMP_COMMUNITY_MAX_LEN) 
....................  
....................    // Default SNMPv2C community names.  These can be overridden at run time if 
....................    // alternate strings are present in external EEPROM or Flash (actual 
....................    // strings are stored in AppConfig.readCommunity[] and 
....................    // AppConfig.writeCommunity[] arrays).  These strings are case sensitive. 
....................    // An empty string means disabled (not matchable). 
....................    // For application security, these default community names should not be 
....................    // used, but should all be disabled to force the end user to select unique 
....................    // community names.  These defaults are provided only to make it easier to 
....................    // start development.  Specifying more strings than 
....................    // SNMP_MAX_COMMUNITY_SUPPORT will result in the later strings being 
....................    // ignored (but still wasting program memory).  Specifying fewer strings is 
....................    // legal, as long as at least one is present.  A string larger than 
....................    // SNMP_COMMUNITY_MAX_LEN bytes will be ignored. 
....................    //#define SNMP_READ_COMMUNITIES      {"public", "read", ""} 
....................    //#define END_OF_SNMP_READ_COMMUNITIES 
....................    //#define SNMP_WRITE_COMMUNITIES        {"private", "write", "public"} 
....................    //#define END_OF_SNMP_WRITE_COMMUNITIES 
.................... #endif 
....................  
....................  
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definitions 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    Compiler.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,  
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,  
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook/CCS      WIFI networkType added to AppConfig, hopefully 
....................  *                         this doesn't conflict with EZ_CONFIG_STORE.  
....................  *                      WIFI adhocBehavior added to AppConfig. 
....................  ********************************************************************/ 
.................... #ifndef __STACK_TSK_H 
.................... #define __STACK_TSK_H 
....................  
.................... #if defined (WF_CS_TRIS) 
....................     #include "WF_Config.h"      
.................... #endif 
....................  
.................... // Check for potential configuration errors in "TCPIPConfig.h" 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 ) 
.................... #error Invalid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... // Check for potential configuration errors in "TCPIPConfig.h" 
.................... #if (MAX_HTTP_CONNECTIONS <= 0 || MAX_HTTP_CONNECTIONS > 255 ) 
.................... #error Invalid MAX_HTTP_CONNECTIONS value specified. 
.................... #endif 
....................  
.................... // Structure to contain a MAC address 
.................... typedef struct __attribute__((__packed__)) 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... // Definition to represent an IP address 
.................... #define IP_ADDR      DWORD_VAL 
....................  
.................... // Address structure for a node 
.................... typedef struct __attribute__((__packed__)) 
.................... { 
....................     IP_ADDR     IPAddr; 
....................     MAC_ADDR    MACAddr; 
.................... } NODE_INFO; 
....................  
.................... // Application-dependent structure used to contain address information 
.................... typedef struct __attribute__((__packed__)) appConfigStruct  
.................... { 
....................    IP_ADDR      MyIPAddr;               // IP address 
....................    IP_ADDR      MyMask;                 // Subnet mask 
....................    IP_ADDR      MyGateway;              // Default Gateway 
....................    IP_ADDR      PrimaryDNSServer;       // Primary DNS Server 
....................    IP_ADDR      SecondaryDNSServer;     // Secondary DNS Server 
....................    IP_ADDR      DefaultIPAddr;          // Default IP address 
....................    IP_ADDR      DefaultMask;            // Default subnet mask 
....................    BYTE      NetBIOSName[16];        // NetBIOS name 
....................    struct 
....................    { 
....................       unsigned char : 6; 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    } Flags;                            // Flag structure 
....................    MAC_ADDR   MyMACAddr;              // Application MAC address 
....................  
.................... #if defined(WF_CS_TRIS) 
....................    BYTE      MySSID[32];             // Wireless SSID (if using MRF24W) 
....................    BYTE        SsidLength;             // number of bytes in SSID 
....................    BYTE        SecurityMode;           // WF_SECURITY_OPEN or one of the other security modes 
....................    BYTE        SecurityKey[64];        // WiFi Security key, or passphrase.    
....................    BYTE        SecurityKeyLength;      // number of bytes in security key (can be 0) 
....................    BYTE        WepKeyIndex;            // WEP key index (only valid for WEP) 
....................    BYTE        networkType; 
....................    BYTE        adhocBehavior; 
....................     #if defined(EZ_CONFIG_STORE) // WLAN configuration data stored to NVM 
....................     BYTE        dataValid; 
....................     //BYTE        networkType; 
....................     BYTE        saveSecurityInfo;       // Save 32-byte PSK 
....................     #endif 
.................... #endif 
....................     
.................... #if defined(STACK_USE_SNMP_SERVER) || defined(STACK_USE_SNMPV3_SERVER) 
....................    // SNMPv2C Read community names 
....................    // SNMP_COMMUNITY_MAX_LEN (8) + 1 null termination byte 
....................    BYTE readCommunity[SNMP_MAX_COMMUNITY_SUPPORT][SNMP_COMMUNITY_MAX_LEN+1];  
....................  
....................    // SNMPv2C Write community names 
....................    // SNMP_COMMUNITY_MAX_LEN (8) + 1 null termination byte 
....................    BYTE writeCommunity[SNMP_MAX_COMMUNITY_SUPPORT][SNMP_COMMUNITY_MAX_LEN+1]; 
....................  
....................    UINT32 SnmpEngineBootRcrd; 
.................... #endif 
....................  
.................... } APP_CONFIG; 
....................  
.................... #ifndef THIS_IS_STACK_APPLICATION 
....................     extern APP_CONFIG AppConfig; 
.................... #endif 
....................  
....................  
.................... void StackInit(void); 
.................... void StackTask(void); 
.................... void StackApplications(void); 
.................... #endif 
....................  
.................... #include "TCPIP Stack/Helpers.h" 
.................... /********************************************************************* 
....................  Header file for Helpers.c 
....................   
....................  FileName:      Helpers.h 
....................  Dependencies:  See INCLUDES section 
....................  Processor:     PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:      Microchip C18, C30, C32 
....................  Company:       Microchip Technology, Inc. 
....................  
....................  Software License Agreement 
....................  
....................  Copyright (C) 2002-2011 Microchip Technology Inc.  All rights 
....................  reserved. 
....................  
....................  Microchip licenses to you the right to use, modify, copy, and 
....................  distribute: 
....................  (i)  the Software when embedded on a Microchip microcontroller or 
....................       digital signal controller product ("Device") which is 
....................       integrated into Licensee's product; or 
....................  (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
.................... 		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
.................... 		used in conjunction with a Microchip ethernet controller for 
.................... 		the sole purpose of interfacing with the ethernet controller. 
....................  
....................  You should refer to the license agreement accompanying this 
....................  Software for additional information regarding your rights and 
....................  obligations. 
....................  
....................  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  
....................  ******************************************************************** 
....................  File Description: 
....................   
....................  Change History: 
....................   
....................   Rev         Description 
....................   ----------  ------------------------------------------------------- 
....................   1.0 - 5.31  Initial release 
....................   5.36        Updated compile time check for ultoa(); 
....................  ********************************************************************/ 
.................... #ifndef __HELPERS_H 
.................... #define __HELPERS_H 
....................  
....................  
.................... #if !defined(__18CXX) || defined(HI_TECH_C) 
.................... 	char *strupr(char* s); 
.................... #endif 
....................  
.................... // Implement consistent ultoa() function 
.................... #if (defined(__PIC32MX__) && (__C32_VERSION__ < 112)) || (defined (__C30__) && (__C30_VERSION__ < 325)) || defined(__C30_LEGACY_LIBC__) || defined(__C32_LEGACY_LIBC__) 
.................... 	// C32 < 1.12 and C30 < v3.25 need this 2 parameter stack implemented function 
.................... 	void ultoa(DWORD Value, BYTE* Buffer); 
.................... #elif defined(__18CXX) && !defined(HI_TECH_C) 
.................... 	// C18 already has a 2 parameter ultoa() function 
.................... 	#include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #else 
.................... 	// HI-TECH PICC-18 PRO 9.63, C30 v3.25+, and C32 v1.12+ already have a ultoa() stdlib  
.................... 	// library function, but it requires 3 parameters.  The TCP/IP Stack  
.................... 	// assumes the C18 style 2 parameter ultoa() function, so we shall  
.................... 	// create a macro to automatically convert the code. 
.................... 	#include <stdlib.h> 
.................... 	#define ultoa(val,buf)	ultoa((char*)(buf),(val),10) 
.................... #endif 
....................  
.................... #if defined(DEBUG) 
.................... 	#define DebugPrint(a)	{putrsUART(a);} 
.................... #else 
.................... 	#define DebugPrint(a) 
.................... #endif 
....................  
.................... DWORD	LFSRSeedRand(DWORD dwSeed); 
.................... WORD	LFSRRand(void); 
.................... DWORD	GenerateRandomDWORD(void); 
.................... void 	uitoa(WORD Value, BYTE* Buffer); 
.................... void 	UnencodeURL(BYTE* URL); 
.................... WORD 	Base64Decode(BYTE* cSourceData, WORD wSourceLen, BYTE* cDestData, WORD wDestLen); 
.................... WORD	Base64Encode(BYTE* cSourceData, WORD wSourceLen, BYTE* cDestData, WORD wDestLen); 
.................... BOOL	StringToIPAddress(BYTE* str, IP_ADDR* IPAddress); 
.................... BYTE 	ReadStringUART(BYTE* Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
.................... signed char stricmppgm2ram(BYTE* a, ROM BYTE* b); 
.................... char * 	strnchr(const char *searchString, size_t count, char c); 
.................... size_t  strncpy_m(char* destStr, size_t destSize, int nStrings, ...); 
....................  
.................... #if defined(__18CXX) 
.................... 	BOOL	ROMStringToIPAddress(ROM BYTE* str, IP_ADDR* IPAddress); 
.................... #else 
.................... 	// Non-ROM variant for C30 and C32 
.................... 	#define ROMStringToIPAddress(a,b)	StringToIPAddress((BYTE*)a,b) 
.................... #endif 
....................  
....................  
.................... WORD    swaps(WORD v); 
....................  
.................... #if defined(__C32__) 
.................... DWORD   __attribute__((nomips16)) swapl(DWORD v); 
.................... #else 
.................... DWORD   swapl(DWORD v); 
.................... #endif 
....................  
.................... WORD    CalcIPChecksum(BYTE* buffer, WORD len); 
....................  
....................  
.................... #if defined(__18CXX) 
.................... 	DWORD leftRotateDWORD(DWORD val, BYTE bits); 
.................... #else 
.................... 	// Rotations are more efficient in C30 and C32 
.................... 	#define leftRotateDWORD(x, n) (((x) << (n)) | ((x) >> (32-(n)))) 
.................... #endif 
....................  
.................... void FormatNetBIOSName(BYTE Name[16]); 
....................  
....................  
.................... // Protocols understood by the ExtractURLFields() function.  IMPORTANT: If you  
.................... // need to reorder these (change their constant values), you must also reorder  
.................... // the constant arrays in ExtractURLFields(). 
.................... typedef enum 
.................... { 
.................... 	PROTOCOL_HTTP = 0u, 
.................... 	PROTOCOL_HTTPS, 
.................... 	PROTOCOL_MMS, 
.................... 	PROTOCOL_RTSP 
.................... } PROTOCOLS; 
....................  
.................... BYTE ExtractURLFields(BYTE *vURL, PROTOCOLS *protocol, BYTE *vUsername, WORD *wUsernameLen, BYTE *vPassword, WORD *wPasswordLen, BYTE *vHostname, WORD *wHostnameLen, WORD *wPort, BYTE *vFilePath, WORD *wFilePathLen); 
.................... SHORT Replace(BYTE *vExpression, ROM BYTE *vFind, ROM BYTE *vReplacement, WORD wMaxLen, BOOL bSearchCaseInsensitive); 
....................  
.................... #endif 
....................  
.................... #include "TCPIP Stack/Delay.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  General Delay rouines 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Delay.h 
....................  * Dependencies:    Compiler.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/9/02  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     6/10/02 Fixed C18 ms and us routines 
....................  * Howard Schlunder		4/04/06	Changed for C30 
....................  ********************************************************************/ 
.................... #ifndef __DELAY_H 
.................... #define __DELAY_H 
....................  
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
.................... #if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 	#include <delays.h> 
.................... #endif 
....................  
.................... #if !defined(GetInstructionClock) 
.................... 	#error GetInstructionClock() must be defined. 
.................... #endif 
....................  
.................... #if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 	#define Delay10us(us)		Delay10TCYx(((GetInstructionClock()/1000000)*(us))) 
.................... 	#define DelayMs(ms)												\ 
.................... 	do																\ 
.................... 	{																\ 
.................... 		unsigned int _iTemp = (ms); 								\ 
.................... 		while(_iTemp--)												\ 
.................... 			Delay1KTCYx((GetInstructionClock()+999999)/1000000);	\ 
.................... 	} while(0) 
....................  
.................... #elif defined(__C30__) || defined(__C32__) 
.................... 	void Delay10us(DWORD dwCount); 
.................... 	void DelayMs(WORD ms); 
....................  
.................... #else 
.................... 	#define Delay10us(x)			\ 
.................... 	do 								\ 
.................... 	{								\ 
.................... 		unsigned long _dcnt;		\ 
.................... 		_dcnt=x*((unsigned long)(0.00001/(1.0/GetInstructionClock())/6));	\ 
.................... 		while(_dcnt--);				\ 
.................... 	} while(0) 
.................... 	void DelayMs(WORD ms); 
.................... #endif 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "TCPIP Stack/Tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  ********************************************************************/ 
.................... #ifndef __TICK_H 
.................... #define __TICK_H 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... // All TICKS are stored as 32-bit unsigned integers. 
.................... // This is deprecated since it conflicts with other TICK definitions used in  
.................... // other Microchip software libraries and therefore poses a merge and maintence  
.................... // problem.  Instead of using the TICK data type, just use the base DWORD data  
.................... // type instead. 
.................... typedef __attribute__((__deprecated__)) DWORD TICK; 
....................  
.................... // This value is used by TCP and other modules to implement timeout actions. 
.................... // For this definition, the Timer must be initialized to use a 1:256 prescalar  
.................... // in Tick.c.  If using a 32kHz watch crystal as the time base, modify the  
.................... // Tick.c file to use no prescalar. 
.................... #define TICKS_PER_SECOND		((GetPeripheralClock()+128ull)/256ull)	// Internal core clock drives timer with 1:256 prescaler 
.................... //#define TICKS_PER_SECOND		(32768ul)								// 32kHz crystal drives timer with no scalar 
....................  
.................... // Represents one second in Ticks 
.................... #define TICK_SECOND				((QWORD)TICKS_PER_SECOND) 
.................... // Represents one minute in Ticks 
.................... #define TICK_MINUTE				((QWORD)TICKS_PER_SECOND*60ull) 
.................... // Represents one hour in Ticks 
.................... #define TICK_HOUR				((QWORD)TICKS_PER_SECOND*3600ull) 
....................  
....................  
.................... void TickInit(void); 
.................... DWORD TickGet(void); 
.................... DWORD TickGetDiv256(void); 
.................... DWORD TickGetDiv64K(void); 
.................... DWORD TickConvertToMilliseconds(DWORD dwTickValue); 
.................... void TickUpdate(void); 
....................  
.................... #endif 
....................  
.................... #include "TCPIP Stack/MAC.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  ********************************************************************/ 
.................... #ifndef __MAC_H 
.................... #define __MAC_H 
....................  
.................... #include "HardwareProfile.h" 
.................... // hardwareprofile.h 
....................  
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #if STACK_USE_CCS_EWLWIFIB || STACK_USE_CCS_EWLWIFIG 
....................  
....................    #bit WF_CS_TRIS1   =     0xF96.1 //E1 
....................    #define WF_CS_TRIS WF_CS_TRIS1 
....................    #bit WF_CS_IO     =  0xF8D.1    //LatE1 
....................    #bit WF_SDI_TRIS  =  0xF94.4    // (TRISCbits.TRISC4) 
....................    #bit WF_SCK_TRIS  =  0xF94.3    // (TRISCbits.TRISC3) 
....................    #bit WF_SDO_TRIS  =  0xF94.5    // (TRISCbits.TRISC5) 
....................    #bit WF_RESET_TRIS=  0xF93.1    //(TRISBbits.TRISB1) 
....................    #bit WF_RESET_IO  =  0xF8A.1     //(LATBbits.LATB1)   
....................    #bit WF_INT_TRIS  =  0xF93.0     // (TRISBbits.TRISB0)  // INT1 
....................    #bit WF_INT_IO    =  0xF81.0   //(PORTBbits.RB0)  
....................    #bit WF_HIBERNATE_TRIS= 0xF93.2  //(TRISBbits.TRISB2)  
....................    #bit   WF_HIBERNATE_IO=  0xF81.2    //(PORTBbits.RB2) 
....................     
....................    #bit WF_INT_EDGE  =  0xFF1.6      //(INTCON2bits.INTEDG0) 
....................    #bit WF_INT_IE    =  0xFF2.4   //(INTCONbits.INT0IE) 
....................    #bit WF_INT_IF    =  0xFF2.1   //(INTCONbits.INT0IF) 
....................    #define WF_SSPBUF  (SSP1BUF) 
....................    #define WF_SPISTAT  (SSP1STATbits) 
....................    #define WF_SPISTATbits SSP1STATbits     //(SSP1STATbits) 
....................    #define WF_SPICON1  (SSP1CON1bits) 
....................    #define WF_SPICON1bits WF_SPICON1    // (SSP1CON1bits) 
....................    #define WF_SPICON2  (SSP1CON2bits) 
....................    #bit WF_SPI_IE    =   0xF9D.3  //(PIE1bits.SSPIE) 
....................    #bit WF_SPI_IP    =   0xF9F.3  //(IPR1bits.SSPIP) 
....................    #bit WF_SPI_IF    =   0xF9E.3  //(PIR1bits.SSPIF) 
....................     
.................... #else 
....................  
.................... //#error define necessary hardware for TCPIP stack 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #if defined(WF_CS_TRIS) 
....................    // Do not use the DMA and other goodies that Microchip Ethernet modules have 
....................    #define NON_MCHP_MAC 
.................... #endif 
....................  
.................... #if defined(ENC_CS_TRIS) && defined(WF_CS_TRIS) 
....................    #error "Error in HardwareProfile.h.  Must select either the ENC28J60 or the MRF24WB10 but not both ENC_CS_TRIS and WF_CS_TRIS." 
.................... #endif 
.................... #if defined(ENC100_INTERFACE_MODE) && defined(WF_CS_TRIS) 
....................    #error "Error in HardwareProfile.h.  Must select either the ENCX24J600 or the MRF24WB10 but not both ENC100_INTERFACE_MODE and WF_CS_TRIS." 
.................... #endif 
.................... #if defined(ENC100_INTERFACE_MODE) && defined(ENC_CS_TRIS) 
....................    #error "Error in HardwareProfile.h.  Must select either the ENC28J60 or the ENCX24J600 but not both ENC_CS_TRIS and ENC100_INTERFACE_MODE." 
.................... #endif 
....................  
....................  
....................  
.................... #if !defined(ENC_CS_TRIS) && !defined(WF_CS_TRIS) && !defined(ENC100_INTERFACE_MODE) && \ 
....................     (defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) || \ 
....................      defined(_18F97J60) ||  defined(_18F96J65) ||  defined(_18F96J60) ||  defined(_18F87J60) ||  defined(_18F86J65) ||  defined(_18F86J60) ||  defined(_18F67J60) ||  defined(_18F66J65) ||  defined(_18F66J60)) 
....................    #include "TCPIP Stack/ETH97J60.h" 
.................... #elif defined(ENC_CS_TRIS) || defined(WF_CS_TRIS) 
....................    #include "TCPIP Stack/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  ********************************************************************/ 
....................  
.................... #ifndef __ENC28J60_H 
.................... #define __ENC28J60_H 
.................... #include "GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... #ifdef BYTE 
.................... #undef BYTE 
.................... #endif 
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		WORD	 		ByteCount; 
.................... 		unsigned char	CollisionCount:4; 
.................... 		unsigned char	CRCError:1; 
.................... 		unsigned char	LengthCheckError:1; 
.................... 		unsigned char	LengthOutOfRange:1; 
.................... 		unsigned char	Done:1; 
.................... 		unsigned char	Multicast:1; 
.................... 		unsigned char	Broadcast:1; 
.................... 		unsigned char	PacketDefer:1; 
.................... 		unsigned char	ExcessiveDefer:1; 
.................... 		unsigned char	MaximumCollisions:1; 
.................... 		unsigned char	LateCollision:1; 
.................... 		unsigned char	Giant:1; 
.................... 		unsigned char	Underrun:1; 
.................... 		WORD 	 		BytesTransmittedOnWire; 
.................... 		unsigned char	ControlFrame:1; 
.................... 		unsigned char	PAUSEControlFrame:1; 
.................... 		unsigned char	BackpressureApplied:1; 
.................... 		unsigned char	VLANTaggedFrame:1; 
.................... 		unsigned char	Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	BYTE v[4]; 
.................... 	struct { 
.................... 		WORD	 		ByteCount; 
.................... 		unsigned char	PreviouslyIgnored:1; 
.................... 		unsigned char	RXDCPreviouslySeen:1; 
.................... 		unsigned char	CarrierPreviouslySeen:1; 
.................... 		unsigned char	CodeViolation:1; 
.................... 		unsigned char	CRCError:1; 
.................... 		unsigned char	LengthCheckError:1; 
.................... 		unsigned char	LengthOutOfRange:1; 
.................... 		unsigned char	ReceiveOk:1; 
.................... 		unsigned char	Multicast:1; 
.................... 		unsigned char	Broadcast:1; 
.................... 		unsigned char	DribbleNibble:1; 
.................... 		unsigned char	ControlFrame:1; 
.................... 		unsigned char	PauseControlFrame:1; 
.................... 		unsigned char	UnsupportedOpcode:1; 
.................... 		unsigned char	VLANType:1; 
.................... 		unsigned char	Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG  
.................... { 
.................... 	BYTE Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char :1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char BUFER:1; 
.................... 		unsigned char INT:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char :3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
.................... 		 
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
.................... 		 
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
.................... 		 
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
.................... 		 
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDREN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDREN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
.................... 		 
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char :1; 
.................... 	} MACON4bits; 
.................... 		 
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char :6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
.................... 		 
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char :5; 
.................... 	} MISTATbits; 
.................... 		 
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char :5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char :5; 
.................... 	} ECOCONbits2; 
.................... 		 
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char :5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char :5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	WORD Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		unsigned :8; 
.................... 		unsigned PDPXMD:1; 
.................... 		unsigned :2; 
.................... 		unsigned PPWRSV:1; 
.................... 		unsigned :2; 
.................... 		unsigned PLOOPBK:1; 
.................... 		unsigned PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		unsigned :1; 
.................... 		unsigned JBSTAT:1; 
.................... 		unsigned LLSTAT:1; 
.................... 		unsigned :5; 
.................... 		unsigned :3; 
.................... 		unsigned PHDPX:1; 
.................... 		unsigned PFDPX:1; 
.................... 		unsigned :3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		unsigned PREV0:1; 
.................... 		unsigned PREV1:1; 
.................... 		unsigned PREV2:1; 
.................... 		unsigned PREV3:1; 
.................... 		unsigned PPN0:1; 
.................... 		unsigned PPN1:1; 
.................... 		unsigned PPN2:1; 
.................... 		unsigned PPN3:1; 
.................... 		unsigned PPN4:1; 
.................... 		unsigned PPN5:1; 
.................... 		unsigned PID19:1; 
.................... 		unsigned PID20:1; 
.................... 		unsigned PID21:1; 
.................... 		unsigned PID22:1; 
.................... 		unsigned PID23:1; 
.................... 		unsigned PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		unsigned PREV:4; 
.................... 		unsigned PPNL:4; 
.................... 		unsigned PPNH:2; 
.................... 		unsigned PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		unsigned :8; 
.................... 		unsigned HDLDIS:1; 
.................... 		unsigned :1; 
.................... 		unsigned JABBER:1; 
.................... 		unsigned :2; 
.................... 		unsigned TXDIS:1; 
.................... 		unsigned FRCLNK:1; 
.................... 		unsigned :1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		unsigned :5; 
.................... 		unsigned PLRITY:1; 
.................... 		unsigned :2; 
.................... 		unsigned :1; 
.................... 		unsigned DPXSTAT:1; 
.................... 		unsigned LSTAT:1; 
.................... 		unsigned COLSTAT:1; 
.................... 		unsigned RXSTAT:1; 
.................... 		unsigned TXSTAT:1; 
.................... 		unsigned :2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		unsigned :1; 
.................... 		unsigned PGEIE:1; 
.................... 		unsigned :2; 
.................... 		unsigned PLNKIE:1; 
.................... 		unsigned :3; 
.................... 		unsigned :8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		unsigned :2; 
.................... 		unsigned PGIF:1; 
.................... 		unsigned :1; 
.................... 		unsigned PLNKIF:1; 
.................... 		unsigned :3; 
.................... 		unsigned :8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		unsigned :1; 
.................... 		unsigned STRCH:1; 
.................... 		unsigned LFRQ0:1; 
.................... 		unsigned LFRQ1:1; 
.................... 		unsigned LBCFG0:1; 
.................... 		unsigned LBCFG1:1; 
.................... 		unsigned LBCFG2:1; 
.................... 		unsigned LBCFG3:1; 
.................... 		unsigned LACFG0:1; 
.................... 		unsigned LACFG1:1; 
.................... 		unsigned LACFG2:1; 
.................... 		unsigned LACFG3:1; 
.................... 		unsigned :4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		unsigned :1; 
.................... 		unsigned STRCH:1; 
.................... 		unsigned LFRQ:2; 
.................... 		unsigned LBCFG:4; 
.................... 		unsigned LACFG:4; 
.................... 		unsigned :4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
.................... 	 
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFER		(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
.................... 	 
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
.................... 	 
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
.................... 	 
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
.................... 	 
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
.................... 	 
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDREN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
.................... 	 
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
.................... 	 
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
.................... 	 
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
.................... 	 
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
.................... #elif defined(ENC100_INTERFACE_MODE) 
....................    #include "TCPIP Stack/ENCX24J600.h" 
....................    #define PHYREG WORD 
.................... #elif defined(__PIC32MX__) && defined(_ETH) 
....................    // extra includes for PIC32MX with embedded ETH Controller 
.................... #else 
....................    #error No Ethernet/WiFi controller defined in HardwareProfile.h.  Defines for an ENC28J60, ENC424J600/624J600, or WiFi MRF24WB10 must be present. 
.................... #endif 
....................  
....................  
.................... #define MAC_TX_BUFFER_SIZE         (1500ul) 
....................  
.................... // A generic structure representing the Ethernet header starting all Ethernet 
.................... // frames 
.................... typedef struct   
.................... #if defined(__CCS__) 
.................... __attribute__((packed)) 
.................... #else 
.................... __attribute__((aligned(2), packed)) 
.................... #endif 
.................... { 
....................    MAC_ADDR        DestMACAddr; 
....................    MAC_ADDR        SourceMACAddr; 
....................    WORD_VAL        Type; 
.................... } ETHER_HEADER; 
....................  
....................  
.................... #define MAC_IP         (0x00u) 
.................... #define MAC_ARP        (0x06u) 
.................... #define MAC_UNKNOWN    (0xFFu) 
....................  
....................  
.................... #if !defined(STACK_USE_HTTP2_SERVER) 
....................    #define RESERVED_HTTP_MEMORY 0ul 
.................... #endif 
....................  
.................... #if !defined(STACK_USE_SSL) 
....................    #define RESERVED_SSL_MEMORY 0ul 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #define MAX_PACKET_SIZE     (1514ul) 
.................... #endif 
....................  
.................... // MAC RAM definitions 
.................... #if defined(ENC100_INTERFACE_MODE) 
....................    #define RESERVED_CRYPTO_MEMORY   (128ul) 
....................    #define RAMSIZE         (24*1024ul) 
....................    #define TXSTART       (0x0000ul) 
....................    #define RXSTART       ((TXSTART + 1518ul + TCP_ETH_RAM_SIZE + RESERVED_HTTP_MEMORY + RESERVED_SSL_MEMORY + RESERVED_CRYPTO_MEMORY + 1ul) & 0xFFFE) 
....................    #define   RXSTOP         (RAMSIZE-1ul) 
....................    #define RXSIZE         (RXSTOP-RXSTART+1ul) 
....................    #define BASE_TX_ADDR   (TXSTART) 
....................    #define BASE_TCB_ADDR   (BASE_TX_ADDR + 1518ul) 
....................    #define BASE_HTTPB_ADDR (BASE_TCB_ADDR + TCP_ETH_RAM_SIZE) 
....................    #define BASE_SSLB_ADDR   (BASE_HTTPB_ADDR + RESERVED_HTTP_MEMORY) 
....................    #define BASE_CRYPTOB_ADDR   (BASE_SSLB_ADDR + RESERVED_SSL_MEMORY) 
.................... #elif defined(WF_CS_TRIS) 
....................    #define RAMSIZE       (14170ul - 8192ul - RESERVED_HTTP_MEMORY - RESERVED_SSL_MEMORY) 
....................    #define TXSTART       (RAMSIZE - (4ul + MAX_PACKET_SIZE + 4ul)) 
....................    #define RXSTART       (0ul) 
....................    #define RXSTOP         ((TXSTART-2ul) | 0x0001ul) 
....................    #define RXSIZE         (RXSTOP-RXSTART+1ul) 
....................    #define BASE_TX_ADDR   (TXSTART + 4ul) 
....................    #define BASE_SCRATCH_ADDR (BASE_TX_ADDR + (MAX_PACKET_SIZE + 4ul)) 
....................    #define BASE_HTTPB_ADDR  (BASE_SCRATCH_ADDR) 
....................    #define BASE_SSLB_ADDR   (BASE_HTTPB_ADDR + RESERVED_HTTP_MEMORY) 
....................    #define BASE_TCB_ADDR   (BASE_SSLB_ADDR + RESERVED_SSL_MEMORY) 
.................... #elif defined(__PIC32MX__) && defined(_ETH) && !defined(ENC_CS_TRIS) 
....................    #define BASE_TX_ADDR   (MACGetTxBaseAddr()) 
....................    #define BASE_HTTPB_ADDR   (MACGetHttpBaseAddr()) 
....................    #define BASE_SSLB_ADDR   (MACGetSslBaseAddr()) 
....................    #define RXSIZE         (EMAC_RX_BUFF_SIZE) 
....................    #define RAMSIZE         (2*RXSIZE)   // not used but silences the compiler 
.................... #else   // ENC28J60 or PIC18F97J60 family internal Ethernet controller 
....................    #define RAMSIZE         (8*1024ul) 
....................    #define TXSTART       (RAMSIZE - (1ul+1518ul+7ul) - TCP_ETH_RAM_SIZE - RESERVED_HTTP_MEMORY - RESERVED_SSL_MEMORY) 
....................    #define RXSTART         (0ul)                  // Should be an even memory address; must be 0 for errata 
....................    #define   RXSTOP         ((TXSTART-2ul) | 0x0001ul)   // Odd for errata workaround 
....................    #define RXSIZE         (RXSTOP-RXSTART+1ul) 
....................    #define BASE_TX_ADDR   (TXSTART + 1ul) 
....................    #define BASE_TCB_ADDR   (BASE_TX_ADDR + (1514ul+7ul)) 
....................    #define BASE_HTTPB_ADDR (BASE_TCB_ADDR + TCP_ETH_RAM_SIZE) 
....................    #define BASE_SSLB_ADDR   (BASE_HTTPB_ADDR + RESERVED_HTTP_MEMORY) 
.................... #endif 
....................  
.................... #if (RXSIZE < 1400) || (RXSIZE > RAMSIZE) 
....................    #error Warning, Ethernet RX buffer is tiny.  Reduce TCP socket count, the size of each TCP socket, or move sockets to a different RAM 
.................... #endif 
....................  
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void   MACEDPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... #if defined(ENC_CS_TRIS) || defined(ENC100_INTERFACE_MODE) || \ 
....................    (defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) || \ 
....................      defined(_18F97J60) ||  defined(_18F96J65) ||  defined(_18F96J60) ||  defined(_18F87J60) ||  defined(_18F86J65) ||  defined(_18F86J60) ||  defined(_18F67J60) ||  defined(_18F66J65) ||  defined(_18F66J60)) 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... #endif 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
.................... // ENC28J60 specific 
.................... void   SetCLKOUT(BYTE NewConfig); 
.................... BYTE   GetCLKOUT(void); 
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
....................  
.................... void MACInit(void); 
.................... void MACProcess(void); 
.................... BOOL MACIsLinked(void); 
....................  
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void MACSetReadPtrInRx(WORD offset); 
.................... PTR_BASE MACSetWritePtr(PTR_BASE address); 
.................... PTR_BASE MACSetReadPtr(PTR_BASE address); 
.................... BYTE MACGet(void); 
.................... WORD MACGetArray(BYTE *val, WORD len); 
.................... void MACDiscardRx(void); 
.................... WORD MACGetFreeRxSize(void); 
.................... void MACMemCopyAsync(PTR_BASE destAddr, PTR_BASE sourceAddr, WORD len); 
.................... BOOL MACIsMemCopyDone(void); 
....................  
.................... void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen); 
.................... BOOL MACIsTxReady(void); 
.................... void MACPut(BYTE val); 
.................... void MACPutArray(BYTE *val, WORD len); 
.................... void MACFlush(void); 
....................  
....................  
.................... // ROM function variants for PIC18 
.................... #if defined(__18CXX) 
....................    void MACPutROMArray(ROM BYTE *val, WORD len); 
.................... #else 
....................    #define MACPutROMArray(a,b)   MACPutArray((BYTE*)a,b) 
.................... #endif 
....................  
.................... // PIC32MX with embedded ETHC functions 
.................... #if defined(__PIC32MX__) && defined(_ETH) 
....................    PTR_BASE MACGetTxBaseAddr(void); 
....................    PTR_BASE MACGetHttpBaseAddr(void); 
....................    PTR_BASE MACGetSslBaseAddr(void); 
.................... #endif 
....................  
....................     
.................... #endif 
....................  
.................... #include "TCPIP Stack/IP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  ********************************************************************/ 
.................... #ifndef __IP_H 
.................... #define __IP_H 
....................  
....................  
.................... #define IP_PROT_ICMP    (1u) 
.................... #define IP_PROT_TCP     (6u) 
.................... #define IP_PROT_UDP     (17u) 
....................  
....................  
.................... // IP packet header definition 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
.................... } IP_HEADER; 
....................  
.................... // IP Pseudo header as defined by RFC 793 (needed for TCP and UDP  
.................... // checksum calculations/verification) 
.................... typedef struct _PSEUDO_HEADER 
.................... { 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................     BYTE Zero; 
....................     BYTE Protocol; 
....................     WORD Length; 
.................... } PSEUDO_HEADER; 
....................  
.................... #define SwapPseudoHeader(h)  (h.Length = swaps(h.Length)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady()       MACIsTxReady() 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(b) MACSetWritePtr(b + BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by  
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset  
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "TCPIP Stack/ARP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder      8/17/06   Combined ARP.h and ARPTsk.h into ARP.h 
....................  ********************************************************************/ 
.................... #ifndef __ARP_H 
.................... #define __ARP_H 
....................  
.................... #ifdef STACK_CLIENT_MODE 
....................    void ARPInit(void); 
.................... #else 
....................    #define ARPInit() 
.................... #endif 
....................  
.................... #define ARP_OPERATION_REQ       0x0001u      // Operation code indicating an ARP Request 
.................... #define ARP_OPERATION_RESP      0x0002u      // Operation code indicating an ARP Response 
....................  
.................... #define HW_ETHERNET             (0x0001u)   // ARP Hardware type as defined by IEEE 802.3 
.................... #define ARP_IP                  (0x0800u)   // ARP IP packet type as defined by IEEE 802.3 
....................  
....................  
.................... // ARP packet structure 
.................... typedef struct  
.................... #if defined(__CCS__) 
.................... __attribute__((packed)) 
.................... #else 
.................... __attribute__((aligned(2), packed)) 
.................... #endif 
.................... { 
....................     WORD        HardwareType;   // Link-layer protocol type (Ethernet is 1). 
....................     WORD        Protocol;       // The upper-layer protocol issuing an ARP request (0x0800 for IPv4).. 
....................     BYTE        MACAddrLen;     // MAC address length (6). 
....................     BYTE        ProtocolLen;    // Length of addresses used in the upper-layer protocol (4). 
....................     WORD        Operation;      // The operation the sender is performing (ARP_REQ or ARP_RESP). 
....................     MAC_ADDR    SenderMACAddr;  // The sender's hardware (MAC) address. 
....................     IP_ADDR     SenderIPAddr;   // The sender's IP address. 
....................     MAC_ADDR    TargetMACAddr;  // The target node's hardware (MAC) address. 
....................     IP_ADDR     TargetIPAddr;   // The target node's IP address. 
.................... } ARP_PACKET; 
....................  
.................... BOOL ARPProcess(void); 
.................... void ARPResolve(IP_ADDR* IPAddr); 
.................... BOOL ARPIsResolved(IP_ADDR* IPAddr, MAC_ADDR* MACAddr); 
.................... void SwapARPPacket(ARP_PACKET* p); 
....................  
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................    /* API specific Definitions */ 
....................    #define ARP_REQ       0x0001u      // Operation code indicating an ARP Request 
....................    #define ARP_RESP      0x0002u      // Operation code indicating an ARP Response 
....................  
....................    struct arp_app_callbacks { 
....................        BOOL used; 
....................        void (*ARPPkt_notify)(DWORD SenderIPAddr, DWORD TargetIPAddr,  
....................                              MAC_ADDR* SenderMACAddr, MAC_ADDR* TargetMACAddr, BYTE op_req); 
....................    }; 
....................    CHAR ARPRegisterCallbacks(struct arp_app_callbacks *app); 
....................    BOOL ARPDeRegisterCallbacks(CHAR id); 
.................... #endif 
....................    BOOL ARPSendPkt(DWORD SrcIPAddr, DWORD DestIPAddr, BYTE op_req ); 
.................... #endif 
....................  
....................  
....................  
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... /********************************************************************* 
....................  * 
....................  *               External serial data EEPROM Access Defs. 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        XEEPROM.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/20/02     Original (Rev. 1.0) 
.................... ********************************************************************/ 
.................... #ifndef __XEEPROM_H 
.................... #define __XEEPROM_H 
....................  
.................... #include "HardwareProfile.h" 
.................... // hardwareprofile.h 
....................  
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #if STACK_USE_CCS_EWLWIFIB || STACK_USE_CCS_EWLWIFIG 
....................  
....................    #bit WF_CS_TRIS1   =     0xF96.1 //E1 
....................    #define WF_CS_TRIS WF_CS_TRIS1 
....................    #bit WF_CS_IO     =  0xF8D.1    //LatE1 
....................    #bit WF_SDI_TRIS  =  0xF94.4    // (TRISCbits.TRISC4) 
....................    #bit WF_SCK_TRIS  =  0xF94.3    // (TRISCbits.TRISC3) 
....................    #bit WF_SDO_TRIS  =  0xF94.5    // (TRISCbits.TRISC5) 
....................    #bit WF_RESET_TRIS=  0xF93.1    //(TRISBbits.TRISB1) 
....................    #bit WF_RESET_IO  =  0xF8A.1     //(LATBbits.LATB1)   
....................    #bit WF_INT_TRIS  =  0xF93.0     // (TRISBbits.TRISB0)  // INT1 
....................    #bit WF_INT_IO    =  0xF81.0   //(PORTBbits.RB0)  
....................    #bit WF_HIBERNATE_TRIS= 0xF93.2  //(TRISBbits.TRISB2)  
....................    #bit   WF_HIBERNATE_IO=  0xF81.2    //(PORTBbits.RB2) 
....................     
....................    #bit WF_INT_EDGE  =  0xFF1.6      //(INTCON2bits.INTEDG0) 
....................    #bit WF_INT_IE    =  0xFF2.4   //(INTCONbits.INT0IE) 
....................    #bit WF_INT_IF    =  0xFF2.1   //(INTCONbits.INT0IF) 
....................    #define WF_SSPBUF  (SSP1BUF) 
....................    #define WF_SPISTAT  (SSP1STATbits) 
....................    #define WF_SPISTATbits SSP1STATbits     //(SSP1STATbits) 
....................    #define WF_SPICON1  (SSP1CON1bits) 
....................    #define WF_SPICON1bits WF_SPICON1    // (SSP1CON1bits) 
....................    #define WF_SPICON2  (SSP1CON2bits) 
....................    #bit WF_SPI_IE    =   0xF9D.3  //(PIE1bits.SSPIE) 
....................    #bit WF_SPI_IP    =   0xF9F.3  //(IPR1bits.SSPIP) 
....................    #bit WF_SPI_IF    =   0xF9E.3  //(PIR1bits.SSPIF) 
....................     
.................... #else 
....................  
.................... //#error define necessary hardware for TCPIP stack 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... typedef BOOL XEE_RESULT; 
.................... #define XEE_SUCCESS FALSE 
....................  
.................... #if defined(EEPROM_CS_TRIS)	 
.................... 	void XEEInit(void); 
.................... 	XEE_RESULT XEEBeginWrite(DWORD address); 
.................... 	XEE_RESULT XEEWrite(BYTE val); 
.................... 	void XEEWriteArray(BYTE *val, WORD wLen); 
.................... 	XEE_RESULT XEEEndWrite(void); 
.................... 	XEE_RESULT XEEBeginRead(DWORD address); 
.................... 	BYTE XEERead(void); 
.................... 	XEE_RESULT XEEReadArray(DWORD address, BYTE *buffer, WORD length); 
.................... 	XEE_RESULT XEEEndRead(void); 
.................... 	BOOL XEEIsBusy(void); 
.................... #else 
.................... 	// If you get any of these linker errors, it means that you either have an  
.................... 	// error in your HardwareProfile.h or TCPIPConfig.h definitions.  The code  
.................... 	// is attempting to call a function that can't possibly work because you  
.................... 	// have not specified what pins and SPI module the physical SPI EEPROM chip  
.................... 	// is connected to.  Alternatively, if you don't have an SPI EERPOM chip, it  
.................... 	// means you have enabled a stack feature that requires SPI EEPROM hardware. 
.................... 	// In this case, you need to edit TCPIPConfig.h and disable this stack  
.................... 	// feature.  The linker error tells you which object file this error was  
.................... 	// generated from.  It should be a clue as to what feature you need to  
.................... 	// disable. 
.................... 	void 		You_cannot_call_the_XEEInit_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEBeginWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void 		You_cannot_call_the_XEEWriteArray_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEEndWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEBeginRead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	BYTE 		You_cannot_call_the_XEERead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEReadArray_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEEndRead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	BOOL 		You_cannot_call_the_XEEIsBusy_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	#define XEEInit()				You_cannot_call_the_XEEInit_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEBeginWrite(a) 		You_cannot_call_the_XEEBeginWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEWrite(a)				You_cannot_call_the_XEEWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEWriteArray(a,b)		You_cannot_call_the_XEEWriteArray_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEEndWrite()			You_cannot_call_the_XEEEndWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEBeginRead(a)			You_cannot_call_the_XEEBeginRead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEERead(a)				You_cannot_call_the_XEERead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEReadArray(a, b, c)	You_cannot_call_the_XEEReadArray_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEEndRead()			You_cannot_call_the_XEEEndRead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEIsBusy()				You_cannot_call_the_XEEIsBusy_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... #endif 
....................  
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... /********************************************************************* 
....................  * 
....................  *  SPI Flash Memory Driver Header 
....................  *	- Tested to be compatible with SST25VF016B 
....................  *  - Expected compatibility with other SST (Microchip) SST25 series  
....................  *    devices 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        SPIFlash.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * E. Wood				3/20/08	Original 
.................... ********************************************************************/ 
.................... #ifndef __SPIFLASH_H 
.................... #define __SPIFLASH_H 
....................  
.................... #include "HardwareProfile.h" 
....................  
.................... #define SPI_FLASH_SECTOR_SIZE		(4096ul) 
.................... #define SPI_FLASH_PAGE_SIZE			(0ul)		// SST has no page boundary requirements 
....................  
.................... #define SPI_FLASH_SECTOR_MASK		(SPI_FLASH_SECTOR_SIZE - 1) 
....................  
....................  
.................... #if defined(SPIFLASH_CS_TRIS) 
.................... 	void SPIFlashInit(void);		 
.................... 	void SPIFlashReadArray(DWORD dwAddress, BYTE *vData, WORD wLen); 
.................... 	void SPIFlashBeginWrite(DWORD dwAddr); 
.................... 	void SPIFlashWrite(BYTE vData); 
.................... 	void SPIFlashWriteArray(BYTE *vData, WORD wLen); 
.................... 	void SPIFlashEraseSector(DWORD dwAddr); 
.................... #else 
.................... 	// If you get any of these linker errors, it means that you either have an  
.................... 	// error in your HardwareProfile.h or TCPIPConfig.h definitions.  The code  
.................... 	// is attempting to call a function that can't possibly work because you  
.................... 	// have not specified what pins and SPI module the physical SPI Flash chip  
.................... 	// is connected to.  Alternatively, if you don't have an SPI Flash chip, it  
.................... 	// means you have enabled a stack feature that requires SPI Flash hardware. 
.................... 	// In this case, you need to edit TCPIPConfig.h and disable this stack  
.................... 	// feature.  The linker error tells you which object file this error was  
.................... 	// generated from.  It should be a clue as to what feature you need to  
.................... 	// disable. 
.................... 	void You_cannot_call_the_SPIFlashInit_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashReadArray_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashBeginWrite_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashWrite_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashWriteArray_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashEraseSector_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	#define SPIFlashInit()				You_cannot_call_the_SPIFlashInit_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashReadArray(a,b,c)	You_cannot_call_the_SPIFlashReadArray_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashBeginWrite(a)		You_cannot_call_the_SPIFlashBeginWrite_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashWrite(a)			You_cannot_call_the_SPIFlashWrite_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashWriteArray(a,b)		You_cannot_call_the_SPIFlashWriteArray_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashEraseSector(a)		You_cannot_call_the_SPIFlashEraseSector_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... #endif 
....................  
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/SPIRAM.h" 
.................... /********************************************************************* 
....................  * 
....................  * Data SPI RAM Access Routines 
....................  *  -Tested with AMI Semiconductor N256S0830HDA 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        SPIRAM.h 
....................  * Dependencies:    Compiler.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * \file SPIRAM.h 
....................  * \author Howard Henry Schlunder 
....................  * \date 25 July 2007 
.................... ********************************************************************/ 
.................... #ifndef __SPIRAM_H 
.................... #define __SPIRAM_H 
....................  
.................... #include "HardwareProfile.h" 
.................... // hardwareprofile.h 
....................  
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #if STACK_USE_CCS_EWLWIFIB || STACK_USE_CCS_EWLWIFIG 
....................  
....................    #bit WF_CS_TRIS1   =     0xF96.1 //E1 
....................    #define WF_CS_TRIS WF_CS_TRIS1 
....................    #bit WF_CS_IO     =  0xF8D.1    //LatE1 
....................    #bit WF_SDI_TRIS  =  0xF94.4    // (TRISCbits.TRISC4) 
....................    #bit WF_SCK_TRIS  =  0xF94.3    // (TRISCbits.TRISC3) 
....................    #bit WF_SDO_TRIS  =  0xF94.5    // (TRISCbits.TRISC5) 
....................    #bit WF_RESET_TRIS=  0xF93.1    //(TRISBbits.TRISB1) 
....................    #bit WF_RESET_IO  =  0xF8A.1     //(LATBbits.LATB1)   
....................    #bit WF_INT_TRIS  =  0xF93.0     // (TRISBbits.TRISB0)  // INT1 
....................    #bit WF_INT_IO    =  0xF81.0   //(PORTBbits.RB0)  
....................    #bit WF_HIBERNATE_TRIS= 0xF93.2  //(TRISBbits.TRISB2)  
....................    #bit   WF_HIBERNATE_IO=  0xF81.2    //(PORTBbits.RB2) 
....................     
....................    #bit WF_INT_EDGE  =  0xFF1.6      //(INTCON2bits.INTEDG0) 
....................    #bit WF_INT_IE    =  0xFF2.4   //(INTCONbits.INT0IE) 
....................    #bit WF_INT_IF    =  0xFF2.1   //(INTCONbits.INT0IF) 
....................    #define WF_SSPBUF  (SSP1BUF) 
....................    #define WF_SPISTAT  (SSP1STATbits) 
....................    #define WF_SPISTATbits SSP1STATbits     //(SSP1STATbits) 
....................    #define WF_SPICON1  (SSP1CON1bits) 
....................    #define WF_SPICON1bits WF_SPICON1    // (SSP1CON1bits) 
....................    #define WF_SPICON2  (SSP1CON2bits) 
....................    #bit WF_SPI_IE    =   0xF9D.3  //(PIE1bits.SSPIE) 
....................    #bit WF_SPI_IP    =   0xF9F.3  //(IPR1bits.SSPIP) 
....................    #bit WF_SPI_IF    =   0xF9E.3  //(PIR1bits.SSPIF) 
....................     
.................... #else 
....................  
.................... //#error define necessary hardware for TCPIP stack 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #if defined(SPIRAM_CS_TRIS) 
.................... 	void SPIRAMInit(void); 
.................... 	void SPIRAMGetArray(WORD wAddress, BYTE *vData, WORD wLength); 
.................... 	void SPIRAMPutArray(WORD wAddress, BYTE *vData, WORD wLength); 
.................... 	 
.................... 	#define SPIRAMPutString(a,b)			SPIRAMPutArray(a, strlen((char*)b)) 
.................... 	 
.................... 	#if defined(__18CXX) 
.................... 		void SPIRAMPutROMArray(WORD wAddress, ROM BYTE *vData, WORD wLength); 
.................... 		#define SPIRAMPutROMString(a,b)		SPIRAMPutROMArray(a, strlenpgm((ROM char*)b)) 
.................... 	#else 
.................... 		#define SPIRAMPutROMString(a,b)		SPIRAMPutArray(a, strlen((char*)b)) 
.................... 		#define SPIRAMPutROMArray(a,b,c)	SPIRAMPutROMArray(a, b, c) 
.................... 	#endif 
.................... #else 
.................... 	// If you get any of these linker errors, it means that you either have an  
.................... 	// error in your HardwareProfile.h or TCPIPConfig.h definitions.  The code  
.................... 	// is attempting to call a function that can't possibly work because you  
.................... 	// have not specified what pins and SPI module the physical SPI SRAM chip  
.................... 	// is connected to.  Alternatively, if you don't have an SPI SRAM chip, it  
.................... 	// means you have enabled a stack feature that requires SPI SRAM hardware. 
.................... 	// In this case, you need to edit TCPIPConfig.h and disable this stack  
.................... 	// feature.  The linker error tells you which object file this error was  
.................... 	// generated from.  It should be a clue as to what feature you need to  
.................... 	// disable. 
.................... 	void You_cannot_call_the_SPIRAMInit_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMGetArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMPutArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMPutString_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMPutROMArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMPutROMString_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	#define SPIRAMInit()				You_cannot_call_the_SPIRAMInit_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMGetArray(a,b,c)		You_cannot_call_the_SPIRAMGetArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMPutArray(a,b,c)		You_cannot_call_the_SPIRAMPutArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMPutString(a,b)		You_cannot_call_the_SPIRAMPutString_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMPutROMArray(a,b,c)	You_cannot_call_the_SPIRAMPutROMArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMPutROMString(a,b)		You_cannot_call_the_SPIRAMPutROMString_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... #endif 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  UDP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        UDP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/19/01  Original        (Rev 1.0) 
....................  ********************************************************************/ 
.................... #ifndef __UDP_H 
.................... #define __UDP_H 
....................  
.................... // Stores a UDP Port Number 
.................... typedef WORD UDP_PORT; 
....................  
.................... // Provides a handle to a UDP Socket 
.................... typedef BYTE UDP_SOCKET; 
....................  
.................... // UDP States  
.................... typedef enum 
.................... { 
.................... 	UDP_DNS_IS_RESOLVED,		// Special state for UDP client mode sockets 
.................... 	UDP_DNS_RESOLVE,		// Special state for UDP client mode sockets 
.................... 	UDP_GATEWAY_SEND_ARP,	// Special state for UDP client mode sockets 
.................... 	UDP_GATEWAY_GET_ARP,		// Special state for UDP client mode sockets	 
....................     UDP_CLOSED,				// Socket is idle and unallocated 
.................... 	UDP_OPENED 
.................... } UDP_STATE; 
....................  
....................  
.................... // Stores information about a current UDP socket 
.................... typedef struct 
.................... { 
.................... 	union 
.................... 	{ 
.................... 		NODE_INFO	remoteNode;		// 10 bytes for MAC and IP address 
.................... 		DWORD		remoteHost;		// RAM or ROM pointer to a hostname string (ex: "www.microchip.com") 
.................... 	} remote; 
....................     //NODE_INFO   remoteNode;		// IP and MAC of remote node 
....................     UDP_PORT    remotePort;		// Remote node's UDP port number 
....................     UDP_PORT    localPort;		// Local UDP port number, or INVALID_UDP_PORT when free 
....................     UDP_STATE smState;			// State of this socket 
....................     DWORD retryInterval; 
.................... 	BYTE retryCount; 
.................... 	struct 
.................... 	{ 
.................... 		unsigned char bRemoteHostIsROM : 1;	// Remote host is stored in ROM 
.................... 	}flags; 
.................... 	WORD eventTime; 
.................... } UDP_SOCKET_INFO; 
....................  
....................  
.................... #define INVALID_UDP_SOCKET      (0xffu)		// Indicates a UDP socket that is not valid 
.................... #define INVALID_UDP_PORT        (0ul)		// Indicates a UDP port that is not valid 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	External Global Variables 
....................   ***************************************************************************/ 
.................... #if !defined(__UDP_C) 
....................     extern UDP_SOCKET activeUDPSocket; 
....................     extern UDP_SOCKET_INFO  UDPSocketInfo[MAX_UDP_SOCKETS]; 
.................... 	extern WORD UDPTxCount; 
.................... 	extern WORD UDPRxCount; 
.................... #endif 
....................  
.................... // Stores the header of a UDP packet 
.................... typedef struct 
.................... { 
....................     UDP_PORT    SourcePort;				// Source UDP port 
....................     UDP_PORT    DestinationPort;		// Destination UDP port 
....................     WORD        Length;					// Length of data 
....................     WORD        Checksum;				// UDP checksum of the data 
.................... } UDP_HEADER; 
....................  
....................  
.................... // Create a server socket and ignore dwRemoteHost. 
.................... #define UDP_OPEN_SERVER		0u 
.................... #if defined(STACK_CLIENT_MODE) 
.................... 	#if defined(STACK_USE_DNS) 
.................... 		// Create a client socket and use dwRemoteHost as a RAM pointer to a hostname string. 
.................... 		#define UDP_OPEN_RAM_HOST	1u 
.................... 		// Create a client socket and use dwRemoteHost as a ROM pointer to a hostname string. 
.................... 		#define UDP_OPEN_ROM_HOST	2u 
.................... 	#else 
.................... 		// Emit an undeclared identifier diagnostic if code tries to use UDP_OPEN_RAM_HOST while the DNS client module is not enabled.  
.................... 		#define UDP_OPEN_RAM_HOST	You_need_to_enable_STACK_USE_DNS_to_use_UDP_OPEN_RAM_HOST 
.................... 		// Emit an undeclared identifier diagnostic if code tries to use UDP_OPEN_ROM_HOST while the DNS client module is not enabled.  
.................... 		#define UDP_OPEN_ROM_HOST	You_need_to_enable_STACK_USE_DNS_to_use_UDP_OPEN_ROM_HOST 
.................... 	#endif 
.................... 	// Create a client socket and use dwRemoteHost as a literal IP address. 
.................... 	#define UDP_OPEN_IP_ADDRESS	3u 
.................... #endif 
....................  
.................... // Create a client socket and use dwRemoteHost as a pointer to a NODE_INFO structure containing the exact remote IP address and MAC address to use. 
.................... #define UDP_OPEN_NODE_INFO	4u 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	Function Prototypes 
....................   ***************************************************************************/ 
.................... void UDPInit(void); 
.................... void UDPTask(void); 
.................... UDP_SOCKET UDPOpenEx(DWORD remoteHost, BYTE remoteHostType, UDP_PORT localPort,UDP_PORT remotePort); 
....................  
.................... //UDP_SOCKET UDPOpen(UDP_PORT localPort, NODE_INFO *remoteNode, UDP_PORT remotePort); 
.................... void UDPClose(UDP_SOCKET s); 
.................... BOOL UDPProcess(NODE_INFO *remoteNode, IP_ADDR *localIP, WORD len); 
....................  
.................... void UDPSetTxBuffer(WORD wOffset); 
.................... void UDPSetRxBuffer(WORD wOffset); 
.................... WORD UDPIsPutReady(UDP_SOCKET s); 
.................... BOOL UDPPut(BYTE v); 
.................... WORD UDPPutArray(BYTE *cData, WORD wDataLen); 
.................... BYTE* UDPPutString(BYTE *strData); 
.................... void UDPFlush(void); 
....................  
.................... // ROM function variants for PIC18 
.................... #if defined(__18CXX) 
.................... 	WORD UDPPutROMArray(ROM BYTE *cData, WORD wDataLen); 
.................... 	ROM BYTE* UDPPutROMString(ROM BYTE *strData); 
.................... #else 
.................... 	#define UDPPutROMArray(a,b)	UDPPutArray((BYTE*)a,b) 
.................... 	#define UDPPutROMString(a)	UDPPutString((BYTE*)a) 
.................... #endif 
....................  
.................... WORD UDPIsGetReady(UDP_SOCKET s); 
.................... BOOL UDPGet(BYTE *v); 
.................... WORD UDPGetArray(BYTE *cData, WORD wDataLen); 
.................... void UDPDiscard(void); 
.................... BOOL UDPIsOpened(UDP_SOCKET socket); 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     UDP_SOCKET UDPOpen(UDP_PORT localPort, NODE_INFO* remoteNode,  
....................                         UDP_PORT remotePort) 
....................  
....................   Summary: 
....................     Macro of the legacy version of UDPOpen. 
....................      
....................   Description: 
....................     UDPOpen is a macro replacement of the legacy implementation of UDPOpen. 
....................     Creates a UDP socket handle for transmiting or receiving UDP packets.   
....................     Call this function to obtain a handle required by other UDP function. 
....................  
....................   Precondition: 
....................     UDPInit() must have been previously called. 
....................  
....................   Parameters: 
....................     localPort - UDP port number to listen on.  If 0, stack will dynamically  
....................         assign a unique port number to use. 
....................     remoteNode - Pointer to remote node info (MAC and IP address) for this 
....................         connection.  If this is a server socket (receives the first packet)  
....................         or the destination is the broadcast address, then this parameter 
....................         should be NULL. 
....................     remotePort - For client sockets, the remote port number. 
....................  
....................   Return Values: 
....................     Success - 
....................         A UDP socket handle that can be used for subsequent UDP API calls. 
....................     Failure - 
....................         INVALID_UDP_SOCKET.  This function fails when no more UDP socket  
....................         handles are available.  Increase MAX_UDP_SOCKETS to make more sockets  
....................         available. 
....................      
....................   Remarks: 
....................     When finished using the UDP socket handle, call the UDPClose() function  
....................     to free the socket and delete the handle. 
....................   ***************************************************************************/ 
.................... #define UDPOpen(localPort,remoteNode,remotePort)  UDPOpenEx((DWORD)remoteNode,UDP_OPEN_NODE_INFO,localPort,remotePort) 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCP.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    	Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01  	Original        (Rev 1.0) 
....................  * Howard Schlunder		11/30/06	See "TCPIP Stack Version.txt" file 
....................  ********************************************************************/ 
.................... #ifndef __TCP_HITECH_WORKAROUND_H 
.................... #define __TCP_HITECH_WORKAROUND_H 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	Type Definitions 
....................   ***************************************************************************/ 
....................  
.................... // A TCP_SOCKET is stored as a single BYTE 
.................... typedef BYTE TCP_SOCKET; 
....................  
.................... #define INVALID_SOCKET      (0xFE)	// The socket is invalid or could not be opened 
.................... #define UNKNOWN_SOCKET      (0xFF)	// The socket is not known 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	State Machine Variables 
....................   ***************************************************************************/ 
....................  
.................... // TCP States as defined by RFC 793 
.................... typedef enum 
.................... { 
.................... 	TCP_GET_DNS_MODULE,		// Special state for TCP client mode sockets 
.................... 	TCP_DNS_RESOLVE,		// Special state for TCP client mode sockets 
.................... 	TCP_GATEWAY_SEND_ARP,	// Special state for TCP client mode sockets 
.................... 	TCP_GATEWAY_GET_ARP,	// Special state for TCP client mode sockets 
....................  
....................     TCP_LISTEN,				// Socket is listening for connections 
....................     TCP_SYN_SENT,			// A SYN has been sent, awaiting an SYN+ACK 
....................     TCP_SYN_RECEIVED,		// A SYN has been received, awaiting an ACK 
....................     TCP_ESTABLISHED,		// Socket is connected and connection is established 
....................     TCP_FIN_WAIT_1,			// FIN WAIT state 1 
....................     TCP_FIN_WAIT_2,			// FIN WAIT state 2 
....................     TCP_CLOSING,			// Socket is closing 
.................... //	TCP_TIME_WAIT, state is not implemented 
.................... 	TCP_CLOSE_WAIT,			// Waiting to close the socket 
....................     TCP_LAST_ACK,			// The final ACK has been sent 
....................     TCP_CLOSED,				// Socket is idle and unallocated 
....................  
....................     TCP_CLOSED_BUT_RESERVED	// Special state for TCP client mode sockets.  Socket is idle, but still allocated pending application closure of the handle. 
.................... } TCP_STATE; 
....................  
.................... typedef enum 
.................... { 
.................... 	SSL_NONE = 0,			// No security is enabled 
.................... 	SSL_HANDSHAKING,		// Handshake is progressing (no application data allowed) 
.................... 	SSL_ESTABLISHED,		// Connection is established and secured 
.................... 	SSL_CLOSED				// Connection has been closed (no applicaiton data is allowed) 
.................... } SSL_STATE; 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	TCB Definitions 
....................   ***************************************************************************/ 
....................  
.................... // TCP Control Block (TCB) stub data storage.  Stubs are stored in local PIC RAM for speed. 
.................... // Current size is 34 bytes (PIC18), 36 bytes (PIC24/dsPIC), or 56 (PIC32) 
.................... typedef struct 
.................... { 
.................... 	PTR_BASE bufferTxStart;		// First byte of TX buffer 
.................... 	PTR_BASE bufferRxStart;		// First byte of RX buffer.  TX buffer ends 1 byte prior 
.................... 	PTR_BASE bufferEnd;			// Last byte of RX buffer 
.................... 	PTR_BASE txHead;			// Head pointer for TX 
.................... 	PTR_BASE txTail;			// Tail pointer for TX 
.................... 	PTR_BASE rxHead;			// Head pointer for RX 
.................... 	PTR_BASE rxTail;			// Tail pointer for RX 
....................     DWORD eventTime;			// Packet retransmissions, state changes 
.................... 	WORD eventTime2;			// Window updates, automatic transmission 
.................... 	union 
.................... 	{ 
.................... 		WORD delayedACKTime;	// Delayed Acknowledgement timer 
.................... 		WORD closeWaitTime;		// TCP_CLOSE_WAIT timeout timer 
.................... 	} OverlappedTimers; 
....................     TCP_STATE smState;			// State of this socket 
....................     struct 
....................     { 
.................... 	    unsigned char vUnackedKeepalives : 3;		// Count of how many keepalives have been sent with no response 
....................         unsigned char bServer : 1;					// Socket should return to listening state when closed 
.................... 		unsigned char bTimerEnabled	: 1;			// Timer is enabled 
.................... 		unsigned char bTimer2Enabled : 1;			// Second timer is enabled 
.................... 		unsigned char bDelayedACKTimerEnabled : 1;	// DelayedACK timer is enabled 
.................... 		unsigned char bOneSegmentReceived : 1;		// A segment has been received 
.................... 		unsigned char bHalfFullFlush : 1;			// Flush is for being half full 
.................... 		unsigned char bTXASAP : 1;					// Transmit as soon as possible (for Flush) 
.................... 		unsigned char bTXASAPWithoutTimerReset : 1;	// Transmit as soon as possible (for Flush), but do not reset retransmission timers 
.................... 		unsigned char bTXFIN : 1;					// FIN needs to be transmitted 
.................... 		unsigned char bSocketReset : 1;				// Socket has been reset (self-clearing semaphore) 
.................... 		unsigned char bSSLHandshaking : 1;			// Socket is in an SSL handshake 
.................... 		unsigned char filler : 2;					// Future expansion 
....................     } Flags; 
.................... 	WORD_VAL remoteHash;	// Consists of remoteIP, remotePort, localPort for connected sockets.  It is a localPort number only for listening server sockets. 
....................  
....................     #if defined(STACK_USE_SSL) 
....................     PTR_BASE sslTxHead;		// Position of data being written in next SSL application record 
....................     						//   Also serves as cache of localSSLPort when smState = TCP_LISTENING 
....................     PTR_BASE sslRxHead;		// Position of incoming data not yet handled by SSL 
....................     BYTE sslStubID;			// Which sslStub is associated with this connection 
....................     BYTE sslReqMessage;		// Currently requested SSL message 
....................     #endif 
....................  
.................... 	BYTE vMemoryMedium;		// Which memory medium the TCB is actually stored 
.................... 	 
.................... } TCB_STUB; 
....................  
.................... // Remainder of TCP Control Block data. 
.................... // The rest of the TCB is stored in Ethernet buffer RAM or elsewhere as defined by vMemoryMedium. 
.................... // Current size is 41 (PIC18), 42 (PIC24/dsPIC), or 48 bytes (PIC32) 
.................... typedef struct 
.................... { 
.................... 	DWORD		retryInterval;			// How long to wait before retrying transmission 
.................... 	DWORD		MySEQ;					// Local sequence number 
.................... 	DWORD		RemoteSEQ;				// Remote sequence number 
.................... 	PTR_BASE	txUnackedTail;			// TX tail pointer for data that is not yet acked 
....................     WORD_VAL	remotePort;				// Remote port number 
....................     WORD_VAL	localPort;				// Local port number 
.................... 	WORD		remoteWindow;			// Remote window size 
.................... 	WORD		wFutureDataSize;		// How much out-of-order data has been received 
.................... 	union 
.................... 	{ 
.................... 		NODE_INFO	niRemoteMACIP;		// 10 bytes for MAC and IP address 
.................... 		DWORD		dwRemoteHost;		// RAM or ROM pointer to a hostname string (ex: "www.microchip.com") 
.................... 	} remote; 
.................... 	SHORT		sHoleSize;				// Size of the hole, or -1 for none exists.  (0 indicates hole has just been filled) 
....................     struct 
....................     { 
....................         unsigned char bFINSent : 1;		// A FIN has been sent 
.................... 		unsigned char bSYNSent : 1;		// A SYN has been sent 
.................... 		unsigned char bRemoteHostIsROM : 1;	// Remote host is stored in ROM 
.................... 		unsigned char bRXNoneACKed1 : 1;	// A duplicate ACK was likely received 
.................... 		unsigned char bRXNoneACKed2 : 1;	// A second duplicate ACK was likely received 
.................... 		unsigned char filler : 3;		// future use 
....................     } flags; 
.................... 	WORD		wRemoteMSS;				// Maximum Segment Size option advirtised by the remote node during initial handshaking 
....................     #if defined(STACK_USE_SSL) 
....................     WORD_VAL	localSSLPort;			// Local SSL port number (for listening sockets) 
....................     #endif 
.................... 	BYTE		retryCount;				// Counter for transmission retries 
.................... 	BYTE		vSocketPurpose;			// Purpose of socket (as defined in TCPIPConfig.h) 
.................... } TCB; 
....................  
.................... // Information about a socket 
.................... typedef struct 
.................... { 
.................... 	NODE_INFO remote;		// NODE_INFO structure for remote node 
.................... 	WORD_VAL remotePort;	// Port number associated with remote node 
.................... } SOCKET_INFO; 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	Function Declarations 
....................   ***************************************************************************/ 
....................  
.................... void TCPInit(void); 
.................... SOCKET_INFO* TCPGetRemoteInfo(TCP_SOCKET hTCP); 
.................... BOOL TCPWasReset(TCP_SOCKET hTCP); 
.................... BOOL TCPIsConnected(TCP_SOCKET hTCP); 
.................... void TCPDisconnect(TCP_SOCKET hTCP); 
.................... void TCPClose(TCP_SOCKET hTCP); 
.................... WORD TCPIsPutReady(TCP_SOCKET hTCP); 
.................... BOOL TCPPut(TCP_SOCKET hTCP, BYTE byte); 
.................... WORD TCPPutArray(TCP_SOCKET hTCP, BYTE* Data, WORD Len); 
.................... BYTE* TCPPutString(TCP_SOCKET hTCP, BYTE* Data); 
.................... WORD TCPIsGetReady(TCP_SOCKET hTCP); 
.................... WORD TCPGetRxFIFOFree(TCP_SOCKET hTCP); 
.................... BOOL TCPGet(TCP_SOCKET hTCP, BYTE* byte); 
.................... WORD TCPGetArray(TCP_SOCKET hTCP, BYTE* buffer, WORD count); 
.................... BYTE TCPPeek(TCP_SOCKET hTCP, WORD wStart); 
.................... WORD TCPPeekArray(TCP_SOCKET hTCP, BYTE *vBuffer, WORD wLen, WORD wStart); 
.................... WORD TCPFindEx(TCP_SOCKET hTCP, BYTE cFind, WORD wStart, WORD wSearchLen, BOOL bTextCompare); 
.................... WORD TCPFindArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare); 
.................... void TCPDiscard(TCP_SOCKET hTCP); 
.................... BOOL TCPProcess(NODE_INFO* remote, IP_ADDR* localIP, WORD len); 
.................... void TCPTick(void); 
.................... void TCPFlush(TCP_SOCKET hTCP); 
....................  
.................... // Create a server socket and ignore dwRemoteHost. 
.................... #define TCP_OPEN_SERVER		0u 
.................... #if defined(STACK_CLIENT_MODE) 
.................... 	#if defined(STACK_USE_DNS) 
.................... 		// Create a client socket and use dwRemoteHost as a RAM pointer to a hostname string. 
.................... 		#define TCP_OPEN_RAM_HOST	1u 
.................... 		// Create a client socket and use dwRemoteHost as a ROM pointer to a hostname string. 
.................... 		#define TCP_OPEN_ROM_HOST	2u 
.................... 	#else 
.................... 		// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_RAM_HOST while the DNS client module is not enabled.  
.................... 		#define TCP_OPEN_RAM_HOST	You_need_to_enable_STACK_USE_DNS_to_use_TCP_OPEN_RAM_HOST 
.................... 		// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_ROM_HOST while the DNS client module is not enabled.  
.................... 		#define TCP_OPEN_ROM_HOST	You_need_to_enable_STACK_USE_DNS_to_use_TCP_OPEN_ROM_HOST 
.................... 	#endif 
.................... 	// Create a client socket and use dwRemoteHost as a literal IP address. 
.................... 	#define TCP_OPEN_IP_ADDRESS	3u 
.................... 	// Create a client socket and use dwRemoteHost as a pointer to a NODE_INFO structure containing the exact remote IP address and MAC address to use. 
.................... 	#define TCP_OPEN_NODE_INFO	4u 
.................... #else 
.................... 	// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_RAM_HOST while STACK_CLIENT_MODE feature is not enabled.  
.................... 	#define TCP_OPEN_RAM_HOST	You_need_to_enable_STACK_CLIENT_MODE_to_use_TCP_OPEN_RAM_HOST 
.................... 	// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_ROM_HOST while STACK_CLIENT_MODE feature is not enabled.  
.................... 	#define TCP_OPEN_ROM_HOST	You_need_to_enable_STACK_CLIENT_MODE_to_use_TCP_OPEN_ROM_HOST 
.................... 	// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_IP_ADDRESS while STACK_CLIENT_MODE feature is not enabled.  
.................... 	#define TCP_OPEN_IP_ADDRESS	You_need_to_enable_STACK_CLIENT_MODE_to_use_TCP_OPEN_IP_ADDRESS 
.................... 	// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_NODE_INFO while STACK_CLIENT_MODE feature is not enabled.  
.................... 	#define TCP_OPEN_NODE_INFO	You_need_to_enable_STACK_CLIENT_MODE_to_use_TCP_OPEN_NODE_INFO 
.................... #endif 
.................... TCP_SOCKET TCPOpen(DWORD dwRemoteHost, BYTE vRemoteHostType, WORD wPort, BYTE vSocketPurpose); 
....................  
.................... #if defined(__18CXX) 
.................... 	WORD TCPFindROMArrayEx(TCP_SOCKET hTCP, ROM BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare); 
....................  
.................... 	/***************************************************************************** 
.................... 	  Summary: 
.................... 		Alias to TCPFindROMArrayEx with no length parameter. 
.................... 	 
.................... 	  Description: 
.................... 		This function is an alias to TCPFindROMArrayEx with no length parameter.   
.................... 		It is provided for backwards compatibility with an older API. 
.................... 	  ***************************************************************************/ 
.................... 	#define TCPFindROMArray(a,b,c,d,e)		TCPFindROMArrayEx(a,b,c,d,0,e) 
.................... 	 
.................... 	WORD TCPPutROMArray(TCP_SOCKET hTCP, ROM BYTE* Data, WORD Len); 
.................... 	ROM BYTE* TCPPutROMString(TCP_SOCKET hTCP, ROM BYTE* Data); 
.................... #else 
.................... 	#define TCPFindROMArray(a,b,c,d,e) 		TCPFindArray(a,(BYTE*)b,c,d,e) 
.................... 	#define TCPFindROMArrayEx(a,b,c,d,e,f) 	TCPFindArrayEx(a,(BYTE*)b,c,d,e,f) 
.................... 	#define TCPPutROMArray(a,b,c)			TCPPutArray(a,(BYTE*)b,c) 
.................... 	#define TCPPutROMString(a,b)			TCPPutString(a,(BYTE*)b) 
.................... #endif 
....................  
.................... WORD TCPGetTxFIFOFull(TCP_SOCKET hTCP); 
.................... // Alias to TCPIsGetReady provided for API completeness 
.................... #define TCPGetRxFIFOFull(a)					TCPIsGetReady(a) 
.................... // Alias to TCPIsPutReady provided for API completeness 
.................... #define TCPGetTxFIFOFree(a) 				TCPIsPutReady(a) 
....................  
.................... #define TCP_ADJUST_GIVE_REST_TO_RX	0x01u	// Resize flag: extra bytes go to RX  
.................... #define TCP_ADJUST_GIVE_REST_TO_TX	0x02u	// Resize flag: extra bytes go to TX 
.................... #define TCP_ADJUST_PRESERVE_RX		0x04u	// Resize flag: attempt to preserve RX buffer 
.................... #define TCP_ADJUST_PRESERVE_TX		0x08u	// Resize flag: attempt to preserve TX buffer 
.................... BOOL TCPAdjustFIFOSize(TCP_SOCKET hTCP, WORD wMinRXSize, WORD wMinTXSize, BYTE vFlags); 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... BOOL TCPStartSSLClient(TCP_SOCKET hTCP, BYTE* host); 
.................... BOOL TCPStartSSLClientEx(TCP_SOCKET hTCP, BYTE* host, void * buffer, BYTE suppDataType); 
.................... BOOL TCPStartSSLServer(TCP_SOCKET hTCP); 
.................... BOOL TCPAddSSLListener(TCP_SOCKET hTCP, WORD port); 
.................... BOOL TCPRequestSSLMessage(TCP_SOCKET hTCP, BYTE msg); 
.................... BOOL TCPSSLIsHandshaking(TCP_SOCKET hTCP); 
.................... BOOL TCPIsSSL(TCP_SOCKET hTCP); 
.................... void TCPSSLHandshakeComplete(TCP_SOCKET hTCP); 
.................... void TCPSSLDecryptMAC(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, WORD len); 
.................... void TCPSSLInPlaceMACEncrypt(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, BYTE* MACSecret, WORD len); 
.................... void TCPSSLPutRecordHeader(TCP_SOCKET hTCP, BYTE* hdr, BOOL recDone); 
.................... WORD TCPSSLGetPendingTxSize(TCP_SOCKET hTCP); 
.................... void TCPSSLHandleIncoming(TCP_SOCKET hTCP); 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Summary: 
.................... 	Alias to TCPFindEx with no length parameter. 
....................  
....................   Description: 
.................... 	This function is an alias to TCPFindEx with no length parameter.  It is 
.................... 	provided for backwards compatibility with an older API. 
....................   ***************************************************************************/ 
.................... #define TCPFind(a,b,c,d)					TCPFindEx(a,b,c,0,d) 
....................  
....................  
.................... /***************************************************************************** 
....................   Summary: 
.................... 	Alias to TCPFindArrayEx with no length parameter. 
....................  
....................   Description: 
.................... 	This function is an alias to TCPFindArrayEx with no length parameter.  It is 
.................... 	provided for backwards compatibility with an older API. 
....................   ***************************************************************************/ 
.................... #define TCPFindArray(a,b,c,d,e)				TCPFindArrayEx(a,b,c,d,0,e) 
....................  
.................... /***************************************************************************** 
....................   Summary: 
.................... 	Alias to TCPOpen as a server. 
....................  
....................   Description: 
.................... 	This function is an alias to TCPOpen for server sockets.  It is provided 
.................... 	for backwards compatibility with older versions of the stack.  New 
.................... 	applications should use the TCPOpen API instead. 
....................   ***************************************************************************/ 
.................... #define TCPListen(port)			TCPOpen(0, TCP_OPEN_SERVER, port, TCP_PURPOSE_DEFAULT) 
....................  
.................... /***************************************************************************** 
....................   Summary: 
.................... 	Alias to TCPOpen as a client. 
....................  
....................   Description: 
.................... 	This function is an alias to TCPOpen for client sockets.  It is provided 
.................... 	for backwards compatibility with older versions of the stack.  New 
.................... 	applications should use the TCPOpen API instead. 
....................   ***************************************************************************/ 
.................... #define TCPConnect(remote,port)	TCPOpen((DWORD)remote, TCP_OPEN_NODE_INFO, port, TCP_PURPOSE_DEFAULT) 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... /********************************************************************* 
....................  * 
....................  *	DNS Client Module Header 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        DNS.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date		Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder     7/31/06		Original 
....................  * Howard Schlunder		10/09/06	Added DNSBeginUsage(), DNSEndUsage()  
....................  *									module ownership semaphore 
....................  ********************************************************************/ 
.................... #ifndef __DNS_H 
.................... #define __DNS_H 
....................  
....................  
.................... #define DNS_TYPE_A				(1u)		// Constant for record type in DNSResolve.  Indicates an A (standard address) record. 
.................... #define DNS_TYPE_MX				(15u)		// Constant for record type in DNSResolve.  Indicates an MX (mail exchanger) record. 
....................  
.................... BOOL DNSBeginUsage(void); 
.................... void DNSResolve(BYTE* HostName, BYTE Type); 
.................... BOOL DNSIsResolved(IP_ADDR* HostIP); 
.................... BOOL DNSEndUsage(void); 
....................  
.................... #if defined(__18CXX) 
.................... 	void DNSResolveROM(ROM BYTE* Hostname, BYTE Type); 
.................... #else 
.................... 	// Non-ROM variant for C30/C32 
.................... 	#define DNSResolveROM(a,b)	DNSResolve((BYTE*)a,b) 
.................... #endif 
....................  
....................  
.................... // DNSs.c function prototypes 
.................... void DNSServerTask(void); 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    	Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		03/16/07	Original 
....................  ********************************************************************/ 
.................... #ifndef __ICMP_H 
.................... #define __ICMP_H 
....................  
.................... void ICMPProcess(NODE_INFO *remote, WORD len); 
....................  
.................... BOOL ICMPBeginUsage(void); 
.................... void ICMPSendPing(DWORD dwRemoteIP); 
.................... void ICMPSendPingToHost(BYTE * szRemoteHost); 
.................... LONG ICMPGetReply(void); 
.................... void ICMPEndUsage(void); 
....................  
.................... #if defined(__18CXX) 
.................... 	void ICMPSendPingToHostROM(ROM BYTE * szRemoteHost); 
.................... #else 
.................... 	#define ICMPSendPingToHostROM(a) 	ICMPSendPingToHost((BYTE*)(a)) 
.................... #endif 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... /********************************************************************* 
....................  * 
....................  *	DNS Client Module Header 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        DNS.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date		Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder     7/31/06		Original 
....................  * Howard Schlunder		10/09/06	Added DNSBeginUsage(), DNSEndUsage()  
....................  *									module ownership semaphore 
....................  ********************************************************************/ 
.................... #ifndef __DNS_H 
.................... #define __DNS_H 
....................  
....................  
.................... #define DNS_TYPE_A				(1u)		// Constant for record type in DNSResolve.  Indicates an A (standard address) record. 
.................... #define DNS_TYPE_MX				(15u)		// Constant for record type in DNSResolve.  Indicates an MX (mail exchanger) record. 
....................  
.................... BOOL DNSBeginUsage(void); 
.................... void DNSResolve(BYTE* HostName, BYTE Type); 
.................... BOOL DNSIsResolved(IP_ADDR* HostIP); 
.................... BOOL DNSEndUsage(void); 
....................  
.................... #if defined(__18CXX) 
.................... 	void DNSResolveROM(ROM BYTE* Hostname, BYTE Type); 
.................... #else 
.................... 	// Non-ROM variant for C30/C32 
.................... 	#define DNSResolveROM(a,b)	DNSResolve((BYTE*)a,b) 
.................... #endif 
....................  
....................  
.................... // DNSs.c function prototypes 
.................... void DNSServerTask(void); 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #if defined(MRF24WG) 
....................  #define WF_DisplayModuleAssertInfo() 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_CCS_HTTP1_SERVER) 
....................    #include "ccs_HTTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    #include "ccs_HTTP2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_TWITTER) 
....................    #include "ccs_twitter.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SMTP) 
....................    #include "ccs_SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_TFTP_SERVER) 
....................    #include "ccs_TFTPs.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    #include "ccs_SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_GRATUITOUS_ARP) 
....................    #include "ccs_gratarp.h" 
.................... #endif 
....................  
.................... #define TickGetDiff(a, b)  (a-b) 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................        #if !defined(STACK_USE_DNS) 
....................            #define STACK_USE_DNS 
....................        #endif 
....................        #if !defined(STACK_USE_UDP) 
....................            #define STACK_USE_UDP 
....................        #endif        
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    #ifndef STACK_USE_MPFS 
....................       #define STACK_USE_MPFS 
....................     #endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    #if !defined(STACK_CLIENT_MODE) 
....................        #define STACK_CLIENT_MODE 
....................    #endif 
.................... #endif 
....................  
.................... #if STACK_USE_WIFI 
....................    // if defined, MyWFIsConnected() won't return TRUE in AdHoc mode until after 
....................    // it receives some IP traffic.  It will then stay connected until after 5 
....................    // minutes of no activity. 
....................    #define WIFI_ADHOC_CONNECTION_TIMER ((TICK)TICKS_PER_SECOND * 300) 
....................     
....................    #if defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    extern int1 g_WifiAdhocIsConn; 
....................    extern TICK g_WifiAdhocTickConn; 
....................    #endif 
....................     
....................    extern unsigned int8 WIFI_channelList[16]; 
....................    extern unsigned int8 WIFI_numChannelsInList; 
....................    extern unsigned int8 WIFI_region; 
....................    extern int1 g_WifiConnectFail; 
....................     
....................    // this is similar to MACIsLinked() and WFisConnected().  this one has some 
....................    // filters and extra UI logic to better represent link status to the user. 
....................    // use this for UI displays. 
....................    // REMOVED - Use IsLinked() instead 
....................    //int1 MyWFisConnected(void); 
....................     
....................    // This routine does a few things: 
....................    //  * Reset WIFI unit if no it goes a long time without a connection, 
....................    //       because old modules would hang on WPA connect failure. 
....................    //  * Ad-Hoc connection timer support (WIFI_ADHOC_CONNECTION_TIMER) 
....................    //  * LED Traffic flickering and LED connection status 
....................    void WIFIConnectTask(void); 
....................     
....................    #if defined(WF_FORCE_NO_PS_POLL) 
....................       void WF_CCS_PsPollDisable(void); 
....................    #endif 
.................... #endif 
....................  
.................... int1 DHCPBoundOrDisabled(void); 
....................  
.................... // A higher level version of MACIsLinked(). 
.................... //  - returns FALSE if MACIsLinked() is TRUE -but- DHCP is enabled and not 
.................... //       bound. 
.................... //  - returns FALSE in WIFI if using AdHoc mode and it has been a while 
.................... //       since no traffic 
.................... //  - else, returns MACIsLinked() 
.................... int1 IsLinked(void); 
....................  
.................... //this macro called by stack when new tcp/ip traffic tx/rx. 
.................... #if STACK_USE_WIFI 
....................    #define STACK_USE_CCS_TX_EVENT()  LinkTraffic(TRUE) 
....................    #define STACK_USE_CCS_RX_EVENT()  LinkTraffic(FALSE) 
....................    void LinkTraffic(int1 isTx); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS) 
....................    #include "TCPIP Stack/mpfs.h" 
....................     
....................    extern MPFS _MpfsEofLoc; 
....................     
....................    //returns number of bytes read before EOF. 
....................    //if it returns n then no EOF. 
....................    unsigned int16 MPFSGetBytes(unsigned int8 *pDest, unsigned int16 n); 
.................... #endif 
....................  
.................... #if defined(__PCH__) 
.................... TICK TickGetSafe(void); 
.................... #endif 
....................  
.................... BYTE GenerateRandomByteFromTimers(void); 
....................  
.................... #endif 
....................  
....................  
.................... #if STACK_USE_CCS_INI 
....................    #include "ee.h" 
....................    #include "ccsui.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS) 
....................    #if !defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)  
....................       #if defined(__PCD__) 
....................          #import(RAW, file="mpfs/mpfsimg.bin", location=MPFS_Start, bpi=2) 
....................       #else 
....................          #import(RAW, file="mpfs/mpfsimg.bin", location=MPFS_Start) 
....................       #endif 
....................    #endif 
.................... #endif 
....................  
....................  
.................... void DebugPutc(char c) 
.................... { 
....................    fputc(c, STREAM_UI); 
.................... } 
....................  
.................... //#define debug_tftp   printf 
.................... //#define debug_tftp_putc DebugPutc 
....................  
.................... //#define debug_html         printf 
.................... //#define debug_html_putc    DebugPutc 
....................  
.................... //#define debug_mpfs         printf 
.................... //#define debug_mpfs_putc    DebugPutc 
....................  
.................... //#define debug_enc28j60  printf 
.................... //#define debug_enc28j60_putc  DebugPutc 
.................... //void MACToString(char *str, MAC_ADDR *mac); 
....................  
.................... //#define debug_dhcp   printf 
.................... //#define debug_dhcp_putc DebugPutc 
....................  
.................... //#define debug_tcp printf 
.................... //#define debug_tcp_putc  DebugPutc 
....................  
.................... #include "tcpip/StackTsk2.c" 
.................... // 'glue' file for using Microchip's TCP/IP stack inside CCS C Compiler without 
.................... // a linker.   
.................... // Also includes some macros/defines for porting older V3 stack to this current 
.................... // stack. 
.................... // Also provides extra routines written by CCS to improve the stack. 
.................... // 
.................... // __DISABLE_WIFI_INTERRUPT__ was supported in an older 5.3x version of the 
.................... // stack, but it is currently not supported anymore. 
....................  
.................... #ifndef __CCS_STACKTSK2_C__ 
.................... #define __CCS_STACKTSK2_C__ 
....................  
.................... #if defined(__DISABLE_WIFI_INTERRUPT__) 
....................    #error This has been removed. 
.................... #endif 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if defined(__PCH__) 
.................... #int_timer0 NOCLEAR 
.................... void ISRTimer0(void) 
.................... { 
....................    TickUpdate(); 
*
000B4:  BRA    0096
.................... } 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) && !defined(__DISABLE_WIFI_INTERRUPT__) 
.................... #int_EXT HIGH NOCLEAR 
....................    void ISREXT0(void) 
....................    { 
....................          WFEintISR(); 
....................        
....................    } 
.................... #endif 
....................  
.................... #if defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    int1 g_WifiAdhocIsConn = FALSE; 
....................    TICK g_WifiAdhocTickConn; 
....................    #define WIFIAdhocConnectionPing()   g_WifiAdhocIsConn=TRUE; g_WifiAdhocTickConn=TickGet() 
....................    #define WIFIAdhocConnectionReset()  g_WifiAdhocIsConn = FALSE 
.................... #endif 
....................  
.................... #include "StackTsk.c" 
.................... /********************************************************************* 
....................  * 
....................  *   TCP/IP Stack Manager 
....................  *  Module for Microchip TCP/IP Stack 
....................  *    -Handles internal RX packet pre-processing prior to dispatching  
....................  *    to upper application layers. 
....................  *    -Reference: AN833 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.c 
....................  * Dependencies:    ARP, IP, Network layer interface (ENC28J60.c,  
....................  *               ETH97J60.c, ENCX24J600.c, or WFMac.c) 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  * 
....................  * Darren Rook/CCS       4/13/11    Added some CCS modules (see STACK_USE_CCS_*) 
....................  *                                  Added STACK_USE_CCS_RX_EVENT() macro on TCP/IP traffic.  
.................... ********************************************************************/ 
.................... #define __STACKTSK_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
000B6:  GOTO   0054
.................... #if defined( WF_CS_TRIS ) 
....................     #if defined( WF_CONFIG_CONSOLE ) 
....................         #include "TCPIP Stack/WFConsole.h" 
....................     #endif 
....................     #if defined( STACK_USE_EZ_CONFIG ) || defined( EZ_CONFIG_SCAN ) 
....................         #include "TCPIP Stack/WFEasyConfig.h" 
....................     #endif 
....................    #include "TCPIP Stack/WFApi.h" 
.................... #endif 
....................  
.................... // Stack FSM states. 
.................... typedef enum 
.................... { 
....................     SM_STACK_IDLE, 
....................     SM_STACK_MAC, 
....................     SM_STACK_IP, 
....................     SM_STACK_ARP, 
....................     SM_STACK_TCP, 
....................     SM_STACK_UDP 
.................... } SM_STACK; 
.................... static SM_STACK smStack; 
....................  
.................... NODE_INFO remoteNode; 
....................  
.................... #if defined (WF_CS_TRIS) && defined (STACK_USE_DHCP_CLIENT) 
.................... BOOL g_DhcpRenew = FALSE; 
.................... extern void SetDhcpProgressState(void); 
.................... UINT32 g_DhcpRetryTimer = 0; 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componets are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines are used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void) 
.................... { 
....................    static BOOL once = FALSE; 
....................     smStack                     = SM_STACK_IDLE; 
*
01642:  MOVLB  1
01644:  CLRF   x02
....................  
.................... #if defined(STACK_USE_IP_GLEANING) || defined(STACK_USE_DHCP_CLIENT) 
....................     /* 
....................      * If DHCP or IP Gleaning is enabled, 
....................      * startup in Config Mode. 
....................      */ 
....................     AppConfig.Flags.bInConfigMode = TRUE; 
....................  
.................... #endif 
....................  
.................... #if defined (WF_CS_TRIS) && defined (STACK_USE_DHCP_CLIENT) 
....................    g_DhcpRenew = FALSE; 
....................    g_DhcpRetryTimer = 0; 
.................... #endif 
....................  
....................    if (!once) { 
01646:  BTFSC  x0D.0
01648:  BRA    1678
....................       // Seed the LFSRRand() function 
....................       LFSRSeedRand(GenerateRandomDWORD()); 
0164A:  MOVLB  0
0164C:  CALL   067E
01650:  MOVFF  03,247
01654:  MOVFF  02,246
01658:  MOVFF  01,245
0165C:  MOVFF  00,244
01660:  MOVFF  03,268
01664:  MOVFF  02,267
01668:  MOVFF  01,266
0166C:  MOVFF  00,265
01670:  CALL   061C
....................       once = TRUE; 
01674:  MOVLB  1
01676:  BSF    x0D.0
....................    } 
....................  
....................     MACInit(); 
01678:  MOVLB  0
0167A:  GOTO   09CE
....................  
.................... #if defined (WF_AGGRESSIVE_PS) && defined (WF_CS_TRIS) 
....................    WFEnableAggressivePowerSave(); 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) && defined(STACK_USE_EZ_CONFIG) && !defined(__18CXX) 
....................     WFEasyConfigInit(); 
.................... #endif     
....................  
....................     ARPInit(); 
0167E:  GOTO   0BEE
....................  
.................... #if defined(STACK_USE_UDP) 
....................     UDPInit(); 
01682:  GOTO   0C8E
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
....................     TCPInit(); 
01686:  BRA    1478
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
....................    BerkeleySocketInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
....................     HTTPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
....................    RSAInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
....................     SSLInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) && defined(STACK_USE_MPFS2) 
....................     FTPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
....................    SNMPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) 
....................    DHCPInit(0); 
....................     if(!AppConfig.Flags.bIsDHCPEnabled) 
....................     { 
....................         DHCPDisable(0); 
....................     } 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     AutoIPInit(0); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
....................    DDNSInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
....................    RandomInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SMTP) 
....................    SMTPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    NTPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_GRATUITOUS_ARP) 
....................    GratArpInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP1_SERVER) || defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    HTTPInit(); 
.................... #endif 
....................  
....................    #if defined(STACK_USE_CCS_TFTP_SERVER) 
01688:  GOTO   8238 (RETURN)
....................    TFTPSInit(); 
....................    #endif 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically to 
....................  *                  ensure timely responses. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void) 
.................... { 
....................     WORD dataCount; 
....................     IP_ADDR tempLocalIP; 
....................    BYTE cFrameType; 
....................    BYTE cIPFrameType; 
....................  
....................     
....................     #if defined( WF_CS_TRIS ) 
....................         // This task performs low-level MAC processing specific to the MRF24W 
....................         MACProcess(); 
....................         #if defined( STACK_USE_EZ_CONFIG ) && !defined(__18CXX) 
....................             WFEasyConfigMgr(); 
....................         #endif 
....................          
....................        #if defined(STACK_USE_DHCP_CLIENT) 
....................            // Normally, an application would not include  DHCP module 
....................            // if it is not enabled. But in case some one wants to disable 
....................            // DHCP module at run-time, remember to not clear our IP 
....................            // address if link is removed. 
....................            if(AppConfig.Flags.bIsDHCPEnabled) 
....................            { 
....................               if(g_DhcpRenew == TRUE) 
....................               { 
....................                  g_DhcpRenew = FALSE; 
....................                   AppConfig.MyIPAddr.Val = AppConfig.DefaultIPAddr.Val; 
....................                  AppConfig.MyMask.Val = AppConfig.DefaultMask.Val; 
....................                  AppConfig.Flags.bInConfigMode = TRUE; 
....................                  DHCPInit(0); 
....................                g_DhcpRetryTimer = (UINT32)TickGet(); 
....................               } else { 
....................                  if (g_DhcpRetryTimer && TickGet() - g_DhcpRetryTimer >= TICKS_PER_SECOND * 8) { 
....................                   DHCPInit(0); 
....................                   g_DhcpRetryTimer = (UINT32)TickGet(); 
....................                  } 
....................               } 
....................             
....................               // DHCP must be called all the time even after IP configuration is 
....................               // discovered. 
....................               // DHCP has to account lease expiration time and renew the configuration 
....................               // time. 
....................               DHCPTask(); 
....................                
....................               if(DHCPIsBound(0)) { 
....................                  AppConfig.Flags.bInConfigMode = FALSE; 
....................                g_DhcpRetryTimer = 0; 
....................               } 
....................            } 
....................        #endif // STACK_USE_DHCP_CLIENT 
....................          
....................     #endif // WF_CS_TRIS 
....................  
....................  
....................    #if defined(STACK_USE_DHCP_CLIENT) && !defined(WF_CS_TRIS) 
....................    // Normally, an application would not include  DHCP module 
....................    // if it is not enabled. But in case some one wants to disable 
....................    // DHCP module at run-time, remember to not clear our IP 
....................    // address if link is removed. 
....................    if(AppConfig.Flags.bIsDHCPEnabled) 
....................    { 
....................       static BOOL bLastLinkState = FALSE; 
....................       BOOL bCurrentLinkState; 
....................        
....................       bCurrentLinkState = MACIsLinked(); 
....................       if(bCurrentLinkState != bLastLinkState) 
....................       { 
....................          bLastLinkState = bCurrentLinkState; 
....................          if(!bCurrentLinkState) 
....................          { 
....................             AppConfig.MyIPAddr.Val = AppConfig.DefaultIPAddr.Val; 
....................             AppConfig.MyMask.Val = AppConfig.DefaultMask.Val; 
....................             AppConfig.Flags.bInConfigMode = TRUE; 
....................             DHCPInit(0); 
....................          } 
....................       } 
....................     
....................       // DHCP must be called all the time even after IP configuration is 
....................       // discovered. 
....................       // DHCP has to account lease expiration time and renew the configuration 
....................       // time. 
....................       DHCPTask(); 
....................        
....................       if(DHCPIsBound(0)) 
....................          AppConfig.Flags.bInConfigMode = FALSE; 
....................    } 
....................    #endif 
....................     
....................  
....................     #if defined (STACK_USE_AUTO_IP) 
....................     AutoIPTasks(); 
....................     #endif 
....................  
....................    #if defined(STACK_USE_TCP) 
....................    // Perform all TCP time related tasks (retransmit, send acknowledge, close connection, etc) 
....................    TCPTick(); 
*
074FA:  GOTO   434E
....................    #endif 
....................  
....................  
....................    #if defined(STACK_USE_UDP) 
....................    UDPTask(); 
074FE:  GOTO   4D5A
....................    #endif 
....................  
....................   #if defined(STACK_USE_CCS_GRATUITOUS_ARP) 
....................    GratArpTask(); 
....................   #endif 
....................  
....................    // Process as many incomming packets as we can 
....................    while(1) 
....................    { 
....................       //if using the random module, generate entropy 
....................       #if defined(STACK_USE_RANDOM) 
....................          RandomAdd(remoteNode.MACAddr.v[5]); 
....................       #endif 
....................  
....................       // We are about to fetch a new packet, make sure that the  
....................       // UDP module knows that any old RX data it has laying  
....................       // around will now be gone. 
....................       #if defined(STACK_USE_UDP) 
....................          UDPDiscard(); 
07502:  CALL   3A6E
....................       #endif 
....................  
....................       // Fetch a packet (throws old one away, if not thrown away  
....................       // yet) 
....................       if(!MACGetHeader(&remoteNode.MACAddr, &cFrameType)) 
07506:  MOVLW  01
07508:  MOVLB  2
0750A:  MOVWF  x4D
0750C:  MOVLW  07
0750E:  MOVWF  x4C
07510:  MOVLW  02
07512:  MOVWF  x4F
07514:  MOVLW  4A
07516:  MOVWF  x4E
07518:  MOVLB  0
0751A:  GOTO   5238
0751E:  MOVF   01,F
07520:  BNZ   7524
....................          break; 
07522:  BRA    766A
....................  
....................       // When using a WiFi module, filter out all incoming packets that have  
....................       // the same source MAC address as our own MAC address.  This is to  
....................       // prevent receiving and passing our own broadcast packets up to other  
....................       // layers and avoid, for example, having our own gratuitous ARPs get  
....................       // answered by ourself. 
....................       #if defined(WF_CS_TRIS) 
....................          if(memcmp((void*)&remoteNode.MACAddr, (void*)&AppConfig.MyMACAddr, 6) == 0u) 
....................             continue; 
....................       #endif 
....................        
....................       #if defined(STACK_USE_CCS_RX_EVENT) 
....................       STACK_USE_CCS_RX_EVENT();  //__CCS__ 
....................       #endif 
....................        
....................       // Dispatch the packet to the appropriate handler 
....................       switch(cFrameType) 
07524:  MOVLB  2
07526:  MOVF   x4A,W
07528:  XORLW  06
0752A:  MOVLB  0
0752C:  BZ    7534
0752E:  XORLW  06
07530:  BZ    753A
07532:  BRA    7668
....................       { 
....................          case MAC_ARP: 
....................             ARPProcess(); 
07534:  GOTO   538A
....................             break; 
07538:  BRA    7668
....................     
....................          case MAC_IP: 
....................             if(!IPGetHeader(&tempLocalIP, &remoteNode, &cIPFrameType, &dataCount)) 
0753A:  MOVLW  02
0753C:  MOVLB  2
0753E:  MOVWF  x4D
07540:  MOVLW  46
07542:  MOVWF  x4C
07544:  MOVLW  01
07546:  MOVWF  x4F
07548:  MOVLW  03
0754A:  MOVWF  x4E
0754C:  MOVLW  02
0754E:  MOVWF  x51
07550:  MOVLW  4B
07552:  MOVWF  x50
07554:  MOVLW  02
07556:  MOVWF  x53
07558:  MOVLW  44
0755A:  MOVWF  x52
0755C:  MOVLB  0
0755E:  GOTO   5594
07562:  MOVF   01,F
07564:  BNZ   7568
....................                break; 
07566:  BRA    7668
....................  
....................             #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................             if(cIPFrameType == IP_PROT_ICMP) 
07568:  MOVLB  2
0756A:  DECFSZ x4B,W
0756C:  BRA    7616
....................             { 
....................                #if defined(STACK_USE_IP_GLEANING) 
....................                if(AppConfig.Flags.bInConfigMode && AppConfig.Flags.bIsDHCPEnabled) 
....................                { 
....................                   // According to "IP Gleaning" procedure, 
....................                   // when we receive an ICMP packet with a valid 
....................                   // IP address while we are still in configuration 
....................                   // mode, accept that address as ours and conclude 
....................                   // configuration mode. 
....................                   if(tempLocalIP.Val != 0xffffffff) 
....................                   { 
....................                      AppConfig.Flags.bInConfigMode = FALSE; 
....................                      AppConfig.MyIPAddr = tempLocalIP; 
....................                   } 
....................                } 
....................                #endif 
....................  
....................                // Process this ICMP packet if it the destination IP address matches our address or one of the broadcast IP addressees 
....................                if( (tempLocalIP.Val == AppConfig.MyIPAddr.Val) || 
....................                   (tempLocalIP.Val == 0xFFFFFFFF) || 
.................... #if defined(STACK_USE_ZEROCONF_LINK_LOCAL) || defined(STACK_USE_ZEROCONF_MDNS_SD) 
....................                                                 (tempLocalIP.Val == 0xFB0000E0) || 
.................... #endif 
....................                   (tempLocalIP.Val == ((AppConfig.MyIPAddr.Val & AppConfig.MyMask.Val) | ~AppConfig.MyMask.Val))) 
0756E:  MOVF   29,W
07570:  SUBWF  x46,W
07572:  BNZ   7586
07574:  MOVF   2A,W
07576:  SUBWF  x47,W
07578:  BNZ   7586
0757A:  MOVF   2B,W
0757C:  SUBWF  x48,W
0757E:  BNZ   7586
07580:  MOVF   2C,W
07582:  SUBWF  x49,W
07584:  BZ    75F8
07586:  INCFSZ x46,W
07588:  BRA    7598
0758A:  INCFSZ x47,W
0758C:  BRA    7598
0758E:  INCFSZ x48,W
07590:  BRA    7598
07592:  INCFSZ x49,W
07594:  BRA    7598
07596:  BRA    75F8
07598:  MOVF   29,W
0759A:  ANDWF  2D,W
0759C:  MOVWF  x4C
0759E:  MOVF   2A,W
075A0:  ANDWF  2E,W
075A2:  MOVWF  x4D
075A4:  MOVF   2B,W
075A6:  ANDWF  2F,W
075A8:  MOVWF  x4E
075AA:  MOVF   2C,W
075AC:  ANDWF  30,W
075AE:  MOVWF  x4F
075B0:  MOVFF  2D,00
075B4:  COMF   00,F
075B6:  MOVFF  2E,01
075BA:  COMF   01,F
075BC:  MOVFF  2F,02
075C0:  COMF   02,F
075C2:  MOVFF  30,03
075C6:  COMF   03,F
075C8:  MOVF   00,W
075CA:  IORWF  x4C,W
075CC:  MOVWF  00
075CE:  MOVF   01,W
075D0:  IORWF  x4D,W
075D2:  MOVWF  01
075D4:  MOVF   02,W
075D6:  IORWF  x4E,W
075D8:  MOVWF  02
075DA:  MOVF   03,W
075DC:  IORWF  x4F,W
075DE:  MOVWF  03
075E0:  MOVF   00,W
075E2:  SUBWF  x46,W
075E4:  BNZ   7610
075E6:  MOVF   01,W
075E8:  SUBWF  x47,W
075EA:  BNZ   7610
075EC:  MOVF   02,W
075EE:  SUBWF  x48,W
075F0:  BNZ   7610
075F2:  MOVF   03,W
075F4:  SUBWF  x49,W
075F6:  BNZ   7610
....................                { 
....................                   ICMPProcess(&remoteNode, dataCount); 
075F8:  MOVLW  01
075FA:  MOVWF  x4D
075FC:  MOVLW  03
075FE:  MOVWF  x4C
07600:  MOVFF  245,24F
07604:  MOVFF  244,24E
07608:  MOVLB  0
0760A:  GOTO   5694
0760E:  MOVLB  2
....................                } 
....................  
....................                break; 
07610:  MOVLB  0
07612:  BRA    7668
07614:  MOVLB  2
....................             } 
....................             #endif 
....................              
....................             #if defined(STACK_USE_TCP) 
....................             if(cIPFrameType == IP_PROT_TCP) 
07616:  MOVF   x4B,W
07618:  SUBLW  06
0761A:  BNZ   763C
....................             { 
....................                TCPProcess(&remoteNode, &tempLocalIP, dataCount); 
0761C:  MOVLW  01
0761E:  MOVWF  x4D
07620:  MOVLW  03
07622:  MOVWF  x4C
07624:  MOVLW  02
07626:  MOVWF  x4F
07628:  MOVLW  46
0762A:  MOVWF  x4E
0762C:  MOVFF  245,251
07630:  MOVFF  244,250
07634:  MOVLB  0
07636:  BRA    707C
....................                break; 
07638:  BRA    7668
0763A:  MOVLB  2
....................             } 
....................             #endif 
....................              
....................             #if defined(STACK_USE_UDP) 
....................             if(cIPFrameType == IP_PROT_UDP) 
0763C:  MOVF   x4B,W
0763E:  SUBLW  11
07640:  BNZ   7666
....................             { 
....................                // Stop processing packets if we came upon a UDP frame with application data in it 
....................                if(UDPProcess(&remoteNode, &tempLocalIP, dataCount)) 
07642:  MOVLW  01
07644:  MOVWF  x4D
07646:  MOVLW  03
07648:  MOVWF  x4C
0764A:  MOVLW  02
0764C:  MOVWF  x4F
0764E:  MOVLW  46
07650:  MOVWF  x4E
07652:  MOVFF  245,251
07656:  MOVFF  244,250
0765A:  MOVLB  0
0765C:  BRA    7376
0765E:  MOVF   01,F
07660:  BZ    7664
....................                   return; 
07662:  BRA    766A
07664:  MOVLB  2
....................             } 
....................             #endif 
....................  
....................             break; 
07666:  MOVLB  0
....................       } 
07668:  BRA    7502
....................    } 
0766A:  GOTO   823C (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackApplications(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Calls all loaded application modules. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called periodically to 
....................  *                  ensure timely responses. 
....................  * 
....................  ********************************************************************/ 
.................... void StackApplications(void) 
.................... { 
....................    #if defined(STACK_USE_HTTP2_SERVER) 
....................    HTTPServer(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_FTP_SERVER) && defined(STACK_USE_MPFS2) 
....................    FTPServer(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_SNMP_SERVER) 
....................    SNMPTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_ANNOUNCE) 
....................    DiscoveryTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_NBNS) 
....................    NBNSTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_DHCP_SERVER) 
....................    DHCPServerTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_DNS_SERVER) 
....................    DNSServerTask(); 
....................    #endif 
....................     
....................    #if defined (STACK_USE_DYNAMICDNS_CLIENT) 
....................    DDNSTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_TELNET_SERVER) 
....................    TelnetTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_REBOOT_SERVER) 
....................    RebootTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_SNTP_CLIENT) 
....................    SNTPClient(); 
....................    #endif 
....................  
....................    #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
....................    UDPPerformanceTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
....................    TCPPerformanceTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_SMTP_CLIENT) 
....................    SMTPTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_UART2TCP_BRIDGE) 
....................    UART2TCPBridgeTask(); 
....................    #endif 
....................  
....................    #if defined(STACK_USE_CCS_SMTP) 
....................    SMTPTask(); 
....................    #endif    
....................  
....................    #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    NTPTask(); 
....................    #endif 
....................  
....................    #if defined(STACK_USE_CCS_HTTP1_SERVER) || defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    HTTPServer(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_CCS_TFTP_SERVER) 
....................    TFTPSTask(); 
....................    #endif 
....................  
....................    #if defined(STACK_USE_TWITTER)   //should be renamed STACK_USE_CCS_TWITTER 
....................    TwitterTask();         // processes TCP tasks including the Tweet tasks 
....................    #endif    
.................... } 
....................  
.................... #if defined(WF_CS_TRIS) && defined(STACK_USE_DHCP_CLIENT) 
.................... void RenewDhcp(void) 
.................... { 
....................     g_DhcpRenew = TRUE; 
....................     SetDhcpProgressState(); 
.................... }     
....................      
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "Helpers.c" 
.................... /********************************************************************* 
....................   
....................  Helper Functions for Microchip TCPIP Stack 
....................   
....................  FileName:      Helpers.c 
....................  Dependencies:  See INCLUDES section 
....................  Processor:     PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:      Microchip C18, C30, C32 
....................  Company:       Microchip Technology, Inc. 
....................  
....................  Software License Agreement 
....................  
....................  Copyright (C) 2002-2011 Microchip Technology Inc.  All rights 
....................  reserved. 
....................  
....................  Microchip licenses to you the right to use, modify, copy, and 
....................  distribute: 
....................  (i)  the Software when embedded on a Microchip microcontroller or 
....................       digital signal controller product ("Device") which is 
....................       integrated into Licensee's product; or 
....................  (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................       ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................       used in conjunction with a Microchip ethernet controller for 
....................       the sole purpose of interfacing with the ethernet controller. 
....................  
....................  You should refer to the license agreement accompanying this 
....................  Software for additional information regarding your rights and 
....................  obligations. 
....................  
....................  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  
....................  ******************************************************************** 
....................  File Description: 
....................   
....................  Change History: 
....................   
....................   Rev         Description 
....................   ----------  ------------------------------------------------------- 
....................   1.0 - 5.31  Initial release; Rewritten CalcIPChecksum() to avoid 
....................               multi-byte shift operation; Added hexatob(), 
....................               btohexa_high(), and btohexa_low(); Optimized swapl(); 
....................               Added leftRotateDWORD() 
....................   5.36        Updated compile time check for ultoa(); 
....................  
....................    DARREN ROOK/CCS   Remove leftRotateDWORD() 
....................  
....................  ********************************************************************/ 
.................... #define __HELPERS_C 
....................  
.................... #include <stdarg.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDARG 
....................  
.................... #define _STDARG 
....................  
.................... typedef char * va_list; 
....................  
.................... #define va_start(a,b)  a=_VA_LIST 
.................... #define va_arg(a,b)    *(b *)_va_arg(a) 
.................... #define va_end 
.................... #define nargs          _nargs(&_va_list) 
....................  
.................... int8 _nargs(int8 * ptr) { 
....................   int8 n; 
....................  
....................   n=0; 
....................   while(*ptr) { 
....................     n++; 
....................     ptr+=*ptr; 
....................   } 
....................   return(n); 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
....................  
.................... // Default Random Number Generator seed. 0x41FE9F9E corresponds to calling LFSRSeedRand(1) 
.................... static DWORD dwLFSRRandSeed = 0x41FE9F9E; 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    DWORD LFSRSeedRand(DWORD dwSeed) 
....................  
....................   Summary: 
....................    Seeds the LFSR random number generator invoked by the LFSRRand() function.   
....................    The prior seed is returned. 
....................  
....................   Description: 
....................    Seeds the LFSR random number generator invoked by the LFSRRand() function.   
....................    The prior seed is returned. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    wSeed - The new 32-bit seed value to assign to the LFSR. 
....................  
....................   Returns: 
....................      The last seed in use.  This can be saved and restored by a subsequent call  
....................    to LFSRSeedRand() if you wish to use LFSRRand() in multiple contexts  
....................    without disrupting the random number sequence from the alternative  
....................    context.  For example, if App 1 needs a given sequence of random numbers  
....................    to perform a test, if you save and restore the seed in App 2, it is  
....................    possible for App 2 to not disrupt the random number sequence provided to  
....................    App 1, even if the number of times App 2 calls LFSRRand() varies. 
....................       
....................   Side Effects: 
....................    None 
....................     
....................   Remarks: 
....................    Upon initial power up, the internal seed is initialized to 0x1.  Using a  
....................    dwSeed value of 0x0 will return the same sequence of random numbers as  
....................    using the seed of 0x1. 
....................   ***************************************************************************/ 
.................... DWORD LFSRSeedRand(DWORD dwSeed) 
.................... { 
....................    DWORD dwOldSeed; 
....................    BYTE i; 
....................  
....................    // Save original seed to be returned later 
....................    dwOldSeed = dwLFSRRandSeed; 
*
0061C:  MOVFF  111,26C
00620:  MOVFF  110,26B
00624:  MOVFF  10F,26A
00628:  MOVFF  10E,269
....................  
....................    // Ensure zero isn't selected as a seed value, this would result in all  
....................    // 0x0000 output values from the LFSR 
....................    if(dwSeed == 0u) 
0062C:  MOVLB  2
0062E:  MOVF   x65,F
00630:  BNZ   0648
00632:  MOVF   x66,F
00634:  BNZ   0648
00636:  MOVF   x67,F
00638:  BNZ   0648
0063A:  MOVF   x68,F
0063C:  BNZ   0648
....................       dwSeed = 1; 
0063E:  CLRF   x68
00640:  CLRF   x67
00642:  CLRF   x66
00644:  MOVLW  01
00646:  MOVWF  x65
....................        
....................    // Set the new seed 
....................    dwLFSRRandSeed = dwSeed; 
00648:  MOVFF  268,111
0064C:  MOVFF  267,110
00650:  MOVFF  266,10F
00654:  MOVFF  265,10E
....................     
....................    // Run the LFSR a few times to get rid of obvious start up artifacts for  
....................    // seed values that don't have many set bits. 
....................    for(i = 0; i < 16; i++) 
00658:  CLRF   x6D
0065A:  MOVF   x6D,W
0065C:  SUBLW  0F
0065E:  BNC   066A
....................       LFSRRand(); 
00660:  MOVLB  0
00662:  RCALL  057C
00664:  MOVLB  2
00666:  INCF   x6D,F
00668:  BRA    065A
....................     
....................    // Return saved old seed 
....................    return dwOldSeed; 
0066A:  MOVFF  269,00
0066E:  MOVFF  26A,01
00672:  MOVFF  26B,02
00676:  MOVFF  26C,03
0067A:  MOVLB  0
0067C:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD LFSRRand(void) 
....................  
....................   Summary: 
....................    Returns a pseudo-random 16-bit unsigned integer in the range from 0  
....................    to 65535 (0x0000 to 0xFFFF). 
....................  
....................   Description: 
....................    Returns a pseudo-random 16-bit unsigned integer in the range from 0  
....................    to 65535 (0x0000 to 0xFFFF).  The random number is generated using a  
....................    Linear Feedback Shift Register (LFSR) type pseudo-random number generator  
....................    algorithm.  The LFSR can be seeded by calling the LFSRSeedRand() function 
....................    to generate the same sequence of random numbers as a prior string of calls. 
....................     
....................    The internal LFSR will repeat after 2^32-1 iterations. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................      Random 16-bit unsigned integer. 
....................       
....................   Side Effects: 
....................    The internal LFSR seed is updated so that the next call to LFSRRand()  
....................    will return a different random number. 
....................     
....................   Remarks: 
....................    None 
....................   ***************************************************************************/ 
.................... WORD LFSRRand(void) 
.................... { 
....................    BYTE i; 
....................     
....................    // Taps: 32 31 29 1 
....................    // Characteristic polynomial: x^32 + x^31 + x^29 + x + 1 
....................    // Repeat 15 times to make the shift pattern less obvious 
....................    for(i = 0; i < 15; i++) 
*
0057C:  MOVLB  2
0057E:  CLRF   x9B
00580:  MOVF   x9B,W
00582:  SUBLW  0E
00584:  BNC   060E
....................       dwLFSRRandSeed = (dwLFSRRandSeed >> 1) ^ ((0ul - (dwLFSRRandSeed & 1ul)) & 0xD0000001ul); 
00586:  BCF    FD8.0
00588:  MOVLB  1
0058A:  RRCF   x11,W
0058C:  MOVLB  2
0058E:  MOVWF  xA0
00590:  MOVLB  1
00592:  RRCF   x10,W
00594:  MOVLB  2
00596:  MOVWF  x9F
00598:  MOVLB  1
0059A:  RRCF   x0F,W
0059C:  MOVLB  2
0059E:  MOVWF  x9E
005A0:  MOVLB  1
005A2:  RRCF   x0E,W
005A4:  MOVLB  2
005A6:  MOVWF  x9D
005A8:  MOVLB  1
005AA:  MOVF   x0E,W
005AC:  ANDLW  01
005AE:  MOVWF  00
005B0:  CLRF   01
005B2:  CLRF   02
005B4:  CLRF   03
005B6:  MOVLW  00
005B8:  BSF    FD8.0
005BA:  SUBFWB 00,W
005BC:  MOVLB  2
005BE:  MOVWF  xA1
005C0:  MOVLW  00
005C2:  SUBFWB 01,W
005C4:  MOVWF  xA2
005C6:  MOVLW  00
005C8:  SUBFWB 02,W
005CA:  MOVWF  xA3
005CC:  MOVLW  00
005CE:  SUBFWB 03,W
005D0:  MOVWF  xA4
005D2:  MOVF   xA1,W
005D4:  ANDLW  01
005D6:  MOVWF  00
005D8:  CLRF   01
005DA:  CLRF   02
005DC:  MOVF   xA4,W
005DE:  ANDLW  D0
005E0:  MOVWF  03
005E2:  MOVF   00,W
005E4:  XORWF  x9D,W
005E6:  MOVLB  1
005E8:  MOVWF  x0E
005EA:  MOVF   01,W
005EC:  MOVLB  2
005EE:  XORWF  x9E,W
005F0:  MOVLB  1
005F2:  MOVWF  x0F
005F4:  MOVF   02,W
005F6:  MOVLB  2
005F8:  XORWF  x9F,W
005FA:  MOVLB  1
005FC:  MOVWF  x10
005FE:  MOVF   03,W
00600:  MOVLB  2
00602:  XORWF  xA0,W
00604:  MOVLB  1
00606:  MOVWF  x11
00608:  MOVLB  2
0060A:  INCF   x9B,F
0060C:  BRA    0580
....................  
....................    // Return 16-bits as pseudo-random number 
....................    return (WORD)dwLFSRRandSeed; 
0060E:  MOVLB  1
00610:  MOVFF  10E,01
00614:  MOVFF  10F,02
00618:  MOVLB  0
0061A:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    DWORD GenerateRandomDWORD(void) 
....................  
....................   Summary: 
....................    Generates a random DWORD. 
....................  
....................   Description: 
....................    This function generates a random 32-bit integer.  It collects 
....................    randomness by comparing the A/D converter's internal R/C oscillator 
....................    clock with our main system clock.  By passing collected entropy to the 
....................    LFSRSeedRand()/LFSRRand() functions, the output is normalized (deskewed)  
....................    in the hopes of meeting statistical randomness tests. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................      Random 32-bit number. 
....................       
....................   Side Effects: 
....................    This function uses the A/D converter (and so you must disable  
....................    interrupts if you use the A/D converted in your ISR).  The LFSRRand()  
....................    function will be reseeded, and Timer0 (PIC18) and Timer1 (PIC24,  
....................    dsPIC, and PIC32) will be used.  TMR#H:TMR#L will have a new value. 
....................    Note that this is the same timer used by the Tick module. 
....................     
....................   Remarks: 
....................    This function times out after 1 second of attempting to generate the  
....................    random DWORD.  In such a case, the output may not be truly random.   
....................    Typically, this function executes in around 500,000 instruction cycles. 
....................     
....................    The intent of this function is to produce statistically random and 
....................    cryptographically secure random number.  Whether or not this is true on 
....................    all (or any) devices/voltages/temperatures is not tested. 
....................   ***************************************************************************/ 
.................... DWORD GenerateRandomDWORD(void) 
.................... { 
....................    BYTE vBitCount; 
....................    WORD w, wTime, wLastValue; 
....................    DWORD dwTotalTime; 
....................    union 
....................    { 
....................       DWORD   dw; 
....................       WORD   w[2]; 
....................    } randomResult; 
....................  
.................... #if defined __18CXX    
.................... { 
....................    BYTE ADCON0Save, ADCON2Save; 
....................    BYTE T0CONSave, TMR0HSave, TMR0LSave; 
....................  
....................    // Save hardware SFRs 
....................    ADCON0Save = ADCON0; 
*
0067E:  MOVFF  FC2,25E
....................    ADCON2Save = ADCON2; 
00682:  MOVFF  FC0,25F
....................    T0CONSave = T0CON; 
00686:  MOVFF  FD5,260
....................    TMR0LSave = TMR0L; 
0068A:  MOVFF  FD6,262
....................    TMR0HSave = TMR0H; 
0068E:  MOVFF  FD7,261
....................  
....................    // Set up Timer and A/D converter module 
....................    ADCON0 = 0x01;   // Turn on the A/D module 
00692:  MOVLW  01
00694:  MOVWF  FC2
....................    ADCON2 = 0x3F;   // 20 Tad acquisition, Frc A/D clock used for conversion 
00696:  MOVLW  3F
00698:  MOVWF  FC0
....................    T0CON = 0x88;   // TMR0ON = 1, no prescalar 
0069A:  MOVLW  88
0069C:  MOVWF  FD5
....................    vBitCount = 0; 
0069E:  MOVLB  2
006A0:  CLRF   x4F
....................    dwTotalTime = 0; 
006A2:  CLRF   x59
006A4:  CLRF   x58
006A6:  CLRF   x57
006A8:  CLRF   x56
....................    wLastValue = 0; 
006AA:  CLRF   x55
006AC:  CLRF   x54
....................    randomResult.dw = LFSRRand(); 
006AE:  MOVLB  0
006B0:  RCALL  057C
006B2:  MOVLB  2
006B4:  CLRF   x5D
006B6:  CLRF   x5C
006B8:  MOVFF  02,25B
006BC:  MOVFF  01,25A
....................    while(1) 
....................    { 
....................       // Time the duration of an A/D acquisition and conversion 
....................       TMR0H = 0x00; 
006C0:  CLRF   FD7
....................       TMR0L = 0x00; 
006C2:  CLRF   FD6
....................       ADCON0bits.GO = 1; 
006C4:  BSF    FC2.1
....................       ClrWdt(); 
006C6:  CLRWDT
....................       while(ADCON0bits.GO); 
006C8:  BTFSC  FC2.1
006CA:  BRA    06C8
....................       ((BYTE*)&wTime)[0] = TMR0L; 
006CC:  MOVFF  FD6,252
....................       ((BYTE*)&wTime)[1] = TMR0H; 
006D0:  MOVFF  FD7,253
....................       w = LFSRRand(); 
006D4:  MOVLB  0
006D6:  RCALL  057C
006D8:  MOVFF  02,251
006DC:  MOVFF  01,250
....................     
....................       // Wait no longer than 1 second obtaining entropy 
....................       dwTotalTime += wTime; 
006E0:  MOVLB  2
006E2:  MOVF   x52,W
006E4:  ADDWF  x56,F
006E6:  MOVF   x53,W
006E8:  ADDWFC x57,F
006EA:  MOVLW  00
006EC:  ADDWFC x58,F
006EE:  ADDWFC x59,F
....................       if(dwTotalTime >= GetInstructionClock()) 
006F0:  MOVF   x59,F
006F2:  BNZ   070E
006F4:  MOVF   x58,W
006F6:  SUBLW  97
006F8:  BC    072C
006FA:  XORLW  FF
006FC:  BNZ   070E
006FE:  MOVF   x57,W
00700:  SUBLW  95
00702:  BC    072C
00704:  XORLW  FF
00706:  BNZ   070E
00708:  MOVF   x56,W
0070A:  SUBLW  7F
0070C:  BC    072C
....................       { 
....................          randomResult.w[0] ^= LFSRRand(); 
0070E:  MOVLB  0
00710:  RCALL  057C
00712:  MOVF   01,W
00714:  MOVLB  2
00716:  XORWF  x5A,F
00718:  MOVF   02,W
0071A:  XORWF  x5B,F
....................          randomResult.w[1] ^= LFSRRand(); 
0071C:  MOVLB  0
0071E:  RCALL  057C
00720:  MOVF   01,W
00722:  MOVLB  2
00724:  XORWF  x5C,F
00726:  MOVF   02,W
00728:  XORWF  x5D,F
....................          break; 
0072A:  BRA    079A
....................       } 
....................     
....................       // Keep sampling if minimal entropy was likely obtained this round 
....................       if(wLastValue == wTime) 
0072C:  MOVF   x52,W
0072E:  SUBWF  x54,W
00730:  BNZ   073A
00732:  MOVF   x53,W
00734:  SUBWF  x55,W
00736:  BNZ   073A
....................          continue; 
00738:  BRA    06C0
....................     
....................       // Add this entropy into the pseudo random number generator by reseeding 
....................       LFSRSeedRand(w + (wLastValue - wTime)); 
0073A:  MOVF   x52,W
0073C:  SUBWF  x54,W
0073E:  MOVWF  00
00740:  MOVF   x53,W
00742:  SUBWFB x55,W
00744:  MOVWF  03
00746:  MOVF   00,W
00748:  ADDWF  x50,W
0074A:  MOVWF  x63
0074C:  MOVF   03,W
0074E:  ADDWFC x51,W
00750:  MOVWF  x64
00752:  CLRF   x68
00754:  CLRF   x67
00756:  MOVWF  x66
00758:  MOVFF  263,265
0075C:  MOVLB  0
0075E:  RCALL  061C
....................       wLastValue = wTime; 
00760:  MOVFF  253,255
00764:  MOVFF  252,254
....................     
....................       // Accumulate at least 32 bits of randomness over time 
....................       randomResult.dw <<= 1; 
00768:  BCF    FD8.0
0076A:  MOVLB  2
0076C:  RLCF   x5A,F
0076E:  RLCF   x5B,F
00770:  RLCF   x5C,F
00772:  RLCF   x5D,F
....................       if(LFSRRand() & 0x0080) 
00774:  MOVLB  0
00776:  RCALL  057C
00778:  MOVFF  02,264
0077C:  MOVFF  01,263
00780:  MOVLB  2
00782:  MOVF   01,W
00784:  ANDLW  80
00786:  MOVWF  00
00788:  CLRF   03
0078A:  MOVF   00,W
0078C:  IORWF  03,W
0078E:  BZ    0792
....................          randomResult.w[0] |= 0x1; 
00790:  BSF    x5A.0
....................     
....................       // See if we've collected a fair amount of entropy and can quit early 
....................       if(++vBitCount == 0u) 
00792:  INCF   x4F,F
00794:  BNZ   0798
....................          break; 
00796:  BRA    079A
00798:  BRA    06C0
....................    } 
....................  
....................    // Restore hardware SFRs 
....................    ADCON0 = ADCON0Save; 
0079A:  MOVFF  25E,FC2
....................    ADCON2 = ADCON2Save; 
0079E:  MOVFF  25F,FC0
....................    TMR0H = TMR0HSave; 
007A2:  MOVFF  261,FD7
....................    TMR0L = TMR0LSave; 
007A6:  MOVFF  262,FD6
....................    T0CON = T0CONSave; 
007AA:  MOVFF  260,FD5
.................... } 
.................... #else 
.................... { 
....................    WORD AD1CON1Save, AD1CON2Save, AD1CON3Save; 
....................    WORD T1CONSave, PR1Save; 
....................  
....................    // Save hardware SFRs 
....................    AD1CON1Save = AD1CON1; 
....................    AD1CON2Save = AD1CON2; 
....................    AD1CON3Save = AD1CON3; 
....................    T1CONSave = T1CON; 
....................    PR1Save = PR1; 
....................  
....................    // Set up Timer and A/D converter module 
....................    AD1CON1 = 0x0000;      // Turn off the ADC so we can write to it 
....................    AD1CON3 = 0x9F00;      // Frc A/D clock, 31 Tad acquisition 
....................    AD1CON2 = 0x003F;      // Interrupt after every 16th sample/convert 
....................    AD1CON1 = 0x80E4;      // Turn on the A/D module, auto-convert 
....................    T1CON = 0x8000;         // TON = 1, no prescalar 
....................    PR1 = 0xFFFF;         // Don't clear timer early 
....................    vBitCount = 0; 
....................    dwTotalTime = 0; 
....................    wLastValue = 0; 
....................    randomResult.dw = LFSRRand(); 
....................    while(1) 
....................    { 
....................       ClrWdt(); 
....................       #if defined(__C30__) 
....................          while(!IFS0bits.AD1IF); 
....................       #else 
....................          while(!IFS1bits.AD1IF); 
....................       #endif 
....................       wTime = TMR1; 
....................       TMR1 = 0x0000; 
....................  
....................       #if defined(__C30__) 
....................          IFS0bits.AD1IF = 0; 
....................       #else 
....................          IFS1CLR = _IFS1_AD1IF_MASK; 
....................       #endif 
....................       w = LFSRRand(); 
....................     
....................       // Wait no longer than 1 second obtaining entropy 
....................       dwTotalTime += wTime; 
....................       if(dwTotalTime >= GetInstructionClock()) 
....................       { 
....................          randomResult.w[0] ^= LFSRRand(); 
....................          randomResult.w[1] ^= LFSRRand(); 
....................          break; 
....................       } 
....................     
....................       // Keep sampling if minimal entropy was likely obtained this round 
....................       if(wLastValue == wTime) 
....................          continue; 
....................     
....................       // Add this entropy into the pseudo random number generator by reseeding 
....................       LFSRSeedRand(w + (wLastValue - wTime)); 
....................       wLastValue = wTime; 
....................     
....................       // Accumulate at least 32 bits of randomness over time 
....................       randomResult.dw <<= 1; 
....................       if(LFSRRand() & 0x0080) 
....................          randomResult.w[0] |= 0x1; 
....................     
....................       // See if we've collected a fair amount of entropy and can quit early 
....................       if(++vBitCount == 0u) 
....................          break; 
....................    } 
....................  
....................  
....................    // Restore hardware SFRs 
....................    AD1CON1 = 0x0000;      // Turn off the ADC so we can write to it 
....................    AD1CON3 = AD1CON3Save; 
....................    AD1CON2 = AD1CON2Save; 
....................    AD1CON1 = AD1CON1Save; 
....................    T1CON = T1CONSave; 
....................    PR1 = PR1Save; 
.................... } 
.................... #endif 
....................  
....................    return randomResult.dw; 
007AE:  MOVFF  25A,00
007B2:  MOVFF  25B,01
007B6:  MOVFF  25C,02
007BA:  MOVFF  25D,03
007BE:  MOVLB  0
007C0:  RETURN 0
.................... } 
....................  
....................  
.................... #if defined(STACK_USE_HTTP_SERVER) 
.................... /***************************************************************************** 
....................   Function: 
....................    void UnencodeURL(BYTE* URL) 
....................  
....................   Summary: 
....................    Decodes a URL-encoded string. 
....................  
....................   Description: 
....................    This function is deprecated except for use with HTTP Classic.  It 
....................    attempts to decode a URL encoded string, converting all hex escape 
....................    sequences into a literal byte.  However, it is inefficient over long 
....................    strings and does not handle URL-encoded data strings ('&' and '='). 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    URL - the null-terminated string to decode 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... void UnencodeURL(BYTE* URL) 
.................... { 
....................    BYTE *Right, *Copy; 
....................    WORD_VAL Number; 
....................  
....................    while((Right = (BYTE*)strchr((char*)URL, '%'))) 
....................    { 
....................       // Make sure the string is long enough 
....................       if(Right[1] == '\0') 
....................          break; 
....................       if(Right[2] == '\0') 
....................          break; 
....................  
....................       // Update the string in place 
....................       Number.v[0] = Right[2]; 
....................       Number.v[1] = Right[1]; 
....................       *Right++ = hexatob(Number); 
....................       URL = Right; 
....................  
....................       // Remove two blank spots by shifting all remaining characters right two 
....................       Copy = Right + 2; 
....................       while((*Right++ = *Copy++)); 
....................    } 
.................... }           
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL StringToIPAddress(BYTE* str, IP_ADDR* IPAddress) 
....................  
....................   Summary: 
....................    Converts a string to an IP address 
....................  
....................   Description: 
....................    This function parses a dotted-quad decimal IP address string into an  
....................    IP_ADDR struct.  The output result is big-endian. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    str - Pointer to a dotted-quad IP address string 
....................    IPAddress - Pointer to IP_ADDR in which to store the result 
....................  
....................   Return Values: 
....................      TRUE - an IP address was successfully decoded 
....................      FALSE - no IP address could be found, or the format was incorrect 
....................   ***************************************************************************/ 
.................... BOOL StringToIPAddress(BYTE* str, IP_ADDR* IPAddress) 
.................... { 
....................    DWORD_VAL dwVal; 
....................    BYTE i, charLen, currentOctet; 
....................  
....................    charLen = 0; 
*
02C84:  MOVLB  2
02C86:  CLRF   x61
....................    currentOctet = 0; 
02C88:  CLRF   x62
....................    dwVal.Val = 0; 
02C8A:  CLRF   x5F
02C8C:  CLRF   x5E
02C8E:  CLRF   x5D
02C90:  CLRF   x5C
....................    while((i = *str++)) 
02C92:  MOVFF  259,03
02C96:  MOVF   x58,W
02C98:  INCF   x58,F
02C9A:  BTFSC  FD8.2
02C9C:  INCF   x59,F
02C9E:  MOVWF  FE9
02CA0:  MOVFF  03,FEA
02CA4:  MOVFF  FEF,260
02CA8:  MOVF   x60,F
02CAA:  BTFSC  FD8.2
02CAC:  BRA    2DB0
....................    { 
....................       if(currentOctet > 3u) 
02CAE:  MOVF   x62,W
02CB0:  SUBLW  03
02CB2:  BC    2CB6
....................          break; 
02CB4:  BRA    2DB0
....................  
....................       i -= '0'; 
02CB6:  MOVLW  30
02CB8:  SUBWF  x60,F
....................        
....................  
....................       // Validate the character is a numerical digit or dot, depending on location 
....................       if(charLen == 0u) 
02CBA:  MOVF   x61,F
02CBC:  BNZ   2CCC
....................       { 
....................          if(i > 9u) 
02CBE:  MOVF   x60,W
02CC0:  SUBLW  09
02CC2:  BC    2CCA
....................             return FALSE; 
02CC4:  MOVLW  00
02CC6:  MOVWF  01
02CC8:  BRA    2E26
....................       } 
02CCA:  BRA    2D9A
....................       else if(charLen == 3u) 
02CCC:  MOVF   x61,W
02CCE:  SUBLW  03
02CD0:  BNZ   2D34
....................       { 
....................          if(i != (BYTE)('.' - '0')) 
02CD2:  MOVF   x60,W
02CD4:  SUBLW  FE
02CD6:  BZ    2CDE
....................             return FALSE; 
02CD8:  MOVLW  00
02CDA:  MOVWF  01
02CDC:  BRA    2E26
....................  
....................          if(dwVal.Val > 0x00020505ul) 
02CDE:  MOVF   x5F,F
02CE0:  BNZ   2CFC
02CE2:  MOVF   x5E,W
02CE4:  SUBLW  01
02CE6:  BC    2D02
02CE8:  XORLW  FF
02CEA:  BNZ   2CFC
02CEC:  MOVF   x5D,W
02CEE:  SUBLW  04
02CF0:  BC    2D02
02CF2:  XORLW  FF
02CF4:  BNZ   2CFC
02CF6:  MOVF   x5C,W
02CF8:  SUBLW  05
02CFA:  BC    2D02
....................             return FALSE; 
02CFC:  MOVLW  00
02CFE:  MOVWF  01
02D00:  BRA    2E26
....................  
....................          IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
02D02:  MOVF   x62,W
02D04:  INCF   x62,F
02D06:  CLRF   03
02D08:  ADDWF  x5A,W
02D0A:  MOVWF  FE9
02D0C:  MOVF   x5B,W
02D0E:  ADDWFC 03,W
02D10:  MOVWF  FEA
02D12:  MOVF   x5E,W
02D14:  MULLW  64
02D16:  MOVFF  FF3,265
02D1A:  MOVF   x5D,W
02D1C:  MULLW  0A
02D1E:  MOVF   FF3,W
02D20:  ADDWF  x65,W
02D22:  ADDWF  x5C,W
02D24:  MOVWF  FEF
....................          charLen = 0; 
02D26:  CLRF   x61
....................          dwVal.Val = 0; 
02D28:  CLRF   x5F
02D2A:  CLRF   x5E
02D2C:  CLRF   x5D
02D2E:  CLRF   x5C
....................          continue; 
02D30:  BRA    2C92
....................       } 
02D32:  BRA    2D9A
....................       else 
....................       { 
....................          if(i == (BYTE)('.' - '0')) 
02D34:  MOVF   x60,W
02D36:  SUBLW  FE
02D38:  BNZ   2D8E
....................          { 
....................             if(dwVal.Val > 0x00020505ul) 
02D3A:  MOVF   x5F,F
02D3C:  BNZ   2D58
02D3E:  MOVF   x5E,W
02D40:  SUBLW  01
02D42:  BC    2D5E
02D44:  XORLW  FF
02D46:  BNZ   2D58
02D48:  MOVF   x5D,W
02D4A:  SUBLW  04
02D4C:  BC    2D5E
02D4E:  XORLW  FF
02D50:  BNZ   2D58
02D52:  MOVF   x5C,W
02D54:  SUBLW  05
02D56:  BC    2D5E
....................                return FALSE; 
02D58:  MOVLW  00
02D5A:  MOVWF  01
02D5C:  BRA    2E26
....................  
....................             IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
02D5E:  MOVF   x62,W
02D60:  INCF   x62,F
02D62:  CLRF   03
02D64:  ADDWF  x5A,W
02D66:  MOVWF  FE9
02D68:  MOVF   x5B,W
02D6A:  ADDWFC 03,W
02D6C:  MOVWF  FEA
02D6E:  MOVF   x5E,W
02D70:  MULLW  64
02D72:  MOVFF  FF3,265
02D76:  MOVF   x5D,W
02D78:  MULLW  0A
02D7A:  MOVF   FF3,W
02D7C:  ADDWF  x65,W
02D7E:  ADDWF  x5C,W
02D80:  MOVWF  FEF
....................             charLen = 0; 
02D82:  CLRF   x61
....................             dwVal.Val = 0; 
02D84:  CLRF   x5F
02D86:  CLRF   x5E
02D88:  CLRF   x5D
02D8A:  CLRF   x5C
....................             continue; 
02D8C:  BRA    2C92
....................          } 
....................          if(i > 9u) 
02D8E:  MOVF   x60,W
02D90:  SUBLW  09
02D92:  BC    2D9A
....................             return FALSE; 
02D94:  MOVLW  00
02D96:  MOVWF  01
02D98:  BRA    2E26
....................       } 
....................  
....................       charLen++; 
02D9A:  INCF   x61,F
....................       dwVal.Val <<= 8; 
02D9C:  MOVFF  25E,25F
02DA0:  MOVFF  25D,25E
02DA4:  MOVFF  25C,25D
02DA8:  CLRF   x5C
....................       dwVal.v[0] = i; 
02DAA:  MOVFF  260,25C
02DAE:  BRA    2C92
....................    } 
....................  
....................    // Make sure the very last character is a valid termination character  
....................    // (i.e., not more hostname, which could be legal and not an IP  
....................    // address as in "10.5.13.233.picsaregood.com" 
....................    if(i != 0u && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t' && i != ':') 
02DB0:  MOVF   x60,F
02DB2:  BZ    2DDE
02DB4:  MOVF   x60,W
02DB6:  SUBLW  2F
02DB8:  BZ    2DDE
02DBA:  MOVF   x60,W
02DBC:  SUBLW  0D
02DBE:  BZ    2DDE
02DC0:  MOVF   x60,W
02DC2:  SUBLW  0A
02DC4:  BZ    2DDE
02DC6:  MOVF   x60,W
02DC8:  SUBLW  20
02DCA:  BZ    2DDE
02DCC:  MOVF   x60,W
02DCE:  SUBLW  09
02DD0:  BZ    2DDE
02DD2:  MOVF   x60,W
02DD4:  SUBLW  3A
02DD6:  BZ    2DDE
....................       return FALSE; 
02DD8:  MOVLW  00
02DDA:  MOVWF  01
02DDC:  BRA    2E26
....................  
....................    // Verify and convert the last octet and return the result 
....................    if(dwVal.Val > 0x00020505ul) 
02DDE:  MOVF   x5F,F
02DE0:  BNZ   2DFC
02DE2:  MOVF   x5E,W
02DE4:  SUBLW  01
02DE6:  BC    2E02
02DE8:  XORLW  FF
02DEA:  BNZ   2DFC
02DEC:  MOVF   x5D,W
02DEE:  SUBLW  04
02DF0:  BC    2E02
02DF2:  XORLW  FF
02DF4:  BNZ   2DFC
02DF6:  MOVF   x5C,W
02DF8:  SUBLW  05
02DFA:  BC    2E02
....................       return FALSE; 
02DFC:  MOVLW  00
02DFE:  MOVWF  01
02E00:  BRA    2E26
....................  
....................    IPAddress->v[3] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
02E02:  MOVLW  03
02E04:  ADDWF  x5A,W
02E06:  MOVWF  FE9
02E08:  MOVLW  00
02E0A:  ADDWFC x5B,W
02E0C:  MOVWF  FEA
02E0E:  MOVF   x5E,W
02E10:  MULLW  64
02E12:  MOVFF  FF3,265
02E16:  MOVF   x5D,W
02E18:  MULLW  0A
02E1A:  MOVF   FF3,W
02E1C:  ADDWF  x65,W
02E1E:  ADDWF  x5C,W
02E20:  MOVWF  FEF
....................  
....................    return TRUE; 
02E22:  MOVLW  01
02E24:  MOVWF  01
02E26:  MOVLB  0
02E28:  GOTO   2E42 (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL ROMStringToIPAddress(ROM BYTE* str, IP_ADDR* IPAddress) 
....................  
....................   Summary: 
....................    Converts a string to an IP address 
....................  
....................   Description: 
....................    This function parses a dotted-quad decimal IP address string into an  
....................    IP_ADDR struct.  The output result is big-endian. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    str - Pointer to a dotted-quad IP address string 
....................    IPAddress - Pointer to IP_ADDR in which to store the result 
....................  
....................   Return Values: 
....................      TRUE - an IP address was successfully decoded 
....................      FALSE - no IP address could be found, or the format was incorrect 
....................    
....................   Remarks: 
....................    This function is aliased to StringToIPAddress on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... BOOL ROMStringToIPAddress(ROM BYTE* str, IP_ADDR* IPAddress) 
.................... { 
....................    DWORD_VAL dwVal; 
....................    BYTE i, charLen, currentOctet; 
....................  
....................    charLen = 0; 
*
02A8E:  MOVLB  2
02A90:  CLRF   x63
....................    currentOctet = 0; 
02A92:  CLRF   x64
....................    dwVal.Val = 0; 
02A94:  CLRF   x61
02A96:  CLRF   x60
02A98:  CLRF   x5F
02A9A:  CLRF   x5E
....................    while(i = *str++) 
02A9C:  MOVFF  25B,03
02AA0:  MOVF   x5A,W
02AA2:  INCF   x5A,F
02AA4:  BTFSC  FD8.2
02AA6:  INCF   x5B,F
02AA8:  MOVWF  FF6
02AAA:  MOVFF  03,FF7
02AAE:  CLRF   FF8
02AB0:  MOVLW  02
02AB2:  MOVWF  FEA
02AB4:  MOVLW  62
02AB6:  MOVWF  FE9
02AB8:  CLRF   x82
02ABA:  MOVLW  01
02ABC:  MOVWF  x81
02ABE:  MOVLB  0
02AC0:  RCALL  2A70
02AC2:  MOVLB  2
02AC4:  MOVF   x62,F
02AC6:  BTFSC  FD8.2
02AC8:  BRA    2BCC
....................    { 
....................       if(currentOctet > 3u) 
02ACA:  MOVF   x64,W
02ACC:  SUBLW  03
02ACE:  BC    2AD2
....................          break; 
02AD0:  BRA    2BCC
....................  
....................       i -= '0'; 
02AD2:  MOVLW  30
02AD4:  SUBWF  x62,F
....................        
....................  
....................       // Validate the character is a numerical digit or dot, depending on location 
....................       if(charLen == 0u) 
02AD6:  MOVF   x63,F
02AD8:  BNZ   2AE8
....................       { 
....................          if(i > 9u) 
02ADA:  MOVF   x62,W
02ADC:  SUBLW  09
02ADE:  BC    2AE6
....................             return FALSE; 
02AE0:  MOVLW  00
02AE2:  MOVWF  01
02AE4:  BRA    2C3C
....................       } 
02AE6:  BRA    2BB6
....................       else if(charLen == 3u) 
02AE8:  MOVF   x63,W
02AEA:  SUBLW  03
02AEC:  BNZ   2B50
....................       { 
....................          if(i != (BYTE)('.' - '0')) 
02AEE:  MOVF   x62,W
02AF0:  SUBLW  FE
02AF2:  BZ    2AFA
....................             return FALSE; 
02AF4:  MOVLW  00
02AF6:  MOVWF  01
02AF8:  BRA    2C3C
....................  
....................          if(dwVal.Val > 0x00020505ul) 
02AFA:  MOVF   x61,F
02AFC:  BNZ   2B18
02AFE:  MOVF   x60,W
02B00:  SUBLW  01
02B02:  BC    2B1E
02B04:  XORLW  FF
02B06:  BNZ   2B18
02B08:  MOVF   x5F,W
02B0A:  SUBLW  04
02B0C:  BC    2B1E
02B0E:  XORLW  FF
02B10:  BNZ   2B18
02B12:  MOVF   x5E,W
02B14:  SUBLW  05
02B16:  BC    2B1E
....................             return FALSE; 
02B18:  MOVLW  00
02B1A:  MOVWF  01
02B1C:  BRA    2C3C
....................  
....................          IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
02B1E:  MOVF   x64,W
02B20:  INCF   x64,F
02B22:  CLRF   03
02B24:  ADDWF  x5C,W
02B26:  MOVWF  FE9
02B28:  MOVF   x5D,W
02B2A:  ADDWFC 03,W
02B2C:  MOVWF  FEA
02B2E:  MOVF   x60,W
02B30:  MULLW  64
02B32:  MOVFF  FF3,267
02B36:  MOVF   x5F,W
02B38:  MULLW  0A
02B3A:  MOVF   FF3,W
02B3C:  ADDWF  x67,W
02B3E:  ADDWF  x5E,W
02B40:  MOVWF  FEF
....................          charLen = 0; 
02B42:  CLRF   x63
....................          dwVal.Val = 0; 
02B44:  CLRF   x61
02B46:  CLRF   x60
02B48:  CLRF   x5F
02B4A:  CLRF   x5E
....................          continue; 
02B4C:  BRA    2A9C
....................       } 
02B4E:  BRA    2BB6
....................       else 
....................       { 
....................          if(i == (BYTE)('.' - '0')) 
02B50:  MOVF   x62,W
02B52:  SUBLW  FE
02B54:  BNZ   2BAA
....................          { 
....................             if(dwVal.Val > 0x00020505ul) 
02B56:  MOVF   x61,F
02B58:  BNZ   2B74
02B5A:  MOVF   x60,W
02B5C:  SUBLW  01
02B5E:  BC    2B7A
02B60:  XORLW  FF
02B62:  BNZ   2B74
02B64:  MOVF   x5F,W
02B66:  SUBLW  04
02B68:  BC    2B7A
02B6A:  XORLW  FF
02B6C:  BNZ   2B74
02B6E:  MOVF   x5E,W
02B70:  SUBLW  05
02B72:  BC    2B7A
....................                return FALSE; 
02B74:  MOVLW  00
02B76:  MOVWF  01
02B78:  BRA    2C3C
....................  
....................             IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
02B7A:  MOVF   x64,W
02B7C:  INCF   x64,F
02B7E:  CLRF   03
02B80:  ADDWF  x5C,W
02B82:  MOVWF  FE9
02B84:  MOVF   x5D,W
02B86:  ADDWFC 03,W
02B88:  MOVWF  FEA
02B8A:  MOVF   x60,W
02B8C:  MULLW  64
02B8E:  MOVFF  FF3,267
02B92:  MOVF   x5F,W
02B94:  MULLW  0A
02B96:  MOVF   FF3,W
02B98:  ADDWF  x67,W
02B9A:  ADDWF  x5E,W
02B9C:  MOVWF  FEF
....................             charLen = 0; 
02B9E:  CLRF   x63
....................             dwVal.Val = 0; 
02BA0:  CLRF   x61
02BA2:  CLRF   x60
02BA4:  CLRF   x5F
02BA6:  CLRF   x5E
....................             continue; 
02BA8:  BRA    2A9C
....................          } 
....................          if(i > 9u) 
02BAA:  MOVF   x62,W
02BAC:  SUBLW  09
02BAE:  BC    2BB6
....................             return FALSE; 
02BB0:  MOVLW  00
02BB2:  MOVWF  01
02BB4:  BRA    2C3C
....................       } 
....................  
....................       charLen++; 
02BB6:  INCF   x63,F
....................       dwVal.Val <<= 8; 
02BB8:  MOVFF  260,261
02BBC:  MOVFF  25F,260
02BC0:  MOVFF  25E,25F
02BC4:  CLRF   x5E
....................       dwVal.v[0] = i; 
02BC6:  MOVFF  262,25E
02BCA:  BRA    2A9C
....................    } 
....................  
....................    // Make sure the very last character is a valid termination character  
....................    // (i.e., not more hostname, which could be legal and not an IP  
....................    // address as in "10.5.13.233.picsaregood.com" 
....................    if(i != 0u && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t') 
02BCC:  MOVF   x62,F
02BCE:  BZ    2BF4
02BD0:  MOVF   x62,W
02BD2:  SUBLW  2F
02BD4:  BZ    2BF4
02BD6:  MOVF   x62,W
02BD8:  SUBLW  0D
02BDA:  BZ    2BF4
02BDC:  MOVF   x62,W
02BDE:  SUBLW  0A
02BE0:  BZ    2BF4
02BE2:  MOVF   x62,W
02BE4:  SUBLW  20
02BE6:  BZ    2BF4
02BE8:  MOVF   x62,W
02BEA:  SUBLW  09
02BEC:  BZ    2BF4
....................       return FALSE; 
02BEE:  MOVLW  00
02BF0:  MOVWF  01
02BF2:  BRA    2C3C
....................  
....................    // Verify and convert the last octet and return the result 
....................    if(dwVal.Val > 0x00020505ul) 
02BF4:  MOVF   x61,F
02BF6:  BNZ   2C12
02BF8:  MOVF   x60,W
02BFA:  SUBLW  01
02BFC:  BC    2C18
02BFE:  XORLW  FF
02C00:  BNZ   2C12
02C02:  MOVF   x5F,W
02C04:  SUBLW  04
02C06:  BC    2C18
02C08:  XORLW  FF
02C0A:  BNZ   2C12
02C0C:  MOVF   x5E,W
02C0E:  SUBLW  05
02C10:  BC    2C18
....................       return FALSE; 
02C12:  MOVLW  00
02C14:  MOVWF  01
02C16:  BRA    2C3C
....................  
....................    IPAddress->v[3] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
02C18:  MOVLW  03
02C1A:  ADDWF  x5C,W
02C1C:  MOVWF  FE9
02C1E:  MOVLW  00
02C20:  ADDWFC x5D,W
02C22:  MOVWF  FEA
02C24:  MOVF   x60,W
02C26:  MULLW  64
02C28:  MOVFF  FF3,267
02C2C:  MOVF   x5F,W
02C2E:  MULLW  0A
02C30:  MOVF   FF3,W
02C32:  ADDWF  x67,W
02C34:  ADDWF  x5E,W
02C36:  MOVWF  FEF
....................  
....................    return TRUE; 
02C38:  MOVLW  01
02C3A:  MOVWF  01
02C3C:  MOVLB  0
02C3E:  GOTO   2C58 (RETURN)
.................... } 
.................... #endif 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD Base64Decode(BYTE* cSourceData, WORD wSourceLen,  
....................                   BYTE* cDestData, WORD wDestLen) 
....................  
....................   Description: 
....................    Decodes a Base-64 array to its literal representation. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    cSourceData - Pointer to a string of Base-64 encoded data 
....................    wSourceLen   - Length of the Base-64 source data 
....................    cDestData   - Pointer to write the decoded data 
....................    wSourceLen   - Maximum length that can be written to cDestData 
....................  
....................   Returns: 
....................      Number of decoded bytes written to cDestData. 
....................    
....................   Remarks: 
....................    This function is binary safe and will ignore invalid characters (CR, LF,  
....................    etc).  If cSourceData is equal to cDestData, the data will be converted 
....................    in-place.  If cSourceData is not equal to cDestData, but the regions  
....................    overlap, the behavior is undefined. 
....................     
....................    Decoded data is always at least 1/4 smaller than the source data. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_BASE64_DECODE) 
.................... WORD Base64Decode(BYTE* cSourceData, WORD wSourceLen, BYTE* cDestData, WORD wDestLen) 
.................... { 
....................    BYTE i; 
....................    BYTE vByteNumber; 
....................    WORD wBytesOutput; 
....................  
....................    vByteNumber = 0; 
....................    wBytesOutput = 0; 
....................  
....................    // Loop over all provided bytes 
....................    while(wSourceLen--) 
....................    { 
....................       // Fetch a Base64 byte and decode it to the original 6 bits 
....................       i = *cSourceData++; 
....................       if(i >= 'A' && i <= 'Z')   // Regular data 
....................          i -= 'A' - 0; 
....................       else if(i >= 'a' && i <= 'z') 
....................          i -= 'a' - 26; 
....................       else if(i >= '0' && i <= '9') 
....................          i -= '0' - 52; 
....................       else if(i == '+' || i == '-') 
....................          i = 62; 
....................       else if(i == '/' || i == '_') 
....................          i = 63; 
....................       else                   // Skip all padding (=) and non-Base64 characters 
....................          continue; 
....................  
....................  
....................       // Write the 6 bits to the correct destination location(s) 
....................       if(vByteNumber == 0u) 
....................       { 
....................          vByteNumber++; 
....................          if(wBytesOutput >= wDestLen) 
....................             break; 
....................          wBytesOutput++; 
....................          *cDestData = i << 2; 
....................       } 
....................       else if(vByteNumber == 1u) 
....................       { 
....................          vByteNumber++; 
....................          *cDestData++ |= i >> 4; 
....................          if(wBytesOutput >= wDestLen) 
....................             break; 
....................          wBytesOutput++; 
....................          *cDestData = i << 4; 
....................       } 
....................       else if(vByteNumber == 2u) 
....................       { 
....................          vByteNumber++; 
....................          *cDestData++ |= i >> 2; 
....................          if(wBytesOutput >= wDestLen) 
....................             break; 
....................          wBytesOutput++; 
....................          *cDestData = i << 6; 
....................       } 
....................       else 
....................       { 
....................          vByteNumber = 0; 
....................          *cDestData++ |= i; 
....................       } 
....................    } 
....................  
....................    return wBytesOutput; 
.................... } 
.................... #endif   // #if defined(STACK_USE_BASE64_DECODE) 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD Base64Encode(BYTE* cSourceData, WORD wSourceLen, 
....................                   BYTE* cDestData, WORD wDestLen) 
....................  
....................   Description: 
....................    Encodes a binary array to Base-64. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    cSourceData - Pointer to a string of binary data 
....................    wSourceLen   - Length of the binary source data 
....................    cDestData   - Pointer to write the Base-64 encoded data 
....................    wSourceLen   - Maximum length that can be written to cDestData 
....................  
....................   Returns: 
....................      Number of encoded bytes written to cDestData.  This will always be 
....................      a multiple of 4. 
....................    
....................   Remarks: 
....................    Encoding cannot be performed in-place.  If cSourceData overlaps with  
....................    cDestData, the behavior is undefined. 
....................     
....................    Encoded data is always at least 1/3 larger than the source data.  It may 
....................    be 1 or 2 bytes larger than that. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_BASE64_ENCODE) || defined(STACK_USE_SMTP_CLIENT) || defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... WORD Base64Encode(BYTE* cSourceData, WORD wSourceLen, BYTE* cDestData, WORD wDestLen) 
.................... { 
....................    BYTE i, j; 
....................    BYTE vOutput[4]; 
....................    WORD wOutputLen; 
....................  
....................    wOutputLen = 0; 
....................    while(wDestLen >= 4u) 
....................    { 
....................       // Start out treating the output as all padding 
....................       vOutput[0] = 0xFF; 
....................       vOutput[1] = 0xFF; 
....................       vOutput[2] = 0xFF; 
....................       vOutput[3] = 0xFF; 
....................  
....................       // Get 3 input octets and split them into 4 output hextets (6-bits each)  
....................       if(wSourceLen == 0u) 
....................          break; 
....................       i = *cSourceData++; 
....................       wSourceLen--; 
....................       vOutput[0] = (i & 0xFC)>>2; 
....................       vOutput[1] = (i & 0x03)<<4; 
....................       if(wSourceLen) 
....................       { 
....................          i = *cSourceData++; 
....................          wSourceLen--; 
....................          vOutput[1] |= (i & 0xF0)>>4; 
....................          vOutput[2] = (i & 0x0F)<<2; 
....................          if(wSourceLen) 
....................          { 
....................             i = *cSourceData++; 
....................             wSourceLen--; 
....................             vOutput[2] |= (i & 0xC0)>>6; 
....................             vOutput[3] = i & 0x3F; 
....................          } 
....................       } 
....................     
....................       // Convert hextets into Base 64 alphabet and store result 
....................       for(i = 0; i < 4u; i++) 
....................       { 
....................          j = vOutput[i]; 
....................  
....................          if(j <= 25u) 
....................             j += 'A' - 0; 
....................          else if(j <= 51u) 
....................             j += 'a' - 26; 
....................          else if(j <= 61u) 
....................             j += '0' - 52; 
....................          else if(j == 62u) 
....................             j = '+'; 
....................          else if(j == 63u) 
....................             j = '/'; 
....................          else            // Padding 
....................             j = '='; 
....................  
....................          *cDestData++ = j; 
....................       } 
....................  
....................       // Update counters 
....................       wDestLen -= 4; 
....................       wOutputLen += 4; 
....................    } 
....................  
....................    return wOutputLen; 
.................... } 
.................... #endif // #if defined(STACK_USE_BASE64_ENCODE) || defined(STACK_USE_SMTP) || defined(STACK_USE_DYNAMICDNS_CLIENT) 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void uitoa(WORD Value, BYTE* Buffer) 
....................  
....................   Summary: 
....................    Converts an unsigned integer to a decimal string. 
....................     
....................   Description: 
....................    Converts a 16-bit unsigned integer to a null-terminated decimal string. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    Value   - The number to be converted 
....................    Buffer   - Pointer in which to store the converted string 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... void uitoa(WORD Value, BYTE* Buffer) 
.................... { 
....................    BYTE i; 
....................    WORD Digit; 
....................    WORD Divisor; 
....................    BOOL Printed = FALSE; 
....................  
....................    if(Value) 
....................    { 
....................       for(i = 0, Divisor = 10000; i < 5u; i++) 
....................       { 
....................          Digit = Value/Divisor; 
....................          if(Digit || Printed) 
....................          { 
....................             *Buffer++ = '0' + Digit; 
....................             Value -= Digit*Divisor; 
....................             Printed = TRUE; 
....................          } 
....................          Divisor /= 10; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       *Buffer++ = '0'; 
....................    } 
....................  
....................    *Buffer = '\0'; 
.................... }              
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ultoa(DWORD Value, BYTE* Buffer) 
....................  
....................   Summary: 
....................    Converts an unsigned integer to a decimal string. 
....................     
....................   Description: 
....................    Converts a 32-bit unsigned integer to a null-terminated decimal string. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    Value   - The number to be converted 
....................    Buffer   - Pointer in which to store the converted string 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... // HI-TECH PICC-18 PRO 9.63, C30 v3.25, and C32 v1.12 already have a ultoa() library function 
.................... // C18 already has a ultoa() function that more-or-less matches this one 
.................... // C32 < 1.12 and C30 < v3.25 need this function 
.................... #if (defined(__PIC32MX__) && (__C32_VERSION__ < 112)) || (defined (__C30__) && (__C30_VERSION__ < 325)) || defined(__C30_LEGACY_LIBC__) || defined(__C32_LEGACY_LIBC__) 
.................... void ultoa(DWORD Value, BYTE* Buffer) 
.................... { 
....................    BYTE i; 
....................    DWORD Digit; 
....................    DWORD Divisor; 
....................    BOOL Printed = FALSE; 
....................  
....................    if(Value) 
....................    { 
....................       for(i = 0, Divisor = 1000000000; i < 10; i++) 
....................       { 
....................          Digit = Value/Divisor; 
....................          if(Digit || Printed) 
....................          { 
....................             *Buffer++ = '0' + Digit; 
....................             Value -= Digit*Divisor; 
....................             Printed = TRUE; 
....................          } 
....................          Divisor /= 10; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       *Buffer++ = '0'; 
....................    } 
....................  
....................    *Buffer = '\0'; 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE hexatob(WORD_VAL AsciiChars) 
....................  
....................   Summary: 
....................    Converts a hex string to a single byte. 
....................     
....................   Description: 
....................    Converts a two-character ASCII hex string to a single packed byte. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    AsciiChars - WORD_VAL where .v[0] is the ASCII value for the lower nibble 
....................                and .v[1] is the ASCII value for the upper nibble.  Each 
....................                must range from '0'-'9', 'A'-'F', or 'a'-'f'. 
....................  
....................   Returns: 
....................      Resulting packed byte 0x00 - 0xFF. 
....................   ***************************************************************************/ 
.................... BYTE hexatob(WORD_VAL AsciiChars) 
.................... { 
....................    // Convert lowercase to uppercase 
....................    if(AsciiChars.v[1] > 'F') 
....................       AsciiChars.v[1] -= 'a'-'A'; 
....................    if(AsciiChars.v[0] > 'F') 
....................       AsciiChars.v[0] -= 'a'-'A'; 
....................  
....................    // Convert 0-9, A-F to 0x0-0xF 
....................    if(AsciiChars.v[1] > '9') 
....................       AsciiChars.v[1] -= 'A' - 10; 
....................    else 
....................       AsciiChars.v[1] -= '0'; 
....................  
....................    if(AsciiChars.v[0] > '9') 
....................       AsciiChars.v[0] -= 'A' - 10; 
....................    else 
....................       AsciiChars.v[0] -= '0'; 
....................  
....................    // Concatenate 
....................    return (AsciiChars.v[1]<<4) |  AsciiChars.v[0]; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE btohexa_high(BYTE b) 
....................  
....................   Summary: 
....................    Converts the upper nibble of a binary value to a hexadecimal ASCII byte. 
....................  
....................   Description: 
....................    Converts the upper nibble of a binary value to a hexadecimal ASCII byte. 
....................    For example, btohexa_high(0xAE) will return 'A'. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    b - the byte to convert 
....................  
....................   Returns: 
....................      The upper hexadecimal ASCII byte '0'-'9' or 'A'-'F'. 
....................   ***************************************************************************/ 
.................... BYTE btohexa_high(BYTE b) 
.................... { 
....................    b >>= 4; 
....................    return (b>0x9u) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE btohexa_high(BYTE b) 
....................  
....................   Summary: 
....................    Converts the lower nibble of a binary value to a hexadecimal ASCII byte. 
....................  
....................   Description: 
....................    Converts the lower nibble of a binary value to a hexadecimal ASCII byte. 
....................    For example, btohexa_high(0xAE) will return 'E'. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    b - the byte to convert 
....................  
....................   Returns: 
....................      The lower hexadecimal ASCII byte '0'-'9' or 'A'-'F'. 
....................   ***************************************************************************/ 
.................... BYTE btohexa_low(BYTE b) 
.................... { 
....................    b &= 0x0F; 
....................    return (b>9u) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    signed char stricmppgm2ram(BYTE* a, ROM BYTE* b) 
....................  
....................   Summary: 
....................    Case-insensitive comparison of a string in RAM to a string in ROM. 
....................  
....................   Description: 
....................    Performs a case-insensitive comparison of a string in RAM to a string 
....................    in ROM.  This function performs identically to strcmppgm2ram, except that 
....................    the comparison is not case-sensitive. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    a - Pinter to tring in RAM 
....................    b - Pointer to string in ROM 
....................  
....................   Return Values: 
....................      \-1 - a < b 
....................      0   - a = b 
....................      1   - a > b 
....................   ***************************************************************************/ 
.................... signed char stricmppgm2ram(BYTE* a, ROM BYTE* b) 
.................... { 
....................    BYTE cA, cB; 
....................     
....................    // Load first two characters 
....................    cA = *a; 
....................    cB = *b; 
....................     
....................    // Loop until one string terminates 
....................    while(cA != '\0' && cB != '\0') 
....................    { 
....................       // Shift case if necessary 
....................       if(cA >= 'a' && cA <= 'z') 
....................          cA -= 'a' - 'A'; 
....................       if(cB >= 'a' && cB <= 'z') 
....................          cB -= 'a' - 'A'; 
....................           
....................       // Compare 
....................       if(cA > cB) 
....................          return 1; 
....................       if(cA < cB) 
....................          return -1; 
....................        
....................       // Characters matched, so continue 
....................       a++; 
....................       b++; 
....................       cA = *a; 
....................       cB = *b; 
....................    } 
....................     
....................    // See if one string terminated first 
....................    if(cA > cB) 
....................       return 1; 
....................    if(cA < cB) 
....................       return -1; 
....................        
....................    // Strings match 
....................    return 0; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD swaps(WORD v) 
....................  
....................   Description: 
....................    Swaps the endian-ness of a WORD. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    v - the WORD to swap 
....................  
....................   Returns: 
....................    The swapped version of v. 
....................   ***************************************************************************/ 
.................... WORD swaps(WORD v) 
.................... { 
....................    WORD_VAL t; 
....................    BYTE b; 
....................  
....................    t.Val   = v; 
*
01874:  MOVFF  2E1,2E3
01878:  MOVFF  2E0,2E2
....................    b       = t.v[1]; 
0187C:  MOVFF  2E3,2E4
....................    t.v[1]  = t.v[0]; 
01880:  MOVFF  2E2,2E3
....................    t.v[0]  = b; 
01884:  MOVFF  2E4,2E2
....................  
....................    return t.Val; 
01888:  MOVLB  2
0188A:  MOVFF  2E2,01
0188E:  MOVFF  2E3,02
01892:  MOVLB  0
01894:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    DWORD swapl(DWORD v) 
....................  
....................   Description: 
....................    Swaps the endian-ness of a DWORD. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    v - the DWORD to swap 
....................  
....................   Returns: 
....................    The swapped version of v. 
....................   ***************************************************************************/ 
.................... #if defined(__C32__) 
.................... DWORD   __attribute__((nomips16)) swapl(DWORD v) 
.................... #else 
.................... DWORD swapl(DWORD v) 
.................... #endif 
.................... { 
....................    // Swap bytes 0 and 3 
....................    ((DWORD_VAL*)&v)->v[0] ^= ((DWORD_VAL*)&v)->v[3]; 
01896:  MOVLW  02
01898:  MOVLB  2
0189A:  MOVWF  xCE
0189C:  MOVLW  C9
0189E:  MOVWF  01
018A0:  MOVFF  2CE,FEA
018A4:  MOVWF  FE9
018A6:  MOVFF  FEF,2D1
018AA:  MOVLW  02
018AC:  MOVWF  xD3
018AE:  MOVLW  C9
018B0:  MOVWF  xD2
018B2:  MOVLW  03
018B4:  ADDWF  xD2,W
018B6:  MOVWF  FE9
018B8:  MOVLW  00
018BA:  ADDWFC xD3,W
018BC:  MOVWF  FEA
018BE:  MOVF   FEF,W
018C0:  XORWF  xD1,W
018C2:  MOVFF  2CE,FEA
018C6:  MOVFF  01,FE9
018CA:  MOVWF  FEF
....................    ((DWORD_VAL*)&v)->v[3] ^= ((DWORD_VAL*)&v)->v[0]; 
018CC:  MOVLW  02
018CE:  MOVWF  xCE
018D0:  MOVLW  C9
018D2:  MOVWF  xCD
018D4:  MOVLW  03
018D6:  ADDWF  xCD,W
018D8:  MOVWF  01
018DA:  MOVLW  00
018DC:  ADDWFC xCE,W
018DE:  MOVWF  03
018E0:  MOVWF  FEA
018E2:  MOVFF  01,FE9
018E6:  MOVFF  FEF,2D1
018EA:  MOVLW  02
018EC:  MOVWF  xD3
018EE:  MOVLW  C9
018F0:  MOVWF  FE9
018F2:  MOVFF  2D3,FEA
018F6:  MOVF   FEF,W
018F8:  XORWF  xD1,W
018FA:  MOVFF  03,FEA
018FE:  MOVFF  01,FE9
01902:  MOVWF  FEF
....................    ((DWORD_VAL*)&v)->v[0] ^= ((DWORD_VAL*)&v)->v[3]; 
01904:  MOVLW  02
01906:  MOVWF  xCE
01908:  MOVLW  C9
0190A:  MOVWF  01
0190C:  MOVFF  2CE,FEA
01910:  MOVWF  FE9
01912:  MOVFF  FEF,2D1
01916:  MOVLW  02
01918:  MOVWF  xD3
0191A:  MOVLW  C9
0191C:  MOVWF  xD2
0191E:  MOVLW  03
01920:  ADDWF  xD2,W
01922:  MOVWF  FE9
01924:  MOVLW  00
01926:  ADDWFC xD3,W
01928:  MOVWF  FEA
0192A:  MOVF   FEF,W
0192C:  XORWF  xD1,W
0192E:  MOVFF  2CE,FEA
01932:  MOVFF  01,FE9
01936:  MOVWF  FEF
....................  
....................    // Swap bytes 1 and 2 
....................    ((DWORD_VAL*)&v)->v[1] ^= ((DWORD_VAL*)&v)->v[2]; 
01938:  MOVLW  02
0193A:  MOVWF  xCE
0193C:  MOVLW  C9
0193E:  MOVWF  xCD
01940:  MOVLW  01
01942:  ADDWF  xCD,W
01944:  MOVWF  01
01946:  MOVLW  00
01948:  ADDWFC xCE,W
0194A:  MOVWF  03
0194C:  MOVWF  FEA
0194E:  MOVFF  01,FE9
01952:  MOVFF  FEF,2D1
01956:  MOVLW  02
01958:  MOVWF  xD3
0195A:  MOVLW  C9
0195C:  MOVWF  xD2
0195E:  MOVLW  02
01960:  ADDWF  xD2,W
01962:  MOVWF  FE9
01964:  MOVLW  00
01966:  ADDWFC xD3,W
01968:  MOVWF  FEA
0196A:  MOVF   FEF,W
0196C:  XORWF  xD1,W
0196E:  MOVFF  03,FEA
01972:  MOVFF  01,FE9
01976:  MOVWF  FEF
....................    ((DWORD_VAL*)&v)->v[2] ^= ((DWORD_VAL*)&v)->v[1]; 
01978:  MOVLW  02
0197A:  MOVWF  xCE
0197C:  MOVLW  C9
0197E:  MOVWF  xCD
01980:  MOVLW  02
01982:  ADDWF  xCD,W
01984:  MOVWF  01
01986:  MOVLW  00
01988:  ADDWFC xCE,W
0198A:  MOVWF  03
0198C:  MOVWF  FEA
0198E:  MOVFF  01,FE9
01992:  MOVFF  FEF,2D1
01996:  MOVLW  02
01998:  MOVWF  xD3
0199A:  MOVLW  C9
0199C:  MOVWF  xD2
0199E:  MOVLW  01
019A0:  ADDWF  xD2,W
019A2:  MOVWF  FE9
019A4:  MOVLW  00
019A6:  ADDWFC xD3,W
019A8:  MOVWF  FEA
019AA:  MOVF   FEF,W
019AC:  XORWF  xD1,W
019AE:  MOVFF  03,FEA
019B2:  MOVFF  01,FE9
019B6:  MOVWF  FEF
....................    ((DWORD_VAL*)&v)->v[1] ^= ((DWORD_VAL*)&v)->v[2]; 
019B8:  MOVLW  02
019BA:  MOVWF  xCE
019BC:  MOVLW  C9
019BE:  MOVWF  xCD
019C0:  MOVLW  01
019C2:  ADDWF  xCD,W
019C4:  MOVWF  01
019C6:  MOVLW  00
019C8:  ADDWFC xCE,W
019CA:  MOVWF  03
019CC:  MOVWF  FEA
019CE:  MOVFF  01,FE9
019D2:  MOVFF  FEF,2D1
019D6:  MOVLW  02
019D8:  MOVWF  xD3
019DA:  MOVLW  C9
019DC:  MOVWF  xD2
019DE:  MOVLW  02
019E0:  ADDWF  xD2,W
019E2:  MOVWF  FE9
019E4:  MOVLW  00
019E6:  ADDWFC xD3,W
019E8:  MOVWF  FEA
019EA:  MOVF   FEF,W
019EC:  XORWF  xD1,W
019EE:  MOVFF  03,FEA
019F2:  MOVFF  01,FE9
019F6:  MOVWF  FEF
....................  
....................    return v; 
019F8:  MOVFF  2C9,00
019FC:  MOVFF  2CA,01
01A00:  MOVFF  2CB,02
01A04:  MOVFF  2CC,03
01A08:  MOVLB  0
01A0A:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD CalcIPChecksum(BYTE* buffer, WORD count) 
....................  
....................   Summary: 
....................    Calculates an IP checksum value. 
....................  
....................   Description: 
....................    This function calculates an IP checksum over an array of input data.  The 
....................    checksum is the 16-bit one's complement of one's complement sum of all  
....................    words in the data (with zero-padding if an odd number of bytes are  
....................    summed).  This checksum is defined in RFC 793. 
....................  
....................   Precondition: 
....................    buffer is WORD aligned (even memory address) on 16- and 32-bit PICs. 
....................  
....................   Parameters: 
....................    buffer - pointer to the data to be checksummed 
....................    count  - number of bytes to be checksummed 
....................  
....................   Returns: 
....................    The calculated checksum. 
....................     
....................   Internal: 
....................    This function could be improved to do 32-bit sums on PIC32 platforms. 
....................   ***************************************************************************/ 
.................... WORD CalcIPChecksum(BYTE* buffer, WORD count) 
.................... { 
....................    WORD i; 
....................    WORD *val; 
....................    union 
....................    { 
....................       WORD w[2]; 
....................       DWORD dw; 
....................    } sum; 
....................  
....................    i = count >> 1; 
*
01C28:  BCF    FD8.0
01C2A:  MOVLB  2
01C2C:  RRCF   xDF,W
01C2E:  MOVWF  xE1
01C30:  RRCF   xDE,W
01C32:  MOVWF  xE0
....................    val = (WORD*)buffer; 
01C34:  MOVFF  2DD,2E3
01C38:  MOVFF  2DC,2E2
....................  
....................    // Calculate the sum of all words 
....................    sum.dw = 0x00000000ul; 
01C3C:  CLRF   xE7
01C3E:  CLRF   xE6
01C40:  CLRF   xE5
01C42:  CLRF   xE4
....................    while(i--) 
01C44:  MOVFF  2E1,03
01C48:  MOVF   xE0,W
01C4A:  BTFSC  FD8.2
01C4C:  DECF   xE1,F
01C4E:  DECF   xE0,F
01C50:  IORWF  03,W
01C52:  BZ    1C90
....................       sum.dw += (DWORD)*val++; 
01C54:  MOVFF  2E3,03
01C58:  MOVFF  2E2,00
01C5C:  MOVLW  02
01C5E:  ADDWF  xE2,F
01C60:  BTFSC  FD8.0
01C62:  INCF   xE3,F
01C64:  MOVFF  00,FE9
01C68:  MOVFF  03,FEA
01C6C:  MOVFF  FEC,03
01C70:  MOVF   FED,F
01C72:  MOVFF  FEF,00
01C76:  MOVFF  03,01
01C7A:  CLRF   02
01C7C:  CLRF   03
01C7E:  MOVF   00,W
01C80:  ADDWF  xE4,F
01C82:  MOVF   01,W
01C84:  ADDWFC xE5,F
01C86:  MOVF   02,W
01C88:  ADDWFC xE6,F
01C8A:  MOVF   03,W
01C8C:  ADDWFC xE7,F
01C8E:  BRA    1C44
....................  
....................    // Add in the sum of the remaining byte, if present 
....................    if(count & 0x1) 
01C90:  MOVF   xDE,W
01C92:  ANDLW  01
01C94:  MOVWF  00
01C96:  CLRF   03
01C98:  MOVF   00,W
01C9A:  IORWF  03,W
01C9C:  BZ    1CC4
....................       sum.dw += (DWORD)*(BYTE*)val; 
01C9E:  MOVFF  2E3,03
01CA2:  MOVFF  2E2,FE9
01CA6:  MOVFF  2E3,FEA
01CAA:  MOVFF  FEF,00
01CAE:  CLRF   01
01CB0:  CLRF   02
01CB2:  CLRF   03
01CB4:  MOVF   00,W
01CB6:  ADDWF  xE4,F
01CB8:  MOVF   01,W
01CBA:  ADDWFC xE5,F
01CBC:  MOVF   02,W
01CBE:  ADDWFC xE6,F
01CC0:  MOVF   03,W
01CC2:  ADDWFC xE7,F
....................  
....................    // Do an end-around carry (one's complement arrithmatic) 
....................    sum.dw = (DWORD)sum.w[0] + (DWORD)sum.w[1]; 
01CC4:  CLRF   xEB
01CC6:  CLRF   xEA
01CC8:  MOVFF  2E5,2E9
01CCC:  MOVFF  2E4,2E8
01CD0:  MOVFF  2E6,00
01CD4:  MOVFF  2E7,01
01CD8:  CLRF   02
01CDA:  CLRF   03
01CDC:  MOVF   xE6,W
01CDE:  ADDWF  xE4,W
01CE0:  MOVWF  xE4
01CE2:  MOVF   xE7,W
01CE4:  ADDWFC xE5,W
01CE6:  MOVWF  xE5
01CE8:  MOVF   02,W
01CEA:  ADDWFC xEA,W
01CEC:  MOVWF  xE6
01CEE:  MOVF   03,W
01CF0:  ADDWFC xEB,W
01CF2:  MOVWF  xE7
....................  
....................    // Do another end-around carry in case if the prior add  
....................    // caused a carry out 
....................    sum.w[0] += sum.w[1]; 
01CF4:  MOVF   xE6,W
01CF6:  ADDWF  xE4,F
01CF8:  MOVF   xE7,W
01CFA:  ADDWFC xE5,F
....................  
....................    // Return the resulting checksum 
....................    return ~sum.w[0]; 
01CFC:  MOVFF  2E5,03
01D00:  COMF   03,F
01D02:  MOVF   xE4,W
01D04:  XORLW  FF
01D06:  MOVWF  01
01D08:  MOVFF  03,02
01D0C:  MOVLB  0
01D0E:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    char* strupr(char* s) 
....................  
....................   Summary: 
....................    Converts a string to uppercase. 
....................  
....................   Description: 
....................    This function converts strings to uppercase on platforms that do not 
....................    already have this function defined.  All lower-case characters are 
....................    converted, an characters not included in 'a'-'z' are left as-is. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    s - the null-terminated string to be converted. 
....................  
....................   Returns: 
....................    Pointer to the initial string. 
....................   ***************************************************************************/ 
.................... #if (!defined(__PCD__) && !defined(__18CXX)) || defined(HI_TECH_C) 
.................... char* strupr(char* s) 
.................... { 
....................    char c; 
....................    char *t; 
....................  
....................    t = s; 
....................    while( (c = *t) ) 
....................    { 
....................       if(c >= 'a' && c <= 'z') 
....................       { 
....................          *t -= ('a' - 'A'); 
....................       } 
....................       t++; 
....................    } 
....................    return s; 
.................... } 
.................... #endif 
....................  
.................... #if defined(__18CXX) //&& !defined(__PCH__) 
.................... // Make this variable global for the following function. 
.................... // Hi-Tech PICC18 cannot access local function variables from inline asm. 
.................... DWORD_VAL toRotate;  
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    DWORD leftRotateDWORD(DWORD val, BYTE bits) 
....................  
....................   Summary: 
....................    Left-rotates a DWORD. 
....................  
....................   Description: 
....................    This function rotates the bits in a 32-bit DWORD left by a specific  
....................    number of bits. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    val      - the DWORD to be rotated 
....................    bits   - the number of bits by which to shift 
....................  
....................   Returns: 
....................    Rotated DWORD value. 
....................     
....................   Remarks: 
....................    This function is only implemented on 8-bit platforms for now.  The  
....................    8-bit compilers generate excessive code for this function, while C30 
....................    and C32 already generate compact code.  Those compilers are served 
....................    by a macro defined in Helpers.h. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... DWORD leftRotateDWORD(DWORD val, BYTE bits) 
.................... { 
....................    BYTE i, t; 
....................    //DWORD_VAL toRotate; 
....................    toRotate.Val = val; 
....................     
....................    for(i = bits; i >= 8u; i -= 8) 
....................    { 
....................       t = toRotate.v[3]; 
....................       toRotate.v[3] = toRotate.v[2]; 
....................       toRotate.v[2] = toRotate.v[1]; 
....................       toRotate.v[1] = toRotate.v[0]; 
....................       toRotate.v[0] = t; 
....................    } 
....................     
....................     
....................    #if defined(HI_TECH_C) 
....................    for(; i != 0; i--) 
....................    { 
....................       asm("movlb (_toRotate)>>8"); 
....................       //asm("bcf _STATUS,0,C"); 
....................       asm("bcf 0xFD8,0,C");      // HI-TECH PICC-18 PRO 9.63PL1 doesn't define _STATUS 
....................       asm("btfsc (_toRotate)&0ffh+3,7,B"); 
....................       //asm("bsf _STATUS,0,C"); 
....................       asm("bsf 0xFD8,0,C");      // HI-TECH PICC-18 PRO 9.63PL1 doesn't define _STATUS 
....................       asm("rlcf (_toRotate)&0ffh+0,F,B"); 
....................       asm("rlcf (_toRotate)&0ffh+1,F,B"); 
....................       asm("rlcf (_toRotate)&0ffh+2,F,B"); 
....................       asm("rlcf (_toRotate)&0ffh+3,F,B"); 
....................    } 
....................    #else 
....................    for(; i != 0u; i--) 
....................    { 
....................       _asm 
....................       movlb toRotate 
....................       bcf STATUS,0,0 
....................       btfsc toRotate+3,7,1 
....................       bsf STATUS,0,0 
....................       rlcf toRotate+0,1,1 
....................       rlcf toRotate+1,1,1 
....................       rlcf toRotate+2,1,1 
....................       rlcf toRotate+3,1,1 
....................       _endasm 
....................    } 
....................    #endif 
....................     
....................    return toRotate.Val; 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void FormatNetBIOSName(BYTE Name[]) 
....................  
....................   Summary: 
....................    Formats a string to a valid NetBIOS name. 
....................  
....................   Description: 
....................    This function formats a string to a valid NetBIOS name.  Names will be 
....................    exactly 16 characters, as defined by the NetBIOS spec.  The 16th  
....................    character will be a 0x00 byte, while the other 15 will be the  
....................    provided string, padded with spaces as necessary. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    Name - the string to format as a NetBIOS name.  This parameter must have 
....................      at least 16 bytes allocated. 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... void FormatNetBIOSName(BYTE Name[]) 
.................... { 
....................    BYTE i; 
....................  
....................    Name[15] = '\0'; 
....................    strupr((char*)Name); 
....................    i = 0; 
....................    while(i < 15u) 
....................    { 
....................       if(Name[i] == '\0') 
....................       { 
....................          while(i < 15u) 
....................          { 
....................             Name[i++] = ' '; 
....................          } 
....................          break; 
....................       } 
....................       i++; 
....................    } 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    char * strnchr(const char *searchString, size_t count, char c) 
....................  
....................   Summary: 
....................    Searches a string up to a specified number of characters for a specific  
....................    character. 
....................  
....................   Description: 
....................    Searches a string up to a specified number of characters for a specific  
....................    character.  The string is searched forward and the first occurance  
....................    location is returned.  If the search character is not present in the  
....................    string, or if the maximum character count is reached first, then a NULL  
....................    pointer is returned. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    searchString - Pointer to a null terminated string to search.  If count is  
....................       less than the string size, then the string need not be null terminated. 
....................    count - Maximum number of characters to search before aborting. 
....................    c - Character to search for 
....................     
....................   Returns: 
....................    Pointer to the first occurance of the character c in the string  
....................    searchString.  If the character is not found or the maximum count is  
....................    reached, a NULL pointer is returned. 
....................   ***************************************************************************/ 
.................... char * strnchr(const char *searchString, size_t count, char c) 
.................... { 
....................    char c2; 
....................     
....................    while(count--) 
....................    { 
....................       c2  = *searchString++; 
....................       if(c2 == 0u) 
....................          return NULL; 
....................       if(c2 == c) 
....................          return (char*)--searchString; 
....................    } 
....................    return NULL; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    char* strncpy_m(char* destStr, size_t destSize, int nStrings, ...) 
....................  
....................   Summary: 
....................    Copies multiple strings to a destination 
....................  
....................   Description: 
....................    Copies multiple strings to a destination 
....................     but doesn't copy more than destSize characters. 
....................     Useful where the destination is actually an array and an extra \0 
....................     won't be appended to overflow the buffer 
....................      
....................   Precondition: 
....................    - valid string pointers 
....................     - destSize should be > 0 
....................  
....................   Parameters: 
....................    destStr - Pointer to a string to be initialized with the multiple strings provided as arguments. 
....................  
....................     destSize    - the maximum size of the destStr field, that cannot be exceeded. 
....................                   An \0 won't be appended if the resulting size is > destSize 
....................  
....................     nStrings    - number of string parameters to be copied into destStr 
....................  
....................     ...         - variable number of arguments 
....................      
....................     
....................   Returns: 
....................    Length of the destination string, terminating \0 (if exists) not included 
....................   ***************************************************************************/ 
.................... size_t strncpy_m(char* destStr, size_t destSize, int nStrings, ...) 
.................... { 
....................     va_list     args; 
....................     const char* str; 
....................     char*       end; 
....................     size_t      len; 
....................  
....................     destStr[0] = '\0'; 
....................     end = destStr + destSize - 1; 
....................     *end = '\0'; 
....................     len = 0; 
....................      
....................     va_start( args, nStrings ); 
....................      
....................     while(nStrings--) 
....................     { 
....................         if(*end) 
....................         {   // if already full don't calculate strlen outside the string area 
....................             len = destSize; 
....................             break; 
....................         } 
....................          
....................         str = va_arg(args, const char*); 
....................         strncpy(destStr + len, str, destSize - len); 
....................         len += strlen(str); 
....................     } 
....................  
....................     va_end( args ); 
....................      
....................     return len; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE ExtractURLFields(BYTE *vURL,  
....................                     PROTOCOLS *protocol,  
....................                     BYTE *vUsername, WORD *wUsernameLen,  
....................                     BYTE *vPassword, WORD *wPasswordLen,  
....................                     BYTE *vHostname, WORD *wHostnameLen,  
....................                     WORD *wPort,  
....................                     BYTE *vFilePath, WORD *wFilePathLen) 
....................  
....................   Summary: 
....................    Extracts all parameters from an URL string (ex:  
....................    "http://admin:passwd@www.microchip.com:8080/myfile.gif" is split into  
....................    {PROTOCOL_HTTP, "admin", "passwd", "www.microchip.com", 8080, "/myfile.gif"}. 
....................  
....................   Description: 
....................    Extracts all parameters from an URL string (ex:  
....................    "http://admin:passwd@www.microchip.com:8080/myfile.gif" is split into  
....................    {PROTOCOL_HTTP, "admin", "passwd", "www.microchip.com", 8080, "/myfile.gif"}. 
....................     
....................    The URL string can be null terminated, or alternatively could be terminated  
....................    by a carriage return or line feed. 
....................     
....................    If the protocol is unrecognized or the protocol is recognized but the URL  
....................    is malformed, than an error is safely returned.  For more information on  
....................    URL/URI interpretation see RFC 2396. 
....................  
....................   Precondition: 
....................    This function is commented out by default to save code space because  
....................    it is not used by any current stack features.  However, if you want to use  
....................    it, go ahead and uncomment it.  It has been tested, so it (should) work  
....................    correctly. 
....................  
....................   Parameters: 
....................    vURL -   Pointer to null terminated URL to decode and extract from.  This  
....................       parameter is required and needs to have the minimum RFC 1738 components  
....................       in it (protocol and hostname). 
....................        
....................    protocol - Optional pointer to a PROTOCOLS enum to retrieve the decoded  
....................       protocol type.  If this parameter is unneeded, specify a NULL pointer.   
....................       The protocol is a required part of the URL, so it must always be  
....................       present.  The protocol also determines what scheme all other parameters  
....................       are decoded using, so the function will fail if an unrecognized  
....................       protocol is provided.  The PROTOCOLS enum members show all of the  
....................       currently supported protocols for this function. 
....................        
....................       <p>For the example URL provided in the function description,  
....................       PROTOCOL_HTTP would be returned for this field. 
....................        
....................    vUsername - Optional pointer to a buffer to write the decoded username  
....................       portion of the URL.  If the URL does not contain a username or a NULL  
....................       pointer is supplied, then this field is ignored. 
....................  
....................       <p>For the example URL provided in the function description, "admin"  
....................       would be returned for this field. 
....................        
....................    wUsernameLen - 
....................       On call\: Optional pointer to a WORD specifying the maximum length of  
....................       the vUsername buffer, including the null terminator character. 
....................        
....................       <p>Upon return\: If wUsernameLen and vUsername are non-NULL, the  
....................       *wUsernameLen WORD is updated with the actual number of characters  
....................       written to the vUsername buffer, including the null terminator  
....................       character.  If vUsername is NULL but wUsernameLen is non-NULL, then no  
....................       characters are copied, but *wUsernameLen will return the number of  
....................       characters required to fit the full username string.  If wUsernameLen  
....................       is NULL, then the username field in the URL, if present, is ignored and  
....................       the vUsername pointer is not used. 
....................        
....................       <p>If zero characters were written, this indicates that the URL did not  
....................       contain a username field.  If one character was written, this indicates  
....................       that a username field was present, but was a zero character string  
....................       (ex\: ""). 
....................         
....................       <p>For the example URL provided in the function description, 6 (0x0006)  
....................       would be returned for this field. 
....................        
....................    vPassword - Optional pointer to a buffer to write the decoded password  
....................       portion of the URL.  If the URL does not contain a password or a NULL  
....................       pointer is supplied, then this field is ignored. 
....................  
....................       <p>For the example URL provided in the function description, "passwd"  
....................       would be returned for this field. 
....................        
....................    wPasswordLen - 
....................       On call\: Optional pointer to a WORD specifying the maximum length of  
....................       the vPassword buffer, including the null terminator character. 
....................        
....................       <p>Upon return\: If wPasswordLen and vPassword are non-NULL, the  
....................       *wPasswordLen WORD is updated with the actual number of characters  
....................       written to the vPassword buffer, including the null terminator  
....................       character.  If vPassword is NULL but wPasswordLen is non-NULL, then no  
....................       characters are copied, but *wPasswordLen will return the number of  
....................       characters required to fit the full password string.  If wPasswordLen  
....................       is NULL, then the password field in the URL, if present, is ignored and  
....................       the vPassword pointer is not used. 
....................        
....................       <p>If zero characters were written, this indicates that the URL did not  
....................       contain a password field.  If one character was written, this indicates  
....................       that a password field was present, but was a zero character string  
....................       (ex\: ""). 
....................         
....................       <p>For the example URL provided in the function description, 7 (0x0007)  
....................       would be returned for this field. 
....................        
....................    vHostname - Optional pointer to a buffer to write the decoded hostname  
....................       portion of the URL.  All Internet URLs must contain a hostname or IP  
....................       address, however, if a NULL pointer is supplied, then this field is  
....................       ignored. 
....................  
....................       <p>For the example URL provided in the function description,  
....................       "www.microchip.com" would be returned for this field.  If the URL was  
....................       "http://192.168.0.1", then this field would be returned as  
....................       "192.168.0.1".   The IP address would not be decoded to a DWORD (use the  
....................       StringToIPAddress() helper function to do this). 
....................        
....................    wHostnameLen - 
....................       On call\: Optional pointer to a WORD specifying the maximum length of  
....................       the vHostname buffer, including the null terminator character. 
....................        
....................       <p>Upon return\: If wHostnameLen and vHostname are non-NULL, the  
....................       *wHostnameLen WORD is updated with the actual number of characters  
....................       written to the vHostname buffer, including the null terminator  
....................       character.  If vHostname is NULL but wHostnameLen is non-NULL, then no  
....................       characters are copied, but *wHostnameLen will return the number of  
....................       characters required to fit the full hostname string.  If wHostnameLen  
....................       is NULL, then the hostname field in the URL, is ignored and the  
....................       vHostname pointer is not used. 
....................        
....................       <p>For the example URL provided in the function description,  
....................       18 (0x0012) would be returned for this field.  If the URL was  
....................       "http://192.168.0.1", then this field would be returned as 12 (0x000C). 
....................        
....................    wPort - Optional pointer to a WORD specifying the TCP or UDP port that the  
....................       server is listening on.  If the port field is absent from the URL, then  
....................       this parameter will specify the default port for the protocol.  For  
....................       example, "http://www.microchip.com" would result in 80 being return as  
....................       the specified port. 
....................         
....................       <p>If the wPort pointer is NULL, then the port field in the URL  
....................       is ignored, if present. 
....................        
....................    vFilePath - Optional pointer to a buffer to write the decoded file path  
....................       portion of the URL.  If a NULL pointer is supplied, then this field is  
....................       ignored.  If a file path is not present in the URL, then "/" will be  
....................       returned in this field.   
....................  
....................       <p>For the example URL provided in the function description,  
....................       "/myfile.gif" would be returned for this field. 
....................        
....................    wFilePathLen - 
....................       On call\: Optional pointer to a WORD specifying the maximum length of  
....................       the vFilePath buffer, including the null terminator character. 
....................        
....................       <p>Upon return\: If wFilePathLen and vFilePath are non-NULL, the  
....................       *wFilePathLen WORD is updated with the actual number of characters  
....................       written to the vFilePath buffer, including the null terminator  
....................       character.  If vFilePath is NULL but wFilePathLen is non-NULL, then no  
....................       characters are copied, but *wFilePathLen will return the number of  
....................       characters required to fit the full file path string.  If wFilePathLen  
....................       is NULL, then the file path field in the URL, if present, is ignored and  
....................       the vFilePath pointer is not used. 
....................        
....................       <p>This function always returns "/" if no file path is present, so 
....................       *wFilePathLen will also be at least 2 characters ('/' and null  
....................       terminator) if the pointer is non-NULL. 
....................     
....................       <p>For the example URL provided in the function description, 12 (0x000C)  
....................       would be returned for this field. 
....................        
....................   Returns: 
....................    Zero on success.  Nonzero indicates an error code.  If a nonzero error code  
....................    is returned, none of the returned buffers or pointer values should be  
....................    treated as valid, but some of them may have been written to.  The following  
....................    are all possible return values. 
....................    <table> 
....................       0   No error 
....................       1   Protocol unknown (additional code needs to be added to  
....................           ExtractURLFields() and the PROTOCOLS enum needs to be updated if  
....................           you want to decode URLs of this protocol type. 
....................       2   URL malformed. Illegal or unknown URL format encountered. 
....................       3   Buffer too small.  One of the input buffer sizes is too small to  
....................           contain the URL parameter. 
....................    </table> 
....................   ***************************************************************************/ 
.................... #if 0    
.................... BYTE ExtractURLFields(BYTE *vURL, PROTOCOLS *protocol, BYTE *vUsername, WORD *wUsernameLen, BYTE *vPassword, WORD *wPasswordLen, BYTE *vHostname, WORD *wHostnameLen, WORD *wPort, BYTE *vFilePath, WORD *wFilePathLen) 
.................... { 
....................    // These two arrays must exactly match up each other and the PROTOCOLS enum  
....................    // elements.  The protocol name strings must also be specified in all  
....................    // lowercase. 
....................    static ROM char * ROM   vProtocolNames[] = {"http", "https", "mms", "rtsp"}; 
....................    static ROM WORD       wProtocolPorts[] = { 80,     443,     1755,  554}; 
....................    WORD w, w2; 
....................    BYTE i, j; 
....................    PROTOCOLS prot; 
....................    BYTE *temp, *temp2; 
....................    WORD wURLLen; 
....................    WORD wLocalPort; 
....................     
....................     
....................    // Calculate how long this URL is 
....................    wURLLen = strlen((char*)vURL); 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, '\r'); 
....................    if(temp) 
....................       wURLLen = temp - vURL; 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, '\n'); 
....................    if(temp) 
....................       wURLLen = temp - vURL; 
....................     
....................  
....................    // Parse starting protocol field 
....................    // Find out how long the protocol name field is 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, ':'); 
....................    if(temp == NULL) 
....................       return 2; 
....................     
....................    // Search protocol list to see if this is a recognized protocol 
....................    for(prot = 0; (BYTE)prot < sizeof(wProtocolPorts)/sizeof(wProtocolPorts[0]); prot++) 
....................    { 
....................       w = strlenpgm(vProtocolNames[prot]); 
....................       if((WORD)(temp - vURL) == w) 
....................       { 
....................          w2 = 0; 
....................          temp2 = vURL; 
....................          while(w) 
....................          { 
....................             i = *temp2++; 
....................             if((i >= 'A') && (i <= 'Z')) 
....................                i += 'a' - 'A'; 
....................             if(i != (BYTE)vProtocolNames[prot][w2++]) 
....................                break; 
....................             w--; 
....................          } 
....................          if(w == 0u) 
....................          { 
....................             if(protocol) 
....................                *protocol = prot; 
....................             break; 
....................          } 
....................       } 
....................    } 
....................  
....................    // If we've search the whole list and didn't find a match, then  
....................    // this protocol is unknown and this URL cannot be parsed. 
....................    if((BYTE)prot >= sizeof(wProtocolPorts)/sizeof(wProtocolPorts[0])) 
....................       return 1; 
....................     
....................    w = temp - vURL + 1; 
....................    vURL += w; 
....................    wURLLen -= w; 
....................  
....................    // Protocols using the authority field all must have a double  
....................    // slash "//" prefix 
....................    if(wURLLen < 2u) 
....................       return 2; 
....................    for(j = 0; j < 2u; j++) 
....................    { 
....................       i = *vURL++; 
....................       if(i != '/') 
....................          return 2; 
....................    } 
....................    wURLLen -= 2; 
....................     
....................  
....................    // Parse username and password fields 
....................    // See if there is a @ sign, indicating that there is at  
....................    // least a username and possibly a password in this URL 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, '@'); 
....................    if(temp == NULL) 
....................    { 
....................       if(wUsernameLen) 
....................          *wUsernameLen = 0; 
....................       if(wPasswordLen) 
....................          *wPasswordLen = 0; 
....................    } 
....................    else 
....................    { 
....................       // If we get down here, there is a user name present, let's  
....................       // see if a password is also present by searching for a  
....................       // colon between the current string position and the @  
....................       // symbol. 
....................       temp2 = (BYTE*)strnchr((char*)vURL, temp - vURL, ':'); 
....................        
....................       // Calculate username length and password length, including  
....................       // null terminator (if the field exists) 
....................       if(temp2 == NULL) 
....................       { 
....................          w = temp - vURL + 1;   // Username 
....................          w2 = 0;               // Password 
....................       } 
....................       else 
....................       { 
....................          w = temp2 - vURL + 1;   // Username 
....................          w2 = temp - temp2;      // Password 
....................       } 
....................        
....................       if(wUsernameLen) 
....................       { 
....................          if(vUsername) 
....................          { 
....................             if(*wUsernameLen < w) 
....................                return 3; 
....................             memcpy((void*)vUsername, (void*)vURL, w - 1); 
....................             vUsername[w-1] = 0; 
....................          } 
....................          *wUsernameLen = w; 
....................       } 
....................     
....................       if(wPasswordLen) 
....................       { 
....................          if(vPassword) 
....................          { 
....................             if(*wPasswordLen < w2) 
....................                return 3; 
....................             if(w2) 
....................             { 
....................                memcpy((void*)vPassword, (void*)temp2+1, w2 - 1); 
....................                vPassword[w2-1] = 0; 
....................             } 
....................          } 
....................          *wPasswordLen = w2; 
....................       } 
....................     
....................       vURL += w; 
....................       wURLLen -= w; 
....................       if(w2) 
....................       { 
....................          vURL += w2; 
....................          wURLLen -= w2; 
....................       } 
....................    } 
....................  
....................  
....................    // Parse hostname field 
....................    // Find the length of the hostname, including NULL  
....................    // terminator 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, ':'); 
....................    temp2 = (BYTE*)strnchr((char*)vURL, wURLLen, '/'); 
....................    if(temp && temp2) 
....................    { 
....................       if(temp > temp2) 
....................          temp = NULL; 
....................    } 
....................    if(temp == NULL) 
....................    { 
....................       temp = temp2; 
....................       if(temp2 == NULL) 
....................          temp = vURL + wURLLen; 
....................    } 
....................    w = temp - vURL + 1; 
....................    if(wHostnameLen) 
....................    { 
....................       if(vHostname) 
....................       { 
....................          if(*wHostnameLen < w) 
....................             return 3; 
....................          memcpy((void*)vHostname, (void*)vURL, w - 1); 
....................          vHostname[w-1] = 0; 
....................       } 
....................       *wHostnameLen = w; 
....................    } 
....................    vURL += w - 1; 
....................    wURLLen -= w - 1; 
....................  
....................  
....................    // Parse port field 
....................    if(*vURL == ':') 
....................    { 
....................       vURL++; 
....................       wURLLen--; 
....................       wLocalPort = 0; 
....................       w = wURLLen; 
....................       temp = (BYTE*)strnchr((char*)vURL, wURLLen, '/'); 
....................       if(temp != NULL) 
....................          w = temp - vURL; 
....................       w2 = w; 
....................       if(wPort) 
....................       { 
....................          while(w--) 
....................          { 
....................             wLocalPort *= 10; 
....................             wLocalPort += *vURL++ - '0'; 
....................          } 
....................          *wPort = wLocalPort; 
....................       } 
....................       else 
....................          vURL += w2; 
....................       wURLLen -= w2; 
....................    } 
....................    else if(wPort) 
....................       *wPort = wProtocolPorts[prot]; 
....................  
....................  
....................    // Parse file path field 
....................    if(wFilePathLen) 
....................    { 
....................       w = ++wURLLen; 
....................       if(wURLLen == 1u) 
....................          w = 2; 
....................       if(vFilePath) 
....................       { 
....................          if(*wFilePathLen < w) 
....................             return 3; 
....................          if(wURLLen == 1u) 
....................             vFilePath[0] = '/'; 
....................          else 
....................             memcpy((void*)vFilePath, (void*)vURL, wURLLen - 1); 
....................          vFilePath[w - 1] = 0; 
....................          *wFilePathLen = w; 
....................          return 0; 
....................       } 
....................       *wFilePathLen = w; 
....................    } 
....................    return 0; 
.................... } 
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    SHORT Replace(BYTE *vExpression, ROM BYTE *vFind, ROM BYTE *vReplacement,  
....................               WORD wMaxLen, BOOL bSearchCaseInsensitive) 
....................  
....................   Summary: 
....................    Replaces all instances of a particular substring with a new string 
....................  
....................   Description: 
....................    Searches a string (vExpression) and replaces all instances of a particular  
....................    substring (vFind) with a new string (vReplacement).  The start offset to  
....................    being searching and a maximum number of replacements can be specified.  The  
....................    search can be performed in a case sensitive or case insensitive manner. 
....................  
....................   Precondition: 
....................    This function is commented out by default to save code space because  
....................    it is not used by any current stack features.  However, if you want to use  
....................    it, go ahead and uncomment it.  It has been tested, so it (should) work  
....................    correctly. 
....................  
....................   Parameters: 
....................    vExpression - Null terminated string to search and make replacements within. 
....................    vFind - Null terminated string to search for. 
....................    vReplacement - Null terminated string to replace all instances of vFind with. 
....................    wMaxLen - Maximum length of the output vExpression string if string  
....................       expansion is going to occur (replacement length is longer than find  
....................       length).  If the replacements will cause this maximum string length to  
....................       be exceeded, then no replacements will be made and a negative result  
....................       will be returned, indicating failure.  If the replacement length is  
....................       shorter or equal to the search length, then this parameter is ignored. 
....................    bSearchCaseInsensitive - Boolean indicating if the search should be  
....................       performed in a case insensitive manner.  Specify TRUE for case  
....................       insensitive searches (slower) or FALSE for case sensitive  
....................       searching (faster). 
....................  
....................   Remarks: 
....................    If the replacement string length is shorter than or equal to the search  
....................    string length and the search string occurs in multiple overlapping  
....................    locations (ex\: expression is "aaa", find is "aa", and replacement is "bb")  
....................    then the first find match occuring when searching from left to right will  
....................    be replaced.  (ex\: output expression will be "bba"). 
....................     
....................    However, if the replacement string length is longer than the search string  
....................    length, the search will occur starting from the end of the string and  
....................    proceed to the beginning (right to left searching).  In this case if the  
....................    expression was "aaa", find was "aa", and replacement was "bbb", then the  
....................    final output expression will be "abbb".   
....................  
....................   Returns: 
....................    If zero or greater, indicates the count of how many replacements were made.   
....................    If less than zero (negative result), indicates that wMaxLen was too small  
....................    to make the necessary replacements.  In this case, no replacements were  
....................    made. 
....................   ***************************************************************************/ 
.................... #if 0 
.................... SHORT Replace(BYTE *vExpression, ROM BYTE *vFind, ROM BYTE *vReplacement, WORD wMaxLen, BOOL bSearchCaseInsensitive) 
.................... { 
....................    WORD wExpressionLen, wFindLen, wFindLenMinusOne, wReplacementLen; 
....................    WORD wFindCount, wReplacementsLeft; 
....................    BYTE i, j; 
....................    BYTE vFirstFindChar; 
....................    WORD wBytesLeft; 
....................    BYTE *vDest; 
....................    BYTE *vExpressionCompare; 
....................    ROM BYTE *vFindCompare; 
....................    WORD w; 
....................  
....................    wFindLen = strlenpgm((ROM char*)vFind); 
....................    if(wFindLen == 0u) 
....................       return 0; 
....................     
....................    wExpressionLen = strlen((char*)vExpression); 
....................    wReplacementLen = strlenpgm((ROM char*)vReplacement); 
....................  
....................    wFindCount = 0; 
....................    wFindLenMinusOne = wFindLen - 1; 
....................    vFirstFindChar = *vFind++; 
....................    if(bSearchCaseInsensitive)   // Convert to all lowercase if needed 
....................       if((vFirstFindChar >= (BYTE)'A') && (vFirstFindChar <= (BYTE)'Z')) 
....................          vFirstFindChar += 'a' - 'A'; 
....................  
....................    // If the replacement string is the same length as the search string, then  
....................    // we can immediately do the needed replacements inline and return. 
....................    if(wFindLen == wReplacementLen) 
....................    { 
....................       for(wBytesLeft = wExpressionLen; wBytesLeft; wBytesLeft--) 
....................       { 
....................          i = *vExpression++; 
....................          if(bSearchCaseInsensitive) 
....................          { 
....................             if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                i += 'a' - 'A'; 
....................             if(i != vFirstFindChar) 
....................                continue; 
....................             vExpressionCompare = vExpression; 
....................             vFindCompare = vFind; 
....................             w = wFindLenMinusOne; 
....................             while(w) 
....................             { 
....................                i = *vExpressionCompare++; 
....................                j = *vFindCompare++; 
....................                if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                   i += 'a' - 'A'; 
....................                if((j >= (BYTE)'A') && (j <= (BYTE)'Z')) 
....................                   j += 'a' - 'A'; 
....................                if(i != j) 
....................                   break; 
....................                w--; 
....................             } 
....................             if(w) 
....................                continue; 
....................          } 
....................          else 
....................          { 
....................             if(i != vFirstFindChar) 
....................                continue; 
....................             if(memcmppgm2ram((void*)vExpression, (ROM void*)vFind, wFindLenMinusOne)) 
....................                continue; 
....................          } 
....................     
....................          memcpypgm2ram((void*)vExpression-1, (ROM void*)vReplacement, wReplacementLen); 
....................          wFindCount++; 
....................          vExpression += wFindLenMinusOne; 
....................          wBytesLeft -= wFindLenMinusOne; 
....................       } 
....................       return wFindCount; 
....................    } 
....................     
....................     
....................    // If the replacement string is shorter than the search string, then we can  
....................    // search from left to right and move the string over as we find occurrences. 
....................    if(wFindLen > wReplacementLen) 
....................    { 
....................       vDest = vExpression; 
....................       for(wBytesLeft = wExpressionLen; wBytesLeft; wBytesLeft--) 
....................       { 
....................          i = *vExpression++; 
....................          *vDest++ = i; 
....................          if(bSearchCaseInsensitive) 
....................          { 
....................             if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                i += 'a' - 'A'; 
....................             if(i != vFirstFindChar) 
....................                continue; 
....................             vExpressionCompare = vExpression; 
....................             vFindCompare = vFind; 
....................             w = wFindLenMinusOne; 
....................             while(w) 
....................             { 
....................                i = *vExpressionCompare++; 
....................                j = *vFindCompare++; 
....................                if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                   i += 'a' - 'A'; 
....................                if((j >= (BYTE)'A') && (j <= (BYTE)'Z')) 
....................                   j += 'a' - 'A'; 
....................                if(i != j) 
....................                   break; 
....................                w--; 
....................             } 
....................             if(w) 
....................                continue; 
....................          } 
....................          else 
....................          { 
....................             if(i != vFirstFindChar) 
....................                continue; 
....................             if(memcmppgm2ram((void*)vExpression, (ROM void*)vFind, wFindLenMinusOne)) 
....................                continue; 
....................          } 
....................     
....................          memcpypgm2ram((void*)vDest-1, (ROM void*)vReplacement, wReplacementLen); 
....................          vDest += wReplacementLen-1; 
....................          wFindCount++; 
....................          vExpression += wFindLenMinusOne; 
....................          wBytesLeft -= wFindLenMinusOne; 
....................       } 
....................       *vDest = 0x00;   // Write new null terminator since the string may have shrunk 
....................       return wFindCount; 
....................    } 
....................     
....................    // If the replacement string is longer than the search string, then we will  
....................    // take a two pass approach.  On the first pass, we will merely count how  
....................    // many replacements to make.  With this we can calculate how long the  
....................    // final string is going to be.  On the second pass, we will search from  
....................    // right to left and expand the string as needed. 
....................  
....................    // Pass 1: count how many occurrences of vFind are in vExpression 
....................    for(wBytesLeft = wExpressionLen; wBytesLeft; wBytesLeft--) 
....................    { 
....................       i = *vExpression++; 
....................       if(bSearchCaseInsensitive) 
....................       { 
....................          if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................             i += 'a' - 'A'; 
....................          if(i != vFirstFindChar) 
....................             continue; 
....................          vExpressionCompare = vExpression; 
....................          vFindCompare = vFind; 
....................          w = wFindLenMinusOne; 
....................          while(w) 
....................          { 
....................             i = *vExpressionCompare++; 
....................             j = *vFindCompare++; 
....................             if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                i += 'a' - 'A'; 
....................             if((j >= (BYTE)'A') && (j <= (BYTE)'Z')) 
....................                j += 'a' - 'A'; 
....................             if(i != j) 
....................                break; 
....................             w--; 
....................          } 
....................          if(w) 
....................             continue; 
....................       } 
....................       else 
....................       { 
....................          if(i != vFirstFindChar) 
....................             continue; 
....................          if(memcmppgm2ram((void*)vExpression, (ROM void*)vFind, wFindLenMinusOne)) 
....................             continue; 
....................       } 
....................  
....................       wFindCount++; 
....................       vExpression += wFindLenMinusOne; 
....................       wBytesLeft -= wFindLenMinusOne; 
....................    } 
....................     
....................    // Return immediately if no replacements are needed 
....................    if(wFindCount == 0u) 
....................       return 0; 
....................  
....................    // Pass 2: make replacements and move string over 
....................    vDest = vExpression + wFindCount * (wReplacementLen - wFindLen); 
....................    if(vDest > vExpression - wExpressionLen + wMaxLen) 
....................       return -1; 
....................    *vDest-- = 0x00;   // Write new null terminator 
....................    vExpression -= 1; 
....................    vFind -= 1; 
....................    vFirstFindChar = vFind[wFindLenMinusOne]; 
....................    if(bSearchCaseInsensitive)   // Convert to all lowercase if needed 
....................       if((vFirstFindChar >= (BYTE)'A') && (vFirstFindChar <= (BYTE)'Z')) 
....................          vFirstFindChar += 'a' - 'A'; 
....................    wReplacementsLeft = wFindCount; 
....................    while(wReplacementsLeft) 
....................    { 
....................       i = *vExpression--; 
....................       *vDest-- = i; 
....................       if(bSearchCaseInsensitive) 
....................       { 
....................          if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................             i += 'a' - 'A'; 
....................          if(i != vFirstFindChar) 
....................             continue; 
....................          vExpressionCompare = vExpression; 
....................          vFindCompare = &vFind[wFindLenMinusOne-1]; 
....................          w = wFindLenMinusOne; 
....................          while(w) 
....................          { 
....................             i = *vExpressionCompare--; 
....................             j = *vFindCompare--; 
....................             if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                i += 'a' - 'A'; 
....................             if((j >= (BYTE)'A') && (j <= (BYTE)'Z')) 
....................                j += 'a' - 'A'; 
....................             if(i != j) 
....................                break; 
....................             w--; 
....................          } 
....................          if(w) 
....................             continue; 
....................       } 
....................       else 
....................       { 
....................          if(i != vFirstFindChar) 
....................             continue; 
....................          if(memcmppgm2ram((void*)vExpression-wFindLenMinusOne, (ROM void*)vFind, wFindLenMinusOne)) 
....................             continue; 
....................       } 
....................       memcpypgm2ram((void*)vDest-wReplacementLen+2, (ROM void*)vReplacement, wReplacementLen); 
....................       vDest -= wReplacementLen-1; 
....................  
....................       vExpression -= wFindLenMinusOne; 
....................       wBytesLeft -= wFindLenMinusOne; 
....................       wReplacementsLeft--; 
....................    } 
....................    return wFindCount; 
.................... } 
.................... #endif 
....................  
.................... //#include "Delay.c" //not needed, we overrode this in StackTsk2.h 
.................... #include "Tick.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for Timekeeping 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.c 
....................  * Dependencies:    Timer 0 (PIC18) or Timer 1 (PIC24F, PIC24H,  
....................  *					dsPIC30F, dsPIC33F, PIC32) 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.10b or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder		6/13/07		Changed to use timer without  
....................  *									writing for perfect accuracy. 
.................... ********************************************************************/ 
.................... #define __TICK_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... // Internal counter to store Ticks.  This variable is incremented in an ISR and  
.................... // therefore must be marked volatile to prevent the compiler optimizer from  
.................... // reordering code to use this value in the main context while interrupts are  
.................... // disabled. 
.................... static volatile DWORD dwInternalTicks = 0; 
....................  
.................... // 6-byte value to store Ticks.  Allows for use over longer periods of time. 
.................... static BYTE vTickReading[6]; 
....................  
.................... static void GetTickCopy(void); 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	void TickInit(void) 
....................  
....................   Summary: 
.................... 	Initializes the Tick manager module. 
....................  
....................   Description: 
.................... 	Configures the Tick module and any necessary hardware resources. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	None 
....................   	 
....................   Remarks: 
.................... 	This function is called only one during lifetime of the application. 
....................   ***************************************************************************/ 
.................... void TickInit(void) 
.................... { 
.................... #if defined(__18CXX) 
.................... 	// Use Timer0 for 8 bit processors 
....................     // Initialize the time 
....................     TMR0H = 0; 
*
0021C:  CLRF   FD7
....................     TMR0L = 0; 
0021E:  CLRF   FD6
....................  
.................... 	// Set up the timer interrupt 
.................... 	INTCON2bits.TMR0IP = 0;		// Low priority 
00220:  BCF    FF1.2
....................     INTCONbits.TMR0IF = 0; 
00222:  BCF    FF2.2
....................     INTCONbits.TMR0IE = 1;		// Enable interrupt 
00224:  BSF    FF2.5
....................  
....................     // Timer0 on, 16-bit, internal timer, 1:256 prescalar 
....................     T0CON = 0x87; 
00226:  MOVLW  87
00228:  MOVWF  FD5
....................  
.................... #else 
0022A:  GOTO   0236 (RETURN)
.................... 	// Use Timer 1 for 16-bit and 32-bit processors 
.................... 	// 1:256 prescale 
.................... 	T1CONbits.TCKPS = 3; 
.................... 	// Base 
.................... 	PR1 = 0xFFFF; 
.................... 	// Clear counter 
.................... 	TMR1 = 0; 
....................  
.................... 	// Enable timer interrupt 
.................... 	#if defined(__C30__) 
.................... 		IPC0bits.T1IP = 2;	// Interrupt priority 2 (low) 
.................... 		IFS0bits.T1IF = 0; 
.................... 		IEC0bits.T1IE = 1; 
.................... 	#else 
.................... 		IPC1bits.T1IP = 2;	// Interrupt priority 2 (low) 
.................... 		IFS0CLR = _IFS0_T1IF_MASK; 
.................... 		IEC0SET = _IEC0_T1IE_MASK; 
.................... 	#endif 
....................  
.................... 	// Start timer 
.................... 	T1CONbits.TON = 1; 
.................... #endif 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	static void GetTickCopy(void) 
....................  
....................   Summary: 
.................... 	Reads the tick value. 
....................  
....................   Description: 
.................... 	This function performs an interrupt-safe and synchronized read of the  
.................... 	48-bit Tick value. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	None 
....................   ***************************************************************************/ 
.................... static void GetTickCopy(void) 
.................... { 
.................... 	// Perform an Interrupt safe and synchronized read of the 48-bit  
.................... 	// tick value 
.................... #if defined(__18CXX) 
.................... 	do 
.................... 	{ 
.................... 		INTCONbits.TMR0IE = 1;		// Enable interrupt 
*
016B4:  BSF    FF2.5
.................... 		Nop(); 
016B6:  NOP   
.................... 		INTCONbits.TMR0IE = 0;		// Disable interrupt 
016B8:  BCF    FF2.5
.................... 		vTickReading[0] = TMR0L; 
016BA:  MOVFF  FD6,11A
.................... 		vTickReading[1] = TMR0H; 
016BE:  MOVFF  FD7,11B
.................... 		*((DWORD*)&vTickReading[2]) = dwInternalTicks; 
016C2:  MOVLW  01
016C4:  MOVLB  2
016C6:  MOVWF  xC2
016C8:  MOVLW  1C
016CA:  MOVWF  FE9
016CC:  MOVFF  2C2,FEA
016D0:  MOVFF  116,FEF
016D4:  MOVFF  117,FEC
016D8:  MOVFF  118,FEC
016DC:  MOVFF  119,FEC
.................... 	} while(INTCONbits.TMR0IF); 
016E0:  BTFSS  FF2.2
016E2:  BRA    16E8
016E4:  MOVLB  0
016E6:  BRA    16B4
.................... 	INTCONbits.TMR0IE = 1;			// Enable interrupt 
016E8:  BSF    FF2.5
.................... #elif defined(__C30__) 
016EA:  MOVLB  0
016EC:  RETURN 0
.................... 	do 
.................... 	{ 
.................... 		DWORD dwTempTicks; 
.................... 		 
.................... 		IEC0bits.T1IE = 1;			// Enable interrupt 
.................... 		Nop(); 
.................... 		IEC0bits.T1IE = 0;			// Disable interrupt 
....................  
.................... 		// Get low 2 bytes 
.................... 		((WORD*)vTickReading)[0] = TMR1; 
.................... 		 
.................... 		// Correct corner case where interrupt increments byte[4+] but  
.................... 		// TMR1 hasn't rolled over to 0x0000 yet 
.................... 		dwTempTicks = dwInternalTicks; 
.................... 		if(((WORD*)vTickReading)[0] == 0xFFFFu) 
.................... 			dwTempTicks--; 
.................... 		 
.................... 		// Get high 4 bytes 
.................... 		vTickReading[2] = ((BYTE*)&dwTempTicks)[0]; 
.................... 		vTickReading[3] = ((BYTE*)&dwTempTicks)[1]; 
.................... 		vTickReading[4] = ((BYTE*)&dwTempTicks)[2]; 
.................... 		vTickReading[5] = ((BYTE*)&dwTempTicks)[3]; 
.................... 	} while(IFS0bits.T1IF); 
.................... 	IEC0bits.T1IE = 1;				// Enable interrupt 
.................... #else	// PIC32 
.................... 	do 
.................... 	{ 
.................... 		DWORD dwTempTicks; 
.................... 		 
.................... 		IEC0SET = _IEC0_T1IE_MASK;	// Enable interrupt 
.................... 		Nop(); 
.................... 		IEC0CLR = _IEC0_T1IE_MASK;	// Disable interrupt 
.................... 		 
.................... 		// Get low 2 bytes 
.................... 		((volatile WORD*)vTickReading)[0] = TMR1; 
.................... 		 
.................... 		// Correct corner case where interrupt increments byte[4+] but  
.................... 		// TMR1 hasn't rolled over to 0x0000 yet 
.................... 		dwTempTicks = dwInternalTicks; 
....................  
.................... 		// PIC32MX3XX/4XX devices trigger the timer interrupt when TMR1 == PR1  
.................... 		// (TMR1 prescalar is 0x00), requiring us to undo the ISR's increment  
.................... 		// of the upper 32 bits of our 48 bit timer in the special case when  
.................... 		// TMR1 == PR1 == 0xFFFF.  For other PIC32 families, the ISR is  
.................... 		// triggered when TMR1 increments from PR1 to 0x0000, making no special  
.................... 		// corner case. 
.................... 		#if __PIC32_FEATURE_SET__ <= 460 
.................... 			if(((WORD*)vTickReading)[0] == 0xFFFFu) 
.................... 				dwTempTicks--; 
.................... 		#elif !defined(__PIC32_FEATURE_SET__) 
.................... 			#error __PIC32_FEATURE_SET__ macro must be defined.  You need to download a newer C32 compiler version. 
.................... 		#endif 
.................... 		 
.................... 		// Get high 4 bytes 
.................... 		vTickReading[2] = ((BYTE*)&dwTempTicks)[0]; 
.................... 		vTickReading[3] = ((BYTE*)&dwTempTicks)[1]; 
.................... 		vTickReading[4] = ((BYTE*)&dwTempTicks)[2]; 
.................... 		vTickReading[5] = ((BYTE*)&dwTempTicks)[3]; 
.................... 	} while(IFS0bits.T1IF); 
.................... 	IEC0SET = _IEC0_T1IE_MASK;		// Enable interrupt 
.................... #endif 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	DWORD TickGet(void) 
....................  
....................   Summary: 
.................... 	Obtains the current Tick value. 
....................  
....................   Description: 
.................... 	This function retrieves the current Tick value, allowing timing and 
.................... 	measurement code to be written in a non-blocking fashion.  This function 
.................... 	retrieves the least significant 32 bits of the internal tick counter,  
.................... 	and is useful for measuring time increments ranging from a few  
.................... 	microseconds to a few hours.  Use TickGetDiv256 or TickGetDiv64K for 
.................... 	longer periods of time. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	Lower 32 bits of the current Tick value. 
....................   ***************************************************************************/ 
.................... DWORD TickGet(void) 
.................... { 
.................... 	GetTickCopy(); 
*
01734:  RCALL  16B4
.................... 	return *((DWORD*)&vTickReading[0]); 
01736:  MOVLW  01
01738:  MOVLB  2
0173A:  MOVWF  xC2
0173C:  MOVLW  1A
0173E:  MOVFF  2C2,03
01742:  MOVWF  FE9
01744:  MOVFF  2C2,FEA
01748:  MOVFF  FEF,00
0174C:  MOVFF  FEC,01
01750:  MOVFF  FEC,02
01754:  MOVFF  FEC,03
01758:  MOVLB  0
0175A:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	DWORD TickGetDiv256(void) 
....................  
....................   Summary: 
.................... 	Obtains the current Tick value divided by 256. 
....................  
....................   Description: 
.................... 	This function retrieves the current Tick value, allowing timing and 
.................... 	measurement code to be written in a non-blocking fashion.  This function 
.................... 	retrieves the middle 32 bits of the internal tick counter,  
.................... 	and is useful for measuring time increments ranging from a few  
.................... 	minutes to a few weeks.  Use TickGet for shorter periods or TickGetDiv64K 
.................... 	for longer ones. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	Middle 32 bits of the current Tick value. 
....................   ***************************************************************************/ 
.................... DWORD TickGetDiv256(void) 
.................... { 
.................... 	DWORD dw; 
....................  
.................... 	GetTickCopy(); 
*
016EE:  RCALL  16B4
.................... 	((BYTE*)&dw)[0] = vTickReading[1];	// Note: This copy must be done one  
016F0:  MOVFF  11B,297
.................... 	((BYTE*)&dw)[1] = vTickReading[2];	// byte at a time to prevent misaligned  
016F4:  MOVFF  11C,298
.................... 	((BYTE*)&dw)[2] = vTickReading[3];	// memory reads, which will reset the PIC. 
016F8:  MOVFF  11D,299
.................... 	((BYTE*)&dw)[3] = vTickReading[4]; 
016FC:  MOVFF  11E,29A
.................... 	 
.................... 	return dw; 
01700:  MOVFF  297,00
01704:  MOVFF  298,01
01708:  MOVFF  299,02
0170C:  MOVFF  29A,03
01710:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	DWORD TickGetDiv64K(void) 
....................  
....................   Summary: 
.................... 	Obtains the current Tick value divided by 64K. 
....................  
....................   Description: 
.................... 	This function retrieves the current Tick value, allowing timing and 
.................... 	measurement code to be written in a non-blocking fashion.  This function 
.................... 	retrieves the most significant 32 bits of the internal tick counter,  
.................... 	and is useful for measuring time increments ranging from a few  
.................... 	days to a few years, or for absolute time measurements.  Use TickGet or 
.................... 	TickGetDiv256 for shorter periods of time. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	Upper 32 bits of the current Tick value. 
....................   ***************************************************************************/ 
.................... DWORD TickGetDiv64K(void) 
.................... { 
.................... 	DWORD dw; 
....................  
.................... 	GetTickCopy(); 
.................... 	((BYTE*)&dw)[0] = vTickReading[2];	// Note: This copy must be done one  
.................... 	((BYTE*)&dw)[1] = vTickReading[3];	// byte at a time to prevent misaligned  
.................... 	((BYTE*)&dw)[2] = vTickReading[4];	// memory reads, which will reset the PIC. 
.................... 	((BYTE*)&dw)[3] = vTickReading[5]; 
.................... 	 
.................... 	return dw; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	DWORD TickConvertToMilliseconds(DWORD dwTickValue) 
....................  
....................   Summary: 
.................... 	Converts a Tick value or difference to milliseconds. 
....................  
....................   Description: 
.................... 	This function converts a Tick value or difference to milliseconds.  For 
.................... 	example, TickConvertToMilliseconds(32768) returns 1000 when a 32.768kHz  
.................... 	clock with no prescaler drives the Tick module interrupt. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	dwTickValue	- Value to convert to milliseconds 
....................  
....................   Returns: 
....................   	Input value expressed in milliseconds. 
....................  
....................   Remarks: 
.................... 	This function performs division on DWORDs, which is slow.  Avoid using 
.................... 	it unless you absolutely must (such as displaying data to a user).  For 
.................... 	timeout comparisons, compare the current value to a multiple or fraction  
.................... 	of TICK_SECOND, which will be calculated only once at compile time. 
....................   ***************************************************************************/ 
.................... DWORD TickConvertToMilliseconds(DWORD dwTickValue) 
.................... { 
.................... 	return (dwTickValue+(TICKS_PER_SECOND/2000ul))/((DWORD)(TICKS_PER_SECOND/1000ul)); 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	void TickUpdate(void) 
....................  
....................   Description: 
.................... 	Updates the tick value when an interrupt occurs. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	None 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... void TickUpdate(void) 
.................... { 
....................     if(INTCONbits.TMR0IF) 
*
00096:  BTFSS  FF2.2
00098:  BRA    00AE
....................     { 
.................... 		// Increment internal high tick counter 
.................... 		dwInternalTicks++; 
0009A:  MOVLW  01
0009C:  MOVLB  1
0009E:  ADDWF  x16,F
000A0:  BTFSC  FD8.0
000A2:  INCF   x17,F
000A4:  BTFSC  FD8.2
000A6:  INCF   x18,F
000A8:  BTFSC  FD8.2
000AA:  INCF   x19,F
....................  
.................... 		// Reset interrupt flag 
....................         INTCONbits.TMR0IF = 0; 
000AC:  BCF    FF2.2
000AE:  MOVLB  0
....................     } 
000B0:  GOTO   00B6 (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	void _ISR _T1Interrupt(void) 
....................  
....................   Description: 
.................... 	Updates the tick value when an interrupt occurs. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	None 
....................   ***************************************************************************/ 
.................... #elif defined(__PIC32MX__) 
.................... void __attribute((interrupt(ipl2), vector(_TIMER_1_VECTOR), nomips16)) _T1Interrupt(void) 
.................... { 
.................... 	// Increment internal high tick counter 
.................... 	dwInternalTicks++; 
....................  
.................... 	// Reset interrupt flag 
.................... 	IFS0CLR = _IFS0_T1IF_MASK; 
.................... } 
.................... #else 
.................... #if defined(__PCD__)  //__CCS__ __PCH__ __PCD__ ccs added 
.................... #int_timer1 NOCLEAR 
.................... void _T1Interrupt(void) 
.................... #elif __C30_VERSION__ >= 300 
.................... void _ISR __attribute__((__no_auto_psv__)) _T1Interrupt(void) 
.................... #else 
.................... void _ISR _T1Interrupt(void) 
.................... #endif 
.................... { 
.................... 	// Increment internal high tick counter 
.................... 	dwInternalTicks++; 
....................  
.................... 	// Reset interrupt flag 
.................... 	IFS0bits.T1IF = 0; 
.................... } 
.................... #endif 
....................  
.................... #if !defined(ENC_CS_TRIS) && !defined(WF_CS_TRIS) && !defined(ENC100_INTERFACE_MODE) && \ 
....................     (defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) || \ 
....................      defined(_18F97J60) ||  defined(_18F96J65) ||  defined(_18F96J60) ||  defined(_18F87J60) ||  defined(_18F86J65) ||  defined(_18F86J60) ||  defined(_18F67J60) ||  defined(_18F66J65) ||  defined(_18F66J60)) 
....................    #include "ETH97J60.c" 
.................... #elif defined(WF_CS_TRIS) 
....................       #include "WF_Config.c" 
....................       #if defined(WF_USE_SCAN_FUNCTIONS) 
....................          #include "WFScan.c" 
....................       #endif 
....................       #if defined(WF_USE_POWER_SAVE_FUNCTIONS) 
....................          #include "WFPowerSave.c" 
....................       #else 
....................          BOOL GetAppPowerSaveMode(void) {return(TRUE);} 
....................       #endif 
....................       #if defined(WF_USE_TX_POWER_CONTROL_FUNCTIONS) 
....................          #include "WFTxPower.c" 
....................       #endif 
....................       #include "WF_Spi.c" 
....................       #include "WF_Eint.c" 
....................       #include "WFConnectionProfile.c" 
....................       #include "WFConnectionAlgorithm.c" 
....................       #include "WFConnectionManager.c" 
....................       #include "WFEventHandler.c" 
....................       #include "WFInit.c" 
....................      #if defined(MRF24WG) 
....................       #include "WFDriverCom_24G.c" 
....................       #include "WFDriverRaw_24G.c" 
....................       #include "WFMac_24G.c" 
....................       #include "WFMgmtMsg_24G.c" 
....................       #include "WFParamMsg_24G.c"      
....................      #else 
....................       #include "WFDriverCom.c" 
....................       #include "WFDriverRaw.c" 
....................       #include "WFMac.c" 
....................       #include "WFMgmtMsg.c" 
....................       #include "WFParamMsg.c" 
....................      #endif 
.................... #elif defined(ENC_CS_TRIS) 
....................    #include "tcpip\ENC28J60.c" 
.................... /********************************************************************* 
....................  * 
....................  *  Medium Access Control (MAC) Layer for Microchip ENC28J60 
....................  *  Module for Microchip TCP/IP Stack 
....................  *   -Provides access to ENC28J60 Ethernet controller 
....................  *   -Reference: ENC28J60 Data sheet, IEEE 802.3 Standard 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.c 
....................  * Dependencies:    ENC28J60.h 
....................  *                  MAC.h 
....................  *                  string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  Delay.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder     6/28/04 Original 
....................  * Howard Schlunder     10/8/04 Cleanup 
....................  * Howard Schlunder     10/19/04 Small optimizations and more cleanup 
....................  * Howard Schlunder     11/29/04 Added Set/GetCLKOUT 
....................  * Howard Schlunder     12/23/05 Added B1 silicon errata workarounds 
....................  * Howard Schlunder     1/09/06 Added comments and minor mods 
....................  * Howard Schlunder     1/18/06 Added more silicon errata workarounds 
....................  * Howard Schlunder     6/16/06 Synchronized with PIC18F97J60 code 
....................  * Howard Schlunder     7/17/06 Updated TestMemory() for C30 
....................  * Howard Schlunder     8/07/06 Added SetRXHashTableEntry() function 
.................... ********************************************************************/ 
.................... #define __ENC28J60_C 
....................  
.................... #include "HardwareProfile.h" 
.................... // hardwareprofile.h 
....................  
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #if STACK_USE_CCS_EWLWIFIB || STACK_USE_CCS_EWLWIFIG 
....................  
....................    #bit WF_CS_TRIS1   =     0xF96.1 //E1 
....................    #define WF_CS_TRIS WF_CS_TRIS1 
....................    #bit WF_CS_IO     =  0xF8D.1    //LatE1 
....................    #bit WF_SDI_TRIS  =  0xF94.4    // (TRISCbits.TRISC4) 
....................    #bit WF_SCK_TRIS  =  0xF94.3    // (TRISCbits.TRISC3) 
....................    #bit WF_SDO_TRIS  =  0xF94.5    // (TRISCbits.TRISC5) 
....................    #bit WF_RESET_TRIS=  0xF93.1    //(TRISBbits.TRISB1) 
....................    #bit WF_RESET_IO  =  0xF8A.1     //(LATBbits.LATB1)   
....................    #bit WF_INT_TRIS  =  0xF93.0     // (TRISBbits.TRISB0)  // INT1 
....................    #bit WF_INT_IO    =  0xF81.0   //(PORTBbits.RB0)  
....................    #bit WF_HIBERNATE_TRIS= 0xF93.2  //(TRISBbits.TRISB2)  
....................    #bit   WF_HIBERNATE_IO=  0xF81.2    //(PORTBbits.RB2) 
....................     
....................    #bit WF_INT_EDGE  =  0xFF1.6      //(INTCON2bits.INTEDG0) 
....................    #bit WF_INT_IE    =  0xFF2.4   //(INTCONbits.INT0IE) 
....................    #bit WF_INT_IF    =  0xFF2.1   //(INTCONbits.INT0IF) 
....................    #define WF_SSPBUF  (SSP1BUF) 
....................    #define WF_SPISTAT  (SSP1STATbits) 
....................    #define WF_SPISTATbits SSP1STATbits     //(SSP1STATbits) 
....................    #define WF_SPICON1  (SSP1CON1bits) 
....................    #define WF_SPICON1bits WF_SPICON1    // (SSP1CON1bits) 
....................    #define WF_SPICON2  (SSP1CON2bits) 
....................    #bit WF_SPI_IE    =   0xF9D.3  //(PIE1bits.SSPIE) 
....................    #bit WF_SPI_IP    =   0xF9F.3  //(IPR1bits.SSPIP) 
....................    #bit WF_SPI_IF    =   0xF9E.3  //(PIR1bits.SSPIF) 
....................     
.................... #else 
....................  
.................... //#error define necessary hardware for TCPIP stack 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... // Make sure that this hardware profile has an ENC28J60 in it 
.................... #if defined(ENC_CS_TRIS) 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... /** D E F I N I T I O N S ****************************************************/ 
.................... // IMPORTANT SPI NOTE: The code in this file expects that the SPI interrupt 
.................... //      flag (ENC_SPI_IF) be clear at all times.  If the SPI is shared with 
.................... //      other hardware, the other code should clear the ENC_SPI_IF when it is 
.................... //      done using the SPI. 
....................  
.................... // Since the ENC28J60 doesn't support auto-negotiation, full-duplex mode is 
.................... // not compatible with most switches/routers.  If a dedicated network is used 
.................... // where the duplex of the remote node can be manually configured, you may 
.................... // change this configuration.  Otherwise, half duplex should always be used. 
.................... #define HALF_DUPLEX 
.................... //#define FULL_DUPLEX 
.................... //#define LEDB_DUPLEX 
....................  
.................... // Pseudo Functions 
.................... #define LOW(a)                  ((a) & 0xFF) 
.................... #define HIGH(a)                 (((a)>>8) & 0xFF) 
....................  
.................... // ENC28J60 Opcodes (to be ORed with a 5 bit address) 
.................... #define WCR (0x2<<5)            // Write Control Register command 
.................... #define BFS (0x4<<5)            // Bit Field Set command 
.................... #define BFC (0x5<<5)            // Bit Field Clear command 
.................... #define RCR (0x0<<5)            // Read Control Register command 
.................... #define RBM ((0x1<<5) | 0x1A)   // Read Buffer Memory command 
.................... #define WBM ((0x3<<5) | 0x1A)   // Write Buffer Memory command 
.................... #define SR  ((0x7<<5) | 0x1F)   // System Reset command does not use an address. 
....................                                 //   It requires 0x1F, however. 
....................  
.................... // Maximum SPI frequency specified in data sheet 
.................... #define ENC_MAX_SPI_FREQ    (20000000ul)    // Hz 
....................  
.................... #define ETHER_IP    (0x00u) 
.................... #define ETHER_ARP   (0x06u) 
....................  
.................... // A header appended at the start of all RX frames by the hardware 
.................... #if defined(__CCS__) 
.................... typedef struct  __attribute__((packed)) 
.................... #else 
.................... typedef struct  __attribute__((aligned(2), packed)) 
.................... #endif 
.................... { 
....................     WORD            NextPacketPointer; 
....................     RXSTATUS        StatusVector; 
....................  
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ENC_PREAMBLE; 
....................  
....................  
.................... #if defined (__18CXX) 
....................     #define ClearSPIDoneFlag()  {ENC_SPI_IF = 0;} 
....................     #define WaitForDataByte()   {while(!ENC_SPI_IF); ENC_SPI_IF = 0;} 
....................     #define SPI_ON_BIT          (ENC_SPICON1bits.SSPEN) 
.................... #elif defined(__C30__) 
....................     #define ClearSPIDoneFlag() 
....................     static inline __attribute__((__always_inline__)) void WaitForDataByte( void ) 
....................     { 
....................         while ((ENC_SPISTATbits.SPITBF == 1) || (ENC_SPISTATbits.SPIRBF == 0)); 
....................     } 
....................  
....................     #define SPI_ON_BIT          (ENC_SPISTATbits.SPIEN) 
.................... #elif defined( __PIC32MX__ ) 
....................     #define ClearSPIDoneFlag() 
....................     static inline __attribute__((__always_inline__)) void WaitForDataByte( void ) 
....................     { 
....................         while (!ENC_SPISTATbits.SPITBE || !ENC_SPISTATbits.SPIRBF); 
....................     } 
....................  
....................     #define SPI_ON_BIT          (ENC_SPICON1bits.ON) 
.................... #else 
....................     #error Determine SPI flag mechanism 
.................... #endif 
....................  
....................  
.................... // Prototypes of functions intended for MAC layer use only. 
.................... static void BankSel(WORD Register); 
.................... static REG ReadETHReg(BYTE Address); 
.................... static REG ReadMACReg(BYTE Address); 
.................... static void WriteReg(BYTE Address, BYTE Data); 
.................... static void BFCReg(BYTE Address, BYTE Data); 
.................... static void BFSReg(BYTE Address, BYTE Data); 
.................... static void SendSystemReset(void); 
.................... //static void GetRegs(void); 
.................... //void Get8KBRAM(void); 
....................  
.................... // Internal MAC level variables and flags. 
.................... static WORD_VAL NextPacketLocation; 
.................... static WORD_VAL CurrentPacketLocation; 
.................... static BOOL WasDiscarded; 
.................... static BYTE ENCRevID; 
....................  
....................  
.................... //NOTE: All code in this module expects Bank 0 to be currently selected.  If code ever changes the bank, it must restore it to Bank 0 before returning. 
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACInit sets up the PIC's SPI module and all the 
....................  *                  registers in the ENC28J60 so that normal operation can 
....................  *                  begin. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACInit(void) 
.................... { 
....................     BYTE i; 
....................  
....................     // Set up the SPI module on the PIC for communications with the ENC28J60 
....................     ENC_CS_IO = 1; 
*
009CE:  BSF    F8C.1
....................     ENC_CS_TRIS = 0;        // Make the Chip Select pin an output 
009D0:  BCF    F95.1
....................  
.................... #if defined(__18CXX) 
....................     ENC_SCK_TRIS = 0; 
009D2:  BCF    F94.3
....................     ENC_SDO_TRIS = 0; 
009D4:  BCF    F94.5
....................     ENC_SDI_TRIS = 1; 
009D6:  BSF    F94.4
.................... #endif 
....................  
....................     // If the RESET pin is connected, take the chip out of reset 
.................... #if defined(ENC_RST_IO) 
....................     ENC_RST_IO      = 1; 
....................     ENC_RST_TRIS    = 0; 
.................... #endif 
....................  
....................     // Set up SPI 
....................     ClearSPIDoneFlag(); 
009D8:  BCF    F9E.3
.................... #if defined(__18CXX) 
....................     ENC_SPICON1 = 0x20;     // SSPEN bit is set, SPI in master mode, FOSC/4, 
009DA:  MOVLW  20
009DC:  MOVWF  FC6
....................                             //   IDLE state is low level 
....................     ENC_SPISTATbits.CKE = 1;// Transmit data on rising edge of clock 
009DE:  BSF    FC7.6
....................     ENC_SPISTATbits.SMP = 0;// Input sampled at middle of data output time 
009E0:  BCF    FC7.7
.................... #elif defined(__C30__) 
....................     ENC_SPISTAT = 0;        // clear SPI 
....................     #if defined(__PIC24H__) || defined(__dsPIC33F__) || defined(__dsPIC33E__)|| defined(__PIC24E__) 
....................         ENC_SPICON1 = 0x0F;     // 1:1 primary prescale, 5:1 secondary prescale (8MHz  @ 40MIPS) 
....................     //    ENC_SPICON1 = 0x1E;   // 4:1 primary prescale, 1:1 secondary prescale (10MHz @ 40MIPS, Doesn't work.  CLKRDY is incorrectly reported as being clear.  Problem caused by dsPIC33/PIC24H ES silicon bug.) 
....................     #elif defined(__PIC24F__) || defined(__PIC24FK__) 
....................         ENC_SPICON1 = 0x1B;     // 1:1 primary prescale, 2:1 secondary prescale (8MHz  @ 16MIPS) 
....................     #else   // dsPIC30F 
....................         ENC_SPICON1 = 0x17;     // 1:1 primary prescale, 3:1 secondary prescale (10MHz @ 30MIPS) 
....................     #endif 
....................     ENC_SPICON2 = 0; 
....................     ENC_SPICON1bits.CKE = 1; 
....................     ENC_SPICON1bits.MSTEN = 1; 
....................     ENC_SPISTATbits.SPIEN = 1; 
.................... #elif defined(__C32__) 
....................     ENC_SPIBRG = (GetPeripheralClock()-1ul)/2ul/ENC_MAX_SPI_FREQ; 
....................    ENC_SPICON1bits.SMP = 1;   // Delay SDI input sampling (PIC perspective) by 1/2 SPI clock 
....................     ENC_SPICON1bits.CKE = 1; 
....................     ENC_SPICON1bits.MSTEN = 1; 
....................     ENC_SPICON1bits.ON = 1; 
.................... #endif 
....................  
....................     // RESET the entire ENC28J60, clearing all registers 
....................     // Also wait for CLKRDY to become set. 
....................     // Bit 3 in ESTAT is an unimplemented bit.  If it reads out as '1' that 
....................     // means the part is in RESET or there is something wrong with the SPI 
....................     // connection.  This loop makes sure that we can communicate with the 
....................     // ENC28J60 before proceeding. 
....................     do 
....................     { 
....................         SendSystemReset(); 
009E2:  BRA    07EC
....................         i = ReadETHReg(ESTAT).Val; 
009E4:  MOVLW  1D
009E6:  MOVLB  2
009E8:  MOVWF  xE1
009EA:  MOVLB  0
009EC:  RCALL  0824
009EE:  MOVFF  01,244
....................     } while((i & 0x08) || (~i & ESTAT_CLKRDY)); 
009F2:  MOVLB  2
009F4:  BTFSS  x44.3
009F6:  BRA    09FC
009F8:  MOVLB  0
009FA:  BRA    09E2
009FC:  MOVF   x44,W
009FE:  XORLW  FF
00A00:  ANDLW  01
00A02:  BTFSC  FD8.2
00A04:  BRA    0A0A
00A06:  MOVLB  0
00A08:  BRA    09E2
....................  
....................     // Start up in Bank 0 and configure the receive buffer boundary pointers 
....................     // and the buffer write protect pointer (receive buffer read pointer) 
....................     WasDiscarded = TRUE; 
00A0A:  MOVLB  1
00A0C:  BSF    x0D.1
....................     NextPacketLocation.Val = RXSTART; 
00A0E:  CLRF   x21
00A10:  CLRF   x20
....................  
....................     WriteReg(ERXSTL, LOW(RXSTART)); 
00A12:  MOVLW  08
00A14:  MOVLB  2
00A16:  MOVWF  xE6
00A18:  CLRF   xE7
00A1A:  MOVLB  0
00A1C:  RCALL  084E
....................     WriteReg(ERXSTH, HIGH(RXSTART)); 
00A1E:  MOVLW  09
00A20:  MOVLB  2
00A22:  MOVWF  xE6
00A24:  CLRF   xE7
00A26:  MOVLB  0
00A28:  RCALL  084E
....................     WriteReg(ERXRDPTL, LOW(RXSTOP));    // Write low byte first 
00A2A:  MOVLW  0C
00A2C:  MOVLB  2
00A2E:  MOVWF  xE6
00A30:  MOVLW  E3
00A32:  MOVWF  xE7
00A34:  MOVLB  0
00A36:  RCALL  084E
....................     WriteReg(ERXRDPTH, HIGH(RXSTOP));   // Write high byte last 
00A38:  MOVLW  0D
00A3A:  MOVLB  2
00A3C:  MOVWF  xE6
00A3E:  MOVLW  17
00A40:  MOVWF  xE7
00A42:  MOVLB  0
00A44:  RCALL  084E
....................     WriteReg(ERXNDL, LOW(RXSTOP)); 
00A46:  MOVLW  0A
00A48:  MOVLB  2
00A4A:  MOVWF  xE6
00A4C:  MOVLW  E3
00A4E:  MOVWF  xE7
00A50:  MOVLB  0
00A52:  RCALL  084E
....................     WriteReg(ERXNDH, HIGH(RXSTOP)); 
00A54:  MOVLW  0B
00A56:  MOVLB  2
00A58:  MOVWF  xE6
00A5A:  MOVLW  17
00A5C:  MOVWF  xE7
00A5E:  MOVLB  0
00A60:  RCALL  084E
....................     WriteReg(ETXSTL, LOW(TXSTART)); 
00A62:  MOVLW  04
00A64:  MOVLB  2
00A66:  MOVWF  xE6
00A68:  MOVLW  E4
00A6A:  MOVWF  xE7
00A6C:  MOVLB  0
00A6E:  RCALL  084E
....................     WriteReg(ETXSTH, HIGH(TXSTART)); 
00A70:  MOVLW  05
00A72:  MOVLB  2
00A74:  MOVWF  xE6
00A76:  MOVLW  17
00A78:  MOVWF  xE7
00A7A:  MOVLB  0
00A7C:  RCALL  084E
....................  
....................     // Write a permanant per packet control byte of 0x00 
....................     WriteReg(EWRPTL, LOW(TXSTART)); 
00A7E:  MOVLW  02
00A80:  MOVLB  2
00A82:  MOVWF  xE6
00A84:  MOVLW  E4
00A86:  MOVWF  xE7
00A88:  MOVLB  0
00A8A:  RCALL  084E
....................     WriteReg(EWRPTH, HIGH(TXSTART)); 
00A8C:  MOVLW  03
00A8E:  MOVLB  2
00A90:  MOVWF  xE6
00A92:  MOVLW  17
00A94:  MOVWF  xE7
00A96:  MOVLB  0
00A98:  RCALL  084E
....................     MACPut(0x00); 
00A9A:  MOVLB  2
00A9C:  CLRF   xE4
00A9E:  MOVLB  0
00AA0:  RCALL  0878
....................  
....................  
....................     // Enter Bank 1 and configure Receive Filters 
....................     // (No need to reconfigure - Unicast OR Broadcast with CRC checking is 
....................     // acceptable) 
....................     // Write ERXFCON_CRCEN only to ERXFCON to enter promiscuous mode 
....................  
....................     // Promiscious mode example: 
....................     //BankSel(ERXFCON); 
....................     //WriteReg((BYTE)ERXFCON, ERXFCON_CRCEN); 
....................  
....................     // Enter Bank 2 and configure the MAC 
....................     BankSel(MACON1); 
00AA2:  MOVLW  02
00AA4:  MOVLB  2
00AA6:  MOVWF  xC6
00AA8:  CLRF   xC5
00AAA:  MOVLB  0
00AAC:  RCALL  08C6
....................  
....................     // Enable the receive portion of the MAC 
....................     WriteReg((BYTE)MACON1, MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN); 
00AAE:  MOVLB  2
00AB0:  CLRF   xE6
00AB2:  MOVLW  0D
00AB4:  MOVWF  xE7
00AB6:  MOVLB  0
00AB8:  RCALL  084E
....................  
....................     // Pad packets to 60 bytes, add CRC, and check Type/Length field. 
.................... #if defined(FULL_DUPLEX) 
....................     WriteReg((BYTE)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN | MACON3_FULDPX); 
....................     WriteReg((BYTE)MABBIPG, 0x15); 
.................... #else 
....................     WriteReg((BYTE)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN); 
00ABA:  MOVLW  02
00ABC:  MOVLB  2
00ABE:  MOVWF  xE6
00AC0:  MOVLW  32
00AC2:  MOVWF  xE7
00AC4:  MOVLB  0
00AC6:  RCALL  084E
....................     WriteReg((BYTE)MABBIPG, 0x12); 
00AC8:  MOVLW  04
00ACA:  MOVLB  2
00ACC:  MOVWF  xE6
00ACE:  MOVLW  12
00AD0:  MOVWF  xE7
00AD2:  MOVLB  0
00AD4:  RCALL  084E
.................... #endif 
....................  
....................     // Allow infinite deferals if the medium is continuously busy 
....................     // (do not time out a transmission if the half duplex medium is 
....................     // completely saturated with other people's data) 
....................     WriteReg((BYTE)MACON4, MACON4_DEFER); 
00AD6:  MOVLW  03
00AD8:  MOVLB  2
00ADA:  MOVWF  xE6
00ADC:  MOVLW  40
00ADE:  MOVWF  xE7
00AE0:  MOVLB  0
00AE2:  RCALL  084E
....................  
....................     // Late collisions occur beyond 63+8 bytes (8 bytes for preamble/start of frame delimiter) 
....................     // 55 is all that is needed for IEEE 802.3, but ENC28J60 B5 errata for improper link pulse 
....................     // collisions will occur less often with a larger number. 
....................     WriteReg((BYTE)MACLCON2, 63); 
00AE4:  MOVLW  09
00AE6:  MOVLB  2
00AE8:  MOVWF  xE6
00AEA:  MOVLW  3F
00AEC:  MOVWF  xE7
00AEE:  MOVLB  0
00AF0:  RCALL  084E
....................  
....................     // Set non-back-to-back inter-packet gap to 9.6us.  The back-to-back 
....................     // inter-packet gap (MABBIPG) is set by MACSetDuplex() which is called 
....................     // later. 
....................     WriteReg((BYTE)MAIPGL, 0x12); 
00AF2:  MOVLW  06
00AF4:  MOVLB  2
00AF6:  MOVWF  xE6
00AF8:  MOVLW  12
00AFA:  MOVWF  xE7
00AFC:  MOVLB  0
00AFE:  RCALL  084E
....................     WriteReg((BYTE)MAIPGH, 0x0C); 
00B00:  MOVLW  07
00B02:  MOVLB  2
00B04:  MOVWF  xE6
00B06:  MOVLW  0C
00B08:  MOVWF  xE7
00B0A:  MOVLB  0
00B0C:  RCALL  084E
....................  
....................     // Set the maximum packet size which the controller will accept 
....................     WriteReg((BYTE)MAMXFLL, LOW(6+6+2+1500+4));  // 1518 is the IEEE 802.3 specified limit 
00B0E:  MOVLW  0A
00B10:  MOVLB  2
00B12:  MOVWF  xE6
00B14:  MOVLW  EE
00B16:  MOVWF  xE7
00B18:  MOVLB  0
00B1A:  RCALL  084E
....................     WriteReg((BYTE)MAMXFLH, HIGH(6+6+2+1500+4)); // 1518 is the IEEE 802.3 specified limit 
00B1C:  MOVLW  0B
00B1E:  MOVLB  2
00B20:  MOVWF  xE6
00B22:  MOVLW  05
00B24:  MOVWF  xE7
00B26:  MOVLB  0
00B28:  RCALL  084E
....................  
....................     // Enter Bank 3 and initialize physical MAC address registers 
....................     BankSel(MAADR1); 
00B2A:  MOVLW  03
00B2C:  MOVLB  2
00B2E:  MOVWF  xC6
00B30:  MOVLW  04
00B32:  MOVWF  xC5
00B34:  MOVLB  0
00B36:  RCALL  08C6
....................     WriteReg((BYTE)MAADR1, AppConfig.MyMACAddr.v[0]); 
00B38:  MOVLW  04
00B3A:  MOVLB  2
00B3C:  MOVWF  xE6
00B3E:  MOVFF  56,2E7
00B42:  MOVLB  0
00B44:  RCALL  084E
....................     WriteReg((BYTE)MAADR2, AppConfig.MyMACAddr.v[1]); 
00B46:  MOVLW  05
00B48:  MOVLB  2
00B4A:  MOVWF  xE6
00B4C:  MOVFF  57,2E7
00B50:  MOVLB  0
00B52:  RCALL  084E
....................     WriteReg((BYTE)MAADR3, AppConfig.MyMACAddr.v[2]); 
00B54:  MOVLW  02
00B56:  MOVLB  2
00B58:  MOVWF  xE6
00B5A:  MOVFF  58,2E7
00B5E:  MOVLB  0
00B60:  RCALL  084E
....................     WriteReg((BYTE)MAADR4, AppConfig.MyMACAddr.v[3]); 
00B62:  MOVLW  03
00B64:  MOVLB  2
00B66:  MOVWF  xE6
00B68:  MOVFF  59,2E7
00B6C:  MOVLB  0
00B6E:  RCALL  084E
....................     WriteReg((BYTE)MAADR5, AppConfig.MyMACAddr.v[4]); 
00B70:  MOVLB  2
00B72:  CLRF   xE6
00B74:  MOVFF  5A,2E7
00B78:  MOVLB  0
00B7A:  RCALL  084E
....................     WriteReg((BYTE)MAADR6, AppConfig.MyMACAddr.v[5]); 
00B7C:  MOVLW  01
00B7E:  MOVLB  2
00B80:  MOVWF  xE6
00B82:  MOVFF  5B,2E7
00B86:  MOVLB  0
00B88:  RCALL  084E
....................  
....................     // Disable the CLKOUT output to reduce EMI generation 
....................     WriteReg((BYTE)ECOCON, 0x00);   // Output off (0V) 
00B8A:  MOVLW  15
00B8C:  MOVLB  2
00B8E:  MOVWF  xE6
00B90:  CLRF   xE7
00B92:  MOVLB  0
00B94:  RCALL  084E
....................     //WriteReg((BYTE)ECOCON, 0x01); // 25.000MHz 
....................     //WriteReg((BYTE)ECOCON, 0x03); // 8.3333MHz (*4 with PLL is 33.3333MHz) 
....................  
....................     // Get the Rev ID so that we can implement the correct errata workarounds 
....................     ENCRevID = ReadETHReg((BYTE)EREVID).Val; 
00B96:  MOVLW  12
00B98:  MOVLB  2
00B9A:  MOVWF  xE1
00B9C:  MOVLB  0
00B9E:  RCALL  0824
00BA0:  MOVFF  01,124
....................  
....................     // Disable half duplex loopback in PHY.  Bank bits changed to Bank 2 as a 
....................     // side effect. 
....................     WritePHYReg(PHCON2, PHCON2_HDLDIS); 
00BA4:  MOVLW  10
00BA6:  MOVLB  2
00BA8:  MOVWF  x45
00BAA:  MOVLW  01
00BAC:  MOVWF  x47
00BAE:  CLRF   x46
00BB0:  MOVLB  0
00BB2:  RCALL  0934
....................  
....................     // Configure LEDA to display LINK status, LEDB to display TX/RX activity 
....................     SetLEDConfig(0x3472); 
00BB4:  MOVLW  14
00BB6:  MOVLB  2
00BB8:  MOVWF  x45
00BBA:  MOVLW  34
00BBC:  MOVWF  x47
00BBE:  MOVLW  72
00BC0:  MOVWF  x46
00BC2:  MOVLB  0
00BC4:  RCALL  0934
....................  
....................     // Set the MAC and PHY into the proper duplex state 
.................... #if defined(FULL_DUPLEX) 
....................     WritePHYReg(PHCON1, PHCON1_PDPXMD); 
.................... #elif defined(HALF_DUPLEX) 
....................     WritePHYReg(PHCON1, 0x0000); 
00BC6:  MOVLB  2
00BC8:  CLRF   x45
00BCA:  CLRF   x47
00BCC:  CLRF   x46
00BCE:  MOVLB  0
00BD0:  RCALL  0934
.................... #else 
....................     // Use the external LEDB polarity to determine weather full or half duplex 
....................     // communication mode should be set. 
....................     { 
....................         REG Register; 
....................         PHYREG PhyReg; 
....................  
....................         // Read the PHY duplex mode 
....................         PhyReg = ReadPHYReg(PHCON1); 
....................         DuplexState = PhyReg.PHCON1bits.PDPXMD; 
....................  
....................         // Set the MAC to the proper duplex mode 
....................         BankSel(MACON3); 
....................         Register = ReadMACReg((BYTE)MACON3); 
....................         Register.MACON3bits.FULDPX = PhyReg.PHCON1bits.PDPXMD; 
....................         WriteReg((BYTE)MACON3, Register.Val); 
....................  
....................         // Set the back-to-back inter-packet gap time to IEEE specified 
....................         // requirements.  The meaning of the MABBIPG value changes with the duplex 
....................         // state, so it must be updated in this function. 
....................         // In full duplex, 0x15 represents 9.6us; 0x12 is 9.6us in half duplex 
....................         WriteReg((BYTE)MABBIPG, PhyReg.PHCON1bits.PDPXMD ? 0x15 : 0x12); 
....................     } 
.................... #endif 
....................  
....................     BankSel(ERDPTL);        // Return to default Bank 0 
00BD2:  MOVLB  2
00BD4:  CLRF   xC6
00BD6:  CLRF   xC5
00BD8:  MOVLB  0
00BDA:  RCALL  08C6
....................  
....................     // Enable packet reception 
....................     BFSReg(ECON1, ECON1_RXEN); 
00BDC:  MOVLW  1F
00BDE:  MOVLB  2
00BE0:  MOVWF  xDB
00BE2:  MOVLW  04
00BE4:  MOVWF  xDC
00BE6:  MOVLB  0
00BE8:  RCALL  089C
00BEA:  GOTO   167E (RETURN)
.................... }//end MACInit 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsLinked(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: If the PHY reports that a link partner is present 
....................  *                        and the link has been up continuously since the last 
....................  *                        call to MACIsLinked() 
....................  *                  FALSE: If the PHY reports no link partner, or the link went 
....................  *                         down momentarily since the last call to MACIsLinked() 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the PHSTAT1.LLSTAT bit. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsLinked(void) 
.................... { 
....................     // LLSTAT is a latching low link status bit.  Therefore, if the link 
....................     // goes down and comes back up before a higher level stack program calls 
....................     // MACIsLinked(), MACIsLinked() will still return FALSE.  The next 
....................     // call to MACIsLinked() will return TRUE (unless the link goes down 
....................     // again). 
....................     return ReadPHYReg(PHSTAT1).PHSTAT1bits.LLSTAT; 
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsTxReady(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: If no Ethernet transmission is in progress 
....................  *                  FALSE: If a previous transmission was started, and it has 
....................  *                         not completed yet.  While FALSE, the data in the 
....................  *                         transmit buffer and the TXST/TXND pointers must not 
....................  *                         be changed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the ECON1.TXRTS bit 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsTxReady(void) 
.................... { 
....................     return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
*
0168C:  MOVLW  1F
0168E:  MOVLB  2
01690:  MOVWF  xE1
01692:  MOVLB  0
01694:  CALL   0824
01698:  MOVFF  01,2C1
0169C:  MOVLW  00
0169E:  MOVLB  2
016A0:  BTFSC  01.3
016A2:  MOVLW  01
016A4:  XORLW  00
016A6:  BZ    16AC
016A8:  MOVLW  00
016AA:  BRA    16AE
016AC:  MOVLW  01
016AE:  MOVWF  01
016B0:  MOVLB  0
016B2:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDiscardRx(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Marks the last received packet (obtained using 
....................  *                  MACGetHeader())as being processed and frees the buffer 
....................  *                  memory associated with it 
....................  * 
....................  * Note:            Is is safe to call this function multiple times between 
....................  *                  MACGetHeader() calls.  Extra packets won't be thrown away 
....................  *                  until MACGetHeader() makes it available. 
....................  *****************************************************************************/ 
.................... void MACDiscardRx(void) 
.................... { 
....................     WORD_VAL NewRXRDLocation; 
....................  
....................     // Make sure the current packet was not already discarded 
....................     if(WasDiscarded) 
*
03A06:  MOVLB  1
03A08:  BTFSS  x0D.1
03A0A:  BRA    3A0E
....................         return; 
03A0C:  BRA    3A6A
....................     WasDiscarded = TRUE; 
03A0E:  BSF    x0D.1
....................  
....................     // Decrement the next packet pointer before writing it into 
....................     // the ERXRDPT registers.  This is a silicon errata workaround. 
....................     // RX buffer wrapping must be taken into account if the 
....................     // NextPacketLocation is precisely RXSTART. 
....................     NewRXRDLocation.Val = NextPacketLocation.Val - 1; 
03A10:  MOVLW  01
03A12:  SUBWF  x20,W
03A14:  MOVLB  2
03A16:  MOVWF  x77
03A18:  MOVLW  00
03A1A:  MOVLB  1
03A1C:  SUBWFB x21,W
03A1E:  MOVLB  2
03A20:  MOVWF  x78
....................     if(NewRXRDLocation.Val > RXSTOP) 
03A22:  MOVF   x78,W
03A24:  SUBLW  16
03A26:  BC    3A3A
03A28:  XORLW  FF
03A2A:  BNZ   3A32
03A2C:  MOVF   x77,W
03A2E:  SUBLW  E3
03A30:  BC    3A3A
....................     { 
....................         NewRXRDLocation.Val = RXSTOP; 
03A32:  MOVLW  17
03A34:  MOVWF  x78
03A36:  MOVLW  E3
03A38:  MOVWF  x77
....................     } 
....................  
....................     // Decrement the RX packet counter register, EPKTCNT 
....................     BFSReg(ECON2, ECON2_PKTDEC); 
03A3A:  MOVLW  1E
03A3C:  MOVWF  xDB
03A3E:  MOVLW  40
03A40:  MOVWF  xDC
03A42:  MOVLB  0
03A44:  CALL   089C
....................  
....................     // Move the receive read pointer to unwrite-protect the memory used by the 
....................     // last packet.  The writing order is important: set the low byte first, 
....................     // high byte last. 
....................     WriteReg(ERXRDPTL, NewRXRDLocation.v[0]); 
03A48:  MOVLW  0C
03A4A:  MOVLB  2
03A4C:  MOVWF  xE6
03A4E:  MOVFF  277,2E7
03A52:  MOVLB  0
03A54:  CALL   084E
....................     WriteReg(ERXRDPTH, NewRXRDLocation.v[1]); 
03A58:  MOVLW  0D
03A5A:  MOVLB  2
03A5C:  MOVWF  xE6
03A5E:  MOVFF  278,2E7
03A62:  MOVLB  0
03A64:  CALL   084E
03A68:  MOVLB  1
03A6A:  MOVLB  0
03A6C:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetFreeRxSize(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          A WORD estimate of how much RX buffer space is free at 
....................  *                  the present time. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetFreeRxSize(void) 
.................... { 
....................     WORD_VAL ReadPT, WritePT; 
....................  
....................     // Read the Ethernet hardware buffer write pointer.  Because packets can be 
....................     // received at any time, it can change between reading the low and high 
....................     // bytes.  A loop is necessary to make certain a proper low/high byte pair 
....................     // is read. 
....................     BankSel(EPKTCNT); 
*
0175C:  MOVLW  01
0175E:  MOVLB  2
01760:  MOVWF  xC6
01762:  MOVLW  19
01764:  MOVWF  xC5
01766:  MOVLB  0
01768:  CALL   08C6
....................     do { 
....................         // Save EPKTCNT in a temporary location 
....................         ReadPT.v[0] = ReadETHReg((BYTE)EPKTCNT).Val; 
0176C:  MOVLW  19
0176E:  MOVLB  2
01770:  MOVWF  xE1
01772:  MOVLB  0
01774:  CALL   0824
01778:  MOVFF  01,2C1
....................  
....................         BankSel(ERXWRPTL); 
0177C:  MOVLB  2
0177E:  CLRF   xC6
01780:  MOVLW  0E
01782:  MOVWF  xC5
01784:  MOVLB  0
01786:  CALL   08C6
....................         WritePT.v[0] = ReadETHReg(ERXWRPTL).Val; 
0178A:  MOVLW  0E
0178C:  MOVLB  2
0178E:  MOVWF  xE1
01790:  MOVLB  0
01792:  CALL   0824
01796:  MOVFF  01,2C3
....................         WritePT.v[1] = ReadETHReg(ERXWRPTH).Val; 
0179A:  MOVLW  0F
0179C:  MOVLB  2
0179E:  MOVWF  xE1
017A0:  MOVLB  0
017A2:  CALL   0824
017A6:  MOVFF  01,2C4
....................  
....................         BankSel(EPKTCNT); 
017AA:  MOVLW  01
017AC:  MOVLB  2
017AE:  MOVWF  xC6
017B0:  MOVLW  19
017B2:  MOVWF  xC5
017B4:  MOVLB  0
017B6:  CALL   08C6
....................     } while(ReadETHReg((BYTE)EPKTCNT).Val != ReadPT.v[0]); 
017BA:  MOVLW  19
017BC:  MOVLB  2
017BE:  MOVWF  xE1
017C0:  MOVLB  0
017C2:  CALL   0824
017C6:  MOVFF  01,2C5
017CA:  MOVLB  2
017CC:  MOVF   xC1,W
017CE:  SUBWF  01,W
017D0:  BTFSC  FD8.2
017D2:  BRA    17D8
017D4:  MOVLB  0
017D6:  BRA    176C
....................  
....................     // Determine where the write protection pointer is 
....................     BankSel(ERXRDPTL); 
017D8:  CLRF   xC6
017DA:  MOVLW  0C
017DC:  MOVWF  xC5
017DE:  MOVLB  0
017E0:  CALL   08C6
....................     ReadPT.v[0] = ReadETHReg(ERXRDPTL).Val; 
017E4:  MOVLW  0C
017E6:  MOVLB  2
017E8:  MOVWF  xE1
017EA:  MOVLB  0
017EC:  CALL   0824
017F0:  MOVFF  01,2C1
....................     ReadPT.v[1] = ReadETHReg(ERXRDPTH).Val; 
017F4:  MOVLW  0D
017F6:  MOVLB  2
017F8:  MOVWF  xE1
017FA:  MOVLB  0
017FC:  CALL   0824
01800:  MOVFF  01,2C2
....................  
....................     // Calculate the difference between the pointers, taking care to account 
....................     // for buffer wrapping conditions 
....................     if(WritePT.Val > ReadPT.Val) 
01804:  MOVLB  2
01806:  MOVF   xC2,W
01808:  SUBWF  xC4,W
0180A:  BNC   1838
0180C:  BNZ   1814
0180E:  MOVF   xC3,W
01810:  SUBWF  xC1,W
01812:  BC    1838
....................     { 
....................         return (RXSTOP - RXSTART) - (WritePT.Val - ReadPT.Val); 
01814:  MOVF   xC1,W
01816:  SUBWF  xC3,W
01818:  MOVWF  00
0181A:  MOVF   xC2,W
0181C:  SUBWFB xC4,W
0181E:  MOVWF  03
01820:  MOVF   00,W
01822:  XORLW  FF
01824:  ADDLW  E4
01826:  MOVWF  00
01828:  MOVLW  17
0182A:  SUBFWB 03,F
0182C:  MOVFF  00,01
01830:  MOVFF  03,02
01834:  BRA    186E
....................     } 
01836:  BRA    186E
....................     else if(WritePT.Val == ReadPT.Val) 
01838:  MOVF   xC1,W
0183A:  SUBWF  xC3,W
0183C:  BNZ   1850
0183E:  MOVF   xC2,W
01840:  SUBWF  xC4,W
01842:  BNZ   1850
....................     { 
....................         return RXSIZE - 1; 
01844:  MOVLW  E3
01846:  MOVWF  01
01848:  MOVLW  17
0184A:  MOVWF  02
0184C:  BRA    186E
....................     } 
0184E:  BRA    186E
....................     else 
....................     { 
....................         return ReadPT.Val - WritePT.Val - 1; 
01850:  MOVF   xC3,W
01852:  SUBWF  xC1,W
01854:  MOVWF  xC5
01856:  MOVF   xC4,W
01858:  SUBWFB xC2,W
0185A:  MOVWF  xC6
0185C:  MOVLW  01
0185E:  SUBWF  xC5,W
01860:  MOVWF  00
01862:  MOVLW  00
01864:  SUBWFB xC6,W
01866:  MOVWF  03
01868:  MOVFF  00,01
0186C:  MOVWF  02
....................     } 
0186E:  MOVLB  0
01870:  GOTO   2786 (RETURN)
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           *remote: Location to store the Source MAC address of the 
....................  *                           received frame. 
....................  *                  *type: Location of a BYTE to store the constant 
....................  *                         MAC_UNKNOWN, ETHER_IP, or ETHER_ARP, representing 
....................  *                         the contents of the Ethernet type field. 
....................  * 
....................  * Output:          TRUE: If a packet was waiting in the RX buffer.  The 
....................  *                        remote, and type values are updated. 
....................  *                  FALSE: If a packet was not pending.  remote and type are 
....................  *                         not changed. 
....................  * 
....................  * Side Effects:    Last packet is discarded if MACDiscardRx() hasn't already 
....................  *                  been called. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
.................... { 
....................     ENC_PREAMBLE header; 
....................     BYTE PacketCount; 
....................  
....................     // Test if at least one packet has been received and is waiting 
....................     BankSel(EPKTCNT); 
*
05238:  MOVLW  01
0523A:  MOVLB  2
0523C:  MOVWF  xC6
0523E:  MOVLW  19
05240:  MOVWF  xC5
05242:  MOVLB  0
05244:  CALL   08C6
....................     PacketCount = ReadETHReg((BYTE)EPKTCNT).Val; 
05248:  MOVLW  19
0524A:  MOVLB  2
0524C:  MOVWF  xE1
0524E:  MOVLB  0
05250:  CALL   0824
05254:  MOVFF  01,264
....................     BankSel(ERDPTL); 
05258:  MOVLB  2
0525A:  CLRF   xC6
0525C:  CLRF   xC5
0525E:  MOVLB  0
05260:  CALL   08C6
....................     if(PacketCount == 0u) 
05264:  MOVLB  2
05266:  MOVF   x64,F
05268:  BNZ   5270
....................         return FALSE; 
0526A:  MOVLW  00
0526C:  MOVWF  01
0526E:  BRA    5384
....................  
....................     // Make absolutely certain that any previous packet was discarded 
....................     if(WasDiscarded == FALSE) 
05270:  MOVLB  1
05272:  BTFSC  x0D.1
05274:  BRA    5286
....................     { 
....................         MACDiscardRx(); 
05276:  MOVLB  0
05278:  CALL   3A06
....................         return FALSE; 
0527C:  MOVLW  00
0527E:  MOVWF  01
05280:  MOVLB  2
05282:  BRA    5384
05284:  MOVLB  1
....................     } 
....................  
....................     // Set the SPI read pointer to the beginning of the next unprocessed packet 
....................     CurrentPacketLocation.Val = NextPacketLocation.Val; 
05286:  MOVFF  121,123
0528A:  MOVFF  120,122
....................     WriteReg(ERDPTL, CurrentPacketLocation.v[0]); 
0528E:  MOVLB  2
05290:  CLRF   xE6
05292:  MOVFF  122,2E7
05296:  MOVLB  0
05298:  CALL   084E
....................     WriteReg(ERDPTH, CurrentPacketLocation.v[1]); 
0529C:  MOVLW  01
0529E:  MOVLB  2
052A0:  MOVWF  xE6
052A2:  MOVFF  123,2E7
052A6:  MOVLB  0
052A8:  CALL   084E
....................  
....................     // Obtain the MAC header from the Ethernet buffer 
....................     MACGetArray((BYTE*)&header, sizeof(header)); 
052AC:  MOVLW  02
052AE:  MOVLB  2
052B0:  MOVWF  x66
052B2:  MOVLW  50
052B4:  MOVWF  x65
052B6:  MOVFF  266,2E4
052BA:  MOVWF  xE3
052BC:  CLRF   xE6
052BE:  MOVLW  14
052C0:  MOVWF  xE5
052C2:  MOVLB  0
052C4:  CALL   0E8E
....................  
....................     // The EtherType field, like most items transmitted on the Ethernet medium 
....................     // are in big endian. 
....................     header.Type.Val = swaps(header.Type.Val); 
052C8:  MOVFF  263,2E1
052CC:  MOVFF  262,2E0
052D0:  CALL   1874
052D4:  MOVFF  02,263
052D8:  MOVFF  01,262
....................  
....................     // Validate the data returned from the ENC28J60.  Random data corruption, 
....................     // such as if a single SPI bit error occurs while communicating or a 
....................     // momentary power glitch could cause this to occur in rare circumstances. 
....................     if(header.NextPacketPointer > RXSTOP || ((BYTE_VAL*)(&header.NextPacketPointer))->bits.b0 || 
....................        header.StatusVector.bits.Zero || 
....................        header.StatusVector.bits.CRCError || 
....................        header.StatusVector.bits.ByteCount > 1518u || 
....................        !header.StatusVector.bits.ReceiveOk) 
052DC:  MOVLB  2
052DE:  MOVF   x51,W
052E0:  SUBLW  16
052E2:  BC    52EE
052E4:  XORLW  FF
052E6:  BNZ   531A
052E8:  MOVF   x50,W
052EA:  SUBLW  E3
052EC:  BNC   531A
052EE:  MOVLW  02
052F0:  MOVWF  x66
052F2:  MOVLW  50
052F4:  MOVWF  FE9
052F6:  MOVFF  266,FEA
052FA:  BTFSC  FEF.0
052FC:  BRA    531A
052FE:  BTFSC  x55.7
05300:  BRA    531A
05302:  BTFSC  x54.4
05304:  BRA    531A
05306:  MOVF   x53,W
05308:  SUBLW  04
0530A:  BC    5316
0530C:  XORLW  FF
0530E:  BNZ   531A
05310:  MOVF   x52,W
05312:  SUBLW  EE
05314:  BNC   531A
05316:  BTFSC  x54.7
05318:  BRA    531C
....................     { 
....................         Reset(); 
0531A:  RESET
....................     } 
....................  
....................     // Save the location where the hardware will write the next packet to 
....................     NextPacketLocation.Val = header.NextPacketPointer; 
0531C:  MOVFF  251,121
05320:  MOVFF  250,120
....................  
....................     // Return the Ethernet frame's Source MAC address field to the caller 
....................     // This parameter is useful for replying to requests without requiring an 
....................     // ARP cycle. 
....................     memcpy((void*)remote->v, (void*)header.SourceMACAddr.v, sizeof(*remote)); 
05324:  MOVFF  24D,03
05328:  MOVFF  24C,265
0532C:  MOVFF  24D,266
05330:  MOVLW  02
05332:  MOVWF  x68
05334:  MOVLW  5C
05336:  MOVFF  24D,FEA
0533A:  MOVFF  24C,FE9
0533E:  MOVFF  268,FE2
05342:  MOVWF  FE1
05344:  MOVLW  06
05346:  MOVWF  01
05348:  MOVFF  FE6,FEE
0534C:  DECFSZ 01,F
0534E:  BRA    5348
....................  
....................     // Return a simplified version of the EtherType field to the caller 
....................     *type = MAC_UNKNOWN; 
05350:  MOVFF  24F,03
05354:  MOVFF  24E,FE9
05358:  MOVFF  03,FEA
0535C:  SETF   FEF
....................     if( (header.Type.v[1] == 0x08u) && 
....................         ((header.Type.v[0] == ETHER_IP) || (header.Type.v[0] == ETHER_ARP)) ) 
0535E:  MOVF   x63,W
05360:  SUBLW  08
05362:  BNZ   537A
05364:  MOVF   x62,F
05366:  BZ    536E
05368:  MOVF   x62,W
0536A:  SUBLW  06
0536C:  BNZ   537A
....................     { 
....................         *type = header.Type.v[0]; 
0536E:  MOVFF  24E,FE9
05372:  MOVFF  24F,FEA
05376:  MOVFF  262,FEF
....................     } 
....................  
....................     // Mark this packet as discardable 
....................     WasDiscarded = FALSE; 
0537A:  MOVLB  1
0537C:  BCF    x0D.1
....................     return TRUE; 
0537E:  MOVLW  01
05380:  MOVWF  01
05382:  MOVLB  2
05384:  MOVLB  0
05386:  GOTO   751E (RETURN)
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen) 
....................  * 
....................  * PreCondition:    MACIsTxReady() must return TRUE. 
....................  * 
....................  * Input:           *remote: Pointer to memory which contains the destination 
....................  *                           MAC address (6 bytes) 
....................  *                  type: The constant ETHER_ARP or ETHER_IP, defining which 
....................  *                        value to write into the Ethernet header's type field. 
....................  *                  dataLen: Length of the Ethernet data payload 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Because of the dataLen parameter, it is probably 
....................  *                  advantagous to call this function immediately before 
....................  *                  transmitting a packet rather than initially when the 
....................  *                  packet is first created.  The order in which the packet 
....................  *                  is constructed (header first or data first) is not 
....................  *                  important. 
....................  *****************************************************************************/ 
.................... void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen) 
.................... { 
....................     // Set the SPI write pointer to the beginning of the transmit buffer (post per packet control byte) 
....................     WriteReg(EWRPTL, LOW(TXSTART+1)); 
*
01DEA:  MOVLW  02
01DEC:  MOVLB  2
01DEE:  MOVWF  xE6
01DF0:  MOVLW  E5
01DF2:  MOVWF  xE7
01DF4:  MOVLB  0
01DF6:  CALL   084E
....................     WriteReg(EWRPTH, HIGH(TXSTART+1)); 
01DFA:  MOVLW  03
01DFC:  MOVLB  2
01DFE:  MOVWF  xE6
01E00:  MOVLW  17
01E02:  MOVWF  xE7
01E04:  MOVLB  0
01E06:  CALL   084E
....................  
....................     // Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TXSTART; 
01E0A:  MOVLW  F2
01E0C:  MOVLB  2
01E0E:  ADDWF  xE1,F
01E10:  MOVLW  17
01E12:  ADDWFC xE2,F
....................  
....................     // Write the TXND pointer into the registers, given the dataLen given 
....................     WriteReg(ETXNDL, ((WORD_VAL*)&dataLen)->v[0]); 
01E14:  MOVLW  02
01E16:  MOVWF  xE4
01E18:  MOVLW  E1
01E1A:  MOVWF  xE3
01E1C:  MOVWF  FE9
01E1E:  MOVFF  2E4,FEA
01E22:  MOVFF  FEF,2E5
01E26:  MOVLW  06
01E28:  MOVWF  xE6
01E2A:  MOVFF  2E5,2E7
01E2E:  MOVLB  0
01E30:  CALL   084E
....................     WriteReg(ETXNDH, ((WORD_VAL*)&dataLen)->v[1]); 
01E34:  MOVLW  02
01E36:  MOVLB  2
01E38:  MOVWF  xE4
01E3A:  MOVLW  E1
01E3C:  MOVWF  xE3
01E3E:  MOVLW  01
01E40:  ADDWF  xE3,W
01E42:  MOVWF  FE9
01E44:  MOVLW  00
01E46:  ADDWFC xE4,W
01E48:  MOVWF  FEA
01E4A:  MOVFF  FEF,2E5
01E4E:  MOVLW  07
01E50:  MOVWF  xE6
01E52:  MOVFF  2E5,2E7
01E56:  MOVLB  0
01E58:  CALL   084E
....................  
....................     // Set the per-packet control byte and write the Ethernet destination 
....................     // address 
....................     MACPutArray((BYTE*)remote, sizeof(*remote)); 
01E5C:  MOVFF  2DF,2E6
01E60:  MOVFF  2DE,2E5
01E64:  MOVLB  2
01E66:  CLRF   xE8
01E68:  MOVLW  06
01E6A:  MOVWF  xE7
01E6C:  MOVLB  0
01E6E:  CALL   0DDC
....................  
....................     // Write our MAC address in the Ethernet source field 
....................     MACPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr)); 
01E72:  MOVLB  2
01E74:  CLRF   xE4
01E76:  MOVLW  56
01E78:  MOVWF  xE3
01E7A:  MOVFF  2E4,2E6
01E7E:  MOVWF  xE5
01E80:  CLRF   xE8
01E82:  MOVLW  06
01E84:  MOVWF  xE7
01E86:  MOVLB  0
01E88:  CALL   0DDC
....................  
....................     // Write the appropriate Ethernet Type WORD for the protocol being used 
....................     MACPut(0x08); 
01E8C:  MOVLW  08
01E8E:  MOVLB  2
01E90:  MOVWF  xE4
01E92:  MOVLB  0
01E94:  CALL   0878
....................     MACPut((type == MAC_IP) ? ETHER_IP : ETHER_ARP); 
01E98:  MOVLB  2
01E9A:  MOVF   xE0,F
01E9C:  BNZ   1EA2
01E9E:  MOVLW  00
01EA0:  BRA    1EA4
01EA2:  MOVLW  06
01EA4:  MOVWF  xE3
01EA6:  MOVWF  xE4
01EA8:  MOVLB  0
01EAA:  CALL   0878
01EAE:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACFlush(void) 
....................  * 
....................  * PreCondition:    A packet has been created by calling MACPut() and 
....................  *                  MACPutHeader(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACFlush causes the current TX packet to be sent out on 
....................  *                  the Ethernet medium.  The hardware MAC will take control 
....................  *                  and handle CRC generation, collision retransmission and 
....................  *                  other details. 
....................  * 
....................  * Note:            After transmission completes (MACIsTxReady() returns TRUE), 
....................  *                  the packet can be modified and transmitted again by calling 
....................  *                  MACFlush() again.  Until MACPutHeader() or MACPut() is 
....................  *                  called (in the TX data area), the data in the TX buffer 
....................  *                  will not be corrupted. 
....................  *****************************************************************************/ 
.................... void MACFlush(void) 
.................... { 
....................     // Reset transmit logic if a TX Error has previously occured 
....................     // This is a silicon errata workaround 
....................     BFSReg(ECON1, ECON1_TXRST); 
*
020E2:  MOVLW  1F
020E4:  MOVLB  2
020E6:  MOVWF  xDB
020E8:  MOVLW  80
020EA:  MOVWF  xDC
020EC:  MOVLB  0
020EE:  CALL   089C
....................     BFCReg(ECON1, ECON1_TXRST); 
020F2:  MOVLW  1F
020F4:  MOVLB  2
020F6:  MOVWF  xDB
020F8:  MOVLW  80
020FA:  MOVWF  xDC
020FC:  MOVLB  0
020FE:  CALL   07C2
....................     BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
02102:  MOVLW  1C
02104:  MOVLB  2
02106:  MOVWF  xDB
02108:  MOVLW  0A
0210A:  MOVWF  xDC
0210C:  MOVLB  0
0210E:  CALL   07C2
....................  
....................     // Start the transmission 
....................     // After transmission completes (MACIsTxReady() returns TRUE), the packet 
....................     // can be modified and transmitted again by calling MACFlush() again. 
....................     // Until MACPutHeader() is called, the data in the TX buffer will not be 
....................     // corrupted. 
....................     BFSReg(ECON1, ECON1_TXRTS); 
02112:  MOVLW  1F
02114:  MOVLB  2
02116:  MOVWF  xDB
02118:  MOVLW  08
0211A:  MOVWF  xDC
0211C:  MOVLB  0
0211E:  CALL   089C
....................  
....................     // Revision B5 and B7 silicon errata workaround 
....................     if(ENCRevID == 0x05u || ENCRevID == 0x06u) 
02122:  MOVLB  1
02124:  MOVF   x24,W
02126:  SUBLW  05
02128:  BZ    2132
0212A:  MOVF   x24,W
0212C:  SUBLW  06
0212E:  BTFSS  FD8.2
02130:  BRA    2316
....................     { 
....................         WORD AttemptCounter = 0x0000; 
02132:  MOVLB  2
02134:  CLRF   xC2
02136:  CLRF   xC1
....................         while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF)) && (++AttemptCounter < 1000u)); 
02138:  MOVLW  1C
0213A:  MOVWF  xE1
0213C:  MOVLB  0
0213E:  CALL   0824
02142:  MOVFF  01,2CF
02146:  MOVLB  2
02148:  MOVF   01,W
0214A:  ANDLW  0A
0214C:  BNZ   2162
0214E:  INCF   xC1,F
02150:  BTFSC  FD8.2
02152:  INCF   xC2,F
02154:  MOVF   xC2,W
02156:  SUBLW  03
02158:  BNC   2162
0215A:  BNZ   2138
0215C:  MOVF   xC1,W
0215E:  SUBLW  E7
02160:  BC    2138
....................         if(ReadETHReg(EIR).EIRbits.TXERIF || (AttemptCounter >= 1000u)) 
02162:  MOVLW  1C
02164:  MOVWF  xE1
02166:  MOVLB  0
02168:  CALL   0824
0216C:  MOVFF  01,2CF
02170:  MOVLW  00
02172:  MOVLB  2
02174:  BTFSC  01.1
02176:  MOVLW  01
02178:  XORLW  00
0217A:  BNZ   2190
0217C:  MOVF   xC2,W
0217E:  SUBLW  02
02180:  BTFSC  FD8.0
02182:  BRA    2314
02184:  XORLW  FF
02186:  BNZ   2190
02188:  MOVF   xC1,W
0218A:  SUBLW  E7
0218C:  BTFSC  FD8.0
0218E:  BRA    2314
....................         { 
....................             WORD_VAL ReadPtrSave; 
....................             WORD_VAL TXEnd; 
....................             TXSTATUS TXStatus; 
....................             BYTE i; 
....................  
....................             // Cancel the previous transmission if it has become stuck set 
....................             BFCReg(ECON1, ECON1_TXRTS); 
02190:  MOVLW  1F
02192:  MOVWF  xDB
02194:  MOVLW  08
02196:  MOVWF  xDC
02198:  MOVLB  0
0219A:  CALL   07C2
....................  
....................             // Save the current read pointer (controlled by application) 
....................             ReadPtrSave.v[0] = ReadETHReg(ERDPTL).Val; 
0219E:  MOVLB  2
021A0:  CLRF   xE1
021A2:  MOVLB  0
021A4:  CALL   0824
021A8:  MOVFF  01,2C3
....................             ReadPtrSave.v[1] = ReadETHReg(ERDPTH).Val; 
021AC:  MOVLW  01
021AE:  MOVLB  2
021B0:  MOVWF  xE1
021B2:  MOVLB  0
021B4:  CALL   0824
021B8:  MOVFF  01,2C4
....................  
....................             // Get the location of the transmit status vector 
....................             TXEnd.v[0] = ReadETHReg(ETXNDL).Val; 
021BC:  MOVLW  06
021BE:  MOVLB  2
021C0:  MOVWF  xE1
021C2:  MOVLB  0
021C4:  CALL   0824
021C8:  MOVFF  01,2C5
....................             TXEnd.v[1] = ReadETHReg(ETXNDH).Val; 
021CC:  MOVLW  07
021CE:  MOVLB  2
021D0:  MOVWF  xE1
021D2:  MOVLB  0
021D4:  CALL   0824
021D8:  MOVFF  01,2C6
....................             TXEnd.Val++; 
021DC:  MOVLB  2
021DE:  INCF   xC5,F
021E0:  BTFSC  FD8.2
021E2:  INCF   xC6,F
....................  
....................             // Read the transmit status vector 
....................             WriteReg(ERDPTL, TXEnd.v[0]); 
021E4:  CLRF   xE6
021E6:  MOVFF  2C5,2E7
021EA:  MOVLB  0
021EC:  CALL   084E
....................             WriteReg(ERDPTH, TXEnd.v[1]); 
021F0:  MOVLW  01
021F2:  MOVLB  2
021F4:  MOVWF  xE6
021F6:  MOVFF  2C6,2E7
021FA:  MOVLB  0
021FC:  CALL   084E
....................             MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
02200:  MOVLW  02
02202:  MOVLB  2
02204:  MOVWF  xD0
02206:  MOVLW  C7
02208:  MOVWF  xCF
0220A:  MOVFF  2D0,2E4
0220E:  MOVWF  xE3
02210:  CLRF   xE6
02212:  MOVLW  07
02214:  MOVWF  xE5
02216:  MOVLB  0
02218:  CALL   0E8E
....................  
....................             // Implement retransmission if a late collision occured (this can 
....................             // happen on B5 when certain link pulses arrive at the same time 
....................             // as the transmission) 
....................             for(i = 0; i < 16u; i++) 
0221C:  MOVLB  2
0221E:  CLRF   xCE
02220:  MOVF   xCE,W
02222:  SUBLW  0F
02224:  BNC   22F6
....................             { 
....................                 if(ReadETHReg(EIR).EIRbits.TXERIF && TXStatus.bits.LateCollision) 
02226:  MOVLW  1C
02228:  MOVWF  xE1
0222A:  MOVLB  0
0222C:  CALL   0824
02230:  MOVFF  01,2CF
02234:  MOVLW  00
02236:  MOVLB  2
02238:  BTFSC  01.1
0223A:  MOVLW  01
0223C:  XORLW  00
0223E:  BZ    22EC
02240:  BTFSS  xCA.5
02242:  BRA    22EC
....................                 { 
....................                     // Reset the TX logic 
....................                     BFSReg(ECON1, ECON1_TXRST); 
02244:  MOVLW  1F
02246:  MOVWF  xDB
02248:  MOVLW  80
0224A:  MOVWF  xDC
0224C:  MOVLB  0
0224E:  CALL   089C
....................                     BFCReg(ECON1, ECON1_TXRST); 
02252:  MOVLW  1F
02254:  MOVLB  2
02256:  MOVWF  xDB
02258:  MOVLW  80
0225A:  MOVWF  xDC
0225C:  MOVLB  0
0225E:  CALL   07C2
....................                     BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
02262:  MOVLW  1C
02264:  MOVLB  2
02266:  MOVWF  xDB
02268:  MOVLW  0A
0226A:  MOVWF  xDC
0226C:  MOVLB  0
0226E:  CALL   07C2
....................  
....................                     // Transmit the packet again 
....................                     BFSReg(ECON1, ECON1_TXRTS); 
02272:  MOVLW  1F
02274:  MOVLB  2
02276:  MOVWF  xDB
02278:  MOVLW  08
0227A:  MOVWF  xDC
0227C:  MOVLB  0
0227E:  CALL   089C
....................                     while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
02282:  MOVLW  1C
02284:  MOVLB  2
02286:  MOVWF  xE1
02288:  MOVLB  0
0228A:  CALL   0824
0228E:  MOVFF  01,2CF
02292:  MOVLB  2
02294:  MOVF   01,W
02296:  ANDLW  0A
02298:  BTFSS  FD8.2
0229A:  BRA    22A0
0229C:  MOVLB  0
0229E:  BRA    2282
....................  
....................                     // Cancel the previous transmission if it has become stuck set 
....................                     BFCReg(ECON1, ECON1_TXRTS); 
022A0:  MOVLW  1F
022A2:  MOVWF  xDB
022A4:  MOVLW  08
022A6:  MOVWF  xDC
022A8:  MOVLB  0
022AA:  CALL   07C2
....................  
....................                     // Read transmit status vector 
....................                     WriteReg(ERDPTL, TXEnd.v[0]); 
022AE:  MOVLB  2
022B0:  CLRF   xE6
022B2:  MOVFF  2C5,2E7
022B6:  MOVLB  0
022B8:  CALL   084E
....................                     WriteReg(ERDPTH, TXEnd.v[1]); 
022BC:  MOVLW  01
022BE:  MOVLB  2
022C0:  MOVWF  xE6
022C2:  MOVFF  2C6,2E7
022C6:  MOVLB  0
022C8:  CALL   084E
....................                     MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
022CC:  MOVLW  02
022CE:  MOVLB  2
022D0:  MOVWF  xD0
022D2:  MOVLW  C7
022D4:  MOVWF  xCF
022D6:  MOVFF  2D0,2E4
022DA:  MOVWF  xE3
022DC:  CLRF   xE6
022DE:  MOVLW  07
022E0:  MOVWF  xE5
022E2:  MOVLB  0
022E4:  CALL   0E8E
....................                 } 
022E8:  BRA    22F0
022EA:  MOVLB  2
....................                 else 
....................                 { 
....................                     break; 
022EC:  BRA    22F6
022EE:  MOVLB  0
....................                 } 
022F0:  MOVLB  2
022F2:  INCF   xCE,F
022F4:  BRA    2220
....................             } 
....................  
....................             // Restore the current read pointer 
....................             WriteReg(ERDPTL, ReadPtrSave.v[0]); 
022F6:  CLRF   xE6
022F8:  MOVFF  2C3,2E7
022FC:  MOVLB  0
022FE:  CALL   084E
....................             WriteReg(ERDPTH, ReadPtrSave.v[1]); 
02302:  MOVLW  01
02304:  MOVLB  2
02306:  MOVWF  xE6
02308:  MOVFF  2C4,2E7
0230C:  MOVLB  0
0230E:  CALL   084E
02312:  MOVLB  2
02314:  MOVLB  1
....................         } 
....................     } 
02316:  MOVLB  0
02318:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetReadPtrInRx(WORD offset) 
....................  * 
....................  * PreCondition:    A packet has been obtained by calling MACGetHeader() and 
....................  *                  getting a TRUE result. 
....................  * 
....................  * Input:           offset: WORD specifying how many bytes beyond the Ethernet 
....................  *                          header's type field to relocate the SPI read 
....................  *                          pointer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read pointer are updated.  All calls to 
....................  *                  MACGet() and MACGetArray() will use these new values. 
....................  * 
....................  * Note:            RXSTOP must be statically defined as being > RXSTART for 
....................  *                  this function to work correctly.  In other words, do not 
....................  *                  define an RX buffer which spans the 0x1FFF->0x0000 memory 
....................  *                  boundary. 
....................  *****************************************************************************/ 
.................... void MACSetReadPtrInRx(WORD offset) 
.................... { 
....................     WORD_VAL ReadPT; 
....................  
....................     // Determine the address of the beginning of the entire packet 
....................     // and adjust the address to the desired location 
....................     ReadPT.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
038E6:  MOVLW  14
038E8:  MOVLB  1
038EA:  ADDWF  x22,W
038EC:  MOVLB  2
038EE:  MOVWF  xA3
038F0:  MOVLW  00
038F2:  MOVLB  1
038F4:  ADDWFC x23,W
038F6:  MOVLB  2
038F8:  MOVWF  xA4
038FA:  MOVF   x9F,W
038FC:  ADDWF  xA3,W
038FE:  MOVWF  xA1
03900:  MOVF   xA0,W
03902:  ADDWFC xA4,W
03904:  MOVWF  xA2
....................  
....................     // Since the receive buffer is circular, adjust if a wraparound is needed 
....................     if(ReadPT.Val > RXSTOP) 
03906:  MOVF   xA2,W
03908:  SUBLW  16
0390A:  BC    391E
0390C:  XORLW  FF
0390E:  BNZ   3916
03910:  MOVF   xA1,W
03912:  SUBLW  E3
03914:  BC    391E
....................         ReadPT.Val -= RXSIZE; 
03916:  MOVLW  E4
03918:  SUBWF  xA1,F
0391A:  MOVLW  17
0391C:  SUBWFB xA2,F
....................  
....................     // Set the SPI read pointer to the new calculated value 
....................     WriteReg(ERDPTL, ReadPT.v[0]); 
0391E:  CLRF   xE6
03920:  MOVFF  2A1,2E7
03924:  MOVLB  0
03926:  CALL   084E
....................     WriteReg(ERDPTH, ReadPT.v[1]); 
0392A:  MOVLW  01
0392C:  MOVLB  2
0392E:  MOVWF  xE6
03930:  MOVFF  2A2,2E7
03934:  MOVLB  0
03936:  CALL   084E
0393A:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        PTR_BASE MACSetWritePtr(PTR_BASE Address) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           Address: Address to seek to 
....................  * 
....................  * Output:          WORD: Old EWRPT location 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI write pointer is updated.  All calls to 
....................  *                  MACPut() and MACPutArray() will use this new value. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PTR_BASE MACSetWritePtr(PTR_BASE address) 
.................... { 
....................     WORD_VAL oldVal; 
....................  
....................     oldVal.v[0] = ReadETHReg(EWRPTL).Val; 
*
00D6C:  MOVLW  02
00D6E:  MOVLB  2
00D70:  MOVWF  xE1
00D72:  MOVLB  0
00D74:  RCALL  0824
00D76:  MOVFF  01,2D2
....................     oldVal.v[1] = ReadETHReg(EWRPTH).Val; 
00D7A:  MOVLW  03
00D7C:  MOVLB  2
00D7E:  MOVWF  xE1
00D80:  MOVLB  0
00D82:  RCALL  0824
00D84:  MOVFF  01,2D3
....................  
....................     // Set the SPI write pointer to the new calculated value 
....................     WriteReg(EWRPTL, ((WORD_VAL*)&address)->v[0]); 
00D88:  MOVLW  02
00D8A:  MOVLB  2
00D8C:  MOVWF  xD5
00D8E:  MOVLW  D0
00D90:  MOVWF  xD4
00D92:  MOVWF  FE9
00D94:  MOVFF  2D5,FEA
00D98:  MOVFF  FEF,2D6
00D9C:  MOVLW  02
00D9E:  MOVWF  xE6
00DA0:  MOVFF  2D6,2E7
00DA4:  MOVLB  0
00DA6:  RCALL  084E
....................     WriteReg(EWRPTH, ((WORD_VAL*)&address)->v[1]); 
00DA8:  MOVLW  02
00DAA:  MOVLB  2
00DAC:  MOVWF  xD5
00DAE:  MOVLW  D0
00DB0:  MOVWF  xD4
00DB2:  MOVLW  01
00DB4:  ADDWF  xD4,W
00DB6:  MOVWF  FE9
00DB8:  MOVLW  00
00DBA:  ADDWFC xD5,W
00DBC:  MOVWF  FEA
00DBE:  MOVFF  FEF,2D6
00DC2:  MOVLW  03
00DC4:  MOVWF  xE6
00DC6:  MOVFF  2D6,2E7
00DCA:  MOVLB  0
00DCC:  RCALL  084E
....................  
....................     return oldVal.Val; 
00DCE:  MOVLB  2
00DD0:  MOVFF  2D2,01
00DD4:  MOVFF  2D3,02
00DD8:  MOVLB  0
00DDA:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        PTR_BASE MACSetReadPtr(PTR_BASE Address) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           Address: Address to seek to 
....................  * 
....................  * Output:          WORD: Old ERDPT value 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI write pointer is updated.  All calls to 
....................  *                  MACPut() and MACPutArray() will use this new value. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PTR_BASE MACSetReadPtr(PTR_BASE address) 
.................... { 
....................     WORD_VAL oldVal; 
....................  
....................     oldVal.v[0] = ReadETHReg(ERDPTL).Val; 
*
00E22:  MOVLB  2
00E24:  CLRF   xE1
00E26:  MOVLB  0
00E28:  RCALL  0824
00E2A:  MOVFF  01,2D2
....................     oldVal.v[1] = ReadETHReg(ERDPTH).Val; 
00E2E:  MOVLW  01
00E30:  MOVLB  2
00E32:  MOVWF  xE1
00E34:  MOVLB  0
00E36:  RCALL  0824
00E38:  MOVFF  01,2D3
....................  
....................     // Set the SPI write pointer to the new calculated value 
....................     WriteReg(ERDPTL, ((WORD_VAL*)&address)->v[0]); 
00E3C:  MOVLW  02
00E3E:  MOVLB  2
00E40:  MOVWF  xD5
00E42:  MOVLW  D0
00E44:  MOVWF  xD4
00E46:  MOVWF  FE9
00E48:  MOVFF  2D5,FEA
00E4C:  MOVFF  FEF,2D6
00E50:  CLRF   xE6
00E52:  MOVFF  2D6,2E7
00E56:  MOVLB  0
00E58:  RCALL  084E
....................     WriteReg(ERDPTH, ((WORD_VAL*)&address)->v[1]); 
00E5A:  MOVLW  02
00E5C:  MOVLB  2
00E5E:  MOVWF  xD5
00E60:  MOVLW  D0
00E62:  MOVWF  xD4
00E64:  MOVLW  01
00E66:  ADDWF  xD4,W
00E68:  MOVWF  FE9
00E6A:  MOVLW  00
00E6C:  ADDWFC xD5,W
00E6E:  MOVWF  FEA
00E70:  MOVFF  FEF,2D6
00E74:  MOVLW  01
00E76:  MOVWF  xE6
00E78:  MOVFF  2D6,2E7
00E7C:  MOVLB  0
00E7E:  RCALL  084E
....................  
....................     return oldVal.Val; 
00E80:  MOVLB  2
00E82:  MOVFF  2D2,01
00E86:  MOVFF  2D3,02
00E8A:  MOVLB  0
00E8C:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcRxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset  - Number of bytes beyond the beginning of the 
....................  *                          Ethernet data (first byte after the type field) 
....................  *                          where the checksum should begin 
....................  *                  len     - Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by RFC 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcRxChecksum(WORD offset, WORD len) 
.................... { 
....................     WORD_VAL temp; 
....................     WORD_VAL RDSave; 
....................  
....................     // Add the offset requested by firmware plus the Ethernet header 
....................     temp.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
054E2:  MOVLW  14
054E4:  MOVLB  1
054E6:  ADDWF  x22,W
054E8:  MOVLB  2
054EA:  MOVWF  x72
054EC:  MOVLW  00
054EE:  MOVLB  1
054F0:  ADDWFC x23,W
054F2:  MOVLB  2
054F4:  MOVWF  x73
054F6:  MOVF   x6A,W
054F8:  ADDWF  x72,W
054FA:  MOVWF  x6E
054FC:  MOVF   x6B,W
054FE:  ADDWFC x73,W
05500:  MOVWF  x6F
....................     if(temp.Val > RXSTOP)       // Adjust value if a wrap is needed 
05502:  MOVF   x6F,W
05504:  SUBLW  16
05506:  BC    551A
05508:  XORLW  FF
0550A:  BNZ   5512
0550C:  MOVF   x6E,W
0550E:  SUBLW  E3
05510:  BC    551A
....................     { 
....................         temp.Val -= RXSIZE; 
05512:  MOVLW  E4
05514:  SUBWF  x6E,F
05516:  MOVLW  17
05518:  SUBWFB x6F,F
....................     } 
....................  
....................     RDSave.v[0] = ReadETHReg(ERDPTL).Val; 
0551A:  CLRF   xE1
0551C:  MOVLB  0
0551E:  CALL   0824
05522:  MOVFF  01,270
....................     RDSave.v[1] = ReadETHReg(ERDPTH).Val; 
05526:  MOVLW  01
05528:  MOVLB  2
0552A:  MOVWF  xE1
0552C:  MOVLB  0
0552E:  CALL   0824
05532:  MOVFF  01,271
....................  
....................     WriteReg(ERDPTL, temp.v[0]); 
05536:  MOVLB  2
05538:  CLRF   xE6
0553A:  MOVFF  26E,2E7
0553E:  MOVLB  0
05540:  CALL   084E
....................     WriteReg(ERDPTH, temp.v[1]); 
05544:  MOVLW  01
05546:  MOVLB  2
05548:  MOVWF  xE6
0554A:  MOVFF  26F,2E7
0554E:  MOVLB  0
05550:  CALL   084E
....................  
....................     temp.Val = CalcIPBufferChecksum(len); 
05554:  MOVFF  26D,2C2
05558:  MOVFF  26C,2C1
0555C:  CALL   1F9A
05560:  MOVFF  02,26F
05564:  MOVFF  01,26E
....................  
....................     WriteReg(ERDPTL, RDSave.v[0]); 
05568:  MOVLB  2
0556A:  CLRF   xE6
0556C:  MOVFF  270,2E7
05570:  MOVLB  0
05572:  CALL   084E
....................     WriteReg(ERDPTH, RDSave.v[1]); 
05576:  MOVLW  01
05578:  MOVLB  2
0557A:  MOVWF  xE6
0557C:  MOVFF  271,2E7
05580:  MOVLB  0
05582:  CALL   084E
....................  
....................     return temp.Val; 
05586:  MOVLB  2
05588:  MOVFF  26E,01
0558C:  MOVFF  26F,02
05590:  MOVLB  0
05592:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    Read buffer pointer set to starting of checksum data 
....................  * 
....................  * Input:           len: Total number of bytes to calculate the checksum over. 
....................  *                       The first byte included in the checksum is the byte 
....................  *                       pointed to by ERDPT, which is updated by calls to 
....................  *                       MACSetReadPtr(), MACGet(), MACGetArray(), 
....................  *                       MACGetHeader(), etc. 
....................  * 
....................  * Output:          16-bit checksum as defined by RFC 793 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself.  The ENC28J60 has a hardware DMA module 
....................  *                  which can calculate the checksum faster than software, so 
....................  *                  this function replaces the CaclIPBufferChecksum() function 
....................  *                  defined in the helpers.c file.  Through the use of 
....................  *                  preprocessor defines, this replacement is automatic. 
....................  * 
....................  * Note:            This function works either in the RX buffer area or the TX 
....................  *                  buffer area.  No validation is done on the len parameter. 
....................  *****************************************************************************/ 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................     WORD_VAL Start; 
....................     DWORD_VAL Checksum = {0x00000000ul}; 
*
01F9A:  MOVLB  2
01F9C:  CLRF   xC5
01F9E:  CLRF   xC6
01FA0:  CLRF   xC7
01FA2:  CLRF   xC8
....................     WORD ChunkLen; 
....................     WORD DataBuffer[10]; 
....................     WORD *DataPtr; 
....................  
....................     // Save the SPI read pointer starting address 
....................     Start.v[0] = ReadETHReg(ERDPTL).Val; 
01FA4:  CLRF   xE1
01FA6:  MOVLB  0
01FA8:  CALL   0824
01FAC:  MOVFF  01,2C3
....................     Start.v[1] = ReadETHReg(ERDPTH).Val; 
01FB0:  MOVLW  01
01FB2:  MOVLB  2
01FB4:  MOVWF  xE1
01FB6:  MOVLB  0
01FB8:  CALL   0824
01FBC:  MOVFF  01,2C4
....................  
....................     while(len) 
01FC0:  MOVLB  2
01FC2:  MOVF   xC1,W
01FC4:  IORWF  xC2,W
01FC6:  BZ    2078
....................     { 
....................         // Obtain a chunk of data (less SPI overhead compared 
....................         // to requesting one byte at a time) 
....................         ChunkLen = len > sizeof(DataBuffer) ? sizeof(DataBuffer) : len; 
01FC8:  MOVF   xC2,F
01FCA:  BNZ   1FD2
01FCC:  MOVF   xC1,W
01FCE:  SUBLW  14
01FD0:  BC    1FD8
01FD2:  CLRF   03
01FD4:  MOVLW  14
01FD6:  BRA    1FDE
01FD8:  MOVFF  2C2,03
01FDC:  MOVF   xC1,W
01FDE:  MOVWF  xC9
01FE0:  MOVFF  03,2CA
....................         MACGetArray((BYTE*)DataBuffer, ChunkLen); 
01FE4:  MOVLW  02
01FE6:  MOVWF  xE2
01FE8:  MOVLW  CB
01FEA:  MOVWF  xE1
01FEC:  MOVFF  2E2,2E4
01FF0:  MOVWF  xE3
01FF2:  MOVFF  2CA,2E6
01FF6:  MOVFF  2C9,2E5
01FFA:  MOVLB  0
01FFC:  CALL   0E8E
....................  
....................         len -= ChunkLen; 
02000:  MOVLB  2
02002:  MOVF   xC9,W
02004:  SUBWF  xC1,F
02006:  MOVF   xCA,W
02008:  SUBWFB xC2,F
....................  
....................         // Take care of a last odd numbered data byte 
....................         if(((WORD_VAL*)&ChunkLen)->bits.b0) 
0200A:  MOVLW  02
0200C:  MOVWF  xE2
0200E:  MOVLW  C9
02010:  MOVWF  FE9
02012:  MOVFF  2E2,FEA
02016:  BTFSS  FEF.0
02018:  BRA    2032
....................         { 
....................             ((BYTE*)DataBuffer)[ChunkLen] = 0x00; 
0201A:  MOVLW  02
0201C:  MOVWF  xE2
0201E:  MOVLW  CB
02020:  ADDWF  xC9,W
02022:  MOVWF  FE9
02024:  MOVF   xE2,W
02026:  ADDWFC xCA,W
02028:  MOVWF  FEA
0202A:  CLRF   FEF
....................             ChunkLen++; 
0202C:  INCF   xC9,F
0202E:  BTFSC  FD8.2
02030:  INCF   xCA,F
....................         } 
....................  
....................         // Calculate the checksum over this chunk 
....................         DataPtr = DataBuffer; 
02032:  MOVLW  02
02034:  MOVWF  xE0
02036:  MOVLW  CB
02038:  MOVWF  xDF
....................         while(ChunkLen) 
0203A:  MOVF   xC9,W
0203C:  IORWF  xCA,W
0203E:  BZ    2076
....................         { 
....................             Checksum.Val += *DataPtr++; 
02040:  MOVFF  2E0,03
02044:  MOVFF  2DF,00
02048:  MOVLW  02
0204A:  ADDWF  xDF,F
0204C:  BTFSC  FD8.0
0204E:  INCF   xE0,F
02050:  MOVFF  00,FE9
02054:  MOVFF  03,FEA
02058:  MOVFF  FEC,03
0205C:  MOVF   FED,F
0205E:  MOVF   FEF,W
02060:  ADDWF  xC5,F
02062:  MOVF   03,W
02064:  ADDWFC xC6,F
02066:  MOVLW  00
02068:  ADDWFC xC7,F
0206A:  ADDWFC xC8,F
....................             ChunkLen -= 2; 
0206C:  MOVLW  02
0206E:  SUBWF  xC9,F
02070:  MOVLW  00
02072:  SUBWFB xCA,F
02074:  BRA    203A
....................         } 
02076:  BRA    1FC2
....................     } 
....................  
....................     // Restore old read pointer location 
....................     WriteReg(ERDPTL, Start.v[0]); 
02078:  CLRF   xE6
0207A:  MOVFF  2C3,2E7
0207E:  MOVLB  0
02080:  CALL   084E
....................     WriteReg(ERDPTH, Start.v[1]); 
02084:  MOVLW  01
02086:  MOVLB  2
02088:  MOVWF  xE6
0208A:  MOVFF  2C4,2E7
0208E:  MOVLB  0
02090:  CALL   084E
....................  
....................     // Do an end-around carry (one's complement arrithmatic) 
....................     Checksum.Val = (DWORD)Checksum.w[0] + (DWORD)Checksum.w[1]; 
02094:  MOVLB  2
02096:  CLRF   xE4
02098:  CLRF   xE3
0209A:  MOVFF  2C6,2E2
0209E:  MOVFF  2C5,2E1
020A2:  MOVFF  2C7,00
020A6:  MOVFF  2C8,01
020AA:  CLRF   02
020AC:  CLRF   03
020AE:  MOVF   xC7,W
020B0:  ADDWF  xC5,W
020B2:  MOVWF  xC5
020B4:  MOVF   xC8,W
020B6:  ADDWFC xC6,W
020B8:  MOVWF  xC6
020BA:  MOVF   02,W
020BC:  ADDWFC xE3,W
020BE:  MOVWF  xC7
020C0:  MOVF   03,W
020C2:  ADDWFC xE4,W
020C4:  MOVWF  xC8
....................  
....................     // Do another end-around carry in case if the prior add 
....................     // caused a carry out 
....................     Checksum.w[0] += Checksum.w[1]; 
020C6:  MOVF   xC7,W
020C8:  ADDWF  xC5,F
020CA:  MOVF   xC8,W
020CC:  ADDWFC xC6,F
....................  
....................     // Return the resulting checksum 
....................     return ~Checksum.w[0]; 
020CE:  MOVFF  2C6,03
020D2:  COMF   03,F
020D4:  MOVF   xC5,W
020D6:  XORLW  FF
020D8:  MOVWF  01
020DA:  MOVFF  03,02
020DE:  MOVLB  0
020E0:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACMemCopyAsync(PTR_BASE destAddr, PTR_BASE sourceAddr, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           destAddr:   Destination address in the Ethernet memory to 
....................  *                              copy to.  If (PTR_BASE)-1 is specified, the  
....................  *                        current EWRPT value will be used instead. 
....................  *                  sourceAddr: Source address to read from.  If (PTR_BASE)-1 is 
....................  *                              specified, the current ERDPT value will be used 
....................  *                              instead. 
....................  *                  len:        Number of bytes to copy 
....................  * 
....................  * Output:          Byte read from the ENC28J60's RAM 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Bytes are asynchrnously transfered within the buffer.  Call 
....................  *                  MACIsMemCopyDone() to see when the transfer is complete. 
....................  * 
....................  * Note:            If a prior transfer is already in progress prior to 
....................  *                  calling this function, this function will block until it 
....................  *                  can start this transfer. 
....................  * 
....................  *                  If (PTR_BASE)-1 is used for the sourceAddr or destAddr 
....................  *                  parameters, then that pointer will get updated with the 
....................  *                  next address after the read or write. 
....................  *****************************************************************************/ 
.................... void MACMemCopyAsync(PTR_BASE destAddr, PTR_BASE sourceAddr, WORD len) 
*
00F2E:  MOVLB  2
00F30:  BCF    xDA.0
00F32:  BCF    xDA.1
.................... { 
....................     WORD_VAL ReadSave, WriteSave; 
....................     BOOL UpdateWritePointer = FALSE; 
....................     BOOL UpdateReadPointer = FALSE; 
....................  
....................     if(destAddr == (PTR_BASE)-1) 
00F34:  INCFSZ xD0,W
00F36:  BRA    0F5C
00F38:  INCFSZ xD1,W
00F3A:  BRA    0F5C
....................     { 
....................         UpdateWritePointer = TRUE; 
00F3C:  BSF    xDA.0
....................         destAddr = ReadETHReg(EWRPTL).Val; 
00F3E:  MOVLW  02
00F40:  MOVWF  xE1
00F42:  MOVLB  0
00F44:  RCALL  0824
00F46:  MOVLB  2
00F48:  CLRF   xD1
00F4A:  MOVFF  01,2D0
....................         ((BYTE*)&destAddr)[1] = ReadETHReg(EWRPTH).Val; 
00F4E:  MOVLW  03
00F50:  MOVWF  xE1
00F52:  MOVLB  0
00F54:  RCALL  0824
00F56:  MOVFF  01,2D1
00F5A:  MOVLB  2
....................     } 
....................     if(sourceAddr == (PTR_BASE)-1) 
00F5C:  INCFSZ xD2,W
00F5E:  BRA    0F82
00F60:  INCFSZ xD3,W
00F62:  BRA    0F82
....................     { 
....................         UpdateReadPointer = TRUE; 
00F64:  BSF    xDA.1
....................         sourceAddr = ReadETHReg(ERDPTL).Val; 
00F66:  CLRF   xE1
00F68:  MOVLB  0
00F6A:  RCALL  0824
00F6C:  MOVLB  2
00F6E:  CLRF   xD3
00F70:  MOVFF  01,2D2
....................         ((BYTE*)&sourceAddr)[1] = ReadETHReg(ERDPTH).Val; 
00F74:  MOVLW  01
00F76:  MOVWF  xE1
00F78:  MOVLB  0
00F7A:  RCALL  0824
00F7C:  MOVFF  01,2D3
00F80:  MOVLB  2
....................     } 
....................  
....................     // Handle special conditions where len == 0 or len == 1 
....................     // The DMA module is not capable of handling those corner cases 
....................     if(len <= 1u) 
00F82:  MOVF   xD5,F
00F84:  BTFSS  FD8.2
00F86:  BRA    106A
00F88:  MOVF   xD4,W
00F8A:  SUBLW  01
00F8C:  BTFSS  FD8.0
00F8E:  BRA    106A
....................     { 
....................         if(!UpdateReadPointer) 
00F90:  BTFSC  xDA.1
00F92:  BRA    0FAE
....................         { 
....................             ReadSave.v[0] = ReadETHReg(ERDPTL).Val; 
00F94:  CLRF   xE1
00F96:  MOVLB  0
00F98:  RCALL  0824
00F9A:  MOVFF  01,2D6
....................             ReadSave.v[1] = ReadETHReg(ERDPTH).Val; 
00F9E:  MOVLW  01
00FA0:  MOVLB  2
00FA2:  MOVWF  xE1
00FA4:  MOVLB  0
00FA6:  RCALL  0824
00FA8:  MOVFF  01,2D7
00FAC:  MOVLB  2
....................         } 
....................         if(!UpdateWritePointer) 
00FAE:  BTFSC  xDA.0
00FB0:  BRA    0FCE
....................         { 
....................             WriteSave.v[0] = ReadETHReg(EWRPTL).Val; 
00FB2:  MOVLW  02
00FB4:  MOVWF  xE1
00FB6:  MOVLB  0
00FB8:  RCALL  0824
00FBA:  MOVFF  01,2D8
....................             WriteSave.v[1] = ReadETHReg(EWRPTH).Val; 
00FBE:  MOVLW  03
00FC0:  MOVLB  2
00FC2:  MOVWF  xE1
00FC4:  MOVLB  0
00FC6:  RCALL  0824
00FC8:  MOVFF  01,2D9
00FCC:  MOVLB  2
....................         } 
....................         WriteReg(ERDPTL, ((BYTE*)&sourceAddr)[0]); 
00FCE:  CLRF   xE6
00FD0:  MOVFF  2D2,2E7
00FD4:  MOVLB  0
00FD6:  RCALL  084E
....................         WriteReg(ERDPTH, ((BYTE*)&sourceAddr)[1]); 
00FD8:  MOVLW  01
00FDA:  MOVLB  2
00FDC:  MOVWF  xE6
00FDE:  MOVFF  2D3,2E7
00FE2:  MOVLB  0
00FE4:  RCALL  084E
....................         WriteReg(EWRPTL, ((BYTE*)&destAddr)[0]); 
00FE6:  MOVLW  02
00FE8:  MOVLB  2
00FEA:  MOVWF  xE6
00FEC:  MOVFF  2D0,2E7
00FF0:  MOVLB  0
00FF2:  RCALL  084E
....................         WriteReg(EWRPTH, ((BYTE*)&destAddr)[1]); 
00FF4:  MOVLW  03
00FF6:  MOVLB  2
00FF8:  MOVWF  xE6
00FFA:  MOVFF  2D1,2E7
00FFE:  MOVLB  0
01000:  RCALL  084E
....................         while(len--) 
01002:  MOVLB  2
01004:  MOVFF  2D5,03
01008:  MOVF   xD4,W
0100A:  BTFSC  FD8.2
0100C:  DECF   xD5,F
0100E:  DECF   xD4,F
01010:  IORWF  03,W
01012:  BZ    1026
....................             MACPut(MACGet()); 
01014:  MOVLB  0
01016:  RCALL  0F04
01018:  MOVFF  01,2DB
0101C:  MOVFF  01,2E4
01020:  RCALL  0878
01022:  BRA    1002
01024:  MOVLB  2
....................         if(!UpdateReadPointer) 
01026:  BTFSC  xDA.1
01028:  BRA    1044
....................         { 
....................             WriteReg(ERDPTL, ReadSave.v[0]); 
0102A:  CLRF   xE6
0102C:  MOVFF  2D6,2E7
01030:  MOVLB  0
01032:  RCALL  084E
....................             WriteReg(ERDPTH, ReadSave.v[1]); 
01034:  MOVLW  01
01036:  MOVLB  2
01038:  MOVWF  xE6
0103A:  MOVFF  2D7,2E7
0103E:  MOVLB  0
01040:  RCALL  084E
01042:  MOVLB  2
....................         } 
....................         if(!UpdateWritePointer) 
01044:  BTFSC  xDA.0
01046:  BRA    1068
....................         { 
....................             WriteReg(EWRPTL, WriteSave.v[0]); 
01048:  MOVLW  02
0104A:  MOVWF  xE6
0104C:  MOVFF  2D8,2E7
01050:  MOVLB  0
01052:  CALL   084E
....................             WriteReg(EWRPTH, WriteSave.v[1]); 
01056:  MOVLW  03
01058:  MOVLB  2
0105A:  MOVWF  xE6
0105C:  MOVFF  2D9,2E7
01060:  MOVLB  0
01062:  CALL   084E
01066:  MOVLB  2
....................         } 
....................     } 
01068:  BRA    11BC
....................     else 
....................     { 
....................         if(UpdateWritePointer) 
0106A:  BTFSS  xDA.0
0106C:  BRA    109A
....................         { 
....................             WriteSave.Val = destAddr + len; 
0106E:  MOVF   xD4,W
01070:  ADDWF  xD0,W
01072:  MOVWF  xD8
01074:  MOVF   xD5,W
01076:  ADDWFC xD1,W
01078:  MOVWF  xD9
....................             WriteReg(EWRPTL, WriteSave.v[0]); 
0107A:  MOVLW  02
0107C:  MOVWF  xE6
0107E:  MOVFF  2D8,2E7
01082:  MOVLB  0
01084:  CALL   084E
....................             WriteReg(EWRPTH, WriteSave.v[1]); 
01088:  MOVLW  03
0108A:  MOVLB  2
0108C:  MOVWF  xE6
0108E:  MOVFF  2D9,2E7
01092:  MOVLB  0
01094:  CALL   084E
01098:  MOVLB  2
....................         } 
....................         len += sourceAddr - 1; 
0109A:  MOVLW  01
0109C:  SUBWF  xD2,W
0109E:  MOVWF  00
010A0:  MOVLW  00
010A2:  SUBWFB xD3,W
010A4:  MOVWF  03
010A6:  MOVF   00,W
010A8:  ADDWF  xD4,F
010AA:  MOVF   03,W
010AC:  ADDWFC xD5,F
....................         while(ReadETHReg(ECON1).ECON1bits.DMAST); 
010AE:  MOVLW  1F
010B0:  MOVWF  xE1
010B2:  MOVLB  0
010B4:  CALL   0824
010B8:  MOVFF  01,2DB
010BC:  MOVLW  00
010BE:  MOVLB  2
010C0:  BTFSC  01.5
010C2:  MOVLW  01
010C4:  XORLW  00
010C6:  BNZ   10AE
....................         WriteReg(EDMASTL, ((BYTE*)&sourceAddr)[0]); 
010C8:  MOVLW  10
010CA:  MOVWF  xE6
010CC:  MOVFF  2D2,2E7
010D0:  MOVLB  0
010D2:  CALL   084E
....................         WriteReg(EDMASTH, ((BYTE*)&sourceAddr)[1]); 
010D6:  MOVLW  11
010D8:  MOVLB  2
010DA:  MOVWF  xE6
010DC:  MOVFF  2D3,2E7
010E0:  MOVLB  0
010E2:  CALL   084E
....................         WriteReg(EDMADSTL, ((BYTE*)&destAddr)[0]); 
010E6:  MOVLW  14
010E8:  MOVLB  2
010EA:  MOVWF  xE6
010EC:  MOVFF  2D0,2E7
010F0:  MOVLB  0
010F2:  CALL   084E
....................         WriteReg(EDMADSTH, ((BYTE*)&destAddr)[1]); 
010F6:  MOVLW  15
010F8:  MOVLB  2
010FA:  MOVWF  xE6
010FC:  MOVFF  2D1,2E7
01100:  MOVLB  0
01102:  CALL   084E
....................         if((sourceAddr <= RXSTOP) && (len > RXSTOP)) //&& (sourceAddr >= RXSTART)) 
01106:  MOVLB  2
01108:  MOVF   xD3,W
0110A:  SUBLW  17
0110C:  BNC   112E
0110E:  BNZ   1116
01110:  MOVF   xD2,W
01112:  SUBLW  E3
01114:  BNC   112E
01116:  MOVF   xD5,W
01118:  SUBLW  16
0111A:  BC    112E
0111C:  XORLW  FF
0111E:  BNZ   1126
01120:  MOVF   xD4,W
01122:  SUBLW  E3
01124:  BC    112E
....................             len -= RXSIZE; 
01126:  MOVLW  E4
01128:  SUBWF  xD4,F
0112A:  MOVLW  17
0112C:  SUBWFB xD5,F
....................         WriteReg(EDMANDL, ((BYTE*)&len)[0]); 
0112E:  MOVLW  12
01130:  MOVWF  xE6
01132:  MOVFF  2D4,2E7
01136:  MOVLB  0
01138:  CALL   084E
....................         WriteReg(EDMANDH, ((BYTE*)&len)[1]); 
0113C:  MOVLW  13
0113E:  MOVLB  2
01140:  MOVWF  xE6
01142:  MOVFF  2D5,2E7
01146:  MOVLB  0
01148:  CALL   084E
....................         BFCReg(ECON1, ECON1_CSUMEN); 
0114C:  MOVLW  1F
0114E:  MOVLB  2
01150:  MOVWF  xDB
01152:  MOVLW  10
01154:  MOVWF  xDC
01156:  MOVLB  0
01158:  CALL   07C2
....................         BFSReg(ECON1, ECON1_DMAST); 
0115C:  MOVLW  1F
0115E:  MOVLB  2
01160:  MOVWF  xDB
01162:  MOVLW  20
01164:  MOVWF  xDC
01166:  MOVLB  0
01168:  CALL   089C
....................         if(UpdateReadPointer) 
0116C:  MOVLB  2
0116E:  BTFSS  xDA.1
01170:  BRA    11BC
....................         { 
....................             len++; 
01172:  INCF   xD4,F
01174:  BTFSC  FD8.2
01176:  INCF   xD5,F
....................             if((sourceAddr <= RXSTOP) && (len > RXSTOP)) //&& (sourceAddr >= RXSTART)) 
01178:  MOVF   xD3,W
0117A:  SUBLW  17
0117C:  BNC   119E
0117E:  BNZ   1186
01180:  MOVF   xD2,W
01182:  SUBLW  E3
01184:  BNC   119E
01186:  MOVF   xD5,W
01188:  SUBLW  16
0118A:  BC    119E
0118C:  XORLW  FF
0118E:  BNZ   1196
01190:  MOVF   xD4,W
01192:  SUBLW  E3
01194:  BC    119E
....................                 len -= RXSIZE; 
01196:  MOVLW  E4
01198:  SUBWF  xD4,F
0119A:  MOVLW  17
0119C:  SUBWFB xD5,F
....................             WriteReg(ERDPTL, ((BYTE*)&len)[0]); 
0119E:  CLRF   xE6
011A0:  MOVFF  2D4,2E7
011A4:  MOVLB  0
011A6:  CALL   084E
....................             WriteReg(ERDPTH, ((BYTE*)&len)[1]); 
011AA:  MOVLW  01
011AC:  MOVLB  2
011AE:  MOVWF  xE6
011B0:  MOVFF  2D5,2E7
011B4:  MOVLB  0
011B6:  CALL   084E
011BA:  MOVLB  2
....................         } 
....................     } 
011BC:  MOVLB  0
011BE:  RETURN 0
.................... } 
....................  
.................... BOOL MACIsMemCopyDone(void) 
.................... { 
....................     return !ReadETHReg(ECON1).ECON1bits.DMAST; 
011C0:  MOVLW  1F
011C2:  MOVLB  2
011C4:  MOVWF  xE1
011C6:  MOVLB  0
011C8:  CALL   0824
011CC:  MOVFF  01,2D0
011D0:  MOVLW  00
011D2:  MOVLB  2
011D4:  BTFSC  01.5
011D6:  MOVLW  01
011D8:  XORLW  00
011DA:  BZ    11E0
011DC:  MOVLW  00
011DE:  BRA    11E2
011E0:  MOVLW  01
011E2:  MOVWF  01
011E4:  MOVLB  0
011E6:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE MACGet() 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Byte read from the ENC28J60's RAM 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACGet returns the byte pointed to by ERDPT and 
....................  *                  increments ERDPT so MACGet() can be called again.  The 
....................  *                  increment will follow the receive buffer wrapping boundary. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE MACGet() 
.................... { 
....................     BYTE Result; 
....................  
....................     ENC_CS_IO = 0; 
*
00F04:  BCF    F8C.1
....................    ClearSPIDoneFlag(); 
00F06:  BCF    F9E.3
....................  
....................     #if defined(__C32__) 
....................     { 
....................         // Send the opcode and read a byte in one 16-bit operation 
....................         ENC_SPICON1bits.MODE16 = 1; 
....................         ENC_SSPBUF = RBM<<8 | 0x00; // Send Read Buffer Memory command plus 8 dummy bits to generate clocks for the return result 
....................         WaitForDataByte();          // Wait until WORD is transmitted 
....................         ENC_SPICON1bits.MODE16 = 0; 
....................     } 
....................     #elif defined(__C30__) 
....................     { 
....................         // Send the opcode and read a byte in one 16-bit operation 
....................         ENC_SPISTATbits.SPIEN = 0; 
....................         ENC_SPICON1bits.MODE16 = 1; 
....................         ENC_SPISTATbits.SPIEN = 1; 
....................         ENC_SSPBUF = RBM<<8 | 0x00; // Send Read Buffer Memory command plus 8 dummy bits to generate clocks for the return result 
....................         WaitForDataByte();          // Wait until WORD is transmitted 
....................         ENC_SPISTATbits.SPIEN = 0; 
....................         ENC_SPICON1bits.MODE16 = 0; 
....................         ENC_SPISTATbits.SPIEN = 1; 
....................     } 
....................     #else 
....................     { 
....................         // Send the opcode and read a byte in two 8-bit operations 
....................         ENC_SSPBUF = RBM; 
00F08:  MOVLW  3A
00F0A:  MOVWF  FC9
....................         WaitForDataByte();      // Wait until opcode/address is transmitted. 
00F0C:  BTFSS  F9E.3
00F0E:  BRA    0F0C
00F10:  BCF    F9E.3
....................         Result = ENC_SSPBUF; 
00F12:  MOVFF  FC9,2DB
....................  
....................         ENC_SSPBUF = 0;         // Send a dummy byte to receive the register 
00F16:  CLRF   FC9
....................                                 //   contents. 
....................         WaitForDataByte();      // Wait until register is received. 
00F18:  BTFSS  F9E.3
00F1A:  BRA    0F18
00F1C:  BCF    F9E.3
....................     } 
....................     #endif 
....................  
....................     Result = ENC_SSPBUF; 
00F1E:  MOVFF  FC9,2DB
....................     ENC_CS_IO = 1; 
00F22:  BSF    F8C.1
....................  
....................     return Result; 
00F24:  MOVLB  2
00F26:  MOVFF  2DB,01
00F2A:  MOVLB  0
00F2C:  RETURN 0
.................... }//end MACGet 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           *val: Pointer to storage location 
....................  *                  len:  Number of bytes to read from the data buffer. 
....................  * 
....................  * Output:          Byte(s) of data read from the data buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Burst reads several sequential bytes from the data buffer 
....................  *                  and places them into local memory.  With SPI burst support, 
....................  *                  it performs much faster than multiple MACGet() calls. 
....................  *                  ERDPT is incremented after each byte, following the same 
....................  *                  rules as MACGet(). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetArray(BYTE *val, WORD len) 
.................... { 
.................... // Workaround needed on HPC Explorer (classic) board to prevent interference 
.................... // with I2C temperature sensor on the same SPI wires 
.................... #if defined(__18F8722) || defined(_18F8722) ||  defined(__18F8723) || defined(_18F8723) 
....................     WORD i; 
....................     volatile BYTE Dummy; 
....................  
....................     i = len; 
....................     Dummy = 0xFF; 
....................     ClearSPIDoneFlag(); 
....................     while(i--) 
....................     { 
....................         if(((BYTE_VAL*)&Dummy)->bits.b0) 
....................         { 
....................             // End bust operation 
....................             ENC_CS_IO = 1; 
....................             ((BYTE_VAL*)&Dummy)->bits.b0 = 0; 
....................  
....................             // Start the burst operation 
....................             ENC_CS_IO = 0; 
....................             ENC_SSPBUF = RBM;       // Send the Read Buffer Memory opcode. 
....................             WaitForDataByte();      // Wait until opcode/address is transmitted. 
....................         } 
....................         else 
....................             Dummy = 0xFF; 
....................  
....................         ENC_SSPBUF = 0;     // Send a dummy byte to receive a byte 
....................         if(val) 
....................         { 
....................             WaitForDataByte();  // Wait until byte is received. 
....................             *val++ = ENC_SSPBUF; 
....................         } 
....................         else 
....................         { 
....................             WaitForDataByte();  // Wait until byte is received. 
....................         } 
....................     } 
....................  
....................     ENC_CS_IO = 1; 
....................  
....................     return len; 
.................... #else 
....................     WORD i; 
....................     volatile BYTE Dummy; 
....................  
....................     // Start the burst operation 
....................     ENC_CS_IO = 0; 
*
00E8E:  BCF    F8C.1
....................     ClearSPIDoneFlag(); 
00E90:  BCF    F9E.3
....................     ENC_SSPBUF = RBM;       // Send the Read Buffer Memory opcode. 
00E92:  MOVLW  3A
00E94:  MOVWF  FC9
....................     i = 0; 
00E96:  MOVLB  2
00E98:  CLRF   xE8
00E9A:  CLRF   xE7
....................     if(val) 
00E9C:  MOVF   xE3,W
00E9E:  IORWF  xE4,W
00EA0:  BZ    0EAA
....................         val--; 
00EA2:  MOVF   xE3,W
00EA4:  BTFSC  FD8.2
00EA6:  DECF   xE4,F
00EA8:  DECF   xE3,F
....................     WaitForDataByte();      // Wait until opcode/address is transmitted. 
00EAA:  BTFSS  F9E.3
00EAC:  BRA    0EAA
00EAE:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
00EB0:  MOVFF  FC9,2E9
....................  
....................     #if defined(__C32__) 
....................     { 
....................         DWORD_VAL dwv; 
....................  
....................         // Read the data, 4 bytes at a time, for as long as possible 
....................         if(len >= 4) 
....................         { 
....................             ENC_SPICON1bits.MODE32 = 1; 
....................             while(1) 
....................             { 
....................                 ENC_SSPBUF = 0x00000000;    // Send a dummy DWORD to generate 32 clocks 
....................                 i += 4; 
....................                 WaitForDataByte();         // Wait until DWORD is transmitted 
....................                 dwv.Val = ENC_SSPBUF; 
....................                 if(val) 
....................                 { 
....................                     *(++val) = dwv.v[3]; 
....................                     *(++val) = dwv.v[2]; 
....................                     *(++val) = dwv.v[1]; 
....................                     *(++val) = dwv.v[0]; 
....................                 } 
....................                 if(len - i < 4) 
....................                     break; 
....................             }; 
....................             ENC_SPICON1bits.MODE32 = 0; 
....................         } 
....................     } 
....................     #elif defined(__C30__) 
....................     { 
....................         WORD_VAL wv; 
....................  
....................         // Read the data, 2 bytes at a time, for as long as possible 
....................         if(len >= 2) 
....................         { 
....................             ENC_SPISTATbits.SPIEN = 0; 
....................             ENC_SPICON1bits.MODE16 = 1; 
....................             ENC_SPISTATbits.SPIEN = 1; 
....................             while(1) 
....................             { 
....................                 ENC_SSPBUF = 0x0000;    // Send a dummy WORD to generate 32 clocks 
....................                 i += 2; 
....................                 WaitForDataByte();      // Wait until WORD is transmitted 
....................                 wv.Val = ENC_SSPBUF; 
....................                 if(val) 
....................                 { 
....................                     *(++val) = wv.v[1]; 
....................                     *(++val) = wv.v[0]; 
....................                 } 
....................                 if(len - i < 2) 
....................                     break; 
....................             }; 
....................             ENC_SPISTATbits.SPIEN = 0; 
....................             ENC_SPICON1bits.MODE16 = 0; 
....................             ENC_SPISTATbits.SPIEN = 1; 
....................         } 
....................     } 
....................     #endif 
....................  
....................     // Read the data 
....................     while(i<len) 
00EB4:  MOVF   xE8,W
00EB6:  SUBWF  xE6,W
00EB8:  BNC   0EF6
00EBA:  BNZ   0EC2
00EBC:  MOVF   xE5,W
00EBE:  SUBWF  xE7,W
00EC0:  BC    0EF6
....................     { 
....................         ENC_SSPBUF = 0;     // Send a dummy byte to receive a byte 
00EC2:  CLRF   FC9
....................         i++; 
00EC4:  INCF   xE7,F
00EC6:  BTFSC  FD8.2
00EC8:  INCF   xE8,F
....................         if(val) 
00ECA:  MOVF   xE3,W
00ECC:  IORWF  xE4,W
00ECE:  BZ    0EEA
....................         { 
....................             val++; 
00ED0:  INCF   xE3,F
00ED2:  BTFSC  FD8.2
00ED4:  INCF   xE4,F
....................             WaitForDataByte();  // Wait until byte is received. 
00ED6:  BTFSS  F9E.3
00ED8:  BRA    0ED6
00EDA:  BCF    F9E.3
....................             *val = ENC_SSPBUF; 
00EDC:  MOVFF  2E3,FE9
00EE0:  MOVFF  2E4,FEA
00EE4:  MOVFF  FC9,FEF
....................         } 
00EE8:  BRA    0EF4
....................         else 
....................         { 
....................             WaitForDataByte();  // Wait until byte is received. 
00EEA:  BTFSS  F9E.3
00EEC:  BRA    0EEA
00EEE:  BCF    F9E.3
....................             Dummy = ENC_SSPBUF; 
00EF0:  MOVFF  FC9,2E9
....................         } 
00EF4:  BRA    0EB4
....................     }; 
....................  
....................     // Terminate the burst operation 
....................     ENC_CS_IO = 1; 
00EF6:  BSF    F8C.1
....................  
....................     return i; 
00EF8:  MOVFF  2E7,01
00EFC:  MOVFF  2E8,02
.................... #endif 
00F00:  MOVLB  0
00F02:  RETURN 0
.................... }//end MACGetArray 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPut(BYTE val) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           Byte to write into the ENC28J60 buffer memory 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPut outputs the Write Buffer Memory opcode/constant 
....................  *                  (8 bits) and data to write (8 bits) over the SPI. 
....................  *                  EWRPT is incremented after the write. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPut(BYTE val) 
.................... { 
....................     volatile BYTE Dummy; 
....................  
....................     ENC_CS_IO = 0; 
*
00878:  BCF    F8C.1
....................     ClearSPIDoneFlag(); 
0087A:  BCF    F9E.3
....................  
....................     #if defined(__C32__) 
....................     { 
....................         // Send the Write Buffer Memory and data, in on 16-bit write 
....................         ENC_SPICON1bits.MODE16 = 1; 
....................         ENC_SSPBUF = (WBM<<8) | (WORD)val;  // Start sending the WORD 
....................         WaitForDataByte();                  // Wait until WORD is transmitted 
....................         ENC_SPICON1bits.MODE16 = 0; 
....................     } 
....................     #elif defined(__C30__) 
....................     { 
....................         // Send the Write Buffer Memory and data, in on 16-bit write 
....................         ENC_SPISTATbits.SPIEN = 0; 
....................         ENC_SPICON1bits.MODE16 = 1; 
....................         ENC_SPISTATbits.SPIEN = 1; 
....................         ENC_SSPBUF = (WBM<<8) | (WORD)val;  // Start sending the WORD 
....................         WaitForDataByte();                  // Wait until WORD is transmitted 
....................         ENC_SPISTATbits.SPIEN = 0; 
....................         ENC_SPICON1bits.MODE16 = 0; 
....................         ENC_SPISTATbits.SPIEN = 1; 
....................     } 
....................     #else 
....................     { 
....................         ENC_SSPBUF = WBM;       // Send the opcode and constant. 
0087C:  MOVLW  7A
0087E:  MOVWF  FC9
....................         WaitForDataByte();      // Wait until opcode/constant is transmitted. 
00880:  BTFSS  F9E.3
00882:  BRA    0880
00884:  BCF    F9E.3
....................         Dummy = ENC_SSPBUF; 
00886:  MOVFF  FC9,2E5
....................         ENC_SSPBUF = val;       // Send the byte to be writen. 
0088A:  MOVFF  2E4,FC9
....................         WaitForDataByte();      // Wait until finished transmitting 
0088E:  BTFSS  F9E.3
00890:  BRA    088E
00892:  BCF    F9E.3
....................     } 
....................     #endif 
....................  
....................     Dummy = ENC_SSPBUF; 
00894:  MOVFF  FC9,2E5
....................     ENC_CS_IO = 1; 
00898:  BSF    F8C.1
0089A:  RETURN 0
.................... }//end MACPut 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPutArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           *val: Pointer to source of bytes to copy. 
....................  *                  len:  Number of bytes to write to the data buffer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPutArray writes several sequential bytes to the 
....................  *                  ENC28J60 RAM.  It performs faster than multiple MACPut() 
....................  *                  calls.  EWRPT is incremented by len. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPutArray(BYTE *val, WORD len) 
.................... { 
.................... // Workaround needed on HPC Explorer (classic) board to prevent interference 
.................... // with I2C temperature sensor on the same SPI wires 
.................... #if defined(__18F8722) || defined(_18F8722) ||  defined(__18F8723) || defined(_18F8723) 
....................     WORD i; 
....................     volatile BYTE Dummy; 
....................  
....................     i = len; 
....................     Dummy = 0xFF; 
....................     ClearSPIDoneFlag(); 
....................     while(i--) 
....................     { 
....................         if(((BYTE_VAL*)&Dummy)->bits.b0) 
....................         { 
....................             // End bust operation 
....................             ENC_CS_IO = 1; 
....................             ((BYTE_VAL*)&Dummy)->bits.b0 = 0; 
....................  
....................             // Start the burst operation 
....................             ENC_CS_IO = 0; 
....................             ENC_SSPBUF = WBM;       // Send the Read Buffer Memory opcode. 
....................             WaitForDataByte();      // Wait until opcode/address is transmitted. 
....................         } 
....................         else 
....................             Dummy = 0xFF; 
....................  
....................         ENC_SSPBUF = *val++;    // Send byte 
....................         WaitForDataByte();      // Wait until byte is sent 
....................     } 
....................  
....................     ENC_CS_IO = 1; 
....................  
....................     return; 
.................... #else 
....................     volatile BYTE Dummy; 
....................  
....................     // Select the chip and send the proper opcode 
....................     ENC_CS_IO = 0; 
*
00DDC:  BCF    F8C.1
....................     ClearSPIDoneFlag(); 
00DDE:  BCF    F9E.3
....................     ENC_SSPBUF = WBM;       // Send the Write Buffer Memory opcode 
00DE0:  MOVLW  7A
00DE2:  MOVWF  FC9
....................     WaitForDataByte();      // Wait until opcode/constant is transmitted. 
00DE4:  BTFSS  F9E.3
00DE6:  BRA    0DE4
00DE8:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
00DEA:  MOVFF  FC9,2E9
....................  
....................     #if defined(__C32__) 
....................     { 
....................         DWORD_VAL dwv; 
....................  
....................         // Send the data, 4 bytes at a time, for as long as possible 
....................         if(len >= 4) 
....................         { 
....................             dwv.v[3] = *val++; 
....................             dwv.v[2] = *val++; 
....................             dwv.v[1] = *val++; 
....................             dwv.v[0] = *val++; 
....................             ENC_SPICON1bits.MODE32 = 1; 
....................             while(1) 
....................             { 
....................                 ENC_SSPBUF = dwv.Val;       // Start sending the DWORD 
....................                 len -= 4; 
....................                 if(len < 4) 
....................                     break; 
....................                 dwv.v[3] = *val++; 
....................                 dwv.v[2] = *val++; 
....................                 dwv.v[1] = *val++; 
....................                 dwv.v[0] = *val++; 
....................                 WaitForDataByte();          // Wait until DWORD is transmitted 
....................                 Dummy = ENC_SSPBUF; 
....................             }; 
....................             WaitForDataByte();              // Wait until DWORD is transmitted 
....................             Dummy = ENC_SSPBUF; 
....................             ENC_SPICON1bits.MODE32 = 0; 
....................         } 
....................     } 
....................     #elif defined(__C30__) 
....................     { 
....................         WORD_VAL wv; 
....................  
....................         // Send the data, 2 bytes at a time, for as long as possible 
....................         if(len >= 2) 
....................         { 
....................             wv.v[1] = *val++; 
....................             wv.v[0] = *val++; 
....................             ENC_SPISTATbits.SPIEN = 0; 
....................             ENC_SPICON1bits.MODE16 = 1; 
....................             ENC_SPISTATbits.SPIEN = 1; 
....................             while(1) 
....................             { 
....................                 ENC_SSPBUF = wv.Val;        // Start sending the WORD 
....................                 len -= 2; 
....................                 if(len < 2) 
....................                     break; 
....................                 wv.v[1] = *val++; 
....................                 wv.v[0] = *val++; 
....................                 WaitForDataByte();          // Wait until WORD is transmitted 
....................                 Dummy = ENC_SSPBUF; 
....................             }; 
....................             WaitForDataByte();              // Wait until WORD is transmitted 
....................             Dummy = ENC_SSPBUF; 
....................             ENC_SPISTATbits.SPIEN = 0; 
....................             ENC_SPICON1bits.MODE16 = 0; 
....................             ENC_SPISTATbits.SPIEN = 1; 
....................         } 
....................     } 
....................     #endif 
....................  
....................     // Send the data, one byte at a time 
....................     while(len) 
00DEE:  MOVLB  2
00DF0:  MOVF   xE7,W
00DF2:  IORWF  xE8,W
00DF4:  BZ    0E1C
....................     { 
....................         ENC_SSPBUF = *val;  // Start sending the byte 
00DF6:  MOVFF  2E5,FE9
00DFA:  MOVFF  2E6,FEA
00DFE:  MOVFF  FEF,FC9
....................         val++;              // Increment after writing to ENC_SSPBUF to increase speed 
00E02:  INCF   xE5,F
00E04:  BTFSC  FD8.2
00E06:  INCF   xE6,F
....................         len--;              // Decrement after writing to ENC_SSPBUF to increase speed 
00E08:  MOVF   xE7,W
00E0A:  BTFSC  FD8.2
00E0C:  DECF   xE8,F
00E0E:  DECF   xE7,F
....................         WaitForDataByte();  // Wait until byte is transmitted 
00E10:  BTFSS  F9E.3
00E12:  BRA    0E10
00E14:  BCF    F9E.3
....................         Dummy = ENC_SSPBUF; 
00E16:  MOVFF  FC9,2E9
00E1A:  BRA    0DF0
....................     }; 
....................  
....................     // Terminate the burst operation 
....................     ENC_CS_IO = 1; 
00E1C:  BSF    F8C.1
.................... #endif 
00E1E:  MOVLB  0
00E20:  RETURN 0
.................... }//end MACPutArray 
....................  
....................  
.................... #if defined(__18CXX) 
.................... /****************************************************************************** 
....................  * Function:        void MACPutROMArray(ROM BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           *val: Pointer to source of bytes to copy. 
....................  *                  len:  Number of bytes to write to the data buffer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPutArray writes several sequential bytes to the 
....................  *                  ENC28J60 RAM.  It performs faster than multiple MACPut() 
....................  *                  calls.  EWRPT is incremented by len. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPutROMArray(ROM BYTE *val, WORD len) 
.................... { 
.................... // Workaround needed on HPC Explorer (classic) board to prevent interference 
.................... // with I2C temperature sensor on the same SPI wires 
.................... #if defined(__18F8722) || defined(_18F8722) ||  defined(__18F8723) || defined(_18F8723) 
....................     WORD i; 
....................     volatile BYTE Dummy; 
....................  
....................     i = len; 
....................     Dummy = 0xFF; 
....................     ClearSPIDoneFlag(); 
....................     while(i--) 
....................     { 
....................         if(((BYTE_VAL*)&Dummy)->bits.b0) 
....................         { 
....................             // End bust operation 
....................             ENC_CS_IO = 1; 
....................             ((BYTE_VAL*)&Dummy)->bits.b0 = 0; 
....................  
....................             // Start the burst operation 
....................             ENC_CS_IO = 0; 
....................             ENC_SSPBUF = WBM;       // Send the Read Buffer Memory opcode. 
....................             WaitForDataByte();      // Wait until opcode/address is transmitted. 
....................         } 
....................         else 
....................             Dummy = 0xFF; 
....................  
....................         ENC_SSPBUF = *val++;    // Send byte 
....................         WaitForDataByte();      // Wait until byte is sent 
....................     } 
....................  
....................     ENC_CS_IO = 1; 
....................  
....................     return; 
.................... #else 
....................     volatile BYTE Dummy; 
....................  
....................     // Select the chip and send the proper opcode 
....................     ENC_CS_IO = 0; 
*
03626:  BCF    F8C.1
....................     ClearSPIDoneFlag(); 
03628:  BCF    F9E.3
....................     ENC_SSPBUF = WBM;       // Send the Write Buffer Memory opcode 
0362A:  MOVLW  7A
0362C:  MOVWF  FC9
....................     WaitForDataByte();      // Wait until opcode/constant is transmitted. 
0362E:  BTFSS  F9E.3
03630:  BRA    362E
03632:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
03634:  MOVFF  FC9,280
....................  
....................     // Send the data 
....................     while(len) 
03638:  MOVLB  2
0363A:  MOVF   x7E,W
0363C:  IORWF  x7F,W
0363E:  BZ    3680
....................     { 
....................         ENC_SSPBUF = *val;  // Start sending the byte 
03640:  CLRF   FF8
03642:  MOVFF  27D,FF7
03646:  MOVFF  27C,FF6
0364A:  MOVLW  0F
0364C:  MOVWF  FEA
0364E:  MOVLW  C9
03650:  MOVWF  FE9
03652:  CLRF   x82
03654:  MOVLW  01
03656:  MOVWF  x81
03658:  MOVLB  0
0365A:  CALL   2A70
....................         val++;              // Increment after writing to ENC_SSPBUF to increase speed 
0365E:  MOVLB  2
03660:  MOVFF  27D,03
03664:  MOVF   x7C,W
03666:  INCF   x7C,F
03668:  BTFSC  FD8.2
0366A:  INCF   x7D,F
....................         len--;              // Decrement after writing to ENC_SSPBUF to increase speed 
0366C:  MOVF   x7E,W
0366E:  BTFSC  FD8.2
03670:  DECF   x7F,F
03672:  DECF   x7E,F
....................         WaitForDataByte();  // Wait until byte is transmitted 
03674:  BTFSS  F9E.3
03676:  BRA    3674
03678:  BCF    F9E.3
....................         Dummy = ENC_SSPBUF; 
0367A:  MOVFF  FC9,280
0367E:  BRA    363A
....................     }; 
....................  
....................     // Terminate the burst operation 
....................     ENC_CS_IO = 1; 
03680:  BSF    F8C.1
.................... #endif 
03682:  MOVLB  0
03684:  GOTO   36FA (RETURN)
.................... }//end MACPutROMArray 
.................... #endif 
....................  
.................... /****************************************************************************** 
....................  * Function:        static void SendSystemReset(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SendSystemReset sends the System Reset SPI command to 
....................  *                  the Ethernet controller.  It resets all register contents 
....................  *                  (except for ECOCON) and returns the device to the power 
....................  *                  on default state. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void SendSystemReset(void) 
.................... { 
....................     volatile BYTE Dummy; 
....................  
....................     // Note: The power save feature may prevent the reset from executing, so 
....................     // we must make sure that the device is not in power save before issuing 
....................     // a reset. 
....................     BFCReg(ECON2, ECON2_PWRSV); 
*
007EC:  MOVLW  1E
007EE:  MOVLB  2
007F0:  MOVWF  xDB
007F2:  MOVLW  20
007F4:  MOVWF  xDC
007F6:  MOVLB  0
007F8:  RCALL  07C2
....................  
....................     // Give some opportunity for the regulator to reach normal regulation and 
....................     // have all clocks running 
....................     DelayMs(1); 
007FA:  MOVLW  01
007FC:  MOVLB  2
007FE:  MOVWF  x62
00800:  MOVLB  0
00802:  RCALL  0262
....................  
....................     // Execute the System Reset command 
....................     ENC_CS_IO = 0; 
00804:  BCF    F8C.1
....................     ClearSPIDoneFlag(); 
00806:  BCF    F9E.3
....................     ENC_SSPBUF = SR; 
00808:  SETF   FC9
....................     WaitForDataByte();      // Wait until the command is transmitted. 
0080A:  BTFSS  F9E.3
0080C:  BRA    080A
0080E:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
00810:  MOVFF  FC9,245
....................     ENC_CS_IO = 1; 
00814:  BSF    F8C.1
....................  
....................     // Wait for the oscillator start up timer and PHY to become ready 
....................     DelayMs(1); 
00816:  MOVLW  01
00818:  MOVLB  2
0081A:  MOVWF  x62
0081C:  MOVLB  0
0081E:  RCALL  0262
00820:  GOTO   09E4 (RETURN)
.................... }//end SendSystemReset 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadETHReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  Bank select bits must be set corresponding to the register 
....................  *                  to read from. 
....................  * 
....................  * Input:           5 bit address of the ETH control register to read from. 
....................  *                    The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's ETH register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadETHReg sends the 8 bit RCR opcode/Address byte over 
....................  *                  the SPI and then retrives the register contents in the 
....................  *                  next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access MAC/MII or PHY 
....................  *                  registers.  Use ReadMACReg() or ReadPHYReg() for that 
....................  *                  purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadETHReg(BYTE Address) 
.................... { 
....................     REG r; 
....................  
....................     // Select the chip and send the Read Control Register opcode/address 
....................     ENC_CS_IO = 0; 
00824:  BCF    F8C.1
....................     ClearSPIDoneFlag(); 
00826:  BCF    F9E.3
....................     ENC_SSPBUF = RCR | Address; 
00828:  MOVLB  2
0082A:  MOVFF  2E1,FC9
....................  
....................     WaitForDataByte();      // Wait until the opcode/address is transmitted 
0082E:  BTFSS  F9E.3
00830:  BRA    082E
00832:  BCF    F9E.3
....................     r.Val = ENC_SSPBUF; 
00834:  MOVFF  FC9,2E2
....................     ENC_SSPBUF = 0;         // Send a dummy byte to receive the register 
00838:  CLRF   FC9
....................                             //   contents 
....................     WaitForDataByte();      // Wait until the register is received 
0083A:  BTFSS  F9E.3
0083C:  BRA    083A
0083E:  BCF    F9E.3
....................     r.Val = ENC_SSPBUF; 
00840:  MOVFF  FC9,2E2
....................     ENC_CS_IO = 1; 
00844:  BSF    F8C.1
....................  
....................     return r; 
00846:  MOVFF  2E2,01
0084A:  MOVLB  0
0084C:  RETURN 0
.................... }//end ReadETHReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadMACReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  Bank select bits must be set corresponding to the register 
....................  *                  to read from. 
....................  * 
....................  * Input:           5 bit address of the MAC or MII register to read from. 
....................  *                    The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's MAC/MII register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadMACReg sends the 8 bit RCR opcode/Address byte as well 
....................  *                  as a dummy byte over the SPI and then retrives the 
....................  *                  register contents in the last 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access ETH or PHY 
....................  *                  registers.  Use ReadETHReg() or ReadPHYReg() for that 
....................  *                  purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadMACReg(BYTE Address) 
.................... { 
....................     REG r; 
....................  
....................     ENC_CS_IO = 0; 
*
008FC:  BCF    F8C.1
....................     ClearSPIDoneFlag(); 
008FE:  BCF    F9E.3
....................     ENC_SSPBUF = RCR | Address; // Send the Read Control Register opcode and 
00900:  MOVLB  2
00902:  MOVFF  248,FC9
....................                                 //   address. 
....................     WaitForDataByte();          // Wait until opcode/address is transmitted. 
00906:  BTFSS  F9E.3
00908:  BRA    0906
0090A:  BCF    F9E.3
....................     r.Val = ENC_SSPBUF; 
0090C:  MOVFF  FC9,249
....................     ENC_SSPBUF = 0;             // Send a dummy byte 
00910:  CLRF   FC9
....................     WaitForDataByte();          // Wait for the dummy byte to be transmitted 
00912:  BTFSS  F9E.3
00914:  BRA    0912
00916:  BCF    F9E.3
....................     r.Val = ENC_SSPBUF; 
00918:  MOVFF  FC9,249
....................     ENC_SSPBUF = 0;             // Send another dummy byte to receive the register 
0091C:  CLRF   FC9
....................                                 //   contents. 
....................     WaitForDataByte();          // Wait until register is received. 
0091E:  BTFSS  F9E.3
00920:  BRA    091E
00922:  BCF    F9E.3
....................     r.Val = ENC_SSPBUF; 
00924:  MOVFF  FC9,249
....................     ENC_CS_IO = 1; 
00928:  BSF    F8C.1
....................  
....................     return r; 
0092A:  MOVFF  249,01
0092E:  MOVLB  0
00930:  GOTO   09AE (RETURN)
.................... }//end ReadMACReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        ReadPHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to read from. 
....................  * 
....................  * Output:          16 bits of data read from the PHY register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadPHYReg performs an MII read operation.  While in 
....................  *                  progress, it simply polls the MII BUSY bit wasting time 
....................  *                  (10.24us). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PHYREG ReadPHYReg(BYTE Register) 
.................... { 
....................     PHYREG Result; 
....................  
....................     // Set the right address and start the register read operation 
....................     BankSel(MIREGADR); 
....................     WriteReg((BYTE)MIREGADR, Register); 
....................     WriteReg((BYTE)MICMD, MICMD_MIIRD); 
....................  
....................     // Loop to wait until the PHY register has been read through the MII 
....................     // This requires 10.24us 
....................     BankSel(MISTAT); 
....................     while(ReadMACReg((BYTE)MISTAT).MISTATbits.BUSY); 
....................  
....................     // Stop reading 
....................     BankSel(MIREGADR); 
....................     WriteReg((BYTE)MICMD, 0x00); 
....................  
....................     // Obtain results and return 
....................     Result.VAL.v[0] = ReadMACReg((BYTE)MIRDL).Val; 
....................     Result.VAL.v[1] = ReadMACReg((BYTE)MIRDH).Val; 
....................  
....................     BankSel(ERDPTL);    // Return to Bank 0 
....................     return Result; 
.................... }//end ReadPHYReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void WriteReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  Bank select bits must be set corresponding to the register 
....................  *                  to modify. 
....................  * 
....................  * Input:           5 bit address of the ETH, MAC, or MII register to modify. 
....................  *                    The top 3 bits must be 0. 
....................  *                  Byte to be written into the register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        WriteReg sends the 8 bit WCR opcode/Address byte over the 
....................  *                  SPI and then sends the data to write in the next 8 SPI 
....................  *                  clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the BFCReg() and 
....................  *                  BFSReg() functions.  It is seperate to maximize speed. 
....................  *                  Unlike the ReadETHReg/ReadMACReg functions, WriteReg() 
....................  *                  can write to any ETH or MAC register.  Writing to PHY 
....................  *                  registers must be accomplished with WritePHYReg(). 
....................  *****************************************************************************/ 
.................... static void WriteReg(BYTE Address, BYTE Data) 
.................... { 
....................     volatile BYTE Dummy; 
....................  
....................     ENC_CS_IO = 0; 
*
0084E:  BCF    F8C.1
....................     ClearSPIDoneFlag(); 
00850:  BCF    F9E.3
....................  
....................     #if defined(__C32__) 
....................     { 
....................         // Send the Write Buffer Memory and data, in on 16-bit write 
....................         ENC_SPICON1bits.MODE16 = 1; 
....................         ENC_SSPBUF = ((WCR | Address)<<8) | (WORD)Data; // Start sending the WORD 
....................         WaitForDataByte();                  // Wait until WORD is transmitted 
....................         ENC_SPICON1bits.MODE16 = 0; 
....................     } 
....................     #else 
....................     { 
....................         ENC_SSPBUF = WCR | Address; // Send the opcode and address. 
00852:  MOVLB  2
00854:  MOVF   xE6,W
00856:  IORLW  40
00858:  MOVWF  FC9
....................         WaitForDataByte();          // Wait until opcode/constant is transmitted. 
0085A:  BTFSS  F9E.3
0085C:  BRA    085A
0085E:  BCF    F9E.3
....................         Dummy = ENC_SSPBUF; 
00860:  MOVFF  FC9,2E8
....................         ENC_SSPBUF = Data;          // Send the byte to be writen. 
00864:  MOVFF  2E7,FC9
....................         WaitForDataByte();          // Wait until finished transmitting 
00868:  BTFSS  F9E.3
0086A:  BRA    0868
0086C:  BCF    F9E.3
....................     } 
....................     #endif 
....................  
....................     Dummy = ENC_SSPBUF; 
0086E:  MOVFF  FC9,2E8
....................  
....................  
....................    // For faster processors (dsPIC), delay for a few clock cycles to ensure  
....................    // the MAC/MII register write Chip Select hold time minimum of 210ns is met. 
....................    #if (GetInstructionClock() > 30000000) 
....................       Nop(); 
....................       Nop(); 
....................    #endif 
....................    #if (GetInstructionClock() > 40000000) 
....................       Nop(); 
....................       Nop(); 
....................    #endif 
....................    #if (GetInstructionClock() > 50000000) 
....................       Nop(); 
....................       Nop(); 
....................    #endif 
....................  
....................    ENC_CS_IO = 1; 
00872:  BSF    F8C.1
00874:  MOVLB  0
00876:  RETURN 0
.................... }//end WriteReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFCReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  Bank select bits must be set corresponding to the register 
....................  *                    to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                    must be 0. 
....................  *                  Byte to be used with the Bit Field Clear operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFCReg sends the 8 bit BFC opcode/Address byte over the 
....................  *                  SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *                  BFSReg() functions.  It is separate to maximize speed. 
....................  *                  BFCReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFCReg(BYTE Address, BYTE Data) 
.................... { 
....................     volatile BYTE Dummy; 
....................  
....................     ENC_CS_IO = 0; 
*
007C2:  BCF    F8C.1
....................     ClearSPIDoneFlag(); 
007C4:  BCF    F9E.3
....................     ENC_SSPBUF = BFC | Address; // Send the opcode and address. 
007C6:  MOVLB  2
007C8:  MOVF   xDB,W
007CA:  IORLW  A0
007CC:  MOVWF  FC9
....................     WaitForDataByte();          // Wait until opcode/address is transmitted. 
007CE:  BTFSS  F9E.3
007D0:  BRA    07CE
007D2:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
007D4:  MOVFF  FC9,2DD
....................     ENC_SSPBUF = Data;          // Send the byte to be writen. 
007D8:  MOVFF  2DC,FC9
....................     WaitForDataByte();          // Wait until register is written. 
007DC:  BTFSS  F9E.3
007DE:  BRA    07DC
007E0:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
007E2:  MOVFF  FC9,2DD
....................     ENC_CS_IO = 1; 
007E6:  BSF    F8C.1
007E8:  MOVLB  0
007EA:  RETURN 0
.................... }//end BFCReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFSReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  Bank select bits must be set corresponding to the register 
....................  *                  to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                    must be 0. 
....................  *                  Byte to be used with the Bit Field Set operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFSReg sends the 8 bit BFC opcode/Address byte over the 
....................  *                  SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *                  BFCReg() functions.  It is separate to maximize speed. 
....................  *                  BFSReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFSReg(BYTE Address, BYTE Data) 
.................... { 
....................     volatile BYTE Dummy; 
....................  
....................     ENC_CS_IO = 0; 
*
0089C:  BCF    F8C.1
....................     ClearSPIDoneFlag(); 
0089E:  BCF    F9E.3
....................     ENC_SSPBUF = BFS | Address; // Send the opcode and address. 
008A0:  MOVLB  2
008A2:  MOVF   xDB,W
008A4:  IORLW  80
008A6:  MOVWF  FC9
....................     WaitForDataByte();          // Wait until opcode/address is transmitted. 
008A8:  BTFSS  F9E.3
008AA:  BRA    08A8
008AC:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
008AE:  MOVFF  FC9,2DD
....................     ENC_SSPBUF = Data;          // Send the byte to be writen. 
008B2:  MOVFF  2DC,FC9
....................     WaitForDataByte();          // Wait until register is written. 
008B6:  BTFSS  F9E.3
008B8:  BRA    08B6
008BA:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
008BC:  MOVFF  FC9,2DD
....................     ENC_CS_IO = 1; 
008C0:  BSF    F8C.1
008C2:  MOVLB  0
008C4:  RETURN 0
.................... }//end BFSReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WritePHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to write to. 
....................  *                  16 bits of data to write to PHY register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 3 
....................  * 
....................  * Overview:        WritePHYReg performs an MII write operation.  While in 
....................  *                  progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void WritePHYReg(BYTE Register, WORD Data) 
.................... { 
....................     // Write the register address 
....................     BankSel(MIREGADR); 
*
00934:  MOVLW  02
00936:  MOVLB  2
00938:  MOVWF  xC6
0093A:  MOVLW  14
0093C:  MOVWF  xC5
0093E:  MOVLB  0
00940:  RCALL  08C6
....................     WriteReg((BYTE)MIREGADR, Register); 
00942:  MOVLW  14
00944:  MOVLB  2
00946:  MOVWF  xE6
00948:  MOVFF  245,2E7
0094C:  MOVLB  0
0094E:  RCALL  084E
....................  
....................     // Write the data 
....................     // Order is important: write low byte first, high byte last 
....................     WriteReg((BYTE)MIWRL, ((WORD_VAL*)&Data)->v[0]); 
00950:  MOVLW  02
00952:  MOVLB  2
00954:  MOVWF  x49
00956:  MOVLW  46
00958:  MOVWF  x48
0095A:  MOVWF  FE9
0095C:  MOVFF  249,FEA
00960:  MOVFF  FEF,24A
00964:  MOVLW  16
00966:  MOVWF  xE6
00968:  MOVFF  24A,2E7
0096C:  MOVLB  0
0096E:  RCALL  084E
....................     WriteReg((BYTE)MIWRH, ((WORD_VAL*)&Data)->v[1]); 
00970:  MOVLW  02
00972:  MOVLB  2
00974:  MOVWF  x49
00976:  MOVLW  46
00978:  MOVWF  x48
0097A:  MOVLW  01
0097C:  ADDWF  x48,W
0097E:  MOVWF  FE9
00980:  MOVLW  00
00982:  ADDWFC x49,W
00984:  MOVWF  FEA
00986:  MOVFF  FEF,24A
0098A:  MOVLW  17
0098C:  MOVWF  xE6
0098E:  MOVFF  24A,2E7
00992:  MOVLB  0
00994:  RCALL  084E
....................  
....................     // Wait until the PHY register has been written 
....................     BankSel(MISTAT); 
00996:  MOVLW  03
00998:  MOVLB  2
0099A:  MOVWF  xC6
0099C:  MOVLW  0A
0099E:  MOVWF  xC5
009A0:  MOVLB  0
009A2:  RCALL  08C6
....................     while(ReadMACReg((BYTE)MISTAT).MISTATbits.BUSY); 
009A4:  MOVLW  0A
009A6:  MOVLB  2
009A8:  MOVWF  x48
009AA:  MOVLB  0
009AC:  BRA    08FC
009AE:  MOVFF  01,248
009B2:  MOVLW  00
009B4:  MOVLB  2
009B6:  BTFSC  01.0
009B8:  MOVLW  01
009BA:  XORLW  00
009BC:  BTFSC  FD8.2
009BE:  BRA    09C4
009C0:  MOVLB  0
009C2:  BRA    09A4
....................  
....................     BankSel(ERDPTL);    // Return to Bank 0 
009C4:  CLRF   xC6
009C6:  CLRF   xC5
009C8:  MOVLB  0
009CA:  RCALL  08C6
009CC:  RETURN 0
.................... }//end WritePHYReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BankSel 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Register address with the high byte containing the 2 bank 
....................  *                    select 2 bits. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BankSel takes the high byte of a register address and 
....................  *                  changes the bank select bits in ETHCON1 to match. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void BankSel(WORD Register) 
.................... { 
....................     BFCReg(ECON1, ECON1_BSEL1 | ECON1_BSEL0); 
*
008C6:  MOVLW  1F
008C8:  MOVLB  2
008CA:  MOVWF  xDB
008CC:  MOVLW  03
008CE:  MOVWF  xDC
008D0:  MOVLB  0
008D2:  RCALL  07C2
....................     BFSReg(ECON1, ((WORD_VAL*)&Register)->v[1]); 
008D4:  MOVLW  02
008D6:  MOVLB  2
008D8:  MOVWF  xC8
008DA:  MOVLW  C5
008DC:  MOVWF  xC7
008DE:  MOVLW  01
008E0:  ADDWF  xC7,W
008E2:  MOVWF  FE9
008E4:  MOVLW  00
008E6:  ADDWFC xC8,W
008E8:  MOVWF  FEA
008EA:  MOVFF  FEF,2C9
008EE:  MOVLW  1F
008F0:  MOVWF  xDB
008F2:  MOVFF  2C9,2DC
008F6:  MOVLB  0
008F8:  RCALL  089C
008FA:  RETURN 0
.................... }//end BankSel 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerDown(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerDown puts the ENC28J60 in low power sleep mode. In 
....................  *                  sleep mode, no packets can be transmitted or received. 
....................  *                  All MAC and PHY registers should not be accessed. 
....................  * 
....................  * Note:            If a packet is being transmitted while this function is 
....................  *                  called, this function will block until it is it complete. 
....................  *                  If anything is being received, it will be completed. 
....................  *****************************************************************************/ 
.................... void MACPowerDown(void) 
.................... { 
....................     // Disable packet reception 
....................     BFCReg(ECON1, ECON1_RXEN); 
....................  
....................     // Make sure any last packet which was in-progress when RXEN was cleared 
....................     // is completed 
....................     while(ReadETHReg(ESTAT).ESTATbits.RXBUSY); 
....................  
....................     // If a packet is being transmitted, wait for it to finish 
....................     while(ReadETHReg(ECON1).ECON1bits.TXRTS); 
....................  
....................     // Enter sleep mode 
....................     BFSReg(ECON2, ECON2_PWRSV); 
.................... }//end MACPowerDown 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerUp(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerUp returns the ENC28J60 back to normal operation 
....................  *                  after a previous call to MACPowerDown().  Calling this 
....................  *                  function when already powered up will have no effect. 
....................  * 
....................  * Note:            If a link partner is present, it will take 10s of 
....................  *                  milliseconds before a new link will be established after 
....................  *                  waking up.  While not linked, packets which are 
....................  *                  transmitted will most likely be lost.  MACIsLinked() can 
....................  *                  be called to determine if a link is established. 
....................  *****************************************************************************/ 
.................... void MACPowerUp(void) 
.................... { 
....................     // Leave power down mode 
....................     BFCReg(ECON2, ECON2_PWRSV); 
....................  
....................     // Wait for the 300us Oscillator Startup Timer (OST) to time out.  This 
....................     // delay is required for the PHY module to return to an operational state. 
....................     while(!ReadETHReg(ESTAT).ESTATbits.CLKRDY); 
....................  
....................     // Enable packet reception 
....................     BFSReg(ECON1, ECON1_RXEN); 
.................... }//end MACPowerUp 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void SetCLKOUT(BYTE NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - 0x00: CLKOUT disabled (pin driven low) 
....................  *                              0x01: Divide by 1 (25 MHz) 
....................  *                              0x02: Divide by 2 (12.5 MHz) 
....................  *                              0x03: Divide by 3 (8.333333 MHz) 
....................  *                              0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                              0x05: Divide by 8 (3.125 MHz) 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the ECOCON register. 
....................  *                  The CLKOUT pin will beginning outputting the new frequency 
....................  *                  immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... void SetCLKOUT(BYTE NewConfig) 
.................... { 
....................     BankSel(ECOCON); 
....................     WriteReg((BYTE)ECOCON, NewConfig); 
....................     BankSel(ERDPTL); 
.................... }//end SetCLKOUT 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE GetCLKOUT(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          BYTE - 0x00: CLKOUT disabled (pin driven low) 
....................  *                         0x01: Divide by 1 (25 MHz) 
....................  *                         0x02: Divide by 2 (12.5 MHz) 
....................  *                         0x03: Divide by 3 (8.333333 MHz) 
....................  *                         0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                         0x05: Divide by 8 (3.125 MHz) 
....................  *                         0x06: Reserved 
....................  *                         0x07: Reserved 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the ECOCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE GetCLKOUT(void) 
.................... { 
....................     BYTE i; 
....................  
....................     BankSel(ECOCON); 
....................     i = ReadETHReg((BYTE)ECOCON).Val; 
....................     BankSel(ERDPTL); 
....................     return i; 
.................... }//end GetCLKOUT 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void SetRXHashTableEntry(MAC_ADDR DestMACAddr) 
....................  * 
....................  * PreCondition:    SPI interface must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           DestMACAddr: 6 byte group destination MAC address to allow  
....................  *                         through the Hash Table Filter.  If DestMACAddr  
....................  *                         is set to 00-00-00-00-00-00, then the hash  
....................  *                         table will be cleared of all entries and the  
....................  *                         filter will be disabled. 
....................  * 
....................  * Output:          Sets the appropriate bit in the EHT* registers to allow  
....................  *               packets sent to DestMACAddr to be received and enables the  
....................  *               Hash Table receive filter (if not already). 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Calculates a CRC-32 using polynomial 0x4C11DB7 and then,  
....................  *               using bits 28:23 of the CRC, sets the appropriate bit in  
....................  *               the EHT0-EHT7 registers. 
....................  * 
....................  * Note:            This code is commented out to save code space on systems  
....................  *               that do not need this function.  Change the  
....................  *               "#if STACK_USE_ZEROCONF_MDNS_SD" line to "#if 1" to  
....................  *               uncomment it, assuming you aren't using the Zeroconf module,  
....................  *               which requires mutlicast support and enables this function  
....................  *               automatically. 
....................  * 
....................  *               There is no way to individually unset destination MAC  
....................  *               addresses from the hash table since it is possible to have  
....................  *               a hash collision and therefore multiple MAC addresses  
....................  *               relying on the same hash table bit.  The stack would have  
....................  *               to individually store each 6 byte MAC address to support  
....................  *               this feature, which would waste a lot of RAM and be  
....................  *               unnecessary in most applications.  As a simple compromise,  
....................  *               you can call SetRXHashTableEntry() using a  
....................  *               00-00-00-00-00-00 destination MAC address, which will clear  
....................  *               the entire hash table and disable the hash table filter.   
....................  *               This will allow you to then re-add the necessary  
....................  *               destination address(es). 
....................  * 
....................  *               This function is intended to be used when  
....................  *               ERXFCON.ANDOR == 0 (OR). 
....................  *****************************************************************************/ 
.................... #if defined(STACK_USE_ZEROCONF_MDNS_SD) 
.................... void SetRXHashTableEntry(MAC_ADDR DestMACAddr) 
.................... { 
....................     DWORD_VAL CRC = {0xFFFFFFFF}; 
....................     BYTE HTRegister; 
....................     BYTE i, j; 
....................  
....................    // Select proper bank for ERXFCON and EHT0-EHT7 register access 
....................    BankSel(ERXFCON); 
....................  
....................    // Clear the Hash Table bits and disable the Hash Table Filter if a special  
....................    // 00-00-00-00-00-00 destination MAC address is provided. 
....................    if((DestMACAddr.v[0] | DestMACAddr.v[1] | DestMACAddr.v[2] | DestMACAddr.v[3] | DestMACAddr.v[4] | DestMACAddr.v[5]) == 0x00u) 
....................    { 
....................       // Disable the Hash Table receive filter and clear the hash table 
....................       BFCReg((BYTE)ERXFCON, ERXFCON_HTEN); 
....................       for(i = (BYTE)EHT0; i <= (BYTE)EHT7; i++) 
....................          WriteReg(i, 0x00); 
....................    } 
....................    else 
....................    { 
....................       // Calculate a CRC-32 over the 6 byte MAC address 
....................       // using polynomial 0x4C11DB7 
....................       for(i = 0; i < sizeof(MAC_ADDR); i++) 
....................       { 
....................          BYTE  crcnext; 
....................  
....................          // shift in 8 bits 
....................          for(j = 0; j < 8; j++) 
....................          { 
....................             crcnext = 0; 
....................             if(((BYTE_VAL*)&(CRC.v[3]))->bits.b7) 
....................                crcnext = 1; 
....................             crcnext ^= (((BYTE_VAL*)&DestMACAddr.v[i])->bits.b0); 
....................  
....................             CRC.Val <<= 1; 
....................             if(crcnext) 
....................                CRC.Val ^= 0x4C11DB7; 
....................             // next bit 
....................             DestMACAddr.v[i] >>= 1; 
....................          } 
....................       } 
....................  
....................       // CRC-32 calculated, now extract bits 28:23 
....................       // Bits 25:23 define where within the Hash Table byte the bit needs to be set 
....................       // Bits 28:26 define which of the 8 Hash Table bytes that bits 25:23 apply to 
....................       i = CRC.v[3] & 0x1F; 
....................       HTRegister = (i >> 2) + (BYTE)EHT0; 
....................       i = (i << 1) & 0x06; 
....................       ((BYTE_VAL*)&i)->bits.b0 = ((BYTE_VAL*)&CRC.v[2])->bits.b7; 
....................  
....................       // Set the proper bit in the Hash Table 
....................       BFSReg(HTRegister, 1<<i); 
....................  
....................       // Ensure that the Hash Table receive filter is enabled 
....................       BFSReg((BYTE)ERXFCON, ERXFCON_HTEN); 
....................    } 
....................  
....................     BankSel(ERDPTL);            // Return to Bank 0 
.................... } 
.................... #endif 
....................  
.................... //// GetRegs is a function for debugging purposes only.  It will read all 
.................... //// registers and store them in the PIC's RAM so they can be viewed with 
.................... //// the ICD2. 
.................... //REG Regs[4][32]; 
.................... //void GetRegs(void) 
.................... //{ 
.................... //  BYTE i; 
.................... // 
.................... //  BankSel(0x000); 
.................... //  for(i=0; i<0x1A; i++) 
.................... //      Regs[0][i] = ReadETHReg(i); 
.................... //  for(i=0x1B; i<32; i++) 
.................... //      Regs[0][i] = ReadETHReg(i); 
.................... // 
.................... //  BankSel(0x100); 
.................... //  for(i=0; i<0x1A; i++) 
.................... //      Regs[1][i] = ReadETHReg(i); 
.................... //  for(i=0x1B; i<32; i++) 
.................... //      Regs[1][i] = ReadETHReg(i); 
.................... // 
.................... //  BankSel(0x200); 
.................... //  for(i=0; i<5; i++) 
.................... //      Regs[2][i] = ReadMACReg(i); 
.................... //  Regs[2][5] = ReadETHReg(i); 
.................... //  for(i=6; i<0x0F; i++) 
.................... //      Regs[2][i] = ReadMACReg(i); 
.................... //  Regs[2][0x0F] = ReadETHReg(i); 
.................... //  for(i=0x10; i<0x13; i++) 
.................... //      Regs[2][i] = ReadMACReg(i); 
.................... //  Regs[2][0x13] = ReadETHReg(i); 
.................... //  for(i=0x14; i<0x1A; i++) 
.................... //      Regs[2][i] = ReadMACReg(i); 
.................... //  for(i=0x1B; i<32; i++) 
.................... //      Regs[2][i] = ReadETHReg(i); 
.................... // 
.................... //  BankSel(0x300); 
.................... //  for(i=0; i<0x06; i++) 
.................... //      Regs[3][i] = ReadMACReg(i); 
.................... //  for(i=6; i<0x0A; i++) 
.................... //      Regs[3][i] = ReadETHReg(i); 
.................... //  Regs[3][0x0A] = ReadMACReg(i); 
.................... //  for(i=0x0B; i<0x1A; i++) 
.................... //      Regs[3][i] = ReadETHReg(i); 
.................... //  for(i=0x1B; i<32; i++) 
.................... //      Regs[3][i] = ReadETHReg(i); 
.................... // 
.................... //  Regs[0][0x1A].Val = 0; 
.................... //  Regs[1][0x1A].Val = 0; 
.................... //  Regs[2][0x1A].Val = 0; 
.................... //  Regs[3][0x1A].Val = 0; 
.................... // 
.................... //  BankSel(ERDPTL); 
.................... // 
.................... //  return; 
.................... //} 
....................  
.................... //// Get8KBMem is a function intended for debugging purposes.  It will read all 
.................... //// Ethernet RAM and output it in hex out the UART 
.................... //void Get8KBMem(void) 
.................... //{ 
.................... //  WORD_VAL i; 
.................... //  BYTE v; 
.................... //  WORD_VAL RDSave; 
.................... // 
.................... //  RDSave.v[0] = ReadETHReg(ERDPTL).Val; 
.................... //  RDSave.v[1] = ReadETHReg(ERDPTH).Val; 
.................... // 
.................... //  for(i.Val = 0; i.Val < 8192; i.Val++) 
.................... //  { 
.................... //      WriteReg(ERDPTL, i.v[0]); 
.................... //      WriteReg(ERDPTH, i.v[1]); 
.................... //      v = MACGet(); 
.................... // 
.................... //      putcUART('0'); 
.................... //      while(BusyUART()); 
.................... //      putcUART('x'); 
.................... //      while(BusyUART()); 
.................... //      putcUART(btohexa_high(v)); 
.................... //      while(BusyUART()); 
.................... //      putcUART(btohexa_low(v)); 
.................... //      while(BusyUART()); 
.................... //  } 
.................... // 
.................... //  WriteReg(ERDPTL, RDSave.v[0]); 
.................... //  WriteReg(ERDPTH, RDSave.v[1]); 
.................... // 
.................... //} 
....................  
.................... #endif //#if defined(ENC_CS_TRIS) 
....................  
.................... #elif defined(ENC100_INTERFACE_MODE) 
....................    #include "ENCX24J600.c" 
....................    #define PHYREG WORD 
.................... #elif defined(__PIC32MX__) && defined(_ETH) 
....................    // extra includes for PIC32MX with embedded ETH Controller 
.................... #else 
....................    #error No Ethernet/WiFi controller defined in HardwareProfile.h.  Defines for an ENC28J60, ENC424J600/624J600, or ZeroG ZG2100 must be present. 
.................... #endif 
.................... #include "IP.c" 
.................... /********************************************************************* 
....................  * 
....................  *  Internet Protocol (IP) Version 4 Communications Layer 
....................  *  Module for Microchip TCP/IP Stack 
....................  *   -Provides a transport for TCP, UDP, and ICMP messages 
....................  *	 -Reference: RFC 791 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.c 
....................  * Dependencies:    Network Layer interface (ENC28J60.c, ETH97J60.c,  
....................  *					ENCX24J600.c or WFMac.c) 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder		8/31/04	Beta Rev 0.9 (See version.log for detail) 
....................  * Howard Schlunder		1/5/06	Improved DMA checksum efficiency 
....................  * Darren Rook			9/21/06	Corrected IPHeaderLen not being  
....................  * 								initialized when NON_MCHP_MAC defined. 
....................  ********************************************************************/ 
.................... #define __IP_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... // This is left shifted by 4.  Actual value is 0x04. 
.................... #define IPv4                (0x40u) 
.................... #define IP_VERSION          IPv4 
....................  
.................... // IHL (Internet Header Length) is # of DWORDs in a header. 
.................... // Since, we do not support options, our IP header length will be 
.................... // minimum i.e. 20 bytes : IHL = 20 / 4 = 5. 
.................... #define IP_IHL              (0x05) 
....................  
.................... #define IP_SERVICE_NW_CTRL  (0x07) 
.................... #define IP_SERVICE_IN_CTRL  (0x06) 
.................... #define IP_SERVICE_ECP      (0x05) 
.................... #define IP_SERVICE_OVR      (0x04) 
.................... #define IP_SERVICE_FLASH    (0x03) 
.................... #define IP_SERVICE_IMM      (0x02) 
.................... #define IP_SERVICE_PRIOR    (0x01) 
.................... #define IP_SERVICE_ROUTINE  (0x00) 
....................  
.................... #define IP_SERVICE_N_DELAY  (0x00) 
.................... #define IP_SERCICE_L_DELAY  (0x08) 
.................... #define IP_SERVICE_N_THRPT  (0x00) 
.................... #define IP_SERVICE_H_THRPT  (0x10) 
.................... #define IP_SERVICE_N_RELIB  (0x00) 
.................... #define IP_SERVICE_H_RELIB  (0x20) 
....................  
.................... #define IP_SERVICE          (IP_SERVICE_ROUTINE | IP_SERVICE_N_DELAY) 
....................  
.................... #if defined(STACK_USE_ZEROCONF_MDNS_SD) 
....................   #define MY_IP_TTL           (255)  // Time-To-Live in hops  
....................   // IP TTL is set to 255 for Multicast DNS compatibility. See mDNS-draft-08, section 4. 
.................... #else 
....................   #define MY_IP_TTL           (100)  // Time-To-Live in hops 
.................... #endif 
....................  
....................  
....................  
.................... static WORD _Identifier = 0; 
.................... static BYTE IPHeaderLen; 
....................  
....................  
.................... static void SwapIPHeader(IP_HEADER* h); 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len) 
.................... { 
....................     WORD_VAL    CalcChecksum; 
....................     IP_HEADER   header; 
....................  
.................... #if defined(NON_MCHP_MAC) 
....................     WORD_VAL    ReceivedChecksum; 
....................     WORD        checksums[2]; 
....................     BYTE        optionsLen; 
.................... 	#define MAX_OPTIONS_LEN     (40u)            // As per RFC 791. 
....................     BYTE        options[MAX_OPTIONS_LEN]; 
.................... #endif 
....................  
....................     // Read IP header. 
....................     MACGetArray((BYTE*)&header, sizeof(header)); 
*
05594:  MOVLW  02
05596:  MOVLB  2
05598:  MOVWF  x6B
0559A:  MOVLW  56
0559C:  MOVWF  x6A
0559E:  MOVFF  26B,2E4
055A2:  MOVWF  xE3
055A4:  CLRF   xE6
055A6:  MOVLW  14
055A8:  MOVWF  xE5
055AA:  MOVLB  0
055AC:  CALL   0E8E
....................  
....................     // Make sure that this is an IPv4 packet. 
....................     if((header.VersionIHL & 0xf0) != IP_VERSION) 
055B0:  MOVLB  2
055B2:  MOVF   x56,W
055B4:  ANDLW  F0
055B6:  SUBLW  40
055B8:  BZ    55C0
....................     	return FALSE; 
055BA:  MOVLW  00
055BC:  MOVWF  01
055BE:  BRA    568E
....................  
.................... 	// Throw this packet away if it is a fragment.   
.................... 	// We don't have enough RAM for IP fragment reconstruction. 
.................... 	if(header.FragmentInfo & 0xFF1F) 
055C0:  MOVF   x5C,W
055C2:  ANDLW  1F
055C4:  MOVWF  00
055C6:  MOVFF  25D,03
055CA:  MOVF   00,W
055CC:  IORWF  x5D,W
055CE:  BZ    55D6
.................... 		return FALSE; 
055D0:  MOVLW  00
055D2:  MOVWF  01
055D4:  BRA    568E
....................  
.................... 	IPHeaderLen = (header.VersionIHL & 0x0f) << 2; 
055D6:  MOVF   x56,W
055D8:  ANDLW  0F
055DA:  MOVWF  00
055DC:  RLCF   00,W
055DE:  MOVLB  1
055E0:  MOVWF  x27
055E2:  RLCF   x27,F
055E4:  MOVLW  FC
055E6:  ANDWF  x27,F
....................  
.................... #if !defined(NON_MCHP_MAC) 
.................... 	// Validate the IP header.  If it is correct, the checksum  
.................... 	// will come out to 0x0000 (because the header contains a  
.................... 	// precomputed checksum).  A corrupt header will have a  
.................... 	// nonzero checksum. 
.................... 	CalcChecksum.Val = MACCalcRxChecksum(0, IPHeaderLen); 
055E8:  MOVLB  2
055EA:  CLRF   x6B
055EC:  CLRF   x6A
055EE:  CLRF   x6D
055F0:  MOVFF  127,26C
055F4:  MOVLB  0
055F6:  RCALL  54E2
055F8:  MOVFF  02,255
055FC:  MOVFF  01,254
....................  
.................... 	// Seek to the end of the IP header 
.................... 	MACSetReadPtrInRx(IPHeaderLen); 
05600:  MOVLB  2
05602:  CLRF   xA0
05604:  MOVFF  127,29F
05608:  MOVLB  0
0560A:  CALL   38E6
....................  
....................     if(CalcChecksum.Val) 
0560E:  MOVLB  2
05610:  MOVF   x54,W
05612:  IORWF  x55,W
05614:  BZ    561C
.................... #else 
....................     // Calculate options length in this header, if there is any. 
....................     // IHL is in terms of numbers of 32-bit DWORDs; i.e. actual 
....................     // length is 4 times IHL. 
....................     optionsLen = IPHeaderLen - sizeof(header); 
....................  
....................     // If there is any option(s), read it so that we can include them 
....................     // in checksum calculation. 
....................     if ( optionsLen > MAX_OPTIONS_LEN ) 
....................         return FALSE; 
....................  
....................     if ( optionsLen > 0u ) 
....................         MACGetArray(options, optionsLen); 
....................  
....................     // Save header checksum; clear it and recalculate it ourselves. 
....................     ReceivedChecksum.Val = header.HeaderChecksum; 
....................     header.HeaderChecksum = 0; 
....................  
....................     // Calculate checksum of header including options bytes. 
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&header, sizeof(header)); 
....................  
....................     // Calculate Options checksum too, if they are present. 
....................     if ( optionsLen > 0u ) 
....................         checksums[1] = ~CalcIPChecksum((BYTE*)options, optionsLen); 
....................     else 
....................         checksums[1] = 0; 
....................  
....................     CalcChecksum.Val  = CalcIPChecksum((BYTE*)checksums, 
....................                                             2 * sizeof(WORD)); 
....................  
....................     // Make sure that checksum is correct 
....................     if ( ReceivedChecksum.Val != CalcChecksum.Val ) 
.................... #endif 
....................     { 
....................         // Bad packet. The function caller will be notified by means of the FALSE  
....................         // return value and it should discard the packet. 
....................         return FALSE; 
05616:  MOVLW  00
05618:  MOVWF  01
0561A:  BRA    568E
....................     } 
....................  
....................     // Network to host conversion. 
....................     SwapIPHeader(&header); 
0561C:  MOVLW  02
0561E:  MOVWF  xDB
05620:  MOVLW  56
05622:  MOVWF  xDA
05624:  MOVLB  0
05626:  CALL   1D10
....................  
....................     // If caller is intrested, return destination IP address 
....................     // as seen in this IP header. 
....................     if ( localIP ) 
0562A:  MOVLB  2
0562C:  MOVF   x4C,W
0562E:  IORWF  x4D,W
05630:  BZ    564A
....................         localIP->Val    = header.DestAddress.Val; 
05632:  MOVFF  24C,FE9
05636:  MOVFF  24D,FEA
0563A:  MOVFF  266,FEF
0563E:  MOVFF  267,FEC
05642:  MOVFF  268,FEC
05646:  MOVFF  269,FEC
....................  
....................     remote->IPAddr.Val  = header.SourceAddress.Val; 
0564A:  MOVFF  24E,FE9
0564E:  MOVF   x4F,W
05650:  MOVWF  FEA
05652:  MOVFF  262,FEF
05656:  MOVFF  263,FEC
0565A:  MOVFF  264,FEC
0565E:  MOVFF  265,FEC
....................     *protocol           = header.Protocol; 
05662:  MOVFF  250,FE9
05666:  MOVFF  251,FEA
0566A:  MOVFF  25F,FEF
....................     *len 				= header.TotalLength - IPHeaderLen; 
0566E:  MOVFF  252,FE9
05672:  MOVFF  253,FEA
05676:  MOVLB  1
05678:  MOVF   x27,W
0567A:  MOVLB  2
0567C:  SUBWF  x58,W
0567E:  MOVWF  00
05680:  MOVLW  00
05682:  SUBWFB x59,W
05684:  MOVFF  00,FEF
05688:  MOVWF  FEC
....................  
....................     return TRUE; 
0568A:  MOVLW  01
0568C:  MOVWF  01
0568E:  MOVLB  0
05690:  GOTO   7562 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function: WORD IPPutHeader(NODE_INFO *remote, 
....................  *           				  BYTE protocol, 
....................  *                			  WORD len) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           *remote     - Destination node address 
....................  *                  protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          (WORD)0 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  ********************************************************************/ 
.................... WORD IPPutHeader(NODE_INFO *remote, 
....................                  BYTE protocol, 
....................                  WORD len) 
.................... { 
....................     IP_HEADER   header; 
....................      
....................     IPHeaderLen = sizeof(IP_HEADER); 
*
01EB0:  MOVLW  14
01EB2:  MOVLB  1
01EB4:  MOVWF  x27
....................  
....................     header.VersionIHL       = IP_VERSION | IP_IHL; 
01EB6:  MOVLW  45
01EB8:  MOVLB  2
01EBA:  MOVWF  xC6
....................     header.TypeOfService    = IP_SERVICE; 
01EBC:  CLRF   xC7
....................     header.TotalLength      = sizeof(header) + len; 
01EBE:  MOVLW  14
01EC0:  ADDWF  xC4,W
01EC2:  MOVWF  xC8
01EC4:  MOVLW  00
01EC6:  ADDWFC xC5,W
01EC8:  MOVWF  xC9
....................     header.Identification   = ++_Identifier; 
01ECA:  MOVLB  1
01ECC:  INCF   x25,F
01ECE:  BTFSC  FD8.2
01ED0:  INCF   x26,F
01ED2:  MOVFF  126,2CB
01ED6:  MOVFF  125,2CA
....................     header.FragmentInfo     = 0; 
01EDA:  MOVLB  2
01EDC:  CLRF   xCD
01EDE:  CLRF   xCC
....................     header.TimeToLive       = MY_IP_TTL; 
01EE0:  MOVLW  64
01EE2:  MOVWF  xCE
....................     header.Protocol         = protocol; 
01EE4:  MOVFF  2C3,2CF
....................     header.HeaderChecksum   = 0; 
01EE8:  CLRF   xD1
01EEA:  CLRF   xD0
.................... 	header.SourceAddress 	= AppConfig.MyIPAddr; 
01EEC:  MOVFF  2C,2D5
01EF0:  MOVFF  2B,2D4
01EF4:  MOVFF  2A,2D3
01EF8:  MOVFF  29,2D2
....................  
....................     header.DestAddress.Val = remote->IPAddr.Val; 
01EFC:  MOVFF  2C1,FE9
01F00:  MOVFF  2C2,FEA
01F04:  MOVFF  FEF,2D6
01F08:  MOVFF  FEC,2D7
01F0C:  MOVFF  FEC,2D8
01F10:  MOVFF  FEC,2D9
....................  
....................     SwapIPHeader(&header); 
01F14:  MOVLW  02
01F16:  MOVWF  xDB
01F18:  MOVLW  C6
01F1A:  MOVWF  xDA
01F1C:  MOVLB  0
01F1E:  RCALL  1D10
....................  
....................     header.HeaderChecksum   = CalcIPChecksum((BYTE*)&header, sizeof(header)); 
01F20:  MOVLW  02
01F22:  MOVLB  2
01F24:  MOVWF  xDB
01F26:  MOVLW  C6
01F28:  MOVWF  xDA
01F2A:  MOVFF  2DB,2DD
01F2E:  MOVWF  xDC
01F30:  CLRF   xDF
01F32:  MOVLW  14
01F34:  MOVWF  xDE
01F36:  MOVLB  0
01F38:  RCALL  1C28
01F3A:  MOVFF  02,2D1
01F3E:  MOVFF  01,2D0
....................  
....................     MACPutHeader(&remote->MACAddr, MAC_IP, (sizeof(header)+len)); 
01F42:  MOVLW  04
01F44:  MOVLB  2
01F46:  ADDWF  xC1,W
01F48:  MOVWF  01
01F4A:  MOVLW  00
01F4C:  ADDWFC xC2,W
01F4E:  MOVWF  03
01F50:  MOVFF  01,2DA
01F54:  MOVWF  xDB
01F56:  MOVLW  14
01F58:  ADDWF  xC4,W
01F5A:  MOVWF  xDC
01F5C:  MOVLW  00
01F5E:  ADDWFC xC5,W
01F60:  MOVWF  xDD
01F62:  MOVFF  03,2DF
01F66:  MOVFF  01,2DE
01F6A:  CLRF   xE0
01F6C:  MOVWF  xE2
01F6E:  MOVFF  2DC,2E1
01F72:  MOVLB  0
01F74:  RCALL  1DEA
....................     MACPutArray((BYTE*)&header, sizeof(header)); 
01F76:  MOVLW  02
01F78:  MOVLB  2
01F7A:  MOVWF  xDB
01F7C:  MOVLW  C6
01F7E:  MOVWF  xDA
01F80:  MOVFF  2DB,2E6
01F84:  MOVWF  xE5
01F86:  CLRF   xE8
01F88:  MOVLW  14
01F8A:  MOVWF  xE7
01F8C:  MOVLB  0
01F8E:  CALL   0DDC
....................  
....................     return 0x0000; 
01F92:  MOVLW  00
01F94:  MOVWF  01
01F96:  MOVWF  02
01F98:  RETURN 0
....................  
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by  
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset  
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset)  
.................... { 
.................... 	MACSetReadPtrInRx(Offset+IPHeaderLen); 
*
0393C:  MOVLB  1
0393E:  MOVF   x27,W
03940:  MOVLB  2
03942:  ADDWF  x9B,W
03944:  MOVWF  x9D
03946:  MOVLW  00
03948:  ADDWFC x9C,W
0394A:  MOVWF  x9E
0394C:  MOVWF  xA0
0394E:  MOVFF  29D,29F
03952:  MOVLB  0
03954:  RCALL  38E6
03956:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... static void SwapIPHeader(IP_HEADER* h) 
.................... { 
....................     h->TotalLength      = swaps(h->TotalLength); 
*
01D10:  MOVLW  02
01D12:  MOVLB  2
01D14:  ADDWF  xDA,W
01D16:  MOVWF  01
01D18:  MOVLW  00
01D1A:  ADDWFC xDB,W
01D1C:  MOVWF  03
01D1E:  MOVFF  01,2DC
01D22:  MOVWF  xDD
01D24:  MOVLW  02
01D26:  ADDWF  xDA,W
01D28:  MOVWF  FE9
01D2A:  MOVLW  00
01D2C:  ADDWFC xDB,W
01D2E:  MOVWF  FEA
01D30:  MOVFF  FEC,2DF
01D34:  MOVF   FED,F
01D36:  MOVFF  FEF,2DE
01D3A:  MOVFF  2DF,2E1
01D3E:  MOVFF  2DE,2E0
01D42:  MOVLB  0
01D44:  RCALL  1874
01D46:  MOVFF  2DD,FEA
01D4A:  MOVFF  2DC,FE9
01D4E:  MOVFF  02,FEC
01D52:  MOVF   FED,F
01D54:  MOVFF  01,FEF
....................     h->Identification   = swaps(h->Identification); 
01D58:  MOVLW  04
01D5A:  MOVLB  2
01D5C:  ADDWF  xDA,W
01D5E:  MOVWF  01
01D60:  MOVLW  00
01D62:  ADDWFC xDB,W
01D64:  MOVWF  03
01D66:  MOVFF  01,2DC
01D6A:  MOVWF  xDD
01D6C:  MOVLW  04
01D6E:  ADDWF  xDA,W
01D70:  MOVWF  FE9
01D72:  MOVLW  00
01D74:  ADDWFC xDB,W
01D76:  MOVWF  FEA
01D78:  MOVFF  FEC,2DF
01D7C:  MOVF   FED,F
01D7E:  MOVFF  FEF,2DE
01D82:  MOVFF  2DF,2E1
01D86:  MOVFF  2DE,2E0
01D8A:  MOVLB  0
01D8C:  RCALL  1874
01D8E:  MOVFF  2DD,FEA
01D92:  MOVFF  2DC,FE9
01D96:  MOVFF  02,FEC
01D9A:  MOVF   FED,F
01D9C:  MOVFF  01,FEF
....................     h->HeaderChecksum   = swaps(h->HeaderChecksum); 
01DA0:  MOVLW  0A
01DA2:  MOVLB  2
01DA4:  ADDWF  xDA,W
01DA6:  MOVWF  01
01DA8:  MOVLW  00
01DAA:  ADDWFC xDB,W
01DAC:  MOVWF  03
01DAE:  MOVFF  01,2DC
01DB2:  MOVWF  xDD
01DB4:  MOVLW  0A
01DB6:  ADDWF  xDA,W
01DB8:  MOVWF  FE9
01DBA:  MOVLW  00
01DBC:  ADDWFC xDB,W
01DBE:  MOVWF  FEA
01DC0:  MOVFF  FEC,2DF
01DC4:  MOVF   FED,F
01DC6:  MOVFF  FEF,2DE
01DCA:  MOVFF  2DF,2E1
01DCE:  MOVFF  2DE,2E0
01DD2:  MOVLB  0
01DD4:  RCALL  1874
01DD6:  MOVFF  2DD,FEA
01DDA:  MOVFF  2DC,FE9
01DDE:  MOVFF  02,FEC
01DE2:  MOVF   FED,F
01DE4:  MOVFF  01,FEF
01DE8:  RETURN 0
.................... } 
....................  
.................... #include "ARP.c" 
.................... /********************************************************************* 
....................  * 
....................  *   Address Resolution Protocol (ARP) Client and Server 
....................  *  Module for Microchip TCP/IP Stack 
....................  *    -Provides IP address to Ethernet MAC address translation 
....................  *    -Reference: RFC 826 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.c 
....................  * Dependencies:    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  ARP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder      8/17/06   Combined ARP.c and ARPTsk.c into ARP.c;  
....................  *                        rewrote some of it to look more linear 
....................  * Darren Rook/CCS      Added call to GratArpReset() if using STACK_USE_CCS_GRATUITOUS_ARP 
....................  ********************************************************************/ 
.................... #define __ARP_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Constants and Variables 
....................   ***************************************************************************/ 
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... //#define ARP_OPERATION_REQ       0x01u      // Operation code indicating an ARP Request 
.................... //#define ARP_OPERATION_RESP      0x02u      // Operation code indicating an ARP Response 
....................  
.................... #define HW_ETHERNET             (0x0001u)   // ARP Hardware type as defined by IEEE 802.3 
.................... #define ARP_IP                  (0x0800u)   // ARP IP packet type as defined by IEEE 802.3 
.................... #endif 
....................  
.................... #ifdef STACK_CLIENT_MODE 
.................... static NODE_INFO Cache;                  // Cache for one ARP response 
.................... #endif 
....................  
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... #define MAX_REG_APPS            2           // MAX num allowed registrations of Modules/Apps 
.................... static struct arp_app_callbacks reg_apps[MAX_REG_APPS]; // Call-Backs storage for MAX of two Modules/Apps 
.................... /* 
.................... // ARP packet structure 
.................... typedef struct __attribute__((aligned(2), packed)) 
.................... { 
....................     WORD        HardwareType; 
....................     WORD        Protocol; 
....................     BYTE        MACAddrLen; 
....................     BYTE        ProtocolLen; 
....................     WORD        Operation; 
....................     MAC_ADDR    SenderMACAddr; 
....................     IP_ADDR     SenderIPAddr; 
....................     MAC_ADDR    TargetMACAddr; 
....................     IP_ADDR     TargetIPAddr; 
.................... } ARP_PACKET; 
.................... */ 
.................... #endif 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Helper Function Prototypes 
....................   ***************************************************************************/ 
....................  
.................... static BOOL ARPPut(ARP_PACKET* packet); 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Function Implementations 
....................   ***************************************************************************/ 
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... /************ User Application APIs ****************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    CHAR ARPRegisterCallbacks(struct arp_app_callbacks *app) 
....................  
....................   Summary: 
....................    Registering callback with ARP module to get notified about certian events. 
....................     
....................   Description: 
....................      This function allows end user application to register with callbacks, which 
....................     will be called by ARP module to give notification to user-application about  
....................     events occurred at ARP layer. For ex: when a ARP-packet is received, which is 
....................     conflicting with our own pair of addresses (MAC-Address and IP-address). 
....................     This is an extension for zeroconf protocol implementation (ZeroconfLL.c) 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    app - ARP-Application callbacks structure supplied by user-application  
....................      
....................   Returns: 
....................     id > 0 - Returns non-negative value that represents the id of registration 
....................              The same id needs to be used in de-registration 
....................     -1     - When registered applications exceed MAX_REG_APPS and there is no 
....................              free slot for registration 
....................   
....................   ***************************************************************************/ 
.................... CHAR ARPRegisterCallbacks(struct arp_app_callbacks *app) 
.................... { 
....................     BYTE i; 
....................     for(i=0; i<MAX_REG_APPS; i++) 
....................     { 
....................         if(!reg_apps[i].used) 
....................         { 
....................             reg_apps[i].ARPPkt_notify = app->ARPPkt_notify; 
....................             reg_apps[i].used = 1; 
....................             return (i+1); // Return Code. Should be used in deregister. 
....................         } 
....................     } 
....................     return -1; // No space for registration 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL ARPDeRegisterCallbacks(CHAR reg_id) 
....................  
....................   Summary: 
....................    De-Registering callbacks with ARP module that are registered previously. 
....................     
....................   Description: 
....................      This function allows end user-application to de-register with callbacks,  
....................     which were registered previously. 
....................     This is called by user-application, when its no longer interested in  
....................     notifications from ARP-Module. This allows the other application to get  
....................     registered with ARP-module.    
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    reg_id - Registration-id returned in ARPRegisterCallbacks call 
....................      
....................   Returns: 
....................     TRUE  - On success 
....................     FALSE - Failure to indicate invalid reg_id   
....................   ***************************************************************************/  
.................... BOOL ARPDeRegisterCallbacks(CHAR reg_id) 
.................... { 
....................     if(reg_id <= 0 || reg_id > MAX_REG_APPS) 
....................         return FALSE; 
....................  
....................     reg_apps[reg_id-1].used = 0; // To indicate free slot for registration 
....................    return TRUE; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ARPProcessRxPkt(ARP_PACKET* packet) 
....................  
....................   Summary: 
....................    Processes Received-ARP packet (ARP request/Reply). 
....................     
....................   Description: 
....................      This function is to pass-on the ARP-packet to registered application, 
....................     with the notification of Rx-ARP packet.  
....................  
....................   Precondition: 
....................    ARP packet is received completely from MAC 
....................  
....................   Parameters: 
....................    packet - Rx packet to be processed      
....................  
....................   Returns: 
....................     None    
....................   ***************************************************************************/ 
.................... void ARPProcessRxPkt(ARP_PACKET* packet) 
.................... { 
....................     BYTE pass_on = 0; // Flag to indicate whether need to be forwarded 
....................     BYTE i; 
....................  
....................     // Probing Stage 
....................     if(AppConfig.MyIPAddr.Val == 0x00) 
....................     { 
....................         pass_on = 1; // Pass to Registered-Application for further processing         
....................     } 
....................     else if(AppConfig.MyIPAddr.Val) 
....................     { 
....................         /* Late-conflict */ 
....................         if(packet->SenderIPAddr.Val == AppConfig.MyIPAddr.Val) 
....................         { 
....................             pass_on = 1; 
....................         } 
....................     } 
....................     if(pass_on) 
....................     { 
....................      
....................         for(i =0; i< MAX_REG_APPS; i++) 
....................         { 
....................             if(reg_apps[i].used) 
....................             { 
....................                 reg_apps[i].ARPPkt_notify(packet->SenderIPAddr.Val, 
....................                                       packet->TargetIPAddr.Val, 
....................                                       &packet->SenderMACAddr, 
....................                                       &packet->TargetMACAddr, 
....................                                       packet->Operation);                 
....................             } 
....................         } 
....................     } 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ARPSendPkt(IP_ADDR* SrcIPAddr, IP_ADDR* DestIPAddr, int op_req ) 
....................  
....................   Summary: 
....................    Transmits an ARP request/Reply initated by Application or external module. 
....................     
....................   Description: 
....................      This function transmits and ARP request/reply to determine the hardware 
....................      address of a given IP address (or) Announce self-address to all nodes in 
....................     network. Extended for zeroconf protocol.  
....................  
....................   Precondition: 
....................    ARP packet is ready in the MAC buffer. 
....................  
....................   Parameters: 
....................    SrcIPAddr - The Source IP-address  
....................     DestIPAddr - The Destination IP-Address 
....................     op_req     - Operation Request (ARP_REQ/ARP_RESP) 
....................  
....................   Returns: 
....................     TRUE - The ARP packet was generated properly 
....................      FALSE - Not possible return value 
....................  
....................   Remarks: 
....................      This API is to give control over AR-packet to external modules.  
....................   ***************************************************************************/ 
.................... BOOL ARPSendPkt(DWORD SrcIPAddr, DWORD DestIPAddr, BYTE op_req ) 
.................... { 
....................     ARP_PACKET packet; 
....................  
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... #define KS_ARP_IP_MULTICAST_HACK y 
.................... #ifdef KS_ARP_IP_MULTICAST_HACK 
....................    DWORD_VAL *DestAddr = (DWORD_VAL *)&DestIPAddr; 
....................    if ((DestAddr->v[0] >= 224) &&(DestAddr->v[0] <= 239)) { 
....................       // "Resolve" the IP to MAC address mapping for 
....................       // IP multicast address range from 224.0.0.0 to 239.255.255.255 
....................     
....................       Cache.MACAddr.v[0] = 0x01; 
....................       Cache.MACAddr.v[1] = 0x00; 
....................       Cache.MACAddr.v[2] = 0x5E; 
....................       Cache.MACAddr.v[3] = 0x7f & DestAddr->v[1]; 
....................       Cache.MACAddr.v[4] = DestAddr->v[2]; 
....................       Cache.MACAddr.v[5] = DestAddr->v[3]; 
....................     
....................       Cache.IPAddr.Val = DestAddr->Val; 
....................     
....................       return TRUE; 
....................    } 
.................... #endif 
.................... #endif 
....................  
....................     packet.Operation = op_req; 
....................    packet.TargetMACAddr.v[0]   = 0xff; 
....................    packet.TargetMACAddr.v[1]   = 0xff; 
....................    packet.TargetMACAddr.v[2]   = 0xff; 
....................    packet.TargetMACAddr.v[3]   = 0xff; 
....................    packet.TargetMACAddr.v[4]   = 0xff; 
....................    packet.TargetMACAddr.v[5]   = 0xff; 
....................  
....................     packet.TargetIPAddr.Val   = DestIPAddr; 
....................     packet.SenderIPAddr.Val = SrcIPAddr; 
....................  
....................     return ( ARPPut(&packet) ); 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static BOOL ARPPut(ARP_PACKET* packet) 
....................  
....................   Description: 
....................    Writes an ARP packet to the MAC. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    packet - A pointer to an ARP_PACKET structure with correct operation 
....................             and target preconfigured. 
....................  
....................   Return Values: 
....................      TRUE - The ARP packet was generated properly 
....................      FALSE - Not a possible return value 
....................   ***************************************************************************/ 
.................... static BOOL ARPPut(ARP_PACKET* packet) 
.................... { 
....................    while(!MACIsTxReady()); 
*
02F48:  CALL   168C
02F4C:  MOVF   01,F
02F4E:  BZ    2F48
....................    MACSetWritePtr(BASE_TX_ADDR); 
02F50:  MOVLW  17
02F52:  MOVLB  2
02F54:  MOVWF  xD1
02F56:  MOVLW  E5
02F58:  MOVWF  xD0
02F5A:  MOVLB  0
02F5C:  CALL   0D6C
....................     
....................  
....................     packet->HardwareType  = HW_ETHERNET; 
02F60:  MOVLB  2
02F62:  MOVFF  28E,FE9
02F66:  MOVFF  28F,FEA
02F6A:  CLRF   FEC
02F6C:  MOVF   FED,F
02F6E:  MOVLW  01
02F70:  MOVWF  FEF
....................     packet->Protocol      = ARP_IP; 
02F72:  MOVLW  02
02F74:  ADDWF  x8E,W
02F76:  MOVWF  FE9
02F78:  MOVLW  00
02F7A:  ADDWFC x8F,W
02F7C:  MOVWF  FEA
02F7E:  MOVLW  08
02F80:  MOVWF  FEC
02F82:  MOVF   FED,F
02F84:  CLRF   FEF
....................     packet->MACAddrLen    = sizeof(MAC_ADDR); 
02F86:  MOVLW  04
02F88:  ADDWF  x8E,W
02F8A:  MOVWF  FE9
02F8C:  MOVLW  00
02F8E:  ADDWFC x8F,W
02F90:  MOVWF  FEA
02F92:  MOVLW  06
02F94:  MOVWF  FEF
....................     packet->ProtocolLen   = sizeof(IP_ADDR); 
02F96:  MOVLW  05
02F98:  ADDWF  x8E,W
02F9A:  MOVWF  FE9
02F9C:  MOVLW  00
02F9E:  ADDWFC x8F,W
02FA0:  MOVWF  FEA
02FA2:  MOVLW  04
02FA4:  MOVWF  FEF
.................... //    packet->SenderMACAddr = AppConfig.MyMACAddr;   // HI-TECH PICC-18 compiler can't handle this statement, use memcpy() as a workaround 
....................    memcpy(&packet->SenderMACAddr, (void*)&AppConfig.MyMACAddr, sizeof(packet->SenderMACAddr)); 
02FA6:  MOVLW  08
02FA8:  ADDWF  x8E,W
02FAA:  MOVWF  01
02FAC:  MOVLW  00
02FAE:  ADDWFC x8F,W
02FB0:  MOVWF  03
02FB2:  MOVFF  01,290
02FB6:  MOVWF  x91
02FB8:  CLRF   x93
02FBA:  MOVLW  56
02FBC:  MOVFF  03,FEA
02FC0:  MOVFF  01,FE9
02FC4:  MOVFF  293,FE2
02FC8:  MOVWF  FE1
02FCA:  MOVLW  06
02FCC:  MOVWF  01
02FCE:  MOVFF  FE6,FEE
02FD2:  DECFSZ 01,F
02FD4:  BRA    2FCE
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................     //packet->SenderIPAddr  = AppConfig.MyIPAddr; /* Removed for ZCLL, SenderIPAddr should be filled in */ 
.................... #else 
....................     packet->SenderIPAddr  = AppConfig.MyIPAddr; 
02FD6:  MOVLW  0E
02FD8:  ADDWF  x8E,W
02FDA:  MOVWF  FE9
02FDC:  MOVLW  00
02FDE:  ADDWFC x8F,W
02FE0:  MOVWF  FEA
02FE2:  MOVFF  29,FEF
02FE6:  MOVFF  2A,FEC
02FEA:  MOVFF  2B,FEC
02FEE:  MOVFF  2C,FEC
.................... #endif 
....................  
....................     SwapARPPacket(packet); 
02FF2:  MOVFF  28F,291
02FF6:  MOVFF  28E,290
02FFA:  MOVLB  0
02FFC:  RCALL  2E6E
....................  
....................     MACPutHeader(&packet->TargetMACAddr, MAC_ARP, sizeof(*packet)); 
02FFE:  MOVLW  12
03000:  MOVLB  2
03002:  ADDWF  x8E,W
03004:  MOVWF  01
03006:  MOVLW  00
03008:  ADDWFC x8F,W
0300A:  MOVWF  03
0300C:  MOVFF  01,290
03010:  MOVWF  x91
03012:  MOVWF  xDF
03014:  MOVFF  01,2DE
03018:  MOVLW  06
0301A:  MOVWF  xE0
0301C:  CLRF   xE2
0301E:  MOVLW  1C
03020:  MOVWF  xE1
03022:  MOVLB  0
03024:  CALL   1DEA
....................     MACPutArray((BYTE*)packet, sizeof(*packet)); 
03028:  MOVFF  28F,2E6
0302C:  MOVFF  28E,2E5
03030:  MOVLB  2
03032:  CLRF   xE8
03034:  MOVLW  1C
03036:  MOVWF  xE7
03038:  MOVLB  0
0303A:  CALL   0DDC
....................     MACFlush(); 
0303E:  CALL   20E2
....................     
....................    return TRUE; 
03042:  MOVLW  01
03044:  MOVWF  01
03046:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ARPInit(void) 
....................  
....................   Summary: 
....................    Initializes the ARP module. 
....................     
....................   Description: 
....................      Initializes the ARP module.  Call this function once at boot to  
....................      invalidate the cached lookup. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................      None 
....................    
....................   Remarks: 
....................      This function is only required when the stack is a client, and therefore 
....................      is only enabled when STACK_CLIENT_MODE is enabled. 
....................   ***************************************************************************/ 
.................... #ifdef STACK_CLIENT_MODE 
.................... void ARPInit(void) 
.................... { 
....................     Cache.MACAddr.v[0] = 0xff; 
*
00BEE:  MOVLB  1
00BF0:  SETF   x2C
....................     Cache.MACAddr.v[1] = 0xff; 
00BF2:  SETF   x2D
....................     Cache.MACAddr.v[2] = 0xff; 
00BF4:  SETF   x2E
....................     Cache.MACAddr.v[3] = 0xff; 
00BF6:  SETF   x2F
....................     Cache.MACAddr.v[4] = 0xff; 
00BF8:  SETF   x30
....................     Cache.MACAddr.v[5] = 0xff; 
00BFA:  SETF   x31
....................  
....................    Cache.IPAddr.Val = 0xfffffffful; 
00BFC:  SETF   x2B
00BFE:  SETF   x2A
00C00:  SETF   x29
00C02:  SETF   x28
00C04:  MOVLB  0
00C06:  GOTO   1682 (RETURN)
.................... } 
.................... #endif 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL ARPProcess(void) 
....................  
....................   Summary: 
....................    Processes an incoming ARP packet. 
....................     
....................   Description: 
....................      Retrieves an ARP packet from the MAC buffer and determines if it is a 
....................      response to our request (in which case the ARP is resolved) or if it 
....................      is a request requiring our response (in which case we transmit one.) 
....................  
....................   Precondition: 
....................    ARP packet is ready in the MAC buffer. 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Return Values: 
....................      TRUE - All processing of this ARP packet is complete.  Do not call  
....................            again until a new ARP packet is waiting in the RX buffer. 
....................      FALSE - This function must be called again.  More time is needed to  
....................            send an ARP response. 
....................   ***************************************************************************/ 
.................... BOOL ARPProcess(void) 
.................... { 
....................    ARP_PACKET packet; 
....................    static NODE_INFO Target; 
....................     #if defined(STACK_USE_AUTO_IP) 
....................         BYTE i; 
....................     #endif 
....................    static enum 
....................    { 
....................        SM_ARP_IDLE = 0, 
....................        SM_ARP_REPLY 
....................    } smARP = SM_ARP_IDLE; 
....................  
....................     switch(smARP) 
*
0538A:  MOVLW  00
0538C:  MOVLB  1
0538E:  BTFSC  x0D.2
05390:  MOVLW  01
05392:  XORLW  00
05394:  MOVLB  0
05396:  BZ    53A0
05398:  XORLW  01
0539A:  BTFSC  FD8.2
0539C:  BRA    5482
0539E:  BRA    54D6
....................     { 
....................        case SM_ARP_IDLE: 
....................          // Obtain the incoming ARP packet 
....................           MACGetArray((BYTE*)&packet, sizeof(packet));       
053A0:  MOVLW  02
053A2:  MOVLB  2
053A4:  MOVWF  x69
053A6:  MOVLW  4C
053A8:  MOVWF  x68
053AA:  MOVFF  269,2E4
053AE:  MOVWF  xE3
053B0:  CLRF   xE6
053B2:  MOVLW  1C
053B4:  MOVWF  xE5
053B6:  MOVLB  0
053B8:  CALL   0E8E
....................           MACDiscardRx(); 
053BC:  CALL   3A06
....................           SwapARPPacket(&packet); 
053C0:  MOVLW  02
053C2:  MOVLB  2
053C4:  MOVWF  x91
053C6:  MOVLW  4C
053C8:  MOVWF  x90
053CA:  MOVLB  0
053CC:  CALL   2E6E
....................        
....................          // Validate the ARP packet 
....................           if ( packet.HardwareType != HW_ETHERNET     || 
....................                packet.MACAddrLen != sizeof(MAC_ADDR)  || 
....................                packet.ProtocolLen != sizeof(IP_ADDR) ) 
053D0:  MOVLB  2
053D2:  DECFSZ x4C,W
053D4:  BRA    53E6
053D6:  MOVF   x4D,F
053D8:  BNZ   53E6
053DA:  MOVF   x50,W
053DC:  SUBLW  06
053DE:  BNZ   53E6
053E0:  MOVF   x51,W
053E2:  SUBLW  04
053E4:  BZ    53EC
....................           { 
....................                return TRUE; 
053E6:  MOVLW  01
053E8:  MOVWF  01
053EA:  BRA    54DC
....................           } 
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................          ARPProcessRxPkt(&packet); 
.................... #endif 
....................  
.................... #ifdef STACK_USE_AUTO_IP 
....................             if (packet.SenderIPAddr.Val == AppConfig.MyIPAddr.Val) 
....................             { 
....................                 AutoIPConflict(0); 
....................                 return TRUE;                 
....................             } 
.................... #endif 
.................... #ifdef STACK_USE_CCS_GRATUITOUS_ARP 
.................... GratArpReset(); 
.................... #endif 
....................          // Handle incoming ARP responses 
.................... #ifdef STACK_CLIENT_MODE 
....................          if(packet.Operation == ARP_OPERATION_RESP) 
053EC:  MOVF   x52,W
053EE:  SUBLW  02
053F0:  BNZ   5428
053F2:  MOVF   x53,F
053F4:  BNZ   5428
....................          { 
.................... /*                #if defined(STACK_USE_AUTO_IP) 
....................                 for (i = 0; i < NETWORK_INTERFACES; i++) 
....................                     if (AutoIPConfigIsInProgress(i)) 
....................                         AutoIPConflict(i); 
....................                 #endif*/ 
....................             Cache.MACAddr = packet.SenderMACAddr; 
053F6:  MOVLW  01
053F8:  MOVWF  FEA
053FA:  MOVLW  2C
053FC:  MOVWF  FE9
053FE:  MOVLW  02
05400:  MOVWF  FE2
05402:  MOVLW  54
05404:  MOVWF  FE1
05406:  MOVLW  06
05408:  MOVWF  01
0540A:  MOVFF  FE6,FEE
0540E:  DECFSZ 01,F
05410:  BRA    540A
....................             Cache.IPAddr = packet.SenderIPAddr; 
05412:  MOVFF  25D,12B
05416:  MOVFF  25C,12A
0541A:  MOVFF  25B,129
0541E:  MOVFF  25A,128
....................             return TRUE; 
05422:  MOVLW  01
05424:  MOVWF  01
05426:  BRA    54DC
....................          } 
.................... #endif 
....................  
....................          // Handle incoming ARP requests for our MAC address 
....................          if(packet.Operation == ARP_OPERATION_REQ) 
05428:  DECFSZ x52,W
0542A:  BRA    5480
0542C:  MOVF   x53,F
0542E:  BNZ   5480
....................          { 
....................             if(packet.TargetIPAddr.Val != AppConfig.MyIPAddr.Val) 
05430:  MOVF   29,W
05432:  SUBWF  x64,W
05434:  BNZ   5448
05436:  MOVF   2A,W
05438:  SUBWF  x65,W
0543A:  BNZ   5448
0543C:  MOVF   2B,W
0543E:  SUBWF  x66,W
05440:  BNZ   5448
05442:  MOVF   2C,W
05444:  SUBWF  x67,W
05446:  BZ    544E
....................             { 
....................                return TRUE; 
05448:  MOVLW  01
0544A:  MOVWF  01
0544C:  BRA    54DC
....................             } 
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................                                /* Fix for Loop-Back suppression: 
....................                                 * For ZCLL-Claim packets, host should not respond. 
....................                                 * Check Sender's MAC-address with own MAC-address and  
....................                                 * if it is matched, response will not be sent back. This 
....................                                 * was leading to flooding of ARP-answeres */ 
....................                                 if(!memcmp (&packet.SenderMACAddr, &AppConfig.MyMACAddr, 6)) 
....................                                 { 
....................                                      putsUART("Loopback answer suppressed \r\n"); 
....................                                      return TRUE; 
....................                                 } 
.................... #endif 
....................                 #if defined(STACK_USE_AUTO_IP) 
....................                 for (i = 0; i < NETWORK_INTERFACES; i++) 
....................                     if (AutoIPConfigIsInProgress(i)) 
....................                     { 
....................                         AutoIPConflict(i); 
....................                         return TRUE; 
....................                     }              
....................                 #endif 
....................             Target.IPAddr = packet.SenderIPAddr; 
0544E:  MOVFF  25D,135
05452:  MOVFF  25C,134
05456:  MOVFF  25B,133
0545A:  MOVFF  25A,132
....................             Target.MACAddr = packet.SenderMACAddr; 
0545E:  MOVLW  01
05460:  MOVWF  FEA
05462:  MOVLW  36
05464:  MOVWF  FE9
05466:  MOVLW  02
05468:  MOVWF  FE2
0546A:  MOVLW  54
0546C:  MOVWF  FE1
0546E:  MOVLW  06
05470:  MOVWF  01
05472:  MOVFF  FE6,FEE
05476:  DECFSZ 01,F
05478:  BRA    5472
....................  
....................             smARP = SM_ARP_REPLY; 
0547A:  MOVLB  1
0547C:  BSF    x0D.2
0547E:  MOVLB  2
05480:  MOVLB  0
....................          } 
....................          // Do not break.  If we get down here, we need to send a reply.    
....................  
....................        case SM_ARP_REPLY: 
....................            packet.Operation      = ARP_OPERATION_RESP; 
05482:  MOVLB  2
05484:  CLRF   x53
05486:  MOVLW  02
05488:  MOVWF  x52
....................             #if defined(STACK_USE_AUTO_IP) 
....................             if (AutoIPIsConfigured(0)) 
....................             { 
....................                 packet.TargetMACAddr.v[0] = 0xFF; 
....................                 packet.TargetMACAddr.v[1] = 0xFF; 
....................                 packet.TargetMACAddr.v[2] = 0xFF; 
....................                 packet.TargetMACAddr.v[3] = 0xFF; 
....................                 packet.TargetMACAddr.v[4] = 0xFF; 
....................                 packet.TargetMACAddr.v[5] = 0xFF; 
....................             } 
....................             else 
....................             #endif 
....................                packet.TargetMACAddr   = Target.MACAddr; 
0548A:  MOVWF  FEA
0548C:  MOVLW  5E
0548E:  MOVWF  FE9
05490:  MOVLW  01
05492:  MOVWF  FE2
05494:  MOVLW  36
05496:  MOVWF  FE1
05498:  MOVLW  06
0549A:  MOVWF  01
0549C:  MOVFF  FE6,FEE
054A0:  DECFSZ 01,F
054A2:  BRA    549C
....................            packet.TargetIPAddr      = Target.IPAddr; 
054A4:  MOVFF  135,267
054A8:  MOVFF  134,266
054AC:  MOVFF  133,265
054B0:  MOVFF  132,264
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................             packet.SenderIPAddr      = AppConfig.MyIPAddr; 
.................... #endif 
....................  
....................          // Send an ARP response to a previously received request 
....................          if(!ARPPut(&packet)) 
054B4:  MOVLW  02
054B6:  MOVWF  x8F
054B8:  MOVLW  4C
054BA:  MOVWF  x8E
054BC:  MOVLB  0
054BE:  CALL   2F48
054C2:  MOVF   01,F
054C4:  BNZ   54D0
....................          { 
....................               return FALSE; 
054C6:  MOVLW  00
054C8:  MOVWF  01
054CA:  MOVLB  2
054CC:  BRA    54DC
054CE:  MOVLB  0
....................          } 
....................  
....................          // Begin listening for ARP requests again 
....................          smARP = SM_ARP_IDLE; 
054D0:  MOVLB  1
054D2:  BCF    x0D.2
....................            break; 
054D4:  MOVLB  0
....................    } 
....................  
....................     return TRUE; 
054D6:  MOVLW  01
054D8:  MOVWF  01
054DA:  MOVLB  2
054DC:  MOVLB  0
054DE:  GOTO   7668 (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ARPResolve(IP_ADDR* IPAddr) 
....................  
....................   Summary: 
....................    Transmits an ARP request to resolve an IP address. 
....................     
....................   Description: 
....................      This function transmits and ARP request to determine the hardware 
....................      address of a given IP address. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    IPAddr - The IP address to be resolved.  The address must be specified  
....................           in network byte order (big endian). 
....................  
....................   Returns: 
....................      None 
....................  
....................   Remarks: 
....................      This function is only required when the stack is a client, and therefore 
....................      is only enabled when STACK_CLIENT_MODE is enabled. 
....................  
....................    To retrieve the ARP query result, call the ARPIsResolved() function. 
....................   ***************************************************************************/ 
.................... #ifdef STACK_CLIENT_MODE 
.................... void ARPResolve(IP_ADDR* IPAddr) 
.................... { 
....................     ARP_PACKET packet; 
....................  
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... #define KS_ARP_IP_MULTICAST_HACK y 
.................... #ifdef KS_ARP_IP_MULTICAST_HACK 
....................     if ((IPAddr->v[0] >= 224) &&(IPAddr->v[0] <= 239)) 
....................     { 
....................       // "Resolve" the IP to MAC address mapping for 
....................       // IP multicast address range from 224.0.0.0 to 239.255.255.255 
....................  
....................       Cache.MACAddr.v[0] = 0x01; 
....................       Cache.MACAddr.v[1] = 0x00; 
....................       Cache.MACAddr.v[2] = 0x5E; 
....................       Cache.MACAddr.v[3] = 0x7f & IPAddr->v[1]; 
....................       Cache.MACAddr.v[4] = IPAddr->v[2]; 
....................       Cache.MACAddr.v[5] = IPAddr->v[3]; 
....................  
....................       Cache.IPAddr.Val = IPAddr->Val; 
....................  
....................       return; 
....................    } 
.................... #endif 
.................... #endif 
....................  
....................    packet.Operation            = ARP_OPERATION_REQ; 
*
03048:  MOVLB  2
0304A:  CLRF   x79
0304C:  MOVLW  01
0304E:  MOVWF  x78
....................    packet.TargetMACAddr.v[0]   = 0xff; 
03050:  SETF   x84
....................    packet.TargetMACAddr.v[1]   = 0xff; 
03052:  SETF   x85
....................    packet.TargetMACAddr.v[2]   = 0xff; 
03054:  SETF   x86
....................    packet.TargetMACAddr.v[3]   = 0xff; 
03056:  SETF   x87
....................    packet.TargetMACAddr.v[4]   = 0xff; 
03058:  SETF   x88
....................    packet.TargetMACAddr.v[5]   = 0xff; 
0305A:  SETF   x89
....................  
....................  
....................     // ARP query either the IP address directly (on our subnet), or do an ARP query for our Gateway if off of our subnet 
....................    packet.TargetIPAddr         = ((AppConfig.MyIPAddr.Val ^ IPAddr->Val) & AppConfig.MyMask.Val) ? AppConfig.MyGateway : *IPAddr; 
0305C:  MOVFF  270,FE9
03060:  MOVFF  271,FEA
03064:  MOVFF  FEF,00
03068:  MOVFF  FEC,01
0306C:  MOVFF  FEC,02
03070:  MOVFF  FEC,03
03074:  MOVF   00,W
03076:  XORWF  29,W
03078:  MOVWF  x8E
0307A:  MOVF   01,W
0307C:  XORWF  2A,W
0307E:  MOVWF  x8F
03080:  MOVF   02,W
03082:  XORWF  2B,W
03084:  MOVWF  x90
03086:  MOVF   03,W
03088:  XORWF  2C,W
0308A:  MOVWF  x91
0308C:  MOVF   x8E,W
0308E:  ANDWF  2D,W
03090:  MOVWF  00
03092:  MOVF   x8F,W
03094:  ANDWF  2E,W
03096:  MOVWF  01
03098:  MOVF   x90,W
0309A:  ANDWF  2F,W
0309C:  MOVWF  02
0309E:  MOVF   x91,W
030A0:  ANDWF  30,W
030A2:  MOVWF  03
030A4:  MOVF   00,F
030A6:  BNZ   30B4
030A8:  MOVF   01,F
030AA:  BNZ   30B4
030AC:  MOVF   02,F
030AE:  BNZ   30B4
030B0:  MOVF   03,F
030B2:  BZ    30C6
030B4:  MOVFF  31,00
030B8:  MOVFF  32,01
030BC:  MOVFF  33,02
030C0:  MOVFF  34,03
030C4:  BRA    30DE
030C6:  MOVFF  270,FE9
030CA:  MOVFF  271,FEA
030CE:  MOVFF  FEF,00
030D2:  MOVFF  FEC,01
030D6:  MOVFF  FEC,02
030DA:  MOVFF  FEC,03
030DE:  MOVFF  00,28A
030E2:  MOVFF  01,28B
030E6:  MOVFF  02,28C
030EA:  MOVFF  03,28D
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................    packet.SenderIPAddr         = AppConfig.MyIPAddr; 
.................... #endif 
....................  
....................     ARPPut(&packet); 
030EE:  MOVLW  02
030F0:  MOVWF  x8F
030F2:  MOVLW  72
030F4:  MOVWF  x8E
030F6:  MOVLB  0
030F8:  RCALL  2F48
030FA:  RETURN 0
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL ARPIsResolved(IP_ADDR* IPAddr, MAC_ADDR* MACAddr) 
....................  
....................   Summary: 
....................    Determines if an ARP request has been resolved yet. 
....................     
....................   Description: 
....................      This function checks if an ARP request has been resolved yet, and if 
....................      so, stores the resolved MAC address in the pointer provided. 
....................  
....................   Precondition: 
....................    ARP packet is ready in the MAC buffer. 
....................  
....................   Parameters: 
....................    IPAddr - The IP address to be resolved.  This must match the IP address  
....................           provided to the ARPResolve() function call. 
....................    MACAddr - A buffer to store the corresponding MAC address retrieved from  
....................           the ARP query. 
....................  
....................   Return Values: 
....................      TRUE - The IP address has been resolved and MACAddr MAC address field 
....................          indicates the response. 
....................      FALSE -   The IP address is not yet resolved.  Try calling ARPIsResolved()  
....................          again at a later time.  If you don't get a response after a  
....................          application specific timeout period, you may want to call  
....................          ARPResolve() again to transmit another ARP query (in case if the  
....................          original query or response was lost on the network).  If you never  
....................          receive an ARP response, this may indicate that the IP address  
....................          isn't in use. 
....................  
....................   Remarks: 
....................      This function is only required when the stack is a client, and therefore 
....................      is only enabled when STACK_CLIENT_MODE is enabled. 
....................   ***************************************************************************/ 
.................... #ifdef STACK_CLIENT_MODE 
.................... BOOL ARPIsResolved(IP_ADDR* IPAddr, MAC_ADDR* MACAddr) 
.................... { 
....................     if((Cache.IPAddr.Val == IPAddr->Val) ||  
....................      ((Cache.IPAddr.Val == AppConfig.MyGateway.Val) && ((AppConfig.MyIPAddr.Val ^ IPAddr->Val) & AppConfig.MyMask.Val))) 
030FC:  MOVLB  2
030FE:  MOVFF  270,FE9
03102:  MOVFF  271,FEA
03106:  MOVFF  FEF,00
0310A:  MOVFF  FEC,01
0310E:  MOVFF  FEC,02
03112:  MOVFF  FEC,03
03116:  MOVF   00,W
03118:  MOVLB  1
0311A:  SUBWF  x28,W
0311C:  BNZ   3130
0311E:  MOVF   01,W
03120:  SUBWF  x29,W
03122:  BNZ   3130
03124:  MOVF   02,W
03126:  SUBWF  x2A,W
03128:  BNZ   3130
0312A:  MOVF   03,W
0312C:  SUBWF  x2B,W
0312E:  BZ    31BC
03130:  MOVF   31,W
03132:  SUBWF  x28,W
03134:  BNZ   31E6
03136:  MOVF   32,W
03138:  SUBWF  x29,W
0313A:  BNZ   31E6
0313C:  MOVF   33,W
0313E:  SUBWF  x2A,W
03140:  BNZ   31E6
03142:  MOVF   34,W
03144:  SUBWF  x2B,W
03146:  BNZ   31E6
03148:  MOVLB  2
0314A:  MOVFF  270,FE9
0314E:  MOVFF  271,FEA
03152:  MOVFF  FEF,00
03156:  MOVFF  FEC,01
0315A:  MOVFF  FEC,02
0315E:  MOVFF  FEC,03
03162:  MOVF   00,W
03164:  XORWF  29,W
03166:  MOVWF  x74
03168:  MOVF   01,W
0316A:  XORWF  2A,W
0316C:  MOVWF  x75
0316E:  MOVF   02,W
03170:  XORWF  2B,W
03172:  MOVWF  x76
03174:  MOVF   03,W
03176:  XORWF  2C,W
03178:  MOVWF  x77
0317A:  MOVF   x74,W
0317C:  ANDWF  2D,W
0317E:  MOVWF  00
03180:  MOVF   x75,W
03182:  ANDWF  2E,W
03184:  MOVWF  01
03186:  MOVF   x76,W
03188:  ANDWF  2F,W
0318A:  MOVWF  02
0318C:  MOVF   x77,W
0318E:  ANDWF  30,W
03190:  MOVWF  03
03192:  MOVF   00,F
03194:  BTFSC  FD8.2
03196:  BRA    319C
03198:  MOVLB  1
0319A:  BRA    31BC
0319C:  MOVF   01,F
0319E:  BTFSC  FD8.2
031A0:  BRA    31A6
031A2:  MOVLB  1
031A4:  BRA    31BC
031A6:  MOVF   02,F
031A8:  BTFSC  FD8.2
031AA:  BRA    31B0
031AC:  MOVLB  1
031AE:  BRA    31BC
031B0:  MOVF   03,F
031B2:  BTFSS  FD8.2
031B4:  BRA    31BA
031B6:  MOVLB  1
031B8:  BRA    31E6
031BA:  MOVLB  1
....................     { 
....................         *MACAddr = Cache.MACAddr; 
031BC:  MOVFF  273,03
031C0:  MOVLB  2
031C2:  MOVFF  272,FE9
031C6:  MOVFF  273,FEA
031CA:  MOVLW  01
031CC:  MOVWF  FE2
031CE:  MOVLW  2C
031D0:  MOVWF  FE1
031D2:  MOVLW  06
031D4:  MOVWF  01
031D6:  MOVFF  FE6,FEE
031DA:  DECFSZ 01,F
031DC:  BRA    31D6
....................         return TRUE; 
031DE:  MOVLW  01
031E0:  MOVWF  01
031E2:  BRA    31EC
031E4:  MOVLB  1
....................     } 
....................     return FALSE; 
031E6:  MOVLW  00
031E8:  MOVWF  01
031EA:  MOVLB  2
031EC:  MOVLB  0
031EE:  RETURN 0
.................... } 
.................... #endif 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void SwapARPPacket(ARP_PACKET* p) 
....................  
....................   Description: 
....................      Swaps endian-ness of header information in an ARP packet. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    p - The ARP packet to be swapped 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... void SwapARPPacket(ARP_PACKET* p) 
.................... { 
....................     p->HardwareType     = swaps(p->HardwareType); 
*
02E6E:  MOVLB  2
02E70:  MOVFF  290,01
02E74:  MOVFF  291,03
02E78:  MOVFF  290,292
02E7C:  MOVFF  291,293
02E80:  MOVFF  290,FE9
02E84:  MOVFF  291,FEA
02E88:  MOVFF  FEC,295
02E8C:  MOVF   FED,F
02E8E:  MOVFF  FEF,294
02E92:  MOVFF  295,2E1
02E96:  MOVFF  294,2E0
02E9A:  MOVLB  0
02E9C:  CALL   1874
02EA0:  MOVFF  293,FEA
02EA4:  MOVFF  292,FE9
02EA8:  MOVFF  02,FEC
02EAC:  MOVF   FED,F
02EAE:  MOVFF  01,FEF
....................     p->Protocol         = swaps(p->Protocol); 
02EB2:  MOVLW  02
02EB4:  MOVLB  2
02EB6:  ADDWF  x90,W
02EB8:  MOVWF  01
02EBA:  MOVLW  00
02EBC:  ADDWFC x91,W
02EBE:  MOVWF  03
02EC0:  MOVFF  01,292
02EC4:  MOVWF  x93
02EC6:  MOVLW  02
02EC8:  ADDWF  x90,W
02ECA:  MOVWF  FE9
02ECC:  MOVLW  00
02ECE:  ADDWFC x91,W
02ED0:  MOVWF  FEA
02ED2:  MOVFF  FEC,295
02ED6:  MOVF   FED,F
02ED8:  MOVFF  FEF,294
02EDC:  MOVFF  295,2E1
02EE0:  MOVFF  294,2E0
02EE4:  MOVLB  0
02EE6:  CALL   1874
02EEA:  MOVFF  293,FEA
02EEE:  MOVFF  292,FE9
02EF2:  MOVFF  02,FEC
02EF6:  MOVF   FED,F
02EF8:  MOVFF  01,FEF
....................     p->Operation        = swaps(p->Operation); 
02EFC:  MOVLW  06
02EFE:  MOVLB  2
02F00:  ADDWF  x90,W
02F02:  MOVWF  01
02F04:  MOVLW  00
02F06:  ADDWFC x91,W
02F08:  MOVWF  03
02F0A:  MOVFF  01,292
02F0E:  MOVWF  x93
02F10:  MOVLW  06
02F12:  ADDWF  x90,W
02F14:  MOVWF  FE9
02F16:  MOVLW  00
02F18:  ADDWFC x91,W
02F1A:  MOVWF  FEA
02F1C:  MOVFF  FEC,295
02F20:  MOVF   FED,F
02F22:  MOVFF  FEF,294
02F26:  MOVFF  295,2E1
02F2A:  MOVFF  294,2E0
02F2E:  MOVLB  0
02F30:  CALL   1874
02F34:  MOVFF  293,FEA
02F38:  MOVFF  292,FE9
02F3C:  MOVFF  02,FEC
02F40:  MOVF   FED,F
02F42:  MOVFF  01,FEF
02F46:  RETURN 0
.................... } 
....................  
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) 
....................    #include "ICMP.c" 
.................... /********************************************************************* 
....................  * 
....................  *  Internet Control Message Protocol (ICMP) Server 
....................  *  Module for Microchip TCP/IP Stack 
....................  *   -Provides "ping" diagnostics 
....................  *	 -Reference: RFC 792 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.c 
....................  * Dependencies:    IP, ARP 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    	Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		03/16/07	Original 
....................  ********************************************************************/ 
.................... #define __ICMP_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................  
.................... #if defined(STACK_USE_ICMP_CLIENT) 
....................  
.................... // ICMP Timeout Value 
.................... #define ICMP_TIMEOUT	(4ul*TICK_SECOND) 
....................  
.................... // ICMP Packet Structure 
.................... typedef struct 
.................... { 
.................... 	BYTE vType; 
.................... 	BYTE vCode; 
.................... 	WORD wChecksum; 
.................... 	WORD wIdentifier; 
.................... 	WORD wSequenceNumber; 
.................... 	WORD wData; 
.................... } ICMP_PACKET; 
....................  
.................... // ICMP Sequence Number 
.................... static WORD wICMPSequenceNumber; 
.................... // ICMP tick timer variable 
.................... static DWORD ICMPTimer; 
....................  
.................... // ICMP Flag structure 
.................... static struct 
.................... { 
.................... 	unsigned char bICMPInUse:1;         // Indicates that the ICMP Client is in use 
.................... 	unsigned char bReplyValid:1;        // Indicates that a correct Ping response to one of our pings was received 
.................... 	unsigned char bRemoteHostIsROM:1;   // Indicates that a remote host name was passed as a ROM pointer argument 
.................... } ICMPFlags = {0x00}; 
....................  
.................... // ICMP Static Variables 
.................... static union 
.................... { 
.................... 	union 
.................... 	{ 
.................... 		ROM BYTE *szROM; 
.................... 		BYTE *szRAM; 
.................... 	} RemoteHost; 
.................... 	NODE_INFO ICMPRemote; 
.................... } StaticVars; 
....................  
.................... // ICMP State Machine Enumeration 
.................... static enum 
.................... { 
.................... 	SM_IDLE = 0, 
.................... 	SM_DNS_SEND_QUERY, 
.................... 	SM_DNS_GET_RESPONSE, 
.................... 	SM_ARP_SEND_QUERY, 
.................... 	SM_ARP_GET_RESPONSE, 
.................... 	SM_ICMP_SEND_ECHO_REQUEST, 
.................... 	SM_ICMP_GET_ECHO_RESPONSE 
.................... } ICMPState; 
....................  
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPProcess(void) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           *remote: Pointer to a NODE_INFO structure of the  
....................  *					ping requester 
....................  *					len: Count of how many bytes the ping header and  
....................  *					payload are in this IP packet 
....................  * 
....................  * Output:          Generates an echo reply, if requested 
....................  *					Validates and sets ICMPFlags.bReplyValid if a  
....................  *					correct ping response to one of ours is received. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPProcess(NODE_INFO *remote, WORD len) 
.................... { 
.................... 	DWORD_VAL dwVal; 
....................  
....................     // Obtain the ICMP header Type, Code, and Checksum fields 
....................     MACGetArray((BYTE*)&dwVal, sizeof(dwVal)); 
*
05694:  MOVLW  02
05696:  MOVLB  2
05698:  MOVWF  x55
0569A:  MOVLW  50
0569C:  MOVWF  x54
0569E:  MOVFF  255,2E4
056A2:  MOVWF  xE3
056A4:  CLRF   xE6
056A6:  MOVLW  04
056A8:  MOVWF  xE5
056AA:  MOVLB  0
056AC:  CALL   0E8E
.................... 	 
.................... 	// See if this is an ICMP echo (ping) request 
.................... 	if(dwVal.w[0] == 0x0008u) 
056B0:  MOVLB  2
056B2:  MOVF   x50,W
056B4:  SUBLW  08
056B6:  BNZ   576E
056B8:  MOVF   x51,F
056BA:  BNZ   576E
.................... 	{ 
.................... 		// Validate the checksum using the Microchip MAC's DMA module 
.................... 		// The checksum data includes the precomputed checksum in the  
.................... 		// header, so a valid packet will always have a checksum of  
.................... 		// 0x0000 if the packet is not disturbed. 
.................... 		if(MACCalcRxChecksum(0+sizeof(IP_HEADER), len)) 
056BC:  CLRF   x6B
056BE:  MOVLW  14
056C0:  MOVWF  x6A
056C2:  MOVFF  24F,26D
056C6:  MOVFF  24E,26C
056CA:  MOVLB  0
056CC:  RCALL  54E2
056CE:  MOVF   01,W
056D0:  IORWF  02,W
056D2:  BZ    56D6
.................... 			return; 
056D4:  BRA    576C
.................... 	 
.................... 		// Calculate new Type, Code, and Checksum values 
.................... 		dwVal.v[0] = 0x00;	// Type: 0 (ICMP echo/ping reply) 
056D6:  MOVLB  2
056D8:  CLRF   x50
.................... 		dwVal.v[2] += 8;	// Subtract 0x0800 from the checksum 
056DA:  MOVLW  08
056DC:  ADDWF  x52,F
.................... 		if(dwVal.v[2] < 8u) 
056DE:  MOVF   x52,W
056E0:  SUBLW  07
056E2:  BNC   56EC
.................... 		{ 
.................... 			dwVal.v[3]++; 
056E4:  INCF   x53,F
.................... 			if(dwVal.v[3] == 0u) 
056E6:  MOVF   x53,F
056E8:  BNZ   56EC
.................... 				dwVal.v[2]++; 
056EA:  INCF   x52,F
.................... 		} 
.................... 	 
.................... 	    // Wait for TX hardware to become available (finish transmitting  
.................... 	    // any previous packet) 
.................... 	    while(!IPIsTxReady()); 
056EC:  MOVLB  0
056EE:  CALL   168C
056F2:  MOVF   01,F
056F4:  BZ    56EE
....................  
.................... 		// Position the write pointer for the next IPPutHeader operation 
.................... 		// NOTE: do not put this before the IPIsTxReady() call for WF compatbility 
.................... 	    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER)); 
056F6:  MOVLW  17
056F8:  MOVLB  2
056FA:  MOVWF  xD1
056FC:  MOVLW  F3
056FE:  MOVWF  xD0
05700:  MOVLB  0
05702:  CALL   0D6C
....................         	 
.................... 		// Create IP header in TX memory 
.................... 		IPPutHeader(remote, IP_PROT_ICMP, len); 
05706:  MOVFF  24D,2C2
0570A:  MOVFF  24C,2C1
0570E:  MOVLW  01
05710:  MOVLB  2
05712:  MOVWF  xC3
05714:  MOVFF  24F,2C5
05718:  MOVFF  24E,2C4
0571C:  MOVLB  0
0571E:  CALL   1EB0
.................... 	 
.................... 		// Copy ICMP response into the TX memory 
.................... 		MACPutArray((BYTE*)&dwVal, sizeof(dwVal)); 
05722:  MOVLW  02
05724:  MOVLB  2
05726:  MOVWF  x55
05728:  MOVLW  50
0572A:  MOVWF  x54
0572C:  MOVFF  255,2E6
05730:  MOVWF  xE5
05732:  CLRF   xE8
05734:  MOVLW  04
05736:  MOVWF  xE7
05738:  MOVLB  0
0573A:  CALL   0DDC
.................... 		MACMemCopyAsync(-1, -1, len-4); 
0573E:  MOVLW  04
05740:  MOVLB  2
05742:  SUBWF  x4E,W
05744:  MOVWF  x54
05746:  MOVLW  00
05748:  SUBWFB x4F,W
0574A:  MOVWF  x55
0574C:  SETF   xD1
0574E:  SETF   xD0
05750:  SETF   xD3
05752:  SETF   xD2
05754:  MOVWF  xD5
05756:  MOVFF  254,2D4
0575A:  MOVLB  0
0575C:  CALL   0F2E
.................... 		while(!MACIsMemCopyDone()); 
05760:  CALL   11C0
05764:  MOVF   01,F
05766:  BZ    5760
.................... 	 
.................... 		// Transmit the echo reply packet 
.................... 	    MACFlush(); 
05768:  CALL   20E2
0576C:  MOVLB  2
.................... 	} 
.................... #if defined(STACK_USE_ICMP_CLIENT) 
0576E:  MOVLB  0
05770:  GOTO   760E (RETURN)
.................... 	else if(dwVal.w[0] == 0x0000u)	// See if this an ICMP Echo reply to our request 
.................... 	{ 
.................... 		// Get the sequence number and identifier fields 
.................... 		MACGetArray((BYTE*)&dwVal, sizeof(dwVal)); 
.................... 		 
.................... 		// See if the identifier matches the one we sent 
.................... 		if(dwVal.w[0] != 0xEFBE)	 
.................... 			return; 
.................... 	 
.................... 		if(dwVal.w[1] != wICMPSequenceNumber) 
.................... 			return; 
....................  
.................... 		// Validate the ICMP checksum field 
.................... 	    IPSetRxBuffer(0); 
.................... 		if(CalcIPBufferChecksum(sizeof(ICMP_PACKET)))	// Two bytes of payload were sent in the echo request 
.................... 			return; 
.................... 		 
.................... 		// Flag that we received the response and stop the timer ticking 
.................... 		ICMPFlags.bReplyValid = 1; 
.................... 		ICMPTimer = TickGet() - ICMPTimer; 
.................... 	} 
.................... #endif 
.................... } 
....................  
.................... #if defined(STACK_USE_ICMP_CLIENT) 
.................... /********************************************************************* 
....................  * Function:        void ICMPSendPing(DWORD dwRemoteIP) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() returned TRUE 
....................  * 
....................  * Input:           dwRemoteIP: IP Address to ping.  Must be stored  
....................  *								big endian.  Ex. 192.168.0.1 should be 
....................  *								passed as 0x0100A8C0. 
....................  * 
....................  * Output:          Begins the process of transmitting an ICMP echo  
....................  *					request.  This normally involves an ARP  
....................  *					resolution procedure first. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPSendPing(DWORD dwRemoteIP) 
.................... { 
.................... 	ICMPFlags.bReplyValid = 0; 
.................... 	ICMPTimer = TickGet(); 
.................... 	StaticVars.ICMPRemote.IPAddr.Val = dwRemoteIP; 
.................... 	ICMPState = SM_ARP_SEND_QUERY; 
.................... } 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... /********************************************************************* 
....................  * Function:        void ICMPSendPingToHost (BYTE * szRemoteHost) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() returned TRUE 
....................  * 
....................  * Input:           szRemoteHost: Host name to ping.  Must be stored  
....................  *								  in RAM if being called by PIC18. 
....................  *								  Ex. www.microchip.com 
....................  * 
....................  * Output:          Begins the process of transmitting an ICMP echo  
....................  *					request.  This normally involves an ARP  
....................  *					resolution procedure first. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPSendPingToHost(BYTE * szRemoteHost) 
.................... { 
.................... 	ICMPFlags.bReplyValid = 0; 
.................... 	ICMPTimer = TickGet(); 
.................... 	ICMPFlags.bRemoteHostIsROM = 0; 
.................... 	StaticVars.RemoteHost.szRAM = szRemoteHost; 
.................... 	ICMPState = SM_DNS_SEND_QUERY; 
.................... } 
....................  
.................... #if defined(__18CXX) 
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPSendPingToHostROM (ROM BYTE * szRemoteHost) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() returned TRUE 
....................  * 
....................  * Input:           szRemoteHost: Host name to ping.  Must be stored  
....................  *								  in ROM. Should only be called by PIC18. 
....................  *								  Ex. www.microchip.com 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Begins the process of transmitting an ICMP echo  
....................  *					request.  This normally involves an ARP  
....................  *					resolution procedure first. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPSendPingToHostROM(ROM BYTE * szRemoteHost) 
.................... { 
.................... 	ICMPFlags.bReplyValid = 0; 
.................... 	ICMPTimer = TickGet(); 
.................... 	ICMPFlags.bRemoteHostIsROM = 1; 
.................... 	StaticVars.RemoteHost.szROM = szRemoteHost; 
.................... 	ICMPState = SM_DNS_SEND_QUERY; 
.................... } 
....................  
.................... #endif 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        LONG ICMPGetReply(void) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() returned TRUE and ICMPSendPing()  
....................  *					was called 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          -3: Could not resolve hostname (DNS timeout or  
....................  *			    	    hostname invalid) 
....................  *					-2: No response received yet 
....................  *					-1: Operation timed out (longer than ICMP_TIMEOUT)  
....................  *						has elapsed. 
....................  *					>=0: Number of TICKs that elapsed between  
....................  *						 initial ICMP transmission and reception of  
....................  *						 a valid echo. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... LONG ICMPGetReply(void) 
.................... { 
.................... 	ICMP_PACKET ICMPPacket; 
....................  
.................... 	switch(ICMPState) 
.................... 	{ 
.................... #if defined(STACK_USE_DNS) 
.................... 		case SM_DNS_SEND_QUERY: 
.................... 			// Obtain DNS module ownership 
.................... 			if(!DNSBeginUsage()) 
.................... 				break; 
.................... 			 
.................... 			// Send DNS query 
.................... 			if(ICMPFlags.bRemoteHostIsROM) 
.................... 				DNSResolveROM(StaticVars.RemoteHost.szROM, DNS_TYPE_A); 
.................... 			else 
.................... 				DNSResolve(StaticVars.RemoteHost.szRAM, DNS_TYPE_A); 
.................... 			 
.................... 			ICMPState = SM_DNS_GET_RESPONSE; 
.................... 			break; 
.................... 				 
.................... 		case SM_DNS_GET_RESPONSE: 
.................... 			// See if DNS is done, and if so, get the remote IP address 
.................... 			if(!DNSIsResolved(&StaticVars.ICMPRemote.IPAddr)) 
.................... 				break; 
.................... 			 
.................... 			// Free the DNS module 
.................... 			DNSEndUsage(); 
.................... 			 
.................... 			// Return error code if the DNS query failed 
.................... 			if(StaticVars.ICMPRemote.IPAddr.Val == 0x00000000ul) 
.................... 			{ 
.................... 				ICMPState = SM_IDLE; 
.................... 				return -3; 
.................... 			} 
....................  
.................... 			ICMPState = SM_ARP_SEND_QUERY;	 
.................... 			// No break;	 
.................... #endif 
....................  
.................... 		case SM_ARP_SEND_QUERY: 
.................... 			ARPResolve(&StaticVars.ICMPRemote.IPAddr); 
.................... 			ICMPState = SM_ARP_GET_RESPONSE; 
.................... 			break; 
.................... 			 
.................... 		case SM_ARP_GET_RESPONSE: 
.................... 			// See if the ARP reponse was successfully received 
.................... 			if(!ARPIsResolved(&StaticVars.ICMPRemote.IPAddr, &StaticVars.ICMPRemote.MACAddr)) 
.................... 				break; 
.................... 			 
.................... 			ICMPState = SM_ICMP_SEND_ECHO_REQUEST; 
.................... 			// No break;  
.................... 		 
.................... 		case SM_ICMP_SEND_ECHO_REQUEST: 
.................... 		    if(!IPIsTxReady()) 
.................... 		    	break; 
....................  
.................... 			// Set up the ping packet 
.................... 			ICMPPacket.vType = 0x08;	// 0x08: Echo (ping) request 
.................... 			ICMPPacket.vCode = 0x00; 
.................... 			ICMPPacket.wChecksum = 0x0000; 
.................... 			ICMPPacket.wIdentifier = 0xEFBE; 
.................... 			wICMPSequenceNumber++;  
.................... 			ICMPPacket.wSequenceNumber = wICMPSequenceNumber; 
.................... 			ICMPPacket.wData = 0x2860; 
.................... 			ICMPPacket.wChecksum = CalcIPChecksum((BYTE*)&ICMPPacket, sizeof(ICMPPacket)); 
.................... 		 
.................... 			// Record the current time.  This will be used as a basis for  
.................... 			// finding the echo response time, which exludes the ARP and DNS  
.................... 			// steps 
.................... 			ICMPTimer = TickGet(); 
....................  
.................... 			// Position the write pointer for the next IPPutHeader operation 
.................... 		    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER)); 
.................... 		 
.................... 			// Create IP header in TX memory 
.................... 			IPPutHeader(&StaticVars.ICMPRemote, IP_PROT_ICMP, sizeof(ICMPPacket)); 
.................... 			MACPutArray((BYTE*)&ICMPPacket, sizeof(ICMPPacket)); 
.................... 			MACFlush(); 
....................  
.................... 			// Echo sent, advance state 
.................... 			ICMPState = SM_ICMP_GET_ECHO_RESPONSE; 
.................... 			break; 
....................  
.................... 		case SM_ICMP_GET_ECHO_RESPONSE: 
.................... 			// See if the echo was successfully received 
.................... 			if(ICMPFlags.bReplyValid) 
.................... 				return (LONG)ICMPTimer; 
.................... 		 
.................... 			break; 
.................... 		 
.................... 		// SM_IDLE or illegal/impossible state: 
.................... 		default: 
.................... 			return -1; 
.................... 	} 
....................  
.................... 	// See if the DNS/ARP/echo request timed out 
.................... 	if(TickGet() - ICMPTimer > ICMP_TIMEOUT) 
.................... 	{ 
.................... 		// Free DNS module if we have it in use 
.................... 		#if defined(STACK_USE_DNS) 
.................... 			if(ICMPState == SM_DNS_GET_RESPONSE) 
.................... 				DNSEndUsage(); 
.................... 		#endif 
.................... 		 
.................... 		// Stop ICMP echo test and return error to caller 
.................... 		ICMPState = SM_IDLE; 
.................... 		return -1; 
.................... 	} 
....................  
.................... 	// Still working.  No response to report yet. 
.................... 	return -2; 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPBeginUsage(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: You have successfully gained ownership of  
....................  *						  the ICMP client module and can now use the  
....................  *						  ICMPSendPing() and ICMPGetReply() functions. 
....................  *					FALSE: Some other application is using the ICMP  
....................  *						   client module.  Calling ICMPSendPing()  
....................  *						   will corrupt the other application's ping  
....................  *						   result. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Claims ownership of the ICMP module. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPBeginUsage(void) 
.................... { 
.................... 	if(ICMPFlags.bICMPInUse) 
.................... 		return FALSE; 
....................  
.................... 	ICMPFlags.bICMPInUse = TRUE; 
.................... 	return TRUE; 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPEndUsage(void) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() was called by you and it  
....................  *					returned TRUE. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Your ownership of the ICMP module is released.   
....................  *					You can no longer use ICMPSendPing(). 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Gives up ownership of the ICMP module. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPEndUsage(void) 
.................... { 
.................... 	ICMPFlags.bICMPInUse = FALSE; 
.................... } 
....................  
.................... #endif //#if defined(STACK_USE_ICMP_CLIENT) 
....................  
.................... #endif //#if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP) 
....................    #include "UDP.c" 
.................... /********************************************************************* 
....................  * 
....................  *   User Datagram Protocol (UDP) Communications Layer 
....................  *  Module for Microchip TCP/IP Stack 
....................  *    -Provides unreliable, minimum latency transport of application  
....................  *    datagram (packet) oriented data 
....................  *    -Reference: RFC 768 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        UDP.c 
....................  * Dependencies:    IP, Ethernet (ENC28J60.c or ETH97J60.c) 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/19/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/26/03  Fixed UDPGet and UDPProcess bugs 
....................  *                               as discovered and fixed by John Owen 
....................  *                               of Powerwave. 
....................  *                               1. UDPGet would return FALSE on last good byte 
....................  *                               2. UDPProcess was incorrectly calculating length. 
....................  * Nilesh Rajbharti     5/19/03  Added bFirstRead flag similar to TCP 
....................  *                               to detect very first UDPGet and 
....................  *                               reset MAC Rx pointer to begining of 
....................  *                               UDP data area.  This would ensure that 
....................  *                               if UDP socket has pending Rx data and 
....................  *                               another module resets MAC Rx pointer, 
....................  *                               next UDP socket Get would get correct 
....................  *                               data. 
....................  * Robert Sloan (RSS)    5/29/03 Improved FindMatchingSocket() 
....................  * Nilesh Rajbharti     12/2/03  Added UDPChecksum logic in UDPProcess() 
....................  * Nilesh Rajbharti     12/5/03  Modified UDPProcess() and FindMatchingSocket() 
....................  *                               to include localIP as new parameter. 
....................  *                               This corrects pseudo header checksum 
....................  *                               logic in UDPProcess(). 
....................  *                               It also corrects broadcast packet 
....................  *                               matching correct in FindMatchingSocket(). 
....................  * Howard Schlunder      1/16/06    Fixed an imporbable RX checksum bug  
....................  *                         when using a Microchip Ethernet controller) 
....................  * Howard Schlunder      6/02/06    Fixed a bug where all RXed UDP packets  
....................  *                         without a checksum (0x0000) were thrown 
....................  *                         away.  No checksum is legal in UDP. 
....................  * Howard Schlunder      8/10/06    Fixed a bug where UDP sockets would  
....................  *                         unintentionally keep the remote MAC  
....................  *                         address cached, even after calling  
....................  *                         UDPInit(), UDPClose(), or reseting  
....................  *                         the part without clearing all the  
....................  *                         PIC memory. 
....................  ********************************************************************/ 
.................... #define __UDP_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_UDP) 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Configuration Parameters 
....................   ***************************************************************************/ 
....................  
.................... // First port number for randomized local port number selection 
.................... #define LOCAL_UDP_PORT_START_NUMBER (4096u) 
....................  
.................... // Last port number for randomized local port number selection 
.................... #define LOCAL_UDP_PORT_END_NUMBER   (8192u) 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    UDP Global Variables 
....................   ***************************************************************************/ 
....................  
.................... // Stores an array of information pertaining to each UDP socket 
.................... UDP_SOCKET_INFO      UDPSocketInfo[MAX_UDP_SOCKETS]; 
....................  
.................... // Indicates which UDP socket is currently active 
.................... UDP_SOCKET         activeUDPSocket; 
....................  
.................... WORD UDPTxCount;   // Number of bytes written to this UDP segment 
.................... WORD UDPRxCount;   // Number of bytes read from this UDP segment 
.................... static UDP_SOCKET   LastPutSocket = INVALID_UDP_SOCKET;   // Indicates the last socket to which data was written 
.................... static WORD wPutOffset;      // Offset from beginning of payload where data is to be written. 
.................... static WORD wGetOffset;      // Offset from beginning of payload from where data is to be read. 
....................  
.................... // Stores various flags for the UDP module 
.................... static struct 
.................... { 
....................    unsigned char bFirstRead : 1;      // No data has been read from this segment yet 
....................    unsigned char bWasDiscarded : 1;   // The data in this segment has been discarded 
.................... } Flags; 
....................  
.................... // Indicates which socket has currently received data for this loop 
.................... static UDP_SOCKET SocketWithRxData = INVALID_UDP_SOCKET; 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Function Prototypes 
....................   ***************************************************************************/ 
....................  
.................... static UDP_SOCKET FindMatchingUDPSocket(UDP_HEADER *h, NODE_INFO *remoteNode, 
....................                                     IP_ADDR *localIP); 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Connection Management Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void UDPInit(void) 
....................  
....................   Summary: 
....................    Initializes the UDP module. 
....................  
....................   Description: 
....................    Initializes the UDP module.  This function initializes all the UDP  
....................    sockets to the closed state. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................      None 
....................       
....................   Remarks: 
....................    This function is called only one during lifetime of the application. 
....................   ***************************************************************************/ 
.................... void UDPInit(void) 
.................... { 
....................     UDP_SOCKET s; 
....................  
....................     for ( s = 0; s < MAX_UDP_SOCKETS; s++ ) 
*
00C8E:  MOVLB  2
00C90:  CLRF   x44
00C92:  MOVF   x44,W
00C94:  SUBLW  06
00C96:  BNC   0CA6
....................     { 
....................       UDPClose(s); 
00C98:  MOVFF  244,270
00C9C:  MOVLB  0
00C9E:  RCALL  0C0A
00CA0:  MOVLB  2
00CA2:  INCF   x44,F
00CA4:  BRA    0C92
....................     } 
....................    Flags.bWasDiscarded = 1; 
00CA6:  MOVLB  1
00CA8:  BSF    x41.1
00CAA:  MOVLB  0
00CAC:  GOTO   1686 (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
.................... Function: 
....................    UDP_SOCKET UDPOpenEx(DWORD remoteHost, BYTE remoteHostType, UDP_PORT localPort, 
....................    UDP_PORT remotePort) 
....................  
....................  Summary: 
....................     Opens a UDP socket for a client. 
....................  
....................  Description: 
....................     Provides a unified method for opening UDP sockets. This function can open both client and  
....................     server   sockets. For client sockets, it can accept a host name string to query in DNS, an IP 
....................     address as a string, an IP address in binary form, or a previously resolved NODE_INFO  
....................     structure containing the remote IP address and associated MAC address. When a host name 
....................     or IP address only is provided, UDP module will internally perform the necessary DNSResolve 
....................     and/or ARP resolution steps before reporting that the UDP socket is connected (via a call to 
....................     UDPISOpen returning TRUE). Server sockets ignore this destination parameter and listen  
....................     only on the indicated port.   Sockets are statically allocated on boot, but can be claimed with 
....................     this function and freed using UDPClose . 
....................  
.................... Conditions: 
.................... UDPInit should be called. 
....................  
.................... Input: 
....................     remoteHost -     Pointer to remote node info (MAC and IP address) for this connection.   
....................     If this is a     server socket (receives the first packet) or the destination is the broadcast  
....................     address, then this parameter should be NULL. For client sockets only. Provide a pointer to 
....................     a null-terminated string of the remote host name (ex\:"www.microchip.com" or  
....................     "192.168.1.123"), a literal destination IP address (ex\: 0x7B01A8C0 or an IP_ADDR data type), 
....................     or a pointer to a NODE_INFO structure with the remote IP address and remote node or gateway 
....................     MAC address specified, If a string is provided. 
....................      
....................     remoteHostType - Any one of the following flags to identify the meaning of the remoteHost parameter: 
....................        - UDP_OPEN_SERVER   = Open a server socket and ignore the remoteHost parameter.  
....................           (e.g. - SNMP agent, DHCP server, Announce) 
....................        - UDP_OPEN_IP_ADDRESS = Open a client socket and connect it to a remote IP address. 
....................           Ex: 0x7B01A8C0 for 192.168.1.123 (DWORD type). Note that the byte ordering is big endian. 
....................        - UDP_OPEN_NODE_INFO = Open a client socket and connect it to a remote IP and MAC  
....................           addresses pair stored in a NODE_INFO structure. 
....................         - UDP_OPEN_RAM_HOST = Open a client socket and connect it to a remote host who's  
....................            name is stored as a null terminated string in a RAM array. Ex:"www.microchip.com" or 
....................            "192.168.0.123" 
....................         - UDP_OPEN_ROM_HOST = Open a client socket and connect it to a remote host who's 
....................            name is stored as a null terminated string in a literal string or ROM array. Ex:  
....................            "www.microchip.com" or "192.168.0.123"  
....................  
....................     localPort - UDP port number to listen on.  If 0, stack will dynamically assign a unique port  
....................     number to use. 
....................  
....................     remotePort - For client sockets, the remote port number. 
....................  
.................... Return Values: 
....................      Success -  
....................       A UDP socket handle that can be used for subsequent UDP API calls. 
....................    Failure - 
....................       INVALID_UDP_SOCKET.  This function fails when no more UDP socket 
....................       handles are available.  Increase MAX_UDP_SOCKETS to make more sockets    available. 
.................... Remarks: 
....................    When finished using the UDP socket handle, call the UDPClose() function to free the  
....................    socket and delete the handle. 
....................  
.................... *****************************************************************************/ 
.................... UDP_SOCKET UDPOpenEx(DWORD remoteHost, BYTE remoteHostType, UDP_PORT localPort, 
....................       UDP_PORT remotePort) 
.................... { 
....................    UDP_SOCKET s; 
....................    UDP_SOCKET_INFO *p; 
....................  
....................    // Local temp port numbers. 
....................    static WORD NextPort __attribute__((persistent)); 
....................  
....................  
....................    p = UDPSocketInfo; 
*
031F0:  MOVLB  2
031F2:  CLRF   x81
031F4:  MOVLW  5D
031F6:  MOVWF  x80
....................    for ( s = 0; s < MAX_UDP_SOCKETS; s++ ) 
031F8:  CLRF   x7F
031FA:  MOVF   x7F,W
031FC:  SUBLW  06
031FE:  BTFSS  FD8.0
03200:  BRA    3404
....................    { 
....................       if(p->localPort == INVALID_UDP_PORT) 
03202:  MOVLW  0C
03204:  ADDWF  x80,W
03206:  MOVWF  FE9
03208:  MOVLW  00
0320A:  ADDWFC x81,W
0320C:  MOVWF  FEA
0320E:  MOVFF  FEC,283
03212:  MOVF   FED,F
03214:  MOVFF  FEF,282
03218:  MOVF   x82,F
0321A:  BTFSS  FD8.2
0321C:  BRA    33F8
0321E:  MOVF   x83,F
03220:  BTFSS  FD8.2
03222:  BRA    33F8
....................       { 
....................           p->localPort = localPort;   
03224:  MOVLW  0C
03226:  ADDWF  x80,W
03228:  MOVWF  FE9
0322A:  MOVLW  00
0322C:  ADDWFC x81,W
0322E:  MOVWF  FEA
03230:  MOVFF  27C,FEC
03234:  MOVF   FED,F
03236:  MOVFF  27B,FEF
....................          if(localPort == 0x0000u) 
0323A:  MOVF   x7B,F
0323C:  BNZ   3284
0323E:  MOVF   x7C,F
03240:  BNZ   3284
....................             { 
....................             if(NextPort > LOCAL_UDP_PORT_END_NUMBER || NextPort < LOCAL_UDP_PORT_START_NUMBER) 
03242:  MOVLB  1
03244:  MOVF   x44,W
03246:  SUBLW  1F
03248:  BC    3254
0324A:  XORLW  FF
0324C:  BNZ   325A
0324E:  MOVF   x43,W
03250:  SUBLW  00
03252:  BNC   325A
03254:  MOVF   x44,W
03256:  SUBLW  0F
03258:  BNC   3260
....................                NextPort = LOCAL_UDP_PORT_START_NUMBER; 
0325A:  MOVLW  10
0325C:  MOVWF  x44
0325E:  CLRF   x43
....................  
....................             p->localPort    = NextPort++; 
03260:  MOVLW  0C
03262:  MOVLB  2
03264:  ADDWF  x80,W
03266:  MOVWF  FE9
03268:  MOVLW  00
0326A:  ADDWFC x81,W
0326C:  MOVWF  FEA
0326E:  MOVLB  1
03270:  MOVFF  144,03
03274:  MOVF   x43,W
03276:  INCF   x43,F
03278:  BTFSC  FD8.2
0327A:  INCF   x44,F
0327C:  MOVWF  FEF
0327E:  MOVFF  03,FEC
03282:  MOVLB  2
....................             } 
....................          if((remoteHostType == UDP_OPEN_SERVER) || (remoteHost == 0)) 
03284:  MOVF   x7A,F
03286:  BZ    3298
03288:  MOVF   x76,F
0328A:  BNZ   32CE
0328C:  MOVF   x77,F
0328E:  BNZ   32CE
03290:  MOVF   x78,F
03292:  BNZ   32CE
03294:  MOVF   x79,F
03296:  BNZ   32CE
....................          { 
....................               //Set remote node as 0xFF ( broadcast address) 
....................               // else Set broadcast address 
....................               memset((void*)&p->remote.remoteNode, 0xFF, sizeof(p->remote)); 
03298:  MOVFF  281,03
0329C:  MOVFF  280,282
032A0:  MOVFF  281,283
032A4:  MOVFF  281,FEA
032A8:  MOVFF  280,FE9
032AC:  SETF   00
032AE:  CLRF   02
032B0:  MOVLW  0A
032B2:  MOVWF  01
032B4:  MOVLB  0
032B6:  CALL   0CB0
....................               p->smState = UDP_OPENED; 
032BA:  MOVLW  0E
032BC:  MOVLB  2
032BE:  ADDWF  x80,W
032C0:  MOVWF  FE9
032C2:  MOVLW  00
032C4:  ADDWFC x81,W
032C6:  MOVWF  FEA
032C8:  MOVLW  05
032CA:  MOVWF  FEF
....................          } 
032CC:  BRA    33D8
....................          else 
....................          { 
....................             switch(remoteHostType) 
032CE:  MOVF   x7A,W
032D0:  XORLW  01
032D2:  MOVLB  0
032D4:  BZ    32E4
032D6:  XORLW  03
032D8:  BZ    32E4
032DA:  XORLW  01
032DC:  BZ    333E
032DE:  XORLW  07
032E0:  BZ    3398
032E2:  BRA    33D6
....................             { 
.................... #if defined (STACK_CLIENT_MODE) 
.................... #if defined (STACK_USE_DNS) 
....................                case UDP_OPEN_RAM_HOST: 
....................                case UDP_OPEN_ROM_HOST: 
....................                   //set the UDP state to UDP_GET_DNS_MODULE 
....................                   p->remote.remoteHost = remoteHost; 
032E4:  MOVLB  2
032E6:  MOVFF  280,FE9
032EA:  MOVFF  281,FEA
032EE:  MOVFF  276,FEF
032F2:  MOVFF  277,FEC
032F6:  MOVFF  278,FEC
032FA:  MOVFF  279,FEC
....................                   p->flags.bRemoteHostIsROM = (remoteHostType == UDP_OPEN_ROM_HOST); 
032FE:  MOVLW  14
03300:  ADDWF  x80,W
03302:  MOVWF  01
03304:  MOVLW  00
03306:  ADDWFC x81,W
03308:  MOVWF  03
0330A:  MOVFF  01,282
0330E:  MOVWF  x83
03310:  MOVF   x7A,W
03312:  SUBLW  02
03314:  BZ    3322
03316:  MOVFF  283,FEA
0331A:  MOVFF  282,FE9
0331E:  BCF    FEF.0
03320:  BRA    332C
03322:  MOVFF  283,FEA
03326:  MOVFF  282,FE9
0332A:  BSF    FEF.0
....................                   p->smState = UDP_DNS_RESOLVE; 
0332C:  MOVLW  0E
0332E:  ADDWF  x80,W
03330:  MOVWF  FE9
03332:  MOVLW  00
03334:  ADDWFC x81,W
03336:  MOVWF  FEA
03338:  MOVLW  01
0333A:  MOVWF  FEF
....................                break; 
0333C:  BRA    33D8
.................... #endif 
....................                case UDP_OPEN_IP_ADDRESS: 
....................                // remoteHost is a literal IP address.   This doesn't need DNS and can skip directly to the Gateway ARPing step.     
....................                //Next UDP state UDP_GATEWAY_SEND_ARP; 
....................                p->remote.remoteNode.IPAddr.Val = remoteHost; 
0333E:  MOVLB  2
03340:  MOVFF  280,FE9
03344:  MOVFF  281,FEA
03348:  MOVFF  276,FEF
0334C:  MOVFF  277,FEC
03350:  MOVFF  278,FEC
03354:  MOVFF  279,FEC
....................                p->retryCount = 0; 
03358:  MOVLW  13
0335A:  ADDWF  x80,W
0335C:  MOVWF  FE9
0335E:  MOVLW  00
03360:  ADDWFC x81,W
03362:  MOVWF  FEA
03364:  CLRF   FEF
....................                p->retryInterval = (TICK_SECOND/4)/256; 
03366:  MOVLW  0F
03368:  ADDWF  x80,W
0336A:  MOVWF  FE9
0336C:  MOVLW  00
0336E:  ADDWFC x81,W
03370:  MOVWF  FEA
03372:  MOVF   FEE,F
03374:  MOVF   FEE,F
03376:  CLRF   FEC
03378:  MOVF   FED,F
0337A:  CLRF   FEF
0337C:  MOVF   FED,F
0337E:  CLRF   FEF
03380:  MOVF   FED,F
03382:  MOVLW  26
03384:  MOVWF  FEF
....................                p->smState = UDP_GATEWAY_SEND_ARP; 
03386:  MOVLW  0E
03388:  ADDWF  x80,W
0338A:  MOVWF  FE9
0338C:  MOVLW  00
0338E:  ADDWFC x81,W
03390:  MOVWF  FEA
03392:  MOVLW  02
03394:  MOVWF  FEF
....................                break; 
03396:  BRA    33D8
.................... #endif                   
....................                case UDP_OPEN_NODE_INFO: 
....................                //skip DNS and ARP resolution steps if connecting to a remote node which we've already 
....................                   memcpy((void*)(BYTE*)&p->remote,(void*)(BYTE*)(PTR_BASE)remoteHost,sizeof(p->remote)); 
03398:  MOVLB  2
0339A:  MOVFF  281,03
0339E:  MOVFF  280,282
033A2:  MOVFF  281,283
033A6:  MOVFF  281,FEA
033AA:  MOVFF  280,FE9
033AE:  MOVFF  277,FE2
033B2:  MOVFF  276,FE1
033B6:  MOVLW  0A
033B8:  MOVWF  01
033BA:  MOVFF  FE6,FEE
033BE:  DECFSZ 01,F
033C0:  BRA    33BA
....................                   p->smState = UDP_OPENED; 
033C2:  MOVLW  0E
033C4:  ADDWF  x80,W
033C6:  MOVWF  FE9
033C8:  MOVLW  00
033CA:  ADDWFC x81,W
033CC:  MOVWF  FEA
033CE:  MOVLW  05
033D0:  MOVWF  FEF
....................                // CALL UDPFlushto transmit incluind peding data. 
....................                break; 
033D2:  BRA    33D8
033D4:  MOVLB  0
....................                default: 
....................                   break; 
033D6:  MOVLB  2
....................             } 
....................          } 
....................          p->remotePort   = remotePort; 
033D8:  MOVLW  0A
033DA:  ADDWF  x80,W
033DC:  MOVWF  FE9
033DE:  MOVLW  00
033E0:  ADDWFC x81,W
033E2:  MOVWF  FEA
033E4:  MOVFF  27E,FEC
033E8:  MOVF   FED,F
033EA:  MOVFF  27D,FEF
....................  
....................          // Mark this socket as active. 
....................          // Once an active socket is set, subsequent operation can be 
....................          // done without explicitely supply socket identifier. 
....................          activeUDPSocket = s; 
033EE:  MOVFF  27F,5C
....................          return s; 
033F2:  MOVFF  27F,01
033F6:  BRA    3408
....................       } 
....................       p++; 
033F8:  MOVLW  17
033FA:  ADDWF  x80,F
033FC:  BTFSC  FD8.0
033FE:  INCF   x81,F
03400:  INCF   x7F,F
03402:  BRA    31FA
....................    } 
....................  
....................    return (UDP_SOCKET)INVALID_UDP_SOCKET; 
03404:  MOVLW  FF
03406:  MOVWF  01
03408:  MOVLB  0
0340A:  GOTO   3C5C (RETURN)
....................  
.................... } 
....................  
....................  
.................... /****************************************************************************** 
.................... Function: 
....................    void UDPTask(void) 
....................  
....................   Summary: 
....................      Performs periodic UDP tasks. 
....................  
....................   Description: 
....................    This function performs any required periodic UDP tasks.  Each socket's state machine is  
....................    checked, and any elapsed timeout periods are handled. 
....................  
....................   Precondition: 
....................    UDP is initialized. 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................    None 
....................  
.................... ******************************************************************************/ 
.................... void UDPTask(void) 
.................... { 
....................    UDP_SOCKET ss; 
....................     
....................    for ( ss = 0; ss < MAX_UDP_SOCKETS; ss++ ) 
*
04D5A:  MOVLB  2
04D5C:  CLRF   x4C
04D5E:  MOVF   x4C,W
04D60:  SUBLW  06
04D62:  BTFSS  FD8.0
04D64:  BRA    5232
....................    { 
....................  
....................       // need to put Extra check if UDP has opened or NOT 
....................  
....................       if((UDPSocketInfo[ss].smState == UDP_OPENED) || 
....................          (UDPSocketInfo[ss].smState == UDP_CLOSED)) 
04D66:  MOVF   x4C,W
04D68:  MULLW  17
04D6A:  MOVF   FF3,W
04D6C:  CLRF   x52
04D6E:  MOVWF  x51
04D70:  MOVLW  0E
04D72:  ADDWF  x51,W
04D74:  MOVWF  01
04D76:  MOVLW  00
04D78:  ADDWFC x52,W
04D7A:  MOVWF  03
04D7C:  MOVF   01,W
04D7E:  ADDLW  5D
04D80:  MOVWF  FE9
04D82:  MOVLW  00
04D84:  ADDWFC 03,W
04D86:  MOVWF  FEA
04D88:  MOVF   FEF,W
04D8A:  SUBLW  05
04D8C:  BZ    4DB6
04D8E:  MOVF   x4C,W
04D90:  MULLW  17
04D92:  MOVF   FF3,W
04D94:  CLRF   x52
04D96:  MOVWF  x51
04D98:  MOVLW  0E
04D9A:  ADDWF  x51,W
04D9C:  MOVWF  01
04D9E:  MOVLW  00
04DA0:  ADDWFC x52,W
04DA2:  MOVWF  03
04DA4:  MOVF   01,W
04DA6:  ADDLW  5D
04DA8:  MOVWF  FE9
04DAA:  MOVLW  00
04DAC:  ADDWFC 03,W
04DAE:  MOVWF  FEA
04DB0:  MOVF   FEF,W
04DB2:  SUBLW  04
04DB4:  BNZ   4DB8
....................          continue; 
04DB6:  BRA    522E
....................       // A timeout has occured.  Respond to this timeout condition 
....................       // depending on what state this socket is in. 
....................       switch(UDPSocketInfo[ss].smState) 
04DB8:  MOVF   x4C,W
04DBA:  MULLW  17
04DBC:  MOVF   FF3,W
04DBE:  CLRF   x52
04DC0:  MOVWF  x51
04DC2:  MOVLW  0E
04DC4:  ADDWF  x51,W
04DC6:  MOVWF  01
04DC8:  MOVLW  00
04DCA:  ADDWFC x52,W
04DCC:  MOVWF  03
04DCE:  MOVF   01,W
04DD0:  ADDLW  5D
04DD2:  MOVWF  FE9
04DD4:  MOVLW  00
04DD6:  ADDWFC 03,W
04DD8:  MOVWF  FEA
04DDA:  MOVF   FEF,W
04DDC:  XORLW  01
04DDE:  MOVLB  0
04DE0:  BZ    4E02
04DE2:  XORLW  01
04DE4:  BTFSC  FD8.2
04DE6:  BRA    4ED8
04DE8:  XORLW  02
04DEA:  BTFSC  FD8.2
04DEC:  BRA    4FCC
04DEE:  XORLW  01
04DF0:  BTFSC  FD8.2
04DF2:  BRA    5064
04DF4:  XORLW  06
04DF6:  BTFSC  FD8.2
04DF8:  BRA    522C
04DFA:  XORLW  01
04DFC:  BTFSC  FD8.2
04DFE:  BRA    522C
04E00:  BRA    522C
....................       { 
....................          #if defined(STACK_CLIENT_MODE) 
....................          #if defined(STACK_USE_DNS) 
....................          case UDP_DNS_RESOLVE: 
....................          if(DNSBeginUsage()) 
04E02:  CALL   2A5A
04E06:  MOVF   01,F
04E08:  BZ    4ED6
....................          { 
....................             // call DNS Resolve function and move to UDP next State machine 
....................             UDPSocketInfo[ss].smState = UDP_DNS_IS_RESOLVED; 
04E0A:  MOVLB  2
04E0C:  MOVF   x4C,W
04E0E:  MULLW  17
04E10:  MOVF   FF3,W
04E12:  CLRF   x52
04E14:  MOVWF  x51
04E16:  MOVLW  0E
04E18:  ADDWF  x51,W
04E1A:  MOVWF  01
04E1C:  MOVLW  00
04E1E:  ADDWFC x52,W
04E20:  MOVWF  03
04E22:  MOVF   01,W
04E24:  ADDLW  5D
04E26:  MOVWF  FE9
04E28:  MOVLW  00
04E2A:  ADDWFC 03,W
04E2C:  MOVWF  FEA
04E2E:  CLRF   FEF
....................             if(UDPSocketInfo[ss].flags.bRemoteHostIsROM) 
04E30:  MOVF   x4C,W
04E32:  MULLW  17
04E34:  MOVF   FF3,W
04E36:  CLRF   x52
04E38:  MOVWF  x51
04E3A:  MOVLW  14
04E3C:  ADDWF  x51,F
04E3E:  MOVLW  00
04E40:  ADDWFC x52,F
04E42:  MOVLW  5D
04E44:  ADDWF  x51,W
04E46:  MOVWF  FE9
04E48:  MOVLW  00
04E4A:  ADDWFC x52,W
04E4C:  MOVWF  FEA
04E4E:  BTFSS  FEF.0
04E50:  BRA    4E96
....................                DNSResolveROM((ROM BYTE*)(ROM_PTR_BASE)UDPSocketInfo[ss].remote.remoteHost, DNS_TYPE_A); 
04E52:  MOVF   x4C,W
04E54:  MULLW  17
04E56:  MOVF   FF3,W
04E58:  CLRF   x52
04E5A:  MOVWF  x51
04E5C:  MOVLW  5D
04E5E:  ADDWF  x51,W
04E60:  MOVWF  FE9
04E62:  MOVLW  00
04E64:  ADDWFC x52,W
04E66:  MOVWF  FEA
04E68:  MOVFF  FEF,00
04E6C:  MOVFF  FEC,01
04E70:  MOVFF  FEC,02
04E74:  MOVFF  FEC,03
04E78:  MOVFF  01,254
04E7C:  MOVFF  00,253
04E80:  MOVFF  01,258
04E84:  MOVFF  00,257
04E88:  MOVLW  01
04E8A:  MOVWF  x59
04E8C:  MOVLB  0
04E8E:  CALL   2C42
04E92:  BRA    4ED6
04E94:  MOVLB  2
....................             else 
....................                DNSResolve((BYTE*)(PTR_BASE)UDPSocketInfo[ss].remote.remoteHost, DNS_TYPE_A); 
04E96:  MOVF   x4C,W
04E98:  MULLW  17
04E9A:  MOVF   FF3,W
04E9C:  CLRF   x52
04E9E:  MOVWF  x51
04EA0:  MOVLW  5D
04EA2:  ADDWF  x51,W
04EA4:  MOVWF  FE9
04EA6:  MOVLW  00
04EA8:  ADDWFC x52,W
04EAA:  MOVWF  FEA
04EAC:  MOVFF  FEF,00
04EB0:  MOVFF  FEC,01
04EB4:  MOVFF  FEC,02
04EB8:  MOVFF  FEC,03
04EBC:  MOVFF  01,254
04EC0:  MOVFF  00,253
04EC4:  MOVFF  01,256
04EC8:  MOVFF  00,255
04ECC:  MOVLW  01
04ECE:  MOVWF  x57
04ED0:  MOVLB  0
04ED2:  CALL   2E2C
....................          } 
....................          break;             
04ED6:  BRA    522C
....................          case UDP_DNS_IS_RESOLVED: 
....................          { 
....................             IP_ADDR ipResolvedDNSIP; 
....................             // See if DNS resolution has finished.   Note that if the DNS  
....................             // fails, the &ipResolvedDNSIP will be written with 0x00000000.  
....................             // MyTCB.remote.dwRemoteHost is unioned with  
....................             // MyTCB.remote.niRemoteMACIP.IPAddr, so we can't directly write  
....................             // the DNS result into MyTCB.remote.niRemoteMACIP.IPAddr.  We  
....................             // must copy it over only if the DNS is resolution step was  
....................             // successful. 
....................              
....................             if(DNSIsResolved(&ipResolvedDNSIP)) 
04ED8:  MOVLW  02
04EDA:  MOVLB  2
04EDC:  MOVWF  x56
04EDE:  MOVLW  4D
04EE0:  MOVWF  x55
04EE2:  MOVLB  0
04EE4:  CALL   3B56
04EE8:  MOVF   01,F
04EEA:  BZ    4FCA
....................             { 
....................                if(DNSEndUsage()) 
04EEC:  CALL   293A
04EF0:  MOVF   01,F
04EF2:  BZ    4FA0
....................                { 
....................                   UDPSocketInfo[ss].remote.remoteNode.IPAddr.Val = ipResolvedDNSIP.Val; 
04EF4:  MOVLB  2
04EF6:  MOVF   x4C,W
04EF8:  MULLW  17
04EFA:  MOVF   FF3,W
04EFC:  CLRF   x52
04EFE:  MOVWF  x51
04F00:  MOVLW  5D
04F02:  ADDWF  x51,W
04F04:  MOVWF  FE9
04F06:  MOVLW  00
04F08:  ADDWFC x52,W
04F0A:  MOVWF  FEA
04F0C:  MOVFF  24D,FEF
04F10:  MOVFF  24E,FEC
04F14:  MOVFF  24F,FEC
04F18:  MOVFF  250,FEC
....................                   UDPSocketInfo[ss].smState = UDP_GATEWAY_SEND_ARP; 
04F1C:  MOVF   x4C,W
04F1E:  MULLW  17
04F20:  MOVF   FF3,W
04F22:  CLRF   x52
04F24:  MOVWF  x51
04F26:  MOVLW  0E
04F28:  ADDWF  x51,W
04F2A:  MOVWF  01
04F2C:  MOVLW  00
04F2E:  ADDWFC x52,W
04F30:  MOVWF  03
04F32:  MOVF   01,W
04F34:  ADDLW  5D
04F36:  MOVWF  FE9
04F38:  MOVLW  00
04F3A:  ADDWFC 03,W
04F3C:  MOVWF  FEA
04F3E:  MOVLW  02
04F40:  MOVWF  FEF
....................                   UDPSocketInfo[ss].retryCount = 0; 
04F42:  MOVF   x4C,W
04F44:  MULLW  17
04F46:  MOVF   FF3,W
04F48:  CLRF   x52
04F4A:  MOVWF  x51
04F4C:  MOVLW  13
04F4E:  ADDWF  x51,W
04F50:  MOVWF  01
04F52:  MOVLW  00
04F54:  ADDWFC x52,W
04F56:  MOVWF  03
04F58:  MOVF   01,W
04F5A:  ADDLW  5D
04F5C:  MOVWF  FE9
04F5E:  MOVLW  00
04F60:  ADDWFC 03,W
04F62:  MOVWF  FEA
04F64:  CLRF   FEF
....................                   UDPSocketInfo[ss].retryInterval = (TICK_SECOND/4)/256; 
04F66:  MOVF   x4C,W
04F68:  MULLW  17
04F6A:  MOVF   FF3,W
04F6C:  CLRF   x52
04F6E:  MOVWF  x51
04F70:  MOVLW  0F
04F72:  ADDWF  x51,W
04F74:  MOVWF  01
04F76:  MOVLW  00
04F78:  ADDWFC x52,W
04F7A:  MOVWF  03
04F7C:  MOVF   01,W
04F7E:  ADDLW  5D
04F80:  MOVWF  FE9
04F82:  MOVLW  00
04F84:  ADDWFC 03,W
04F86:  MOVWF  FEA
04F88:  MOVF   FEE,F
04F8A:  MOVF   FEE,F
04F8C:  CLRF   FEC
04F8E:  MOVF   FED,F
04F90:  CLRF   FEF
04F92:  MOVF   FED,F
04F94:  CLRF   FEF
04F96:  MOVF   FED,F
04F98:  MOVLW  26
04F9A:  MOVWF  FEF
....................                } 
04F9C:  BRA    4FC8
04F9E:  MOVLB  0
....................                else 
....................                { 
....................                   UDPSocketInfo[ss].smState = UDP_DNS_RESOLVE; 
04FA0:  MOVLB  2
04FA2:  MOVF   x4C,W
04FA4:  MULLW  17
04FA6:  MOVF   FF3,W
04FA8:  CLRF   x52
04FAA:  MOVWF  x51
04FAC:  MOVLW  0E
04FAE:  ADDWF  x51,W
04FB0:  MOVWF  01
04FB2:  MOVLW  00
04FB4:  ADDWFC x52,W
04FB6:  MOVWF  03
04FB8:  MOVF   01,W
04FBA:  ADDLW  5D
04FBC:  MOVWF  FE9
04FBE:  MOVLW  00
04FC0:  ADDWFC 03,W
04FC2:  MOVWF  FEA
04FC4:  MOVLW  01
04FC6:  MOVWF  FEF
04FC8:  MOVLB  0
....................                } 
....................             }          
....................          } 
....................          break; 
04FCA:  BRA    522C
....................          #endif // #if defined(STACK_USE_DNS) 
....................  
....................          case UDP_GATEWAY_SEND_ARP: 
....................             // Obtain the MAC address associated with the server's IP address  
....................             //(either direct MAC address on same subnet, or the MAC address of the Gateway machine) 
....................             UDPSocketInfo[ss].eventTime = (WORD)TickGetDiv256(); 
04FCC:  MOVLB  2
04FCE:  MOVF   x4C,W
04FD0:  MULLW  17
04FD2:  MOVF   FF3,W
04FD4:  CLRF   x52
04FD6:  MOVWF  x51
04FD8:  MOVLW  15
04FDA:  ADDWF  x51,W
04FDC:  MOVWF  01
04FDE:  MOVLW  00
04FE0:  ADDWFC x52,W
04FE2:  MOVWF  03
04FE4:  MOVF   01,W
04FE6:  ADDLW  5D
04FE8:  MOVWF  01
04FEA:  MOVLW  00
04FEC:  ADDWFC 03,F
04FEE:  MOVFF  01,251
04FF2:  MOVFF  03,252
04FF6:  MOVLB  0
04FF8:  CALL   16EE
04FFC:  MOVFF  252,FEA
05000:  MOVFF  251,FE9
05004:  MOVFF  01,FEC
05008:  MOVF   FED,F
0500A:  MOVFF  00,FEF
....................             ARPResolve(&UDPSocketInfo[ss].remote.remoteNode.IPAddr); 
0500E:  MOVLB  2
05010:  MOVF   x4C,W
05012:  MULLW  17
05014:  MOVF   FF3,W
05016:  CLRF   x52
05018:  MOVWF  x51
0501A:  MOVLW  5D
0501C:  ADDWF  x51,W
0501E:  MOVWF  01
05020:  MOVLW  00
05022:  ADDWFC x52,W
05024:  MOVWF  03
05026:  MOVFF  01,253
0502A:  MOVWF  x54
0502C:  MOVWF  x71
0502E:  MOVFF  01,270
05032:  MOVLB  0
05034:  CALL   3048
....................             UDPSocketInfo[ss].smState = UDP_GATEWAY_GET_ARP; 
05038:  MOVLB  2
0503A:  MOVF   x4C,W
0503C:  MULLW  17
0503E:  MOVF   FF3,W
05040:  CLRF   x52
05042:  MOVWF  x51
05044:  MOVLW  0E
05046:  ADDWF  x51,W
05048:  MOVWF  01
0504A:  MOVLW  00
0504C:  ADDWFC x52,W
0504E:  MOVWF  03
05050:  MOVF   01,W
05052:  ADDLW  5D
05054:  MOVWF  FE9
05056:  MOVLW  00
05058:  ADDWFC 03,W
0505A:  MOVWF  FEA
0505C:  MOVLW  03
0505E:  MOVWF  FEF
....................             break; 
05060:  MOVLB  0
05062:  BRA    522C
....................  
....................          case UDP_GATEWAY_GET_ARP: 
....................          if(!ARPIsResolved(&UDPSocketInfo[ss].remote.remoteNode.IPAddr,  
....................                         &UDPSocketInfo[ss].remote.remoteNode.MACAddr)) 
05064:  MOVLB  2
05066:  MOVF   x4C,W
05068:  MULLW  17
0506A:  MOVF   FF3,W
0506C:  CLRF   x52
0506E:  MOVWF  x51
05070:  MOVLW  5D
05072:  ADDWF  x51,W
05074:  MOVWF  01
05076:  MOVLW  00
05078:  ADDWFC x52,W
0507A:  MOVWF  03
0507C:  MOVFF  01,253
05080:  MOVWF  x54
05082:  MOVF   x4C,W
05084:  MULLW  17
05086:  MOVF   FF3,W
05088:  CLRF   x56
0508A:  MOVWF  x55
0508C:  MOVLW  04
0508E:  ADDWF  x55,W
05090:  MOVWF  01
05092:  MOVLW  00
05094:  ADDWFC x56,W
05096:  MOVWF  03
05098:  MOVF   01,W
0509A:  ADDLW  5D
0509C:  MOVWF  01
0509E:  MOVLW  00
050A0:  ADDWFC 03,F
050A2:  MOVFF  01,255
050A6:  MOVFF  03,256
050AA:  MOVFF  254,271
050AE:  MOVFF  253,270
050B2:  MOVFF  03,273
050B6:  MOVFF  01,272
050BA:  MOVLB  0
050BC:  CALL   30FC
050C0:  MOVF   01,F
050C2:  BTFSS  FD8.2
050C4:  BRA    5200
....................          { 
....................             // Time out if too much time is spent in this state 
....................             // Note that this will continuously send out ARP  
....................             // requests for an infinite time if the Gateway  
....................             // never responds 
....................             if((WORD)TickGetDiv256() - UDPSocketInfo[ss].eventTime> (WORD)UDPSocketInfo[ss].retryInterval) 
050C6:  CALL   16EE
050CA:  MOVFF  01,252
050CE:  MOVFF  00,251
050D2:  MOVLB  2
050D4:  MOVF   x4C,W
050D6:  MULLW  17
050D8:  MOVF   FF3,W
050DA:  CLRF   x54
050DC:  MOVWF  x53
050DE:  MOVLW  15
050E0:  ADDWF  x53,W
050E2:  MOVWF  01
050E4:  MOVLW  00
050E6:  ADDWFC x54,W
050E8:  MOVWF  03
050EA:  MOVF   01,W
050EC:  ADDLW  5D
050EE:  MOVWF  FE9
050F0:  MOVLW  00
050F2:  ADDWFC 03,W
050F4:  MOVWF  FEA
050F6:  MOVFF  FEC,03
050FA:  MOVF   FED,F
050FC:  MOVF   FEF,W
050FE:  SUBWF  x51,F
05100:  MOVF   03,W
05102:  SUBWFB x52,F
05104:  MOVF   x4C,W
05106:  MULLW  17
05108:  MOVF   FF3,W
0510A:  CLRF   x54
0510C:  MOVWF  x53
0510E:  MOVLW  0F
05110:  ADDWF  x53,W
05112:  MOVWF  01
05114:  MOVLW  00
05116:  ADDWFC x54,W
05118:  MOVWF  03
0511A:  MOVF   01,W
0511C:  ADDLW  5D
0511E:  MOVWF  FE9
05120:  MOVLW  00
05122:  ADDWFC 03,W
05124:  MOVWF  FEA
05126:  MOVFF  FEF,00
0512A:  MOVFF  FEC,01
0512E:  MOVFF  FEC,02
05132:  MOVFF  FEC,03
05136:  MOVF   01,W
05138:  SUBWF  x52,W
0513A:  BNC   51FC
0513C:  BNZ   5144
0513E:  MOVF   x51,W
05140:  SUBWF  00,W
05142:  BC    51FC
....................             { 
....................                // Exponentially increase timeout until we reach 6 attempts then stay constant 
....................                if(UDPSocketInfo[ss].retryCount < 6u) 
05144:  MOVF   x4C,W
05146:  MULLW  17
05148:  MOVF   FF3,W
0514A:  CLRF   x52
0514C:  MOVWF  x51
0514E:  MOVLW  13
05150:  ADDWF  x51,W
05152:  MOVWF  01
05154:  MOVLW  00
05156:  ADDWFC x52,W
05158:  MOVWF  03
0515A:  MOVF   01,W
0515C:  ADDLW  5D
0515E:  MOVWF  FE9
05160:  MOVLW  00
05162:  ADDWFC 03,W
05164:  MOVWF  FEA
05166:  MOVF   FEF,W
05168:  SUBLW  05
0516A:  BNC   51D6
....................                { 
....................                   UDPSocketInfo[ss].retryCount++; 
0516C:  MOVF   x4C,W
0516E:  MULLW  17
05170:  MOVF   FF3,W
05172:  CLRF   x52
05174:  MOVWF  x51
05176:  MOVLW  13
05178:  ADDWF  x51,W
0517A:  MOVWF  01
0517C:  MOVLW  00
0517E:  ADDWFC x52,W
05180:  MOVWF  03
05182:  MOVF   01,W
05184:  ADDLW  5D
05186:  MOVWF  FE9
05188:  MOVLW  00
0518A:  ADDWFC 03,W
0518C:  MOVWF  FEA
0518E:  INCF   FEF,F
....................                   UDPSocketInfo[ss].retryInterval <<= 1; 
05190:  MOVF   x4C,W
05192:  MULLW  17
05194:  MOVF   FF3,W
05196:  CLRF   x52
05198:  MOVWF  x51
0519A:  MOVLW  0F
0519C:  ADDWF  x51,W
0519E:  MOVWF  01
051A0:  MOVLW  00
051A2:  ADDWFC x52,W
051A4:  MOVWF  03
051A6:  MOVF   01,W
051A8:  ADDLW  5D
051AA:  MOVWF  FE9
051AC:  MOVLW  00
051AE:  ADDWFC 03,W
051B0:  MOVWF  FEA
051B2:  BCF    FD8.0
051B4:  RLCF   FEF,W
051B6:  MOVWF  00
051B8:  RLCF   FEC,W
051BA:  MOVWF  01
051BC:  RLCF   FEC,W
051BE:  MOVWF  02
051C0:  RLCF   FEC,W
051C2:  MOVF   FED,F
051C4:  MOVF   FED,F
051C6:  MOVF   FED,F
051C8:  MOVFF  00,FEF
051CC:  MOVFF  01,FEC
051D0:  MOVFF  02,FEC
051D4:  MOVWF  FEC
....................                } 
....................                // Retransmit ARP request 
....................                UDPSocketInfo[ss].smState = UDP_GATEWAY_SEND_ARP; 
051D6:  MOVF   x4C,W
051D8:  MULLW  17
051DA:  MOVF   FF3,W
051DC:  CLRF   x52
051DE:  MOVWF  x51
051E0:  MOVLW  0E
051E2:  ADDWF  x51,W
051E4:  MOVWF  01
051E6:  MOVLW  00
051E8:  ADDWFC x52,W
051EA:  MOVWF  03
051EC:  MOVF   01,W
051EE:  ADDLW  5D
051F0:  MOVWF  FE9
051F2:  MOVLW  00
051F4:  ADDWFC 03,W
051F6:  MOVWF  FEA
051F8:  MOVLW  02
051FA:  MOVWF  FEF
....................             }             
....................          } 
051FC:  BRA    5228
051FE:  MOVLB  0
....................          else 
....................          { 
....................             UDPSocketInfo[ss].smState = UDP_OPENED; 
05200:  MOVLB  2
05202:  MOVF   x4C,W
05204:  MULLW  17
05206:  MOVF   FF3,W
05208:  CLRF   x52
0520A:  MOVWF  x51
0520C:  MOVLW  0E
0520E:  ADDWF  x51,W
05210:  MOVWF  01
05212:  MOVLW  00
05214:  ADDWFC x52,W
05216:  MOVWF  03
05218:  MOVF   01,W
0521A:  ADDLW  5D
0521C:  MOVWF  FE9
0521E:  MOVLW  00
05220:  ADDWFC 03,W
05222:  MOVWF  FEA
05224:  MOVLW  05
05226:  MOVWF  FEF
....................          } 
....................          break; 
05228:  MOVLB  0
0522A:  BRA    522C
....................          default: 
....................          case UDP_OPENED: 
....................          case UDP_CLOSED: 
....................          // not used 
....................          break; 
0522C:  MOVLB  2
.................... #endif // #if defined(STACK_CLIENT_MODE) 
....................       } 
0522E:  INCF   x4C,F
05230:  BRA    4D5E
....................    } 
05232:  MOVLB  0
05234:  GOTO   7502 (RETURN)
.................... }  
....................  
.................... /****************************************************************************** 
....................   
....................   Function: 
....................      BOOL UDPISOpened(UDP_SOCKET socket) 
....................    
....................  Summary: 
....................      Determines if a socket has an established connection. 
....................  
....................  Description: 
....................    This function determines if a socket has an established connection to a remote node .   
....................    Call this function after calling UDPOpen to determine when the connection is set up  
....................    and ready for use.   
....................  
....................  Precondition: 
....................    UDP is initialized. 
....................  
....................  Parameters: 
....................    socket - The socket to check. 
....................  
....................  Return Values: 
....................    TRUE - The socket has been opened and ARP has been resolved. 
....................    FALSE - The socket is not currently connected. 
....................  
....................  Remarks: 
....................    None 
....................   
....................  *****************************************************************************/ 
.................... BOOL UDPIsOpened(UDP_SOCKET socket) 
.................... { 
....................    return (UDPSocketInfo[socket].smState == UDP_OPENED); 
.................... } 
....................  
....................  
.................... #if 0 
.................... /***************************************************************************** 
....................   Function: 
....................    void UDPTask(void) 
....................  
....................   Summary: 
....................    Performs state management and housekeeping for UDP. 
....................     
....................   Description: 
....................    Performs state management and housekeeping for UDP.  This is an internal 
....................    function meant to be called by StackTask() (not a user API). 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Return Values: 
....................      None 
....................       
....................   Remarks: 
....................    UDPTask() is called once per StackTask() iteration to ensure that calls  
....................    to UDPIsPutReady() always update the Ethernet Write pointer location  
....................    between StackTask() iterations. 
....................   ***************************************************************************/ 
.................... void UDPTask(void) 
.................... { 
....................    LastPutSocket = INVALID_UDP_SOCKET; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    UDP_SOCKET UDPOpen(UDP_PORT localPort, NODE_INFO* remoteNode,  
....................                   UDP_PORT remotePort) 
....................  
....................   Summary: 
....................    Creates a UDP socket handle for transmiting or receiving UDP packets. 
....................     
....................   Description: 
....................    Creates a UDP socket handle for transmiting or receiving UDP packets.   
....................    Call this function to obtain a handle required by other UDP function. 
....................  
....................   Precondition: 
....................    UDPInit() must have been previously called. 
....................  
....................   Parameters: 
....................    localPort - UDP port number to listen on.  If 0, stack will dynamically  
....................       assign a unique port number to use. 
....................    remoteNode - Pointer to remote node info (MAC and IP address) for this 
....................       connection.  If this is a server socket (receives the first packet)  
....................       or the destination is the broadcast address, then this parameter 
....................       should be NULL. 
....................    remotePort - For client sockets, the remote port number. 
....................  
....................   Return Values: 
....................      Success - 
....................       A UDP socket handle that can be used for subsequent UDP API calls. 
....................    Failure - 
....................       INVALID_UDP_SOCKET.  This function fails when no more UDP socket  
....................       handles are available.  Increase MAX_UDP_SOCKETS to make more sockets  
....................       available. 
....................       
....................   Remarks: 
....................    When finished using the UDP socket handle, call the UDPClose() function  
....................    to free the socket and delete the handle. 
....................   ***************************************************************************/ 
.................... UDP_SOCKET UDPOpen(UDP_PORT localPort, 
....................                    NODE_INFO *remoteNode, 
....................                    UDP_PORT remotePort) 
.................... { 
....................     UDP_SOCKET s; 
....................     UDP_SOCKET_INFO *p; 
....................  
....................    // Local temp port numbers. 
....................    static WORD NextPort __attribute__((persistent)); 
....................  
....................  
....................     p = UDPSocketInfo; 
....................     for ( s = 0; s < MAX_UDP_SOCKETS; s++ ) 
....................     { 
....................         if(p->localPort == INVALID_UDP_PORT) 
....................         { 
....................          p->localPort = localPort;    
....................  
....................          if(localPort == 0x0000u) 
....................          { 
....................             if(NextPort > LOCAL_UDP_PORT_END_NUMBER || NextPort < LOCAL_UDP_PORT_START_NUMBER) 
....................                NextPort = LOCAL_UDP_PORT_START_NUMBER; 
....................     
....................                p->localPort    = NextPort++; 
....................          } 
....................  
....................             // If remoteNode is supplied, remember it. 
....................             if(remoteNode) 
....................             { 
....................                 memcpy((void*)&p->remoteNode, 
....................                         (const void*)remoteNode, 
....................                         sizeof(p->remoteNode)); 
....................             } 
....................             else 
....................          { 
....................             // else Set broadcast address 
....................             memset((void*)&p->remoteNode, 0xFF, sizeof(p->remoteNode)); 
....................          } 
....................  
....................             p->remotePort   = remotePort; 
....................  
....................             // Mark this socket as active. 
....................             // Once an active socket is set, subsequent operation can be 
....................             // done without explicitely supply socket identifier. 
....................             activeUDPSocket = s; 
....................             return s; 
....................         } 
....................         p++; 
....................     } 
....................  
....................     return (UDP_SOCKET)INVALID_UDP_SOCKET; 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void UDPClose(UDP_SOCKET s) 
....................  
....................   Summary: 
....................    Closes a UDP socket and frees the handle. 
....................     
....................   Description: 
....................    Closes a UDP socket and frees the handle.  Call this function to release 
....................    a socket and return it to the pool for use by future communications. 
....................  
....................   Precondition: 
....................    UDPInit() must have been previously called. 
....................  
....................   Parameters: 
....................    s - The socket handle to be released.  If an illegal handle value is  
....................       provided, the function safely does nothing. 
....................  
....................   Returns: 
....................      None 
....................       
....................   Remarks: 
....................    This function does not affect the previously designated active socket. 
....................   ***************************************************************************/ 
.................... void UDPClose(UDP_SOCKET s) 
.................... { 
....................    if(s >= MAX_UDP_SOCKETS) 
*
00C0A:  MOVLB  2
00C0C:  MOVF   x70,W
00C0E:  SUBLW  06
00C10:  BC    0C14
....................       return; 
00C12:  BRA    0C8A
....................  
....................    UDPSocketInfo[s].localPort = INVALID_UDP_PORT; 
00C14:  MOVF   x70,W
00C16:  MULLW  17
00C18:  MOVF   FF3,W
00C1A:  CLRF   x72
00C1C:  MOVWF  x71
00C1E:  MOVLW  0C
00C20:  ADDWF  x71,W
00C22:  MOVWF  01
00C24:  MOVLW  00
00C26:  ADDWFC x72,W
00C28:  MOVWF  03
00C2A:  MOVF   01,W
00C2C:  ADDLW  5D
00C2E:  MOVWF  FE9
00C30:  MOVLW  00
00C32:  ADDWFC 03,W
00C34:  MOVWF  FEA
00C36:  CLRF   FEC
00C38:  MOVF   FED,F
00C3A:  CLRF   FEF
....................    UDPSocketInfo[s].remote.remoteNode.IPAddr.Val = 0x00000000; 
00C3C:  MOVF   x70,W
00C3E:  MULLW  17
00C40:  MOVF   FF3,W
00C42:  CLRF   x72
00C44:  MOVWF  x71
00C46:  MOVLW  5D
00C48:  ADDWF  x71,W
00C4A:  MOVWF  FE9
00C4C:  MOVLW  00
00C4E:  ADDWFC x72,W
00C50:  MOVWF  FEA
00C52:  MOVF   FEE,F
00C54:  MOVF   FEE,F
00C56:  CLRF   FEC
00C58:  MOVF   FED,F
00C5A:  CLRF   FEF
00C5C:  MOVF   FED,F
00C5E:  CLRF   FEF
00C60:  MOVF   FED,F
00C62:  CLRF   FEF
....................    UDPSocketInfo[s].smState = UDP_CLOSED; 
00C64:  MOVF   x70,W
00C66:  MULLW  17
00C68:  MOVF   FF3,W
00C6A:  CLRF   x72
00C6C:  MOVWF  x71
00C6E:  MOVLW  0E
00C70:  ADDWF  x71,W
00C72:  MOVWF  01
00C74:  MOVLW  00
00C76:  ADDWFC x72,W
00C78:  MOVWF  03
00C7A:  MOVF   01,W
00C7C:  ADDLW  5D
00C7E:  MOVWF  FE9
00C80:  MOVLW  00
00C82:  ADDWFC 03,W
00C84:  MOVWF  FEA
00C86:  MOVLW  04
00C88:  MOVWF  FEF
00C8A:  MOVLB  0
00C8C:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void UDPSetTxBuffer(WORD wOffset) 
....................  
....................   Summary: 
....................    Moves the pointer within the TX buffer. 
....................     
....................   Description: 
....................    This function allows the write location within the TX buffer to be  
....................    specified.  Future calls to UDPPut, UDPPutArray, UDPPutString, etc will 
....................    write data from the indicated location. 
....................  
....................   Precondition: 
....................    UDPInit() must have been previously called and a socket is currently  
....................    active. 
....................  
....................   Parameters: 
....................    wOffset - Offset from beginning of UDP packet data payload to place the 
....................       write pointer. 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... void UDPSetTxBuffer(WORD wOffset) 
.................... { 
....................    IPSetTxBuffer(wOffset+sizeof(UDP_HEADER)); 
*
0340E:  MOVLW  08
03410:  MOVLB  2
03412:  ADDWF  x71,W
03414:  MOVWF  x73
03416:  MOVLW  00
03418:  ADDWFC x72,W
0341A:  MOVWF  x74
0341C:  MOVLW  E5
0341E:  ADDWF  x73,F
03420:  MOVLW  17
03422:  ADDWFC x74,F
03424:  MOVLW  0E
03426:  ADDWF  x73,F
03428:  MOVLW  00
0342A:  ADDWFC x74,F
0342C:  MOVLW  14
0342E:  ADDWF  x73,F
03430:  MOVLW  00
03432:  ADDWFC x74,F
03434:  MOVFF  274,2D1
03438:  MOVFF  273,2D0
0343C:  MOVLB  0
0343E:  CALL   0D6C
....................    wPutOffset = wOffset; 
03442:  MOVFF  272,13E
03446:  MOVFF  271,13D
0344A:  GOTO   347C (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void UDPSetRxBuffer(WORD wOffset) 
....................  
....................   Summary: 
....................    Moves the pointer within the RX buffer. 
....................     
....................   Description: 
....................    This function allows the read location within the RX buffer to be  
....................    specified.  Future calls to UDPGet and UDPGetArray will read data from 
....................    the indicated location forward. 
....................  
....................   Precondition: 
....................    UDPInit() must have been previously called and a socket is currently  
....................    active. 
....................  
....................   Parameters: 
....................    wOffset - Offset from beginning of UDP packet data payload to place the 
....................       read pointer. 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... void UDPSetRxBuffer(WORD wOffset) 
.................... { 
....................    IPSetRxBuffer(wOffset+sizeof(UDP_HEADER)); 
*
03958:  MOVLW  08
0395A:  MOVLB  2
0395C:  ADDWF  x71,W
0395E:  MOVWF  x73
03960:  MOVLW  00
03962:  ADDWFC x72,W
03964:  MOVWF  x74
03966:  MOVWF  x9C
03968:  MOVFF  273,29B
0396C:  MOVLB  0
0396E:  RCALL  393C
....................    wGetOffset = wOffset; 
03970:  MOVFF  272,140
03974:  MOVFF  271,13F
03978:  GOTO   39A2 (RETURN)
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Transmit Functions 
....................   ***************************************************************************/ 
....................    
.................... /***************************************************************************** 
....................   Function: 
....................    WORD UDPIsPutReady(UDP_SOCKET s) 
....................  
....................   Summary: 
....................    Determines how many bytes can be written to the UDP socket. 
....................     
....................   Description: 
....................    This function determines if bytes can be written to the specified UDP 
....................    socket.  It also prepares the UDP module for writing by setting the  
....................    indicated socket as the currently active connection. 
....................  
....................   Precondition: 
....................    UDPInit() must have been previously called. 
....................  
....................   Parameters: 
....................    s - The socket to be made active 
....................  
....................   Returns: 
....................      The number of bytes that can be written to this socket. 
....................   ***************************************************************************/ 
.................... WORD UDPIsPutReady(UDP_SOCKET s) 
.................... { 
....................    if(!MACIsTxReady()) 
*
0344E:  CALL   168C
03452:  MOVF   01,F
03454:  BNZ   345E
....................       return 0; 
03456:  MOVLW  00
03458:  MOVWF  01
0345A:  MOVWF  02
0345C:  BRA    3498
....................  
....................    if(LastPutSocket != s) 
0345E:  MOVLB  2
03460:  MOVF   x70,W
03462:  MOVLB  1
03464:  SUBWF  x3C,W
03466:  BZ    347E
....................    { 
....................       LastPutSocket = s; 
03468:  MOVFF  270,13C
....................       UDPTxCount = 0; 
0346C:  MOVLB  0
0346E:  CLRF   xFF
03470:  CLRF   xFE
....................       UDPSetTxBuffer(0); 
03472:  MOVLB  2
03474:  CLRF   x72
03476:  CLRF   x71
03478:  MOVLB  0
0347A:  BRA    340E
0347C:  MOVLB  1
....................    } 
....................  
....................    activeUDPSocket = s; 
0347E:  MOVFF  270,5C
....................  
....................    return MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER) - UDPTxCount; 
03482:  MOVLW  C0
03484:  BSF    FD8.0
03486:  MOVLB  0
03488:  SUBFWB xFE,W
0348A:  MOVWF  00
0348C:  MOVLW  05
0348E:  SUBFWB xFF,W
03490:  MOVWF  03
03492:  MOVFF  00,01
03496:  MOVWF  02
03498:  GOTO   3C7C (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL UDPPut(BYTE v) 
....................  
....................   Summary: 
....................    Writes a byte to the currently active socket. 
....................     
....................   Description: 
....................    This function writes a single byte to the currently active UDP socket,  
....................    while incrementing the buffer length.  UDPIsPutReady should be used  
....................    before calling this function to specify the currently active socket. 
....................  
....................   Precondition: 
....................    UDPIsPutReady() was previously called to specify the current socket. 
....................  
....................   Parameters: 
....................    v - The byte to be loaded into the transmit buffer. 
....................  
....................   Return Values: 
....................      TRUE - The byte was successfully written to the socket. 
....................      FALSE - The transmit buffer is already full and so the write failed. 
....................   ***************************************************************************/ 
.................... BOOL UDPPut(BYTE v) 
.................... { 
....................    // See if we are out of transmit space. 
....................    if(wPutOffset >= (MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER))) 
0349C:  MOVLB  1
0349E:  MOVF   x3E,W
034A0:  SUBLW  04
034A2:  BC    34B4
034A4:  XORLW  FF
034A6:  BNZ   34AE
034A8:  MOVF   x3D,W
034AA:  SUBLW  BF
034AC:  BC    34B4
....................    { 
....................       return FALSE; 
034AE:  MOVLW  00
034B0:  MOVWF  01
034B2:  BRA    34EE
....................    } 
....................  
....................     // Load application data byte 
....................     MACPut(v); 
034B4:  MOVFF  276,2E4
034B8:  MOVLB  0
034BA:  CALL   0878
....................    wPutOffset++; 
034BE:  MOVLB  1
034C0:  INCF   x3D,F
034C2:  BTFSC  FD8.2
034C4:  INCF   x3E,F
....................    if(wPutOffset > UDPTxCount) 
034C6:  MOVLB  0
034C8:  MOVF   xFF,W
034CA:  MOVLB  1
034CC:  SUBWF  x3E,W
034CE:  BNC   34EA
034D0:  BNZ   34E2
034D2:  MOVF   x3D,W
034D4:  MOVLB  0
034D6:  SUBWF  xFE,W
034D8:  BTFSS  FD8.0
034DA:  BRA    34E0
034DC:  MOVLB  1
034DE:  BRA    34EA
034E0:  MOVLB  1
....................       UDPTxCount = wPutOffset; 
034E2:  MOVFF  13E,FF
034E6:  MOVFF  13D,FE
....................  
....................     return TRUE; 
034EA:  MOVLW  01
034EC:  MOVWF  01
034EE:  MOVLB  0
034F0:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD UDPPutArray(BYTE *cData, WORD wDataLen) 
....................  
....................   Summary: 
....................    Writes an array of bytes to the currently active socket. 
....................     
....................   Description: 
....................    This function writes an array of bytes to the currently active UDP socket,  
....................    while incrementing the buffer length.  UDPIsPutReady should be used  
....................    before calling this function to specify the currently active socket. 
....................  
....................   Precondition: 
....................    UDPIsPutReady() was previously called to specify the current socket. 
....................  
....................   Parameters: 
....................    cData - The array to write to the socket. 
....................    wDateLen - Number of bytes from cData to be written. 
....................     
....................   Returns: 
....................      The number of bytes successfully placed in the UDP transmit buffer.  If 
....................      this value is less than wDataLen, then the buffer became full and the 
....................      input was truncated. 
....................   ***************************************************************************/ 
.................... WORD UDPPutArray(BYTE *cData, WORD wDataLen) 
.................... { 
....................    WORD wTemp; 
....................  
....................    wTemp = (MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER)) - wPutOffset; 
034F2:  MOVLW  C0
034F4:  BSF    FD8.0
034F6:  MOVLB  1
034F8:  SUBFWB x3D,W
034FA:  MOVLB  2
034FC:  MOVWF  x7A
034FE:  MOVLW  05
03500:  MOVLB  1
03502:  SUBFWB x3E,W
03504:  MOVLB  2
03506:  MOVWF  x7B
....................    if(wTemp < wDataLen) 
03508:  MOVF   x7B,W
0350A:  SUBWF  x79,W
0350C:  BNC   351E
0350E:  BNZ   3516
03510:  MOVF   x78,W
03512:  SUBWF  x7A,W
03514:  BC    351E
....................       wDataLen = wTemp; 
03516:  MOVFF  27B,279
0351A:  MOVFF  27A,278
....................  
....................    wPutOffset += wDataLen; 
0351E:  MOVF   x78,W
03520:  MOVLB  1
03522:  ADDWF  x3D,F
03524:  MOVLB  2
03526:  MOVF   x79,W
03528:  MOVLB  1
0352A:  ADDWFC x3E,F
....................    if(wPutOffset > UDPTxCount) 
0352C:  MOVLB  0
0352E:  MOVF   xFF,W
03530:  MOVLB  1
03532:  SUBWF  x3E,W
03534:  BNC   3550
03536:  BNZ   3548
03538:  MOVF   x3D,W
0353A:  MOVLB  0
0353C:  SUBWF  xFE,W
0353E:  BTFSS  FD8.0
03540:  BRA    3546
03542:  MOVLB  1
03544:  BRA    3550
03546:  MOVLB  1
....................       UDPTxCount = wPutOffset; 
03548:  MOVFF  13E,FF
0354C:  MOVFF  13D,FE
....................  
....................     // Load application data bytes 
....................     MACPutArray(cData, wDataLen); 
03550:  MOVFF  277,2E6
03554:  MOVFF  276,2E5
03558:  MOVFF  279,2E8
0355C:  MOVFF  278,2E7
03560:  MOVLB  0
03562:  CALL   0DDC
....................  
....................     return wDataLen; 
03566:  MOVLB  2
03568:  MOVFF  278,01
0356C:  MOVFF  279,02
03570:  MOVLB  0
03572:  GOTO   35E8 (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD UDPPutROMArray(ROM BYTE *cData, WORD wDataLen) 
....................  
....................   Summary: 
....................    Writes an array of bytes from ROM to the currently active socket. 
....................     
....................   Description: 
....................    This function writes an array of bytes from ROM to the currently active  
....................    UDP socket, while incrementing the buffer length.  UDPIsPutReady should  
....................    be used before calling this function to specify the currently active  
....................    socket. 
....................  
....................   Precondition: 
....................    UDPIsPutReady() was previously called to specify the current socket. 
....................  
....................   Parameters: 
....................    cData - The array to write to the socket. 
....................    wDateLen - Number of bytes from cData to be written. 
....................     
....................   Returns: 
....................      The number of bytes successfully placed in the UDP transmit buffer.  If 
....................      this value is less than wDataLen, then the buffer became full and the 
....................      input was truncated. 
....................       
....................   Remarks: 
....................    This function is aliased to UDPPutArray on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... WORD UDPPutROMArray(ROM BYTE *cData, WORD wDataLen) 
.................... { 
....................    WORD wTemp; 
....................  
....................    wTemp = (MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER)) - wPutOffset; 
*
03688:  MOVLW  C0
0368A:  BSF    FD8.0
0368C:  MOVLB  1
0368E:  SUBFWB x3D,W
03690:  MOVLB  2
03692:  MOVWF  x7A
03694:  MOVLW  05
03696:  MOVLB  1
03698:  SUBFWB x3E,W
0369A:  MOVLB  2
0369C:  MOVWF  x7B
....................    if(wTemp < wDataLen) 
0369E:  MOVF   x7B,W
036A0:  SUBWF  x79,W
036A2:  BNC   36B4
036A4:  BNZ   36AC
036A6:  MOVF   x78,W
036A8:  SUBWF  x7A,W
036AA:  BC    36B4
....................       wDataLen = wTemp; 
036AC:  MOVFF  27B,279
036B0:  MOVFF  27A,278
....................  
....................    wPutOffset += wDataLen; 
036B4:  MOVF   x78,W
036B6:  MOVLB  1
036B8:  ADDWF  x3D,F
036BA:  MOVLB  2
036BC:  MOVF   x79,W
036BE:  MOVLB  1
036C0:  ADDWFC x3E,F
....................    if(wPutOffset > UDPTxCount) 
036C2:  MOVLB  0
036C4:  MOVF   xFF,W
036C6:  MOVLB  1
036C8:  SUBWF  x3E,W
036CA:  BNC   36E6
036CC:  BNZ   36DE
036CE:  MOVF   x3D,W
036D0:  MOVLB  0
036D2:  SUBWF  xFE,W
036D4:  BTFSS  FD8.0
036D6:  BRA    36DC
036D8:  MOVLB  1
036DA:  BRA    36E6
036DC:  MOVLB  1
....................       UDPTxCount = wPutOffset; 
036DE:  MOVFF  13E,FF
036E2:  MOVFF  13D,FE
....................  
....................     // Load application data bytes 
....................     MACPutROMArray(cData, wDataLen); 
036E6:  MOVFF  277,27D
036EA:  MOVFF  276,27C
036EE:  MOVFF  279,27F
036F2:  MOVFF  278,27E
036F6:  MOVLB  0
036F8:  BRA    3626
....................  
....................     return wDataLen; 
036FA:  MOVLB  2
036FC:  MOVFF  278,01
03700:  MOVFF  279,02
03704:  MOVLB  0
03706:  GOTO   3794 (RETURN)
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE* UDPPutString(BYTE *strData) 
....................  
....................   Summary: 
....................    Writes null-terminated string to the currently active socket. 
....................     
....................   Description: 
....................    This function writes a null-terminated string to the currently active  
....................    UDP socket, while incrementing the buffer length.  UDPIsPutReady should  
....................    be used before calling this function to specify the currently active 
....................    socket. 
....................  
....................   Precondition: 
....................    UDPIsPutReady() was previously called to specify the current socket. 
....................  
....................   Parameters: 
....................    cData - Pointer to the string to be written to the socket. 
....................     
....................   Returns: 
....................      A pointer to the byte following the last byte written.  Note that this 
....................      is different than the UDPPutArray functions.  If this pointer does not 
....................      dereference to a NULL byte, then the buffer became full and the input 
....................      data was truncated. 
....................   ***************************************************************************/ 
.................... BYTE* UDPPutString(BYTE *strData) 
.................... { 
....................    return strData + UDPPutArray(strData, strlen((char*)strData)); 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE* UDPPutString(BYTE *strData) 
....................  
....................   Summary: 
....................    Writes null-terminated string from ROM to the currently active socket. 
....................     
....................   Description: 
....................    This function writes a null-terminated string from ROM to the currently 
....................    active UDP socket, while incrementing the buffer length.  UDPIsPutReady 
....................    should be used before calling this function to specify the currently 
....................    active socket. 
....................  
....................   Precondition: 
....................    UDPIsPutReady() was previously called to specify the current socket. 
....................  
....................   Parameters: 
....................    cData - Pointer to the string to be written to the socket. 
....................     
....................   Returns: 
....................      A pointer to the byte following the last byte written.  Note that this 
....................      is different than the UDPPutArray functions.  If this pointer does not 
....................      dereference to a NULL byte, then the buffer became full and the input 
....................      data was truncated. 
....................    
....................   Remarks: 
....................    This function is aliased to UDPPutString on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... ROM BYTE* UDPPutROMString(ROM BYTE *strData) 
.................... { 
....................    return strData + UDPPutROMArray(strData, strlenpgm((ROM char*)strData)); 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void UDPFlush(void) 
....................  
....................   Summary: 
....................    Transmits all pending data in a UDP socket. 
....................     
....................   Description: 
....................    This function builds a UDP packet with the pending TX data and marks it  
....................    for transmission over the network interface.  Since UDP is a frame-based 
....................    protocol, this function must be called before returning to the main 
....................    stack loop whenever any data is written. 
....................  
....................   Precondition: 
....................    UDPIsPutReady() was previously called to specify the current socket, and 
....................    data has been written to the socket using the UDPPut family of functions. 
....................  
....................   Parameters: 
....................    None 
....................     
....................   Returns: 
....................      None 
....................  
....................   Remarks: 
....................    Note that unlike TCPFlush, UDPFlush must be called before returning to  
....................    the main stack loop.  There is no auto transmit for UDP segments. 
....................   ***************************************************************************/ 
.................... void UDPFlush(void) 
.................... { 
....................     UDP_HEADER      h; 
....................     UDP_SOCKET_INFO *p; 
....................     WORD         wUDPLength; 
....................  
....................     p = &UDPSocketInfo[activeUDPSocket]; 
*
037DC:  MOVF   5C,W
037DE:  MULLW  17
037E0:  MOVF   FF3,W
037E2:  CLRF   03
037E4:  ADDLW  5D
037E6:  MOVWF  01
037E8:  MOVLW  00
037EA:  ADDWFC 03,F
037EC:  MOVFF  01,278
037F0:  MOVLB  2
037F2:  MOVFF  03,279
....................  
....................    wUDPLength = UDPTxCount + sizeof(UDP_HEADER); 
037F6:  MOVLW  08
037F8:  MOVLB  0
037FA:  ADDWF  xFE,W
037FC:  MOVLB  2
037FE:  MOVWF  x7A
03800:  MOVLW  00
03802:  MOVLB  0
03804:  ADDWFC xFF,W
03806:  MOVLB  2
03808:  MOVWF  x7B
....................  
....................    // Generate the correct UDP header 
....................     h.SourcePort        = swaps(p->localPort); 
0380A:  MOVLW  0C
0380C:  ADDWF  x78,W
0380E:  MOVWF  FE9
03810:  MOVLW  00
03812:  ADDWFC x79,W
03814:  MOVWF  FEA
03816:  MOVFF  FEC,27D
0381A:  MOVF   FED,F
0381C:  MOVFF  FEF,27C
03820:  MOVFF  27D,2E1
03824:  MOVFF  27C,2E0
03828:  MOVLB  0
0382A:  CALL   1874
0382E:  MOVFF  02,271
03832:  MOVFF  01,270
....................     h.DestinationPort   = swaps(p->remotePort); 
03836:  MOVLW  0A
03838:  MOVLB  2
0383A:  ADDWF  x78,W
0383C:  MOVWF  FE9
0383E:  MOVLW  00
03840:  ADDWFC x79,W
03842:  MOVWF  FEA
03844:  MOVFF  FEC,27D
03848:  MOVF   FED,F
0384A:  MOVFF  FEF,27C
0384E:  MOVFF  27D,2E1
03852:  MOVFF  27C,2E0
03856:  MOVLB  0
03858:  CALL   1874
0385C:  MOVFF  02,273
03860:  MOVFF  01,272
....................     h.Length            = swaps(wUDPLength); 
03864:  MOVFF  27B,2E1
03868:  MOVFF  27A,2E0
0386C:  CALL   1874
03870:  MOVFF  02,275
03874:  MOVFF  01,274
....................    h.Checksum          = 0x0000; 
03878:  MOVLB  2
0387A:  CLRF   x77
0387C:  CLRF   x76
....................      
....................    // Calculate IP pseudoheader checksum if we are going to enable  
....................    // the checksum field 
....................    #if defined(UDP_USE_TX_CHECKSUM) 
....................    { 
....................       PSEUDO_HEADER   pseudoHeader; 
....................        
....................       pseudoHeader.SourceAddress   = AppConfig.MyIPAddr; 
....................       pseudoHeader.DestAddress    = p->remote.remoteNode.IPAddr; 
....................       pseudoHeader.Zero           = 0x0; 
....................       pseudoHeader.Protocol       = IP_PROT_UDP; 
....................       pseudoHeader.Length         = wUDPLength; 
....................       SwapPseudoHeader(pseudoHeader); 
....................       h.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader, sizeof(pseudoHeader)); 
....................    } 
....................    #endif 
....................  
....................    // Position the hardware write pointer where we will need to  
....................    // begin writing the IP header 
....................    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER)); 
0387E:  MOVLW  17
03880:  MOVWF  xD1
03882:  MOVLW  F3
03884:  MOVWF  xD0
03886:  MOVLB  0
03888:  CALL   0D6C
....................     
....................    // Write IP header to packet 
....................    IPPutHeader(&p->remote.remoteNode, IP_PROT_UDP, wUDPLength); 
0388C:  MOVLB  2
0388E:  MOVFF  278,01
03892:  MOVFF  279,03
03896:  MOVFF  278,27C
0389A:  MOVFF  279,27D
0389E:  MOVFF  279,2C2
038A2:  MOVFF  278,2C1
038A6:  MOVLW  11
038A8:  MOVWF  xC3
038AA:  MOVFF  27B,2C5
038AE:  MOVFF  27A,2C4
038B2:  MOVLB  0
038B4:  CALL   1EB0
....................  
....................     // Write UDP header to packet 
....................     MACPutArray((BYTE*)&h, sizeof(h)); 
038B8:  MOVLW  02
038BA:  MOVLB  2
038BC:  MOVWF  x7D
038BE:  MOVLW  70
038C0:  MOVWF  x7C
038C2:  MOVFF  27D,2E6
038C6:  MOVWF  xE5
038C8:  CLRF   xE8
038CA:  MOVLW  08
038CC:  MOVWF  xE7
038CE:  MOVLB  0
038D0:  CALL   0DDC
....................      
....................    // Calculate the final UDP checksum and write it in, if enabled 
....................    #if defined(UDP_USE_TX_CHECKSUM) 
....................    { 
....................         PTR_BASE   wReadPtrSave; 
....................         WORD      wChecksum; 
....................  
....................       wReadPtrSave = MACSetReadPtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER)); 
....................       wChecksum = CalcIPBufferChecksum(wUDPLength); 
....................       if(wChecksum == 0x0000u) 
....................          wChecksum = 0xFFFF; 
....................       MACSetReadPtr(wReadPtrSave); 
....................       MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER) + 6);   // 6 is the offset to the Checksum field in UDP_HEADER 
....................       MACPutArray((BYTE*)&wChecksum, sizeof(wChecksum)); 
....................    } 
....................    #endif 
....................      
....................    // Transmit the packet 
....................     MACFlush(); 
038D4:  CALL   20E2
....................  
....................    // Reset packet size counter for the next TX operation 
....................     UDPTxCount = 0; 
038D8:  CLRF   xFF
038DA:  CLRF   xFE
....................    LastPutSocket = INVALID_UDP_SOCKET; 
038DC:  MOVLB  1
038DE:  SETF   x3C
038E0:  MOVLB  0
038E2:  GOTO   3D58 (RETURN)
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Receive Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD UDPIsGetReady(UDP_SOCKET s) 
....................  
....................   Summary: 
....................    Determines how many bytes can be read from the UDP socket. 
....................     
....................   Description: 
....................    This function determines if bytes can be read from the specified UDP 
....................    socket.  It also prepares the UDP module for reading by setting the  
....................    indicated socket as the currently active connection. 
....................  
....................   Precondition: 
....................    UDPInit() must have been previously called. 
....................  
....................   Parameters: 
....................    s - The socket to be made active (which has already been opened or is 
....................       listening) 
....................  
....................   Returns: 
....................      The number of bytes that can be read from this socket. 
....................   ***************************************************************************/ 
.................... WORD UDPIsGetReady(UDP_SOCKET s) 
.................... { 
....................     activeUDPSocket = s; 
*
0397C:  MOVFF  270,5C
....................    if(SocketWithRxData != s) 
03980:  MOVLB  2
03982:  MOVF   x70,W
03984:  MOVLB  1
03986:  SUBWF  x42,W
03988:  BZ    3992
....................       return 0; 
0398A:  MOVLW  00
0398C:  MOVWF  01
0398E:  MOVWF  02
03990:  BRA    39B6
....................  
....................     // If this is the very first time we are accessing this packet,  
....................     // move the read point to the begining of the packet. 
....................     if(Flags.bFirstRead) 
03992:  BTFSS  x41.0
03994:  BRA    39A4
....................     { 
....................         Flags.bFirstRead = 0; 
03996:  BCF    x41.0
....................         UDPSetRxBuffer(0); 
03998:  MOVLB  2
0399A:  CLRF   x72
0399C:  CLRF   x71
0399E:  MOVLB  0
039A0:  BRA    3958
039A2:  MOVLB  1
....................     } 
....................  
....................     return UDPRxCount - wGetOffset; 
039A4:  MOVF   x3F,W
039A6:  SUBWF  x00,W
039A8:  MOVWF  00
039AA:  MOVF   x40,W
039AC:  SUBWFB x01,W
039AE:  MOVWF  03
039B0:  MOVFF  00,01
039B4:  MOVWF  02
039B6:  MOVLB  0
039B8:  GOTO   3D7A (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL UDPGet(BYTE *v) 
....................  
....................   Summary: 
....................    Reads a byte from the currently active socket. 
....................     
....................   Description: 
....................    This function reads a single byte from the currently active UDP socket,  
....................    while decrementing the remaining buffer length.  UDPIsGetReady should be  
....................    used before calling this function to specify the currently active socket. 
....................  
....................   Precondition: 
....................    UDPIsGetReady() was previously called to specify the current socket. 
....................  
....................   Parameters: 
....................    v - The buffer to receive the data being read. 
....................  
....................   Return Values: 
....................      TRUE - A byte was successfully read 
....................      FALSE - No data remained in the read buffer 
....................   ***************************************************************************/ 
.................... BOOL UDPGet(BYTE *v) 
.................... { 
....................    // Make sure that there is data to return 
....................     if((wGetOffset >= UDPRxCount) || (SocketWithRxData != activeUDPSocket)) 
039BC:  MOVLB  1
039BE:  MOVF   x01,W
039C0:  SUBWF  x40,W
039C2:  BNC   39CC
039C4:  BNZ   39D2
039C6:  MOVF   x00,W
039C8:  SUBWF  x3F,W
039CA:  BC    39D2
039CC:  MOVF   5C,W
039CE:  SUBWF  x42,W
039D0:  BZ    39D8
....................         return FALSE; 
039D2:  MOVLW  00
039D4:  MOVWF  01
039D6:  BRA    3A02
....................  
....................     *v = MACGet(); 
039D8:  MOVFF  272,03
039DC:  MOVFF  271,273
039E0:  MOVFF  272,274
039E4:  MOVLB  0
039E6:  CALL   0F04
039EA:  MOVFF  274,FEA
039EE:  MOVFF  273,FE9
039F2:  MOVFF  01,FEF
....................     wGetOffset++; 
039F6:  MOVLB  1
039F8:  INCF   x3F,F
039FA:  BTFSC  FD8.2
039FC:  INCF   x40,F
....................  
....................     return TRUE; 
039FE:  MOVLW  01
03A00:  MOVWF  01
03A02:  MOVLB  0
03A04:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD UDPGetArray(BYTE *cData, WORD wDataLen) 
....................  
....................   Summary: 
....................    Reads an array of bytes from the currently active socket. 
....................     
....................   Description: 
....................    This function reads an array of bytes from the currently active UDP socket,  
....................    while decrementing the remaining bytes available. UDPIsGetReady should be  
....................    used before calling this function to specify the currently active socket. 
....................  
....................   Precondition: 
....................    UDPIsGetReady() was previously called to specify the current socket. 
....................  
....................   Parameters: 
....................    cData - The buffer to receive the bytes being read.  If NULL, the bytes are  
....................          simply discarded without being written anywhere (effectively skips  
....................          over the bytes in the RX buffer, although if you need to skip a lot  
....................          of data, seeking using the UDPSetRxBuffer() will be more efficient). 
....................    wDateLen - Number of bytes to be read from the socket. 
....................     
....................   Returns: 
....................      The number of bytes successfully read from the UDP buffer.  If this 
....................      value is less than wDataLen, then the buffer was emptied and no more  
....................      data is available. 
....................   ***************************************************************************/ 
.................... WORD UDPGetArray(BYTE *cData, WORD wDataLen) 
.................... { 
....................    WORD wBytesAvailable; 
....................     
....................    // Make sure that there is data to return 
....................     if((wGetOffset >= UDPRxCount) || (SocketWithRxData != activeUDPSocket)) 
*
03A86:  MOVLB  1
03A88:  MOVF   x01,W
03A8A:  SUBWF  x40,W
03A8C:  BNC   3A96
03A8E:  BNZ   3A9C
03A90:  MOVF   x00,W
03A92:  SUBWF  x3F,W
03A94:  BC    3A9C
03A96:  MOVF   5C,W
03A98:  SUBWF  x42,W
03A9A:  BZ    3AA4
....................       return 0; 
03A9C:  MOVLW  00
03A9E:  MOVWF  01
03AA0:  MOVWF  02
03AA2:  BRA    3B06
....................  
....................    // Make sure we don't try to read more data than exists 
....................    wBytesAvailable = UDPRxCount - wGetOffset; 
03AA4:  MOVF   x3F,W
03AA6:  SUBWF  x00,W
03AA8:  MOVLB  2
03AAA:  MOVWF  x75
03AAC:  MOVLB  1
03AAE:  MOVF   x40,W
03AB0:  SUBWFB x01,W
03AB2:  MOVLB  2
03AB4:  MOVWF  x76
....................    if(wBytesAvailable < wDataLen) 
03AB6:  MOVF   x76,W
03AB8:  SUBWF  x74,W
03ABA:  BNC   3ACC
03ABC:  BNZ   3AC4
03ABE:  MOVF   x73,W
03AC0:  SUBWF  x75,W
03AC2:  BC    3ACC
....................       wDataLen = wBytesAvailable; 
03AC4:  MOVFF  276,274
03AC8:  MOVFF  275,273
....................  
....................    wDataLen = MACGetArray(cData, wDataLen); 
03ACC:  MOVFF  272,2E4
03AD0:  MOVFF  271,2E3
03AD4:  MOVFF  274,2E6
03AD8:  MOVFF  273,2E5
03ADC:  MOVLB  0
03ADE:  CALL   0E8E
03AE2:  MOVFF  02,274
03AE6:  MOVFF  01,273
....................     wGetOffset += wDataLen; 
03AEA:  MOVLB  2
03AEC:  MOVF   x73,W
03AEE:  MOVLB  1
03AF0:  ADDWF  x3F,F
03AF2:  MOVLB  2
03AF4:  MOVF   x74,W
03AF6:  MOVLB  1
03AF8:  ADDWFC x40,F
....................  
....................     return wDataLen; 
03AFA:  MOVLB  2
03AFC:  MOVFF  273,01
03B00:  MOVFF  274,02
03B04:  MOVLB  1
03B06:  MOVLB  0
03B08:  GOTO   3B52 (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void UDPDiscard(void) 
....................  
....................   Summary: 
....................    Discards any remaining RX data from a UDP socket. 
....................     
....................   Description: 
....................    This function discards any remaining received data in the currently  
....................    active UDP socket. 
....................  
....................   Precondition: 
....................    UDPIsGetReady() was previously called to select the currently active 
....................    socket. 
....................  
....................   Parameters: 
....................    None 
....................     
....................   Returns: 
....................      None 
....................  
....................   Remarks: 
....................    It is safe to call this function more than is necessary.  If no data is 
....................    available, this function does nothing. 
....................   ***************************************************************************/ 
.................... void UDPDiscard(void) 
.................... { 
....................    if(!Flags.bWasDiscarded) 
*
03A6E:  MOVLB  1
03A70:  BTFSC  x41.1
03A72:  BRA    3A82
....................    { 
....................       MACDiscardRx(); 
03A74:  MOVLB  0
03A76:  RCALL  3A06
....................       UDPRxCount = 0; 
03A78:  MOVLB  1
03A7A:  CLRF   x01
03A7C:  CLRF   x00
....................       SocketWithRxData = INVALID_UDP_SOCKET; 
03A7E:  SETF   x42
....................       Flags.bWasDiscarded = 1; 
03A80:  BSF    x41.1
....................    } 
03A82:  MOVLB  0
03A84:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Data Processing Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL UDPProcess(NODE_INFO *remoteNode, IP_ADDR *localIP, WORD len) 
....................  
....................   Summary: 
....................    Handles an incoming UDP segment. 
....................     
....................   Description: 
....................    This function handles an incoming UDP segment to determine if it is  
....................    acceptable and should be handed to one of the stack applications for 
....................    processing. 
....................  
....................   Precondition: 
....................    UDPInit() has been called an a UDP segment is ready in the MAC buffer. 
....................  
....................   Parameters: 
....................    remoteNode - The remote node that sent this segment. 
....................    localIP - The destination IP address for this segment. 
....................    len - Total length of the UDP segment. 
....................     
....................   Return Values: 
....................      TRUE - A valid packet is waiting and the stack applications should be 
....................         called to handle it. 
....................      FALSE - The packet was discarded. 
....................   ***************************************************************************/ 
.................... BOOL UDPProcess(NODE_INFO *remoteNode, IP_ADDR *localIP, WORD len) 
.................... { 
....................     UDP_HEADER      h; 
....................     UDP_SOCKET      s; 
....................     PSEUDO_HEADER   pseudoHeader; 
....................     DWORD_VAL      checksums; 
....................  
....................    UDPRxCount = 0; 
*
07376:  MOVLB  1
07378:  CLRF   x01
0737A:  CLRF   x00
....................  
....................     // Retrieve UDP header. 
....................     MACGetArray((BYTE*)&h, sizeof(h)); 
0737C:  MOVLW  02
0737E:  MOVLB  2
07380:  MOVWF  x6C
07382:  MOVLW  52
07384:  MOVWF  x6B
07386:  MOVFF  26C,2E4
0738A:  MOVWF  xE3
0738C:  CLRF   xE6
0738E:  MOVLW  08
07390:  MOVWF  xE5
07392:  MOVLB  0
07394:  CALL   0E8E
....................  
....................     h.SourcePort        = swaps(h.SourcePort); 
07398:  MOVFF  253,2E1
0739C:  MOVFF  252,2E0
073A0:  CALL   1874
073A4:  MOVFF  02,253
073A8:  MOVFF  01,252
....................     h.DestinationPort   = swaps(h.DestinationPort); 
073AC:  MOVFF  255,2E1
073B0:  MOVFF  254,2E0
073B4:  CALL   1874
073B8:  MOVFF  02,255
073BC:  MOVFF  01,254
....................     h.Length            = swaps(h.Length) - sizeof(UDP_HEADER); 
073C0:  MOVFF  257,2E1
073C4:  MOVFF  256,2E0
073C8:  CALL   1874
073CC:  MOVLW  08
073CE:  MOVLB  2
073D0:  SUBWF  01,W
073D2:  MOVWF  x56
073D4:  MOVLW  00
073D6:  SUBWFB 02,W
073D8:  MOVWF  x57
....................  
....................    // See if we need to validate the checksum field (0x0000 is disabled) 
....................    if(h.Checksum) 
073DA:  MOVF   x58,W
073DC:  IORWF  x59,W
073DE:  BZ    74A8
....................    { 
....................        // Calculate IP pseudoheader checksum. 
....................        pseudoHeader.SourceAddress      = remoteNode->IPAddr; 
073E0:  MOVFF  24C,FE9
073E4:  MOVFF  24D,FEA
073E8:  MOVFF  FEF,00
073EC:  MOVFF  FEC,01
073F0:  MOVFF  FEC,02
073F4:  MOVFF  FEC,03
073F8:  MOVFF  00,25B
073FC:  MOVFF  01,25C
07400:  MOVFF  02,25D
07404:  MOVFF  03,25E
....................        pseudoHeader.DestAddress.Val   = localIP->Val; 
07408:  MOVFF  24E,FE9
0740C:  MOVFF  24F,FEA
07410:  MOVFF  FEF,25F
07414:  MOVFF  FEC,260
07418:  MOVFF  FEC,261
0741C:  MOVFF  FEC,262
....................        pseudoHeader.Zero            = 0x0; 
07420:  CLRF   x63
....................        pseudoHeader.Protocol         = IP_PROT_UDP; 
07422:  MOVLW  11
07424:  MOVWF  x64
....................        pseudoHeader.Length            = len; 
07426:  MOVFF  251,266
0742A:  MOVFF  250,265
....................  
....................        SwapPseudoHeader(pseudoHeader); 
0742E:  MOVFF  266,2E1
07432:  MOVFF  265,2E0
07436:  MOVLB  0
07438:  CALL   1874
0743C:  MOVFF  02,266
07440:  MOVFF  01,265
....................     
....................        checksums.w[0] = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................                                        sizeof(pseudoHeader)); 
07444:  MOVLW  02
07446:  MOVLB  2
07448:  MOVWF  x6C
0744A:  MOVLW  5B
0744C:  MOVWF  x6B
0744E:  MOVFF  26C,2DD
07452:  MOVWF  xDC
07454:  CLRF   xDF
07456:  MOVLW  0C
07458:  MOVWF  xDE
0745A:  MOVLB  0
0745C:  CALL   1C28
07460:  MOVFF  01,267
07464:  MOVLB  2
07466:  COMF   x67,F
07468:  MOVFF  02,268
0746C:  COMF   x68,F
....................     
....................     
....................        // Now calculate UDP packet checksum in NIC RAM -- should match pseudoHeader 
....................        IPSetRxBuffer(0); 
0746E:  CLRF   x9C
07470:  CLRF   x9B
07472:  MOVLB  0
07474:  CALL   393C
....................        checksums.w[1] = CalcIPBufferChecksum(len); 
07478:  MOVFF  251,2C2
0747C:  MOVFF  250,2C1
07480:  CALL   1F9A
07484:  MOVFF  02,26A
07488:  MOVFF  01,269
....................     
....................        if(checksums.w[0] != checksums.w[1]) 
0748C:  MOVLB  2
0748E:  MOVF   x69,W
07490:  SUBWF  x67,W
07492:  BNZ   749A
07494:  MOVF   x6A,W
07496:  SUBWF  x68,W
07498:  BZ    74A8
....................        { 
....................            MACDiscardRx(); 
0749A:  MOVLB  0
0749C:  CALL   3A06
....................            return FALSE; 
074A0:  MOVLW  00
074A2:  MOVWF  01
074A4:  BRA    74F6
074A6:  MOVLB  2
....................        } 
....................    } 
....................  
....................     s = FindMatchingUDPSocket(&h, remoteNode, localIP); 
074A8:  MOVLW  02
074AA:  MOVWF  x6C
074AC:  MOVLW  52
074AE:  MOVWF  x6B
074B0:  MOVFF  24D,26E
074B4:  MOVFF  24C,26D
074B8:  MOVFF  24F,270
074BC:  MOVFF  24E,26F
074C0:  MOVLB  0
074C2:  BRA    71F0
074C4:  MOVFF  01,25A
....................     if(s == INVALID_UDP_SOCKET) 
074C8:  MOVLB  2
074CA:  INCFSZ x5A,W
074CC:  BRA    74DE
....................     { 
....................         // If there is no matching socket, There is no one to handle 
....................         // this data.  Discard it. 
....................         MACDiscardRx(); 
074CE:  MOVLB  0
074D0:  CALL   3A06
....................       return FALSE; 
074D4:  MOVLW  00
074D6:  MOVWF  01
074D8:  BRA    74F6
....................     } 
074DA:  BRA    74F2
074DC:  MOVLB  2
....................     else 
....................     { 
....................       SocketWithRxData = s; 
074DE:  MOVFF  25A,142
....................         UDPRxCount = h.Length; 
074E2:  MOVFF  257,101
074E6:  MOVFF  256,100
....................         Flags.bFirstRead = 1; 
074EA:  MOVLB  1
074EC:  BSF    x41.0
....................       Flags.bWasDiscarded = 0; 
074EE:  BCF    x41.1
074F0:  MOVLB  0
....................     } 
....................  
....................  
....................     return TRUE; 
074F2:  MOVLW  01
074F4:  MOVWF  01
074F6:  GOTO   765E (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static UDP_SOCKET FindMatchingUDPSocket(UDP_HEADER *h, NODE_INFO *remoteNode, 
....................                                            IP_ADDR *localIP) 
....................  
....................   Summary: 
....................    Matches an incoming UDP segment to a currently active socket. 
....................     
....................   Description: 
....................    This function attempts to match an incoming UDP segment to a currently 
....................    active socket for processing. 
....................  
....................   Precondition: 
....................    UDP segment header and IP header have both been retrieved. 
....................  
....................   Parameters: 
....................    h - The UDP header that was received. 
....................    remoteNode - IP and MAC of the remote node that sent this segment. 
....................    localIP - IP address that this segment was destined for. 
....................     
....................   Returns: 
....................      A UDP_SOCKET handle of a matching socket, or INVALID_UDP_SOCKET when no 
....................      match could be made. 
....................   ***************************************************************************/ 
.................... static UDP_SOCKET FindMatchingUDPSocket(UDP_HEADER *h, 
....................                                      NODE_INFO *remoteNode, 
....................                                      IP_ADDR *localIP) 
.................... { 
....................    UDP_SOCKET s; 
....................    UDP_SOCKET partialMatch; 
....................    UDP_SOCKET_INFO *p; 
....................  
.................... // This is commented out because most applications don't need this type of filtering.  It comes at a performance cost. 
.................... //   // Filter out unicast packets that aren't for our IP address, but accept  
.................... //   // all multicast and broadcast traffic 
.................... //   if(!((localIP->Val == AppConfig.MyIPAddr.Val) || (localIP->v[0] & 0x80) || (localIP->Val == (AppConfig.MyIPAddr.Val | (~AppConfig.MyMask.Val))))) 
.................... //      return INVALID_UDP_SOCKET; 
....................  
....................    // Discard any packets received that were generated by ourself.  In  
....................    // structured Wi-Fi networks, the Access Point rebroadcasts our broadcast  
....................    // and multicast packets, causing self-reception to occur unless filtered  
....................    // out. 
....................    if(remoteNode->IPAddr.Val == AppConfig.MyIPAddr.Val) 
*
071F0:  MOVLB  2
071F2:  MOVFF  26D,FE9
071F6:  MOVFF  26E,FEA
071FA:  MOVFF  FEF,275
071FE:  MOVFF  FEC,276
07202:  MOVFF  FEC,277
07206:  MOVFF  FEC,278
0720A:  MOVF   29,W
0720C:  SUBWF  x75,W
0720E:  BNZ   7228
07210:  MOVF   2A,W
07212:  SUBWF  x76,W
07214:  BNZ   7228
07216:  MOVF   2B,W
07218:  SUBWF  x77,W
0721A:  BNZ   7228
0721C:  MOVF   2C,W
0721E:  SUBWF  x78,W
07220:  BNZ   7228
....................       return INVALID_UDP_SOCKET; 
07222:  MOVLW  FF
07224:  MOVWF  01
07226:  BRA    7370
....................  
....................    partialMatch = INVALID_UDP_SOCKET; 
07228:  SETF   x72
....................  
....................    p = UDPSocketInfo; 
0722A:  CLRF   x74
0722C:  MOVLW  5D
0722E:  MOVWF  x73
....................     for(s = 0; s < MAX_UDP_SOCKETS; s++) 
07230:  CLRF   x71
07232:  MOVF   x71,W
07234:  SUBLW  06
07236:  BNC   72FA
....................    { 
....................       // This packet is said to be matching with current socket: 
....................       // 1. If its destination port matches with our local port and 
....................       // 2. Packet source IP address matches with previously saved socket remote IP address and 
....................       // 3. Packet source port number matches with previously saved socket remote port number 
....................       if(p->localPort == h->DestinationPort) 
07238:  MOVLW  0C
0723A:  ADDWF  x73,W
0723C:  MOVWF  FE9
0723E:  MOVLW  00
07240:  ADDWFC x74,W
07242:  MOVWF  FEA
07244:  MOVFF  FEC,276
07248:  MOVF   FED,F
0724A:  MOVFF  FEF,275
0724E:  MOVLW  02
07250:  ADDWF  x6B,W
07252:  MOVWF  FE9
07254:  MOVLW  00
07256:  ADDWFC x6C,W
07258:  MOVWF  FEA
0725A:  MOVFF  FEC,03
0725E:  MOVF   FED,F
07260:  MOVF   FEF,W
07262:  SUBWF  x75,W
07264:  BNZ   72EE
07266:  MOVF   03,W
07268:  SUBWF  x76,W
0726A:  BNZ   72EE
....................       { 
....................          if(p->remotePort == h->SourcePort) 
0726C:  MOVLW  0A
0726E:  ADDWF  x73,W
07270:  MOVWF  FE9
07272:  MOVLW  00
07274:  ADDWFC x74,W
07276:  MOVWF  FEA
07278:  MOVFF  FEC,276
0727C:  MOVF   FED,F
0727E:  MOVFF  FEF,275
07282:  MOVFF  26B,FE9
07286:  MOVFF  26C,FEA
0728A:  MOVFF  FEC,03
0728E:  MOVF   FED,F
07290:  MOVF   FEF,W
07292:  SUBWF  x75,W
07294:  BNZ   72EA
07296:  MOVF   03,W
07298:  SUBWF  x76,W
0729A:  BNZ   72EA
....................          { 
....................             if(p->remote.remoteNode.IPAddr.Val == remoteNode->IPAddr.Val) 
0729C:  MOVFF  273,FE9
072A0:  MOVFF  274,FEA
072A4:  MOVFF  FEF,275
072A8:  MOVFF  FEC,276
072AC:  MOVFF  FEC,277
072B0:  MOVFF  FEC,278
072B4:  MOVFF  26D,FE9
072B8:  MOVFF  26E,FEA
072BC:  MOVFF  FEF,00
072C0:  MOVFF  FEC,01
072C4:  MOVFF  FEC,02
072C8:  MOVFF  FEC,03
072CC:  MOVF   00,W
072CE:  SUBWF  x75,W
072D0:  BNZ   72EA
072D2:  MOVF   01,W
072D4:  SUBWF  x76,W
072D6:  BNZ   72EA
072D8:  MOVF   02,W
072DA:  SUBWF  x77,W
072DC:  BNZ   72EA
072DE:  MOVF   03,W
072E0:  SUBWF  x78,W
072E2:  BNZ   72EA
....................             { 
....................                return s; 
072E4:  MOVFF  271,01
072E8:  BRA    7370
....................             } 
....................          } 
....................  
....................          partialMatch = s; 
072EA:  MOVFF  271,272
....................       } 
....................       p++; 
072EE:  MOVLW  17
072F0:  ADDWF  x73,F
072F2:  BTFSC  FD8.0
072F4:  INCF   x74,F
072F6:  INCF   x71,F
072F8:  BRA    7232
....................    } 
....................  
....................    if(partialMatch != INVALID_UDP_SOCKET) 
072FA:  INCFSZ x72,W
072FC:  BRA    7300
072FE:  BRA    736C
....................    { 
....................       p = &UDPSocketInfo[partialMatch]; 
07300:  MOVF   x72,W
07302:  MULLW  17
07304:  MOVF   FF3,W
07306:  CLRF   03
07308:  ADDLW  5D
0730A:  MOVWF  01
0730C:  MOVLW  00
0730E:  ADDWFC 03,F
07310:  MOVFF  01,273
07314:  MOVFF  03,274
....................  
....................       memcpy((void*)&p->remote.remoteNode, 
....................             (const void*)remoteNode, sizeof(p->remote.remoteNode) ); 
07318:  MOVFF  274,03
0731C:  MOVFF  273,275
07320:  MOVFF  274,276
07324:  MOVFF  274,FEA
07328:  MOVFF  273,FE9
0732C:  MOVFF  26E,FE2
07330:  MOVFF  26D,FE1
07334:  MOVLW  0A
07336:  MOVWF  01
07338:  MOVFF  FE6,FEE
0733C:  DECFSZ 01,F
0733E:  BRA    7338
....................  
....................       p->remotePort = h->SourcePort; 
07340:  MOVLW  0A
07342:  ADDWF  x73,W
07344:  MOVWF  01
07346:  MOVLW  00
07348:  ADDWFC x74,W
0734A:  MOVFF  26B,FE9
0734E:  MOVFF  26C,FEA
07352:  MOVFF  FEC,03
07356:  MOVF   FED,F
07358:  MOVFF  FEF,277
0735C:  MOVWF  FEA
0735E:  MOVFF  01,FE9
07362:  MOVFF  03,FEC
07366:  MOVF   FED,F
07368:  MOVFF  277,FEF
....................    } 
....................  
....................    return partialMatch; 
0736C:  MOVFF  272,01
07370:  MOVLB  0
07372:  GOTO   74C4 (RETURN)
.................... } 
....................  
....................  
.................... #endif //#if defined(STACK_USE_UDP) 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) 
....................    #include "DHCP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_SERVER) 
....................    #include "DHCPs.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS_SERVER) 
....................    #include "DNSs.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
....................    #include "TCP.c" 
.................... /********************************************************************* 
....................  * 
....................  *   Transmission Control Protocol (TCP) Communications Layer 
....................  *  Module for Microchip TCP/IP Stack 
....................  *    -Provides reliable, handshaked transport of application stream  
....................  *    oriented data with flow control 
....................  *    -Reference: RFC 793 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCP.c 
....................  * Dependencies:    IP, Tick, Ethernet/WiFi (ENC28J60.c, ETH97J60.c,  
....................  *               ENCX24J600.c, or WFMac.c), ARP (optional),  
....................  *               DNS (optional) 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date       Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01     Original        (Rev 1.0) 
....................  * Howard Schlunder      12/11/06   Changed almost everything to  
....................  *                           better meet RFC 793. 
....................  * Darren Rook          04/14/11 Changed TCP_SOCKET_COUNT to use TCP_CONFIGURATION. 
....................  ********************************************************************/ 
.................... #define __TCP_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_TCP) 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Configuration Parameters 
....................   ***************************************************************************/ 
....................  
.................... // Starting port for client sockets 
.................... #define LOCAL_PORT_START_NUMBER (1024u) 
.................... // End port for client sockets 
.................... #define LOCAL_PORT_END_NUMBER   (5000u) 
....................  
.................... // For debugging only.  Normal applications should never enable these 
.................... //#define DEBUG_GENERATE_TX_LOSS      62257 
.................... //#define DEBUG_GENERATE_RX_LOSS      64225 
....................  
.................... // A lot of pointer dereference code can be removed if you  
.................... // locally copy TCBStubs to an absolute memory location. 
.................... // If you define TCP_OPTIMIZE_FOR_SIZE, local caching will  
.................... // occur and will substantially decrease the entire TCP ROM  
.................... // footprint (up to 35%).  If you leave TCP_OPTIMIZE_FOR_SIZE  
.................... // undefined, the local caching will be disabled.  On PIC18  
.................... // products, this will improve TCP performance/throughput by  
.................... // approximately 15%. 
.................... #define TCP_OPTIMIZE_FOR_SIZE 
....................  
.................... // For smallest size and best throughput, TCP_OPTIMIZE_FOR_SIZE  
.................... // should always be enabled on PIC24/dsPIC products.  On PIC32  
.................... // products there is very little difference and depnds on compiler  
.................... // optimization level 
.................... #if defined(__C30__) && !defined(TCP_OPTIMIZE_FOR_SIZE) 
....................    #define TCP_OPTIMIZE_FOR_SIZE 
.................... #elif defined(__C32__) && defined(TCP_OPTIMIZE_FOR_SIZE) 
....................    #undef TCP_OPTIMIZE_FOR_SIZE 
.................... #endif 
....................  
.................... // TCP Maximum Segment Size for TX.  The TX maximum segment size is actually  
.................... // govered by the remote node's MSS option advirtised during connection  
.................... // establishment.  However, if the remote node specifies an unhandlably large  
.................... // MSS (ex: > Ethernet MTU), this define sets a hard limit so that we don't  
.................... // cause any TX buffer overflows.  If the remote node does not advirtise a MSS  
.................... // option, all TX segments are fixed at 536 bytes maximum. 
.................... #define TCP_MAX_SEG_SIZE_TX         (1460u) 
....................  
.................... // TCP Maximum Segment Size for RX.  This value is advirtised during connection  
.................... // establishment and the remote node should obey it.  This should be set to 536  
.................... // to avoid IP layer fragmentation from causing packet loss.  However, raising  
.................... // its value can enhance performance at the (small) risk of introducing  
.................... // incompatibility with certain special remote nodes (ex: ones connected via a  
.................... // slow dial up modem). 
.................... #define TCP_MAX_SEG_SIZE_RX         (536u) 
....................  
.................... // TCP Timeout and retransmit numbers 
.................... #define TCP_START_TIMEOUT_VAL      ((DWORD)TICK_SECOND*1)   // Timeout to retransmit unacked data 
.................... #define TCP_DELAYED_ACK_TIMEOUT      ((DWORD)TICK_SECOND/10)   // Timeout for delayed-acknowledgement algorithm 
.................... #define TCP_FIN_WAIT_2_TIMEOUT      ((DWORD)TICK_SECOND*5)   // Timeout for FIN WAIT 2 state 
.................... #define TCP_KEEP_ALIVE_TIMEOUT      ((DWORD)TICK_SECOND*10)   // Timeout for keep-alive messages when no traffic is sent 
.................... #define TCP_CLOSE_WAIT_TIMEOUT      ((DWORD)TICK_SECOND/5)   // Timeout for the CLOSE_WAIT state 
.................... #define TCP_MAX_RETRIES             (5u)               // Maximum number of retransmission attempts 
.................... #define TCP_MAX_UNACKED_KEEP_ALIVES   (6u)               // Maximum number of keep-alive messages that can be sent without receiving a response before automatically closing the connection 
.................... #define TCP_MAX_SYN_RETRIES         (2u)   // Smaller than all other retries to reduce SYN flood DoS duration 
....................  
.................... #define TCP_AUTO_TRANSMIT_TIMEOUT_VAL   (TICK_SECOND/25ull)   // Timeout before automatically transmitting unflushed data 
.................... #define TCP_WINDOW_UPDATE_TIMEOUT_VAL   (TICK_SECOND/5ull)   // Timeout before automatically transmitting a window update due to a TCPGet() or TCPGetArray() function call 
....................  
.................... #define TCP_SYN_QUEUE_MAX_ENTRIES   (3u)                // Number of TCP RX SYN packets to save if they cannot be serviced immediately 
.................... #define TCP_SYN_QUEUE_TIMEOUT      ((DWORD)TICK_SECOND*3)   // Timeout for when SYN queue entries are deleted if unserviceable 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    TCP Header Data Types 
....................   ***************************************************************************/ 
....................  
.................... #define FIN     (0x01)      // FIN Flag as defined in RFC 
.................... #define SYN     (0x02)      // SYN Flag as defined in RFC 
.................... #define RST     (0x04)      // Reset Flag as defined in RFC 
.................... #define PSH     (0x08)      // Push Flag as defined in RFC 
.................... #define ACK     (0x10)      // Acknowledge Flag as defined in RFC 
.................... #define URG     (0x20)      // Urgent Flag as defined in RFC 
....................  
.................... // TCP Header Data Structure 
.................... typedef struct 
.................... { 
....................    WORD    SourcePort;      // Local port number 
....................    WORD    DestPort;      // Remote port number 
....................    DWORD   SeqNumber;      // Local sequence number 
....................    DWORD   AckNumber;      // Acknowledging remote sequence number 
....................  
....................    struct 
....................    { 
....................       unsigned char Reserved3      : 4; 
....................       unsigned char Val            : 4; 
....................    } DataOffset;         // Data offset flags nibble 
....................  
....................    union 
....................    { 
....................       struct 
....................       { 
....................          unsigned char flagFIN    : 1; 
....................          unsigned char flagSYN    : 1; 
....................          unsigned char flagRST    : 1; 
....................          unsigned char flagPSH    : 1; 
....................          unsigned char flagACK    : 1; 
....................          unsigned char flagURG    : 1; 
....................          unsigned char Reserved2  : 2; 
....................       } bits; 
....................       BYTE byte; 
....................    } Flags;            // TCP Flags as defined in RFC 
....................  
....................    WORD    Window;         // Local free RX buffer window 
....................    WORD    Checksum;      // Data payload checksum 
....................    WORD    UrgentPointer;   // Urgent pointer 
.................... } TCP_HEADER; 
....................  
.................... #define TCP_OPTIONS_END_OF_LIST     (0x00u)      // End of List TCP Option Flag 
.................... #define TCP_OPTIONS_NO_OP           (0x01u)      // No Op TCP Option 
.................... #define TCP_OPTIONS_MAX_SEG_SIZE    (0x02u)      // Maximum segment size TCP flag 
.................... typedef struct 
.................... { 
....................    BYTE        Kind;                     // Type of option 
....................    BYTE        Length;                     // Length 
....................    WORD_VAL    MaxSegSize;                  // Maximum segment size 
.................... } TCP_OPTIONS;                           // TCP Options data structure                      
....................  
.................... // Structure containing all the important elements of an incomming  
.................... // SYN packet in order to establish a connection at a future time  
.................... // if all sockets on the listening port are already connected to  
.................... // someone 
.................... typedef struct  
.................... { 
....................    NODE_INFO   niSourceAddress;// Remote IP address and MAC address 
....................    WORD      wSourcePort;   // Remote TCP port number that the response SYN needs to be sent to 
....................    DWORD      dwSourceSEQ;   // Remote TCP SEQuence number that must be ACKnowledged when we send our response SYN 
....................    WORD      wDestPort;      // Local TCP port which the original SYN was destined for 
....................    WORD      wTimestamp;      // Timer to expire old SYN packets that can't be serviced at all 
.................... } TCP_SYN_QUEUE; 
....................  
....................  
.................... #if defined(STACK_CLIENT_MODE) 
.................... static WORD NextPort __attribute__((persistent));   // Tracking variable for next local client port number 
.................... #endif 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    TCB Definitions 
....................   ***************************************************************************/ 
....................  
.................... // Determines the number of defined TCP sockets 
.................... //#define TCP_SOCKET_COUNT   (sizeof(TCPSocketInitializer)/sizeof(TCPSocketInitializer[0])) 
.................... #define TCP_SOCKET_COUNT   TCP_CONFIGURATION    //ccs changed 
....................  
.................... #if defined(HI_TECH_C) 
....................    // The initializer forces this large array out of the bss section  
....................    // so we can link correctly. 
....................    #pragma psect bigdata=TCB_uRAM_BIG 
....................    #pragma psect data=TCB_uRAM 
....................    static TCB_STUB TCBStubs[TCP_SOCKET_COUNT] = {'\0'};    
....................    #pragma psect data=ordinary_data_sect 
....................    #pragma psect bigdata=ordinary_data_sect_big 
.................... #else 
....................    // The TCB array is very large.  With the C18 compiler, one must  
....................    // modify the linker script to make an array that spans more than  
....................    // one memory bank.  To do this, make the necessary changes to your  
....................    // processor's linker script (.lkr).  Here is an example showing  
....................    // gpr11 and 128 bytes of gpr12 being combined into one 384 byte  
....................    // block used exclusively by the TCB_uRAM data section: 
....................    // ... 
....................    // //DATABANK   NAME=gpr11      START=0xB00          END=0xBFF 
....................    // //DATABANK   NAME=gpr12      START=0xC00          END=0xCFF 
....................    // DATABANK   NAME=gpr11b     START=0xB00          END=0xC7F           PROTECTED 
....................    // DATABANK   NAME=gpr12      START=0xC80          END=0xCFF 
....................    // ... 
....................    // SECTION    NAME=TCB_uRAM    RAM=gpr11b 
....................    // ... 
....................    #if defined(__18CXX) && !defined(HI_TECH_C)    
....................       #pragma udata TCB_uRAM 
....................    #endif 
....................    static TCB_STUB TCBStubs[TCP_SOCKET_COUNT]; 
....................    #if defined(__18CXX) && !defined(HI_TECH_C)    
....................       #pragma udata               // Return to any other RAM section 
....................    #endif 
.................... #endif 
....................  
.................... static TCB MyTCB;                           // Currently loaded TCB 
.................... static TCP_SOCKET hCurrentTCP = INVALID_SOCKET;      // Current TCP socket 
.................... #if TCP_SYN_QUEUE_MAX_ENTRIES 
....................    #if defined(__18CXX) && !defined(HI_TECH_C)    
....................       #pragma udata SYN_QUEUE_RAM_SECT 
....................    #endif 
....................    static TCP_SYN_QUEUE SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES];   // Array of saved incoming SYN requests that need to be serviced later 
....................    #if defined(__18CXX) && !defined(HI_TECH_C)    
....................       #pragma udata 
....................    #endif 
.................... #endif 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Function Prototypes 
....................   ***************************************************************************/ 
....................  
.................... static void TCPRAMCopy(PTR_BASE wDest, BYTE vDestType, PTR_BASE wSource, BYTE vSourceType, WORD wLength); 
....................  
.................... #if defined(__18CXX) 
....................    static void TCPRAMCopyROM(PTR_BASE wDest, BYTE wDestType, ROM BYTE* wSource, WORD wLength); 
.................... #else 
....................    #define TCPRAMCopyROM(a,b,c,d)   TCPRAMCopy(a,b,c,TCP_PIC_RAM,d) 
.................... #endif 
....................  
.................... static void SendTCP(BYTE vTCPFlags, BYTE vSendFlags); 
.................... static void HandleTCPSeg(TCP_HEADER* h, WORD len); 
.................... static BOOL FindMatchingTCPSocket(TCP_HEADER* h, NODE_INFO* remote); 
.................... static void SwapTCPHeader(TCP_HEADER* header); 
.................... static void CloseSocket(void); 
.................... static void SyncTCB(void); 
....................  
.................... #if defined(WF_CS_TRIS) 
.................... UINT16 WFGetTCBSize(void); 
.................... #endif 
....................  
.................... // Indicates if this packet is a retransmission (no reset) or a new packet (reset required) 
.................... #define SENDTCP_RESET_TIMERS   0x01 
.................... // Instead of transmitting normal data, a garbage octet is transmitted according to RFC 1122 section 4.2.3.6 
.................... #define SENDTCP_KEEP_ALIVE      0x02 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    TCB Optimization Configuration 
....................   ***************************************************************************/ 
....................  
.................... #if defined(TCP_OPTIMIZE_FOR_SIZE) 
....................    static TCB_STUB MyTCBStub; 
....................     
....................    // Flushes MyTCBStub cache and loads up the specified TCB_STUB. 
....................    // Does nothing on cache hit. 
....................    static void SyncTCBStub(TCP_SOCKET hTCP) 
....................    { 
....................       if(hCurrentTCP == hTCP) 
*
00CCA:  MOVLB  2
00CCC:  MOVF   x81,W
00CCE:  MOVLB  1
00CD0:  SUBWF  x8A,W
00CD2:  BNZ   0CD6
....................          return; 
00CD4:  BRA    0D68
....................     
....................       if(hCurrentTCP != INVALID_SOCKET) 
00CD6:  MOVF   x8A,W
00CD8:  SUBLW  FE
00CDA:  BZ    0D18
....................       { 
....................          // Save the current TCB stub 
....................          memcpy((void*)&TCBStubs[hCurrentTCP], (void*)&MyTCBStub, sizeof(MyTCBStub)); 
00CDC:  MOVF   x8A,W
00CDE:  MULLW  1C
00CE0:  MOVF   FF3,W
00CE2:  CLRF   03
00CE4:  ADDLW  47
00CE6:  MOVWF  01
00CE8:  MOVLW  01
00CEA:  ADDWFC 03,F
00CEC:  MOVFF  01,282
00CF0:  MOVLB  2
00CF2:  MOVFF  03,283
00CF6:  MOVLW  01
00CF8:  MOVWF  x85
00CFA:  MOVLW  C7
00CFC:  MOVFF  03,FEA
00D00:  MOVFF  01,FE9
00D04:  MOVFF  285,FE2
00D08:  MOVWF  FE1
00D0A:  MOVLW  1C
00D0C:  MOVWF  01
00D0E:  MOVFF  FE6,FEE
00D12:  DECFSZ 01,F
00D14:  BRA    0D0E
00D16:  MOVLB  1
....................       } 
....................     
....................       hCurrentTCP = hTCP; 
00D18:  MOVFF  281,18A
....................     
....................       if(hTCP == INVALID_SOCKET) 
00D1C:  MOVLB  2
00D1E:  MOVF   x81,W
00D20:  SUBLW  FE
00D22:  BNZ   0D2A
....................          return; 
00D24:  MOVLB  1
00D26:  BRA    0D68
00D28:  MOVLB  2
....................     
....................       // Load up the new TCB stub 
....................       memcpy((void*)&MyTCBStub, (void*)&TCBStubs[hTCP], sizeof(MyTCBStub)); 
00D2A:  MOVLW  01
00D2C:  MOVWF  x83
00D2E:  MOVLW  C7
00D30:  MOVWF  x82
00D32:  MOVF   x81,W
00D34:  MULLW  1C
00D36:  MOVF   FF3,W
00D38:  CLRF   03
00D3A:  ADDLW  47
00D3C:  MOVWF  01
00D3E:  MOVLW  01
00D40:  ADDWFC 03,F
00D42:  MOVFF  01,284
00D46:  MOVFF  03,285
00D4A:  MOVFF  283,FEA
00D4E:  MOVFF  282,FE9
00D52:  MOVFF  03,FE2
00D56:  MOVFF  01,FE1
00D5A:  MOVLW  1C
00D5C:  MOVWF  01
00D5E:  MOVFF  FE6,FEE
00D62:  DECFSZ 01,F
00D64:  BRA    0D5E
00D66:  MOVLB  1
00D68:  MOVLB  0
00D6A:  RETURN 0
....................    } 
.................... #else 
....................    // Flushes MyTCBStub cache and loads up the specified TCB_STUB. 
....................    // Does nothing on cache hit. 
....................    #define SyncTCBStub(a)   hCurrentTCP = (a) 
....................    // Alias to current TCP stub. 
....................    #define MyTCBStub      TCBStubs[hCurrentTCP] 
.................... #endif 
....................  
....................  
....................  
.................... // Flushes MyTCB cache and loads up the specified TCB. 
.................... // Does nothing on cache hit. 
.................... static void SyncTCB(void) 
.................... { 
....................    static TCP_SOCKET hLastTCB = INVALID_SOCKET; 
....................     
....................    if(hLastTCB == hCurrentTCP) 
*
012CE:  MOVLB  1
012D0:  MOVF   x8A,W
012D2:  SUBWF  xE3,W
012D4:  BNZ   12D8
....................       return; 
012D6:  BRA    13A2
....................  
....................    if(hLastTCB != INVALID_SOCKET) 
012D8:  MOVF   xE3,W
012DA:  SUBLW  FE
012DC:  BZ    135C
....................    { 
....................       // Save the current TCB 
....................       TCPRAMCopy(TCBStubs[hLastTCB].bufferTxStart - sizeof(MyTCB), TCBStubs[hLastTCB].vMemoryMedium, (PTR_BASE)&MyTCB, TCP_PIC_RAM, sizeof(MyTCB)); 
012DE:  MOVF   xE3,W
012E0:  MULLW  1C
012E2:  MOVF   FF3,W
012E4:  MOVLB  2
012E6:  CLRF   xC2
012E8:  MOVWF  xC1
012EA:  MOVLW  47
012EC:  ADDWF  xC1,W
012EE:  MOVWF  FE9
012F0:  MOVLW  01
012F2:  ADDWFC xC2,W
012F4:  MOVWF  FEA
012F6:  MOVFF  FEC,2C4
012FA:  MOVF   FED,F
012FC:  MOVFF  FEF,2C3
01300:  MOVLW  27
01302:  SUBWF  xC3,F
01304:  MOVLW  00
01306:  SUBWFB xC4,F
01308:  MOVLB  1
0130A:  MOVF   xE3,W
0130C:  MULLW  1C
0130E:  MOVF   FF3,W
01310:  MOVLB  2
01312:  CLRF   xC6
01314:  MOVWF  xC5
01316:  MOVLW  1B
01318:  ADDWF  xC5,W
0131A:  MOVWF  01
0131C:  MOVLW  00
0131E:  ADDWFC xC6,W
01320:  MOVWF  03
01322:  MOVF   01,W
01324:  ADDLW  47
01326:  MOVWF  FE9
01328:  MOVLW  01
0132A:  ADDWFC 03,W
0132C:  MOVWF  FEA
0132E:  MOVFF  FEF,2C5
01332:  MOVLW  01
01334:  MOVWF  xC7
01336:  MOVLW  63
01338:  MOVWF  xC6
0133A:  MOVFF  2C4,2C9
0133E:  MOVFF  2C3,2C8
01342:  MOVFF  2C5,2CA
01346:  MOVFF  2C7,2CC
0134A:  MOVWF  xCB
0134C:  MOVLW  01
0134E:  MOVWF  xCD
01350:  CLRF   xCF
01352:  MOVLW  27
01354:  MOVWF  xCE
01356:  MOVLB  0
01358:  RCALL  11E8
0135A:  MOVLB  1
....................    } 
....................  
....................    // Load up the new TCB 
....................    hLastTCB = hCurrentTCP; 
0135C:  MOVFF  18A,1E3
....................    TCPRAMCopy((PTR_BASE)&MyTCB, TCP_PIC_RAM, MyTCBStub.bufferTxStart - sizeof(MyTCB), MyTCBStub.vMemoryMedium, sizeof(MyTCB)); 
01360:  MOVLW  01
01362:  MOVLB  2
01364:  MOVWF  xC2
01366:  MOVLW  63
01368:  MOVWF  xC1
0136A:  MOVLW  27
0136C:  MOVLB  1
0136E:  SUBWF  xC7,W
01370:  MOVLB  2
01372:  MOVWF  xC3
01374:  MOVLW  00
01376:  MOVLB  1
01378:  SUBWFB xC8,W
0137A:  MOVLB  2
0137C:  MOVWF  xC4
0137E:  MOVFF  2C2,2C9
01382:  MOVFF  2C1,2C8
01386:  MOVLW  01
01388:  MOVWF  xCA
0138A:  MOVFF  2C4,2CC
0138E:  MOVFF  2C3,2CB
01392:  MOVFF  1E2,2CD
01396:  CLRF   xCF
01398:  MOVLW  27
0139A:  MOVWF  xCE
0139C:  MOVLB  0
0139E:  RCALL  11E8
013A0:  MOVLB  1
013A2:  MOVLB  0
013A4:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPInit(void) 
....................  
....................   Summary: 
....................    Initializes the TCP module. 
....................  
....................   Description: 
....................    Initializes the TCP module.  This function sets up the TCP buffers 
....................    in memory and initializes each socket to the CLOSED state.  If 
....................    insufficient memory was allocated for the TCP sockets, the function 
....................    will hang here to be captured by the debugger. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................      None 
....................       
....................   Remarks: 
....................    This function is called only one during lifetime of the application. 
....................   ***************************************************************************/ 
.................... void TCPInit(void) 
*
01478:  MOVLW  1D
0147A:  MOVLB  2
0147C:  MOVWF  x4E
0147E:  MOVLW  D6
01480:  MOVWF  x4D
.................... { 
....................    BYTE i; 
....................    BYTE vSocketsAllocated; 
....................    WORD wTXSize, wRXSize; 
....................    PTR_BASE ptrBaseAddress; 
....................    BYTE vMedium; 
....................    #if TCP_ETH_RAM_SIZE > 0 
....................    WORD wCurrentETHAddress = TCP_ETH_RAM_BASE_ADDRESS; 
....................    #endif 
....................    #if TCP_PIC_RAM_SIZE > 0 
....................    PTR_BASE ptrCurrentPICAddress = TCP_PIC_RAM_BASE_ADDRESS; 
....................    #endif 
....................    #if TCP_SPI_RAM_SIZE > 0 
....................    WORD wCurrentSPIAddress = TCP_SPI_RAM_BASE_ADDRESS; 
....................    #endif 
....................  
....................    #if defined(STACK_CLIENT_MODE) 
....................       // Initialize NextPort to a random value if it is zero (such as after  
....................       // reset on a PIC32 or PIC18 when the static memory initializer is  
....................       // used).  By starting with a random number, we decrease the risk of  
....................       // reusing a port number that was previously used if the user power  
....................       // cycles the device. 
....................       if(NextPort == 0u) 
01482:  MOVLB  1
01484:  MOVF   x45,F
01486:  BNZ   14AA
01488:  MOVF   x46,F
0148A:  BNZ   14AA
....................          NextPort = (((WORD)GenerateRandomDWORD()) & 0x07FFu) + LOCAL_PORT_START_NUMBER; 
0148C:  MOVLB  0
0148E:  CALL   067E
01492:  MOVFF  01,250
01496:  MOVLW  07
01498:  MOVLB  2
0149A:  ANDWF  x50,F
0149C:  MOVFF  00,145
014A0:  MOVLW  04
014A2:  MOVLB  2
014A4:  ADDWF  x50,W
014A6:  MOVLB  1
014A8:  MOVWF  x46
....................    #endif 
....................  
....................  
....................    // Mark all SYN Queue entries as invalid by zeroing the memory 
....................    #if TCP_SYN_QUEUE_MAX_ENTRIES 
....................       memset((void*)SYNQueue, 0x00, sizeof(SYNQueue)); 
014AA:  MOVLW  01
014AC:  MOVLB  2
014AE:  MOVWF  x50
014B0:  MOVLW  8B
014B2:  MOVWF  x4F
014B4:  MOVFF  250,FEA
014B8:  MOVWF  FE9
014BA:  CLRF   00
014BC:  CLRF   02
014BE:  MOVLW  3C
014C0:  MOVWF  01
014C2:  MOVLB  0
014C4:  CALL   0CB0
....................    #endif 
....................     
....................    // Allocate all socket FIFO addresses 
....................    vSocketsAllocated = 0; 
014C8:  MOVLB  2
014CA:  CLRF   x45
....................    for(i = 0; i < TCP_SOCKET_COUNT; i++) 
014CC:  CLRF   x44
014CE:  MOVF   x44,F
014D0:  BTFSS  FD8.2
014D2:  BRA    163C
....................    { 
....................       // Generate all needed sockets of each type (TCP_PURPOSE_*) 
....................       SyncTCBStub(i); 
014D4:  MOVFF  244,281
014D8:  MOVLB  0
014DA:  CALL   0CCA
....................     
....................       vMedium = TCPSocketInitializer[i].vMemoryMedium; 
014DE:  MOVLB  2
014E0:  MOVF   x44,W
014E2:  MULLW  06
014E4:  MOVF   FF3,W
014E6:  CLRF   x50
014E8:  MOVWF  x4F
014EA:  MOVLW  01
014EC:  ADDWF  x4F,W
014EE:  MOVWF  01
014F0:  MOVLW  00
014F2:  ADDWFC x50,W
014F4:  MOVWF  03
014F6:  MOVF   01,W
014F8:  ADDLW  23
014FA:  MOVWF  FE9
014FC:  MOVLW  00
014FE:  ADDWFC 03,W
01500:  MOVWF  FEA
01502:  MOVFF  FEF,24C
....................       wTXSize = TCPSocketInitializer[i].wTXBufferSize; 
01506:  MOVF   x44,W
01508:  MULLW  06
0150A:  MOVF   FF3,W
0150C:  CLRF   x50
0150E:  MOVWF  x4F
01510:  MOVLW  02
01512:  ADDWF  x4F,W
01514:  MOVWF  01
01516:  MOVLW  00
01518:  ADDWFC x50,W
0151A:  MOVWF  03
0151C:  MOVF   01,W
0151E:  ADDLW  23
01520:  MOVWF  FE9
01522:  MOVLW  00
01524:  ADDWFC 03,W
01526:  MOVWF  FEA
01528:  MOVFF  FEC,247
0152C:  MOVF   FED,F
0152E:  MOVFF  FEF,246
....................       wRXSize = TCPSocketInitializer[i].wRXBufferSize; 
01532:  MOVF   x44,W
01534:  MULLW  06
01536:  MOVF   FF3,W
01538:  CLRF   x50
0153A:  MOVWF  x4F
0153C:  MOVLW  04
0153E:  ADDWF  x4F,W
01540:  MOVWF  01
01542:  MOVLW  00
01544:  ADDWFC x50,W
01546:  MOVWF  03
01548:  MOVF   01,W
0154A:  ADDLW  23
0154C:  MOVWF  FE9
0154E:  MOVLW  00
01550:  ADDWFC 03,W
01552:  MOVWF  FEA
01554:  MOVFF  FEC,249
01558:  MOVF   FED,F
0155A:  MOVFF  FEF,248
....................     
....................       switch(vMedium) 
0155E:  MOVF   x4C,W
01560:  XORLW  00
01562:  MOVLB  0
01564:  BZ    1568
01566:  BRA    15B6
....................       { 
....................          #if TCP_ETH_RAM_SIZE > 0 
....................          case TCP_ETH_RAM: 
....................             ptrBaseAddress = wCurrentETHAddress; 
01568:  MOVFF  24E,24B
0156C:  MOVFF  24D,24A
....................             wCurrentETHAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1; 
01570:  MOVLW  27
01572:  MOVLB  2
01574:  ADDWF  x46,W
01576:  MOVWF  x4F
01578:  MOVLW  00
0157A:  ADDWFC x47,W
0157C:  MOVWF  x50
0157E:  MOVLW  01
01580:  ADDWF  x4F,F
01582:  MOVLW  00
01584:  ADDWFC x50,F
01586:  MOVF   x48,W
01588:  ADDWF  x4F,F
0158A:  MOVF   x49,W
0158C:  ADDWFC x50,F
0158E:  MOVLW  01
01590:  ADDWF  x4F,W
01592:  MOVWF  01
01594:  MOVLW  00
01596:  ADDWFC x50,W
01598:  MOVWF  03
0159A:  MOVF   01,W
0159C:  ADDWF  x4D,F
0159E:  MOVF   03,W
015A0:  ADDWFC x4E,F
....................             // Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us. 
....................             // If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in TCPIPConfig.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken. 
.................... #if defined(WF_CS_TRIS) 
....................             while(wCurrentETHAddress > TCP_ETH_RAM_BASE_ADDRESS + WFGetTCBSize()/*TCP_ETH_RAM_SIZE*/); 
.................... #else 
....................             while(wCurrentETHAddress > TCP_ETH_RAM_BASE_ADDRESS + TCP_ETH_RAM_SIZE); 
015A2:  MOVF   x4E,W
015A4:  SUBLW  1E
015A6:  BC    15B2
015A8:  XORLW  FF
015AA:  BNZ   15A2
015AC:  MOVF   x4D,W
015AE:  SUBLW  FC
015B0:  BNC   15A2
.................... #endif 
....................             break; 
015B2:  BRA    15BA
015B4:  MOVLB  0
....................          #endif 
....................              
....................          #if TCP_PIC_RAM_SIZE > 0 
....................          case TCP_PIC_RAM: 
....................             ptrBaseAddress = ptrCurrentPICAddress; 
....................             ptrCurrentPICAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1; 
....................             // Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us. 
....................             // If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in TCPIPConfig.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken. 
....................             while(ptrCurrentPICAddress > TCP_PIC_RAM_BASE_ADDRESS + TCP_PIC_RAM_SIZE); 
....................             break; 
....................          #endif 
....................              
....................          #if TCP_SPI_RAM_SIZE > 0 
....................          case TCP_SPI_RAM: 
....................             ptrBaseAddress = wCurrentSPIAddress; 
....................             wCurrentSPIAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1; 
....................             // Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us. 
....................             // If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in TCPIPConfig.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken. 
....................             while(wCurrentSPIAddress > TCP_SPI_RAM_BASE_ADDRESS + TCP_SPI_RAM_SIZE); 
....................             break; 
....................          #endif 
....................           
....................          default: 
....................             while(1); // Undefined allocation medium.  Go fix your TCPIPConfig.h TCP memory allocations. 
015B6:  BRA    15B6
015B8:  MOVLB  2
....................       } 
....................     
....................       MyTCBStub.vMemoryMedium = vMedium; 
015BA:  MOVFF  24C,1E2
....................       MyTCBStub.bufferTxStart   = ptrBaseAddress + sizeof(TCB); 
015BE:  MOVLW  27
015C0:  ADDWF  x4A,W
015C2:  MOVLB  1
015C4:  MOVWF  xC7
015C6:  MOVLW  00
015C8:  MOVLB  2
015CA:  ADDWFC x4B,W
015CC:  MOVLB  1
015CE:  MOVWF  xC8
....................       MyTCBStub.bufferRxStart   = MyTCBStub.bufferTxStart + wTXSize + 1; 
015D0:  MOVLB  2
015D2:  MOVF   x46,W
015D4:  MOVLB  1
015D6:  ADDWF  xC7,W
015D8:  MOVLB  2
015DA:  MOVWF  x4F
015DC:  MOVF   x47,W
015DE:  MOVLB  1
015E0:  ADDWFC xC8,W
015E2:  MOVLB  2
015E4:  MOVWF  x50
015E6:  MOVLW  01
015E8:  ADDWF  x4F,W
015EA:  MOVLB  1
015EC:  MOVWF  xC9
015EE:  MOVLW  00
015F0:  MOVLB  2
015F2:  ADDWFC x50,W
015F4:  MOVLB  1
015F6:  MOVWF  xCA
....................       MyTCBStub.bufferEnd      = MyTCBStub.bufferRxStart + wRXSize; 
015F8:  MOVLB  2
015FA:  MOVF   x48,W
015FC:  MOVLB  1
015FE:  ADDWF  xC9,W
01600:  MOVWF  xCB
01602:  MOVLB  2
01604:  MOVF   x49,W
01606:  MOVLB  1
01608:  ADDWFC xCA,W
0160A:  MOVWF  xCC
....................       MyTCBStub.smState      = TCP_CLOSED; 
0160C:  MOVLW  0D
0160E:  MOVWF  xDD
....................       MyTCBStub.Flags.bServer   = FALSE; 
01610:  BCF    xDE.3
....................       #if defined(STACK_USE_SSL) 
....................       MyTCBStub.sslStubID = SSL_INVALID_ID; 
....................       #endif       
....................  
....................       SyncTCB(); 
01612:  MOVLB  0
01614:  RCALL  12CE
....................       MyTCB.vSocketPurpose = TCPSocketInitializer[i].vSocketPurpose; 
01616:  MOVLB  2
01618:  MOVF   x44,W
0161A:  MULLW  06
0161C:  MOVF   FF3,W
0161E:  CLRF   x50
01620:  MOVWF  x4F
01622:  MOVLW  23
01624:  ADDWF  x4F,W
01626:  MOVWF  FE9
01628:  MOVLW  00
0162A:  ADDWFC x50,W
0162C:  MOVWF  FEA
0162E:  MOVFF  FEF,189
....................       CloseSocket(); 
01632:  MOVLB  0
01634:  RCALL  13A6
01636:  MOVLB  2
01638:  INCF   x44,F
0163A:  BRA    14CE
....................    } 
0163C:  MOVLB  0
0163E:  GOTO   1688 (RETURN)
.................... } 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Connection Management Functions 
....................   ***************************************************************************/ 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    TCP_SOCKET TCPOpen(DWORD dwRemoteHost, BYTE vRemoteHostType, WORD wPort, BYTE vSocketPurpose) 
....................      
....................   Summary: 
....................     Opens a TCP socket for listening or as a client. 
....................  
....................   Description: 
....................     Provides a unified method for opening TCP sockets. This function can 
....................     open both client and server sockets. For client sockets, it can accept 
....................     a host name string to query in DNS, an IP address as a string, an IP 
....................     address in binary form, or a previously resolved NODE_INFO structure 
....................     containing the remote IP address and associated MAC address. When a 
....................     host name or IP address only is provided, the TCP module will 
....................     internally perform the necessary DNS and/or ARP resolution steps before 
....................     reporting that the TCP socket is connected (via a call to 
....................     TCPISConnected returning TRUE). Server sockets ignore this destination 
....................     parameter and listen only on the indicated port. 
....................      
....................     The vSocketPurpose field allows sockets to be opened with varying 
....................     buffer size parameters and memory storage mediums. This field 
....................     corresponds to pre-defined sockets allocated in the 
....................     TCPSocketInitializer[] array in TCPIPConfig.h. The TCPIPConfig.h file 
....................     can be edited using the TCP/IP Configuration Wizard. 
....................      
....................     Sockets are statically allocated on boot, but can be claimed with this 
....................     \function and freed using TCPDisconnect or TCPClose (for client 
....................     sockets). Server sockets can be freed using TCPClose only (calls to 
....................     TCPDisconnect will return server sockets to the listening state, 
....................     allowing reuse). 
....................  
....................   Conditions: 
....................     TCP is initialized. 
....................  
....................   Input: 
....................     dwRemoteHost -     For client sockets only. Provide a pointer to a 
....................                        null\-terminated string of the remote host name (ex\: 
....................                        "www.microchip.com" or "192.168.1.123"), a literal 
....................                        destination IP address (ex\: 0x7B01A8C0 or an IP_ADDR 
....................                        data type), or a pointer to a NODE_INFO structure 
....................                        with the remote IP address and remote node or gateway 
....................                        MAC address specified. If a string is provided, note 
....................                        that it must be statically allocated in memory and 
....................                        cannot be modified or deallocated until 
....................                        TCPIsConnected returns TRUE.<p />This parameter is 
....................                        ignored for server sockets. 
....................     vRemoteHostType -  Any one of the following flags to identify the 
....................                        meaning of the dwRemoteHost parameter\: 
....................                        * TCP_OPEN_SERVER &#45; Open a server socket and 
....................                          ignore the dwRemoteHost parameter. 
....................                        * TCP_OPEN_RAM_HOST &#45; Open a client socket and 
....................                          connect it to a remote host who's name is stored as a 
....................                          null terminated string in a RAM array. Ex\: 
....................                          "www.microchip.com" or "192.168.0.123" (BYTE&#42; 
....................                          type) 
....................                        * TCP_OPEN_ROM_HOST &#45; Open a client socket and 
....................                          connect it to a remote host who's name is stored as a 
....................                          null terminated string in a literal string or ROM 
....................                          array. Ex\: "www.microchip.com" or "192.168.0.123" 
....................                          (ROM BYTE&#42; type) 
....................                        * TCP_OPEN_IP_ADDRESS &#45; Open a client socket and 
....................                          connect it to a remote IP address. Ex\: 0x7B01A8C0 
....................                          for 192.168.1.123 (DWORD type). Note that the byte 
....................                          ordering is big endian. 
....................                        * TCP_OPEN_NODE_INFO &#45; Open a client socket and 
....................                          connect it to a remote IP and MAC addresses pair 
....................                          stored in a NODE_INFO structure. dwRemoteHost must be 
....................                          a pointer to the NODE_INFO structure. This option is 
....................                          provided for backwards compatibility with 
....................                          applications built against prior stack versions that 
....................                          only implemented the TCPConnect() function. It can 
....................                          also be used to skip DNS and ARP resolution steps if 
....................                          connecting to a remote node which you've already 
....................                          connected to and have cached addresses for. 
....................     wPort -            TCP port to listen on or connect to\: 
....................                        * Client sockets &#45; the remote TCP port to which a 
....................                          connection should be made. The local port for client 
....................                          sockets will be automatically picked by the TCP 
....................                          module. 
....................                        * Server sockets &#45; the local TCP port on which to 
....................                          listen for connections. 
....................     vSocketPurpose -   Any of the TCP_PURPOSE_* constants defined in 
....................                        TCPIPConfig.h or the TCPIPConfig utility (see 
....................                        TCPSocketInitializer[] array). 
....................  
....................   Return Values: 
....................     INVALID_SOCKET -  No sockets of the specified type were available to be 
....................                       opened. 
....................     Otherwise -       A TCP_SOCKET handle. Save this handle and use it when 
....................                       calling all other TCP APIs. 
....................  
....................   Remarks: 
....................     This function replaces the old TCPConnect and TCPListen functions. 
....................      
....................     If TCP_OPEN_RAM_HOST or TCP_OPEN_ROM_HOST are used for the destination 
....................     type, the DNS client module must also be enabled (STACK_USE_DNS must be 
....................     defined in TCPIPConfig.h). 
....................  
....................   Example: 
....................     \ \  
....................     <code> 
....................     // Open a server socket 
....................     skt = TCPOpen(NULL, TCP_OPEN_SERVER, HTTP_PORT, TCP_PURPOSE_HTTP_SERVER); 
....................      
....................     // Open a client socket to www.microchip.com 
....................     // The double cast here prevents compiler warnings 
....................     skt = TCPOpen((DWORD)(PTR_BASE)"www.microchip.com", 
....................                     TCP_OPEN_ROM_HOST, 80, TCP_PURPOSE_DEFAULT); 
....................      
....................     // Reopen a client socket without repeating DNS or ARP 
....................     SOCKET_INFO cache = TCPGetSocketInfo(skt);  // Call with the old socket 
....................     skt = TCPOpen((DWORD)(PTR_BASE)&amp;cache.remote, TCP_OPEN_NODE_INFO, 
....................                     cache.remotePort.Val, TCP_PURPOSE_DEFAULT); 
....................     </code>                                                     
....................   *****************************************************************************/ 
.................... TCP_SOCKET TCPOpen(DWORD dwRemoteHost, BYTE vRemoteHostType, WORD wPort, BYTE vSocketPurpose) 
.................... { 
....................    TCP_SOCKET hTCP; 
....................  
....................    // Find an available socket that matches the specified socket type 
....................    for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++) 
*
076BE:  MOVLB  2
076C0:  CLRF   x51
076C2:  MOVF   x51,F
076C4:  BTFSS  FD8.2
076C6:  BRA    78B8
....................    { 
....................       SyncTCBStub(hTCP); 
076C8:  MOVFF  251,281
076CC:  MOVLB  0
076CE:  CALL   0CCA
....................  
....................       // Sockets that are in use will be in a non-closed state 
....................       if(MyTCBStub.smState != TCP_CLOSED) 
076D2:  MOVLB  1
076D4:  MOVF   xDD,W
076D6:  SUBLW  0D
076D8:  BZ    76DC
....................          continue; 
076DA:  BRA    78B2
....................  
....................       SyncTCB(); 
076DC:  MOVLB  0
076DE:  CALL   12CE
....................  
....................       // See if this socket matches the desired type 
....................       if(MyTCB.vSocketPurpose != vSocketPurpose) 
076E2:  MOVLB  2
076E4:  MOVF   x50,W
076E6:  MOVLB  1
076E8:  SUBWF  x89,W
076EA:  BZ    76EE
....................          continue; 
076EC:  BRA    78B2
....................  
....................       // Start out assuming worst case Maximum Segment Size (changes when MSS  
....................       // option is received from remote node) 
....................       MyTCB.wRemoteMSS = 536; 
076EE:  MOVLW  02
076F0:  MOVWF  x87
076F2:  MOVLW  18
076F4:  MOVWF  x86
....................  
....................       // See if this is a server socket 
....................       if(vRemoteHostType == TCP_OPEN_SERVER) 
076F6:  MOVLB  2
076F8:  MOVF   x4D,F
076FA:  BNZ   7718
....................       { 
....................          MyTCB.localPort.Val = wPort; 
076FC:  MOVFF  24F,174
07700:  MOVFF  24E,173
....................          MyTCBStub.Flags.bServer = TRUE; 
07704:  MOVLB  1
07706:  BSF    xDE.3
....................          MyTCBStub.smState = TCP_LISTEN; 
07708:  MOVLW  04
0770A:  MOVWF  xDD
....................          MyTCBStub.remoteHash.Val = wPort; 
0770C:  MOVFF  24F,1E1
07710:  MOVFF  24E,1E0
....................          #if defined(STACK_USE_SSL_SERVER) 
....................          MyTCB.localSSLPort.Val = 0; 
....................          #endif 
....................       } 
07714:  BRA    78A8
07716:  MOVLB  2
....................       // Handle all the client mode socket types 
....................       else 
....................       { 
....................          #if defined(STACK_CLIENT_MODE) 
....................          { 
....................             // Each new socket that is opened by this node, gets the  
....................             // next sequential local port number. 
....................             if(NextPort < LOCAL_PORT_START_NUMBER || NextPort > LOCAL_PORT_END_NUMBER) 
07718:  MOVLB  1
0771A:  MOVF   x46,W
0771C:  SUBLW  03
0771E:  BC    7730
07720:  MOVF   x46,W
07722:  SUBLW  12
07724:  BC    7736
07726:  XORLW  FF
07728:  BNZ   7730
0772A:  MOVF   x45,W
0772C:  SUBLW  88
0772E:  BC    7736
....................                NextPort = LOCAL_PORT_START_NUMBER; 
07730:  MOVLW  04
07732:  MOVWF  x46
07734:  CLRF   x45
....................              
....................             // Set the non-zero TCB fields 
....................             MyTCB.localPort.Val = NextPort++; 
07736:  MOVFF  146,03
0773A:  MOVF   x45,W
0773C:  INCF   x45,F
0773E:  BTFSC  FD8.2
07740:  INCF   x46,F
07742:  MOVWF  x73
07744:  MOVFF  03,174
....................             MyTCB.remotePort.Val = wPort; 
07748:  MOVFF  24F,172
0774C:  MOVFF  24E,171
....................     
....................             // Flag to start the DNS, ARP, SYN processes 
....................             MyTCBStub.eventTime = TickGet(); 
07750:  MOVLB  0
07752:  CALL   1734
07756:  MOVFF  03,1D8
0775A:  MOVFF  02,1D7
0775E:  MOVFF  01,1D6
07762:  MOVFF  00,1D5
....................             MyTCBStub.Flags.bTimerEnabled = 1; 
07766:  MOVLB  1
07768:  BSF    xDE.4
....................     
....................             switch(vRemoteHostType) 
0776A:  MOVLW  01
0776C:  MOVLB  2
0776E:  SUBWF  x4D,W
07770:  ADDLW  FC
07772:  BTFSC  FD8.0
07774:  BRA    78A6
07776:  ADDLW  04
07778:  MOVLB  0
0777A:  GOTO   78C2
....................             { 
....................                #if defined(STACK_USE_DNS) 
....................                case TCP_OPEN_RAM_HOST: 
....................                case TCP_OPEN_ROM_HOST: 
....................                   MyTCB.remote.dwRemoteHost = dwRemoteHost; 
0777E:  MOVFF  24C,17C
07782:  MOVFF  24B,17B
07786:  MOVFF  24A,17A
0778A:  MOVFF  249,179
....................                   MyTCB.flags.bRemoteHostIsROM = (vRemoteHostType == TCP_OPEN_ROM_HOST); 
0778E:  MOVLB  1
07790:  BCF    x85.2
07792:  MOVLB  2
07794:  MOVF   x4D,W
07796:  SUBLW  02
07798:  BNZ   77A0
0779A:  MOVLB  1
0779C:  BSF    x85.2
0779E:  MOVLB  2
....................                   MyTCBStub.smState = TCP_GET_DNS_MODULE; 
077A0:  MOVLB  1
077A2:  CLRF   xDD
....................                   break; 
077A4:  MOVLB  2
077A6:  BRA    78A6
....................                #endif 
....................        
....................                case TCP_OPEN_IP_ADDRESS: 
....................                   // dwRemoteHost is a literal IP address.  This  
....................                   // doesn't need DNS and can skip directly to the  
....................                   // Gateway ARPing step. 
....................                   MyTCBStub.remoteHash.Val = (((DWORD_VAL*)&dwRemoteHost)->w[1]+((DWORD_VAL*)&dwRemoteHost)->w[0] + wPort) ^ MyTCB.localPort.Val; 
077A8:  MOVLW  02
077AA:  MOVLB  2
077AC:  MOVWF  x53
077AE:  MOVLW  49
077B0:  MOVWF  x52
077B2:  MOVLW  02
077B4:  ADDWF  x52,W
077B6:  MOVWF  FE9
077B8:  MOVLW  00
077BA:  ADDWFC x53,W
077BC:  MOVWF  FEA
077BE:  MOVFF  FEC,255
077C2:  MOVF   FED,F
077C4:  MOVFF  FEF,254
077C8:  MOVLW  02
077CA:  MOVWF  x57
077CC:  MOVLW  49
077CE:  MOVWF  FE9
077D0:  MOVFF  257,FEA
077D4:  MOVFF  FEC,03
077D8:  MOVF   FED,F
077DA:  MOVF   FEF,W
077DC:  ADDWF  x54,F
077DE:  MOVF   03,W
077E0:  ADDWFC x55,F
077E2:  MOVF   x4E,W
077E4:  ADDWF  x54,F
077E6:  MOVF   x4F,W
077E8:  ADDWFC x55,F
077EA:  MOVF   x54,W
077EC:  MOVLB  1
077EE:  XORWF  x73,W
077F0:  MOVWF  xE0
077F2:  MOVLB  2
077F4:  MOVF   x55,W
077F6:  MOVLB  1
077F8:  XORWF  x74,W
077FA:  MOVWF  xE1
....................                   MyTCB.remote.niRemoteMACIP.IPAddr.Val = dwRemoteHost; 
077FC:  MOVFF  24C,17C
07800:  MOVFF  24B,17B
07804:  MOVFF  24A,17A
07808:  MOVFF  249,179
....................                   MyTCB.retryCount = 0; 
0780C:  CLRF   x88
....................                   MyTCB.retryInterval = (TICK_SECOND/4)/256; 
0780E:  CLRF   x66
07810:  CLRF   x65
07812:  CLRF   x64
07814:  MOVLW  26
07816:  MOVWF  x63
....................                   MyTCBStub.smState = TCP_GATEWAY_SEND_ARP; 
07818:  MOVLW  02
0781A:  MOVWF  xDD
....................                   break; 
0781C:  MOVLB  2
0781E:  BRA    78A6
....................        
....................                case TCP_OPEN_NODE_INFO: 
....................                   MyTCBStub.remoteHash.Val = (((NODE_INFO*)(PTR_BASE)dwRemoteHost)->IPAddr.w[1]+((NODE_INFO*)(PTR_BASE)dwRemoteHost)->IPAddr.w[0] + wPort) ^ MyTCB.localPort.Val; 
07820:  MOVLW  02
07822:  MOVLB  2
07824:  ADDWF  x49,W
07826:  MOVWF  FE9
07828:  MOVLW  00
0782A:  ADDWFC x4A,W
0782C:  MOVWF  FEA
0782E:  MOVFF  FEC,253
07832:  MOVF   FED,F
07834:  MOVFF  FEF,252
07838:  MOVFF  249,FE9
0783C:  MOVFF  24A,FEA
07840:  MOVFF  FEC,03
07844:  MOVF   FED,F
07846:  MOVF   FEF,W
07848:  ADDWF  x52,F
0784A:  MOVF   03,W
0784C:  ADDWFC x53,F
0784E:  MOVF   x4E,W
07850:  ADDWF  x52,F
07852:  MOVF   x4F,W
07854:  ADDWFC x53,F
07856:  MOVF   x52,W
07858:  MOVLB  1
0785A:  XORWF  x73,W
0785C:  MOVWF  xE0
0785E:  MOVLB  2
07860:  MOVF   x53,W
07862:  MOVLB  1
07864:  XORWF  x74,W
07866:  MOVWF  xE1
....................                   memcpy((void*)(BYTE*)&MyTCB.remote, (void*)(BYTE*)(PTR_BASE)dwRemoteHost, sizeof(NODE_INFO)); 
07868:  MOVLW  01
0786A:  MOVLB  2
0786C:  MOVWF  x53
0786E:  MOVLW  79
07870:  MOVFF  253,FEA
07874:  MOVWF  FE9
07876:  MOVFF  24A,FE2
0787A:  MOVFF  249,FE1
0787E:  MOVLW  0A
07880:  MOVWF  01
07882:  MOVFF  FE6,FEE
07886:  DECFSZ 01,F
07888:  BRA    7882
....................                   MyTCBStub.smState = TCP_SYN_SENT; 
0788A:  MOVLW  05
0788C:  MOVLB  1
0788E:  MOVWF  xDD
....................                   SendTCP(SYN, SENDTCP_RESET_TIMERS); 
07890:  MOVLW  02
07892:  MOVLB  2
07894:  MOVWF  x97
07896:  MOVLW  01
07898:  MOVWF  x98
0789A:  MOVLB  0
0789C:  CALL   231A
....................                   break; 
078A0:  MOVLB  2
078A2:  BRA    78A6
078A4:  MOVLB  2
078A6:  MOVLB  1
....................             } 
....................          }       
....................          #else 
....................          { 
....................             return INVALID_SOCKET; 
....................          }    
....................          #endif 
....................       } 
....................        
....................       return hTCP;       
078A8:  MOVLB  2
078AA:  MOVFF  251,01
078AE:  BRA    78BC
078B0:  MOVLB  1
078B2:  MOVLB  2
078B4:  INCF   x51,F
078B6:  BRA    76C2
....................    } 
....................  
....................    // If there is no socket available, return error. 
....................    return INVALID_SOCKET; 
078B8:  MOVLW  FE
078BA:  MOVWF  01
078BC:  MOVLB  0
078BE:  GOTO   7F66 (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPWasReset(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Self-clearing semaphore inidicating socket reset. 
....................  
....................   Description: 
....................    This function is a self-clearing semaphore indicating whether or not 
....................    a socket has been disconnected since the previous call.  This function 
....................    works for all possible disconnections: a call to TCPDisconnect, a FIN  
....................    from the remote node, or an acknowledgement timeout caused by the loss 
....................    of a network link.  It also returns TRUE after the first call to TCPInit. 
....................    Applications should use this function to reset their state machines. 
....................     
....................    This function was added due to the possibility of an error when relying 
....................    on TCPIsConnected returing FALSE to check for a condition requiring a 
....................    state machine reset.  If a socket is closed (due to a FIN ACK) and then 
....................    immediately reopened (due to a the arrival of a new SYN) in the same 
....................    cycle of the stack, calls to TCPIsConnected by the application will  
....................    never return FALSE even though the socket has been disconnected.  This  
....................    can cause errors for protocols such as HTTP in which a client will  
....................    immediately open a new connection upon closing of a prior one.  Relying 
....................    on this function instead allows applications to trap those conditions  
....................    and properly reset their internal state for the new connection. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Return Values: 
....................      TRUE - The socket has been disconnected since the previous call. 
....................      FALSE - The socket has not been disconnected since the previous call. 
....................   ***************************************************************************/ 
.................... BOOL TCPWasReset(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return TRUE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    if(MyTCBStub.Flags.bSocketReset) 
....................    { 
....................       MyTCBStub.Flags.bSocketReset = 0; 
....................       return TRUE; 
....................    }    
....................     
....................    return FALSE; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPIsConnected(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines if a socket has an established connection. 
....................  
....................   Description: 
....................    This function determines if a socket has an established connection to  
....................    a remote node.  Call this function after calling TCPOpen to determine  
....................    when the connection is set up and ready for use.  This function was  
....................    historically used to check for disconnections, but TCPWasReset is now a 
....................    more appropriate solution.  
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Return Values: 
....................      TRUE - The socket has an established connection to a remote node. 
....................      FALSE - The socket is not currently connected. 
....................  
....................   Remarks: 
....................    A socket is said to be connected only if it is in the TCP_ESTABLISHED 
....................    state.  Sockets in the process of opening or closing will return FALSE. 
....................   ***************************************************************************/ 
.................... BOOL TCPIsConnected(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
078EE:  MOVLB  2
078F0:  MOVF   x49,W
078F2:  SUBLW  00
078F4:  BC    78FC
....................     { 
....................         return FALSE; 
078F6:  MOVLW  00
078F8:  MOVWF  01
078FA:  BRA    7918
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
078FC:  MOVFF  249,281
07900:  MOVLB  0
07902:  CALL   0CCA
....................    return (MyTCBStub.smState == TCP_ESTABLISHED); 
07906:  MOVLB  1
07908:  MOVF   xDD,W
0790A:  SUBLW  07
0790C:  BZ    7912
0790E:  MOVLW  00
07910:  BRA    7914
07912:  MOVLW  01
07914:  MOVWF  01
07916:  MOVLB  2
07918:  MOVLB  0
0791A:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPDisconnect(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Disconnects an open socket. 
....................  
....................   Description: 
....................    This function closes a connection to a remote node by sending a FIN (if  
....................    currently connected). 
....................     
....................    The function can be called a second time to force a socket closed by  
....................    sending a RST packet.  This is useful when the application knows that  
....................    the remote node will not send an ACK (if it has crashed or lost its link), 
....................    or when the application needs to reuse the socket immediately regardless 
....................    of whether or not the remote node would like to transmit more data before 
....................    closing. 
....................     
....................    For client mode sockets, upon return, the hTCP handle is relinquished to  
....................    the TCP/IP stack and must no longer be used by the application (except for  
....................    an immediate subsequent call to TCPDisconnect() to force a RST  
....................    transmission, if needed).   
....................     
....................    For server mode sockets, upon return, the hTCP handle is NOT relinquished  
....................    to the TCP/IP stack.  After closing, the socket returns to the listening  
....................    state allowing future connection requests to be serviced.  This leaves the  
....................    hTCP handle in a valid state and must be retained for future operations on  
....................    the socket.  If you want to close the server and relinquish the socket back  
....................    to the TCP/IP stack, call the TCPClose() API instead of TCPDisconnect(). 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    hTCP - Handle of the socket to disconnect. 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    If the socket is using SSL, a CLOSE_NOTIFY record will be transmitted 
....................    first to allow the SSL session to be resumed at a later time. 
....................   ***************************************************************************/ 
.................... void TCPDisconnect(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
02964:  MOVLB  2
02966:  MOVF   x55,W
02968:  SUBLW  00
0296A:  BC    296E
....................     { 
....................         return; 
0296C:  BRA    2A56
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
0296E:  MOVFF  255,281
02972:  MOVLB  0
02974:  CALL   0CCA
....................  
....................    // Delete all data in the RX FIFO 
....................    // In this stack's API, the application TCP handle is  
....................    // immediately invalid after calling this function, so there  
....................    // is no longer any way to receive data from the TCP RX FIFO,  
....................    // even though the data is still there.  Leaving the data there  
....................    // could interfere with the remote node sending us a FIN if our 
....................    // RX window is zero 
....................    MyTCBStub.rxTail = MyTCBStub.rxHead; 
02978:  MOVFF  1D2,1D4
0297C:  MOVFF  1D1,1D3
....................  
....................    switch(MyTCBStub.smState) 
02980:  MOVLB  1
02982:  MOVF   xDD,W
02984:  XORLW  01
02986:  MOVLB  0
02988:  BZ    29B8
0298A:  XORLW  01
0298C:  BZ    29C0
0298E:  XORLW  02
02990:  BZ    29C0
02992:  XORLW  01
02994:  BZ    29C0
02996:  XORLW  06
02998:  BZ    29C0
0299A:  XORLW  03
0299C:  BZ    29C6
0299E:  XORLW  01
029A0:  BZ    29C6
029A2:  XORLW  0C
029A4:  BZ    2A00
029A6:  XORLW  05
029A8:  BZ    2A3A
029AA:  XORLW  06
029AC:  BZ    2A44
029AE:  XORLW  01
029B0:  BZ    2A44
029B2:  XORLW  05
029B4:  BZ    2A44
029B6:  BRA    2A44
....................    { 
....................       #if defined(STACK_CLIENT_MODE) && defined(STACK_USE_DNS) 
....................       case TCP_DNS_RESOLVE: 
....................          DNSEndUsage();   // Release the DNS module, since the user is aborting 
029B8:  RCALL  293A
....................          CloseSocket(); 
029BA:  CALL   13A6
....................          break; 
029BE:  BRA    2A54
....................       #endif 
....................  
....................       case TCP_GET_DNS_MODULE: 
....................       case TCP_GATEWAY_SEND_ARP: 
....................       case TCP_GATEWAY_GET_ARP: 
....................       case TCP_SYN_SENT: 
....................          CloseSocket(); 
029C0:  CALL   13A6
....................          break; 
029C4:  BRA    2A54
....................  
....................       case TCP_SYN_RECEIVED: 
....................       case TCP_ESTABLISHED: 
....................          #if defined(STACK_USE_SSL) 
....................          // When disconnecting SSL sockets, send a close_notify so we can resume later 
....................          if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................          { 
....................             // Flush pending data and send close_notify 
....................             SSLTxRecord(hTCP, MyTCBStub.sslStubID, SSL_APPLICATION); 
....................             SSLTxMessage(hTCP, MyTCBStub.sslStubID, SSL_ALERT_CLOSE_NOTIFY); 
....................          } 
....................          #endif 
....................  
....................          // Send the FIN.  This is done in a loop to ensure that if we have  
....................          // more data wating in the TX FIFO than can be sent in a single  
....................          // packet (due to the remote Max Segment Size packet size limit),  
....................          // we will keep generating more packets until either all data gets  
....................          // transmitted or the remote node's receive window fills up. 
....................          do 
....................          { 
....................             SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS); 
029C6:  MOVLW  11
029C8:  MOVLB  2
029CA:  MOVWF  x97
029CC:  MOVLW  01
029CE:  MOVWF  x98
029D0:  MOVLB  0
029D2:  RCALL  231A
....................             if(MyTCB.remoteWindow == 0u) 
029D4:  MOVLB  1
029D6:  MOVF   x75,F
029D8:  BNZ   29E0
029DA:  MOVF   x76,F
029DC:  BNZ   29E0
....................                break; 
029DE:  BRA    29F8
....................          } while(MyTCBStub.txHead != MyTCB.txUnackedTail); 
029E0:  MOVF   x6F,W
029E2:  SUBWF  xCD,W
029E4:  BTFSC  FD8.2
029E6:  BRA    29EC
029E8:  MOVLB  0
029EA:  BRA    29C6
029EC:  MOVF   x70,W
029EE:  SUBWF  xCE,W
029F0:  BTFSC  FD8.2
029F2:  BRA    29F8
029F4:  MOVLB  0
029F6:  BRA    29C6
....................           
....................          MyTCBStub.smState = TCP_FIN_WAIT_1; 
029F8:  MOVLW  08
029FA:  MOVWF  xDD
....................          break; 
029FC:  MOVLB  0
029FE:  BRA    2A54
....................  
....................       case TCP_CLOSE_WAIT: 
....................          // Send the FIN.  This is done in a loop to ensure that if we have  
....................          // more data wating in the TX FIFO than can be sent in a single  
....................          // packet (due to the remote Max Segment Size packet size limit),  
....................          // we will keep generating more packets until either all data gets  
....................          // transmitted or the remote node's receive window fills up. 
....................          do 
....................          { 
....................             SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS); 
02A00:  MOVLW  11
02A02:  MOVLB  2
02A04:  MOVWF  x97
02A06:  MOVLW  01
02A08:  MOVWF  x98
02A0A:  MOVLB  0
02A0C:  RCALL  231A
....................             if(MyTCB.remoteWindow == 0u) 
02A0E:  MOVLB  1
02A10:  MOVF   x75,F
02A12:  BNZ   2A1A
02A14:  MOVF   x76,F
02A16:  BNZ   2A1A
....................                break; 
02A18:  BRA    2A32
....................          } while(MyTCBStub.txHead != MyTCB.txUnackedTail); 
02A1A:  MOVF   x6F,W
02A1C:  SUBWF  xCD,W
02A1E:  BTFSC  FD8.2
02A20:  BRA    2A26
02A22:  MOVLB  0
02A24:  BRA    2A00
02A26:  MOVF   x70,W
02A28:  SUBWF  xCE,W
02A2A:  BTFSC  FD8.2
02A2C:  BRA    2A32
02A2E:  MOVLB  0
02A30:  BRA    2A00
....................  
....................          MyTCBStub.smState = TCP_LAST_ACK; 
02A32:  MOVLW  0C
02A34:  MOVWF  xDD
....................          break; 
02A36:  MOVLB  0
02A38:  BRA    2A54
....................           
....................       // These states are all already closed or don't need explicit disconnecting -- they will disconnect by themselves after a while 
....................       //case TCP_CLOSED: 
....................       //case TCP_LISTEN: 
....................       //case TCP_CLOSING: 
....................       //case TCP_TIME_WAIT: 
....................       //   return; 
....................  
....................       case TCP_CLOSED_BUT_RESERVED: 
....................          MyTCBStub.smState = TCP_CLOSED; 
02A3A:  MOVLW  0D
02A3C:  MOVLB  1
02A3E:  MOVWF  xDD
....................          break; 
02A40:  MOVLB  0
02A42:  BRA    2A54
....................  
....................       // These states will close themselves after some delay, however,  
....................       // this is handled so that the user can call TCPDisconnect()  
....................       // twice to immediately close a socket (using an RST) without  
....................       // having to get an ACK back from the remote node.  This is  
....................       // great for instance when the application determines that  
....................       // the remote node has been physically disconnected and  
....................       // already knows that no ACK will be returned.  Alternatively,  
....................       // if the application needs to immediately reuse the socket  
....................       // regardless of what the other node's state is in (half open). 
....................       case TCP_FIN_WAIT_1: 
....................       case TCP_FIN_WAIT_2: 
....................       case TCP_LAST_ACK: 
....................       default: 
....................          SendTCP(RST | ACK, 0); 
02A44:  MOVLW  14
02A46:  MOVLB  2
02A48:  MOVWF  x97
02A4A:  CLRF   x98
02A4C:  MOVLB  0
02A4E:  RCALL  231A
....................          CloseSocket(); 
02A50:  CALL   13A6
....................          break; 
02A54:  MOVLB  2
....................    } 
02A56:  MOVLB  0
02A58:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPClose(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Disconnects an open socket and destroys the socket handle, including server  
....................    mode socket handles. 
....................  
....................   Description: 
....................    Disconnects an open socket and destroys the socket handle, including server  
....................    mode socket handles.  This function performs identically to the  
....................    TCPDisconnect() function, except that both client and server mode socket  
....................    handles are relinquished to the TCP/IP stack upon return. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    hTCP - Handle to the socket to disconnect and close. 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... void TCPClose(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    MyTCBStub.Flags.bServer = FALSE; 
....................    TCPDisconnect(hTCP); 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    SOCKET_INFO* TCPGetRemoteInfo(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Obtains information about a currently open socket. 
....................  
....................   Description: 
....................    Returns the SOCKET_INFO structure associated with this socket.  This  
....................    contains the NODE_INFO structure with IP and MAC address (or gateway 
....................    MAC) and the remote port. 
....................  
....................   Precondition: 
....................    TCP is initialized and the socket is connected. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    The SOCKET_INFO structure associated with this socket.  This structure is  
....................    allocated statically by the function and is valid only until the next  
....................    time TCPGetRemoteInfo() is called. 
....................   ***************************************************************************/ 
.................... SOCKET_INFO* TCPGetRemoteInfo(TCP_SOCKET hTCP) 
.................... { 
....................    static SOCKET_INFO   RemoteInfo; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    SyncTCB(); 
....................    memcpy((void*)&RemoteInfo.remote, (void*)&MyTCB.remote, sizeof(NODE_INFO)); 
....................    RemoteInfo.remotePort.Val = MyTCB.remotePort.Val; 
....................  
....................    return &RemoteInfo; 
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Transmit Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPFlush(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Immediately transmits all pending TX data. 
....................  
....................   Description: 
....................    This function immediately transmits all pending TX data with a PSH  
....................    flag.  If this function is not called, data will automatically be sent 
....................    when either a) the TX buffer is half full or b) the  
....................    TCP_AUTO_TRANSMIT_TIMEOUT_VAL (default: 40ms) has elapsed. 
....................  
....................   Precondition: 
....................    TCP is initialized and the socket is connected. 
....................  
....................   Parameters: 
....................    hTCP - The socket whose data is to be transmitted. 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    SSL application data is automatically flushed, so this function has  
....................    no effect for SSL sockets. 
....................   ***************************************************************************/ 
.................... void TCPFlush(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
07C2A:  MOVLB  2
07C2C:  MOVF   x6B,W
07C2E:  SUBLW  00
07C30:  BC    7C34
....................     { 
....................         return; 
07C32:  BRA    7C64
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
07C34:  MOVFF  26B,281
07C38:  MOVLB  0
07C3A:  CALL   0CCA
....................    SyncTCB(); 
07C3E:  CALL   12CE
....................  
....................    // NOTE: Pending SSL data will NOT be transferred here 
....................  
....................    if(MyTCBStub.txHead != MyTCB.txUnackedTail) 
07C42:  MOVLB  1
07C44:  MOVF   x6F,W
07C46:  SUBWF  xCD,W
07C48:  BNZ   7C50
07C4A:  MOVF   x70,W
07C4C:  SUBWF  xCE,W
07C4E:  BZ    7C62
....................    { 
....................       // Send the TCP segment with all unacked bytes 
....................       SendTCP(ACK, SENDTCP_RESET_TIMERS); 
07C50:  MOVLW  10
07C52:  MOVLB  2
07C54:  MOVWF  x97
07C56:  MOVLW  01
07C58:  MOVWF  x98
07C5A:  MOVLB  0
07C5C:  CALL   231A
07C60:  MOVLB  1
07C62:  MOVLB  2
....................    } 
07C64:  MOVLB  0
07C66:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPIsPutReady(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines how much free space is available in the TCP TX buffer. 
....................  
....................   Description: 
....................    Call this function to determine how many bytes can be written to the  
....................    TCP TX buffer.  If this function returns zero, the application must  
....................    return to the main stack loop before continuing in order to transmit 
....................    more data. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    The number of bytes available to be written in the TCP TX buffer. 
....................   ***************************************************************************/ 
.................... WORD TCPIsPutReady(TCP_SOCKET hTCP) 
.................... { 
....................    BYTE i; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
07A4C:  MOVLB  2
07A4E:  MOVF   x6B,W
07A50:  SUBLW  00
07A52:  BC    7A5C
....................     { 
....................         return 0; 
07A54:  MOVLW  00
07A56:  MOVWF  01
07A58:  MOVWF  02
07A5A:  BRA    7AF6
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
07A5C:  MOVFF  26B,281
07A60:  MOVLB  0
07A62:  CALL   0CCA
....................  
....................    i = MyTCBStub.smState; 
07A66:  MOVFF  1DD,26C
....................  
....................    // Unconnected sockets shouldn't be transmitting anything. 
....................    if(!( (i == (BYTE)TCP_ESTABLISHED) || (i == (BYTE)TCP_CLOSE_WAIT) )) 
07A6A:  MOVLB  2
07A6C:  MOVF   x6C,W
07A6E:  SUBLW  07
07A70:  BZ    7A80
07A72:  MOVF   x6C,W
07A74:  SUBLW  0B
07A76:  BZ    7A80
....................       return 0; 
07A78:  MOVLW  00
07A7A:  MOVWF  01
07A7C:  MOVWF  02
07A7E:  BRA    7AF6
....................  
....................    // Calculate the free space in this socket's TX FIFO 
....................    #if defined(STACK_USE_SSL) 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    {// Use sslTxHead as the head pointer when SSL is active 
....................       WORD rem; 
....................        
....................       // Find out raw free space 
....................       if(MyTCBStub.sslTxHead >= MyTCBStub.txTail) 
....................          rem = (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.sslTxHead - MyTCBStub.txTail); 
....................       else 
....................          rem = MyTCBStub.txTail - MyTCBStub.sslTxHead - 1; 
....................           
....................       // Reserve space for a new MAC and header 
....................       if(rem > 22u) 
....................          return rem - 22; 
....................       else 
....................          return 0; 
....................    } 
....................    #endif 
....................     
....................    if(MyTCBStub.txHead >= MyTCBStub.txTail) 
07A80:  MOVLB  1
07A82:  MOVF   xD0,W
07A84:  SUBWF  xCE,W
07A86:  BNC   7AD2
07A88:  BNZ   7A90
07A8A:  MOVF   xCF,W
07A8C:  SUBWF  xCD,W
07A8E:  BNC   7AD2
....................       return (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.txHead - MyTCBStub.txTail); 
07A90:  MOVF   xC7,W
07A92:  SUBWF  xC9,W
07A94:  MOVLB  2
07A96:  MOVWF  x6D
07A98:  MOVLB  1
07A9A:  MOVF   xC8,W
07A9C:  SUBWFB xCA,W
07A9E:  MOVLB  2
07AA0:  MOVWF  x6E
07AA2:  MOVLW  01
07AA4:  SUBWF  x6D,F
07AA6:  MOVLW  00
07AA8:  SUBWFB x6E,F
07AAA:  MOVLB  1
07AAC:  MOVF   xCF,W
07AAE:  SUBWF  xCD,W
07AB0:  MOVWF  00
07AB2:  MOVF   xD0,W
07AB4:  SUBWFB xCE,W
07AB6:  MOVWF  03
07AB8:  MOVF   00,W
07ABA:  MOVLB  2
07ABC:  SUBWF  x6D,W
07ABE:  MOVWF  00
07AC0:  MOVF   03,W
07AC2:  SUBWFB x6E,W
07AC4:  MOVWF  03
07AC6:  MOVFF  00,01
07ACA:  MOVWF  02
07ACC:  BRA    7AF6
07ACE:  BRA    7AF6
07AD0:  MOVLB  1
....................    else 
....................       return MyTCBStub.txTail - MyTCBStub.txHead - 1; 
07AD2:  MOVF   xCD,W
07AD4:  SUBWF  xCF,W
07AD6:  MOVLB  2
07AD8:  MOVWF  x6D
07ADA:  MOVLB  1
07ADC:  MOVF   xCE,W
07ADE:  SUBWFB xD0,W
07AE0:  MOVLB  2
07AE2:  MOVWF  x6E
07AE4:  MOVLW  01
07AE6:  SUBWF  x6D,W
07AE8:  MOVWF  00
07AEA:  MOVLW  00
07AEC:  SUBWFB x6E,W
07AEE:  MOVWF  03
07AF0:  MOVFF  00,01
07AF4:  MOVWF  02
07AF6:  MOVLB  0
07AF8:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPPut(TCP_SOCKET hTCP, BYTE byte) 
....................  
....................   Description: 
....................    Writes a single byte to a TCP socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    byte - The byte to write. 
....................  
....................   Return Values: 
....................    TRUE - The byte was written to the transmit buffer. 
....................    FALSE - The transmit buffer was full, or the socket is not connected. 
....................   ***************************************************************************/ 
.................... BOOL TCPPut(TCP_SOCKET hTCP, BYTE byte) 
.................... { 
....................    WORD wFreeTXSpace; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    wFreeTXSpace = TCPIsPutReady(hTCP); 
....................    if(wFreeTXSpace == 0u) 
....................       return FALSE; 
....................    else if(wFreeTXSpace == 1u) // About to run out of space, lets transmit so the remote node might send an ACK back faster 
....................       TCPFlush(hTCP);    
....................  
....................    // Send all current bytes if we are crossing half full 
....................    // This is required to improve performance with the delayed  
....................    // acknowledgement algorithm 
....................    if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1))) 
....................    { 
....................       TCPFlush(hTCP);    
....................       MyTCBStub.Flags.bHalfFullFlush = TRUE; 
....................    } 
....................  
....................    #if defined(STACK_USE_SSL) 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    { 
....................       TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte)); 
....................       if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    else 
....................    { 
....................       TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte)); 
....................       if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    #else 
....................    TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte)); 
....................    if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart) 
....................       MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................    #endif 
....................     
....................  
....................    // Send the last byte as a separate packet (likely will make the remote node send back ACK faster) 
....................    if(wFreeTXSpace == 1u) 
....................    { 
....................       TCPFlush(hTCP); 
....................    } 
....................    // If not already enabled, start a timer so this data will  
....................    // eventually get sent even if the application doens't call 
....................    // TCPFlush() 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull; 
....................    } 
....................  
....................    return TRUE; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPPutArray(TCP_SOCKET hTCP, BYTE* data, WORD len) 
....................  
....................   Description: 
....................    Writes an array from RAM to a TCP socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    data - Pointer to the array to be written. 
....................    len  - Number of bytes to be written. 
....................  
....................   Returns: 
....................    The number of bytes written to the socket.  If less than len, the 
....................    buffer became full or the socket is not conected. 
....................   ***************************************************************************/ 
.................... WORD TCPPutArray(TCP_SOCKET hTCP, BYTE* data, WORD len) 
*
07C68:  MOVLB  2
07C6A:  CLRF   x6A
07C6C:  CLRF   x69
.................... { 
....................    WORD wActualLen; 
....................    WORD wFreeTXSpace; 
....................    WORD wRightLen = 0; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
07C6E:  MOVF   x60,W
07C70:  SUBLW  00
07C72:  BC    7C7C
....................     { 
....................         return 0; 
07C74:  MOVLW  00
07C76:  MOVWF  01
07C78:  MOVWF  02
07C7A:  BRA    7E1C
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
07C7C:  MOVFF  260,281
07C80:  MOVLB  0
07C82:  CALL   0CCA
....................  
....................    wFreeTXSpace = TCPIsPutReady(hTCP); 
07C86:  MOVFF  260,26B
07C8A:  RCALL  7A4C
07C8C:  MOVFF  02,268
07C90:  MOVFF  01,267
....................    if(wFreeTXSpace == 0u) 
07C94:  MOVLB  2
07C96:  MOVF   x67,F
07C98:  BNZ   7CB0
07C9A:  MOVF   x68,F
07C9C:  BNZ   7CB0
....................    { 
....................       TCPFlush(hTCP); 
07C9E:  MOVFF  260,26B
07CA2:  MOVLB  0
07CA4:  RCALL  7C2A
....................       return 0; 
07CA6:  MOVLW  00
07CA8:  MOVWF  01
07CAA:  MOVWF  02
07CAC:  MOVLB  2
07CAE:  BRA    7E1C
....................    } 
....................  
....................    wActualLen = wFreeTXSpace; 
07CB0:  MOVFF  268,266
07CB4:  MOVFF  267,265
....................    if(wFreeTXSpace > len) 
07CB8:  MOVF   x64,W
07CBA:  SUBWF  x68,W
07CBC:  BNC   7CCE
07CBE:  BNZ   7CC6
07CC0:  MOVF   x67,W
07CC2:  SUBWF  x63,W
07CC4:  BC    7CCE
....................       wActualLen = len; 
07CC6:  MOVFF  264,266
07CCA:  MOVFF  263,265
....................  
....................    // Send all current bytes if we are crossing half full 
....................    // This is required to improve performance with the delayed  
....................    // acknowledgement algorithm 
....................    if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1))) 
07CCE:  MOVLB  1
07CD0:  BTFSC  xDF.0
07CD2:  BRA    7D18
07CD4:  MOVF   xC7,W
07CD6:  SUBWF  xC9,W
07CD8:  MOVLB  2
07CDA:  MOVWF  x6B
07CDC:  MOVLB  1
07CDE:  MOVF   xC8,W
07CE0:  SUBWFB xCA,W
07CE2:  MOVLB  2
07CE4:  MOVWF  x6C
07CE6:  BCF    FD8.0
07CE8:  RRCF   x6C,W
07CEA:  MOVWF  03
07CEC:  RRCF   x6B,W
07CEE:  MOVWF  02
07CF0:  MOVWF  01
07CF2:  MOVF   x68,W
07CF4:  SUBWF  03,W
07CF6:  BTFSC  FD8.0
07CF8:  BRA    7CFE
07CFA:  MOVLB  1
07CFC:  BRA    7D18
07CFE:  BNZ   7D0C
07D00:  MOVF   x67,W
07D02:  SUBWF  01,W
07D04:  BTFSC  FD8.0
07D06:  BRA    7D0C
07D08:  MOVLB  1
07D0A:  BRA    7D18
....................    { 
....................       TCPFlush(hTCP);    
07D0C:  MOVFF  260,26B
07D10:  MOVLB  0
07D12:  RCALL  7C2A
....................       MyTCBStub.Flags.bHalfFullFlush = TRUE; 
07D14:  MOVLB  1
07D16:  BSF    xDF.0
....................    } 
....................     
....................    #if defined(STACK_USE_SSL) 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    { 
....................       // See if we need a two part put 
....................       if(MyTCBStub.sslTxHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................       { 
....................          wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead; 
....................          TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen); 
....................          data += wRightLen; 
....................          wActualLen -= wRightLen; 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................       } 
....................     
....................       TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen); 
....................       MyTCBStub.sslTxHead += wActualLen; 
....................    } 
....................    else 
....................    { 
....................       // See if we need a two part put 
....................       if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................       { 
....................          wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead; 
....................          TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen); 
....................          data += wRightLen; 
....................          wActualLen -= wRightLen; 
....................          MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................       } 
....................     
....................       TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen); 
....................       MyTCBStub.txHead += wActualLen; 
....................    } 
....................    #else 
....................    // See if we need a two part put 
....................    if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart) 
07D18:  MOVLB  2
07D1A:  MOVF   x65,W
07D1C:  MOVLB  1
07D1E:  ADDWF  xCD,W
07D20:  MOVLB  2
07D22:  MOVWF  x6B
07D24:  MOVF   x66,W
07D26:  MOVLB  1
07D28:  ADDWFC xCE,W
07D2A:  MOVLB  2
07D2C:  MOVWF  x6C
07D2E:  MOVLB  1
07D30:  MOVF   xCA,W
07D32:  MOVLB  2
07D34:  SUBWF  x6C,W
07D36:  BNC   7D98
07D38:  BNZ   7D44
07D3A:  MOVLB  1
07D3C:  MOVF   xC9,W
07D3E:  MOVLB  2
07D40:  SUBWF  x6B,W
07D42:  BNC   7D98
....................    { 
....................       wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead; 
07D44:  MOVLB  1
07D46:  MOVF   xCD,W
07D48:  SUBWF  xC9,W
07D4A:  MOVLB  2
07D4C:  MOVWF  x69
07D4E:  MOVLB  1
07D50:  MOVF   xCE,W
07D52:  SUBWFB xCA,W
07D54:  MOVLB  2
07D56:  MOVWF  x6A
....................       TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen); 
07D58:  MOVFF  1CE,2C9
07D5C:  MOVFF  1CD,2C8
07D60:  MOVFF  1E2,2CA
07D64:  MOVFF  262,2CC
07D68:  MOVFF  261,2CB
07D6C:  MOVLW  01
07D6E:  MOVWF  xCD
07D70:  MOVFF  26A,2CF
07D74:  MOVFF  269,2CE
07D78:  MOVLB  0
07D7A:  CALL   11E8
....................       data += wRightLen; 
07D7E:  MOVLB  2
07D80:  MOVF   x69,W
07D82:  ADDWF  x61,F
07D84:  MOVF   x6A,W
07D86:  ADDWFC x62,F
....................       wActualLen -= wRightLen; 
07D88:  MOVF   x69,W
07D8A:  SUBWF  x65,F
07D8C:  MOVF   x6A,W
07D8E:  SUBWFB x66,F
....................       MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
07D90:  MOVFF  1C8,1CE
07D94:  MOVFF  1C7,1CD
....................    } 
....................  
....................    TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen); 
07D98:  MOVFF  1CE,2C9
07D9C:  MOVFF  1CD,2C8
07DA0:  MOVFF  1E2,2CA
07DA4:  MOVFF  262,2CC
07DA8:  MOVFF  261,2CB
07DAC:  MOVLW  01
07DAE:  MOVWF  xCD
07DB0:  MOVFF  266,2CF
07DB4:  MOVFF  265,2CE
07DB8:  MOVLB  0
07DBA:  CALL   11E8
....................    MyTCBStub.txHead += wActualLen; 
07DBE:  MOVLB  2
07DC0:  MOVF   x65,W
07DC2:  MOVLB  1
07DC4:  ADDWF  xCD,F
07DC6:  MOVLB  2
07DC8:  MOVF   x66,W
07DCA:  MOVLB  1
07DCC:  ADDWFC xCE,F
....................    #endif 
....................  
....................    // Send these bytes right now if we are out of TX buffer space 
....................    if(wFreeTXSpace <= len) 
07DCE:  MOVLB  2
07DD0:  MOVF   x68,W
07DD2:  SUBWF  x64,W
07DD4:  BNC   7DE8
07DD6:  BNZ   7DDE
07DD8:  MOVF   x67,W
07DDA:  SUBWF  x63,W
07DDC:  BNC   7DE8
....................    { 
....................       TCPFlush(hTCP); 
07DDE:  MOVFF  260,26B
07DE2:  MOVLB  0
07DE4:  RCALL  7C2A
....................    } 
07DE6:  BRA    7E0C
....................    // If not already enabled, start a timer so this data will  
....................    // eventually get sent even if the application doens't call 
....................    // TCPFlush() 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
07DE8:  MOVLB  1
07DEA:  BTFSC  xDE.5
07DEC:  BRA    7E0A
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
07DEE:  BSF    xDE.5
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull; 
07DF0:  MOVLB  0
07DF2:  CALL   16EE
07DF6:  MOVLW  06
07DF8:  MOVLB  2
07DFA:  ADDWF  00,W
07DFC:  MOVLB  1
07DFE:  MOVWF  xD9
07E00:  MOVLW  00
07E02:  MOVLB  2
07E04:  ADDWFC 01,W
07E06:  MOVLB  1
07E08:  MOVWF  xDA
07E0A:  MOVLB  0
....................    } 
....................  
....................    return wActualLen + wRightLen; 
07E0C:  MOVLB  2
07E0E:  MOVF   x69,W
07E10:  ADDWF  x65,W
07E12:  MOVWF  01
07E14:  MOVF   x6A,W
07E16:  ADDWFC x66,W
07E18:  MOVWF  03
07E1A:  MOVWF  02
07E1C:  MOVLB  0
07E1E:  GOTO   7EE2 (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPPutROMArray(TCP_SOCKET hTCP, ROM BYTE* data, WORD len) 
....................  
....................   Description: 
....................    Writes an array from ROM to a TCP socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    data - Pointer to the array to be written. 
....................    len  - Number of bytes to be written. 
....................  
....................   Returns: 
....................    The number of bytes written to the socket.  If less than len, the 
....................    buffer became full or the socket is not conected. 
....................  
....................   Remarks: 
....................    This function is aliased to TCPPutArray on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... WORD TCPPutROMArray(TCP_SOCKET hTCP, ROM BYTE* data, WORD len) 
.................... { 
....................    WORD wActualLen; 
....................    WORD wFreeTXSpace; 
....................    WORD wRightLen = 0; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    wFreeTXSpace = TCPIsPutReady(hTCP); 
....................    if(wFreeTXSpace == 0u) 
....................    { 
....................       TCPFlush(hTCP); 
....................       return 0; 
....................    } 
....................  
....................    // Send all current bytes if we are crossing half full 
....................    // This is required to improve performance with the delayed  
....................    // acknowledgement algorithm 
....................    if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1))) 
....................    { 
....................       TCPFlush(hTCP);    
....................       MyTCBStub.Flags.bHalfFullFlush = TRUE; 
....................    } 
....................     
....................    wActualLen = wFreeTXSpace; 
....................    if(wFreeTXSpace > len) 
....................       wActualLen = len; 
....................     
....................    #if defined(STACK_USE_SSL) 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    { 
....................       // See if we need a two part put 
....................       if(MyTCBStub.sslTxHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................       { 
....................          wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead; 
....................          TCPRAMCopyROM(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, data, wRightLen); 
....................          data += wRightLen; 
....................          wActualLen -= wRightLen; 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................       } 
....................     
....................       TCPRAMCopyROM(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, data, wActualLen); 
....................       MyTCBStub.sslTxHead += wActualLen; 
....................    } 
....................    else 
....................    { 
....................       // See if we need a two part put 
....................       if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................       { 
....................          wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead; 
....................          TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wRightLen); 
....................          data += wRightLen; 
....................          wActualLen -= wRightLen; 
....................          MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................       } 
....................     
....................       TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wActualLen); 
....................       MyTCBStub.txHead += wActualLen; 
....................    } 
....................    #else 
....................    // See if we need a two part put 
....................    if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................    { 
....................       wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead; 
....................       TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wRightLen); 
....................       data += wRightLen; 
....................       wActualLen -= wRightLen; 
....................       MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................    } 
....................  
....................    TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wActualLen); 
....................    MyTCBStub.txHead += wActualLen; 
....................    #endif 
....................  
....................    // Send these bytes right now if we are out of TX buffer space 
....................    if(wFreeTXSpace <= len) 
....................    { 
....................       TCPFlush(hTCP); 
....................    } 
....................    // If not already enabled, start a timer so this data will  
....................    // eventually get sent even if the application doens't call 
....................    // TCPFlush() 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull; 
....................    } 
....................  
....................    return wActualLen + wRightLen; 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE* TCPPutString(TCP_SOCKET hTCP, BYTE* data) 
....................  
....................   Description: 
....................    Writes a null-terminated string from RAM to a TCP socket.  The  
....................    null-terminator is not copied to the socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    data - Pointer to the string to be written. 
....................  
....................   Returns: 
....................    Pointer to the byte following the last byte written to the socket.  If 
....................    this pointer does not dereference to a NUL byte, the buffer became full 
....................    or the socket is not connected. 
....................  
....................   Remarks: 
....................    The return value of this function differs from that of TCPPutArray.  To 
....................    write long strings in a single state, initialize the *data pointer to the 
....................    first byte, then call this function repeatedly (breaking to the main  
....................    stack loop after each call) until the return value dereferences to a NUL 
....................    byte.  Save the return value as the new starting *data pointer otherwise. 
....................   ***************************************************************************/ 
.................... BYTE* TCPPutString(TCP_SOCKET hTCP, BYTE* data) 
.................... { 
....................    return data + TCPPutArray(hTCP, data, strlen((char*)data)); 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE* TCPPutROMString(TCP_SOCKET hTCP, ROM BYTE* data) 
....................  
....................   Description: 
....................    Writes a null-terminated string from ROM to a TCP socket.  The  
....................    null-terminator is not copied to the socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    data - Pointer to the string to be written. 
....................  
....................   Returns: 
....................    Pointer to the byte following the last byte written to the socket.  If 
....................    this pointer does not dereference to a NUL byte, the buffer became full 
....................    or the socket is not connected. 
....................  
....................   Remarks: 
....................    The return value of this function differs from that of TCPPutArray.  To 
....................    write long strings in a single state, initialize the *data pointer to the 
....................    first byte, then call this function repeatedly (breaking to the main  
....................    stack loop after each call) until the return value dereferences to a NUL 
....................    byte.  Save the return value as the new starting *data pointer otherwise. 
....................     
....................    This function is aliased to TCPPutString on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... ROM BYTE* TCPPutROMString(TCP_SOCKET hTCP, ROM BYTE* data) 
.................... { 
....................    return data + TCPPutROMArray(hTCP, data, strlenpgm((ROM char*)data)); 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPGetTxFIFOFull(TCP_SOCKET hTCP) 
....................  
....................   Description: 
....................    Determines how many bytes are pending in the TCP TX FIFO. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    Number of bytes pending to be flushed in the TCP TX FIFO. 
....................   ***************************************************************************/ 
.................... WORD TCPGetTxFIFOFull(TCP_SOCKET hTCP) 
.................... { 
....................    WORD wDataLen; 
....................    WORD wFIFOSize; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    // Calculate total usable FIFO size 
....................    wFIFOSize = MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1; 
....................  
....................    // Find out how many data bytes are free in the TX FIFO 
....................    wDataLen = TCPIsPutReady(hTCP); 
....................  
....................    return wFIFOSize - wDataLen; 
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Receive Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPDiscard(TCP_SOCKET hTCP) 
....................  
....................   Description: 
....................    Discards any pending data in the TCP RX FIFO. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket whose RX FIFO is to be cleared. 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... void TCPDiscard(TCP_SOCKET hTCP) 
.................... { 
....................    if(TCPIsGetReady(hTCP)) 
....................    { 
....................       SyncTCBStub(hTCP); 
....................     
....................       // Delete all data in the RX buffer 
....................       MyTCBStub.rxTail = MyTCBStub.rxHead; 
....................     
....................       // Send a Window update message to the remote node 
....................       SendTCP(ACK, SENDTCP_RESET_TIMERS); 
....................    } 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void WORD TCPIsGetReady(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines how many bytes can be read from the TCP RX buffer. 
....................  
....................   Description: 
....................    Call this function to determine how many bytes can be read from the  
....................    TCP RX buffer.  If this function returns zero, the application must  
....................    return to the main stack loop before continuing in order to wait for 
....................    more data to arrive. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    The number of bytes available to be read from the TCP RX buffer. 
....................   ***************************************************************************/ 
.................... WORD TCPIsGetReady(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
0791C:  MOVLB  2
0791E:  MOVF   x64,W
07920:  SUBLW  00
07922:  BC    792C
....................     { 
....................         return 0; 
07924:  MOVLW  00
07926:  MOVWF  01
07928:  MOVWF  02
0792A:  BRA    7998
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
0792C:  MOVFF  264,281
07930:  MOVLB  0
07932:  CALL   0CCA
....................        
....................    if(MyTCBStub.rxHead >= MyTCBStub.rxTail) 
07936:  MOVLB  1
07938:  MOVF   xD4,W
0793A:  SUBWF  xD2,W
0793C:  BNC   7960
0793E:  BNZ   7946
07940:  MOVF   xD3,W
07942:  SUBWF  xD1,W
07944:  BNC   7960
....................       return MyTCBStub.rxHead - MyTCBStub.rxTail; 
07946:  MOVF   xD3,W
07948:  SUBWF  xD1,W
0794A:  MOVWF  00
0794C:  MOVF   xD4,W
0794E:  SUBWFB xD2,W
07950:  MOVWF  03
07952:  MOVFF  00,01
07956:  MOVWF  02
07958:  MOVLB  2
0795A:  BRA    7998
0795C:  BRA    7998
0795E:  MOVLB  1
....................    else 
....................       return (MyTCBStub.bufferEnd - MyTCBStub.rxTail + 1) + (MyTCBStub.rxHead - MyTCBStub.bufferRxStart); 
07960:  MOVF   xD3,W
07962:  SUBWF  xCB,W
07964:  MOVLB  2
07966:  MOVWF  x65
07968:  MOVLB  1
0796A:  MOVF   xD4,W
0796C:  SUBWFB xCC,W
0796E:  MOVLB  2
07970:  MOVWF  x66
07972:  MOVLW  01
07974:  ADDWF  x65,F
07976:  MOVLW  00
07978:  ADDWFC x66,F
0797A:  MOVLB  1
0797C:  MOVF   xC9,W
0797E:  SUBWF  xD1,W
07980:  MOVWF  00
07982:  MOVF   xCA,W
07984:  SUBWFB xD2,W
07986:  MOVWF  03
07988:  MOVF   00,W
0798A:  MOVLB  2
0798C:  ADDWF  x65,W
0798E:  MOVWF  01
07990:  MOVF   x66,W
07992:  ADDWFC 03,F
07994:  MOVFF  03,02
07998:  MOVLB  0
0799A:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPGet(TCP_SOCKET hTCP, BYTE* byte) 
....................  
....................   Description: 
....................    Retrieves a single byte to a TCP socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket from which to read. 
....................    byte - Pointer to location in which the read byte should be stored. 
....................  
....................   Return Values: 
....................    TRUE - A byte was read from the buffer. 
....................    FALSE - The buffer was empty, or the socket is not connected. 
....................   ***************************************************************************/ 
.................... BOOL TCPGet(TCP_SOCKET hTCP, BYTE* byte) 
.................... { 
....................    WORD wGetReadyCount; 
....................  
....................    // See if there is any data which can be read 
....................    wGetReadyCount = TCPIsGetReady(hTCP); 
0799C:  MOVFF  25F,264
079A0:  RCALL  791C
079A2:  MOVFF  02,263
079A6:  MOVFF  01,262
....................    if(wGetReadyCount == 0u) 
079AA:  MOVLB  2
079AC:  MOVF   x62,F
079AE:  BNZ   79BA
079B0:  MOVF   x63,F
079B2:  BNZ   79BA
....................       return FALSE; 
079B4:  MOVLW  00
079B6:  MOVWF  01
079B8:  BRA    7A46
....................  
....................    SyncTCBStub(hTCP); 
079BA:  MOVFF  25F,281
079BE:  MOVLB  0
079C0:  CALL   0CCA
....................     
....................    if(byte) 
079C4:  MOVLB  2
079C6:  MOVF   x60,W
079C8:  IORWF  x61,W
079CA:  BZ    79F0
....................       TCPRAMCopy((PTR_BASE)byte, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, 1); 
079CC:  MOVFF  261,2C9
079D0:  MOVFF  260,2C8
079D4:  MOVLW  01
079D6:  MOVWF  xCA
079D8:  MOVFF  1D4,2CC
079DC:  MOVFF  1D3,2CB
079E0:  MOVFF  1E2,2CD
079E4:  CLRF   xCF
079E6:  MOVWF  xCE
079E8:  MOVLB  0
079EA:  CALL   11E8
079EE:  MOVLB  2
....................    if(++MyTCBStub.rxTail > MyTCBStub.bufferEnd) 
079F0:  MOVLB  1
079F2:  INCF   xD3,F
079F4:  BTFSC  FD8.2
079F6:  INCF   xD4,F
079F8:  MOVF   xCC,W
079FA:  SUBWF  xD4,W
079FC:  BNC   7A0E
079FE:  BNZ   7A06
07A00:  MOVF   xD3,W
07A02:  SUBWF  xCB,W
07A04:  BC    7A0E
....................       MyTCBStub.rxTail = MyTCBStub.bufferRxStart; 
07A06:  MOVFF  1CA,1D4
07A0A:  MOVFF  1C9,1D3
....................  
....................    // Send a window update if we've run out of data 
....................    if(wGetReadyCount == 1u) 
07A0E:  MOVLB  2
07A10:  DECFSZ x62,W
07A12:  BRA    7A1E
07A14:  MOVF   x63,F
07A16:  BNZ   7A1E
....................    { 
....................       MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
07A18:  MOVLB  1
07A1A:  BSF    xDF.2
....................    } 
07A1C:  BRA    7A40
....................    // If not already enabled, start a timer so a window  
....................    // update will get sent to the remote node at some point 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
07A1E:  MOVLB  1
07A20:  BTFSC  xDE.5
07A22:  BRA    7A40
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
07A24:  BSF    xDE.5
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_WINDOW_UPDATE_TIMEOUT_VAL/256ull; 
07A26:  MOVLB  0
07A28:  CALL   16EE
07A2C:  MOVLW  1E
07A2E:  MOVLB  2
07A30:  ADDWF  00,W
07A32:  MOVLB  1
07A34:  MOVWF  xD9
07A36:  MOVLW  00
07A38:  MOVLB  2
07A3A:  ADDWFC 01,W
07A3C:  MOVLB  1
07A3E:  MOVWF  xDA
....................    } 
....................  
....................  
....................    return TRUE; 
07A40:  MOVLW  01
07A42:  MOVWF  01
07A44:  MOVLB  2
07A46:  MOVLB  0
07A48:  GOTO   7E4C (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPGetArray(TCP_SOCKET hTCP, BYTE* buffer, WORD len) 
....................  
....................   Description: 
....................    Reads an array of data bytes from a TCP socket's receive FIFO.  The data  
....................    is removed from the FIFO in the process. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket from which data is to be read. 
....................    buffer - Pointer to the array to store data that was read. 
....................    len  - Number of bytes to be read. 
....................  
....................   Returns: 
....................    The number of bytes read from the socket.  If less than len, the 
....................    RX FIFO buffer became empty or the socket is not conected. 
....................   ***************************************************************************/ 
.................... WORD TCPGetArray(TCP_SOCKET hTCP, BYTE* buffer, WORD len) 
.................... { 
....................    WORD wGetReadyCount; 
....................    WORD RightLen = 0; 
....................  
....................    // See if there is any data which can be read 
....................    wGetReadyCount = TCPIsGetReady(hTCP); 
....................    if(wGetReadyCount == 0u) 
....................       return 0x0000u; 
....................  
....................    SyncTCBStub(hTCP); 
....................  
....................    // Make sure we don't try to read more data than is available 
....................    if(len > wGetReadyCount) 
....................       len = wGetReadyCount; 
....................  
....................    // See if we need a two part get 
....................    if(MyTCBStub.rxTail + len > MyTCBStub.bufferEnd) 
....................    { 
....................       RightLen = MyTCBStub.bufferEnd - MyTCBStub.rxTail + 1; 
....................       if(buffer) 
....................       { 
....................          TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, RightLen); 
....................          buffer += RightLen; 
....................       } 
....................       len -= RightLen; 
....................       MyTCBStub.rxTail = MyTCBStub.bufferRxStart; 
....................    } 
....................  
....................    if(buffer) 
....................       TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, len); 
....................    MyTCBStub.rxTail += len; 
....................    len += RightLen; 
....................  
....................    // Send a window update if we've run low on data 
....................    if(wGetReadyCount - len <= len) 
....................    { 
....................       MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
....................    } 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
....................    // If not already enabled, start a timer so a window  
....................    // update will get sent to the remote node at some point 
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_WINDOW_UPDATE_TIMEOUT_VAL/256ull; 
....................    } 
....................  
....................    return len; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPGetRxFIFOFree(TCP_SOCKET hTCP) 
....................  
....................   Description: 
....................    Determines how many bytes are free in the RX FIFO. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    The number of bytes free in the TCP RX FIFO.  If zero, no additional  
....................    data can be received until the application removes some data using one 
....................    of the TCPGet family functions. 
....................   ***************************************************************************/ 
.................... WORD TCPGetRxFIFOFree(TCP_SOCKET hTCP) 
.................... { 
....................    WORD wDataLen; 
....................    WORD wFIFOSize; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    // Calculate total usable FIFO size 
....................    wFIFOSize = MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart; 
....................  
....................    #if defined(STACK_USE_SSL) 
....................    { 
....................       PTR_BASE SSLtemp = MyTCBStub.rxHead; 
....................  
....................       // Move SSL pointer to determine full buffer size 
....................       if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................          MyTCBStub.rxHead = MyTCBStub.sslRxHead; 
....................  
....................       // Find out how many data bytes are actually in the RX FIFO 
....................       wDataLen = TCPIsGetReady(hTCP); 
....................        
....................       // Move SSL pointer back to proper location (if we changed it) 
....................       MyTCBStub.rxHead = SSLtemp; 
....................    } 
....................    #else 
....................    { 
....................       // Find out how many data bytes are actually in the RX FIFO 
....................       wDataLen = TCPIsGetReady(hTCP); 
....................    } 
....................    #endif 
....................     
....................    // Perform the calculation    
....................    return wFIFOSize - wDataLen; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPPeekArray(TCP_SOCKET hTCP, BYTE *vBuffer, WORD wLen, WORD wStart) 
....................  
....................   Summary: 
....................      Reads a specified number of data bytes from the TCP RX FIFO without  
....................      removing them from the buffer. 
....................  
....................   Description: 
....................    Reads a specified number of data bytes from the TCP RX FIFO without  
....................      removing them from the buffer.  No TCP control actions are taken as a  
....................      result of this function (ex: no window update is sent to the remote node). 
....................       
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to peak from (read without removing from stream). 
....................    vBuffer - Destination to write the peeked data bytes. 
....................    wLen - Length of bytes to peak from the RX FIFO and copy to vBuffer. 
....................    wStart - Zero-indexed starting position within the FIFO to start peeking  
....................       from. 
....................  
....................   Return Values: 
....................    Number of bytes actually peeked from the stream and copied to vBuffer.   
....................    This value can be less than wLen if wStart + wLen is greater than the  
....................    deepest possible character in the RX FIFO. 
....................  
....................   Remarks: 
....................      None 
....................   ***************************************************************************/ 
.................... WORD TCPPeekArray(TCP_SOCKET hTCP, BYTE *vBuffer, WORD wLen, WORD wStart) 
.................... { 
....................    PTR_BASE ptrRead; 
....................    WORD w; 
....................    WORD wBytesUntilWrap; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT || wLen == 0) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    // Find out how many bytes are in the RX FIFO and decrease read length  
....................    // if the start offset + read length is beyond the end of the FIFO 
....................    w = TCPIsGetReady(hTCP); 
....................    if(wStart + wLen > w) 
....................       wLen = w - wStart; 
....................  
....................    // Find the read start location 
....................    ptrRead = MyTCBStub.rxTail + wStart; 
....................    if(ptrRead > MyTCBStub.bufferEnd) 
....................       ptrRead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................  
....................    // Calculate how many bytes can be read in a single go 
....................    wBytesUntilWrap = MyTCBStub.bufferEnd - ptrRead + 1; 
....................    if(wLen <= wBytesUntilWrap) 
....................    { 
....................       // Read all at once 
....................       TCPRAMCopy((PTR_BASE)vBuffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, wLen); 
....................    } 
....................    else 
....................    { 
....................       // Read all bytes up to the wrap position and then read remaining bytes  
....................       // at the start of the buffer 
....................       TCPRAMCopy((PTR_BASE)vBuffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, wBytesUntilWrap); 
....................       TCPRAMCopy((PTR_BASE)vBuffer+wBytesUntilWrap, TCP_PIC_RAM, MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, wLen - wBytesUntilWrap); 
....................    } 
....................     
....................    return wLen; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE TCPPeek(TCP_SOCKET hTCP, WORD wStart) 
....................  
....................   Summary: 
....................      Peaks at one byte in the TCP RX FIFO without removing it from the buffer. 
....................  
....................   Description: 
....................    Peaks at one byte in the TCP RX FIFO without removing it from the buffer. 
....................       
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to peak from (read without removing from stream). 
....................    wStart - Zero-indexed starting position within the FIFO to peek from. 
....................  
....................   Return Values: 
....................    Byte peeked from the RX FIFO.  If there is no data in the buffer or an  
....................    illegal wStart starting offset is given, then an indeterminate value is  
....................    returned.  The caller must ensure that valid parameters are passed to avoid  
....................    (i.e ensure that TCPIsGetReady() returns a number that is less than wStart  
....................    before calling TCPPeek()). 
....................  
....................   Remarks: 
....................      Use the TCPPeekArray() function to read more than one byte.  It will  
....................      perform better than calling TCPPeek() in a loop. 
....................   ***************************************************************************/ 
.................... BYTE TCPPeek(TCP_SOCKET hTCP, WORD wStart) 
.................... { 
....................    BYTE i; 
....................     
....................    TCPPeekArray(hTCP, &i, 1, wStart); 
....................    return i; 
.................... } 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Search Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPFindArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen,  
....................                   WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
....................  
....................   Summary: 
....................      Searches for a string in the TCP RX buffer. 
....................  
....................   Description: 
....................    This function finds the first occurrance of an array of bytes in the 
....................    TCP RX buffer.  It can be used by an application to abstract searches  
....................    out of their own application code.  For increased efficiency, the  
....................    function is capable of limiting the scope of search to a specific 
....................    range of bytes.  It can also perform a case-insensitive search if 
....................    required. 
....................     
....................    For example, if the buffer contains "I love PIC MCUs!" and the search 
....................    array is "love" with a length of 4, a value of 2 will be returned. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to search within. 
....................    cFindArray - The array of bytes to find in the buffer. 
....................    wLen - Length of cFindArray. 
....................    wStart - Zero-indexed starting position within the buffer. 
....................    wSearchLen - Length from wStart to search in the buffer. 
....................    bTextCompare - TRUE for case-insensitive text search, FALSE for binary search 
....................  
....................   Return Values: 
....................    0xFFFF - Search array not found 
....................    Otherwise - Zero-indexed position of the first occurrance 
....................  
....................   Remarks: 
....................    Since this function usually must transfer data from external storage 
....................    to internal RAM for comparison, its performance degrades significantly 
....................    when the buffer is full and the array is not found.  For better  
....................    performance, try to search for characters that are expected to exist or 
....................    limit the scope of the search as much as possible.  The HTTP2 module,  
....................    for example, uses this function to parse headers.  However, it searches  
....................    for newlines, then the separating colon, then reads the header name to  
....................    RAM for final comparison.  This has proven to be significantly faster   
....................    than searching for full header name strings outright. 
....................   ***************************************************************************/ 
.................... WORD TCPFindArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
.................... { 
....................    PTR_BASE ptrRead; 
....................    WORD wDataLen; 
....................    WORD wBytesUntilWrap; 
....................    PTR_BASE ptrLocation; 
....................    WORD wLenStart; 
....................    BYTE *cFindArrayStart; 
....................    BYTE i, j, k; 
....................    BOOL isFinding; 
....................    BYTE buffer[32]; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT || wLen == 0) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    // Find out how many bytes are in the RX FIFO and return  
....................    // immediately if we won't possibly find a match 
....................    wDataLen = TCPIsGetReady(hTCP) - wStart; 
....................    if(wDataLen < wLen) 
....................       return 0xFFFFu; 
....................    if(wSearchLen && (wDataLen > wSearchLen)) 
....................       wDataLen = wSearchLen; 
....................  
....................    ptrLocation = MyTCBStub.rxTail + wStart; 
....................    if(ptrLocation > MyTCBStub.bufferEnd) 
....................       ptrLocation -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................    ptrRead = ptrLocation; 
....................    wBytesUntilWrap = MyTCBStub.bufferEnd - ptrLocation + 1; 
....................    ptrLocation = wStart; 
....................    wLenStart = wLen; 
....................    cFindArrayStart = cFindArray; 
....................    j = *cFindArray++; 
....................    isFinding = FALSE; 
....................    if(bTextCompare) 
....................    { 
....................       if(j >= 'a' && j <= 'z') 
....................          j += 'A'-'a'; 
....................    } 
....................  
....................    // Search for the array 
....................    while(1) 
....................    { 
....................       // Figure out how big of a chunk to read 
....................       k = sizeof(buffer); 
....................       if(k > wBytesUntilWrap) 
....................          k = wBytesUntilWrap; 
....................       if((WORD)k > wDataLen) 
....................          k = wDataLen; 
....................  
....................       // Read a chunk of data into the buffer 
....................       TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, (WORD)k); 
....................       ptrRead += k; 
....................       wBytesUntilWrap -= k; 
....................  
....................       if(wBytesUntilWrap == 0u) 
....................       { 
....................          ptrRead = MyTCBStub.bufferRxStart; 
....................          wBytesUntilWrap = 0xFFFFu; 
....................       } 
....................  
....................       // Convert everything to uppercase 
....................       if(bTextCompare) 
....................       { 
....................          for(i = 0; i < k; i++) 
....................          { 
....................             if(buffer[i] >= 'a' && buffer[i] <= 'z') 
....................                buffer[i] += 'A'-'a'; 
....................  
....................             if(j == buffer[i]) 
....................             { 
....................                if(--wLen == 0u) 
....................                   return ptrLocation-wLenStart + i + 1; 
....................                j = *cFindArray++; 
....................                isFinding = TRUE; 
....................                if(j >= 'a' && j <= 'z') 
....................                   j += 'A'-'a'; 
....................             } 
....................             else 
....................             { 
....................                wLen = wLenStart; 
....................                if(isFinding) 
....................                { 
....................                   cFindArray = cFindArrayStart; 
....................                   j = *cFindArray++; 
....................                   if(j >= 'a' && j <= 'z') 
....................                      j += 'A'-'a'; 
....................                   isFinding = FALSE; 
....................                } 
....................             } 
....................          } 
....................       } 
....................       else   // Compare as is 
....................       { 
....................          for(i = 0; i < k; i++) 
....................          { 
....................             if(j == buffer[i]) 
....................             { 
....................                if(--wLen == 0u) 
....................                   return ptrLocation-wLenStart + i + 1; 
....................                j = *cFindArray++; 
....................                isFinding = TRUE; 
....................             } 
....................             else 
....................             { 
....................                wLen = wLenStart; 
....................                if(isFinding) 
....................                { 
....................                   cFindArray = cFindArrayStart; 
....................                   j = *cFindArray++; 
....................                   isFinding = FALSE; 
....................                } 
....................             } 
....................          } 
....................       } 
....................  
....................       // Check to see if it is impossible to find a match 
....................       wDataLen -= k; 
....................       if(wDataLen < wLen) 
....................          return 0xFFFFu; 
....................  
....................       ptrLocation += k; 
....................    } 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPFindROMArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen,  
....................                   WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
....................  
....................   Summary: 
....................      Searches for a ROM string in the TCP RX buffer. 
....................  
....................   Description: 
....................    This function finds the first occurrance of an array of bytes in the 
....................    TCP RX buffer.  It can be used by an application to abstract searches  
....................    out of their own application code.  For increased efficiency, the  
....................    function is capable of limiting the scope of search to a specific 
....................    range of bytes.  It can also perform a case-insensitive search if 
....................    required. 
....................     
....................    For example, if the buffer contains "I love PIC MCUs!" and the search 
....................    array is "love" with a length of 4, a value of 2 will be returned. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to search within. 
....................    cFindArray - The array of bytes to find in the buffer. 
....................    wLen - Length of cFindArray. 
....................    wStart - Zero-indexed starting position within the buffer. 
....................    wSearchLen - Length from wStart to search in the buffer. 
....................    bTextCompare - TRUE for case-insensitive text search, FALSE for binary search 
....................  
....................   Return Values: 
....................    0xFFFF - Search array not found 
....................    Otherwise - Zero-indexed position of the first occurrance 
....................  
....................   Remarks: 
....................    Since this function usually must transfer data from external storage 
....................    to internal RAM for comparison, its performance degrades significantly 
....................    when the buffer is full and the array is not found.  For better  
....................    performance, try to search for characters that are expected to exist or 
....................    limit the scope of the search as much as possible.  The HTTP2 module,  
....................    for example, uses this function to parse headers.  However, it searches  
....................    for newlines, then the separating colon, then reads the header name to  
....................    RAM for final comparison.  This has proven to be significantly faster   
....................    than searching for full header name strings outright. 
....................     
....................    This function is aliased to TCPFindArrayEx on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... WORD TCPFindROMArrayEx(TCP_SOCKET hTCP, ROM BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
.................... { 
....................    PTR_BASE ptrRead; 
....................    WORD wDataLen; 
....................    WORD wBytesUntilWrap; 
....................    PTR_BASE ptrLocation; 
....................    WORD wLenStart; 
....................    ROM BYTE *cFindArrayStart; 
....................    BYTE i, j, k; 
....................    BOOL isFinding; 
....................    BYTE buffer[32]; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT || wLen == 0) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    // Find out how many bytes are in the RX FIFO and return  
....................    // immediately if we won't possibly find a match 
....................    wDataLen = TCPIsGetReady(hTCP) - wStart; 
....................    if(wDataLen < wLen) 
....................       return 0xFFFFu; 
....................    if(wSearchLen && (wDataLen > wSearchLen)) 
....................       wDataLen = wSearchLen; 
....................  
....................    ptrLocation = MyTCBStub.rxTail + wStart; 
....................    if(ptrLocation > MyTCBStub.bufferEnd) 
....................       ptrLocation -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................    ptrRead = ptrLocation; 
....................    wBytesUntilWrap = MyTCBStub.bufferEnd - ptrLocation + 1; 
....................    ptrLocation = wStart; 
....................    wLenStart = wLen; 
....................    cFindArrayStart = cFindArray; 
....................    j = *cFindArray++; 
....................    isFinding = FALSE; 
....................    if(bTextCompare) 
....................    { 
....................       if(j >= 'a' && j <= 'z') 
....................          j += 'A'-'a'; 
....................    } 
....................  
....................    // Search for the array 
....................    while(1) 
....................    { 
....................       // Figure out how big of a chunk to read 
....................       k = sizeof(buffer); 
....................       if(k > wBytesUntilWrap) 
....................          k = wBytesUntilWrap; 
....................       if((WORD)k > wDataLen) 
....................          k = wDataLen; 
....................  
....................       // Read a chunk of data into the buffer 
....................       TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, (WORD)k); 
....................       ptrRead += k; 
....................       wBytesUntilWrap -= k; 
....................  
....................       if(wBytesUntilWrap == 0u) 
....................       { 
....................          ptrRead = MyTCBStub.bufferRxStart; 
....................          wBytesUntilWrap = 0xFFFFu; 
....................       } 
....................  
....................       // Convert everything to uppercase 
....................       if(bTextCompare) 
....................       { 
....................          for(i = 0; i < k; i++) 
....................          { 
....................             if(buffer[i] >= 'a' && buffer[i] <= 'z') 
....................                buffer[i] += 'A'-'a'; 
....................  
....................             if(j == buffer[i]) 
....................             { 
....................                if(--wLen == 0u) 
....................                   return ptrLocation-wLenStart + i + 1; 
....................                j = *cFindArray++; 
....................                isFinding = TRUE; 
....................                if(j >= 'a' && j <= 'z') 
....................                   j += 'A'-'a'; 
....................             } 
....................             else 
....................             { 
....................                wLen = wLenStart; 
....................                if(isFinding) 
....................                { 
....................                   cFindArray = cFindArrayStart; 
....................                   j = *cFindArray++; 
....................                   if(j >= 'a' && j <= 'z') 
....................                      j += 'A'-'a'; 
....................                   isFinding = FALSE; 
....................                } 
....................             } 
....................          } 
....................       } 
....................       else   // Compare as is 
....................       { 
....................          for(i = 0; i < k; i++) 
....................          { 
....................             if(j == buffer[i]) 
....................             { 
....................                if(--wLen == 0u) 
....................                   return ptrLocation-wLenStart + i + 1; 
....................                j = *cFindArray++; 
....................                isFinding = TRUE; 
....................             } 
....................             else 
....................             { 
....................                wLen = wLenStart; 
....................                if(isFinding) 
....................                { 
....................                   cFindArray = cFindArrayStart; 
....................                   j = *cFindArray++; 
....................                   isFinding = FALSE; 
....................                } 
....................             } 
....................          } 
....................       } 
....................  
....................       // Check to see if it is impossible to find a match 
....................       wDataLen -= k; 
....................       if(wDataLen < wLen) 
....................          return 0xFFFFu; 
....................  
....................       ptrLocation += k; 
....................    } 
.................... } 
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPFindEx(TCP_SOCKET hTCP, BYTE cFind, 
....................                   WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
....................  
....................   Summary: 
....................      Searches for a byte in the TCP RX buffer. 
....................  
....................   Description: 
....................    This function finds the first occurrance of a byte in the TCP RX 
....................    buffer.  It can be used by an application to abstract searches  
....................    out of their own application code.  For increased efficiency, the  
....................    function is capable of limiting the scope of search to a specific 
....................    range of bytes.  It can also perform a case-insensitive search if 
....................    required. 
....................     
....................    For example, if the buffer contains "I love PIC MCUs!" and the cFind 
....................    byte is ' ', a value of 1 will be returned. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to search within. 
....................    cFind - The byte to find in the buffer. 
....................    wStart - Zero-indexed starting position within the buffer. 
....................    wSearchLen - Length from wStart to search in the buffer. 
....................    bTextCompare - TRUE for case-insensitive text search, FALSE for binary search 
....................  
....................   Return Values: 
....................    0xFFFF - Search array not found 
....................    Otherwise - Zero-indexed position of the first occurrance 
....................  
....................   Remarks: 
....................    Since this function usually must transfer data from external storage 
....................    to internal RAM for comparison, its performance degrades significantly 
....................    when the buffer is full and the array is not found.  For better  
....................    performance, try to search for characters that are expected to exist or 
....................    limit the scope of the search as much as possible.  The HTTP2 module,  
....................    for example, uses this function to parse headers.  However, it searches  
....................    for newlines, then the separating colon, then reads the header name to  
....................    RAM for final comparison.  This has proven to be significantly faster   
....................    than searching for full header name strings outright. 
....................   ***************************************************************************/ 
.................... WORD TCPFindEx(TCP_SOCKET hTCP, BYTE cFind, WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
.................... { 
....................    return TCPFindArrayEx(hTCP, &cFind, sizeof(cFind), wStart, wSearchLen, bTextCompare); 
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Data Processing Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPTick(void) 
....................  
....................   Summary: 
....................      Performs periodic TCP tasks. 
....................  
....................   Description: 
....................    This function performs any required periodic TCP tasks.  Each  
....................    socket's state machine is checked, and any elapsed timeout periods 
....................    are handled. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... void TCPTick(void) 
.................... { 
....................    TCP_SOCKET hTCP; 
....................    BOOL bRetransmit; 
....................    BOOL bCloseSocket; 
....................    BYTE vFlags; 
....................    WORD w; 
....................  
....................    // Periodically all "not closed" sockets must perform timed operations 
....................    for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++) 
*
0434E:  MOVLB  2
04350:  CLRF   x4C
04352:  MOVF   x4C,F
04354:  BTFSS  FD8.2
04356:  GOTO   4BD0
....................    { 
....................       SyncTCBStub(hTCP); 
0435A:  MOVFF  24C,281
0435E:  MOVLB  0
04360:  CALL   0CCA
....................        
....................       // Handle any SSL Processing and Message Transmission 
....................       #if defined(STACK_USE_SSL) 
....................       if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       { 
....................          // Handle any periodic tasks, such as RSA operations 
....................          SSLPeriodic(hTCP, MyTCBStub.sslStubID); 
....................           
....................          // If unsent data is waiting, transmit it as an application record 
....................          if(MyTCBStub.sslTxHead != MyTCBStub.txHead && TCPSSLGetPendingTxSize(hTCP) != 0u) 
....................             SSLTxRecord(hTCP, MyTCBStub.sslStubID, SSL_APPLICATION); 
....................           
....................          // If an SSL message is requested, send it now 
....................          if(MyTCBStub.sslReqMessage != SSL_NO_MESSAGE) 
....................             SSLTxMessage(hTCP, MyTCBStub.sslStubID, MyTCBStub.sslReqMessage); 
....................       } 
....................       #endif 
....................        
....................       vFlags = 0x00; 
04364:  MOVLB  2
04366:  CLRF   x4E
....................       bRetransmit = FALSE; 
04368:  BCF    x4D.0
....................       bCloseSocket = FALSE; 
0436A:  BCF    x4D.1
....................  
....................       // Transmit ASAP data if the medium is available 
....................       if(MyTCBStub.Flags.bTXASAP || MyTCBStub.Flags.bTXASAPWithoutTimerReset) 
0436C:  MOVLB  1
0436E:  BTFSC  xDF.1
04370:  BRA    4376
04372:  BTFSS  xDF.2
04374:  BRA    4394
....................       { 
....................          if(MACIsTxReady()) 
04376:  MOVLB  0
04378:  CALL   168C
0437C:  MOVF   01,F
0437E:  BZ    4396
....................          { 
....................             vFlags = ACK; 
04380:  MOVLW  10
04382:  MOVLB  2
04384:  MOVWF  x4E
....................             bRetransmit = MyTCBStub.Flags.bTXASAPWithoutTimerReset; 
04386:  BCF    x4D.0
04388:  MOVLB  1
0438A:  BTFSS  xDF.2
0438C:  BRA    4394
0438E:  MOVLB  2
04390:  BSF    x4D.0
04392:  MOVLB  1
04394:  MOVLB  0
....................          } 
....................       } 
....................  
....................       // Perform any needed window updates and data transmissions 
....................       if(MyTCBStub.Flags.bTimer2Enabled) 
04396:  MOVLB  1
04398:  BTFSS  xDE.5
0439A:  BRA    43CC
....................       { 
....................          // See if the timeout has occured, and we need to send a new window update and pending data 
....................          if((SHORT)(MyTCBStub.eventTime2 - (WORD)TickGetDiv256()) <= (SHORT)0) 
0439C:  MOVLB  0
0439E:  CALL   16EE
043A2:  MOVF   00,W
043A4:  MOVLB  1
043A6:  SUBWF  xD9,W
043A8:  MOVWF  00
043AA:  MOVF   01,W
043AC:  SUBWFB xDA,W
043AE:  MOVWF  03
043B0:  MOVFF  00,255
043B4:  MOVLB  2
043B6:  MOVWF  x56
043B8:  BTFSC  FE8.7
043BA:  BRA    43C6
043BC:  MOVF   x56,F
043BE:  BNZ   43CA
043C0:  MOVF   x55,W
043C2:  SUBLW  00
043C4:  BNC   43CA
....................             vFlags = ACK; 
043C6:  MOVLW  10
043C8:  MOVWF  x4E
043CA:  MOVLB  1
....................       } 
....................  
....................       // Process Delayed ACKnowledgement timer 
....................       if(MyTCBStub.Flags.bDelayedACKTimerEnabled) 
043CC:  BTFSS  xDE.6
043CE:  BRA    4400
....................       { 
....................          // See if the timeout has occured and delayed ACK needs to be sent 
....................          if((SHORT)(MyTCBStub.OverlappedTimers.delayedACKTime - (WORD)TickGetDiv256()) <= (SHORT)0) 
043D0:  MOVLB  0
043D2:  CALL   16EE
043D6:  MOVF   00,W
043D8:  MOVLB  1
043DA:  SUBWF  xDB,W
043DC:  MOVWF  00
043DE:  MOVF   01,W
043E0:  SUBWFB xDC,W
043E2:  MOVWF  03
043E4:  MOVFF  00,255
043E8:  MOVLB  2
043EA:  MOVWF  x56
043EC:  BTFSC  FE8.7
043EE:  BRA    43FA
043F0:  MOVF   x56,F
043F2:  BNZ   43FE
043F4:  MOVF   x55,W
043F6:  SUBLW  00
043F8:  BNC   43FE
....................             vFlags = ACK; 
043FA:  MOVLW  10
043FC:  MOVWF  x4E
043FE:  MOVLB  1
....................       } 
....................        
....................       // Process TCP_CLOSE_WAIT timer 
....................       if(MyTCBStub.smState == TCP_CLOSE_WAIT) 
04400:  MOVF   xDD,W
04402:  SUBLW  0B
04404:  BNZ   443A
....................       { 
....................          // Automatically close the socket on our end if the application  
....................          // fails to call TCPDisconnect() is a reasonable amount of time. 
....................          if((SHORT)(MyTCBStub.OverlappedTimers.closeWaitTime - (WORD)TickGetDiv256()) <= (SHORT)0) 
04406:  MOVLB  0
04408:  CALL   16EE
0440C:  MOVF   00,W
0440E:  MOVLB  1
04410:  SUBWF  xDB,W
04412:  MOVWF  00
04414:  MOVF   01,W
04416:  SUBWFB xDC,W
04418:  MOVWF  03
0441A:  MOVFF  00,255
0441E:  MOVLB  2
04420:  MOVWF  x56
04422:  BTFSC  FE8.7
04424:  BRA    4430
04426:  MOVF   x56,F
04428:  BNZ   443C
0442A:  MOVF   x55,W
0442C:  SUBLW  00
0442E:  BNC   443C
....................          { 
....................             vFlags = FIN | ACK; 
04430:  MOVLW  11
04432:  MOVWF  x4E
....................             MyTCBStub.smState = TCP_LAST_ACK; 
04434:  MOVLW  0C
04436:  MOVLB  1
04438:  MOVWF  xDD
0443A:  MOVLB  2
....................          } 
....................       } 
....................  
....................       // Process listening server sockets that might have a SYN waiting in the SYNQueue[] 
....................       #if TCP_SYN_QUEUE_MAX_ENTRIES 
....................          if(MyTCBStub.smState == TCP_LISTEN) 
0443C:  MOVLB  1
0443E:  MOVF   xDD,W
04440:  SUBLW  04
04442:  BTFSS  FD8.2
04444:  BRA    46F8
....................          { 
....................             for(w = 0; w < TCP_SYN_QUEUE_MAX_ENTRIES; w++) 
04446:  MOVLB  2
04448:  CLRF   x50
0444A:  CLRF   x4F
0444C:  MOVF   x50,F
0444E:  BTFSS  FD8.2
04450:  BRA    46F6
04452:  MOVF   x4F,W
04454:  SUBLW  02
04456:  BTFSS  FD8.0
04458:  BRA    46F6
....................             { 
....................                // Abort search if there are no more valid records 
....................                if(SYNQueue[w].wDestPort == 0u) 
0445A:  MOVFF  250,282
0445E:  MOVFF  24F,281
04462:  CLRF   x84
04464:  MOVLW  14
04466:  MOVWF  x83
04468:  MOVLB  0
0446A:  CALL   1712
0446E:  MOVFF  01,255
04472:  MOVLW  10
04474:  MOVLB  2
04476:  ADDWF  01,W
04478:  MOVWF  01
0447A:  MOVLW  00
0447C:  ADDWFC 02,W
0447E:  MOVWF  03
04480:  MOVF   01,W
04482:  ADDLW  8B
04484:  MOVWF  FE9
04486:  MOVLW  01
04488:  ADDWFC 03,W
0448A:  MOVWF  FEA
0448C:  MOVFF  FEC,256
04490:  MOVF   FED,F
04492:  MOVFF  FEF,255
04496:  MOVF   x55,F
04498:  BNZ   44A0
0449A:  MOVF   x56,F
0449C:  BNZ   44A0
....................                   break; 
0449E:  BRA    46F6
....................                 
....................                // Stop searching if this SYN queue entry can be used by this socket 
....................                #if defined(STACK_USE_SSL_SERVER) 
....................                if(SYNQueue[w].wDestPort == MyTCBStub.remoteHash.Val || SYNQueue[w].wDestPort == MyTCBStub.sslTxHead) 
....................                #else 
....................                if(SYNQueue[w].wDestPort == MyTCBStub.remoteHash.Val) 
044A0:  MOVFF  250,282
044A4:  MOVFF  24F,281
044A8:  CLRF   x84
044AA:  MOVLW  14
044AC:  MOVWF  x83
044AE:  MOVLB  0
044B0:  CALL   1712
044B4:  MOVFF  01,255
044B8:  MOVLW  10
044BA:  MOVLB  2
044BC:  ADDWF  01,W
044BE:  MOVWF  01
044C0:  MOVLW  00
044C2:  ADDWFC 02,W
044C4:  MOVWF  03
044C6:  MOVF   01,W
044C8:  ADDLW  8B
044CA:  MOVWF  FE9
044CC:  MOVLW  01
044CE:  ADDWFC 03,W
044D0:  MOVWF  FEA
044D2:  MOVFF  FEC,256
044D6:  MOVF   FED,F
044D8:  MOVFF  FEF,255
044DC:  MOVLB  1
044DE:  MOVF   xE0,W
044E0:  MOVLB  2
044E2:  SUBWF  x55,W
044E4:  BTFSS  FD8.2
044E6:  BRA    46EE
044E8:  MOVLB  1
044EA:  MOVF   xE1,W
044EC:  MOVLB  2
044EE:  SUBWF  x56,W
044F0:  BTFSS  FD8.2
044F2:  BRA    46EE
....................                #endif 
....................                { 
....................                   // Set up our socket and generate a reponse SYN+ACK packet 
....................                   SyncTCB(); 
044F4:  MOVLB  0
044F6:  CALL   12CE
....................                    
....................                   #if defined(STACK_USE_SSL_SERVER) 
....................                   // If this matches the SSL port, make sure that can be configured 
....................                   // before continuing.  If not, break and leave this in the queue 
....................                   if(SYNQueue[w].wDestPort == MyTCBStub.sslTxHead && !TCPStartSSLServer(hTCP)) 
....................                      break; 
....................                   #endif 
....................                    
....................                   memcpy((void*)&MyTCB.remote.niRemoteMACIP, (void*)&SYNQueue[w].niSourceAddress, sizeof(NODE_INFO)); 
044FA:  MOVLW  01
044FC:  MOVLB  2
044FE:  MOVWF  x56
04500:  MOVLW  79
04502:  MOVWF  x55
04504:  MOVFF  250,282
04508:  MOVFF  24F,281
0450C:  CLRF   x84
0450E:  MOVLW  14
04510:  MOVWF  x83
04512:  MOVLB  0
04514:  CALL   1712
04518:  MOVFF  02,258
0451C:  MOVFF  01,257
04520:  MOVLW  8B
04522:  MOVLB  2
04524:  ADDWF  01,W
04526:  MOVWF  01
04528:  MOVLW  01
0452A:  ADDWFC 02,W
0452C:  MOVWF  03
0452E:  MOVFF  01,259
04532:  MOVWF  x5A
04534:  MOVFF  256,FEA
04538:  MOVFF  255,FE9
0453C:  MOVWF  FE2
0453E:  MOVFF  01,FE1
04542:  MOVLW  0A
04544:  MOVWF  01
04546:  MOVFF  FE6,FEE
0454A:  DECFSZ 01,F
0454C:  BRA    4546
....................                   MyTCB.remotePort.Val = SYNQueue[w].wSourcePort; 
0454E:  MOVFF  250,282
04552:  MOVFF  24F,281
04556:  CLRF   x84
04558:  MOVLW  14
0455A:  MOVWF  x83
0455C:  MOVLB  0
0455E:  CALL   1712
04562:  MOVFF  01,255
04566:  MOVLW  0A
04568:  MOVLB  2
0456A:  ADDWF  01,W
0456C:  MOVWF  01
0456E:  MOVLW  00
04570:  ADDWFC 02,W
04572:  MOVWF  03
04574:  MOVF   01,W
04576:  ADDLW  8B
04578:  MOVWF  FE9
0457A:  MOVLW  01
0457C:  ADDWFC 03,W
0457E:  MOVWF  FEA
04580:  MOVFF  FEC,172
04584:  MOVF   FED,F
04586:  MOVFF  FEF,171
....................                   MyTCB.RemoteSEQ = SYNQueue[w].dwSourceSEQ + 1; 
0458A:  MOVFF  250,282
0458E:  MOVFF  24F,281
04592:  CLRF   x84
04594:  MOVLW  14
04596:  MOVWF  x83
04598:  MOVLB  0
0459A:  CALL   1712
0459E:  MOVFF  01,255
045A2:  MOVLW  0C
045A4:  MOVLB  2
045A6:  ADDWF  01,W
045A8:  MOVWF  01
045AA:  MOVLW  00
045AC:  ADDWFC 02,W
045AE:  MOVWF  03
045B0:  MOVF   01,W
045B2:  ADDLW  8B
045B4:  MOVWF  FE9
045B6:  MOVLW  01
045B8:  ADDWFC 03,W
045BA:  MOVWF  FEA
045BC:  MOVFF  FEF,255
045C0:  MOVFF  FEC,256
045C4:  MOVFF  FEC,257
045C8:  MOVFF  FEC,258
045CC:  MOVLW  01
045CE:  ADDWF  x55,W
045D0:  MOVLB  1
045D2:  MOVWF  x6B
045D4:  MOVLW  00
045D6:  MOVLB  2
045D8:  ADDWFC x56,W
045DA:  MOVLB  1
045DC:  MOVWF  x6C
045DE:  MOVLW  00
045E0:  MOVLB  2
045E2:  ADDWFC x57,W
045E4:  MOVLB  1
045E6:  MOVWF  x6D
045E8:  MOVLW  00
045EA:  MOVLB  2
045EC:  ADDWFC x58,W
045EE:  MOVLB  1
045F0:  MOVWF  x6E
....................                   MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1] + MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val; 
045F2:  MOVF   x79,W
045F4:  ADDWF  x7B,W
045F6:  MOVLB  2
045F8:  MOVWF  x55
045FA:  MOVLB  1
045FC:  MOVF   x7A,W
045FE:  ADDWFC x7C,W
04600:  MOVLB  2
04602:  MOVWF  x56
04604:  MOVLB  1
04606:  MOVF   x71,W
04608:  MOVLB  2
0460A:  ADDWF  x55,F
0460C:  MOVLB  1
0460E:  MOVF   x72,W
04610:  MOVLB  2
04612:  ADDWFC x56,F
04614:  MOVF   x55,W
04616:  MOVLB  1
04618:  XORWF  x73,W
0461A:  MOVWF  xE0
0461C:  MOVLB  2
0461E:  MOVF   x56,W
04620:  MOVLB  1
04622:  XORWF  x74,W
04624:  MOVWF  xE1
....................                   vFlags = SYN | ACK; 
04626:  MOVLW  12
04628:  MOVLB  2
0462A:  MOVWF  x4E
....................                   MyTCBStub.smState = TCP_SYN_RECEIVED; 
0462C:  MOVLW  06
0462E:  MOVLB  1
04630:  MOVWF  xDD
....................                    
....................                   // Delete this SYN from the SYNQueue and compact the SYNQueue[] array 
....................                   TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE)); 
04632:  MOVFF  250,282
04636:  MOVFF  24F,281
0463A:  MOVLB  2
0463C:  CLRF   x84
0463E:  MOVLW  14
04640:  MOVWF  x83
04642:  MOVLB  0
04644:  CALL   1712
04648:  MOVFF  02,03
0464C:  MOVF   01,W
0464E:  ADDLW  8B
04650:  MOVWF  01
04652:  MOVLW  01
04654:  ADDWFC 03,F
04656:  MOVFF  01,255
0465A:  MOVLB  2
0465C:  MOVFF  03,256
04660:  MOVLW  01
04662:  ADDWF  x4F,W
04664:  MOVWF  x57
04666:  MOVLW  00
04668:  ADDWFC x50,W
0466A:  MOVWF  x58
0466C:  MOVWF  x82
0466E:  MOVFF  257,281
04672:  CLRF   x84
04674:  MOVLW  14
04676:  MOVWF  x83
04678:  MOVLB  0
0467A:  CALL   1712
0467E:  MOVFF  02,03
04682:  MOVF   01,W
04684:  ADDLW  8B
04686:  MOVWF  01
04688:  MOVLW  01
0468A:  ADDWFC 03,F
0468C:  MOVFF  01,257
04690:  MOVLB  2
04692:  MOVFF  03,258
04696:  MOVLW  02
04698:  BSF    FD8.0
0469A:  SUBFWB x4F,W
0469C:  MOVWF  x59
0469E:  MOVLW  00
046A0:  SUBFWB x50,W
046A2:  MOVWF  x5A
046A4:  MOVWF  x82
046A6:  MOVFF  259,281
046AA:  CLRF   x84
046AC:  MOVLW  14
046AE:  MOVWF  x83
046B0:  MOVLB  0
046B2:  CALL   1712
046B6:  MOVFF  02,25A
046BA:  MOVFF  01,259
046BE:  MOVFF  256,2C9
046C2:  MOVFF  255,2C8
046C6:  MOVLW  01
046C8:  MOVLB  2
046CA:  MOVWF  xCA
046CC:  MOVFF  258,2CC
046D0:  MOVFF  257,2CB
046D4:  MOVWF  xCD
046D6:  MOVFF  02,2CF
046DA:  MOVFF  01,2CE
046DE:  MOVLB  0
046E0:  CALL   11E8
....................                   SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort = 0u; 
046E4:  MOVLB  1
046E6:  CLRF   xC4
046E8:  CLRF   xC3
....................     
....................                   break; 
046EA:  MOVLB  2
046EC:  BRA    46F6
....................                } 
046EE:  INCF   x4F,F
046F0:  BTFSC  FD8.2
046F2:  INCF   x50,F
046F4:  BRA    444C
046F6:  MOVLB  1
....................             } 
....................          } 
....................       #endif 
....................  
....................       if(vFlags) 
046F8:  MOVLB  2
046FA:  MOVF   x4E,F
046FC:  BZ    4718
....................          SendTCP(vFlags, bRetransmit ? 0 : SENDTCP_RESET_TIMERS); 
046FE:  BTFSS  x4D.0
04700:  BRA    4706
04702:  MOVLW  00
04704:  BRA    4708
04706:  MOVLW  01
04708:  MOVWF  x55
0470A:  MOVFF  24E,297
0470E:  MOVWF  x98
04710:  MOVLB  0
04712:  CALL   231A
04716:  MOVLB  2
....................  
....................       // The TCP_CLOSED, TCP_LISTEN, and sometimes the TCP_ESTABLISHED  
....................       // state don't need any timeout events, so see if the timer is enabled 
....................       if(!MyTCBStub.Flags.bTimerEnabled) 
04718:  MOVLB  1
0471A:  BTFSC  xDE.4
0471C:  BRA    47FC
....................       { 
....................          #if defined(TCP_KEEP_ALIVE_TIMEOUT) 
....................             // Only the established state has any use for keep-alives 
....................             if(MyTCBStub.smState == TCP_ESTABLISHED) 
0471E:  MOVF   xDD,W
04720:  SUBLW  07
04722:  BNZ   47F6
....................             { 
....................                // If timeout has not occured, do not do anything. 
....................                if((LONG)(TickGet() - MyTCBStub.eventTime) < (LONG)0) 
04724:  MOVLB  0
04726:  CALL   1734
0472A:  MOVFF  03,258
0472E:  MOVFF  02,257
04732:  MOVFF  01,256
04736:  MOVFF  00,255
0473A:  MOVLB  1
0473C:  MOVF   xD5,W
0473E:  MOVLB  2
04740:  SUBWF  00,W
04742:  MOVWF  00
04744:  MOVLB  1
04746:  MOVF   xD6,W
04748:  MOVLB  2
0474A:  SUBWFB 01,W
0474C:  MOVWF  01
0474E:  MOVLB  1
04750:  MOVF   xD7,W
04752:  MOVLB  2
04754:  SUBWFB 02,W
04756:  MOVWF  02
04758:  MOVLB  1
0475A:  MOVF   xD8,W
0475C:  MOVLB  2
0475E:  SUBWFB 03,W
04760:  MOVWF  03
04762:  MOVWF  x58
04764:  MOVFF  02,257
04768:  MOVFF  01,256
0476C:  MOVFF  00,255
04770:  BTFSS  FE8.7
04772:  BRA    4776
....................                   continue; 
04774:  BRA    4BCA
....................        
....................                // If timeout has occured and the connection appears to be dead (no  
....................                // responses from remote node at all), close the connection so the  
....................                // application doesn't sit around indefinitely with a useless socket  
....................                // that it thinks is still open 
....................                if(MyTCBStub.Flags.vUnackedKeepalives == TCP_MAX_UNACKED_KEEP_ALIVES) 
04776:  MOVLB  1
04778:  MOVF   xDE,W
0477A:  ANDLW  07
0477C:  SUBLW  06
0477E:  BNZ   47B4
....................                { 
....................                   vFlags = MyTCBStub.Flags.bServer; 
04780:  MOVLB  2
04782:  CLRF   x4E
04784:  MOVLB  1
04786:  BTFSS  xDE.3
04788:  BRA    4790
0478A:  MOVLB  2
0478C:  INCF   x4E,F
0478E:  MOVLB  1
....................  
....................                   // Force an immediate FIN and RST transmission 
....................                   // Double calling TCPDisconnect() will also place us  
....................                   // back in the listening state immediately if a server socket. 
....................                   TCPDisconnect(hTCP); 
04790:  MOVFF  24C,255
04794:  MOVLB  0
04796:  CALL   2964
....................                   TCPDisconnect(hTCP); 
0479A:  MOVFF  24C,255
0479E:  CALL   2964
....................                    
....................                   // Prevent client mode sockets from getting reused by other applications.   
....................                   // The application must call TCPDisconnect() with the handle to free this  
....................                   // socket (and the handle associated with it) 
....................                   if(!vFlags) 
047A2:  MOVLB  2
047A4:  MOVF   x4E,F
047A6:  BNZ   47B0
....................                      MyTCBStub.smState = TCP_CLOSED_BUT_RESERVED; 
047A8:  MOVLW  0E
047AA:  MOVLB  1
047AC:  MOVWF  xDD
047AE:  MOVLB  2
....................                    
....................                   continue; 
047B0:  BRA    4BCA
047B2:  MOVLB  1
....................                } 
....................                 
....................                // Otherwise, if a timeout occured, simply send a keep-alive packet 
....................                SyncTCB(); 
047B4:  MOVLB  0
047B6:  CALL   12CE
....................                SendTCP(ACK, SENDTCP_KEEP_ALIVE); 
047BA:  MOVLW  10
047BC:  MOVLB  2
047BE:  MOVWF  x97
047C0:  MOVLW  02
047C2:  MOVWF  x98
047C4:  MOVLB  0
047C6:  CALL   231A
....................                MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
047CA:  CALL   1734
047CE:  MOVLW  E6
047D0:  MOVLB  2
047D2:  ADDWF  00,W
047D4:  MOVLB  1
047D6:  MOVWF  xD5
047D8:  MOVLW  F5
047DA:  MOVLB  2
047DC:  ADDWFC 01,W
047DE:  MOVLB  1
047E0:  MOVWF  xD6
047E2:  MOVLW  05
047E4:  MOVLB  2
047E6:  ADDWFC 02,W
047E8:  MOVLB  1
047EA:  MOVWF  xD7
047EC:  MOVLW  00
047EE:  MOVLB  2
047F0:  ADDWFC 03,W
047F2:  MOVLB  1
047F4:  MOVWF  xD8
....................             } 
....................          #endif 
....................          continue; 
047F6:  MOVLB  2
047F8:  BRA    4BCA
047FA:  MOVLB  1
....................       } 
....................  
....................       // If timeout has not occured, do not do anything. 
....................       if((LONG)(TickGet() - MyTCBStub.eventTime) < (LONG)0) 
047FC:  MOVLB  0
047FE:  CALL   1734
04802:  MOVFF  03,258
04806:  MOVFF  02,257
0480A:  MOVFF  01,256
0480E:  MOVFF  00,255
04812:  MOVLB  1
04814:  MOVF   xD5,W
04816:  MOVLB  2
04818:  SUBWF  00,W
0481A:  MOVWF  00
0481C:  MOVLB  1
0481E:  MOVF   xD6,W
04820:  MOVLB  2
04822:  SUBWFB 01,W
04824:  MOVWF  01
04826:  MOVLB  1
04828:  MOVF   xD7,W
0482A:  MOVLB  2
0482C:  SUBWFB 02,W
0482E:  MOVWF  02
04830:  MOVLB  1
04832:  MOVF   xD8,W
04834:  MOVLB  2
04836:  SUBWFB 03,W
04838:  MOVWF  03
0483A:  MOVWF  x58
0483C:  MOVFF  02,257
04840:  MOVFF  01,256
04844:  MOVFF  00,255
04848:  BTFSS  FE8.7
0484A:  BRA    484E
....................          continue; 
0484C:  BRA    4BCA
....................  
....................       // Load up extended TCB information 
....................       SyncTCB(); 
0484E:  MOVLB  0
04850:  CALL   12CE
....................  
....................       // A timeout has occured.  Respond to this timeout condition 
....................       // depending on what state this socket is in. 
....................       switch(MyTCBStub.smState) 
04854:  MOVLB  1
04856:  MOVF   xDD,W
04858:  XORLW  00
0485A:  MOVLB  0
0485C:  BZ    48A0
0485E:  XORLW  01
04860:  BZ    48E8
04862:  XORLW  03
04864:  BTFSC  FD8.2
04866:  BRA    4990
04868:  XORLW  01
0486A:  BTFSC  FD8.2
0486C:  BRA    49B6
0486E:  XORLW  06
04870:  BTFSC  FD8.2
04872:  BRA    4A3A
04874:  XORLW  03
04876:  BTFSC  FD8.2
04878:  BRA    4A60
0487A:  XORLW  01
0487C:  BTFSC  FD8.2
0487E:  BRA    4A8E
04880:  XORLW  0C
04882:  BTFSC  FD8.2
04884:  BRA    4A8E
04886:  XORLW  03
04888:  BTFSC  FD8.2
0488A:  BRA    4AB0
0488C:  XORLW  01
0488E:  BTFSC  FD8.2
04890:  BRA    4AD0
04892:  XORLW  03
04894:  BTFSC  FD8.2
04896:  BRA    4ADC
04898:  XORLW  06
0489A:  BTFSC  FD8.2
0489C:  BRA    4AFC
0489E:  BRA    4B1C
....................       { 
....................          #if defined(STACK_CLIENT_MODE) 
....................          #if defined(STACK_USE_DNS) 
....................          case TCP_GET_DNS_MODULE: 
....................             if(DNSBeginUsage()) 
048A0:  CALL   2A5A
048A4:  MOVF   01,F
048A6:  BZ    48E6
....................             { 
....................                MyTCBStub.smState = TCP_DNS_RESOLVE; 
048A8:  MOVLW  01
048AA:  MOVLB  1
048AC:  MOVWF  xDD
....................                if(MyTCB.flags.bRemoteHostIsROM) 
048AE:  BTFSS  x85.2
048B0:  BRA    48D2
....................                   DNSResolveROM((ROM BYTE*)(ROM_PTR_BASE)MyTCB.remote.dwRemoteHost, DNS_TYPE_A); 
048B2:  MOVFF  17A,256
048B6:  MOVFF  179,255
048BA:  MOVFF  17A,258
048BE:  MOVFF  179,257
048C2:  MOVLW  01
048C4:  MOVLB  2
048C6:  MOVWF  x59
048C8:  MOVLB  0
048CA:  CALL   2C42
048CE:  BRA    48E6
048D0:  MOVLB  1
....................                else 
....................                   DNSResolve((BYTE*)(PTR_BASE)MyTCB.remote.dwRemoteHost, DNS_TYPE_A); 
048D2:  MOVFF  17A,256
048D6:  MOVFF  179,255
048DA:  MOVLW  01
048DC:  MOVLB  2
048DE:  MOVWF  x57
048E0:  MOVLB  0
048E2:  CALL   2E2C
....................             } 
....................             break; 
048E6:  BRA    4B1C
....................              
....................          case TCP_DNS_RESOLVE: 
....................          { 
....................             IP_ADDR ipResolvedDNSIP; 
....................  
....................             // See if DNS resolution has finished.  Note that if the DNS  
....................             // fails, the &ipResolvedDNSIP will be written with 0x00000000.  
....................             // MyTCB.remote.dwRemoteHost is unioned with  
....................             // MyTCB.remote.niRemoteMACIP.IPAddr, so we can't directly write  
....................             // the DNS result into MyTCB.remote.niRemoteMACIP.IPAddr.  We  
....................             // must copy it over only if the DNS is resolution step was  
....................             // successful. 
....................             if(DNSIsResolved(&ipResolvedDNSIP)) 
048E8:  MOVLW  02
048EA:  MOVLB  2
048EC:  MOVWF  x56
048EE:  MOVLW  51
048F0:  MOVWF  x55
048F2:  MOVLB  0
048F4:  CALL   3B56
048F8:  MOVF   01,F
048FA:  BZ    498E
....................             { 
....................                if(DNSEndUsage()) 
048FC:  CALL   293A
04900:  MOVF   01,F
04902:  BZ    495E
....................                { 
....................                   MyTCB.remote.niRemoteMACIP.IPAddr.Val = ipResolvedDNSIP.Val; 
04904:  MOVFF  254,17C
04908:  MOVFF  253,17B
0490C:  MOVFF  252,17A
04910:  MOVFF  251,179
....................                   MyTCBStub.smState = TCP_GATEWAY_SEND_ARP; 
04914:  MOVLW  02
04916:  MOVLB  1
04918:  MOVWF  xDD
....................                   MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1]+MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val; 
0491A:  MOVF   x79,W
0491C:  ADDWF  x7B,W
0491E:  MOVLB  2
04920:  MOVWF  x55
04922:  MOVLB  1
04924:  MOVF   x7A,W
04926:  ADDWFC x7C,W
04928:  MOVLB  2
0492A:  MOVWF  x56
0492C:  MOVLB  1
0492E:  MOVF   x71,W
04930:  MOVLB  2
04932:  ADDWF  x55,F
04934:  MOVLB  1
04936:  MOVF   x72,W
04938:  MOVLB  2
0493A:  ADDWFC x56,F
0493C:  MOVF   x55,W
0493E:  MOVLB  1
04940:  XORWF  x73,W
04942:  MOVWF  xE0
04944:  MOVLB  2
04946:  MOVF   x56,W
04948:  MOVLB  1
0494A:  XORWF  x74,W
0494C:  MOVWF  xE1
....................                   MyTCB.retryCount = 0; 
0494E:  CLRF   x88
....................                   MyTCB.retryInterval = (TICK_SECOND/4)/256; 
04950:  CLRF   x66
04952:  CLRF   x65
04954:  CLRF   x64
04956:  MOVLW  26
04958:  MOVWF  x63
....................                } 
0495A:  BRA    498C
0495C:  MOVLB  0
....................                else 
....................                { 
....................                   MyTCBStub.eventTime = TickGet() + 10*TICK_SECOND; 
0495E:  CALL   1734
04962:  MOVLW  E6
04964:  MOVLB  2
04966:  ADDWF  00,W
04968:  MOVLB  1
0496A:  MOVWF  xD5
0496C:  MOVLW  F5
0496E:  MOVLB  2
04970:  ADDWFC 01,W
04972:  MOVLB  1
04974:  MOVWF  xD6
04976:  MOVLW  05
04978:  MOVLB  2
0497A:  ADDWFC 02,W
0497C:  MOVLB  1
0497E:  MOVWF  xD7
04980:  MOVLW  00
04982:  MOVLB  2
04984:  ADDWFC 03,W
04986:  MOVLB  1
04988:  MOVWF  xD8
....................                   MyTCBStub.smState = TCP_GET_DNS_MODULE; 
0498A:  CLRF   xDD
0498C:  MOVLB  0
....................                } 
....................             } 
....................             break; 
0498E:  BRA    4B1C
....................          } 
....................          #endif // #if defined(STACK_USE_DNS) 
....................              
....................          case TCP_GATEWAY_SEND_ARP: 
....................             // Obtain the MAC address associated with the server's IP address (either direct MAC address on same subnet, or the MAC address of the Gateway machine) 
....................             MyTCBStub.eventTime2 = (WORD)TickGetDiv256(); 
04990:  CALL   16EE
04994:  MOVFF  01,1DA
04998:  MOVFF  00,1D9
....................             ARPResolve(&MyTCB.remote.niRemoteMACIP.IPAddr); 
0499C:  MOVLW  01
0499E:  MOVLB  2
049A0:  MOVWF  x71
049A2:  MOVLW  79
049A4:  MOVWF  x70
049A6:  MOVLB  0
049A8:  CALL   3048
....................             MyTCBStub.smState = TCP_GATEWAY_GET_ARP; 
049AC:  MOVLW  03
049AE:  MOVLB  1
049B0:  MOVWF  xDD
....................             break; 
049B2:  MOVLB  0
049B4:  BRA    4B1C
....................  
....................          case TCP_GATEWAY_GET_ARP: 
....................             // Wait for the MAC address to finish being obtained 
....................             if(!ARPIsResolved(&MyTCB.remote.niRemoteMACIP.IPAddr, &MyTCB.remote.niRemoteMACIP.MACAddr)) 
049B6:  MOVLW  01
049B8:  MOVLB  2
049BA:  MOVWF  x71
049BC:  MOVLW  79
049BE:  MOVWF  x70
049C0:  MOVLW  01
049C2:  MOVWF  x73
049C4:  MOVLW  7D
049C6:  MOVWF  x72
049C8:  MOVLB  0
049CA:  CALL   30FC
049CE:  MOVF   01,F
049D0:  BNZ   4A28
....................             { 
....................                // Time out if too much time is spent in this state 
....................                // Note that this will continuously send out ARP  
....................                // requests for an infinite time if the Gateway  
....................                // never responds 
....................                if((WORD)TickGetDiv256() - MyTCBStub.eventTime2 > (WORD)MyTCB.retryInterval) 
049D2:  CALL   16EE
049D6:  MOVFF  01,256
049DA:  MOVFF  00,255
049DE:  MOVLB  1
049E0:  MOVF   xD9,W
049E2:  MOVLB  2
049E4:  SUBWF  x55,F
049E6:  MOVLB  1
049E8:  MOVF   xDA,W
049EA:  MOVLB  2
049EC:  SUBWFB x56,F
049EE:  MOVLB  1
049F0:  MOVF   x64,W
049F2:  MOVLB  2
049F4:  SUBWF  x56,W
049F6:  BNC   4A24
049F8:  BNZ   4A0A
049FA:  MOVF   x55,W
049FC:  MOVLB  1
049FE:  SUBWF  x63,W
04A00:  BTFSS  FD8.0
04A02:  BRA    4A08
04A04:  MOVLB  2
04A06:  BRA    4A24
04A08:  MOVLB  2
....................                { 
....................                   // Exponentially increase timeout until we reach 6 attempts then stay constant 
....................                   if(MyTCB.retryCount < 6u) 
04A0A:  MOVLB  1
04A0C:  MOVF   x88,W
04A0E:  SUBLW  05
04A10:  BNC   4A1E
....................                   { 
....................                      MyTCB.retryCount++; 
04A12:  INCF   x88,F
....................                      MyTCB.retryInterval <<= 1; 
04A14:  BCF    FD8.0
04A16:  RLCF   x63,F
04A18:  RLCF   x64,F
04A1A:  RLCF   x65,F
04A1C:  RLCF   x66,F
....................                   } 
....................  
....................                   // Retransmit ARP request 
....................                   MyTCBStub.smState = TCP_GATEWAY_SEND_ARP; 
04A1E:  MOVLW  02
04A20:  MOVWF  xDD
04A22:  MOVLB  2
....................                } 
....................                break; 
04A24:  MOVLB  0
04A26:  BRA    4B1C
....................             } 
....................              
....................             // Send out SYN connection request to remote node 
....................             // This automatically disables the Timer from  
....................             // continuously firing for this socket 
....................             vFlags = SYN; 
04A28:  MOVLW  02
04A2A:  MOVLB  2
04A2C:  MOVWF  x4E
....................             bRetransmit = FALSE; 
04A2E:  BCF    x4D.0
....................             MyTCBStub.smState = TCP_SYN_SENT; 
04A30:  MOVLW  05
04A32:  MOVLB  1
04A34:  MOVWF  xDD
....................             break; 
04A36:  MOVLB  0
04A38:  BRA    4B1C
....................          #endif // #if defined(STACK_CLIENT_MODE) 
....................           
....................          case TCP_SYN_SENT: 
....................             // Keep sending SYN until we hear from remote node. 
....................             // This may be for infinite time, in that case 
....................             // caller must detect it and do something. 
....................             vFlags = SYN; 
04A3A:  MOVLW  02
04A3C:  MOVLB  2
04A3E:  MOVWF  x4E
....................             bRetransmit = TRUE; 
04A40:  BSF    x4D.0
....................  
....................             // Exponentially increase timeout until we reach TCP_MAX_RETRIES attempts then stay constant 
....................             if(MyTCB.retryCount >= (TCP_MAX_RETRIES - 1)) 
04A42:  MOVLB  1
04A44:  MOVF   x88,W
04A46:  SUBLW  03
04A48:  BC    4A5C
....................             { 
....................                MyTCB.retryCount = TCP_MAX_RETRIES - 1; 
04A4A:  MOVLW  04
04A4C:  MOVWF  x88
....................                MyTCB.retryInterval = TCP_START_TIMEOUT_VAL<<(TCP_MAX_RETRIES-1); 
04A4E:  CLRF   x66
04A50:  MOVLW  09
04A52:  MOVWF  x65
04A54:  MOVLW  89
04A56:  MOVWF  x64
04A58:  MOVLW  70
04A5A:  MOVWF  x63
....................             } 
....................             break; 
04A5C:  MOVLB  0
04A5E:  BRA    4B1C
....................     
....................          case TCP_SYN_RECEIVED: 
....................             // We must receive ACK before timeout expires. 
....................             // If not, resend SYN+ACK. 
....................             // Abort, if maximum attempts counts are reached. 
....................             if(MyTCB.retryCount < TCP_MAX_SYN_RETRIES) 
04A60:  MOVLB  1
04A62:  MOVF   x88,W
04A64:  SUBLW  01
04A66:  BNC   4A74
....................             { 
....................                vFlags = SYN | ACK; 
04A68:  MOVLW  12
04A6A:  MOVLB  2
04A6C:  MOVWF  x4E
....................                bRetransmit = TRUE; 
04A6E:  BSF    x4D.0
....................             } 
04A70:  BRA    4A8A
04A72:  MOVLB  1
....................             else 
....................             { 
....................                if(MyTCBStub.Flags.bServer) 
04A74:  BTFSS  xDE.3
04A76:  BRA    4A84
....................                { 
....................                   vFlags = RST | ACK; 
04A78:  MOVLW  14
04A7A:  MOVLB  2
04A7C:  MOVWF  x4E
....................                   bCloseSocket = TRUE; 
04A7E:  BSF    x4D.1
....................                } 
04A80:  BRA    4A8A
04A82:  MOVLB  1
....................                else 
....................                { 
....................                   vFlags = SYN; 
04A84:  MOVLW  02
04A86:  MOVLB  2
04A88:  MOVWF  x4E
....................                } 
....................             } 
....................             break; 
04A8A:  MOVLB  0
04A8C:  BRA    4B1C
....................     
....................          case TCP_ESTABLISHED: 
....................          case TCP_CLOSE_WAIT: 
....................             // Retransmit any unacknowledged data 
....................             if(MyTCB.retryCount < TCP_MAX_RETRIES) 
04A8E:  MOVLB  1
04A90:  MOVF   x88,W
04A92:  SUBLW  04
04A94:  BNC   4AA2
....................             { 
....................                vFlags = ACK; 
04A96:  MOVLW  10
04A98:  MOVLB  2
04A9A:  MOVWF  x4E
....................                bRetransmit = TRUE; 
04A9C:  BSF    x4D.0
....................             } 
04A9E:  BRA    4AAC
04AA0:  MOVLB  1
....................             else 
....................             { 
....................                // No response back for too long, close connection 
....................                // This could happen, for instance, if the communication  
....................                // medium was lost 
....................                MyTCBStub.smState = TCP_FIN_WAIT_1; 
04AA2:  MOVLW  08
04AA4:  MOVWF  xDD
....................                vFlags = FIN | ACK; 
04AA6:  MOVLW  11
04AA8:  MOVLB  2
04AAA:  MOVWF  x4E
....................             } 
....................             break; 
04AAC:  MOVLB  0
04AAE:  BRA    4B1C
....................     
....................          case TCP_FIN_WAIT_1: 
....................             if(MyTCB.retryCount < TCP_MAX_RETRIES) 
04AB0:  MOVLB  1
04AB2:  MOVF   x88,W
04AB4:  SUBLW  04
04AB6:  BNC   4AC4
....................             { 
....................                // Send another FIN 
....................                vFlags = FIN | ACK; 
04AB8:  MOVLW  11
04ABA:  MOVLB  2
04ABC:  MOVWF  x4E
....................                bRetransmit = TRUE; 
04ABE:  BSF    x4D.0
....................             } 
04AC0:  BRA    4ACC
04AC2:  MOVLB  1
....................             else 
....................             { 
....................                // Close on our own, we can't seem to communicate  
....................                // with the remote node anymore 
....................                vFlags = RST | ACK; 
04AC4:  MOVLW  14
04AC6:  MOVLB  2
04AC8:  MOVWF  x4E
....................                bCloseSocket = TRUE; 
04ACA:  BSF    x4D.1
....................             } 
....................             break; 
04ACC:  MOVLB  0
04ACE:  BRA    4B1C
....................     
....................          case TCP_FIN_WAIT_2: 
....................             // Close on our own, we can't seem to communicate  
....................             // with the remote node anymore 
....................             vFlags = RST | ACK; 
04AD0:  MOVLW  14
04AD2:  MOVLB  2
04AD4:  MOVWF  x4E
....................             bCloseSocket = TRUE; 
04AD6:  BSF    x4D.1
....................             break; 
04AD8:  MOVLB  0
04ADA:  BRA    4B1C
....................  
....................          case TCP_CLOSING: 
....................             if(MyTCB.retryCount < TCP_MAX_RETRIES) 
04ADC:  MOVLB  1
04ADE:  MOVF   x88,W
04AE0:  SUBLW  04
04AE2:  BNC   4AF0
....................             { 
....................                // Send another ACK+FIN (the FIN is retransmitted  
....................                // automatically since it hasn't been acknowledged by  
....................                // the remote node yet) 
....................                vFlags = ACK; 
04AE4:  MOVLW  10
04AE6:  MOVLB  2
04AE8:  MOVWF  x4E
....................                bRetransmit = TRUE; 
04AEA:  BSF    x4D.0
....................             } 
04AEC:  BRA    4AF8
04AEE:  MOVLB  1
....................             else 
....................             { 
....................                // Close on our own, we can't seem to communicate  
....................                // with the remote node anymore 
....................                vFlags = RST | ACK; 
04AF0:  MOVLW  14
04AF2:  MOVLB  2
04AF4:  MOVWF  x4E
....................                bCloseSocket = TRUE; 
04AF6:  BSF    x4D.1
....................             } 
....................             break; 
04AF8:  MOVLB  0
04AFA:  BRA    4B1C
....................     
.................... //         case TCP_TIME_WAIT: 
.................... //            // Wait around for a while (2MSL) and then goto closed state 
.................... //            bCloseSocket = TRUE; 
.................... //            break; 
.................... //          
....................  
....................          case TCP_LAST_ACK: 
....................             // Send some more FINs or close anyway 
....................             if(MyTCB.retryCount < TCP_MAX_RETRIES) 
04AFC:  MOVLB  1
04AFE:  MOVF   x88,W
04B00:  SUBLW  04
04B02:  BNC   4B10
....................             { 
....................                vFlags = FIN | ACK; 
04B04:  MOVLW  11
04B06:  MOVLB  2
04B08:  MOVWF  x4E
....................                bRetransmit = TRUE; 
04B0A:  BSF    x4D.0
....................             } 
04B0C:  BRA    4B18
04B0E:  MOVLB  1
....................             else 
....................             { 
....................                vFlags = RST | ACK; 
04B10:  MOVLW  14
04B12:  MOVLB  2
04B14:  MOVWF  x4E
....................                bCloseSocket = TRUE; 
04B16:  BSF    x4D.1
....................             } 
....................             break; 
04B18:  MOVLB  0
04B1A:  BRA    4B1C
....................           
....................          default: 
....................             break; 
....................       } 
....................  
....................       if(vFlags) 
04B1C:  MOVLB  2
04B1E:  MOVF   x4E,F
04B20:  BZ    4BBE
....................       { 
....................          // Transmit all unacknowledged data over again 
....................          if(bRetransmit) 
04B22:  BTFSS  x4D.0
04B24:  BRA    4BAE
....................          { 
....................             // Set the appropriate retry time 
....................             MyTCB.retryCount++; 
04B26:  MOVLB  1
04B28:  INCF   x88,F
....................             MyTCB.retryInterval <<= 1; 
04B2A:  BCF    FD8.0
04B2C:  RLCF   x63,F
04B2E:  RLCF   x64,F
04B30:  RLCF   x65,F
04B32:  RLCF   x66,F
....................        
....................             // Calculate how many bytes we have to roll back and retransmit 
....................             w = MyTCB.txUnackedTail - MyTCBStub.txTail; 
04B34:  MOVF   xCF,W
04B36:  SUBWF  x6F,W
04B38:  MOVLB  2
04B3A:  MOVWF  x4F
04B3C:  MOVLB  1
04B3E:  MOVF   xD0,W
04B40:  SUBWFB x70,W
04B42:  MOVLB  2
04B44:  MOVWF  x50
....................             if(MyTCB.txUnackedTail < MyTCBStub.txTail) 
04B46:  MOVLB  1
04B48:  MOVF   x70,W
04B4A:  SUBWF  xD0,W
04B4C:  BNC   4B6E
04B4E:  BNZ   4B56
04B50:  MOVF   xCF,W
04B52:  SUBWF  x6F,W
04B54:  BC    4B6E
....................                w += MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
04B56:  MOVF   xC7,W
04B58:  SUBWF  xC9,W
04B5A:  MOVWF  00
04B5C:  MOVF   xC8,W
04B5E:  SUBWFB xCA,W
04B60:  MOVWF  03
04B62:  MOVF   00,W
04B64:  MOVLB  2
04B66:  ADDWF  x4F,F
04B68:  MOVF   03,W
04B6A:  ADDWFC x50,F
04B6C:  MOVLB  1
....................              
....................             // Perform roll back of local SEQuence counter, remote window  
....................             // adjustment, and cause all unacknowledged data to be  
....................             // retransmitted by moving the unacked tail pointer. 
....................             MyTCB.MySEQ -= w; 
04B6E:  MOVLB  2
04B70:  MOVF   x4F,W
04B72:  MOVLB  1
04B74:  SUBWF  x67,F
04B76:  MOVLB  2
04B78:  MOVF   x50,W
04B7A:  MOVLB  1
04B7C:  SUBWFB x68,F
04B7E:  MOVLW  00
04B80:  SUBWFB x69,F
04B82:  SUBWFB x6A,F
....................             MyTCB.remoteWindow += w; 
04B84:  MOVLB  2
04B86:  MOVF   x4F,W
04B88:  MOVLB  1
04B8A:  ADDWF  x75,F
04B8C:  MOVLB  2
04B8E:  MOVF   x50,W
04B90:  MOVLB  1
04B92:  ADDWFC x76,F
....................             MyTCB.txUnackedTail = MyTCBStub.txTail;       
04B94:  MOVFF  1D0,170
04B98:  MOVFF  1CF,16F
....................             SendTCP(vFlags, 0); 
04B9C:  MOVFF  24E,297
04BA0:  MOVLB  2
04BA2:  CLRF   x98
04BA4:  MOVLB  0
04BA6:  CALL   231A
....................          } 
04BAA:  BRA    4BBC
04BAC:  MOVLB  2
....................          else 
....................             SendTCP(vFlags, SENDTCP_RESET_TIMERS); 
04BAE:  MOVFF  24E,297
04BB2:  MOVLW  01
04BB4:  MOVWF  x98
04BB6:  MOVLB  0
04BB8:  CALL   231A
04BBC:  MOVLB  2
....................  
....................       } 
....................        
....................       if(bCloseSocket) 
04BBE:  BTFSS  x4D.1
04BC0:  BRA    4BCA
....................          CloseSocket(); 
04BC2:  MOVLB  0
04BC4:  CALL   13A6
04BC8:  MOVLB  2
....................    } 
....................     
....................     
....................    #if TCP_SYN_QUEUE_MAX_ENTRIES 
04BCA:  INCF   x4C,F
04BCC:  GOTO   4352
....................       // Process SYN Queue entry timeouts 
....................       for(w = 0; w < TCP_SYN_QUEUE_MAX_ENTRIES; w++) 
04BD0:  CLRF   x50
04BD2:  CLRF   x4F
04BD4:  MOVF   x50,F
04BD6:  BTFSS  FD8.2
04BD8:  BRA    4D54
04BDA:  MOVF   x4F,W
04BDC:  SUBLW  02
04BDE:  BTFSS  FD8.0
04BE0:  BRA    4D54
....................       { 
....................          // Abort search if there are no more valid records 
....................          if(SYNQueue[w].wDestPort == 0u) 
04BE2:  MOVFF  250,282
04BE6:  MOVFF  24F,281
04BEA:  CLRF   x84
04BEC:  MOVLW  14
04BEE:  MOVWF  x83
04BF0:  MOVLB  0
04BF2:  CALL   1712
04BF6:  MOVFF  01,255
04BFA:  MOVLW  10
04BFC:  MOVLB  2
04BFE:  ADDWF  01,W
04C00:  MOVWF  01
04C02:  MOVLW  00
04C04:  ADDWFC 02,W
04C06:  MOVWF  03
04C08:  MOVF   01,W
04C0A:  ADDLW  8B
04C0C:  MOVWF  FE9
04C0E:  MOVLW  01
04C10:  ADDWFC 03,W
04C12:  MOVWF  FEA
04C14:  MOVFF  FEC,256
04C18:  MOVF   FED,F
04C1A:  MOVFF  FEF,255
04C1E:  MOVF   x55,F
04C20:  BNZ   4C28
04C22:  MOVF   x56,F
04C24:  BNZ   4C28
....................             break; 
04C26:  BRA    4D54
....................           
....................          // See if this SYN has timed out 
....................          if((WORD)TickGetDiv256() - SYNQueue[w].wTimestamp > (WORD)(TCP_SYN_QUEUE_TIMEOUT/256ull)) 
04C28:  MOVLB  0
04C2A:  CALL   16EE
04C2E:  MOVFF  01,256
04C32:  MOVFF  00,255
04C36:  MOVFF  250,282
04C3A:  MOVFF  24F,281
04C3E:  MOVLB  2
04C40:  CLRF   x84
04C42:  MOVLW  14
04C44:  MOVWF  x83
04C46:  MOVLB  0
04C48:  CALL   1712
04C4C:  MOVFF  02,258
04C50:  MOVFF  01,257
04C54:  MOVLW  12
04C56:  MOVLB  2
04C58:  ADDWF  01,W
04C5A:  MOVWF  01
04C5C:  MOVLW  00
04C5E:  ADDWFC 02,W
04C60:  MOVWF  03
04C62:  MOVF   01,W
04C64:  ADDLW  8B
04C66:  MOVWF  FE9
04C68:  MOVLW  01
04C6A:  ADDWFC 03,W
04C6C:  MOVWF  FEA
04C6E:  MOVFF  FEC,03
04C72:  MOVF   FED,F
04C74:  MOVF   FEF,W
04C76:  SUBWF  x55,F
04C78:  MOVF   03,W
04C7A:  SUBWFB x56,F
04C7C:  MOVF   x56,W
04C7E:  SUBLW  00
04C80:  BC    4D4C
04C82:  XORLW  FF
04C84:  BNZ   4C8C
04C86:  MOVF   x55,W
04C88:  SUBLW  C9
04C8A:  BC    4D4C
....................          { 
....................             // Delete this SYN from the SYNQueue and compact the SYNQueue[] array 
....................             TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE)); 
04C8C:  MOVFF  250,282
04C90:  MOVFF  24F,281
04C94:  CLRF   x84
04C96:  MOVLW  14
04C98:  MOVWF  x83
04C9A:  MOVLB  0
04C9C:  CALL   1712
04CA0:  MOVFF  02,03
04CA4:  MOVF   01,W
04CA6:  ADDLW  8B
04CA8:  MOVWF  01
04CAA:  MOVLW  01
04CAC:  ADDWFC 03,F
04CAE:  MOVFF  01,255
04CB2:  MOVLB  2
04CB4:  MOVFF  03,256
04CB8:  MOVLW  01
04CBA:  ADDWF  x4F,W
04CBC:  MOVWF  x57
04CBE:  MOVLW  00
04CC0:  ADDWFC x50,W
04CC2:  MOVWF  x58
04CC4:  MOVWF  x82
04CC6:  MOVFF  257,281
04CCA:  CLRF   x84
04CCC:  MOVLW  14
04CCE:  MOVWF  x83
04CD0:  MOVLB  0
04CD2:  CALL   1712
04CD6:  MOVFF  02,03
04CDA:  MOVF   01,W
04CDC:  ADDLW  8B
04CDE:  MOVWF  01
04CE0:  MOVLW  01
04CE2:  ADDWFC 03,F
04CE4:  MOVFF  01,257
04CE8:  MOVLB  2
04CEA:  MOVFF  03,258
04CEE:  MOVLW  02
04CF0:  BSF    FD8.0
04CF2:  SUBFWB x4F,W
04CF4:  MOVWF  x59
04CF6:  MOVLW  00
04CF8:  SUBFWB x50,W
04CFA:  MOVWF  x5A
04CFC:  MOVWF  x82
04CFE:  MOVFF  259,281
04D02:  CLRF   x84
04D04:  MOVLW  14
04D06:  MOVWF  x83
04D08:  MOVLB  0
04D0A:  CALL   1712
04D0E:  MOVFF  02,25A
04D12:  MOVFF  01,259
04D16:  MOVFF  256,2C9
04D1A:  MOVFF  255,2C8
04D1E:  MOVLW  01
04D20:  MOVLB  2
04D22:  MOVWF  xCA
04D24:  MOVFF  258,2CC
04D28:  MOVFF  257,2CB
04D2C:  MOVWF  xCD
04D2E:  MOVFF  02,2CF
04D32:  MOVFF  01,2CE
04D36:  MOVLB  0
04D38:  CALL   11E8
....................             SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort = 0u; 
04D3C:  MOVLB  1
04D3E:  CLRF   xC4
04D40:  CLRF   xC3
....................     
....................             // Since we deleted an entry, we need to roll back one  
....................             // index so next loop will process the correct record 
....................             w--;    
04D42:  MOVLB  2
04D44:  MOVF   x4F,W
04D46:  BTFSC  FD8.2
04D48:  DECF   x50,F
04D4A:  DECF   x4F,F
....................          } 
04D4C:  INCF   x4F,F
04D4E:  BTFSC  FD8.2
04D50:  INCF   x50,F
04D52:  BRA    4BD4
....................       } 
....................    #endif 
04D54:  MOVLB  0
04D56:  GOTO   74FE (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPProcess(NODE_INFO* remote, IP_ADDR* localIP, WORD len) 
....................  
....................   Summary: 
....................      Handles incoming TCP segments. 
....................  
....................   Description: 
....................    This function handles incoming TCP segments.  When a segment arrives, it 
....................    is compared to open sockets using a hash of the remote port and IP.   
....................    On a match, the data is passed to HandleTCPSeg for further processing. 
....................  
....................   Precondition: 
....................    TCP is initialized and a TCP segment is ready in the MAC buffer. 
....................  
....................   Parameters: 
....................    remote - Remote NODE_INFO structure 
....................    localIP - This stack's IP address (for header checking) 
....................    len - Total length of the waiting TCP segment 
....................  
....................   Return Values: 
....................    TRUE - the segment was properly handled. 
....................    FALSE - otherwise 
....................   ***************************************************************************/ 
.................... BOOL TCPProcess(NODE_INFO* remote, IP_ADDR* localIP, WORD len) 
.................... { 
....................    TCP_HEADER      TCPHeader; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................    WORD_VAL        checksum1; 
....................    WORD_VAL        checksum2; 
....................    BYTE            optionsSize; 
....................  
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress      = remote->IPAddr; 
*
0707C:  MOVLB  2
0707E:  MOVFF  24C,FE9
07082:  MOVFF  24D,FEA
07086:  MOVFF  FEF,00
0708A:  MOVFF  FEC,01
0708E:  MOVFF  FEC,02
07092:  MOVFF  FEC,03
07096:  MOVFF  00,266
0709A:  MOVFF  01,267
0709E:  MOVFF  02,268
070A2:  MOVFF  03,269
....................    pseudoHeader.DestAddress        = *localIP; 
070A6:  MOVFF  24E,FE9
070AA:  MOVFF  24F,FEA
070AE:  MOVFF  FEF,00
070B2:  MOVFF  FEC,01
070B6:  MOVFF  FEC,02
070BA:  MOVFF  FEC,03
070BE:  MOVFF  00,26A
070C2:  MOVFF  01,26B
070C6:  MOVFF  02,26C
070CA:  MOVFF  03,26D
....................    pseudoHeader.Zero               = 0x0; 
070CE:  CLRF   x6E
....................    pseudoHeader.Protocol           = IP_PROT_TCP; 
070D0:  MOVLW  06
070D2:  MOVWF  x6F
....................    pseudoHeader.Length             = len; 
070D4:  MOVFF  251,271
070D8:  MOVFF  250,270
....................  
....................    SwapPseudoHeader(pseudoHeader); 
070DC:  MOVFF  271,2E1
070E0:  MOVFF  270,2E0
070E4:  MOVLB  0
070E6:  CALL   1874
070EA:  MOVFF  02,271
070EE:  MOVFF  01,270
....................  
....................    checksum1.Val = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
070F2:  MOVLW  02
070F4:  MOVLB  2
070F6:  MOVWF  x78
070F8:  MOVLW  66
070FA:  MOVWF  x77
070FC:  MOVFF  278,2DD
07100:  MOVWF  xDC
07102:  CLRF   xDF
07104:  MOVLW  0C
07106:  MOVWF  xDE
07108:  MOVLB  0
0710A:  CALL   1C28
0710E:  MOVFF  01,272
07112:  MOVLB  2
07114:  COMF   x72,F
07116:  MOVFF  02,273
0711A:  COMF   x73,F
....................  
....................    // Now calculate TCP packet checksum in NIC RAM - should match 
....................    // pesudo header checksum 
....................    checksum2.Val = CalcIPBufferChecksum(len); 
0711C:  MOVFF  251,2C2
07120:  MOVFF  250,2C1
07124:  MOVLB  0
07126:  CALL   1F9A
0712A:  MOVFF  02,275
0712E:  MOVFF  01,274
....................  
....................    // Compare checksums. 
....................    if(checksum1.Val != checksum2.Val) 
07132:  MOVLB  2
07134:  MOVF   x74,W
07136:  SUBWF  x72,W
07138:  BNZ   7140
0713A:  MOVF   x75,W
0713C:  SUBWF  x73,W
0713E:  BZ    714E
....................    { 
....................       MACDiscardRx(); 
07140:  MOVLB  0
07142:  CALL   3A06
....................       return TRUE; 
07146:  MOVLW  01
07148:  MOVWF  01
0714A:  BRA    71EC
0714C:  MOVLB  2
....................    } 
....................  
.................... #if defined(DEBUG_GENERATE_RX_LOSS) 
....................    // Throw RX packets away randomly 
....................    if(LFSRRand() > DEBUG_GENERATE_RX_LOSS) 
....................    { 
....................       MACDiscardRx(); 
....................       return TRUE; 
....................    } 
.................... #endif 
....................  
....................    // Retrieve TCP header. 
....................    IPSetRxBuffer(0); 
0714E:  CLRF   x9C
07150:  CLRF   x9B
07152:  MOVLB  0
07154:  CALL   393C
....................    MACGetArray((BYTE*)&TCPHeader, sizeof(TCPHeader)); 
07158:  MOVLW  02
0715A:  MOVLB  2
0715C:  MOVWF  x78
0715E:  MOVLW  52
07160:  MOVWF  x77
07162:  MOVFF  278,2E4
07166:  MOVWF  xE3
07168:  CLRF   xE6
0716A:  MOVLW  14
0716C:  MOVWF  xE5
0716E:  MOVLB  0
07170:  CALL   0E8E
....................    SwapTCPHeader(&TCPHeader); 
07174:  MOVLW  02
07176:  MOVLB  2
07178:  MOVWF  xC2
0717A:  MOVLW  52
0717C:  MOVWF  xC1
0717E:  MOVLB  0
07180:  CALL   1A0C
....................  
....................  
....................    // Skip over options to retrieve data bytes 
....................    optionsSize = (BYTE)((TCPHeader.DataOffset.Val << 2)- 
....................       sizeof(TCPHeader)); 
07184:  MOVLB  2
07186:  SWAPF  x5E,W
07188:  ANDLW  0F
0718A:  MOVWF  00
0718C:  RLCF   00,F
0718E:  RLCF   00,F
07190:  MOVLW  FC
07192:  ANDWF  00,F
07194:  MOVF   00,W
07196:  ADDLW  EC
07198:  MOVWF  x76
....................    len = len - optionsSize - sizeof(TCPHeader); 
0719A:  MOVF   x76,W
0719C:  SUBWF  x50,W
0719E:  MOVWF  x77
071A0:  MOVLW  00
071A2:  SUBWFB x51,W
071A4:  MOVWF  x78
071A6:  MOVLW  14
071A8:  SUBWF  x77,W
071AA:  MOVWF  x50
071AC:  MOVLW  00
071AE:  SUBWFB x78,W
071B0:  MOVWF  x51
....................  
....................    // Find matching socket. 
....................    if(FindMatchingTCPSocket(&TCPHeader, remote)) 
071B2:  MOVLW  02
071B4:  MOVWF  x78
071B6:  MOVLW  52
071B8:  MOVWF  x77
071BA:  MOVFF  24D,27A
071BE:  MOVFF  24C,279
071C2:  MOVLB  0
071C4:  GOTO   5774
071C8:  MOVF   01,F
071CA:  BZ    71E4
....................    { 
....................       #if defined(STACK_USE_SSL) 
....................       PTR_BASE prevRxHead; 
....................       // For SSL connections, show HandleTCPSeg() the full data buffer 
....................       prevRxHead = MyTCBStub.rxHead; 
....................       if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................          MyTCBStub.rxHead = MyTCBStub.sslRxHead; 
....................       #endif 
....................        
....................       HandleTCPSeg(&TCPHeader, len); 
071CC:  MOVLW  02
071CE:  MOVLB  2
071D0:  MOVWF  x78
071D2:  MOVLW  52
071D4:  MOVWF  x77
071D6:  MOVFF  251,27A
071DA:  MOVFF  250,279
071DE:  MOVLB  0
071E0:  GOTO   5EB8
....................        
....................       #if defined(STACK_USE_SSL) 
....................       if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       { 
....................          // Restore the buffer state 
....................          MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................          MyTCBStub.rxHead = prevRxHead; 
....................  
....................          // Process the new SSL data, using the currently loaded stub 
....................          TCPSSLHandleIncoming(hCurrentTCP); 
....................       } 
....................       #endif 
....................    } 
.................... //   else 
.................... //   { 
.................... //      // NOTE: RFC 793 specifies that if the socket is closed and a segment  
.................... //      // arrives, we should send back a RST if the RST bit in the incoming  
.................... //      // packet is not set.  Instead, we will just silently ignore such a  
.................... //      // packet since this is what firewalls do on purpose to enhance  
.................... //      // security. 
.................... //      //if(!TCPHeader.Flags.bits.flagRST) 
.................... //      //   SendTCP(RST, SENDTCP_RESET_TIMERS); 
.................... //   } 
....................  
....................    // Finished with this packet, discard it and free the Ethernet RAM for new packets 
....................    MACDiscardRx(); 
071E4:  CALL   3A06
....................  
....................    return TRUE; 
071E8:  MOVLW  01
071EA:  MOVWF  01
071EC:  GOTO   7668 (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void SendTCP(BYTE vTCPFlags, BYTE vSendFlags) 
....................  
....................   Summary: 
....................    Transmits a TPC segment. 
....................  
....................   Description: 
....................    This function assembles and transmits a TCP segment, including any  
....................    pending data.  It also supports retransmissions, keep-alives, and  
....................    other packet types. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    vTCPFlags - Additional TCP flags to include 
....................    vSendFlags - Any combinations of SENDTCP_* constants to modify the 
....................              transmit behavior or contents. 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... static void SendTCP(BYTE vTCPFlags, BYTE vSendFlags) 
.................... { 
....................    WORD_VAL        wVal; 
....................    TCP_HEADER      header; 
....................    TCP_OPTIONS     options; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................    WORD          len; 
....................     
....................    SyncTCB(); 
*
0231A:  CALL   12CE
....................  
....................    // FINs must be handled specially 
....................    if(vTCPFlags & FIN) 
0231E:  MOVLB  2
02320:  BTFSS  x97.0
02322:  BRA    232C
....................    { 
....................       MyTCBStub.Flags.bTXFIN = 1; 
02324:  MOVLB  1
02326:  BSF    xDF.3
....................       vTCPFlags &= ~FIN; 
02328:  MOVLB  2
0232A:  BCF    x97.0
....................    } 
....................  
....................    // Status will now be synched, disable automatic future  
....................    // status transmissions 
....................    MyTCBStub.Flags.bTimer2Enabled = 0; 
0232C:  MOVLB  1
0232E:  BCF    xDE.5
....................    MyTCBStub.Flags.bDelayedACKTimerEnabled = 0; 
02330:  BCF    xDE.6
....................    MyTCBStub.Flags.bOneSegmentReceived = 0; 
02332:  BCF    xDE.7
....................    MyTCBStub.Flags.bTXASAP = 0; 
02334:  BCF    xDF.1
....................    MyTCBStub.Flags.bTXASAPWithoutTimerReset = 0; 
02336:  BCF    xDF.2
....................    MyTCBStub.Flags.bHalfFullFlush = 0; 
02338:  BCF    xDF.0
....................  
....................    //  Make sure that we can write to the MAC transmit area 
....................    while(!IPIsTxReady()); 
0233A:  MOVLB  0
0233C:  CALL   168C
02340:  MOVF   01,F
02342:  BZ    233C
....................  
....................    // Put all socket application data in the TX space 
....................    if(vTCPFlags & (SYN | RST)) 
02344:  MOVLB  2
02346:  MOVF   x97,W
02348:  ANDLW  06
0234A:  BZ    2352
....................    { 
....................       // Don't put any data in SYN and RST messages 
....................       len = 0; 
0234C:  CLRF   xC0
0234E:  CLRF   xBF
....................    } 
02350:  BRA    2584
....................    else 
....................    { 
....................       // Begin copying any application data over to the TX space 
....................       if(MyTCBStub.txHead == MyTCB.txUnackedTail) 
02352:  MOVLB  1
02354:  MOVF   x6F,W
02356:  SUBWF  xCD,W
02358:  BNZ   236A
0235A:  MOVF   x70,W
0235C:  SUBWF  xCE,W
0235E:  BNZ   236A
....................       { 
....................          // All caught up on data TX, no real data for this packet 
....................          len = 0; 
02360:  MOVLB  2
02362:  CLRF   xC0
02364:  CLRF   xBF
....................       } 
02366:  BRA    2556
02368:  MOVLB  1
....................       else if(MyTCBStub.txHead > MyTCB.txUnackedTail) 
0236A:  MOVF   x70,W
0236C:  SUBWF  xCE,W
0236E:  BNC   240E
02370:  BNZ   2378
02372:  MOVF   xCD,W
02374:  SUBWF  x6F,W
02376:  BC    240E
....................       { 
....................          len = MyTCBStub.txHead - MyTCB.txUnackedTail; 
02378:  MOVF   x6F,W
0237A:  SUBWF  xCD,W
0237C:  MOVLB  2
0237E:  MOVWF  xBF
02380:  MOVLB  1
02382:  MOVF   x70,W
02384:  SUBWFB xCE,W
02386:  MOVLB  2
02388:  MOVWF  xC0
....................  
....................          if(len > MyTCB.remoteWindow) 
0238A:  MOVLB  1
0238C:  MOVF   x76,W
0238E:  MOVLB  2
02390:  SUBWF  xC0,W
02392:  BNC   23AE
02394:  BNZ   23A6
02396:  MOVF   xBF,W
02398:  MOVLB  1
0239A:  SUBWF  x75,W
0239C:  BTFSS  FD8.0
0239E:  BRA    23A4
023A0:  MOVLB  2
023A2:  BRA    23AE
023A4:  MOVLB  2
....................             len = MyTCB.remoteWindow; 
023A6:  MOVFF  176,2C0
023AA:  MOVFF  175,2BF
....................  
....................          if(len > MyTCB.wRemoteMSS) 
023AE:  MOVLB  1
023B0:  MOVF   x87,W
023B2:  MOVLB  2
023B4:  SUBWF  xC0,W
023B6:  BNC   23D8
023B8:  BNZ   23CA
023BA:  MOVF   xBF,W
023BC:  MOVLB  1
023BE:  SUBWF  x86,W
023C0:  BTFSS  FD8.0
023C2:  BRA    23C8
023C4:  MOVLB  2
023C6:  BRA    23D8
023C8:  MOVLB  2
....................          { 
....................             len = MyTCB.wRemoteMSS; 
023CA:  MOVFF  187,2C0
023CE:  MOVFF  186,2BF
....................             MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
023D2:  MOVLB  1
023D4:  BSF    xDF.2
023D6:  MOVLB  2
....................          } 
....................  
....................          // Copy application data into the raw TX buffer 
....................          TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER), TCP_ETH_RAM, MyTCB.txUnackedTail, MyTCBStub.vMemoryMedium, len); 
023D8:  MOVLW  18
023DA:  MOVWF  xC9
023DC:  MOVLW  1B
023DE:  MOVWF  xC8
023E0:  CLRF   xCA
023E2:  MOVFF  170,2CC
023E6:  MOVFF  16F,2CB
023EA:  MOVFF  1E2,2CD
023EE:  MOVFF  2C0,2CF
023F2:  MOVFF  2BF,2CE
023F6:  MOVLB  0
023F8:  CALL   11E8
....................          MyTCB.txUnackedTail += len; 
023FC:  MOVLB  2
023FE:  MOVF   xBF,W
02400:  MOVLB  1
02402:  ADDWF  x6F,F
02404:  MOVLB  2
02406:  MOVF   xC0,W
02408:  MOVLB  1
0240A:  ADDWFC x70,F
....................       } 
0240C:  BRA    2554
....................       else 
....................       { 
....................          pseudoHeader.Length = MyTCBStub.bufferRxStart - MyTCB.txUnackedTail; 
0240E:  MOVF   x6F,W
02410:  SUBWF  xC9,W
02412:  MOVLB  2
02414:  MOVWF  xBD
02416:  MOVLB  1
02418:  MOVF   x70,W
0241A:  SUBWFB xCA,W
0241C:  MOVLB  2
0241E:  MOVWF  xBE
....................          len = pseudoHeader.Length + MyTCBStub.txHead - MyTCBStub.bufferTxStart; 
02420:  MOVLB  1
02422:  MOVF   xCD,W
02424:  MOVLB  2
02426:  ADDWF  xBD,W
02428:  MOVWF  xC1
0242A:  MOVLB  1
0242C:  MOVF   xCE,W
0242E:  MOVLB  2
02430:  ADDWFC xBE,W
02432:  MOVWF  xC2
02434:  MOVLB  1
02436:  MOVF   xC7,W
02438:  MOVLB  2
0243A:  SUBWF  xC1,W
0243C:  MOVWF  xBF
0243E:  MOVLB  1
02440:  MOVF   xC8,W
02442:  MOVLB  2
02444:  SUBWFB xC2,W
02446:  MOVWF  xC0
....................  
....................          if(len > MyTCB.remoteWindow) 
02448:  MOVLB  1
0244A:  MOVF   x76,W
0244C:  MOVLB  2
0244E:  SUBWF  xC0,W
02450:  BNC   246C
02452:  BNZ   2464
02454:  MOVF   xBF,W
02456:  MOVLB  1
02458:  SUBWF  x75,W
0245A:  BTFSS  FD8.0
0245C:  BRA    2462
0245E:  MOVLB  2
02460:  BRA    246C
02462:  MOVLB  2
....................             len = MyTCB.remoteWindow; 
02464:  MOVFF  176,2C0
02468:  MOVFF  175,2BF
....................  
....................          if(len > MyTCB.wRemoteMSS) 
0246C:  MOVLB  1
0246E:  MOVF   x87,W
02470:  MOVLB  2
02472:  SUBWF  xC0,W
02474:  BNC   2496
02476:  BNZ   2488
02478:  MOVF   xBF,W
0247A:  MOVLB  1
0247C:  SUBWF  x86,W
0247E:  BTFSS  FD8.0
02480:  BRA    2486
02482:  MOVLB  2
02484:  BRA    2496
02486:  MOVLB  2
....................          { 
....................             len = MyTCB.wRemoteMSS; 
02488:  MOVFF  187,2C0
0248C:  MOVFF  186,2BF
....................             MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
02490:  MOVLB  1
02492:  BSF    xDF.2
02494:  MOVLB  2
....................          } 
....................  
....................          if(pseudoHeader.Length > len) 
02496:  MOVF   xC0,W
02498:  SUBWF  xBE,W
0249A:  BNC   24AC
0249C:  BNZ   24A4
0249E:  MOVF   xBD,W
024A0:  SUBWF  xBF,W
024A2:  BC    24AC
....................             pseudoHeader.Length = len; 
024A4:  MOVFF  2C0,2BE
024A8:  MOVFF  2BF,2BD
....................  
....................          // Copy application data into the raw TX buffer 
....................          TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER), TCP_ETH_RAM, MyTCB.txUnackedTail, MyTCBStub.vMemoryMedium, pseudoHeader.Length); 
024AC:  MOVLW  18
024AE:  MOVWF  xC9
024B0:  MOVLW  1B
024B2:  MOVWF  xC8
024B4:  CLRF   xCA
024B6:  MOVFF  170,2CC
024BA:  MOVFF  16F,2CB
024BE:  MOVFF  1E2,2CD
024C2:  MOVFF  2BE,2CF
024C6:  MOVFF  2BD,2CE
024CA:  MOVLB  0
024CC:  CALL   11E8
....................          pseudoHeader.Length = len - pseudoHeader.Length; 
024D0:  MOVLB  2
024D2:  MOVF   xBD,W
024D4:  SUBWF  xBF,W
024D6:  MOVWF  xBD
024D8:  MOVF   xBE,W
024DA:  SUBWFB xC0,W
024DC:  MOVWF  xBE
....................     
....................          // Copy any left over chunks of application data over 
....................          if(pseudoHeader.Length) 
024DE:  MOVF   xBD,W
024E0:  IORWF  xBE,W
024E2:  BZ    2524
....................          { 
....................             TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER)+(MyTCBStub.bufferRxStart-MyTCB.txUnackedTail), TCP_ETH_RAM, MyTCBStub.bufferTxStart, MyTCBStub.vMemoryMedium, pseudoHeader.Length); 
024E4:  MOVLB  1
024E6:  MOVF   x6F,W
024E8:  SUBWF  xC9,W
024EA:  MOVWF  00
024EC:  MOVF   x70,W
024EE:  SUBWFB xCA,W
024F0:  MOVWF  03
024F2:  MOVF   00,W
024F4:  ADDLW  1B
024F6:  MOVLB  2
024F8:  MOVWF  xC1
024FA:  MOVLW  18
024FC:  ADDWFC 03,W
024FE:  MOVWF  xC2
02500:  MOVWF  xC9
02502:  MOVFF  2C1,2C8
02506:  CLRF   xCA
02508:  MOVFF  1C8,2CC
0250C:  MOVFF  1C7,2CB
02510:  MOVFF  1E2,2CD
02514:  MOVFF  2BE,2CF
02518:  MOVFF  2BD,2CE
0251C:  MOVLB  0
0251E:  CALL   11E8
02522:  MOVLB  2
....................          } 
....................  
....................          MyTCB.txUnackedTail += len; 
02524:  MOVF   xBF,W
02526:  MOVLB  1
02528:  ADDWF  x6F,F
0252A:  MOVLB  2
0252C:  MOVF   xC0,W
0252E:  MOVLB  1
02530:  ADDWFC x70,F
....................          if(MyTCB.txUnackedTail >= MyTCBStub.bufferRxStart) 
02532:  MOVF   xCA,W
02534:  SUBWF  x70,W
02536:  BNC   2554
02538:  BNZ   2540
0253A:  MOVF   xC9,W
0253C:  SUBWF  x6F,W
0253E:  BNC   2554
....................             MyTCB.txUnackedTail -= MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart; 
02540:  MOVF   xC7,W
02542:  SUBWF  xC9,W
02544:  MOVWF  00
02546:  MOVF   xC8,W
02548:  SUBWFB xCA,W
0254A:  MOVWF  03
0254C:  MOVF   00,W
0254E:  SUBWF  x6F,F
02550:  MOVF   03,W
02552:  SUBWFB x70,F
02554:  MOVLB  2
....................       } 
....................  
....................       // If we are to transmit a FIN, make sure we can put one in this packet 
....................       if(MyTCBStub.Flags.bTXFIN) 
02556:  MOVLB  1
02558:  BTFSS  xDF.3
0255A:  BRA    2586
....................       { 
....................          if((len != MyTCB.remoteWindow) && (len != MyTCB.wRemoteMSS)) 
0255C:  MOVF   x75,W
0255E:  MOVLB  2
02560:  SUBWF  xBF,W
02562:  BNZ   256E
02564:  MOVLB  1
02566:  MOVF   x76,W
02568:  MOVLB  2
0256A:  SUBWF  xC0,W
0256C:  BZ    2584
0256E:  MOVLB  1
02570:  MOVF   x86,W
02572:  MOVLB  2
02574:  SUBWF  xBF,W
02576:  BNZ   2582
02578:  MOVLB  1
0257A:  MOVF   x87,W
0257C:  MOVLB  2
0257E:  SUBWF  xC0,W
02580:  BZ    2584
....................             vTCPFlags |= FIN; 
02582:  BSF    x97.0
02584:  MOVLB  1
....................       } 
....................    } 
....................  
....................    // Ensure that all packets with data of some kind are  
....................    // retransmitted by TCPTick() until acknowledged 
....................    // Pure ACK packets with no data are not ACKed back in TCP 
....................    if(len || (vTCPFlags & (SYN | FIN))) 
02586:  MOVLB  2
02588:  MOVF   xBF,W
0258A:  IORWF  xC0,W
0258C:  BNZ   2594
0258E:  MOVF   x97,W
02590:  ANDLW  03
02592:  BZ    25F8
....................    { 
....................       // Transmitting data, update remote window variable to reflect smaller  
....................       // window. 
....................       MyTCB.remoteWindow -= len; 
02594:  MOVF   xBF,W
02596:  MOVLB  1
02598:  SUBWF  x75,F
0259A:  MOVLB  2
0259C:  MOVF   xC0,W
0259E:  MOVLB  1
025A0:  SUBWFB x76,F
....................  
....................       // Push (PSH) all data for enhanced responsiveness on  
....................       // the remote end, especially with GUIs 
....................       if(len) 
025A2:  MOVLB  2
025A4:  MOVF   xBF,W
025A6:  IORWF  xC0,W
025A8:  BZ    25AC
....................          vTCPFlags |= PSH; 
025AA:  BSF    x97.3
....................  
....................       if(vSendFlags & SENDTCP_RESET_TIMERS) 
025AC:  BTFSS  x98.0
025AE:  BRA    25C2
....................       { 
....................          MyTCB.retryCount = 0; 
025B0:  MOVLB  1
025B2:  CLRF   x88
....................          MyTCB.retryInterval = TCP_START_TIMEOUT_VAL; 
025B4:  CLRF   x66
025B6:  CLRF   x65
025B8:  MOVLW  98
025BA:  MOVWF  x64
025BC:  MOVLW  97
025BE:  MOVWF  x63
025C0:  MOVLB  2
....................       }    
....................  
....................       MyTCBStub.eventTime = TickGet() + MyTCB.retryInterval; 
025C2:  MOVLB  0
025C4:  CALL   1734
025C8:  MOVLB  1
025CA:  MOVF   x63,W
025CC:  MOVLB  2
025CE:  ADDWF  00,W
025D0:  MOVLB  1
025D2:  MOVWF  xD5
025D4:  MOVF   x64,W
025D6:  MOVLB  2
025D8:  ADDWFC 01,W
025DA:  MOVLB  1
025DC:  MOVWF  xD6
025DE:  MOVF   x65,W
025E0:  MOVLB  2
025E2:  ADDWFC 02,W
025E4:  MOVLB  1
025E6:  MOVWF  xD7
025E8:  MOVF   x66,W
025EA:  MOVLB  2
025EC:  ADDWFC 03,W
025EE:  MOVLB  1
025F0:  MOVWF  xD8
....................       MyTCBStub.Flags.bTimerEnabled = 1; 
025F2:  BSF    xDE.4
....................    } 
025F4:  BRA    2674
025F6:  MOVLB  2
....................    else if(vSendFlags & SENDTCP_KEEP_ALIVE) 
025F8:  BTFSS  x98.1
025FA:  BRA    2624
....................    { 
....................       // Increment Keep Alive TX counter to handle disconnection if not response is returned 
....................       MyTCBStub.Flags.vUnackedKeepalives++; 
025FC:  MOVLB  1
025FE:  MOVF   xDE,W
02600:  ADDLW  01
02602:  ANDLW  07
02604:  MOVWF  00
02606:  MOVLW  F8
02608:  ANDWF  xDE,W
0260A:  IORWF  00,W
0260C:  MOVWF  xDE
....................        
....................       // Generate a dummy byte 
....................       MyTCB.MySEQ -= 1; 
0260E:  MOVLW  01
02610:  SUBWF  x67,F
02612:  MOVLW  00
02614:  SUBWFB x68,F
02616:  SUBWFB x69,F
02618:  SUBWFB x6A,F
....................       len = 1; 
0261A:  MOVLB  2
0261C:  CLRF   xC0
0261E:  MOVLW  01
02620:  MOVWF  xBF
....................    } 
02622:  BRA    2676
....................    else if(MyTCBStub.Flags.bTimerEnabled)  
02624:  MOVLB  1
02626:  BTFSS  xDE.4
02628:  BRA    2674
....................    { 
....................       // If we have data to transmit, but the remote RX window is zero,  
....................       // so we aren't transmitting any right now then make sure to not  
....................       // extend the retry counter or timer.  This will stall our TX  
....................       // with a periodic ACK sent to the remote node. 
....................       if(!(vSendFlags & SENDTCP_RESET_TIMERS)) 
0262A:  MOVLB  2
0262C:  BTFSC  x98.0
0262E:  BRA    2644
....................       { 
....................          // Roll back retry counters since we can't send anything,  
....................          // but only if we incremented it in the first place 
....................          if(MyTCB.retryCount) 
02630:  MOVLB  1
02632:  MOVF   x88,F
02634:  BZ    2642
....................          { 
....................             MyTCB.retryCount--; 
02636:  DECF   x88,F
....................             MyTCB.retryInterval >>= 1; 
02638:  BCF    FD8.0
0263A:  RRCF   x66,F
0263C:  RRCF   x65,F
0263E:  RRCF   x64,F
02640:  RRCF   x63,F
02642:  MOVLB  2
....................          } 
....................       } 
....................     
....................       MyTCBStub.eventTime = TickGet() + MyTCB.retryInterval; 
02644:  MOVLB  0
02646:  CALL   1734
0264A:  MOVLB  1
0264C:  MOVF   x63,W
0264E:  MOVLB  2
02650:  ADDWF  00,W
02652:  MOVLB  1
02654:  MOVWF  xD5
02656:  MOVF   x64,W
02658:  MOVLB  2
0265A:  ADDWFC 01,W
0265C:  MOVLB  1
0265E:  MOVWF  xD6
02660:  MOVF   x65,W
02662:  MOVLB  2
02664:  ADDWFC 02,W
02666:  MOVLB  1
02668:  MOVWF  xD7
0266A:  MOVF   x66,W
0266C:  MOVLB  2
0266E:  ADDWFC 03,W
02670:  MOVLB  1
02672:  MOVWF  xD8
02674:  MOVLB  2
....................    } 
....................     
....................  
....................    header.SourcePort         = MyTCB.localPort.Val; 
02676:  MOVFF  174,29C
0267A:  MOVFF  173,29B
....................    header.DestPort            = MyTCB.remotePort.Val; 
0267E:  MOVFF  172,29E
02682:  MOVFF  171,29D
....................    header.SeqNumber         = MyTCB.MySEQ; 
02686:  MOVFF  16A,2A2
0268A:  MOVFF  169,2A1
0268E:  MOVFF  168,2A0
02692:  MOVFF  167,29F
....................    header.AckNumber         = MyTCB.RemoteSEQ; 
02696:  MOVFF  16E,2A6
0269A:  MOVFF  16D,2A5
0269E:  MOVFF  16C,2A4
026A2:  MOVFF  16B,2A3
....................    header.Flags.bits.Reserved2   = 0; 
026A6:  MOVLW  3F
026A8:  ANDWF  xA8,W
026AA:  MOVWF  xA8
....................    header.DataOffset.Reserved3   = 0; 
026AC:  MOVLW  F0
026AE:  ANDWF  xA7,W
026B0:  MOVWF  xA7
....................    header.Flags.byte         = vTCPFlags; 
026B2:  MOVFF  297,2A8
....................    header.UrgentPointer        = 0; 
026B6:  CLRF   xAE
026B8:  CLRF   xAD
....................  
....................    // Update our send sequence number and ensure retransmissions  
....................    // of SYNs and FINs use the right sequence number 
....................    MyTCB.MySEQ += (DWORD)len; 
026BA:  MOVFF  2C0,01
026BE:  CLRF   02
026C0:  CLRF   03
026C2:  MOVF   xBF,W
026C4:  MOVLB  1
026C6:  ADDWF  x67,F
026C8:  MOVF   01,W
026CA:  ADDWFC x68,F
026CC:  MOVF   02,W
026CE:  ADDWFC x69,F
026D0:  MOVF   03,W
026D2:  ADDWFC x6A,F
....................    if(vTCPFlags & SYN) 
026D4:  MOVLB  2
026D6:  BTFSS  x97.1
026D8:  BRA    2716
....................    { 
....................       // SEG.ACK needs to be zero for the first SYN packet for compatibility  
....................       // with certain paranoid TCP/IP stacks, even though the ACK flag isn't  
....................       // set (indicating that the AckNumber field is unused). 
....................       if(!(vTCPFlags & ACK)) 
026DA:  BTFSC  x97.4
026DC:  BRA    26E6
....................          header.AckNumber = 0x00000000; 
026DE:  CLRF   xA6
026E0:  CLRF   xA5
026E2:  CLRF   xA4
026E4:  CLRF   xA3
....................  
....................       if(MyTCB.flags.bSYNSent) 
026E6:  MOVLB  1
026E8:  BTFSS  x85.1
026EA:  BRA    2702
....................          header.SeqNumber--; 
026EC:  MOVLW  FF
026EE:  MOVLB  2
026F0:  ADDWF  x9F,F
026F2:  BTFSS  FD8.0
026F4:  ADDWF  xA0,F
026F6:  BTFSS  FD8.0
026F8:  ADDWF  xA1,F
026FA:  BTFSS  FD8.0
026FC:  ADDWF  xA2,F
026FE:  BRA    2716
02700:  MOVLB  1
....................       else 
....................       { 
....................          MyTCB.MySEQ++; 
02702:  MOVLW  01
02704:  ADDWF  x67,F
02706:  BTFSC  FD8.0
02708:  INCF   x68,F
0270A:  BTFSC  FD8.2
0270C:  INCF   x69,F
0270E:  BTFSC  FD8.2
02710:  INCF   x6A,F
....................          MyTCB.flags.bSYNSent = 1; 
02712:  BSF    x85.1
02714:  MOVLB  2
....................       } 
....................    } 
....................    if(vTCPFlags & FIN) 
02716:  BTFSS  x97.0
02718:  BRA    2720
....................    { 
....................         MyTCB.flags.bFINSent = 1;   // do not advance the seq no for FIN! 
0271A:  MOVLB  1
0271C:  BSF    x85.0
0271E:  MOVLB  2
....................    } 
....................  
....................    // Calculate the amount of free space in the RX buffer area of this socket 
....................    if(MyTCBStub.rxHead >= MyTCBStub.rxTail) 
02720:  MOVLB  1
02722:  MOVF   xD4,W
02724:  SUBWF  xD2,W
02726:  BNC   2762
02728:  BNZ   2730
0272A:  MOVF   xD3,W
0272C:  SUBWF  xD1,W
0272E:  BNC   2762
....................       header.Window = (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart) - (MyTCBStub.rxHead - MyTCBStub.rxTail); 
02730:  MOVF   xC9,W
02732:  SUBWF  xCB,W
02734:  MOVLB  2
02736:  MOVWF  xC1
02738:  MOVLB  1
0273A:  MOVF   xCA,W
0273C:  SUBWFB xCC,W
0273E:  MOVLB  2
02740:  MOVWF  xC2
02742:  MOVLB  1
02744:  MOVF   xD3,W
02746:  SUBWF  xD1,W
02748:  MOVWF  00
0274A:  MOVF   xD4,W
0274C:  SUBWFB xD2,W
0274E:  MOVWF  03
02750:  MOVF   00,W
02752:  MOVLB  2
02754:  SUBWF  xC1,W
02756:  MOVWF  xA9
02758:  MOVF   03,W
0275A:  SUBWFB xC2,W
0275C:  MOVWF  xAA
0275E:  BRA    2780
02760:  MOVLB  1
....................    else 
....................       header.Window = MyTCBStub.rxTail - MyTCBStub.rxHead - 1; 
02762:  MOVF   xD1,W
02764:  SUBWF  xD3,W
02766:  MOVLB  2
02768:  MOVWF  xC1
0276A:  MOVLB  1
0276C:  MOVF   xD2,W
0276E:  SUBWFB xD4,W
02770:  MOVLB  2
02772:  MOVWF  xC2
02774:  MOVLW  01
02776:  SUBWF  xC1,W
02778:  MOVWF  xA9
0277A:  MOVLW  00
0277C:  SUBWFB xC2,W
0277E:  MOVWF  xAA
....................  
....................    // Calculate the amount of free space in the MAC RX buffer area and adjust window if needed 
....................    wVal.Val = MACGetFreeRxSize(); 
02780:  MOVLB  0
02782:  GOTO   175C
02786:  MOVFF  02,29A
0278A:  MOVFF  01,299
....................    if(wVal.Val < 64) 
0278E:  MOVLB  2
02790:  MOVF   x9A,F
02792:  BNZ   27A0
02794:  MOVF   x99,W
02796:  SUBLW  3F
02798:  BNC   27A0
....................     { 
....................       wVal.Val = 0; 
0279A:  CLRF   x9A
0279C:  CLRF   x99
....................     } 
0279E:  BRA    27A8
....................     else 
....................     { 
....................       wVal.Val -= 64; 
027A0:  MOVLW  40
027A2:  SUBWF  x99,F
027A4:  MOVLW  00
027A6:  SUBWFB x9A,F
....................     } 
....................    // Force the remote node to throttle back if we are running low on general RX buffer space 
....................    if(header.Window > wVal.Val) 
027A8:  MOVF   x9A,W
027AA:  SUBWF  xAA,W
027AC:  BNC   27BE
027AE:  BNZ   27B6
027B0:  MOVF   xA9,W
027B2:  SUBWF  x99,W
027B4:  BC    27BE
....................       header.Window = wVal.Val; 
027B6:  MOVFF  29A,2AA
027BA:  MOVFF  299,2A9
....................  
....................    SwapTCPHeader(&header); 
027BE:  MOVLW  02
027C0:  MOVWF  xC2
027C2:  MOVLW  9B
027C4:  MOVWF  xC1
027C6:  MOVLB  0
027C8:  CALL   1A0C
....................  
....................  
....................    len += sizeof(header); 
027CC:  MOVLW  14
027CE:  MOVLB  2
027D0:  ADDWF  xBF,F
027D2:  MOVLW  00
027D4:  ADDWFC xC0,F
....................    header.DataOffset.Val   = sizeof(header) >> 2; 
027D6:  MOVLW  0F
027D8:  ANDWF  xA7,W
027DA:  IORLW  50
027DC:  MOVWF  xA7
....................  
....................    // Insert the MSS (Maximum Segment Size) TCP option if this is SYN packet 
....................    if(vTCPFlags & SYN) 
027DE:  BTFSS  x97.1
027E0:  BRA    2810
....................    { 
....................       len += sizeof(options); 
027E2:  MOVLW  04
027E4:  ADDWF  xBF,F
027E6:  MOVLW  00
027E8:  ADDWFC xC0,F
....................       options.Kind = TCP_OPTIONS_MAX_SEG_SIZE; 
027EA:  MOVLW  02
027EC:  MOVWF  xAF
....................       options.Length = 0x04; 
027EE:  MOVLW  04
027F0:  MOVWF  xB0
....................  
....................       // Load MSS and swap to big endian 
....................       options.MaxSegSize.Val = (((TCP_MAX_SEG_SIZE_RX)&0x00FF)<<8) | (((TCP_MAX_SEG_SIZE_RX)&0xFF00)>>8); 
027F2:  MOVLW  18
027F4:  MOVWF  xB2
027F6:  MOVLW  02
027F8:  MOVWF  xB1
....................  
....................      #if defined(__PCD__)  //__PCD__ __PCH__ __CCS__ bug 
....................       unsigned int8 scr8; 
....................       scr8 = header.DataOffset.Val; 
....................       scr8 += sizeof(options) >> 2; 
....................       header.DataOffset.Val = scr8; 
....................      #else  //standard code 
....................       header.DataOffset.Val   += sizeof(options) >> 2; 
027FA:  SWAPF  xA7,W
027FC:  ANDLW  0F
027FE:  ADDLW  01
02800:  MOVWF  00
02802:  SWAPF  00,W
02804:  ANDLW  F0
02806:  MOVWF  00
02808:  MOVLW  0F
0280A:  ANDWF  xA7,W
0280C:  IORWF  00,W
0280E:  MOVWF  xA7
....................      #endif 
....................    } 
....................  
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress   = AppConfig.MyIPAddr; 
02810:  MOVFF  2C,2B6
02814:  MOVFF  2B,2B5
02818:  MOVFF  2A,2B4
0281C:  MOVFF  29,2B3
....................    pseudoHeader.DestAddress    = MyTCB.remote.niRemoteMACIP.IPAddr; 
02820:  MOVFF  17C,2BA
02824:  MOVFF  17B,2B9
02828:  MOVFF  17A,2B8
0282C:  MOVFF  179,2B7
....................    pseudoHeader.Zero           = 0x0; 
02830:  CLRF   xBB
....................    pseudoHeader.Protocol       = IP_PROT_TCP; 
02832:  MOVLW  06
02834:  MOVWF  xBC
....................    pseudoHeader.Length         = len; 
02836:  MOVFF  2C0,2BE
0283A:  MOVFF  2BF,2BD
....................    SwapPseudoHeader(pseudoHeader); 
0283E:  MOVFF  2BE,2E1
02842:  MOVFF  2BD,2E0
02846:  MOVLB  0
02848:  CALL   1874
0284C:  MOVFF  02,2BE
02850:  MOVFF  01,2BD
....................    header.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader, sizeof(pseudoHeader)); 
02854:  MOVLW  02
02856:  MOVLB  2
02858:  MOVWF  xC2
0285A:  MOVLW  B3
0285C:  MOVWF  xC1
0285E:  MOVFF  2C2,2DD
02862:  MOVWF  xDC
02864:  CLRF   xDF
02866:  MOVLW  0C
02868:  MOVWF  xDE
0286A:  MOVLB  0
0286C:  CALL   1C28
02870:  MOVFF  01,2AB
02874:  MOVLB  2
02876:  COMF   xAB,F
02878:  MOVFF  02,2AC
0287C:  COMF   xAC,F
....................  
....................    // Write IP header 
....................    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER)); 
0287E:  MOVLW  17
02880:  MOVWF  xD1
02882:  MOVLW  F3
02884:  MOVWF  xD0
02886:  MOVLB  0
02888:  CALL   0D6C
....................    IPPutHeader(&MyTCB.remote.niRemoteMACIP, IP_PROT_TCP, len); 
0288C:  MOVLW  01
0288E:  MOVLB  2
02890:  MOVWF  xC2
02892:  MOVLW  79
02894:  MOVWF  xC1
02896:  MOVLW  06
02898:  MOVWF  xC3
0289A:  MOVFF  2C0,2C5
0289E:  MOVFF  2BF,2C4
028A2:  MOVLB  0
028A4:  CALL   1EB0
....................    MACPutArray((BYTE*)&header, sizeof(header)); 
028A8:  MOVLW  02
028AA:  MOVLB  2
028AC:  MOVWF  xC2
028AE:  MOVLW  9B
028B0:  MOVWF  xC1
028B2:  MOVFF  2C2,2E6
028B6:  MOVWF  xE5
028B8:  CLRF   xE8
028BA:  MOVLW  14
028BC:  MOVWF  xE7
028BE:  MOVLB  0
028C0:  CALL   0DDC
....................    if(vTCPFlags & SYN) 
028C4:  MOVLB  2
028C6:  BTFSS  x97.1
028C8:  BRA    28E6
....................       MACPutArray((BYTE*)&options, sizeof(options)); 
028CA:  MOVLW  02
028CC:  MOVWF  xC2
028CE:  MOVLW  AF
028D0:  MOVWF  xC1
028D2:  MOVFF  2C2,2E6
028D6:  MOVWF  xE5
028D8:  CLRF   xE8
028DA:  MOVLW  04
028DC:  MOVWF  xE7
028DE:  MOVLB  0
028E0:  CALL   0DDC
028E4:  MOVLB  2
....................  
....................    // Update the TCP checksum 
....................    MACSetReadPtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER)); 
028E6:  MOVLW  18
028E8:  MOVWF  xD1
028EA:  MOVLW  07
028EC:  MOVWF  xD0
028EE:  MOVLB  0
028F0:  CALL   0E22
....................    wVal.Val = CalcIPBufferChecksum(len); 
028F4:  MOVFF  2C0,2C2
028F8:  MOVFF  2BF,2C1
028FC:  CALL   1F9A
02900:  MOVFF  02,29A
02904:  MOVFF  01,299
.................... #if defined(DEBUG_GENERATE_TX_LOSS) 
....................    // Damage TCP checksums on TX packets randomly 
....................    if(LFSRRand() > DEBUG_GENERATE_TX_LOSS) 
....................    { 
....................       wVal.Val++; 
....................    } 
.................... #endif 
....................    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER) + 16); 
02908:  MOVLW  18
0290A:  MOVLB  2
0290C:  MOVWF  xD1
0290E:  MOVLW  17
02910:  MOVWF  xD0
02912:  MOVLB  0
02914:  CALL   0D6C
....................    MACPutArray((BYTE*)&wVal, sizeof(WORD)); 
02918:  MOVLW  02
0291A:  MOVLB  2
0291C:  MOVWF  xC2
0291E:  MOVLW  99
02920:  MOVWF  xC1
02922:  MOVFF  2C2,2E6
02926:  MOVWF  xE5
02928:  CLRF   xE8
0292A:  MOVLW  02
0292C:  MOVWF  xE7
0292E:  MOVLB  0
02930:  CALL   0DDC
....................  
....................    // Physically start the packet transmission over the network 
....................    MACFlush(); 
02934:  CALL   20E2
02938:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static BOOL FindMatchingTCPSocket(TCP_HEADER* h, NODE_INFO* remote) 
....................  
....................   Summary: 
....................    Finds a suitable socket for a TCP segment. 
....................  
....................   Description: 
....................    This function searches through the sockets and attempts to match one with 
....................    a given TCP header and NODE_INFO structure.  If a socket is found, its  
....................    index is saved in hCurrentTCP and the associated MyTCBStub and MyTCB are 
....................    loaded. Otherwise, INVALID_SOCKET is placed in hCurrentTCP. 
....................     
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    h - TCP header to be matched against 
....................    remote - The remote node who sent this header 
....................  
....................   Return Values: 
....................    TRUE - A match was found and is loaded in hCurrentTCP 
....................    FALSE - No suitable socket was found and hCurrentTCP is INVALID_SOCKET 
....................   ***************************************************************************/ 
.................... static BOOL FindMatchingTCPSocket(TCP_HEADER* h, NODE_INFO* remote) 
.................... { 
....................    TCP_SOCKET hTCP; 
....................    TCP_SOCKET partialMatch; 
....................    WORD hash; 
....................  
....................    // Prevent connections on invalid port 0 
....................    if(h->DestPort == 0u) 
*
05774:  MOVLW  02
05776:  MOVLB  2
05778:  ADDWF  x77,W
0577A:  MOVWF  FE9
0577C:  MOVLW  00
0577E:  ADDWFC x78,W
05780:  MOVWF  FEA
05782:  MOVFF  FEC,282
05786:  MOVF   FED,F
05788:  MOVFF  FEF,281
0578C:  MOVF   x81,F
0578E:  BNZ   579A
05790:  MOVF   x82,F
05792:  BNZ   579A
....................       return FALSE; 
05794:  MOVLW  00
05796:  MOVWF  01
05798:  BRA    5D94
....................  
....................    partialMatch = INVALID_SOCKET; 
0579A:  MOVLW  FE
0579C:  MOVWF  x7C
....................    hash = (remote->IPAddr.w[1]+remote->IPAddr.w[0] + h->SourcePort) ^ h->DestPort; 
0579E:  MOVLW  02
057A0:  ADDWF  x79,W
057A2:  MOVWF  FE9
057A4:  MOVLW  00
057A6:  ADDWFC x7A,W
057A8:  MOVWF  FEA
057AA:  MOVFF  FEC,282
057AE:  MOVF   FED,F
057B0:  MOVFF  FEF,281
057B4:  MOVFF  279,FE9
057B8:  MOVFF  27A,FEA
057BC:  MOVFF  FEC,03
057C0:  MOVF   FED,F
057C2:  MOVF   FEF,W
057C4:  ADDWF  x81,F
057C6:  MOVF   03,W
057C8:  ADDWFC x82,F
057CA:  MOVFF  277,FE9
057CE:  MOVFF  278,FEA
057D2:  MOVFF  FEC,03
057D6:  MOVF   FED,F
057D8:  MOVF   FEF,W
057DA:  ADDWF  x81,F
057DC:  MOVF   03,W
057DE:  ADDWFC x82,F
057E0:  MOVLW  02
057E2:  ADDWF  x77,W
057E4:  MOVWF  FE9
057E6:  MOVLW  00
057E8:  ADDWFC x78,W
057EA:  MOVWF  FEA
057EC:  MOVFF  FEC,03
057F0:  MOVF   FED,F
057F2:  MOVF   FEF,W
057F4:  XORWF  x81,W
057F6:  MOVWF  x7D
057F8:  MOVF   03,W
057FA:  XORWF  x82,W
057FC:  MOVWF  x7E
....................  
....................    // Loop through all sockets looking for a socket that is expecting this  
....................    // packet or can handle it. 
....................    for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++ ) 
057FE:  CLRF   x7B
05800:  MOVF   x7B,F
05802:  BTFSS  FD8.2
05804:  BRA    5908
....................    { 
....................       SyncTCBStub(hTCP); 
05806:  MOVFF  27B,281
0580A:  MOVLB  0
0580C:  CALL   0CCA
....................  
....................       if(MyTCBStub.smState == TCP_CLOSED) 
05810:  MOVLB  1
05812:  MOVF   xDD,W
05814:  SUBLW  0D
05816:  BNZ   581C
....................       { 
....................          continue; 
05818:  BRA    5902
....................       } 
0581A:  BRA    5862
....................       else if(MyTCBStub.smState == TCP_LISTEN) 
0581C:  MOVF   xDD,W
0581E:  SUBLW  04
05820:  BNZ   584C
....................       {// For listening ports, check if this is the correct port 
....................          if(MyTCBStub.remoteHash.Val == h->DestPort) 
05822:  MOVLW  02
05824:  MOVLB  2
05826:  ADDWF  x77,W
05828:  MOVWF  FE9
0582A:  MOVLW  00
0582C:  ADDWFC x78,W
0582E:  MOVWF  FEA
05830:  MOVFF  FEC,03
05834:  MOVF   FED,F
05836:  MOVF   FEF,W
05838:  MOVLB  1
0583A:  SUBWF  xE0,W
0583C:  BNZ   5848
0583E:  MOVF   03,W
05840:  SUBWF  xE1,W
05842:  BNZ   5848
....................             partialMatch = hTCP; 
05844:  MOVFF  27B,27C
....................           
....................          #if defined(STACK_USE_SSL_SERVER) 
....................          // Check the SSL port as well for SSL Servers 
....................          // 0 is defined as an invalid port number 
....................          if(MyTCBStub.sslTxHead == h->DestPort) 
....................             partialMatch = hTCP; 
....................          #endif 
....................           
....................          continue; 
05848:  BRA    5902
....................       } 
0584A:  BRA    5862
....................       else if(MyTCBStub.remoteHash.Val != hash) 
0584C:  MOVLB  2
0584E:  MOVF   x7D,W
05850:  MOVLB  1
05852:  SUBWF  xE0,W
05854:  BNZ   5860
05856:  MOVLB  2
05858:  MOVF   x7E,W
0585A:  MOVLB  1
0585C:  SUBWF  xE1,W
0585E:  BZ    5862
....................       {// Ignore if the hash doesn't match 
....................          continue; 
05860:  BRA    5902
....................       } 
....................  
....................       SyncTCB(); 
05862:  MOVLB  0
05864:  CALL   12CE
....................       if(   h->DestPort == MyTCB.localPort.Val && 
....................          h->SourcePort == MyTCB.remotePort.Val && 
....................          remote->IPAddr.Val == MyTCB.remote.niRemoteMACIP.IPAddr.Val) 
05868:  MOVLW  02
0586A:  MOVLB  2
0586C:  ADDWF  x77,W
0586E:  MOVWF  FE9
05870:  MOVLW  00
05872:  ADDWFC x78,W
05874:  MOVWF  FEA
05876:  MOVFF  FEC,282
0587A:  MOVF   FED,F
0587C:  MOVFF  FEF,281
05880:  MOVLB  1
05882:  MOVF   x73,W
05884:  MOVLB  2
05886:  SUBWF  x81,W
05888:  BNZ   5900
0588A:  MOVLB  1
0588C:  MOVF   x74,W
0588E:  MOVLB  2
05890:  SUBWF  x82,W
05892:  BNZ   5900
05894:  MOVFF  277,FE9
05898:  MOVFF  278,FEA
0589C:  MOVFF  FEC,282
058A0:  MOVF   FED,F
058A2:  MOVFF  FEF,281
058A6:  MOVLB  1
058A8:  MOVF   x71,W
058AA:  MOVLB  2
058AC:  SUBWF  x81,W
058AE:  BNZ   5900
058B0:  MOVLB  1
058B2:  MOVF   x72,W
058B4:  MOVLB  2
058B6:  SUBWF  x82,W
058B8:  BNZ   5900
058BA:  MOVFF  279,FE9
058BE:  MOVFF  27A,FEA
058C2:  MOVFF  FEF,281
058C6:  MOVFF  FEC,282
058CA:  MOVFF  FEC,283
058CE:  MOVFF  FEC,284
058D2:  MOVLB  1
058D4:  MOVF   x79,W
058D6:  MOVLB  2
058D8:  SUBWF  x81,W
058DA:  BNZ   5900
058DC:  MOVLB  1
058DE:  MOVF   x7A,W
058E0:  MOVLB  2
058E2:  SUBWF  x82,W
058E4:  BNZ   5900
058E6:  MOVLB  1
058E8:  MOVF   x7B,W
058EA:  MOVLB  2
058EC:  SUBWF  x83,W
058EE:  BNZ   5900
058F0:  MOVLB  1
058F2:  MOVF   x7C,W
058F4:  MOVLB  2
058F6:  SUBWF  x84,W
058F8:  BNZ   5900
....................       { 
....................          return TRUE; 
058FA:  MOVLW  01
058FC:  MOVWF  01
058FE:  BRA    5D94
05900:  MOVLB  1
....................       } 
05902:  MOVLB  2
05904:  INCF   x7B,F
05906:  BRA    5800
....................    } 
....................  
....................  
....................    // If there is a partial match, then a listening socket is currently  
....................    // available.  Set up the extended TCB with the info needed  
....................    // to establish a connection and return this socket to the  
....................    // caller. 
....................    if(partialMatch != INVALID_SOCKET) 
05908:  MOVF   x7C,W
0590A:  SUBLW  FE
0590C:  BZ    5982
....................    { 
....................       SyncTCBStub(partialMatch); 
0590E:  MOVFF  27C,281
05912:  MOVLB  0
05914:  CALL   0CCA
....................       SyncTCB(); 
05918:  CALL   12CE
....................     
....................       // For SSL ports, begin the SSL Handshake 
....................       #if defined(STACK_USE_SSL_SERVER) 
....................       if(MyTCBStub.sslTxHead == h->DestPort) 
....................       { 
....................          // Try to start an SSL session.  If no stubs are available, 
....................          // we can't service this request right now, so ignore it. 
....................          if(!TCPStartSSLServer(partialMatch)) 
....................             partialMatch = INVALID_SOCKET; 
....................       } 
....................       #endif 
....................     
....................       // Make sure the above check didn't fail (this is unfortunately  
....................       // redundant for non-SSL sockets).  Otherwise, fall out to below 
....................       // and add to the SYN queue. 
....................       if(partialMatch != INVALID_SOCKET) 
0591C:  MOVLB  2
0591E:  MOVF   x7C,W
05920:  SUBLW  FE
05922:  BZ    5982
....................       { 
....................          MyTCBStub.remoteHash.Val = hash; 
05924:  MOVFF  27E,1E1
05928:  MOVFF  27D,1E0
....................        
....................          memcpy((void*)&MyTCB.remote, (void*)remote, sizeof(NODE_INFO)); 
0592C:  MOVLW  01
0592E:  MOVWF  x82
05930:  MOVLW  79
05932:  MOVFF  282,FEA
05936:  MOVWF  FE9
05938:  MOVFF  27A,FE2
0593C:  MOVFF  279,FE1
05940:  MOVLW  0A
05942:  MOVWF  01
05944:  MOVFF  FE6,FEE
05948:  DECFSZ 01,F
0594A:  BRA    5944
....................          MyTCB.remotePort.Val = h->SourcePort; 
0594C:  MOVFF  277,FE9
05950:  MOVFF  278,FEA
05954:  MOVFF  FEC,172
05958:  MOVF   FED,F
0595A:  MOVFF  FEF,171
....................          MyTCB.localPort.Val = h->DestPort; 
0595E:  MOVLW  02
05960:  ADDWF  x77,W
05962:  MOVWF  FE9
05964:  MOVLW  00
05966:  ADDWFC x78,W
05968:  MOVWF  FEA
0596A:  MOVFF  FEC,174
0596E:  MOVF   FED,F
05970:  MOVFF  FEF,173
....................          MyTCB.txUnackedTail   = MyTCBStub.bufferTxStart; 
05974:  MOVFF  1C8,170
05978:  MOVFF  1C7,16F
....................        
....................          // All done, and we have a match 
....................          return TRUE; 
0597C:  MOVLW  01
0597E:  MOVWF  01
05980:  BRA    5D94
....................       } 
....................    } 
....................  
....................    // No available sockets are listening on this port.  (Or, for 
....................    // SSL requests, perhaps no SSL sessions were available.  However, 
....................    // there may be a server socket which is currently busy but  
....................    // could handle this packet, so we should check. 
....................    #if TCP_SYN_QUEUE_MAX_ENTRIES 
....................    { 
....................       WORD wQueueInsertPos; 
....................        
....................       // See if this is a SYN packet 
....................       if(!h->Flags.bits.flagSYN) 
05982:  MOVLW  0D
05984:  ADDWF  x77,W
05986:  MOVWF  FE9
05988:  MOVLW  00
0598A:  ADDWFC x78,W
0598C:  MOVWF  FEA
0598E:  BTFSC  FEF.1
05990:  BRA    5998
....................          return FALSE; 
05992:  MOVLW  00
05994:  MOVWF  01
05996:  BRA    5D94
....................  
....................       // See if there is space in our SYN queue 
....................       if(SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort) 
05998:  MOVLB  1
0599A:  MOVF   xC3,W
0599C:  IORWF  xC4,W
0599E:  BZ    59AA
....................          return FALSE; 
059A0:  MOVLW  00
059A2:  MOVWF  01
059A4:  MOVLB  2
059A6:  BRA    5D94
059A8:  MOVLB  1
....................        
....................       // See if we have this SYN already in our SYN queue. 
....................       // If not already in the queue, find out where we  
....................       // should insert this SYN to the queue 
....................       for(wQueueInsertPos = 0; wQueueInsertPos < TCP_SYN_QUEUE_MAX_ENTRIES; wQueueInsertPos++) 
059AA:  MOVLB  2
059AC:  CLRF   x80
059AE:  CLRF   x7F
059B0:  MOVF   x80,F
059B2:  BTFSS  FD8.2
059B4:  BRA    5B82
059B6:  MOVF   x7F,W
059B8:  SUBLW  02
059BA:  BTFSS  FD8.0
059BC:  BRA    5B82
....................       { 
....................          // Exit loop if we found a free record 
....................          if(SYNQueue[wQueueInsertPos].wDestPort == 0u) 
059BE:  MOVFF  280,282
059C2:  MOVFF  27F,281
059C6:  CLRF   x84
059C8:  MOVLW  14
059CA:  MOVWF  x83
059CC:  MOVLB  0
059CE:  CALL   1712
059D2:  MOVFF  01,281
059D6:  MOVLW  10
059D8:  MOVLB  2
059DA:  ADDWF  01,W
059DC:  MOVWF  01
059DE:  MOVLW  00
059E0:  ADDWFC 02,W
059E2:  MOVWF  03
059E4:  MOVF   01,W
059E6:  ADDLW  8B
059E8:  MOVWF  FE9
059EA:  MOVLW  01
059EC:  ADDWFC 03,W
059EE:  MOVWF  FEA
059F0:  MOVFF  FEC,282
059F4:  MOVF   FED,F
059F6:  MOVFF  FEF,281
059FA:  MOVF   x81,F
059FC:  BNZ   5A04
059FE:  MOVF   x82,F
05A00:  BNZ   5A04
....................             break; 
05A02:  BRA    5B82
....................  
....................          // Check if this SYN packet is already in the SYN queue 
....................          if(SYNQueue[wQueueInsertPos].wDestPort != h->DestPort) 
05A04:  MOVFF  280,282
05A08:  MOVFF  27F,281
05A0C:  CLRF   x84
05A0E:  MOVLW  14
05A10:  MOVWF  x83
05A12:  MOVLB  0
05A14:  CALL   1712
05A18:  MOVFF  01,281
05A1C:  MOVLW  10
05A1E:  MOVLB  2
05A20:  ADDWF  01,W
05A22:  MOVWF  01
05A24:  MOVLW  00
05A26:  ADDWFC 02,W
05A28:  MOVWF  03
05A2A:  MOVF   01,W
05A2C:  ADDLW  8B
05A2E:  MOVWF  FE9
05A30:  MOVLW  01
05A32:  ADDWFC 03,W
05A34:  MOVWF  FEA
05A36:  MOVFF  FEC,282
05A3A:  MOVF   FED,F
05A3C:  MOVFF  FEF,281
05A40:  MOVLW  02
05A42:  ADDWF  x77,W
05A44:  MOVWF  FE9
05A46:  MOVLW  00
05A48:  ADDWFC x78,W
05A4A:  MOVWF  FEA
05A4C:  MOVFF  FEC,03
05A50:  MOVF   FED,F
05A52:  MOVF   FEF,W
05A54:  SUBWF  x81,W
05A56:  BNZ   5A5E
05A58:  MOVF   03,W
05A5A:  SUBWF  x82,W
05A5C:  BZ    5A60
....................             continue; 
05A5E:  BRA    5B7A
....................          if(SYNQueue[wQueueInsertPos].wSourcePort != h->SourcePort) 
05A60:  MOVFF  280,282
05A64:  MOVFF  27F,281
05A68:  CLRF   x84
05A6A:  MOVLW  14
05A6C:  MOVWF  x83
05A6E:  MOVLB  0
05A70:  CALL   1712
05A74:  MOVFF  01,281
05A78:  MOVLW  0A
05A7A:  MOVLB  2
05A7C:  ADDWF  01,W
05A7E:  MOVWF  01
05A80:  MOVLW  00
05A82:  ADDWFC 02,W
05A84:  MOVWF  03
05A86:  MOVF   01,W
05A88:  ADDLW  8B
05A8A:  MOVWF  FE9
05A8C:  MOVLW  01
05A8E:  ADDWFC 03,W
05A90:  MOVWF  FEA
05A92:  MOVFF  FEC,282
05A96:  MOVF   FED,F
05A98:  MOVFF  FEF,281
05A9C:  MOVFF  277,FE9
05AA0:  MOVFF  278,FEA
05AA4:  MOVFF  FEC,03
05AA8:  MOVF   FED,F
05AAA:  MOVF   FEF,W
05AAC:  SUBWF  x81,W
05AAE:  BNZ   5AB6
05AB0:  MOVF   03,W
05AB2:  SUBWF  x82,W
05AB4:  BZ    5AB8
....................             continue; 
05AB6:  BRA    5B7A
....................          if(SYNQueue[wQueueInsertPos].niSourceAddress.IPAddr.Val != remote->IPAddr.Val) 
05AB8:  MOVFF  280,282
05ABC:  MOVFF  27F,281
05AC0:  CLRF   x84
05AC2:  MOVLW  14
05AC4:  MOVWF  x83
05AC6:  MOVLB  0
05AC8:  CALL   1712
05ACC:  MOVFF  02,282
05AD0:  MOVFF  01,281
05AD4:  MOVLW  8B
05AD6:  MOVLB  2
05AD8:  ADDWF  01,W
05ADA:  MOVWF  FE9
05ADC:  MOVLW  01
05ADE:  ADDWFC 02,W
05AE0:  MOVWF  FEA
05AE2:  MOVFF  FEF,283
05AE6:  MOVFF  FEC,284
05AEA:  MOVFF  FEC,285
05AEE:  MOVFF  FEC,286
05AF2:  MOVFF  279,FE9
05AF6:  MOVFF  27A,FEA
05AFA:  MOVFF  FEF,00
05AFE:  MOVFF  FEC,01
05B02:  MOVFF  FEC,02
05B06:  MOVFF  FEC,03
05B0A:  MOVF   00,W
05B0C:  SUBWF  x83,W
05B0E:  BNZ   5B22
05B10:  MOVF   01,W
05B12:  SUBWF  x84,W
05B14:  BNZ   5B22
05B16:  MOVF   02,W
05B18:  SUBWF  x85,W
05B1A:  BNZ   5B22
05B1C:  MOVF   03,W
05B1E:  SUBWF  x86,W
05B20:  BZ    5B24
....................             continue; 
05B22:  BRA    5B7A
....................  
....................          // SYN matches SYN queue entry.  Update timestamp and do nothing. 
....................          SYNQueue[wQueueInsertPos].wTimestamp = TickGetDiv256(); 
05B24:  MOVFF  280,282
05B28:  MOVFF  27F,281
05B2C:  CLRF   x84
05B2E:  MOVLW  14
05B30:  MOVWF  x83
05B32:  MOVLB  0
05B34:  CALL   1712
05B38:  MOVFF  01,281
05B3C:  MOVLW  12
05B3E:  MOVLB  2
05B40:  ADDWF  01,W
05B42:  MOVWF  01
05B44:  MOVLW  00
05B46:  ADDWFC 02,W
05B48:  MOVWF  03
05B4A:  MOVF   01,W
05B4C:  ADDLW  8B
05B4E:  MOVWF  01
05B50:  MOVLW  01
05B52:  ADDWFC 03,F
05B54:  MOVFF  01,281
05B58:  MOVFF  03,282
05B5C:  MOVLB  0
05B5E:  CALL   16EE
05B62:  MOVFF  282,FEA
05B66:  MOVFF  281,FE9
05B6A:  MOVFF  00,FEF
05B6E:  MOVFF  01,FEC
....................          return FALSE; 
05B72:  MOVLW  00
05B74:  MOVWF  01
05B76:  MOVLB  2
05B78:  BRA    5D94
05B7A:  INCF   x7F,F
05B7C:  BTFSC  FD8.2
05B7E:  INCF   x80,F
05B80:  BRA    59B0
....................       } 
....................        
....................       // Check to see if we have any server sockets which  
....................       // are currently connected, but could handle this SYN  
....................       // request at a later time if the client disconnects. 
....................       for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++) 
05B82:  CLRF   x7B
05B84:  MOVF   x7B,F
05B86:  BTFSS  FD8.2
05B88:  BRA    5D90
....................       { 
....................          SyncTCBStub(hTCP); 
05B8A:  MOVFF  27B,281
05B8E:  MOVLB  0
05B90:  CALL   0CCA
....................          if(!MyTCBStub.Flags.bServer) 
05B94:  MOVLB  1
05B96:  BTFSC  xDE.3
05B98:  BRA    5B9C
....................             continue; 
05B9A:  BRA    5D8A
....................  
....................          SyncTCB(); 
05B9C:  MOVLB  0
05B9E:  CALL   12CE
....................          #if defined(STACK_USE_SSL_SERVER) 
....................          if((MyTCB.localPort.Val != h->DestPort) && (MyTCB.localSSLPort.Val != h->DestPort)) 
....................          #else 
....................          if(MyTCB.localPort.Val != h->DestPort) 
05BA2:  MOVLW  02
05BA4:  MOVLB  2
05BA6:  ADDWF  x77,W
05BA8:  MOVWF  FE9
05BAA:  MOVLW  00
05BAC:  ADDWFC x78,W
05BAE:  MOVWF  FEA
05BB0:  MOVFF  FEC,03
05BB4:  MOVF   FED,F
05BB6:  MOVF   FEF,W
05BB8:  MOVLB  1
05BBA:  SUBWF  x73,W
05BBC:  BNZ   5BC4
05BBE:  MOVF   03,W
05BC0:  SUBWF  x74,W
05BC2:  BZ    5BC6
....................          #endif 
....................             continue; 
05BC4:  BRA    5D8A
....................  
....................          // Generate the SYN queue entry 
....................          memcpy((void*)&SYNQueue[wQueueInsertPos].niSourceAddress, (void*)remote, sizeof(NODE_INFO)); 
05BC6:  MOVFF  280,282
05BCA:  MOVFF  27F,281
05BCE:  MOVLB  2
05BD0:  CLRF   x84
05BD2:  MOVLW  14
05BD4:  MOVWF  x83
05BD6:  MOVLB  0
05BD8:  CALL   1712
05BDC:  MOVFF  02,282
05BE0:  MOVFF  01,281
05BE4:  MOVLW  8B
05BE6:  MOVLB  2
05BE8:  ADDWF  01,W
05BEA:  MOVWF  01
05BEC:  MOVLW  01
05BEE:  ADDWFC 02,W
05BF0:  MOVWF  03
05BF2:  MOVFF  01,283
05BF6:  MOVWF  x84
05BF8:  MOVWF  FEA
05BFA:  MOVFF  01,FE9
05BFE:  MOVFF  27A,FE2
05C02:  MOVFF  279,FE1
05C06:  MOVLW  0A
05C08:  MOVWF  01
05C0A:  MOVFF  FE6,FEE
05C0E:  DECFSZ 01,F
05C10:  BRA    5C0A
....................          SYNQueue[wQueueInsertPos].wSourcePort = h->SourcePort; 
05C12:  MOVFF  280,282
05C16:  MOVFF  27F,281
05C1A:  CLRF   x84
05C1C:  MOVLW  14
05C1E:  MOVWF  x83
05C20:  MOVLB  0
05C22:  CALL   1712
05C26:  MOVFF  01,281
05C2A:  MOVLW  0A
05C2C:  MOVLB  2
05C2E:  ADDWF  01,W
05C30:  MOVWF  01
05C32:  MOVLW  00
05C34:  ADDWFC 02,W
05C36:  MOVWF  03
05C38:  MOVF   01,W
05C3A:  ADDLW  8B
05C3C:  MOVWF  01
05C3E:  MOVLW  01
05C40:  ADDWFC 03,F
05C42:  MOVFF  03,282
05C46:  MOVFF  277,FE9
05C4A:  MOVFF  278,FEA
05C4E:  MOVFF  FEC,03
05C52:  MOVF   FED,F
05C54:  MOVFF  FEF,283
05C58:  MOVFF  282,FEA
05C5C:  MOVFF  01,FE9
05C60:  MOVFF  03,FEC
05C64:  MOVF   FED,F
05C66:  MOVFF  283,FEF
....................          SYNQueue[wQueueInsertPos].dwSourceSEQ = h->SeqNumber; 
05C6A:  MOVFF  280,282
05C6E:  MOVFF  27F,281
05C72:  CLRF   x84
05C74:  MOVLW  14
05C76:  MOVWF  x83
05C78:  MOVLB  0
05C7A:  CALL   1712
05C7E:  MOVFF  01,281
05C82:  MOVLW  0C
05C84:  MOVLB  2
05C86:  ADDWF  01,W
05C88:  MOVWF  01
05C8A:  MOVLW  00
05C8C:  ADDWFC 02,W
05C8E:  MOVWF  03
05C90:  MOVF   01,W
05C92:  ADDLW  8B
05C94:  MOVWF  01
05C96:  MOVLW  01
05C98:  ADDWFC 03,F
05C9A:  MOVFF  01,281
05C9E:  MOVFF  03,282
05CA2:  MOVLW  04
05CA4:  ADDWF  x77,W
05CA6:  MOVWF  FE9
05CA8:  MOVLW  00
05CAA:  ADDWFC x78,W
05CAC:  MOVWF  FEA
05CAE:  MOVFF  FEF,00
05CB2:  MOVFF  FEC,01
05CB6:  MOVFF  FEC,02
05CBA:  MOVFF  FEC,03
05CBE:  MOVFF  282,FEA
05CC2:  MOVFF  281,FE9
05CC6:  MOVFF  00,FEF
05CCA:  MOVFF  01,FEC
05CCE:  MOVFF  02,FEC
05CD2:  MOVFF  03,FEC
....................          SYNQueue[wQueueInsertPos].wDestPort = h->DestPort; 
05CD6:  MOVFF  280,282
05CDA:  MOVFF  27F,281
05CDE:  CLRF   x84
05CE0:  MOVLW  14
05CE2:  MOVWF  x83
05CE4:  MOVLB  0
05CE6:  CALL   1712
05CEA:  MOVFF  01,281
05CEE:  MOVLW  10
05CF0:  MOVLB  2
05CF2:  ADDWF  01,W
05CF4:  MOVWF  01
05CF6:  MOVLW  00
05CF8:  ADDWFC 02,W
05CFA:  MOVWF  03
05CFC:  MOVF   01,W
05CFE:  ADDLW  8B
05D00:  MOVWF  01
05D02:  MOVLW  01
05D04:  ADDWFC 03,F
05D06:  MOVFF  03,282
05D0A:  MOVLW  02
05D0C:  ADDWF  x77,W
05D0E:  MOVWF  FE9
05D10:  MOVLW  00
05D12:  ADDWFC x78,W
05D14:  MOVWF  FEA
05D16:  MOVFF  FEC,03
05D1A:  MOVF   FED,F
05D1C:  MOVFF  FEF,283
05D20:  MOVFF  282,FEA
05D24:  MOVFF  01,FE9
05D28:  MOVFF  03,FEC
05D2C:  MOVF   FED,F
05D2E:  MOVFF  283,FEF
....................          SYNQueue[wQueueInsertPos].wTimestamp = TickGetDiv256(); 
05D32:  MOVFF  280,282
05D36:  MOVFF  27F,281
05D3A:  CLRF   x84
05D3C:  MOVLW  14
05D3E:  MOVWF  x83
05D40:  MOVLB  0
05D42:  CALL   1712
05D46:  MOVFF  01,281
05D4A:  MOVLW  12
05D4C:  MOVLB  2
05D4E:  ADDWF  01,W
05D50:  MOVWF  01
05D52:  MOVLW  00
05D54:  ADDWFC 02,W
05D56:  MOVWF  03
05D58:  MOVF   01,W
05D5A:  ADDLW  8B
05D5C:  MOVWF  01
05D5E:  MOVLW  01
05D60:  ADDWFC 03,F
05D62:  MOVFF  01,281
05D66:  MOVFF  03,282
05D6A:  MOVLB  0
05D6C:  CALL   16EE
05D70:  MOVFF  282,FEA
05D74:  MOVFF  281,FE9
05D78:  MOVFF  00,FEF
05D7C:  MOVFF  01,FEC
....................  
....................          return FALSE; 
05D80:  MOVLW  00
05D82:  MOVWF  01
05D84:  MOVLB  2
05D86:  BRA    5D94
05D88:  MOVLB  1
05D8A:  MOVLB  2
05D8C:  INCF   x7B,F
05D8E:  BRA    5B84
....................       } 
....................    } 
....................    #endif 
....................        
....................    return FALSE; 
05D90:  MOVLW  00
05D92:  MOVWF  01
05D94:  MOVLB  0
05D96:  GOTO   71C8 (RETURN)
....................  
.................... } 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void SwapTCPHeader(TCP_HEADER* header) 
....................  
....................   Summary: 
....................    Swaps endian-ness of a TCP header. 
....................  
....................   Description: 
....................    This function swaps the endian-ness of a given TCP header for comparison. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    header - The TCP header that is to be swapped 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... static void SwapTCPHeader(TCP_HEADER* header) 
.................... { 
....................    header->SourcePort      = swaps(header->SourcePort); 
*
01A0C:  MOVLB  2
01A0E:  MOVFF  2C1,01
01A12:  MOVFF  2C2,03
01A16:  MOVFF  2C1,2C3
01A1A:  MOVFF  2C2,2C4
01A1E:  MOVFF  2C1,FE9
01A22:  MOVFF  2C2,FEA
01A26:  MOVFF  FEC,2C6
01A2A:  MOVF   FED,F
01A2C:  MOVFF  FEF,2C5
01A30:  MOVFF  2C6,2E1
01A34:  MOVFF  2C5,2E0
01A38:  MOVLB  0
01A3A:  RCALL  1874
01A3C:  MOVFF  2C4,FEA
01A40:  MOVFF  2C3,FE9
01A44:  MOVFF  02,FEC
01A48:  MOVF   FED,F
01A4A:  MOVFF  01,FEF
....................    header->DestPort        = swaps(header->DestPort); 
01A4E:  MOVLW  02
01A50:  MOVLB  2
01A52:  ADDWF  xC1,W
01A54:  MOVWF  01
01A56:  MOVLW  00
01A58:  ADDWFC xC2,W
01A5A:  MOVWF  03
01A5C:  MOVFF  01,2C3
01A60:  MOVWF  xC4
01A62:  MOVLW  02
01A64:  ADDWF  xC1,W
01A66:  MOVWF  FE9
01A68:  MOVLW  00
01A6A:  ADDWFC xC2,W
01A6C:  MOVWF  FEA
01A6E:  MOVFF  FEC,2C6
01A72:  MOVF   FED,F
01A74:  MOVFF  FEF,2C5
01A78:  MOVFF  2C6,2E1
01A7C:  MOVFF  2C5,2E0
01A80:  MOVLB  0
01A82:  RCALL  1874
01A84:  MOVFF  2C4,FEA
01A88:  MOVFF  2C3,FE9
01A8C:  MOVFF  02,FEC
01A90:  MOVF   FED,F
01A92:  MOVFF  01,FEF
....................    header->SeqNumber       = swapl(header->SeqNumber); 
01A96:  MOVLW  04
01A98:  MOVLB  2
01A9A:  ADDWF  xC1,W
01A9C:  MOVWF  01
01A9E:  MOVLW  00
01AA0:  ADDWFC xC2,W
01AA2:  MOVWF  03
01AA4:  MOVFF  01,2C3
01AA8:  MOVWF  xC4
01AAA:  MOVLW  04
01AAC:  ADDWF  xC1,W
01AAE:  MOVWF  FE9
01AB0:  MOVLW  00
01AB2:  ADDWFC xC2,W
01AB4:  MOVWF  FEA
01AB6:  MOVFF  FEF,2C5
01ABA:  MOVFF  FEC,2C6
01ABE:  MOVFF  FEC,2C7
01AC2:  MOVFF  FEC,2C8
01AC6:  MOVFF  2C8,2CC
01ACA:  MOVFF  2C7,2CB
01ACE:  MOVFF  2C6,2CA
01AD2:  MOVFF  2C5,2C9
01AD6:  MOVLB  0
01AD8:  RCALL  1896
01ADA:  MOVFF  2C4,FEA
01ADE:  MOVFF  2C3,FE9
01AE2:  MOVFF  00,FEF
01AE6:  MOVFF  01,FEC
01AEA:  MOVFF  02,FEC
01AEE:  MOVFF  03,FEC
....................    header->AckNumber       = swapl(header->AckNumber); 
01AF2:  MOVLW  08
01AF4:  MOVLB  2
01AF6:  ADDWF  xC1,W
01AF8:  MOVWF  01
01AFA:  MOVLW  00
01AFC:  ADDWFC xC2,W
01AFE:  MOVWF  03
01B00:  MOVFF  01,2C3
01B04:  MOVWF  xC4
01B06:  MOVLW  08
01B08:  ADDWF  xC1,W
01B0A:  MOVWF  FE9
01B0C:  MOVLW  00
01B0E:  ADDWFC xC2,W
01B10:  MOVWF  FEA
01B12:  MOVFF  FEF,2C5
01B16:  MOVFF  FEC,2C6
01B1A:  MOVFF  FEC,2C7
01B1E:  MOVFF  FEC,2C8
01B22:  MOVFF  2C8,2CC
01B26:  MOVFF  2C7,2CB
01B2A:  MOVFF  2C6,2CA
01B2E:  MOVFF  2C5,2C9
01B32:  MOVLB  0
01B34:  RCALL  1896
01B36:  MOVFF  2C4,FEA
01B3A:  MOVFF  2C3,FE9
01B3E:  MOVFF  00,FEF
01B42:  MOVFF  01,FEC
01B46:  MOVFF  02,FEC
01B4A:  MOVFF  03,FEC
....................    header->Window          = swaps(header->Window); 
01B4E:  MOVLW  0E
01B50:  MOVLB  2
01B52:  ADDWF  xC1,W
01B54:  MOVWF  01
01B56:  MOVLW  00
01B58:  ADDWFC xC2,W
01B5A:  MOVWF  03
01B5C:  MOVFF  01,2C3
01B60:  MOVWF  xC4
01B62:  MOVLW  0E
01B64:  ADDWF  xC1,W
01B66:  MOVWF  FE9
01B68:  MOVLW  00
01B6A:  ADDWFC xC2,W
01B6C:  MOVWF  FEA
01B6E:  MOVFF  FEC,2C6
01B72:  MOVF   FED,F
01B74:  MOVFF  FEF,2C5
01B78:  MOVFF  2C6,2E1
01B7C:  MOVFF  2C5,2E0
01B80:  MOVLB  0
01B82:  RCALL  1874
01B84:  MOVFF  2C4,FEA
01B88:  MOVFF  2C3,FE9
01B8C:  MOVFF  02,FEC
01B90:  MOVF   FED,F
01B92:  MOVFF  01,FEF
....................    header->Checksum        = swaps(header->Checksum); 
01B96:  MOVLW  10
01B98:  MOVLB  2
01B9A:  ADDWF  xC1,W
01B9C:  MOVWF  01
01B9E:  MOVLW  00
01BA0:  ADDWFC xC2,W
01BA2:  MOVWF  03
01BA4:  MOVFF  01,2C3
01BA8:  MOVWF  xC4
01BAA:  MOVLW  10
01BAC:  ADDWF  xC1,W
01BAE:  MOVWF  FE9
01BB0:  MOVLW  00
01BB2:  ADDWFC xC2,W
01BB4:  MOVWF  FEA
01BB6:  MOVFF  FEC,2C6
01BBA:  MOVF   FED,F
01BBC:  MOVFF  FEF,2C5
01BC0:  MOVFF  2C6,2E1
01BC4:  MOVFF  2C5,2E0
01BC8:  MOVLB  0
01BCA:  RCALL  1874
01BCC:  MOVFF  2C4,FEA
01BD0:  MOVFF  2C3,FE9
01BD4:  MOVFF  02,FEC
01BD8:  MOVF   FED,F
01BDA:  MOVFF  01,FEF
....................    header->UrgentPointer   = swaps(header->UrgentPointer); 
01BDE:  MOVLW  12
01BE0:  MOVLB  2
01BE2:  ADDWF  xC1,W
01BE4:  MOVWF  01
01BE6:  MOVLW  00
01BE8:  ADDWFC xC2,W
01BEA:  MOVWF  03
01BEC:  MOVFF  01,2C3
01BF0:  MOVWF  xC4
01BF2:  MOVLW  12
01BF4:  ADDWF  xC1,W
01BF6:  MOVWF  FE9
01BF8:  MOVLW  00
01BFA:  ADDWFC xC2,W
01BFC:  MOVWF  FEA
01BFE:  MOVFF  FEC,2C6
01C02:  MOVF   FED,F
01C04:  MOVFF  FEF,2C5
01C08:  MOVFF  2C6,2E1
01C0C:  MOVFF  2C5,2E0
01C10:  MOVLB  0
01C12:  RCALL  1874
01C14:  MOVFF  2C4,FEA
01C18:  MOVFF  2C3,FE9
01C1C:  MOVFF  02,FEC
01C20:  MOVF   FED,F
01C22:  MOVFF  01,FEF
01C26:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void CloseSocket(void) 
....................  
....................   Summary: 
....................    Closes a TCP socket. 
....................  
....................   Description: 
....................    This function closes a TCP socket.  All socket state information is  
....................    reset, and any buffered bytes are discarded.  The socket is no longer 
....................    accessible by the application after this point. 
....................  
....................   Precondition: 
....................    The TCPStub corresponding to the socket to be closed is synced. 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... static void CloseSocket(void) 
.................... { 
....................    SyncTCB(); 
*
013A6:  RCALL  12CE
....................  
....................    MyTCBStub.remoteHash.Val = MyTCB.localPort.Val; 
013A8:  MOVFF  174,1E1
013AC:  MOVFF  173,1E0
....................    MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
013B0:  MOVFF  1C8,1CE
013B4:  MOVFF  1C7,1CD
....................    MyTCBStub.txTail = MyTCBStub.bufferTxStart; 
013B8:  MOVFF  1C8,1D0
013BC:  MOVFF  1C7,1CF
....................    MyTCBStub.rxHead = MyTCBStub.bufferRxStart; 
013C0:  MOVFF  1CA,1D2
013C4:  MOVFF  1C9,1D1
....................    MyTCBStub.rxTail = MyTCBStub.bufferRxStart; 
013C8:  MOVFF  1CA,1D4
013CC:  MOVFF  1C9,1D3
....................    MyTCBStub.smState = MyTCBStub.Flags.bServer ? TCP_LISTEN : TCP_CLOSED; 
013D0:  MOVLB  1
013D2:  BTFSS  xDE.3
013D4:  BRA    13DA
013D6:  MOVLW  04
013D8:  BRA    13DC
013DA:  MOVLW  0D
013DC:  MOVWF  xDD
....................    MyTCBStub.Flags.vUnackedKeepalives = 0; 
013DE:  MOVLW  F8
013E0:  ANDWF  xDE,W
013E2:  MOVWF  xDE
....................    MyTCBStub.Flags.bTimerEnabled = 0; 
013E4:  BCF    xDE.4
....................    MyTCBStub.Flags.bTimer2Enabled = 0; 
013E6:  BCF    xDE.5
....................    MyTCBStub.Flags.bDelayedACKTimerEnabled = 0; 
013E8:  BCF    xDE.6
....................    MyTCBStub.Flags.bOneSegmentReceived = 0; 
013EA:  BCF    xDE.7
....................    MyTCBStub.Flags.bHalfFullFlush = 0; 
013EC:  BCF    xDF.0
....................    MyTCBStub.Flags.bTXASAP = 0; 
013EE:  BCF    xDF.1
....................    MyTCBStub.Flags.bTXASAPWithoutTimerReset = 0; 
013F0:  BCF    xDF.2
....................    MyTCBStub.Flags.bTXFIN = 0; 
013F2:  BCF    xDF.3
....................    MyTCBStub.Flags.bSocketReset = 1; 
013F4:  BSF    xDF.4
....................  
....................    #if defined(STACK_USE_SSL) 
....................    // If SSL is active, then we need to close it 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    { 
....................       SSLTerminate(MyTCBStub.sslStubID); 
....................       MyTCBStub.sslStubID = SSL_INVALID_ID; 
....................  
....................       // Swap the SSL port and local port back to proper values 
....................       MyTCBStub.remoteHash.Val = MyTCB.localSSLPort.Val; 
....................       MyTCB.localSSLPort.Val = MyTCB.localPort.Val; 
....................       MyTCB.localPort.Val = MyTCBStub.remoteHash.Val; 
....................    } 
....................  
....................    // Reset the SSL buffer pointers 
....................    MyTCBStub.sslRxHead = MyTCBStub.bufferRxStart; 
....................    MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    #endif 
....................     
....................    #if defined(STACK_USE_SSL_SERVER) 
....................    MyTCBStub.sslTxHead = MyTCB.localSSLPort.Val; 
....................    #endif 
....................  
....................    MyTCB.flags.bFINSent = 0; 
013F6:  BCF    x85.0
....................    MyTCB.flags.bSYNSent = 0; 
013F8:  BCF    x85.1
....................    MyTCB.flags.bRXNoneACKed1 = 0; 
013FA:  BCF    x85.3
....................    MyTCB.flags.bRXNoneACKed2 = 0; 
013FC:  BCF    x85.4
....................    MyTCB.txUnackedTail = MyTCBStub.bufferTxStart; 
013FE:  MOVFF  1C8,170
01402:  MOVFF  1C7,16F
....................    ((DWORD_VAL*)(&MyTCB.MySEQ))->w[0] = LFSRRand(); 
01406:  MOVLW  01
01408:  MOVLB  2
0140A:  MOVWF  x98
0140C:  MOVLW  67
0140E:  MOVWF  x97
01410:  MOVWF  01
01412:  MOVFF  298,03
01416:  MOVWF  x99
01418:  MOVFF  298,29A
0141C:  MOVLB  0
0141E:  CALL   057C
01422:  MOVFF  29A,FEA
01426:  MOVFF  299,FE9
0142A:  MOVFF  02,FEC
0142E:  MOVF   FED,F
01430:  MOVFF  01,FEF
....................    ((DWORD_VAL*)(&MyTCB.MySEQ))->w[1] = LFSRRand(); 
01434:  MOVLW  01
01436:  MOVLB  2
01438:  MOVWF  x98
0143A:  MOVLW  67
0143C:  MOVWF  x97
0143E:  MOVLW  02
01440:  ADDWF  x97,W
01442:  MOVWF  01
01444:  MOVLW  00
01446:  ADDWFC x98,W
01448:  MOVWF  03
0144A:  MOVFF  01,299
0144E:  MOVWF  x9A
01450:  MOVLB  0
01452:  CALL   057C
01456:  MOVFF  29A,FEA
0145A:  MOVFF  299,FE9
0145E:  MOVFF  02,FEC
01462:  MOVF   FED,F
01464:  MOVFF  01,FEF
....................    MyTCB.sHoleSize = -1; 
01468:  MOVLB  1
0146A:  SETF   x84
0146C:  SETF   x83
....................    MyTCB.remoteWindow = 1; 
0146E:  CLRF   x76
01470:  MOVLW  01
01472:  MOVWF  x75
01474:  MOVLB  0
01476:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static WORD GetMaxSegSizeOption(void) 
....................  
....................   Summary: 
....................    Obtains the Maximum Segment Size (MSS) TCP Option out of the TCP header  
....................    for the current socket. 
....................  
....................   Description: 
....................    Parses the current TCP packet header and extracts the Maximum Segment Size  
....................    option.   
....................  
....................   Precondition: 
....................    Must be called while a TCP packet is present and being processed via  
....................    HandleTCPSeg() and only if the the TCP SYN flag is set. 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................    Maximum segment size option value.  If illegal or not present, a failsafe  
....................    value of 536 is returned.  If the option is larger than the  
....................    TCP_MAX_SEG_SIZE_TX upper limit, then TCP_MAX_SEG_SIZE_TX is returned. 
....................  
....................   Remarks: 
....................    The internal MAC Read Pointer is moved but not restored. 
....................   ***************************************************************************/ 
.................... static WORD GetMaxSegSizeOption(void) 
.................... { 
....................    BYTE vOptionsBytes; 
....................    BYTE vOption; 
....................    WORD wMSS; 
....................  
....................    // Find out how many options bytes are in this packet. 
....................    IPSetRxBuffer(2+2+4+4);   // Seek to data offset field, skipping Source port (2), Destination port (2), Sequence number (4), and Acknowledgement number (4) 
*
05D9A:  MOVLB  2
05D9C:  CLRF   x9C
05D9E:  MOVLW  0C
05DA0:  MOVWF  x9B
05DA2:  MOVLB  0
05DA4:  CALL   393C
....................    vOptionsBytes = MACGet(); 
05DA8:  CALL   0F04
05DAC:  MOVFF  01,297
....................    vOptionsBytes = ((vOptionsBytes&0xF0)>>2) - sizeof(TCP_HEADER); 
05DB0:  MOVLB  2
05DB2:  MOVF   x97,W
05DB4:  ANDLW  F0
05DB6:  MOVWF  00
05DB8:  RRCF   00,F
05DBA:  RRCF   00,F
05DBC:  MOVLW  3F
05DBE:  ANDWF  00,F
05DC0:  MOVF   00,W
05DC2:  ADDLW  EC
05DC4:  MOVWF  x97
....................  
....................    // Return minimum Maximum Segment Size value of 536 bytes if none are  
....................    // present 
....................    if(vOptionsBytes == 0u) 
05DC6:  MOVF   x97,F
05DC8:  BNZ   5DD4
....................       return 536; 
05DCA:  MOVLW  18
05DCC:  MOVWF  01
05DCE:  MOVLW  02
05DD0:  MOVWF  02
05DD2:  BRA    5EB4
....................        
....................    // Seek to beginning of options 
....................    MACGetArray(NULL, 7); 
05DD4:  CLRF   xE4
05DD6:  CLRF   xE3
05DD8:  CLRF   xE6
05DDA:  MOVLW  07
05DDC:  MOVWF  xE5
05DDE:  MOVLB  0
05DE0:  CALL   0E8E
....................  
....................    // Search for the Maximum Segment Size option    
....................    while(vOptionsBytes--) 
05DE4:  MOVLB  2
05DE6:  MOVF   x97,W
05DE8:  DECF   x97,F
05DEA:  XORLW  00
05DEC:  BTFSC  FD8.2
05DEE:  BRA    5EAC
....................    { 
....................       vOption = MACGet(); 
05DF0:  MOVLB  0
05DF2:  CALL   0F04
05DF6:  MOVFF  01,298
....................        
....................       if(vOption == 0u)   // End of Options list 
05DFA:  MOVLB  2
05DFC:  MOVF   x98,F
05DFE:  BNZ   5E02
....................          break; 
05E00:  BRA    5EAC
....................        
....................       if(vOption == 1u)   // NOP option 
05E02:  DECFSZ x98,W
05E04:  BRA    5E08
....................          continue; 
05E06:  BRA    5DE6
....................           
....................       if(vOption == 2u)   // Maximum Segment Size option 
05E08:  MOVF   x98,W
05E0A:  SUBLW  02
05E0C:  BNZ   5E78
....................       { 
....................          if(vOptionsBytes < 3u) 
05E0E:  MOVF   x97,W
05E10:  SUBLW  02
05E12:  BNC   5E16
....................             break; 
05E14:  BRA    5EAC
....................  
....................          wMSS = 0; 
05E16:  CLRF   x9A
05E18:  CLRF   x99
....................              
....................          // Get option length 
....................          vOption = MACGet(); 
05E1A:  MOVLB  0
05E1C:  CALL   0F04
05E20:  MOVFF  01,298
....................          if(vOption == 4u) 
05E24:  MOVLB  2
05E26:  MOVF   x98,W
05E28:  SUBLW  04
05E2A:  BNZ   5E40
....................          {// Retrieve MSS and swap value to little endian 
....................             ((BYTE*)&wMSS)[1] = MACGet(); 
05E2C:  MOVLB  0
05E2E:  CALL   0F04
05E32:  MOVFF  01,29A
....................             ((BYTE*)&wMSS)[0] = MACGet(); 
05E36:  CALL   0F04
05E3A:  MOVFF  01,299
05E3E:  MOVLB  2
....................          } 
....................           
....................          if(wMSS < 536u) 
05E40:  MOVF   x9A,W
05E42:  SUBLW  02
05E44:  BNC   5E50
05E46:  BNZ   5E4E
05E48:  MOVF   x99,W
05E4A:  SUBLW  17
05E4C:  BNC   5E50
....................             break; 
05E4E:  BRA    5EAC
....................          if(wMSS > TCP_MAX_SEG_SIZE_TX) 
05E50:  MOVF   x9A,W
05E52:  SUBLW  04
05E54:  BC    5E6C
05E56:  XORLW  FF
05E58:  BNZ   5E60
05E5A:  MOVF   x99,W
05E5C:  SUBLW  B4
05E5E:  BC    5E6C
....................             return TCP_MAX_SEG_SIZE_TX; 
05E60:  MOVLW  B4
05E62:  MOVWF  01
05E64:  MOVLW  05
05E66:  MOVWF  02
05E68:  BRA    5EB4
05E6A:  BRA    5E76
....................          else  
....................             return wMSS; 
05E6C:  MOVFF  299,01
05E70:  MOVFF  29A,02
05E74:  BRA    5EB4
....................       } 
05E76:  BRA    5EAA
....................       else 
....................       { // Assume this is a multi byte option and throw it way 
....................          if(vOptionsBytes < 2u) 
05E78:  MOVF   x97,W
05E7A:  SUBLW  01
05E7C:  BNC   5E80
....................             break; 
05E7E:  BRA    5EAC
....................          vOption = MACGet(); 
05E80:  MOVLB  0
05E82:  CALL   0F04
05E86:  MOVFF  01,298
....................          if(vOptionsBytes < vOption) 
05E8A:  MOVLB  2
05E8C:  MOVF   x98,W
05E8E:  SUBWF  x97,W
05E90:  BC    5E94
....................             break; 
05E92:  BRA    5EAC
....................          MACGetArray(NULL, vOption); 
05E94:  CLRF   xE4
05E96:  CLRF   xE3
05E98:  CLRF   xE6
05E9A:  MOVFF  298,2E5
05E9E:  MOVLB  0
05EA0:  CALL   0E8E
....................          vOptionsBytes -= vOption; 
05EA4:  MOVLB  2
05EA6:  MOVF   x98,W
05EA8:  SUBWF  x97,F
....................       } 
05EAA:  BRA    5DE6
....................        
....................    } 
....................     
....................    // Did not find MSS option, return worst case default 
....................    return 536; 
05EAC:  MOVLW  18
05EAE:  MOVWF  01
05EB0:  MOVLW  02
05EB2:  MOVWF  02
05EB4:  MOVLB  0
05EB6:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void HandleTCPSeg(TCP_HEADER* h, WORD len) 
....................  
....................   Summary: 
....................    Processes an incoming TCP segment. 
....................  
....................   Description: 
....................    Once an incoming segment has been matched to a socket, this function 
....................    performs the necessary processing with the data.  Depending on the  
....................    segment and the state, this may include copying data to the TCP buffer, 
....................    re-assembling out-of order packets, continuing an initialization or  
....................    closing handshake, or closing the socket altogether. 
....................  
....................   Precondition: 
....................    TCP is initialized and the current TCP stub is already synced. 
....................  
....................   Parameters: 
....................    h - The TCP header for this packet 
....................    len - The total buffer length of this segment 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... static void HandleTCPSeg(TCP_HEADER* h, WORD len) 
.................... { 
....................    DWORD dwTemp; 
....................    PTR_BASE wTemp; 
....................    LONG lMissingBytes; 
....................    WORD wMissingBytes; 
....................    WORD wFreeSpace; 
....................    BYTE localHeaderFlags; 
....................    DWORD localAckNumber; 
....................    DWORD localSeqNumber; 
....................    WORD wSegmentLength; 
....................    BOOL bSegmentAcceptable; 
....................    WORD wNewWindow; 
....................  
....................  
....................    // Cache a few variables in local RAM.   
....................    // PIC18s take a fair amount of code and execution time to  
....................    // dereference pointers frequently. 
....................    localHeaderFlags = h->Flags.byte; 
05EB8:  MOVLW  0D
05EBA:  MOVLB  2
05EBC:  ADDWF  x77,W
05EBE:  MOVWF  FE9
05EC0:  MOVLW  00
05EC2:  ADDWFC x78,W
05EC4:  MOVWF  FEA
05EC6:  MOVFF  FEF,289
....................    localAckNumber = h->AckNumber; 
05ECA:  MOVLW  08
05ECC:  ADDWF  x77,W
05ECE:  MOVWF  FE9
05ED0:  MOVLW  00
05ED2:  ADDWFC x78,W
05ED4:  MOVWF  FEA
05ED6:  MOVFF  FEF,28A
05EDA:  MOVFF  FEC,28B
05EDE:  MOVFF  FEC,28C
05EE2:  MOVFF  FEC,28D
....................    localSeqNumber = h->SeqNumber; 
05EE6:  MOVLW  04
05EE8:  ADDWF  x77,W
05EEA:  MOVWF  FE9
05EEC:  MOVLW  00
05EEE:  ADDWFC x78,W
05EF0:  MOVWF  FEA
05EF2:  MOVFF  FEF,28E
05EF6:  MOVFF  FEC,28F
05EFA:  MOVFF  FEC,290
05EFE:  MOVFF  FEC,291
....................  
....................    // We received a packet, reset the keep alive timer and count 
....................    #if defined(TCP_KEEP_ALIVE_TIMEOUT) 
....................       MyTCBStub.Flags.vUnackedKeepalives = 0; 
05F02:  MOVLW  F8
05F04:  MOVLB  1
05F06:  ANDWF  xDE,W
05F08:  MOVWF  xDE
....................       if(!MyTCBStub.Flags.bTimerEnabled) 
05F0A:  BTFSC  xDE.4
05F0C:  BRA    5F3C
....................          MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
05F0E:  MOVLB  0
05F10:  CALL   1734
05F14:  MOVLW  E6
05F16:  MOVLB  2
05F18:  ADDWF  00,W
05F1A:  MOVLB  1
05F1C:  MOVWF  xD5
05F1E:  MOVLW  F5
05F20:  MOVLB  2
05F22:  ADDWFC 01,W
05F24:  MOVLB  1
05F26:  MOVWF  xD6
05F28:  MOVLW  05
05F2A:  MOVLB  2
05F2C:  ADDWFC 02,W
05F2E:  MOVLB  1
05F30:  MOVWF  xD7
05F32:  MOVLW  00
05F34:  MOVLB  2
05F36:  ADDWFC 03,W
05F38:  MOVLB  1
05F3A:  MOVWF  xD8
....................    #endif 
....................  
....................    // Handle TCP_LISTEN and TCP_SYN_SENT states 
....................    // Both of these states will return, so code following this  
....................    // state machine need not check explicitly for these two  
....................    // states. 
....................    switch(MyTCBStub.smState) 
05F3C:  MOVF   xDD,W
05F3E:  XORLW  04
05F40:  MOVLB  0
05F42:  BZ    5F4A
05F44:  XORLW  01
05F46:  BZ    5FE4
05F48:  BRA    611A
....................    { 
....................       case TCP_LISTEN: 
....................          // First: check RST flag 
....................          if(localHeaderFlags & RST) 
05F4A:  MOVLB  2
05F4C:  BTFSS  x89.2
05F4E:  BRA    5F5C
....................          { 
....................             CloseSocket();   // Unbind remote IP address/port info 
05F50:  MOVLB  0
05F52:  CALL   13A6
....................             return; 
05F56:  GOTO   7074
05F5A:  MOVLB  2
....................          } 
....................  
....................          // Second: check ACK flag, which would be invalid 
....................          if(localHeaderFlags & ACK) 
05F5C:  BTFSS  x89.4
05F5E:  BRA    5F86
....................          { 
....................             // Use a believable sequence number and reset the remote node 
....................             MyTCB.MySEQ = localAckNumber; 
05F60:  MOVFF  28D,16A
05F64:  MOVFF  28C,169
05F68:  MOVFF  28B,168
05F6C:  MOVFF  28A,167
....................             SendTCP(RST, 0); 
05F70:  MOVLW  04
05F72:  MOVWF  x97
05F74:  CLRF   x98
05F76:  MOVLB  0
05F78:  CALL   231A
....................             CloseSocket();   // Unbind remote IP address/port info 
05F7C:  CALL   13A6
....................             return; 
05F80:  GOTO   7074
05F84:  MOVLB  2
....................          } 
....................  
....................          // Third: check for SYN flag, which is what we're looking for 
....................          if(localHeaderFlags & SYN) 
05F86:  BTFSS  x89.1
05F88:  BRA    5FD6
....................          { 
....................             // We now have a sequence number for the remote node 
....................             MyTCB.RemoteSEQ = localSeqNumber + 1; 
05F8A:  MOVLW  01
05F8C:  ADDWF  x8E,W
05F8E:  MOVLB  1
05F90:  MOVWF  x6B
05F92:  MOVLW  00
05F94:  MOVLB  2
05F96:  ADDWFC x8F,W
05F98:  MOVLB  1
05F9A:  MOVWF  x6C
05F9C:  MOVLW  00
05F9E:  MOVLB  2
05FA0:  ADDWFC x90,W
05FA2:  MOVLB  1
05FA4:  MOVWF  x6D
05FA6:  MOVLW  00
05FA8:  MOVLB  2
05FAA:  ADDWFC x91,W
05FAC:  MOVLB  1
05FAE:  MOVWF  x6E
....................  
....................             // Get MSS option 
....................             MyTCB.wRemoteMSS = GetMaxSegSizeOption(); 
05FB0:  MOVLB  0
05FB2:  RCALL  5D9A
05FB4:  MOVFF  02,187
05FB8:  MOVFF  01,186
....................  
....................             // Set Initial Send Sequence (ISS) number 
....................             // Nothing to do on this step... ISS already set in CloseSocket() 
....................              
....................             // Respond with SYN + ACK 
....................             SendTCP(SYN | ACK, SENDTCP_RESET_TIMERS); 
05FBC:  MOVLW  12
05FBE:  MOVLB  2
05FC0:  MOVWF  x97
05FC2:  MOVLW  01
05FC4:  MOVWF  x98
05FC6:  MOVLB  0
05FC8:  CALL   231A
....................             MyTCBStub.smState = TCP_SYN_RECEIVED; 
05FCC:  MOVLW  06
05FCE:  MOVLB  1
05FD0:  MOVWF  xDD
....................          } 
05FD2:  BRA    5FDE
05FD4:  MOVLB  2
....................          else 
....................          { 
....................             CloseSocket();   // Unbind remote IP address/port info 
05FD6:  MOVLB  0
05FD8:  CALL   13A6
05FDC:  MOVLB  1
....................          } 
....................  
....................          // Fourth: check for other text and control 
....................          // Nothing to do since we don't support this 
....................          return; 
05FDE:  MOVLB  0
05FE0:  GOTO   7074
....................  
....................       case TCP_SYN_SENT: 
....................          // Second: check the RST bit 
....................          // This is out of order because this stack has no API for  
....................          // notifying the application that the connection seems to  
....................          // be failing.  Instead, the application must time out and  
....................          // the stack will just keep trying in the mean time. 
....................          if(localHeaderFlags & RST) 
05FE4:  MOVLB  2
05FE6:  BTFSS  x89.2
05FE8:  BRA    5FF2
....................             return; 
05FEA:  MOVLB  0
05FEC:  GOTO   7074
05FF0:  MOVLB  2
....................  
....................          // First: check ACK bit 
....................          if(localHeaderFlags & ACK) 
05FF2:  BTFSS  x89.4
05FF4:  BRA    6062
....................          { 
....................             if(localAckNumber != MyTCB.MySEQ) 
05FF6:  MOVLB  1
05FF8:  MOVF   x67,W
05FFA:  MOVLB  2
05FFC:  SUBWF  x8A,W
05FFE:  BNZ   601E
06000:  MOVLB  1
06002:  MOVF   x68,W
06004:  MOVLB  2
06006:  SUBWF  x8B,W
06008:  BNZ   601E
0600A:  MOVLB  1
0600C:  MOVF   x69,W
0600E:  MOVLB  2
06010:  SUBWF  x8C,W
06012:  BNZ   601E
06014:  MOVLB  1
06016:  MOVF   x6A,W
06018:  MOVLB  2
0601A:  SUBWF  x8D,W
0601C:  BZ    6062
....................             { 
....................                // Send a RST packet with SEQ = SEG.ACK, but retain our SEQ  
....................                // number for arivial of any other SYN+ACK packets 
....................                localSeqNumber = MyTCB.MySEQ;   // Save our original SEQ number 
0601E:  MOVFF  16A,291
06022:  MOVFF  169,290
06026:  MOVFF  168,28F
0602A:  MOVFF  167,28E
....................                MyTCB.MySEQ = localAckNumber;   // Set SEQ = SEG.ACK 
0602E:  MOVFF  28D,16A
06032:  MOVFF  28C,169
06036:  MOVFF  28B,168
0603A:  MOVFF  28A,167
....................                SendTCP(RST, SENDTCP_RESET_TIMERS);      // Send the RST 
0603E:  MOVLW  04
06040:  MOVWF  x97
06042:  MOVLW  01
06044:  MOVWF  x98
06046:  MOVLB  0
06048:  CALL   231A
....................                MyTCB.MySEQ = localSeqNumber;   // Restore original SEQ number 
0604C:  MOVFF  291,16A
06050:  MOVFF  290,169
06054:  MOVFF  28F,168
06058:  MOVFF  28E,167
....................                return; 
0605C:  GOTO   7074
06060:  MOVLB  2
....................             } 
....................          } 
....................  
....................          // Third: check the security and precedence 
....................          // No such feature in this stack.  We want to accept all connections. 
....................  
....................          // Fourth: check the SYN bit 
....................          if(localHeaderFlags & SYN) 
06062:  BTFSS  x89.1
06064:  BRA    6114
....................          { 
....................             // We now have an initial sequence number and window size 
....................             MyTCB.RemoteSEQ = localSeqNumber + 1; 
06066:  MOVLW  01
06068:  ADDWF  x8E,W
0606A:  MOVLB  1
0606C:  MOVWF  x6B
0606E:  MOVLW  00
06070:  MOVLB  2
06072:  ADDWFC x8F,W
06074:  MOVLB  1
06076:  MOVWF  x6C
06078:  MOVLW  00
0607A:  MOVLB  2
0607C:  ADDWFC x90,W
0607E:  MOVLB  1
06080:  MOVWF  x6D
06082:  MOVLW  00
06084:  MOVLB  2
06086:  ADDWFC x91,W
06088:  MOVLB  1
0608A:  MOVWF  x6E
....................             MyTCB.remoteWindow = h->Window; 
0608C:  MOVLW  0E
0608E:  MOVLB  2
06090:  ADDWF  x77,W
06092:  MOVWF  FE9
06094:  MOVLW  00
06096:  ADDWFC x78,W
06098:  MOVWF  FEA
0609A:  MOVFF  FEC,176
0609E:  MOVF   FED,F
060A0:  MOVFF  FEF,175
....................  
....................             // Get MSS option 
....................             MyTCB.wRemoteMSS = GetMaxSegSizeOption(); 
060A4:  MOVLB  0
060A6:  RCALL  5D9A
060A8:  MOVFF  02,187
060AC:  MOVFF  01,186
....................  
....................             if(localHeaderFlags & ACK) 
060B0:  MOVLB  2
060B2:  BTFSS  x89.4
060B4:  BRA    60FE
....................             { 
....................                SendTCP(ACK, SENDTCP_RESET_TIMERS); 
060B6:  MOVLW  10
060B8:  MOVWF  x97
060BA:  MOVLW  01
060BC:  MOVWF  x98
060BE:  MOVLB  0
060C0:  CALL   231A
....................                MyTCBStub.smState = TCP_ESTABLISHED; 
060C4:  MOVLW  07
060C6:  MOVLB  1
060C8:  MOVWF  xDD
....................                // Set up keep-alive timer 
....................                #if defined(TCP_KEEP_ALIVE_TIMEOUT) 
....................                   MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
060CA:  MOVLB  0
060CC:  CALL   1734
060D0:  MOVLW  E6
060D2:  MOVLB  2
060D4:  ADDWF  00,W
060D6:  MOVLB  1
060D8:  MOVWF  xD5
060DA:  MOVLW  F5
060DC:  MOVLB  2
060DE:  ADDWFC 01,W
060E0:  MOVLB  1
060E2:  MOVWF  xD6
060E4:  MOVLW  05
060E6:  MOVLB  2
060E8:  ADDWFC 02,W
060EA:  MOVLB  1
060EC:  MOVWF  xD7
060EE:  MOVLW  00
060F0:  MOVLB  2
060F2:  ADDWFC 03,W
060F4:  MOVLB  1
060F6:  MOVWF  xD8
....................                #endif 
....................                MyTCBStub.Flags.bTimerEnabled = 0; 
060F8:  BCF    xDE.4
....................             } 
060FA:  BRA    6112
060FC:  MOVLB  2
....................             else 
....................             { 
....................                SendTCP(SYN | ACK, SENDTCP_RESET_TIMERS); 
060FE:  MOVLW  12
06100:  MOVWF  x97
06102:  MOVLW  01
06104:  MOVWF  x98
06106:  MOVLB  0
06108:  CALL   231A
....................                MyTCBStub.smState = TCP_SYN_RECEIVED; 
0610C:  MOVLW  06
0610E:  MOVLB  1
06110:  MOVWF  xDD
06112:  MOVLB  2
....................             } 
....................          } 
....................  
....................          // Fifth: drop the segment if neither SYN or RST is set 
....................          return; 
06114:  MOVLB  0
06116:  GOTO   7074
....................  
....................       default: 
....................          break; 
....................    } 
....................  
....................    // 
....................    // First: check the sequence number 
....................    // 
....................    wSegmentLength = len; 
0611A:  MOVFF  27A,293
0611E:  MOVFF  279,292
....................    if(localHeaderFlags & FIN) 
06122:  MOVLB  2
06124:  BTFSS  x89.0
06126:  BRA    612E
....................       wSegmentLength++; 
06128:  INCF   x92,F
0612A:  BTFSC  FD8.2
0612C:  INCF   x93,F
....................    if(localHeaderFlags & SYN) 
0612E:  BTFSS  x89.1
06130:  BRA    6138
....................       wSegmentLength++; 
06132:  INCF   x92,F
06134:  BTFSC  FD8.2
06136:  INCF   x93,F
....................  
....................    // Calculate the RX FIFO space 
....................    if(MyTCBStub.rxHead >= MyTCBStub.rxTail) 
06138:  MOVLB  1
0613A:  MOVF   xD4,W
0613C:  SUBWF  xD2,W
0613E:  BNC   617A
06140:  BNZ   6148
06142:  MOVF   xD3,W
06144:  SUBWF  xD1,W
06146:  BNC   617A
....................       wFreeSpace = (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart) - (MyTCBStub.rxHead - MyTCBStub.rxTail); 
06148:  MOVF   xC9,W
0614A:  SUBWF  xCB,W
0614C:  MOVLB  2
0614E:  MOVWF  x97
06150:  MOVLB  1
06152:  MOVF   xCA,W
06154:  SUBWFB xCC,W
06156:  MOVLB  2
06158:  MOVWF  x98
0615A:  MOVLB  1
0615C:  MOVF   xD3,W
0615E:  SUBWF  xD1,W
06160:  MOVWF  00
06162:  MOVF   xD4,W
06164:  SUBWFB xD2,W
06166:  MOVWF  03
06168:  MOVF   00,W
0616A:  MOVLB  2
0616C:  SUBWF  x97,W
0616E:  MOVWF  x87
06170:  MOVF   03,W
06172:  SUBWFB x98,W
06174:  MOVWF  x88
06176:  BRA    6198
06178:  MOVLB  1
....................    else 
....................       wFreeSpace = MyTCBStub.rxTail - MyTCBStub.rxHead - 1; 
0617A:  MOVF   xD1,W
0617C:  SUBWF  xD3,W
0617E:  MOVLB  2
06180:  MOVWF  x97
06182:  MOVLB  1
06184:  MOVF   xD2,W
06186:  SUBWFB xD4,W
06188:  MOVLB  2
0618A:  MOVWF  x98
0618C:  MOVLW  01
0618E:  SUBWF  x97,W
06190:  MOVWF  x87
06192:  MOVLW  00
06194:  SUBWFB x98,W
06196:  MOVWF  x88
....................  
....................    // Calculate the number of bytes ahead of our head pointer this segment skips 
....................    lMissingBytes = localSeqNumber - MyTCB.RemoteSEQ; 
06198:  MOVLB  1
0619A:  MOVF   x6B,W
0619C:  MOVLB  2
0619E:  SUBWF  x8E,W
061A0:  MOVWF  00
061A2:  MOVLB  1
061A4:  MOVF   x6C,W
061A6:  MOVLB  2
061A8:  SUBWFB x8F,W
061AA:  MOVWF  01
061AC:  MOVLB  1
061AE:  MOVF   x6D,W
061B0:  MOVLB  2
061B2:  SUBWFB x90,W
061B4:  MOVWF  02
061B6:  MOVLB  1
061B8:  MOVF   x6E,W
061BA:  MOVLB  2
061BC:  SUBWFB x91,W
061BE:  MOVWF  x84
061C0:  MOVFF  02,283
061C4:  MOVFF  01,282
061C8:  MOVFF  00,281
....................    wMissingBytes = (WORD)lMissingBytes; 
061CC:  MOVFF  282,286
061D0:  MOVFF  281,285
....................     
....................    // Run TCP acceptability tests to verify that this packet has a valid sequence number 
....................    bSegmentAcceptable = FALSE; 
061D4:  BCF    x94.0
....................    if(wSegmentLength) 
061D6:  MOVF   x92,W
061D8:  IORWF  x93,W
061DA:  BTFSC  FD8.2
061DC:  BRA    62E0
....................    { 
....................       // Check to see if we have free space, and if so, if any of the data falls within the freespace 
....................       if(wFreeSpace) 
061DE:  MOVF   x87,W
061E0:  IORWF  x88,W
061E2:  BTFSC  FD8.2
061E4:  BRA    62DE
....................       { 
....................          // RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND 
....................          if((lMissingBytes >= (LONG)0) && (wFreeSpace > (DWORD)lMissingBytes)) 
061E6:  BTFSC  x84.7
061E8:  BRA    6204
061EA:  MOVF   x84,F
061EC:  BNZ   6204
061EE:  MOVF   x83,F
061F0:  BNZ   6204
061F2:  MOVF   x82,W
061F4:  SUBWF  x88,W
061F6:  BNC   6204
061F8:  BNZ   6200
061FA:  MOVF   x87,W
061FC:  SUBWF  x81,W
061FE:  BC    6204
....................             bSegmentAcceptable = TRUE; 
06200:  BSF    x94.0
06202:  BRA    628A
....................          else 
....................          { 
....................             // RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND 
....................             if((lMissingBytes + (LONG)wSegmentLength > (LONG)0) && (lMissingBytes <= (LONG)(SHORT)(wFreeSpace - wSegmentLength))) 
06204:  MOVFF  292,00
06208:  MOVFF  293,01
0620C:  CLRF   02
0620E:  CLRF   03
06210:  MOVF   x92,W
06212:  ADDWF  x81,W
06214:  MOVWF  x97
06216:  MOVF   x93,W
06218:  ADDWFC x82,W
0621A:  MOVWF  x98
0621C:  MOVF   02,W
0621E:  ADDWFC x83,W
06220:  MOVWF  x99
06222:  MOVF   03,W
06224:  ADDWFC x84,W
06226:  MOVWF  x9A
06228:  BTFSC  FE8.7
0622A:  BRA    628A
0622C:  MOVF   x9A,F
0622E:  BNZ   623E
06230:  MOVF   x99,F
06232:  BNZ   623E
06234:  MOVF   x98,F
06236:  BNZ   623E
06238:  MOVF   x97,W
0623A:  SUBLW  00
0623C:  BC    628A
0623E:  MOVF   x92,W
06240:  SUBWF  x87,W
06242:  MOVWF  00
06244:  MOVF   x93,W
06246:  SUBWFB x88,W
06248:  MOVWF  03
0624A:  MOVF   00,W
0624C:  MOVFF  03,01
06250:  CLRF   02
06252:  CLRF   03
06254:  BTFSS  01.7
06256:  BRA    625C
06258:  DECF   02,F
0625A:  DECF   03,F
0625C:  BTFSS  x84.7
0625E:  BRA    6266
06260:  BTFSS  03.7
06262:  BRA    6288
06264:  BRA    626A
06266:  BTFSC  03.7
06268:  BRA    628A
0626A:  MOVF   x84,W
0626C:  SUBWF  03,W
0626E:  BNC   628A
06270:  BNZ   6288
06272:  MOVF   x83,W
06274:  SUBWF  02,W
06276:  BNC   628A
06278:  BNZ   6288
0627A:  MOVF   x82,W
0627C:  SUBWF  01,W
0627E:  BNC   628A
06280:  BNZ   6288
06282:  MOVF   x81,W
06284:  SUBWF  00,W
06286:  BNC   628A
....................                bSegmentAcceptable = TRUE; 
06288:  BSF    x94.0
....................          } 
....................           
....................          if((lMissingBytes < (LONG)wFreeSpace) && ((SHORT)wMissingBytes + (SHORT)wSegmentLength > (SHORT)0)) 
0628A:  MOVFF  287,00
0628E:  MOVFF  288,01
06292:  CLRF   02
06294:  CLRF   03
06296:  BTFSS  x84.7
06298:  BRA    62A0
0629A:  BTFSS  03.7
0629C:  BRA    62C2
0629E:  BRA    62A4
062A0:  BTFSC  03.7
062A2:  BRA    62DE
062A4:  MOVF   x84,W
062A6:  SUBWF  03,W
062A8:  BNC   62DE
062AA:  BNZ   62C2
062AC:  MOVF   x83,W
062AE:  SUBWF  02,W
062B0:  BNC   62DE
062B2:  BNZ   62C2
062B4:  MOVF   x82,W
062B6:  SUBWF  01,W
062B8:  BNC   62DE
062BA:  BNZ   62C2
062BC:  MOVF   00,W
062BE:  SUBWF  x81,W
062C0:  BC    62DE
062C2:  MOVF   x92,W
062C4:  ADDWF  x85,W
062C6:  MOVWF  x97
062C8:  MOVF   x93,W
062CA:  ADDWFC x86,W
062CC:  MOVWF  x98
062CE:  BTFSC  FE8.7
062D0:  BRA    62DE
062D2:  MOVF   x98,F
062D4:  BNZ   62DC
062D6:  MOVF   x97,W
062D8:  SUBLW  00
062DA:  BC    62DE
....................             bSegmentAcceptable = TRUE; 
062DC:  BSF    x94.0
....................       } 
....................       // Segments with data are not acceptable if we have no free space 
....................    } 
062DE:  BRA    6310
....................    else 
....................    { 
....................       // Zero length packets are acceptable if they fall within our free space window 
....................       // SEG.SEQ = RCV.NXT 
....................       if(lMissingBytes == 0) 
062E0:  MOVF   x81,F
062E2:  BNZ   62F4
062E4:  MOVF   x82,F
062E6:  BNZ   62F4
062E8:  MOVF   x83,F
062EA:  BNZ   62F4
062EC:  MOVF   x84,F
062EE:  BNZ   62F4
....................       { 
....................          bSegmentAcceptable = TRUE; 
062F0:  BSF    x94.0
....................       } 
062F2:  BRA    6310
....................       else 
....................       { 
....................          // RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND 
....................          if((lMissingBytes >= (LONG)0) && (wFreeSpace > (DWORD)lMissingBytes)) 
062F4:  BTFSC  x84.7
062F6:  BRA    6310
062F8:  MOVF   x84,F
062FA:  BNZ   6310
062FC:  MOVF   x83,F
062FE:  BNZ   6310
06300:  MOVF   x82,W
06302:  SUBWF  x88,W
06304:  BNC   6310
06306:  BNZ   630E
06308:  MOVF   x87,W
0630A:  SUBWF  x81,W
0630C:  BC    6310
....................             bSegmentAcceptable = TRUE; 
0630E:  BSF    x94.0
....................       } 
....................    } 
....................     
....................    if(!bSegmentAcceptable) 
06310:  BTFSC  x94.0
06312:  BRA    6330
....................    { 
....................       // Unacceptable segment, drop it and respond appropriately 
....................       if(!(localHeaderFlags & RST))  
06314:  BTFSC  x89.2
06316:  BRA    6328
....................          SendTCP(ACK, SENDTCP_RESET_TIMERS); 
06318:  MOVLW  10
0631A:  MOVWF  x97
0631C:  MOVLW  01
0631E:  MOVWF  x98
06320:  MOVLB  0
06322:  CALL   231A
06326:  MOVLB  2
....................       return; 
06328:  MOVLB  0
0632A:  GOTO   7074
0632E:  MOVLB  2
....................    } 
....................  
....................  
....................    // 
....................    // Second: check the RST bit 
....................    // 
....................    // 
....................    // Fourth: check the SYN bit 
....................    // 
....................    // Note, that since the third step is not implemented, we can  
....................    // combine this second and fourth step into a single operation. 
....................    if(localHeaderFlags & (RST | SYN)) 
06330:  MOVF   x89,W
06332:  ANDLW  06
06334:  BZ    6342
....................    { 
....................       CloseSocket(); 
06336:  MOVLB  0
06338:  CALL   13A6
....................       return; 
0633C:  GOTO   7074
06340:  MOVLB  2
....................    } 
....................  
....................    // 
....................    // Third: check the security and precedence 
....................    // 
....................    // Feature not supported.  Let's process this segment. 
....................  
....................    // 
....................    // Fifth: check the ACK bit 
....................    // 
....................    if(!(localHeaderFlags & ACK)) 
06342:  BTFSC  x89.4
06344:  BRA    634E
....................       return; 
06346:  MOVLB  0
06348:  GOTO   7074
0634C:  MOVLB  2
....................  
....................    switch(MyTCBStub.smState) 
0634E:  MOVLB  1
06350:  MOVF   xDD,W
06352:  XORLW  06
06354:  MOVLB  0
06356:  BZ    6374
06358:  XORLW  01
0635A:  BZ    63E8
0635C:  XORLW  0F
0635E:  BZ    63E8
06360:  XORLW  01
06362:  BZ    63E8
06364:  XORLW  02
06366:  BZ    63E8
06368:  XORLW  01
0636A:  BZ    63E8
0636C:  XORLW  06
0636E:  BTFSC  FD8.2
06370:  BRA    692C
06372:  BRA    697A
....................    { 
....................       case TCP_SYN_RECEIVED: 
....................          if(localAckNumber != MyTCB.MySEQ) 
06374:  MOVLB  1
06376:  MOVF   x67,W
06378:  MOVLB  2
0637A:  SUBWF  x8A,W
0637C:  BNZ   639C
0637E:  MOVLB  1
06380:  MOVF   x68,W
06382:  MOVLB  2
06384:  SUBWF  x8B,W
06386:  BNZ   639C
06388:  MOVLB  1
0638A:  MOVF   x69,W
0638C:  MOVLB  2
0638E:  SUBWF  x8C,W
06390:  BNZ   639C
06392:  MOVLB  1
06394:  MOVF   x6A,W
06396:  MOVLB  2
06398:  SUBWF  x8D,W
0639A:  BZ    63E0
....................          { 
....................             // Send a RST packet with SEQ = SEG.ACK, but retain our SEQ  
....................             // number for arivial of any other correct packets 
....................             localSeqNumber = MyTCB.MySEQ;   // Save our original SEQ number 
0639C:  MOVFF  16A,291
063A0:  MOVFF  169,290
063A4:  MOVFF  168,28F
063A8:  MOVFF  167,28E
....................             MyTCB.MySEQ = localAckNumber;   // Set SEQ = SEG.ACK 
063AC:  MOVFF  28D,16A
063B0:  MOVFF  28C,169
063B4:  MOVFF  28B,168
063B8:  MOVFF  28A,167
....................             SendTCP(RST, SENDTCP_RESET_TIMERS);      // Send the RST 
063BC:  MOVLW  04
063BE:  MOVWF  x97
063C0:  MOVLW  01
063C2:  MOVWF  x98
063C4:  MOVLB  0
063C6:  CALL   231A
....................             MyTCB.MySEQ = localSeqNumber;   // Restore original SEQ number 
063CA:  MOVFF  291,16A
063CE:  MOVFF  290,169
063D2:  MOVFF  28F,168
063D6:  MOVFF  28E,167
....................             return; 
063DA:  GOTO   7074
063DE:  MOVLB  2
....................          } 
....................          MyTCBStub.smState = TCP_ESTABLISHED; 
063E0:  MOVLW  07
063E2:  MOVLB  1
063E4:  MOVWF  xDD
063E6:  MOVLB  0
....................          // No break 
....................  
....................       case TCP_ESTABLISHED: 
....................       case TCP_FIN_WAIT_1: 
....................       case TCP_FIN_WAIT_2: 
....................       case TCP_CLOSE_WAIT: 
....................       case TCP_CLOSING: 
....................          // Calculate what the highest possible SEQ number in our TX FIFO is 
....................          wTemp = MyTCBStub.txHead - MyTCB.txUnackedTail; 
063E8:  MOVLB  1
063EA:  MOVF   x6F,W
063EC:  SUBWF  xCD,W
063EE:  MOVLB  2
063F0:  MOVWF  x7F
063F2:  MOVLB  1
063F4:  MOVF   x70,W
063F6:  SUBWFB xCE,W
063F8:  MOVLB  2
063FA:  MOVWF  x80
....................          if((SHORT)wTemp < (SHORT)0) 
063FC:  BTFSS  x80.7
063FE:  BRA    6418
....................             wTemp += MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
06400:  MOVLB  1
06402:  MOVF   xC7,W
06404:  SUBWF  xC9,W
06406:  MOVWF  00
06408:  MOVF   xC8,W
0640A:  SUBWFB xCA,W
0640C:  MOVWF  03
0640E:  MOVF   00,W
06410:  MOVLB  2
06412:  ADDWF  x7F,F
06414:  MOVF   03,W
06416:  ADDWFC x80,F
....................          dwTemp = MyTCB.MySEQ + (DWORD)wTemp; 
06418:  CLRF   02
0641A:  CLRF   03
0641C:  MOVF   x7F,W
0641E:  MOVLB  1
06420:  ADDWF  x67,W
06422:  MOVLB  2
06424:  MOVWF  x7B
06426:  MOVF   x80,W
06428:  MOVLB  1
0642A:  ADDWFC x68,W
0642C:  MOVLB  2
0642E:  MOVWF  x7C
06430:  MOVF   02,W
06432:  MOVLB  1
06434:  ADDWFC x69,W
06436:  MOVLB  2
06438:  MOVWF  x7D
0643A:  MOVF   03,W
0643C:  MOVLB  1
0643E:  ADDWFC x6A,W
06440:  MOVLB  2
06442:  MOVWF  x7E
....................  
....................          // Drop the packet if it ACKs something we haven't sent 
....................             dwTemp = (LONG)localAckNumber - (LONG)dwTemp; 
06444:  MOVF   x7B,W
06446:  SUBWF  x8A,W
06448:  MOVWF  00
0644A:  MOVF   x7C,W
0644C:  SUBWFB x8B,W
0644E:  MOVWF  01
06450:  MOVF   x7D,W
06452:  SUBWFB x8C,W
06454:  MOVWF  02
06456:  MOVF   x7E,W
06458:  SUBWFB x8D,W
0645A:  MOVWF  x7E
0645C:  MOVFF  02,27D
06460:  MOVFF  01,27C
06464:  MOVFF  00,27B
....................             if((LONG)dwTemp > 0) 
06468:  BTFSC  x7E.7
0646A:  BRA    64D0
0646C:  MOVF   x7E,F
0646E:  BNZ   647E
06470:  MOVF   x7D,F
06472:  BNZ   647E
06474:  MOVF   x7C,F
06476:  BNZ   647E
06478:  MOVF   x7B,W
0647A:  SUBLW  00
0647C:  BC    64D0
....................             {   // acknowledged more than we've sent?? 
....................                 if(!MyTCB.flags.bFINSent || dwTemp != 1) 
0647E:  MOVLB  1
06480:  BTFSS  x85.0
06482:  BRA    64AA
06484:  MOVLB  2
06486:  DECFSZ x7B,W
06488:  BRA    648C
0648A:  BRA    6490
0648C:  MOVLB  1
0648E:  BRA    64AA
06490:  MOVF   x7C,F
06492:  BTFSC  FD8.2
06494:  BRA    649A
06496:  MOVLB  1
06498:  BRA    64AA
0649A:  MOVF   x7D,F
0649C:  BTFSC  FD8.2
0649E:  BRA    64A4
064A0:  MOVLB  1
064A2:  BRA    64AA
064A4:  MOVF   x7E,F
064A6:  BZ    64C0
064A8:  MOVLB  1
....................                 { 
....................                     SendTCP(ACK, 0); 
064AA:  MOVLW  10
064AC:  MOVLB  2
064AE:  MOVWF  x97
064B0:  CLRF   x98
064B2:  MOVLB  0
064B4:  CALL   231A
....................                     return; 
064B8:  GOTO   7074
....................                 } 
064BC:  BRA    64D2
064BE:  MOVLB  2
....................                 else 
....................                 { 
....................                     localAckNumber--;   // since we don't count the FIN anyway 
064C0:  MOVLW  FF
064C2:  ADDWF  x8A,F
064C4:  BTFSS  FD8.0
064C6:  ADDWF  x8B,F
064C8:  BTFSS  FD8.0
064CA:  ADDWF  x8C,F
064CC:  BTFSS  FD8.0
064CE:  ADDWF  x8D,F
064D0:  MOVLB  0
....................                 } 
....................             } 
....................  
....................          // Throw away all ACKnowledged TX data: 
....................          // Calculate what the last acknowledged sequence number was (ignoring any FINs we sent) 
....................          dwTemp = MyTCB.MySEQ - (LONG)(SHORT)(MyTCB.txUnackedTail - MyTCBStub.txTail); 
064D2:  MOVLB  1
064D4:  MOVF   xCF,W
064D6:  SUBWF  x6F,W
064D8:  MOVWF  00
064DA:  MOVF   xD0,W
064DC:  SUBWFB x70,W
064DE:  MOVWF  03
064E0:  MOVF   00,W
064E2:  MOVFF  03,01
064E6:  CLRF   02
064E8:  CLRF   03
064EA:  BTFSS  01.7
064EC:  BRA    64F2
064EE:  DECF   02,F
064F0:  DECF   03,F
064F2:  MOVF   00,W
064F4:  SUBWF  x67,W
064F6:  MOVWF  00
064F8:  MOVF   01,W
064FA:  SUBWFB x68,W
064FC:  MOVWF  01
064FE:  MOVF   02,W
06500:  SUBWFB x69,W
06502:  MOVWF  02
06504:  MOVF   03,W
06506:  SUBWFB x6A,W
06508:  MOVFF  FE8,27E
0650C:  MOVFF  02,27D
06510:  MOVFF  01,27C
06514:  MOVFF  00,27B
....................          if(MyTCB.txUnackedTail < MyTCBStub.txTail) 
06518:  MOVF   x70,W
0651A:  SUBWF  xD0,W
0651C:  BNC   6544
0651E:  BNZ   6526
06520:  MOVF   xCF,W
06522:  SUBWF  x6F,W
06524:  BC    6544
....................             dwTemp -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
06526:  MOVF   xC7,W
06528:  SUBWF  xC9,W
0652A:  MOVWF  00
0652C:  MOVF   xC8,W
0652E:  SUBWFB xCA,W
06530:  MOVWF  03
06532:  MOVF   00,W
06534:  MOVLB  2
06536:  SUBWF  x7B,F
06538:  MOVF   03,W
0653A:  SUBWFB x7C,F
0653C:  MOVLW  00
0653E:  SUBWFB x7D,F
06540:  SUBWFB x7E,F
06542:  MOVLB  1
....................     
....................          // Calcluate how many bytes were ACKed with this packet 
....................          dwTemp = localAckNumber - dwTemp; 
06544:  MOVLB  2
06546:  MOVF   x7B,W
06548:  SUBWF  x8A,W
0654A:  MOVWF  x7B
0654C:  MOVF   x7C,W
0654E:  SUBWFB x8B,W
06550:  MOVWF  x7C
06552:  MOVF   x7D,W
06554:  SUBWFB x8C,W
06556:  MOVWF  x7D
06558:  MOVF   x7E,W
0655A:  SUBWFB x8D,W
0655C:  MOVWF  x7E
....................          if(((LONG)(dwTemp) > (LONG)0) && (dwTemp <= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart)) 
0655E:  BTFSC  x7E.7
06560:  BRA    66BA
06562:  MOVF   x7E,F
06564:  BNZ   6576
06566:  MOVF   x7D,F
06568:  BNZ   6576
0656A:  MOVF   x7C,F
0656C:  BNZ   6576
0656E:  MOVF   x7B,W
06570:  SUBLW  00
06572:  BTFSC  FD8.0
06574:  BRA    66BA
06576:  MOVLB  1
06578:  MOVF   xC7,W
0657A:  SUBWF  xC9,W
0657C:  MOVWF  00
0657E:  MOVF   xC8,W
06580:  SUBWFB xCA,W
06582:  MOVWF  03
06584:  MOVFF  00,01
06588:  MOVLB  2
0658A:  MOVF   x7E,F
0658C:  BTFSS  FD8.2
0658E:  BRA    66BA
06590:  MOVF   x7D,F
06592:  BTFSS  FD8.2
06594:  BRA    66BA
06596:  MOVF   x7C,W
06598:  SUBWF  03,W
0659A:  BTFSS  FD8.0
0659C:  BRA    66BA
0659E:  BNZ   65A8
065A0:  MOVF   x7B,W
065A2:  SUBWF  01,W
065A4:  BTFSS  FD8.0
065A6:  BRA    66BA
....................          { 
....................             MyTCB.flags.bRXNoneACKed1 = 0; 
065A8:  MOVLB  1
065AA:  BCF    x85.3
....................             MyTCB.flags.bRXNoneACKed2 = 0; 
065AC:  BCF    x85.4
....................             MyTCBStub.Flags.bHalfFullFlush = FALSE; 
065AE:  BCF    xDF.0
....................     
....................             // Bytes ACKed, free up the TX FIFO space 
....................             wTemp = MyTCBStub.txTail; 
065B0:  MOVFF  1D0,280
065B4:  MOVFF  1CF,27F
....................             MyTCBStub.txTail += dwTemp; 
065B8:  MOVLB  2
065BA:  MOVF   x7B,W
065BC:  MOVLB  1
065BE:  ADDWF  xCF,F
065C0:  MOVLB  2
065C2:  MOVF   x7C,W
065C4:  MOVLB  1
065C6:  ADDWFC xD0,F
....................             if(MyTCB.txUnackedTail >= wTemp) 
065C8:  MOVLB  2
065CA:  MOVF   x80,W
065CC:  MOVLB  1
065CE:  SUBWF  x70,W
065D0:  BNC   6610
065D2:  BNZ   65DE
065D4:  MOVLB  2
065D6:  MOVF   x7F,W
065D8:  MOVLB  1
065DA:  SUBWF  x6F,W
065DC:  BNC   6610
....................             { 
....................                if(MyTCB.txUnackedTail < MyTCBStub.txTail) 
065DE:  MOVF   x70,W
065E0:  SUBWF  xD0,W
065E2:  BNC   660E
065E4:  BNZ   65EC
065E6:  MOVF   xCF,W
065E8:  SUBWF  x6F,W
065EA:  BC    660E
....................                { 
....................                   MyTCB.MySEQ += MyTCBStub.txTail - MyTCB.txUnackedTail; 
065EC:  MOVF   x6F,W
065EE:  SUBWF  xCF,W
065F0:  MOVWF  00
065F2:  MOVF   x70,W
065F4:  SUBWFB xD0,W
065F6:  MOVWF  03
065F8:  MOVF   00,W
065FA:  ADDWF  x67,F
065FC:  MOVF   03,W
065FE:  ADDWFC x68,F
06600:  MOVLW  00
06602:  ADDWFC x69,F
06604:  ADDWFC x6A,F
....................                   MyTCB.txUnackedTail = MyTCBStub.txTail; 
06606:  MOVFF  1D0,170
0660A:  MOVFF  1CF,16F
....................                } 
....................             } 
0660E:  BRA    6672
....................             else 
....................             { 
....................                wTemp = MyTCB.txUnackedTail + (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart); 
06610:  MOVF   xC7,W
06612:  SUBWF  xC9,W
06614:  MOVWF  00
06616:  MOVF   xC8,W
06618:  SUBWFB xCA,W
0661A:  MOVWF  03
0661C:  MOVF   00,W
0661E:  ADDWF  x6F,W
06620:  MOVLB  2
06622:  MOVWF  x7F
06624:  MOVF   03,W
06626:  MOVLB  1
06628:  ADDWFC x70,W
0662A:  MOVLB  2
0662C:  MOVWF  x80
....................                if(wTemp < MyTCBStub.txTail) 
0662E:  MOVF   x80,W
06630:  MOVLB  1
06632:  SUBWF  xD0,W
06634:  BNC   6672
06636:  BNZ   6648
06638:  MOVF   xCF,W
0663A:  MOVLB  2
0663C:  SUBWF  x7F,W
0663E:  BTFSS  FD8.0
06640:  BRA    6646
06642:  MOVLB  1
06644:  BRA    6672
06646:  MOVLB  1
....................                { 
....................                   MyTCB.MySEQ += MyTCBStub.txTail - wTemp; 
06648:  MOVLB  2
0664A:  MOVF   x7F,W
0664C:  MOVLB  1
0664E:  SUBWF  xCF,W
06650:  MOVWF  00
06652:  MOVLB  2
06654:  MOVF   x80,W
06656:  MOVLB  1
06658:  SUBWFB xD0,W
0665A:  MOVWF  03
0665C:  MOVF   00,W
0665E:  ADDWF  x67,F
06660:  MOVF   03,W
06662:  ADDWFC x68,F
06664:  MOVLW  00
06666:  ADDWFC x69,F
06668:  ADDWFC x6A,F
....................                   MyTCB.txUnackedTail = MyTCBStub.txTail; 
0666A:  MOVFF  1D0,170
0666E:  MOVFF  1CF,16F
....................                } 
....................             } 
....................             if(MyTCBStub.txTail >= MyTCBStub.bufferRxStart) 
06672:  MOVF   xCA,W
06674:  SUBWF  xD0,W
06676:  BNC   6694
06678:  BNZ   6680
0667A:  MOVF   xC9,W
0667C:  SUBWF  xCF,W
0667E:  BNC   6694
....................                MyTCBStub.txTail -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
06680:  MOVF   xC7,W
06682:  SUBWF  xC9,W
06684:  MOVWF  00
06686:  MOVF   xC8,W
06688:  SUBWFB xCA,W
0668A:  MOVWF  03
0668C:  MOVF   00,W
0668E:  SUBWF  xCF,F
06690:  MOVF   03,W
06692:  SUBWFB xD0,F
....................             if(MyTCB.txUnackedTail >= MyTCBStub.bufferRxStart) 
06694:  MOVF   xCA,W
06696:  SUBWF  x70,W
06698:  BNC   66B6
0669A:  BNZ   66A2
0669C:  MOVF   xC9,W
0669E:  SUBWF  x6F,W
066A0:  BNC   66B6
....................                MyTCB.txUnackedTail -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
066A2:  MOVF   xC7,W
066A4:  SUBWF  xC9,W
066A6:  MOVWF  00
066A8:  MOVF   xC8,W
066AA:  SUBWFB xCA,W
066AC:  MOVWF  03
066AE:  MOVF   00,W
066B0:  SUBWF  x6F,F
066B2:  MOVF   03,W
066B4:  SUBWFB x70,F
....................          } 
066B6:  BRA    6770
066B8:  MOVLB  2
....................          else 
....................          { 
....................             // See if we have outstanding TX data that is waiting for an ACK 
....................             if(MyTCBStub.txTail != MyTCB.txUnackedTail) 
066BA:  MOVLB  1
066BC:  MOVF   x6F,W
066BE:  SUBWF  xCF,W
066C0:  BNZ   66C8
066C2:  MOVF   x70,W
066C4:  SUBWF  xD0,W
066C6:  BZ    6770
....................             { 
....................                if(MyTCB.flags.bRXNoneACKed1) 
066C8:  BTFSS  x85.3
066CA:  BRA    676E
....................                { 
....................                   if(MyTCB.flags.bRXNoneACKed2) 
066CC:  BTFSS  x85.4
066CE:  BRA    676C
....................                   { 
....................                      // Set up to perform a fast retransmission 
....................                      // Roll back unacknowledged TX tail pointer to cause retransmit to occur 
....................                      MyTCB.MySEQ -= (LONG)(SHORT)(MyTCB.txUnackedTail - MyTCBStub.txTail); 
066D0:  MOVF   xCF,W
066D2:  SUBWF  x6F,W
066D4:  MOVWF  00
066D6:  MOVF   xD0,W
066D8:  SUBWFB x70,W
066DA:  MOVWF  03
066DC:  MOVF   00,W
066DE:  MOVFF  03,01
066E2:  CLRF   02
066E4:  CLRF   03
066E6:  BTFSS  01.7
066E8:  BRA    66EE
066EA:  DECF   02,F
066EC:  DECF   03,F
066EE:  MOVF   00,W
066F0:  SUBWF  x67,W
066F2:  MOVWF  00
066F4:  MOVF   01,W
066F6:  SUBWFB x68,W
066F8:  MOVWF  01
066FA:  MOVF   02,W
066FC:  SUBWFB x69,W
066FE:  MOVWF  02
06700:  MOVF   03,W
06702:  SUBWFB x6A,W
06704:  MOVWF  x6A
06706:  MOVFF  02,169
0670A:  MOVFF  01,168
0670E:  MOVFF  00,167
....................                      if(MyTCB.txUnackedTail < MyTCBStub.txTail) 
06712:  MOVF   x70,W
06714:  SUBWF  xD0,W
06716:  BNC   6762
06718:  BNZ   6720
0671A:  MOVF   xCF,W
0671C:  SUBWF  x6F,W
0671E:  BC    6762
....................                         MyTCB.MySEQ -= (LONG)(SHORT)(MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart); 
06720:  MOVF   xC7,W
06722:  SUBWF  xC9,W
06724:  MOVWF  00
06726:  MOVF   xC8,W
06728:  SUBWFB xCA,W
0672A:  MOVWF  03
0672C:  MOVF   00,W
0672E:  MOVFF  03,01
06732:  CLRF   02
06734:  CLRF   03
06736:  BTFSS  01.7
06738:  BRA    673E
0673A:  DECF   02,F
0673C:  DECF   03,F
0673E:  MOVF   00,W
06740:  SUBWF  x67,W
06742:  MOVWF  00
06744:  MOVF   01,W
06746:  SUBWFB x68,W
06748:  MOVWF  01
0674A:  MOVF   02,W
0674C:  SUBWFB x69,W
0674E:  MOVWF  02
06750:  MOVF   03,W
06752:  SUBWFB x6A,W
06754:  MOVWF  x6A
06756:  MOVFF  02,169
0675A:  MOVFF  01,168
0675E:  MOVFF  00,167
....................                      MyTCB.txUnackedTail = MyTCBStub.txTail; 
06762:  MOVFF  1D0,170
06766:  MOVFF  1CF,16F
....................                      MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
0676A:  BSF    xDF.2
....................                   } 
....................                   MyTCB.flags.bRXNoneACKed2 = 1; 
0676C:  BSF    x85.4
....................                } 
....................                MyTCB.flags.bRXNoneACKed1 = 1; 
0676E:  BSF    x85.3
....................             } 
....................          } 
....................  
....................          // No need to keep our retransmit timer going if we have nothing that needs ACKing anymore 
....................          if(MyTCBStub.txTail == MyTCBStub.txHead) 
06770:  MOVF   xCD,W
06772:  SUBWF  xCF,W
06774:  BNZ   67E2
06776:  MOVF   xCE,W
06778:  SUBWF  xD0,W
0677A:  BNZ   67E2
....................          { 
....................             // Make sure there isn't a "FIN byte in our TX FIFO" 
....................             if(MyTCBStub.Flags.bTXFIN == 0u) 
0677C:  BTFSC  xDF.3
0677E:  BRA    67B2
....................             { 
....................                // Convert retransmission timer to keep-alive timer 
....................                #if defined(TCP_KEEP_ALIVE_TIMEOUT) 
....................                   MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
06780:  MOVLB  0
06782:  CALL   1734
06786:  MOVLW  E6
06788:  MOVLB  2
0678A:  ADDWF  00,W
0678C:  MOVLB  1
0678E:  MOVWF  xD5
06790:  MOVLW  F5
06792:  MOVLB  2
06794:  ADDWFC 01,W
06796:  MOVLB  1
06798:  MOVWF  xD6
0679A:  MOVLW  05
0679C:  MOVLB  2
0679E:  ADDWFC 02,W
067A0:  MOVLB  1
067A2:  MOVWF  xD7
067A4:  MOVLW  00
067A6:  MOVLB  2
067A8:  ADDWFC 03,W
067AA:  MOVLB  1
067AC:  MOVWF  xD8
....................                #endif 
....................                MyTCBStub.Flags.bTimerEnabled = 0; 
067AE:  BCF    xDE.4
....................             } 
067B0:  BRA    67E2
....................             else 
....................             { 
....................                // "Throw away" FIN byte from our TX FIFO if it has been ACKed 
....................                if((MyTCB.MySEQ == localAckNumber) && MyTCB.flags.bFINSent) 
067B2:  MOVLB  2
067B4:  MOVF   x8A,W
067B6:  MOVLB  1
067B8:  SUBWF  x67,W
067BA:  BNZ   67E2
067BC:  MOVLB  2
067BE:  MOVF   x8B,W
067C0:  MOVLB  1
067C2:  SUBWF  x68,W
067C4:  BNZ   67E2
067C6:  MOVLB  2
067C8:  MOVF   x8C,W
067CA:  MOVLB  1
067CC:  SUBWF  x69,W
067CE:  BNZ   67E2
067D0:  MOVLB  2
067D2:  MOVF   x8D,W
067D4:  MOVLB  1
067D6:  SUBWF  x6A,W
067D8:  BNZ   67E2
067DA:  BTFSS  x85.0
067DC:  BRA    67E2
....................                { 
....................                   MyTCBStub.Flags.bTimerEnabled = 0; 
067DE:  BCF    xDE.4
....................                   MyTCBStub.Flags.bTXFIN = 0; 
067E0:  BCF    xDF.3
....................                } 
....................             } 
....................          } 
....................  
....................          // The window size advirtised in this packet is adjusted to account  
....................          // for any bytes that we have transmitted but haven't been ACKed yet  
....................          // by this segment. 
....................          wNewWindow = h->Window - ((WORD)(MyTCB.MySEQ - localAckNumber)); 
067E2:  MOVLW  0E
067E4:  MOVLB  2
067E6:  ADDWF  x77,W
067E8:  MOVWF  FE9
067EA:  MOVLW  00
067EC:  ADDWFC x78,W
067EE:  MOVWF  FEA
067F0:  MOVFF  FEC,298
067F4:  MOVF   FED,F
067F6:  MOVFF  FEF,297
067FA:  MOVF   x8A,W
067FC:  MOVLB  1
067FE:  SUBWF  x67,W
06800:  MOVWF  00
06802:  MOVLB  2
06804:  MOVF   x8B,W
06806:  MOVLB  1
06808:  SUBWFB x68,W
0680A:  MOVWF  01
0680C:  MOVLB  2
0680E:  MOVF   x8C,W
06810:  MOVLB  1
06812:  SUBWFB x69,W
06814:  MOVLB  2
06816:  MOVF   x8D,W
06818:  MOVLB  1
0681A:  SUBWFB x6A,W
0681C:  MOVF   00,W
0681E:  MOVLB  2
06820:  SUBWF  x97,W
06822:  MOVWF  x95
06824:  MOVF   01,W
06826:  SUBWFB x98,W
06828:  MOVWF  x96
....................  
....................          // Update the local stored copy of the RemoteWindow. 
....................          // If previously we had a zero window, and now we don't, then  
....................          // immediately send whatever was pending. 
....................          if((MyTCB.remoteWindow == 0u) && wNewWindow) 
0682A:  MOVLB  1
0682C:  MOVF   x75,F
0682E:  BNZ   6846
06830:  MOVF   x76,F
06832:  BNZ   6846
06834:  MOVLB  2
06836:  MOVF   x95,W
06838:  IORWF  x96,W
0683A:  BTFSS  FD8.2
0683C:  BRA    6842
0683E:  MOVLB  1
06840:  BRA    6846
....................             MyTCBStub.Flags.bTXASAP = 1; 
06842:  MOVLB  1
06844:  BSF    xDF.1
....................          MyTCB.remoteWindow = wNewWindow; 
06846:  MOVFF  296,176
0684A:  MOVFF  295,175
....................  
....................          // A couple of states must do all of the TCP_ESTABLISHED stuff, but also a little more 
....................          if(MyTCBStub.smState == TCP_FIN_WAIT_1) 
0684E:  MOVF   xDD,W
06850:  SUBLW  08
06852:  BNZ   68B6
....................          { 
....................             // Check to see if our FIN has been ACKnowledged 
....................             if((MyTCB.MySEQ == localAckNumber) && MyTCB.flags.bFINSent) 
06854:  MOVLB  2
06856:  MOVF   x8A,W
06858:  MOVLB  1
0685A:  SUBWF  x67,W
0685C:  BNZ   68B4
0685E:  MOVLB  2
06860:  MOVF   x8B,W
06862:  MOVLB  1
06864:  SUBWF  x68,W
06866:  BNZ   68B4
06868:  MOVLB  2
0686A:  MOVF   x8C,W
0686C:  MOVLB  1
0686E:  SUBWF  x69,W
06870:  BNZ   68B4
06872:  MOVLB  2
06874:  MOVF   x8D,W
06876:  MOVLB  1
06878:  SUBWF  x6A,W
0687A:  BNZ   68B4
0687C:  BTFSS  x85.0
0687E:  BRA    68B4
....................             { 
....................                // Reset our timer for forced closure if the remote node  
....................                // doesn't send us a FIN in a timely manner. 
....................                MyTCBStub.eventTime = TickGet() + TCP_FIN_WAIT_2_TIMEOUT; 
06880:  MOVLB  0
06882:  CALL   1734
06886:  MOVLW  F3
06888:  MOVLB  2
0688A:  ADDWF  00,W
0688C:  MOVLB  1
0688E:  MOVWF  xD5
06890:  MOVLW  FA
06892:  MOVLB  2
06894:  ADDWFC 01,W
06896:  MOVLB  1
06898:  MOVWF  xD6
0689A:  MOVLW  02
0689C:  MOVLB  2
0689E:  ADDWFC 02,W
068A0:  MOVLB  1
068A2:  MOVWF  xD7
068A4:  MOVLW  00
068A6:  MOVLB  2
068A8:  ADDWFC 03,W
068AA:  MOVLB  1
068AC:  MOVWF  xD8
....................                MyTCBStub.Flags.bTimerEnabled = 1; 
068AE:  BSF    xDE.4
....................                MyTCBStub.smState = TCP_FIN_WAIT_2; 
068B0:  MOVLW  09
068B2:  MOVWF  xDD
....................             } 
....................          } 
068B4:  BRA    6928
....................          else if(MyTCBStub.smState == TCP_FIN_WAIT_2) 
068B6:  MOVF   xDD,W
068B8:  SUBLW  09
068BA:  BNZ   68EC
....................          { 
....................             // RFC noncompliance: 
....................             // The remote node should not keep sending us data  
....................             // indefinitely after we send a FIN to it.   
....................             // However, some bad stacks may still keep sending  
....................             // us data indefinitely after ACKing our FIN.  To  
....................             // prevent this from locking up our socket, let's  
....................             // send a RST right now and close forcefully on  
....................             // our side. 
....................             if(!(localHeaderFlags & FIN)) 
068BC:  MOVLB  2
068BE:  BTFSC  x89.0
068C0:  BRA    68E8
....................             { 
....................                MyTCB.MySEQ = localAckNumber;   // Set SEQ = SEG.ACK 
068C2:  MOVFF  28D,16A
068C6:  MOVFF  28C,169
068CA:  MOVFF  28B,168
068CE:  MOVFF  28A,167
....................                SendTCP(RST | ACK, 0); 
068D2:  MOVLW  14
068D4:  MOVWF  x97
068D6:  CLRF   x98
068D8:  MOVLB  0
068DA:  CALL   231A
....................                CloseSocket(); 
068DE:  CALL   13A6
....................                return; 
068E2:  GOTO   7074
068E6:  MOVLB  2
....................             } 
....................          } 
068E8:  BRA    692A
068EA:  MOVLB  1
....................          else if(MyTCBStub.smState == TCP_CLOSING) 
068EC:  MOVF   xDD,W
068EE:  SUBLW  0A
068F0:  BNZ   6928
....................          { 
....................             // Check to see if our FIN has been ACKnowledged 
....................             if(MyTCB.MySEQ == localAckNumber) 
068F2:  MOVLB  2
068F4:  MOVF   x8A,W
068F6:  MOVLB  1
068F8:  SUBWF  x67,W
068FA:  BNZ   6922
068FC:  MOVLB  2
068FE:  MOVF   x8B,W
06900:  MOVLB  1
06902:  SUBWF  x68,W
06904:  BNZ   6922
06906:  MOVLB  2
06908:  MOVF   x8C,W
0690A:  MOVLB  1
0690C:  SUBWF  x69,W
0690E:  BNZ   6922
06910:  MOVLB  2
06912:  MOVF   x8D,W
06914:  MOVLB  1
06916:  SUBWF  x6A,W
06918:  BNZ   6922
....................             { 
....................                // RFC not recommended: We should be going to  
....................                // the TCP_TIME_WAIT state right here and  
....................                // starting a 2MSL timer, but since we have so  
....................                // few precious sockets, we can't afford to  
....................                // leave a socket waiting around doing nothing  
....................                // for a long time.  If the remote node does  
....................                // not recieve this ACK, it'll have to figure  
....................                // out on it's own that the connection is now  
....................                // closed. 
....................                CloseSocket(); 
0691A:  MOVLB  0
0691C:  CALL   13A6
06920:  MOVLB  1
....................             } 
....................  
....................             return; 
06922:  MOVLB  0
06924:  GOTO   7074
06928:  MOVLB  2
....................          } 
....................  
....................          break; 
0692A:  BRA    697C
....................  
....................       case TCP_LAST_ACK: 
....................          // Check to see if our FIN has been ACKnowledged 
....................          if(MyTCB.MySEQ + 1 == localAckNumber) 
0692C:  MOVLW  01
0692E:  MOVLB  1
06930:  ADDWF  x67,W
06932:  MOVLB  2
06934:  MOVWF  x97
06936:  MOVLW  00
06938:  MOVLB  1
0693A:  ADDWFC x68,W
0693C:  MOVLB  2
0693E:  MOVWF  x98
06940:  MOVLW  00
06942:  MOVLB  1
06944:  ADDWFC x69,W
06946:  MOVLB  2
06948:  MOVWF  x99
0694A:  MOVLW  00
0694C:  MOVLB  1
0694E:  ADDWFC x6A,W
06950:  MOVLB  2
06952:  MOVWF  x9A
06954:  MOVF   x8A,W
06956:  SUBWF  x97,W
06958:  BNZ   6974
0695A:  MOVF   x8B,W
0695C:  SUBWF  x98,W
0695E:  BNZ   6974
06960:  MOVF   x8C,W
06962:  SUBWF  x99,W
06964:  BNZ   6974
06966:  MOVF   x8D,W
06968:  SUBWF  x9A,W
0696A:  BNZ   6974
....................             CloseSocket(); 
0696C:  MOVLB  0
0696E:  CALL   13A6
06972:  MOVLB  2
....................          return; 
06974:  MOVLB  0
06976:  GOTO   7074
....................  
.................... //      case TCP_TIME_WAIT: 
.................... //         // Nothing is supposed to arrive here.  If it does, reset the quiet timer. 
.................... //         SendTCP(ACK, SENDTCP_RESET_TIMERS); 
.................... //         return; 
....................  
....................       default: 
....................          break; 
0697A:  MOVLB  2
....................    } 
....................  
....................    // 
....................    // Sixth: Check the URG bit 
....................    // 
....................    // Urgent packets are not supported in this stack, so we 
....................    // will throw them away instead 
....................    if(localHeaderFlags & URG) 
0697C:  BTFSS  x89.5
0697E:  BRA    6986
....................       return; 
06980:  MOVLB  0
06982:  BRA    7074
06984:  MOVLB  2
....................  
....................    // 
....................    // Seventh: Process the segment text 
....................    // 
....................    // Throw data away if in a state that doesn't accept data 
....................    if(MyTCBStub.smState == TCP_CLOSE_WAIT) 
06986:  MOVLB  1
06988:  MOVF   xDD,W
0698A:  SUBLW  0B
0698C:  BNZ   6994
....................       return; 
0698E:  MOVLB  0
06990:  BRA    7074
06992:  MOVLB  1
....................    if(MyTCBStub.smState == TCP_CLOSING) 
06994:  MOVF   xDD,W
06996:  SUBLW  0A
06998:  BNZ   69A0
....................       return; 
0699A:  MOVLB  0
0699C:  BRA    7074
0699E:  MOVLB  1
....................    if(MyTCBStub.smState == TCP_LAST_ACK) 
069A0:  MOVF   xDD,W
069A2:  SUBLW  0C
069A4:  BNZ   69AC
....................       return; 
069A6:  MOVLB  0
069A8:  BRA    7074
069AA:  MOVLB  1
.................... //   if(MyTCBStub.smState == TCP_TIME_WAIT) 
.................... //      return; 
....................  
....................    // Copy any valid segment data into our RX FIFO, if any 
....................    if(len) 
069AC:  MOVLB  2
069AE:  MOVF   x79,W
069B0:  IORWF  x7A,W
069B2:  BTFSC  FD8.2
069B4:  BRA    6EE2
....................    { 
....................       // See if there are bytes we must skip 
....................       if((SHORT)wMissingBytes <= 0) 
069B6:  BTFSC  x86.7
069B8:  BRA    69C8
069BA:  MOVF   x86,F
069BC:  BTFSS  FD8.2
069BE:  BRA    6BD4
069C0:  MOVF   x85,W
069C2:  SUBLW  00
069C4:  BTFSS  FD8.0
069C6:  BRA    6BD4
....................       { 
....................          // Position packet read pointer to start of useful data area. 
....................          IPSetRxBuffer((h->DataOffset.Val << 2) - wMissingBytes); 
069C8:  MOVLW  0C
069CA:  ADDWF  x77,W
069CC:  MOVWF  FE9
069CE:  MOVLW  00
069D0:  ADDWFC x78,W
069D2:  MOVWF  FEA
069D4:  MOVFF  FEF,00
069D8:  SWAPF  00,W
069DA:  ANDLW  0F
069DC:  MOVWF  00
069DE:  RLCF   00,F
069E0:  RLCF   00,F
069E2:  MOVLW  FC
069E4:  ANDWF  00,F
069E6:  MOVF   00,W
069E8:  BSF    FD8.0
069EA:  SUBFWB x85,W
069EC:  MOVWF  x97
069EE:  MOVLW  00
069F0:  SUBFWB x86,W
069F2:  MOVWF  x98
069F4:  MOVWF  x9C
069F6:  MOVFF  297,29B
069FA:  MOVLB  0
069FC:  CALL   393C
....................          len += wMissingBytes;       
06A00:  MOVLB  2
06A02:  MOVF   x85,W
06A04:  ADDWF  x79,F
06A06:  MOVF   x86,W
06A08:  ADDWFC x7A,F
....................     
....................          // Truncate packets that would overflow our TCP RX FIFO 
....................          // and request a retransmit by sending a duplicate ACK 
....................          if(len > wFreeSpace) 
06A0A:  MOVF   x88,W
06A0C:  SUBWF  x7A,W
06A0E:  BNC   6A20
06A10:  BNZ   6A18
06A12:  MOVF   x79,W
06A14:  SUBWF  x87,W
06A16:  BC    6A20
....................             len = wFreeSpace; 
06A18:  MOVFF  288,27A
06A1C:  MOVFF  287,279
....................     
....................          MyTCB.RemoteSEQ += (DWORD)len; 
06A20:  MOVFF  27A,01
06A24:  CLRF   02
06A26:  CLRF   03
06A28:  MOVF   x79,W
06A2A:  MOVLB  1
06A2C:  ADDWF  x6B,F
06A2E:  MOVF   01,W
06A30:  ADDWFC x6C,F
06A32:  MOVF   02,W
06A34:  ADDWFC x6D,F
06A36:  MOVF   03,W
06A38:  ADDWFC x6E,F
....................        
....................          // Copy the application data from the packet into the socket RX FIFO 
....................          // See if we need a two part copy (spans bufferEnd->bufferRxStart) 
....................          if(MyTCBStub.rxHead + len > MyTCBStub.bufferEnd) 
06A3A:  MOVLB  2
06A3C:  MOVF   x79,W
06A3E:  MOVLB  1
06A40:  ADDWF  xD1,W
06A42:  MOVLB  2
06A44:  MOVWF  x97
06A46:  MOVF   x7A,W
06A48:  MOVLB  1
06A4A:  ADDWFC xD2,W
06A4C:  MOVLB  2
06A4E:  MOVWF  x98
06A50:  MOVLB  1
06A52:  MOVF   xCC,W
06A54:  MOVLB  2
06A56:  SUBWF  x98,W
06A58:  BNC   6AF8
06A5A:  BNZ   6A6C
06A5C:  MOVF   x97,W
06A5E:  MOVLB  1
06A60:  SUBWF  xCB,W
06A62:  BTFSS  FD8.0
06A64:  BRA    6A6A
06A66:  MOVLB  2
06A68:  BRA    6AF8
06A6A:  MOVLB  2
....................          { 
....................             wTemp = MyTCBStub.bufferEnd - MyTCBStub.rxHead + 1; 
06A6C:  MOVLB  1
06A6E:  MOVF   xD1,W
06A70:  SUBWF  xCB,W
06A72:  MOVLB  2
06A74:  MOVWF  x97
06A76:  MOVLB  1
06A78:  MOVF   xD2,W
06A7A:  SUBWFB xCC,W
06A7C:  MOVLB  2
06A7E:  MOVWF  x98
06A80:  MOVLW  01
06A82:  ADDWF  x97,W
06A84:  MOVWF  x7F
06A86:  MOVLW  00
06A88:  ADDWFC x98,W
06A8A:  MOVWF  x80
....................             TCPRAMCopy(MyTCBStub.rxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, wTemp); 
06A8C:  MOVFF  1D2,2C9
06A90:  MOVFF  1D1,2C8
06A94:  MOVFF  1E2,2CA
06A98:  SETF   xCC
06A9A:  SETF   xCB
06A9C:  CLRF   xCD
06A9E:  MOVFF  280,2CF
06AA2:  MOVFF  27F,2CE
06AA6:  MOVLB  0
06AA8:  CALL   11E8
....................             TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len - wTemp); 
06AAC:  MOVLB  2
06AAE:  MOVF   x7F,W
06AB0:  SUBWF  x79,W
06AB2:  MOVWF  x97
06AB4:  MOVF   x80,W
06AB6:  SUBWFB x7A,W
06AB8:  MOVWF  x98
06ABA:  MOVFF  1CA,2C9
06ABE:  MOVFF  1C9,2C8
06AC2:  MOVFF  1E2,2CA
06AC6:  SETF   xCC
06AC8:  SETF   xCB
06ACA:  CLRF   xCD
06ACC:  MOVWF  xCF
06ACE:  MOVFF  297,2CE
06AD2:  MOVLB  0
06AD4:  CALL   11E8
....................             MyTCBStub.rxHead = MyTCBStub.bufferRxStart + (len - wTemp); 
06AD8:  MOVLB  2
06ADA:  MOVF   x7F,W
06ADC:  SUBWF  x79,W
06ADE:  MOVWF  00
06AE0:  MOVF   x80,W
06AE2:  SUBWFB x7A,W
06AE4:  MOVWF  03
06AE6:  MOVF   00,W
06AE8:  MOVLB  1
06AEA:  ADDWF  xC9,W
06AEC:  MOVWF  xD1
06AEE:  MOVF   03,W
06AF0:  ADDWFC xCA,W
06AF2:  MOVWF  xD2
....................          } 
06AF4:  BRA    6B28
06AF6:  MOVLB  2
....................          else 
....................          { 
....................             TCPRAMCopy(MyTCBStub.rxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len); 
06AF8:  MOVFF  1D2,2C9
06AFC:  MOVFF  1D1,2C8
06B00:  MOVFF  1E2,2CA
06B04:  SETF   xCC
06B06:  SETF   xCB
06B08:  CLRF   xCD
06B0A:  MOVFF  27A,2CF
06B0E:  MOVFF  279,2CE
06B12:  MOVLB  0
06B14:  CALL   11E8
....................             MyTCBStub.rxHead += len; 
06B18:  MOVLB  2
06B1A:  MOVF   x79,W
06B1C:  MOVLB  1
06B1E:  ADDWF  xD1,F
06B20:  MOVLB  2
06B22:  MOVF   x7A,W
06B24:  MOVLB  1
06B26:  ADDWFC xD2,F
....................          } 
....................        
....................          // See if we have a hole and other data waiting already in the RX FIFO 
....................          if(MyTCB.sHoleSize != -1) 
06B28:  INCFSZ x83,W
06B2A:  BRA    6B32
06B2C:  INCFSZ x84,W
06B2E:  BRA    6B32
06B30:  BRA    6BD0
....................          { 
....................             MyTCB.sHoleSize -= len; 
06B32:  MOVLB  2
06B34:  MOVF   x79,W
06B36:  MOVLB  1
06B38:  SUBWF  x83,F
06B3A:  MOVLB  2
06B3C:  MOVF   x7A,W
06B3E:  MOVLB  1
06B40:  SUBWFB x84,F
....................             wTemp = MyTCB.wFutureDataSize + MyTCB.sHoleSize; 
06B42:  MOVF   x83,W
06B44:  ADDWF  x77,W
06B46:  MOVWF  01
06B48:  MOVF   x84,W
06B4A:  ADDWFC x78,W
06B4C:  MOVFF  01,27F
06B50:  MOVLB  2
06B52:  MOVWF  x80
....................        
....................             // See if we just closed up a hole, and if so, advance head pointer 
....................             if((SHORT)wTemp < (SHORT)0) 
06B54:  BTFSS  x80.7
06B56:  BRA    6B60
....................             { 
....................                MyTCB.sHoleSize = -1; 
06B58:  MOVLB  1
06B5A:  SETF   x84
06B5C:  SETF   x83
....................             } 
06B5E:  BRA    6BD0
....................             else if(MyTCB.sHoleSize <= 0) 
06B60:  MOVLB  1
06B62:  BTFSC  x84.7
06B64:  BRA    6B70
06B66:  MOVF   x84,F
06B68:  BNZ   6BD0
06B6A:  MOVF   x83,W
06B6C:  SUBLW  00
06B6E:  BNC   6BD0
....................             { 
....................                MyTCB.RemoteSEQ += wTemp; 
06B70:  MOVLB  2
06B72:  MOVF   x7F,W
06B74:  MOVLB  1
06B76:  ADDWF  x6B,F
06B78:  MOVLB  2
06B7A:  MOVF   x80,W
06B7C:  MOVLB  1
06B7E:  ADDWFC x6C,F
06B80:  MOVLW  00
06B82:  ADDWFC x6D,F
06B84:  ADDWFC x6E,F
....................                MyTCBStub.rxHead += wTemp; 
06B86:  MOVLB  2
06B88:  MOVF   x7F,W
06B8A:  MOVLB  1
06B8C:  ADDWF  xD1,F
06B8E:  MOVLB  2
06B90:  MOVF   x80,W
06B92:  MOVLB  1
06B94:  ADDWFC xD2,F
....................                if(MyTCBStub.rxHead > MyTCBStub.bufferEnd) 
06B96:  MOVF   xCC,W
06B98:  SUBWF  xD2,W
06B9A:  BNC   6BCC
06B9C:  BNZ   6BA4
06B9E:  MOVF   xD1,W
06BA0:  SUBWF  xCB,W
06BA2:  BC    6BCC
....................                   MyTCBStub.rxHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;                      
06BA4:  MOVF   xC9,W
06BA6:  SUBWF  xCB,W
06BA8:  MOVLB  2
06BAA:  MOVWF  x97
06BAC:  MOVLB  1
06BAE:  MOVF   xCA,W
06BB0:  SUBWFB xCC,W
06BB2:  MOVLB  2
06BB4:  MOVWF  x98
06BB6:  MOVLW  01
06BB8:  ADDWF  x97,W
06BBA:  MOVWF  01
06BBC:  MOVLW  00
06BBE:  ADDWFC x98,W
06BC0:  MOVWF  03
06BC2:  MOVF   01,W
06BC4:  MOVLB  1
06BC6:  SUBWF  xD1,F
06BC8:  MOVF   03,W
06BCA:  SUBWFB xD2,F
....................                MyTCB.sHoleSize = -1; 
06BCC:  SETF   x84
06BCE:  SETF   x83
....................             } 
....................          } 
....................       } // This packet is out of order or we lost a packet, see if we can generate a hole to accomodate it 
06BD0:  BRA    6EE0
06BD2:  MOVLB  2
....................       else if((SHORT)wMissingBytes > 0) 
06BD4:  BTFSC  x86.7
06BD6:  BRA    6EE2
06BD8:  MOVF   x86,F
06BDA:  BNZ   6BE4
06BDC:  MOVF   x85,W
06BDE:  SUBLW  00
06BE0:  BTFSC  FD8.0
06BE2:  BRA    6EE2
....................       { 
....................          // Truncate packets that would overflow our TCP RX FIFO 
....................          if(len + wMissingBytes > wFreeSpace) 
06BE4:  MOVF   x85,W
06BE6:  ADDWF  x79,W
06BE8:  MOVWF  x97
06BEA:  MOVF   x86,W
06BEC:  ADDWFC x7A,W
06BEE:  MOVWF  x98
06BF0:  MOVF   x88,W
06BF2:  SUBWF  x98,W
06BF4:  BNC   6C0A
06BF6:  BNZ   6BFE
06BF8:  MOVF   x97,W
06BFA:  SUBWF  x87,W
06BFC:  BC    6C0A
....................             len = wFreeSpace - wMissingBytes; 
06BFE:  MOVF   x85,W
06C00:  SUBWF  x87,W
06C02:  MOVWF  x79
06C04:  MOVF   x86,W
06C06:  SUBWFB x88,W
06C08:  MOVWF  x7A
....................        
....................          // Position packet read pointer to start of useful data area. 
....................          IPSetRxBuffer(h->DataOffset.Val << 2); 
06C0A:  MOVLW  0C
06C0C:  ADDWF  x77,W
06C0E:  MOVWF  FE9
06C10:  MOVLW  00
06C12:  ADDWFC x78,W
06C14:  MOVWF  FEA
06C16:  MOVFF  FEF,00
06C1A:  SWAPF  00,W
06C1C:  ANDLW  0F
06C1E:  MOVWF  00
06C20:  RLCF   00,W
06C22:  MOVWF  x97
06C24:  RLCF   x97,F
06C26:  MOVLW  FC
06C28:  ANDWF  x97,F
06C2A:  CLRF   x9C
06C2C:  MOVFF  297,29B
06C30:  MOVLB  0
06C32:  CALL   393C
....................     
....................          // See if we need a two part copy (spans bufferEnd->bufferRxStart) 
....................          if(MyTCBStub.rxHead + wMissingBytes + len > MyTCBStub.bufferEnd) 
06C36:  MOVLB  2
06C38:  MOVF   x85,W
06C3A:  MOVLB  1
06C3C:  ADDWF  xD1,W
06C3E:  MOVLB  2
06C40:  MOVWF  x97
06C42:  MOVF   x86,W
06C44:  MOVLB  1
06C46:  ADDWFC xD2,W
06C48:  MOVLB  2
06C4A:  MOVWF  x98
06C4C:  MOVF   x79,W
06C4E:  ADDWF  x97,F
06C50:  MOVF   x7A,W
06C52:  ADDWFC x98,F
06C54:  MOVLB  1
06C56:  MOVF   xCC,W
06C58:  MOVLB  2
06C5A:  SUBWF  x98,W
06C5C:  BTFSS  FD8.0
06C5E:  BRA    6D60
06C60:  BNZ   6C72
06C62:  MOVF   x97,W
06C64:  MOVLB  1
06C66:  SUBWF  xCB,W
06C68:  BTFSS  FD8.0
06C6A:  BRA    6C70
06C6C:  MOVLB  2
06C6E:  BRA    6D60
06C70:  MOVLB  2
....................          { 
....................             // Calculate number of data bytes to copy before wraparound 
....................             wTemp = MyTCBStub.bufferEnd - MyTCBStub.rxHead + 1 - wMissingBytes; 
06C72:  MOVLB  1
06C74:  MOVF   xD1,W
06C76:  SUBWF  xCB,W
06C78:  MOVLB  2
06C7A:  MOVWF  x97
06C7C:  MOVLB  1
06C7E:  MOVF   xD2,W
06C80:  SUBWFB xCC,W
06C82:  MOVLB  2
06C84:  MOVWF  x98
06C86:  MOVLW  01
06C88:  ADDWF  x97,F
06C8A:  MOVLW  00
06C8C:  ADDWFC x98,F
06C8E:  MOVF   x85,W
06C90:  SUBWF  x97,W
06C92:  MOVWF  x7F
06C94:  MOVF   x86,W
06C96:  SUBWFB x98,W
06C98:  MOVWF  x80
....................             if((SHORT)wTemp >= 0) 
06C9A:  BTFSC  x80.7
06C9C:  BRA    6D00
....................             { 
....................                TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, wTemp); 
06C9E:  MOVF   x85,W
06CA0:  MOVLB  1
06CA2:  ADDWF  xD1,W
06CA4:  MOVLB  2
06CA6:  MOVWF  x97
06CA8:  MOVF   x86,W
06CAA:  MOVLB  1
06CAC:  ADDWFC xD2,W
06CAE:  MOVLB  2
06CB0:  MOVWF  x98
06CB2:  MOVWF  xC9
06CB4:  MOVFF  297,2C8
06CB8:  MOVFF  1E2,2CA
06CBC:  SETF   xCC
06CBE:  SETF   xCB
06CC0:  CLRF   xCD
06CC2:  MOVFF  280,2CF
06CC6:  MOVFF  27F,2CE
06CCA:  MOVLB  0
06CCC:  CALL   11E8
....................                TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len - wTemp); 
06CD0:  MOVLB  2
06CD2:  MOVF   x7F,W
06CD4:  SUBWF  x79,W
06CD6:  MOVWF  x97
06CD8:  MOVF   x80,W
06CDA:  SUBWFB x7A,W
06CDC:  MOVWF  x98
06CDE:  MOVFF  1CA,2C9
06CE2:  MOVFF  1C9,2C8
06CE6:  MOVFF  1E2,2CA
06CEA:  SETF   xCC
06CEC:  SETF   xCB
06CEE:  CLRF   xCD
06CF0:  MOVWF  xCF
06CF2:  MOVFF  297,2CE
06CF6:  MOVLB  0
06CF8:  CALL   11E8
....................             } 
06CFC:  BRA    6D5C
06CFE:  MOVLB  2
....................             else 
....................             { 
....................                TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes - (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1), MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len); 
06D00:  MOVF   x85,W
06D02:  MOVLB  1
06D04:  ADDWF  xD1,W
06D06:  MOVLB  2
06D08:  MOVWF  x97
06D0A:  MOVF   x86,W
06D0C:  MOVLB  1
06D0E:  ADDWFC xD2,W
06D10:  MOVLB  2
06D12:  MOVWF  x98
06D14:  MOVLB  1
06D16:  MOVF   xC9,W
06D18:  SUBWF  xCB,W
06D1A:  MOVLB  2
06D1C:  MOVWF  x99
06D1E:  MOVLB  1
06D20:  MOVF   xCA,W
06D22:  SUBWFB xCC,W
06D24:  MOVLB  2
06D26:  MOVWF  x9A
06D28:  MOVLW  01
06D2A:  ADDWF  x99,W
06D2C:  MOVWF  01
06D2E:  MOVLW  00
06D30:  ADDWFC x9A,W
06D32:  MOVWF  03
06D34:  MOVF   01,W
06D36:  SUBWF  x97,F
06D38:  MOVF   03,W
06D3A:  SUBWFB x98,F
06D3C:  MOVFF  298,2C9
06D40:  MOVFF  297,2C8
06D44:  MOVFF  1E2,2CA
06D48:  SETF   xCC
06D4A:  SETF   xCB
06D4C:  CLRF   xCD
06D4E:  MOVFF  27A,2CF
06D52:  MOVFF  279,2CE
06D56:  MOVLB  0
06D58:  CALL   11E8
....................             } 
....................          } 
06D5C:  BRA    6D92
06D5E:  MOVLB  2
....................          else 
....................          { 
....................             TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len); 
06D60:  MOVF   x85,W
06D62:  MOVLB  1
06D64:  ADDWF  xD1,W
06D66:  MOVLB  2
06D68:  MOVWF  x97
06D6A:  MOVF   x86,W
06D6C:  MOVLB  1
06D6E:  ADDWFC xD2,W
06D70:  MOVLB  2
06D72:  MOVWF  x98
06D74:  MOVWF  xC9
06D76:  MOVFF  297,2C8
06D7A:  MOVFF  1E2,2CA
06D7E:  SETF   xCC
06D80:  SETF   xCB
06D82:  CLRF   xCD
06D84:  MOVFF  27A,2CF
06D88:  MOVFF  279,2CE
06D8C:  MOVLB  0
06D8E:  CALL   11E8
....................          } 
....................        
....................          // Record the hole is here 
....................          if(MyTCB.sHoleSize == -1) 
06D92:  MOVLB  1
06D94:  INCFSZ x83,W
06D96:  BRA    6DAE
06D98:  INCFSZ x84,W
06D9A:  BRA    6DAE
....................          { 
....................             MyTCB.sHoleSize = wMissingBytes; 
06D9C:  MOVFF  286,184
06DA0:  MOVFF  285,183
....................             MyTCB.wFutureDataSize = len; 
06DA4:  MOVFF  27A,178
06DA8:  MOVFF  279,177
....................          } 
06DAC:  BRA    6EE0
....................          else 
....................          { 
....................             // We already have a hole, see if we can shrink the hole  
....................             // or extend the future data size 
....................             if(wMissingBytes < (WORD)MyTCB.sHoleSize) 
06DAE:  MOVLB  2
06DB0:  MOVF   x86,W
06DB2:  MOVLB  1
06DB4:  SUBWF  x84,W
06DB6:  BNC   6E5A
06DB8:  BNZ   6DCA
06DBA:  MOVF   x83,W
06DBC:  MOVLB  2
06DBE:  SUBWF  x85,W
06DC0:  BTFSS  FD8.0
06DC2:  BRA    6DC8
06DC4:  MOVLB  1
06DC6:  BRA    6E5A
06DC8:  MOVLB  1
....................             { 
....................                if((wMissingBytes + len > (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize) || (wMissingBytes + len < (WORD)MyTCB.sHoleSize)) 
06DCA:  MOVLB  2
06DCC:  MOVF   x79,W
06DCE:  ADDWF  x85,W
06DD0:  MOVWF  x97
06DD2:  MOVF   x7A,W
06DD4:  ADDWFC x86,W
06DD6:  MOVWF  x98
06DD8:  MOVLB  1
06DDA:  MOVF   x77,W
06DDC:  ADDWF  x83,W
06DDE:  MOVWF  01
06DE0:  MOVF   x78,W
06DE2:  ADDWFC x84,W
06DE4:  MOVWF  03
06DE6:  MOVF   03,W
06DE8:  MOVLB  2
06DEA:  SUBWF  x98,W
06DEC:  BNC   6DF6
06DEE:  BNZ   6E1E
06DF0:  MOVF   x97,W
06DF2:  SUBWF  01,W
06DF4:  BNC   6E1E
06DF6:  MOVF   x79,W
06DF8:  ADDWF  x85,W
06DFA:  MOVWF  x97
06DFC:  MOVF   x7A,W
06DFE:  ADDWFC x86,W
06E00:  MOVWF  x98
06E02:  MOVLB  1
06E04:  SUBWF  x84,W
06E06:  BNC   6E2A
06E08:  BTFSC  FD8.2
06E0A:  BRA    6E10
06E0C:  MOVLB  2
06E0E:  BRA    6E1E
06E10:  MOVF   x83,W
06E12:  MOVLB  2
06E14:  SUBWF  x97,W
06E16:  BTFSS  FD8.0
06E18:  BRA    6E1E
06E1A:  MOVLB  1
06E1C:  BRA    6E2A
....................                   MyTCB.wFutureDataSize = len; 
06E1E:  MOVFF  27A,178
06E22:  MOVFF  279,177
06E26:  BRA    6E50
06E28:  MOVLB  1
....................                else 
....................                   MyTCB.wFutureDataSize = (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize - wMissingBytes; 
06E2A:  MOVF   x77,W
06E2C:  ADDWF  x83,W
06E2E:  MOVLB  2
06E30:  MOVWF  x97
06E32:  MOVLB  1
06E34:  MOVF   x78,W
06E36:  ADDWFC x84,W
06E38:  MOVLB  2
06E3A:  MOVWF  x98
06E3C:  MOVF   x85,W
06E3E:  SUBWF  x97,W
06E40:  MOVLB  1
06E42:  MOVWF  x77
06E44:  MOVLB  2
06E46:  MOVF   x86,W
06E48:  SUBWFB x98,W
06E4A:  MOVLB  1
06E4C:  MOVWF  x78
06E4E:  MOVLB  2
....................                MyTCB.sHoleSize = wMissingBytes; 
06E50:  MOVFF  286,184
06E54:  MOVFF  285,183
....................             } 
06E58:  BRA    6EE2
....................             else if(wMissingBytes + len > (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize) 
06E5A:  MOVLB  2
06E5C:  MOVF   x79,W
06E5E:  ADDWF  x85,W
06E60:  MOVWF  x97
06E62:  MOVF   x7A,W
06E64:  ADDWFC x86,W
06E66:  MOVWF  x98
06E68:  MOVLB  1
06E6A:  MOVF   x77,W
06E6C:  ADDWF  x83,W
06E6E:  MOVWF  01
06E70:  MOVF   x78,W
06E72:  ADDWFC x84,W
06E74:  MOVWF  03
06E76:  MOVF   03,W
06E78:  MOVLB  2
06E7A:  SUBWF  x98,W
06E7C:  BNC   6EE2
06E7E:  BNZ   6E86
06E80:  MOVF   x97,W
06E82:  SUBWF  01,W
06E84:  BC    6EE2
....................             { 
....................                // Make sure that there isn't a second hole between  
....................                // our future data and this TCP segment's future data 
....................                if(wMissingBytes <= (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize) 
06E86:  MOVLB  1
06E88:  MOVF   x77,W
06E8A:  ADDWF  x83,W
06E8C:  MOVWF  01
06E8E:  MOVF   x78,W
06E90:  ADDWFC x84,W
06E92:  MOVWF  03
06E94:  MOVF   01,W
06E96:  MOVLB  2
06E98:  MOVF   x86,W
06E9A:  SUBWF  03,W
06E9C:  BNC   6EE2
06E9E:  BNZ   6EA6
06EA0:  MOVF   x85,W
06EA2:  SUBWF  01,W
06EA4:  BNC   6EE2
....................                   MyTCB.wFutureDataSize += wMissingBytes + len - (WORD)MyTCB.sHoleSize - MyTCB.wFutureDataSize; 
06EA6:  MOVF   x79,W
06EA8:  ADDWF  x85,W
06EAA:  MOVWF  x97
06EAC:  MOVF   x7A,W
06EAE:  ADDWFC x86,W
06EB0:  MOVWF  x98
06EB2:  MOVLB  1
06EB4:  MOVF   x83,W
06EB6:  MOVLB  2
06EB8:  SUBWF  x97,F
06EBA:  MOVLB  1
06EBC:  MOVF   x84,W
06EBE:  MOVLB  2
06EC0:  SUBWFB x98,F
06EC2:  MOVLB  1
06EC4:  MOVF   x77,W
06EC6:  MOVLB  2
06EC8:  SUBWF  x97,W
06ECA:  MOVWF  00
06ECC:  MOVLB  1
06ECE:  MOVF   x78,W
06ED0:  MOVLB  2
06ED2:  SUBWFB x98,W
06ED4:  MOVWF  03
06ED6:  MOVF   00,W
06ED8:  MOVLB  1
06EDA:  ADDWF  x77,F
06EDC:  MOVF   03,W
06EDE:  ADDWFC x78,F
06EE0:  MOVLB  2
....................             } 
....................              
....................          } 
....................       } 
....................    } 
....................  
....................    // Send back an ACK of the data (+SYN | FIN) we just received,  
....................    // if any.  To minimize bandwidth waste, we are implementing  
....................    // the delayed acknowledgement algorithm here, only sending  
....................    // back an immediate ACK if this is the second segment received.   
....................    // Otherwise, a 200ms timer will cause the ACK to be transmitted. 
....................    if(wSegmentLength) 
06EE2:  MOVF   x92,W
06EE4:  IORWF  x93,W
06EE6:  BZ    6F3A
....................    { 
....................       // For non-established sockets, let's delete all data in  
....................       // the RX buffer immediately after receiving it.  This is  
....................       // not really how TCP was intended to operate since a  
....................       // socket cannot receive any response after it sends a FIN, 
....................       // but our TCP application API doesn't readily accomodate 
....................       // receiving data after calling TCPDisconnect(), which  
....................       // invalidates the application TCP handle.  By deleting all  
....................       // data, we'll ensure that the RX window is nonzero and  
....................       // the remote node will be able to send us a FIN response,  
....................       // which needs an RX window of at least 1. 
....................       if(MyTCBStub.smState != TCP_ESTABLISHED) 
06EE8:  MOVLB  1
06EEA:  MOVF   xDD,W
06EEC:  SUBLW  07
06EEE:  BZ    6EF8
....................          MyTCBStub.rxTail = MyTCBStub.rxHead; 
06EF0:  MOVFF  1D2,1D4
06EF4:  MOVFF  1D1,1D3
....................  
....................       if(MyTCBStub.Flags.bOneSegmentReceived) 
06EF8:  BTFSS  xDE.7
06EFA:  BRA    6F14
....................       { 
....................          SendTCP(ACK, SENDTCP_RESET_TIMERS); 
06EFC:  MOVLW  10
06EFE:  MOVLB  2
06F00:  MOVWF  x97
06F02:  MOVLW  01
06F04:  MOVWF  x98
06F06:  MOVLB  0
06F08:  CALL   231A
....................          SyncTCB(); 
06F0C:  CALL   12CE
....................          // bOneSegmentReceived is cleared in SendTCP(), so no need here 
....................       } 
06F10:  BRA    6F38
06F12:  MOVLB  1
....................       else 
....................       { 
....................          MyTCBStub.Flags.bOneSegmentReceived = TRUE;    
06F14:  BSF    xDE.7
....................        
....................          // Do not send an ACK immediately back.  Instead, we will  
....................          // perform delayed acknowledgements.  To do this, we will  
....................          // just start a timer 
....................          if(!MyTCBStub.Flags.bDelayedACKTimerEnabled) 
06F16:  BTFSC  xDE.6
06F18:  BRA    6F36
....................          { 
....................             MyTCBStub.Flags.bDelayedACKTimerEnabled = 1; 
06F1A:  BSF    xDE.6
....................             MyTCBStub.OverlappedTimers.delayedACKTime = (WORD)TickGetDiv256() + (WORD)((TCP_DELAYED_ACK_TIMEOUT)>>8); 
06F1C:  MOVLB  0
06F1E:  CALL   16EE
06F22:  MOVLW  0F
06F24:  MOVLB  2
06F26:  ADDWF  00,W
06F28:  MOVLB  1
06F2A:  MOVWF  xDB
06F2C:  MOVLW  00
06F2E:  MOVLB  2
06F30:  ADDWFC 01,W
06F32:  MOVLB  1
06F34:  MOVWF  xDC
06F36:  MOVLB  0
06F38:  MOVLB  2
....................          } 
....................       } 
....................    } 
....................  
....................    // 
....................    // Eighth: check the FIN bit 
....................    // 
....................    if(localHeaderFlags & FIN) 
06F3A:  BTFSS  x89.0
06F3C:  BRA    7076
....................    { 
....................       // Note: Since we don't have a good means of storing "FIN bytes"  
....................       // in our TCP RX FIFO, we must ensure that FINs are processed  
....................       // in-order. 
....................       if(MyTCB.RemoteSEQ + 1 == localSeqNumber + (DWORD)wSegmentLength) 
06F3E:  MOVLW  01
06F40:  MOVLB  1
06F42:  ADDWF  x6B,W
06F44:  MOVLB  2
06F46:  MOVWF  x97
06F48:  MOVLW  00
06F4A:  MOVLB  1
06F4C:  ADDWFC x6C,W
06F4E:  MOVLB  2
06F50:  MOVWF  x98
06F52:  MOVLW  00
06F54:  MOVLB  1
06F56:  ADDWFC x6D,W
06F58:  MOVLB  2
06F5A:  MOVWF  x99
06F5C:  MOVLW  00
06F5E:  MOVLB  1
06F60:  ADDWFC x6E,W
06F62:  MOVLB  2
06F64:  MOVWF  x9A
06F66:  MOVFF  292,00
06F6A:  MOVFF  293,01
06F6E:  CLRF   02
06F70:  CLRF   03
06F72:  MOVF   x8E,W
06F74:  ADDWF  00,F
06F76:  MOVF   x8F,W
06F78:  ADDWFC 01,F
06F7A:  MOVF   x90,W
06F7C:  ADDWFC 02,F
06F7E:  MOVF   x91,W
06F80:  ADDWFC 03,F
06F82:  MOVF   00,W
06F84:  SUBWF  x97,W
06F86:  BTFSS  FD8.2
06F88:  BRA    7076
06F8A:  MOVF   01,W
06F8C:  SUBWF  x98,W
06F8E:  BTFSS  FD8.2
06F90:  BRA    7076
06F92:  MOVF   02,W
06F94:  SUBWF  x99,W
06F96:  BTFSS  FD8.2
06F98:  BRA    7076
06F9A:  MOVF   03,W
06F9C:  SUBWF  x9A,W
06F9E:  BTFSS  FD8.2
06FA0:  BRA    7076
....................       { 
....................          // FINs are treated as one byte of data for ACK sequencing 
....................          MyTCB.RemoteSEQ++; 
06FA2:  MOVLW  01
06FA4:  MOVLB  1
06FA6:  ADDWF  x6B,F
06FA8:  BTFSC  FD8.0
06FAA:  INCF   x6C,F
06FAC:  BTFSC  FD8.2
06FAE:  INCF   x6D,F
06FB0:  BTFSC  FD8.2
06FB2:  INCF   x6E,F
....................           
....................          switch(MyTCBStub.smState) 
06FB4:  MOVF   xDD,W
06FB6:  XORLW  06
06FB8:  MOVLB  0
06FBA:  BZ    6FCA
06FBC:  XORLW  01
06FBE:  BZ    6FE2
06FC0:  XORLW  0F
06FC2:  BZ    7004
06FC4:  XORLW  01
06FC6:  BZ    704E
06FC8:  BRA    7062
....................          { 
....................             case TCP_SYN_RECEIVED: 
....................                // RFC in exact: Our API has no need for the user  
....................                // to explicitly close a socket that never really  
....................                // got opened fully in the first place, so just  
....................                // transmit a FIN automatically and jump to  
....................                // TCP_LAST_ACK 
....................                MyTCBStub.smState = TCP_LAST_ACK; 
06FCA:  MOVLW  0C
06FCC:  MOVLB  1
06FCE:  MOVWF  xDD
....................                SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS); 
06FD0:  MOVLW  11
06FD2:  MOVLB  2
06FD4:  MOVWF  x97
06FD6:  MOVLW  01
06FD8:  MOVWF  x98
06FDA:  MOVLB  0
06FDC:  CALL   231A
....................                return; 
06FE0:  BRA    7074
....................  
....................             case TCP_ESTABLISHED: 
....................                // Go to TCP_CLOSE_WAIT state 
....................                MyTCBStub.smState = TCP_CLOSE_WAIT; 
06FE2:  MOVLW  0B
06FE4:  MOVLB  1
06FE6:  MOVWF  xDD
....................                 
....................                // For legacy applications that don't call  
....................                // TCPDisconnect() as needed and expect the TCP/IP  
....................                // Stack to automatically close sockets when the  
....................                // remote node sends a FIN, let's start a timer so  
....................                // that we will eventually close the socket automatically 
....................                MyTCBStub.OverlappedTimers.closeWaitTime = (WORD)TickGetDiv256() + (WORD)((TCP_CLOSE_WAIT_TIMEOUT)>>8); 
06FE8:  MOVLB  0
06FEA:  CALL   16EE
06FEE:  MOVLW  1E
06FF0:  MOVLB  2
06FF2:  ADDWF  00,W
06FF4:  MOVLB  1
06FF6:  MOVWF  xDB
06FF8:  MOVLW  00
06FFA:  MOVLB  2
06FFC:  ADDWFC 01,W
06FFE:  MOVLB  1
07000:  MOVWF  xDC
....................                break; 
07002:  BRA    7064
....................     
....................             case TCP_FIN_WAIT_1: 
....................                if(MyTCB.MySEQ == localAckNumber) 
07004:  MOVLB  2
07006:  MOVF   x8A,W
07008:  MOVLB  1
0700A:  SUBWF  x67,W
0700C:  BNZ   7044
0700E:  MOVLB  2
07010:  MOVF   x8B,W
07012:  MOVLB  1
07014:  SUBWF  x68,W
07016:  BNZ   7044
07018:  MOVLB  2
0701A:  MOVF   x8C,W
0701C:  MOVLB  1
0701E:  SUBWF  x69,W
07020:  BNZ   7044
07022:  MOVLB  2
07024:  MOVF   x8D,W
07026:  MOVLB  1
07028:  SUBWF  x6A,W
0702A:  BNZ   7044
....................                { 
....................                   // RFC not recommended: We should be going to  
....................                   // the TCP_TIME_WAIT state right here and  
....................                   // starting a 2MSL timer, but since we have so  
....................                   // few precious sockets, we can't afford to  
....................                   // leave a socket waiting around doing nothing  
....................                   // for a long time.  If the remote node does  
....................                   // not recieve this ACK, it'll have to figure  
....................                   // out on it's own that the connection is now  
....................                   // closed. 
....................                   SendTCP(ACK, 0); 
0702C:  MOVLW  10
0702E:  MOVLB  2
07030:  MOVWF  x97
07032:  CLRF   x98
07034:  MOVLB  0
07036:  CALL   231A
....................                   CloseSocket(); 
0703A:  CALL   13A6
....................                   return; 
0703E:  BRA    7074
....................                } 
07040:  BRA    704A
07042:  MOVLB  1
....................                else 
....................                { 
....................                   MyTCBStub.smState = TCP_CLOSING; 
07044:  MOVLW  0A
07046:  MOVWF  xDD
07048:  MOVLB  0
....................                } 
....................                break; 
0704A:  MOVLB  1
0704C:  BRA    7064
....................     
....................             case TCP_FIN_WAIT_2: 
....................                // RFC not recommended: We should be going to  
....................                // the TCP_TIME_WAIT state right here and  
....................                // starting a 2MSL timer, but since we have so  
....................                // few precious sockets, we can't afford to  
....................                // leave a socket waiting around doing nothing  
....................                // for a long time.  If the remote node does  
....................                // not recieve this ACK, it'll have to figure  
....................                // out on it's own that the connection is now  
....................                // closed. 
....................                SendTCP(ACK, 0); 
0704E:  MOVLW  10
07050:  MOVLB  2
07052:  MOVWF  x97
07054:  CLRF   x98
07056:  MOVLB  0
07058:  CALL   231A
....................                CloseSocket(); 
0705C:  CALL   13A6
....................                return; 
07060:  BRA    7074
....................  
....................             default: 
....................                break; 
07062:  MOVLB  1
....................          } 
....................  
....................          // Acknowledge receipt of FIN 
....................          SendTCP(ACK, SENDTCP_RESET_TIMERS); 
07064:  MOVLW  10
07066:  MOVLB  2
07068:  MOVWF  x97
0706A:  MOVLW  01
0706C:  MOVWF  x98
0706E:  MOVLB  0
07070:  CALL   231A
07074:  MOVLB  2
....................       } 
....................    } 
07076:  MOVLB  0
07078:  GOTO   71E4 (RETURN)
.................... } 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Buffer Management Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPAdjustFIFOSize(TCP_SOCKET hTCP, WORD wMinRXSize,  
....................                      WORD wMinTXSize, BYTE vFlags) 
....................  
....................   Summary: 
....................    Adjusts the relative sizes of the RX and TX buffers. 
....................  
....................   Description: 
....................    This function can be used to adjust the relative sizes of the RX and 
....................    TX FIFO depending on the immediate needs of an application.  Since a  
....................    larger FIFO can allow more data to be sent in a given packet, adjusting  
....................    the relative sizes on the fly can allow for optimal transmission speed  
....................    for one-sided application protocols.  For example, HTTP typically  
....................    begins by receiving large amounts of data from the client, then switches 
....................    to serving large amounts of data back.  Adjusting the FIFO at these  
....................    points can increase performance substantially.  Once the FIFO is 
....................    adjusted, a window update is sent. 
....................     
....................    If neither or both of TCP_ADJUST_GIVE_REST_TO_TX and  
....................    TCP_ADJUST_GIVE_REST_TO_RX are set, the function distributes the 
....................    remaining space equally. 
....................     
....................    Received data can be preserved as long as the buffer is expanding and  
....................    has not wrapped. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP      - The socket to be adjusted 
....................    wMinRXSize   - Minimum number of byte for the RX FIFO 
....................    wMinTXSize    - Minimum number of bytes for the RX FIFO 
....................    vFlags      - Any combination of TCP_ADJUST_GIVE_REST_TO_RX,  
....................               TCP_ADJUST_GIVE_REST_TO_TX, TCP_ADJUST_PRESERVE_RX. 
....................               TCP_ADJUST_PRESERVE_TX is not currently supported. 
....................  
....................   Return Values: 
....................    TRUE - The FIFOs were adjusted successfully 
....................    FALSE - Minimum RX, Minimum TX, or flags couldn't be accommodated and 
....................          therefore the socket was left unchanged. 
....................  
....................   Side Effects: 
....................    Any unacknowledged or untransmitted data in the TX FIFO is always 
....................    deleted. 
....................  
....................   Remarks: 
....................    At least one byte must always be allocated to the RX buffer so that 
....................    a FIN can be received.  The function automatically corrects for this. 
....................   ***************************************************************************/ 
.................... BOOL TCPAdjustFIFOSize(TCP_SOCKET hTCP, WORD wMinRXSize, WORD wMinTXSize, BYTE vFlags) 
.................... { 
....................    PTR_BASE ptrTemp, ptrHead; 
....................    WORD wTXAllocation; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    // Load up info on this socket 
....................    SyncTCBStub(hTCP); 
....................  
....................    // RX has to be at least 1 byte to receive SYN and FIN bytes  
....................    // from the remote node, even if they aren't stored in the RX FIFO 
....................    if(wMinRXSize == 0u) 
....................       wMinRXSize = 1; 
....................        
....................    // SSL connections need to be able to send or receive at least  
....................    // a full Alert record, MAC, and FIN 
....................    #if defined(STACK_USE_SSL) 
....................    if(TCPIsSSL(hTCP) && wMinRXSize < 25u) 
....................       wMinRXSize = 25; 
....................    if(TCPIsSSL(hTCP) && wMinTXSize < 25u) 
....................       wMinTXSize = 25; 
....................    #endif 
....................     
....................    // Make sure space is available for minimums 
....................    ptrTemp = MyTCBStub.bufferEnd - MyTCBStub.bufferTxStart - 1; 
....................    if(wMinRXSize + wMinTXSize > ptrTemp) 
....................       return FALSE; 
....................  
....................    SyncTCB(); 
....................  
....................    // Set both allocation flags if none set 
....................    if(!(vFlags & (TCP_ADJUST_GIVE_REST_TO_TX | TCP_ADJUST_GIVE_REST_TO_RX))) 
....................       vFlags |= TCP_ADJUST_GIVE_REST_TO_TX | TCP_ADJUST_GIVE_REST_TO_RX; 
....................        
....................  
....................    // Allocate minimums 
....................    wTXAllocation = wMinTXSize; 
....................    ptrTemp -= wMinRXSize + wMinTXSize; 
....................  
....................    // Allocate extra 
....................    if(vFlags & TCP_ADJUST_GIVE_REST_TO_TX) 
....................    { 
....................       if(vFlags & TCP_ADJUST_GIVE_REST_TO_RX) 
....................       { 
....................          // Do a 50%/50% split with any odd byte always going to the RX FIFO 
....................          wTXAllocation += ptrTemp>>1; 
....................       } 
....................       else 
....................       { 
....................          wTXAllocation += ptrTemp; 
....................       } 
....................    } 
....................  
....................    // Calculate new bufferRxStart pointer 
....................    ptrTemp = MyTCBStub.bufferTxStart + wTXAllocation + 1; 
....................  
....................    // Find the head pointer to use 
....................    ptrHead = MyTCBStub.rxHead; 
....................    #if defined(STACK_USE_SSL) 
....................    if(TCPIsSSL(hTCP)) 
....................       ptrHead = MyTCBStub.sslRxHead; 
....................    #endif 
....................     
....................    // If there's out-of-order data pending, adjust the head pointer to compensate 
....................    if(MyTCB.sHoleSize != -1) 
....................    { 
....................       ptrHead += MyTCB.sHoleSize + MyTCB.wFutureDataSize; 
....................       if(ptrHead > MyTCBStub.bufferEnd) 
....................          ptrHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................    } 
....................  
....................    // Determine if resizing will lose any RX data 
....................    if(MyTCBStub.rxTail < ptrHead) 
....................    { 
....................       if(ptrTemp > MyTCBStub.rxTail) 
....................       { 
....................          if(vFlags & TCP_ADJUST_PRESERVE_RX) 
....................             return FALSE; 
....................          else 
....................          { 
....................             MyTCBStub.rxTail = ptrTemp; 
....................             MyTCBStub.rxHead = ptrTemp; 
....................  
....................             #if defined(STACK_USE_SSL) 
....................             MyTCBStub.sslRxHead = ptrTemp; 
....................             #endif 
....................          } 
....................       } 
....................    } 
....................    else if(MyTCBStub.rxTail > ptrHead) 
....................    { 
....................       if(ptrTemp > MyTCBStub.bufferRxStart) 
....................       { 
....................          if(vFlags & TCP_ADJUST_PRESERVE_RX) 
....................             return FALSE; 
....................          else 
....................          { 
....................             MyTCBStub.rxTail = ptrTemp; 
....................             MyTCBStub.rxHead = ptrTemp; 
....................              
....................             #if defined(STACK_USE_SSL) 
....................             MyTCBStub.sslRxHead = ptrTemp; 
....................             #endif 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       // No data to preserve, but we may need to move  
....................       // the pointers to stay in the RX space 
....................       MyTCBStub.rxTail = ptrTemp; 
....................       MyTCBStub.rxHead = ptrTemp; 
....................        
....................       #if defined(STACK_USE_SSL) 
....................       MyTCBStub.sslRxHead = ptrTemp; 
....................       #endif 
....................    } 
....................     
....................    // If we need to preserve data that wrapped in the ring, we must copy 
....................    if(ptrHead < MyTCBStub.rxTail && (vFlags & TCP_ADJUST_PRESERVE_RX)) 
....................    { 
....................       TCPRAMCopy(ptrTemp, MyTCBStub.vMemoryMedium,  
....................          MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, 
....................          ptrHead - MyTCBStub.bufferRxStart); 
....................  
....................       // Move the pointers if they were in front of the tail 
....................       #if defined(STACK_USE_SSL) 
....................       if(TCPIsSSL(hTCP) && MyTCBStub.sslRxHead < MyTCBStub.rxTail) 
....................          MyTCBStub.sslRxHead -= MyTCBStub.bufferRxStart - ptrTemp; 
....................       #endif 
....................       if(MyTCBStub.rxHead < MyTCBStub.rxTail) 
....................          MyTCBStub.rxHead -= MyTCBStub.bufferRxStart - ptrTemp; 
....................    } 
....................     
....................    // Move the RX buffer pointer - it's the one that divides the two 
....................    MyTCBStub.bufferRxStart = ptrTemp; 
....................  
....................    // Empty the TX buffer 
....................    MyTCB.txUnackedTail = MyTCBStub.bufferTxStart; 
....................    MyTCBStub.txTail = MyTCBStub.bufferTxStart; 
....................    MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................     
....................    #if defined(STACK_USE_SSL) 
....................    if(TCPIsSSL(hTCP)) 
....................       MyTCBStub.sslTxHead = MyTCBStub.txHead + 5; 
....................    #endif 
....................     
....................    // Send a window update to notify remote node of change 
....................    if(MyTCBStub.smState == TCP_ESTABLISHED) 
....................       SendTCP(ACK, SENDTCP_RESET_TIMERS); 
....................  
....................    return TRUE; 
....................  
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void TCPRAMCopy(PTR_BASE ptrDest, BYTE vDestType, PTR_BASE ptrSource,  
....................                      BYTE vSourceType, WORD wLength) 
....................  
....................   Summary: 
....................    Copies data to/from various memory mediums. 
....................  
....................   Description: 
....................    This function copies data between memory mediums (PIC RAM, SPI 
....................    RAM, and Ethernet buffer RAM). 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    ptrDest      - Address to write to 
....................    vDestType   - Destination meidum (TCP_PIC_RAM, TCP_ETH_RAM, TCP_SPI_RAM) 
....................    ptrSource   - Address to copy from 
....................    vSourceType - Source medium (TCP_PIC_RAM, TCP_ETH_RAM, or TCP_SPI_RAM) 
....................    wLength      - Number of bytes to copy 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    Copying to a destination region that overlaps with the source address  
....................    is supported only if the destination start address is at a lower memory  
....................    address (closer to 0x0000) than the source pointer.  However, if they do  
....................    overlap there must be at least 4 bytes of non-overlap to ensure correct  
....................    results due to hardware DMA requirements. 
....................   ***************************************************************************/ 
.................... static void TCPRAMCopy(PTR_BASE ptrDest, BYTE vDestType, PTR_BASE ptrSource, BYTE vSourceType, WORD wLength) 
.................... { 
....................    #if defined(SPIRAM_CS_TRIS) 
....................    BYTE vBuffer[16]; 
....................    WORD w; 
....................    #endif 
....................        
....................    switch(vSourceType) 
*
011E8:  MOVLB  2
011EA:  MOVF   xCD,W
011EC:  XORLW  01
011EE:  MOVLB  0
011F0:  BZ    11F8
011F2:  XORLW  01
011F4:  BZ    126A
011F6:  BRA    12CC
....................    { 
....................       case TCP_PIC_RAM: 
....................          switch(vDestType) 
011F8:  MOVLB  2
011FA:  MOVF   xCA,W
011FC:  XORLW  01
011FE:  MOVLB  0
01200:  BZ    1208
01202:  XORLW  01
01204:  BZ    123A
01206:  BRA    1268
....................          { 
....................             case TCP_PIC_RAM: 
....................                memcpy((void*)(BYTE*)ptrDest, (void*)(BYTE*)ptrSource, wLength); 
01208:  MOVFF  2C9,FEA
0120C:  MOVFF  2C8,FE9
01210:  MOVFF  2CC,FE2
01214:  MOVFF  2CB,FE1
01218:  MOVFF  2CF,02
0121C:  MOVFF  2CE,01
01220:  MOVF   01,F
01222:  BZ    1228
01224:  INCF   02,F
01226:  BRA    122C
01228:  MOVF   02,F
0122A:  BZ    1238
0122C:  MOVFF  FE6,FEE
01230:  DECFSZ 01,F
01232:  BRA    122C
01234:  DECFSZ 02,F
01236:  BRA    122C
....................                break; 
01238:  BRA    1268
....................     
....................             case TCP_ETH_RAM: 
....................                if(ptrDest!=(PTR_BASE)-1) 
0123A:  MOVLB  2
0123C:  INCFSZ xC8,W
0123E:  BRA    1246
01240:  INCFSZ xC9,W
01242:  BRA    1246
01244:  BRA    1254
....................                   MACSetWritePtr(ptrDest); 
01246:  MOVFF  2C9,2D1
0124A:  MOVFF  2C8,2D0
0124E:  MOVLB  0
01250:  RCALL  0D6C
01252:  MOVLB  2
....................                MACPutArray((BYTE*)ptrSource, wLength); 
01254:  MOVFF  2CC,2E6
01258:  MOVFF  2CB,2E5
0125C:  MOVFF  2CF,2E8
01260:  MOVFF  2CE,2E7
01264:  MOVLB  0
01266:  RCALL  0DDC
....................                break; 
....................     
....................             #if defined(SPIRAM_CS_TRIS) 
....................             case TCP_SPI_RAM: 
....................                SPIRAMPutArray(ptrDest, (BYTE*)ptrSource, wLength); 
....................                break; 
....................             #endif 
....................          } 
....................          break; 
01268:  BRA    12CC
....................     
....................       case TCP_ETH_RAM: 
....................          switch(vDestType) 
0126A:  MOVLB  2
0126C:  MOVF   xCA,W
0126E:  XORLW  01
01270:  MOVLB  0
01272:  BZ    127A
01274:  XORLW  01
01276:  BZ    12AA
01278:  BRA    12CA
....................          { 
....................             case TCP_PIC_RAM: 
....................                if(ptrSource!=(PTR_BASE)-1) 
0127A:  MOVLB  2
0127C:  INCFSZ xCB,W
0127E:  BRA    1286
01280:  INCFSZ xCC,W
01282:  BRA    1286
01284:  BRA    1294
....................                   MACSetReadPtr(ptrSource); 
01286:  MOVFF  2CC,2D1
0128A:  MOVFF  2CB,2D0
0128E:  MOVLB  0
01290:  RCALL  0E22
01292:  MOVLB  2
....................                MACGetArray((BYTE*)ptrDest, wLength); 
01294:  MOVFF  2C9,2E4
01298:  MOVFF  2C8,2E3
0129C:  MOVFF  2CF,2E6
012A0:  MOVFF  2CE,2E5
012A4:  MOVLB  0
012A6:  RCALL  0E8E
....................                break; 
012A8:  BRA    12CA
....................     
....................             case TCP_ETH_RAM: 
....................                MACMemCopyAsync(ptrDest, ptrSource, wLength); 
012AA:  MOVFF  2C9,2D1
012AE:  MOVFF  2C8,2D0
012B2:  MOVFF  2CC,2D3
012B6:  MOVFF  2CB,2D2
012BA:  MOVFF  2CF,2D5
012BE:  MOVFF  2CE,2D4
012C2:  RCALL  0F2E
....................                while(!MACIsMemCopyDone()); 
012C4:  RCALL  11C0
012C6:  MOVF   01,F
012C8:  BZ    12C4
....................                break; 
....................     
....................             #if defined(SPIRAM_CS_TRIS) 
....................             case TCP_SPI_RAM: 
....................                if(ptrSource!=(PTR_BASE)-1) 
....................                   MACSetReadPtr(ptrSource); 
....................                w = sizeof(vBuffer); 
....................                while(wLength) 
....................                { 
....................                   if(w > wLength) 
....................                      w = wLength; 
....................                    
....................                   // Read and write a chunk    
....................                   MACGetArray(vBuffer, w); 
....................                   SPIRAMPutArray(ptrDest, vBuffer, w); 
....................                   ptrDest += w; 
....................                   wLength -= w; 
....................                } 
....................                break; 
....................             #endif 
....................          } 
....................          break; 
012CA:  BRA    12CC
....................     
....................       #if defined(SPIRAM_CS_TRIS) 
....................       case TCP_SPI_RAM: 
....................          switch(vDestType) 
....................          { 
....................             case TCP_PIC_RAM: 
....................                SPIRAMGetArray(ptrSource, (BYTE*)ptrDest, wLength); 
....................                break; 
....................     
....................             case TCP_ETH_RAM: 
....................                if(ptrDest!=(PTR_BASE)-1) 
....................                   MACSetWritePtr(ptrDest); 
....................                w = sizeof(vBuffer); 
....................                while(wLength) 
....................                { 
....................                   if(w > wLength) 
....................                      w = wLength; 
....................                    
....................                   // Read and write a chunk    
....................                   SPIRAMGetArray(ptrSource, vBuffer, w); 
....................                   ptrSource += w; 
....................                   MACPutArray(vBuffer, w); 
....................                   wLength -= w; 
....................                } 
....................                break; 
....................     
....................             case TCP_SPI_RAM: 
....................                // Copy all of the data over in chunks 
....................                w = sizeof(vBuffer); 
....................                while(wLength) 
....................                { 
....................                   if(w > wLength) 
....................                      w = wLength; 
....................                       
....................                   SPIRAMGetArray(ptrSource, vBuffer, w); 
....................                   SPIRAMPutArray(ptrDest, vBuffer, w); 
....................                   ptrSource += w; 
....................                   ptrDest += w; 
....................                   wLength -= w; 
....................                } 
....................                break; 
....................          } 
....................          break; 
....................       #endif          
....................    } 
012CC:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void TCPRAMCopyROM(PTR_BASE wDest, BYTE wDestType, ROM BYTE* wSource,  
....................                         WORD wLength) 
....................  
....................   Summary: 
....................    Copies data to/from various memory mediums. 
....................  
....................   Description: 
....................    This function copies data between memory mediums (PIC RAM, SPI 
....................    RAM, and Ethernet buffer RAM).  This function is to be used when  
....................    copying from ROM. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    wDest      - Address to write to 
....................    wDestType   - Destination meidum (TCP_PIC_RAM, TCP_ETH_RAM, TCP_SPI_RAM) 
....................    wSource      - Address to copy from 
....................    wLength      - Number of bytes to copy 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    Copying to a destination region that overlaps with the source address  
....................    is supported only if the destination start address is at a lower memory  
....................    address (closer to 0x0000) than the source pointer. 
....................     
....................    This function is aliased to TCPRAMCopy on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... static void TCPRAMCopyROM(PTR_BASE wDest, BYTE wDestType, ROM BYTE* wSource, WORD wLength) 
.................... { 
....................    BYTE vBuffer[16]; 
....................    WORD w; 
....................     
....................    switch(wDestType) 
....................    { 
....................       case TCP_PIC_RAM: 
....................          memcpypgm2ram((void*)(BYTE*)wDest, (ROM void*)wSource, wLength); 
....................          break; 
....................     
....................       case TCP_ETH_RAM: 
....................          if(wDest!=(PTR_BASE)-1) 
....................             MACSetWritePtr(wDest); 
....................          w = sizeof(vBuffer); 
....................          while(wLength) 
....................          { 
....................             if(w > wLength) 
....................                w = wLength; 
....................              
....................             // Read and write a chunk    
....................             memcpypgm2ram(vBuffer, (ROM void*)wSource, w); 
....................             MACPutArray(vBuffer, w); 
....................             wSource += w; 
....................             wLength -= w; 
....................          } 
....................          break; 
....................     
....................       #if defined(SPIRAM_CS_TRIS) 
....................       case TCP_SPI_RAM: 
....................          w = sizeof(vBuffer); 
....................          while(wLength) 
....................          { 
....................             if(w > wLength) 
....................                w = wLength; 
....................              
....................             // Read and write a chunk    
....................             memcpypgm2ram(vBuffer, (ROM void*)wSource, w); 
....................             SPIRAMPutArray(wDest, vBuffer, w); 
....................             wDest += w; 
....................             wSource += w; 
....................             wLength -= w; 
....................          } 
....................          break; 
....................       #endif 
....................    } 
.................... } 
.................... #endif 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    SSL Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPStartSSLClient(TCP_SOCKET hTCP, BYTE* host) 
....................  
....................   Summary: 
....................    Begins an SSL client session. 
....................  
....................   Description: 
....................    This function escalates the current connection to an SSL secured  
....................    connection by initiating an SSL client handshake. 
....................  
....................   Precondition: 
....................    TCP is initialized and hTCP is already connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to secure 
....................    host      - Expected host name on certificate (currently ignored) 
....................  
....................   Return Values: 
....................    TRUE       - an SSL connection was initiated 
....................    FALSE       - Insufficient SSL resources (stubs) were available 
....................  
....................   Remarks: 
....................    The host parameter is currently ignored and is not validated. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL_CLIENT) 
.................... BOOL TCPStartSSLClient(TCP_SOCKET hTCP, BYTE* host) 
.................... { 
....................    BYTE i; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    // Make sure SSL is not established already 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       return FALSE; 
....................     
....................    // Try to start the session 
....................    MyTCBStub.sslStubID = SSLStartSession(hTCP, NULL, 0); 
....................     
....................    // Make sure a session stub was obtained 
....................    if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................       return FALSE; 
....................  
....................    // Mark connection as handshaking and return 
....................    MyTCBStub.sslReqMessage = SSL_CLIENT_HELLO; 
....................    MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................    MyTCBStub.sslTxHead = MyTCBStub.txHead; 
....................    MyTCBStub.Flags.bSSLHandshaking = 1; 
....................    for(i = 0; i < 5u; i++) 
....................    {// Skip first 5 bytes in TX for the record header 
....................       if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    return TRUE; 
.................... } 
.................... #endif // SSL Client 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPStartSSLClientEx(TCP_SOCKET hTCP, BYTE* host, BYTE * buffer, BYTE suppDataType) 
....................  
....................   Summary: 
....................    Begins an SSL client session. 
....................  
....................   Description: 
....................    This function escalates the current connection to an SSL secured  
....................    connection by initiating an SSL client handshake. 
....................  
....................   Precondition: 
....................    TCP is initialized and hTCP is already connected. 
....................  
....................   Parameters: 
....................    hTCP         - TCP connection to secure 
....................    host         - Expected host name on certificate (currently ignored) 
....................    buffer         - Buffer for supplementary data return 
....................    suppDataType    - Type of supplementary data to copy 
....................  
....................   Return Values: 
....................    TRUE       - an SSL connection was initiated 
....................    FALSE       - Insufficient SSL resources (stubs) were available 
....................  
....................   Remarks: 
....................    The host parameter is currently ignored and is not validated. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL_CLIENT) 
.................... BOOL TCPStartSSLClientEx(TCP_SOCKET hTCP, BYTE* host, void * buffer, BYTE suppDataType) 
.................... { 
....................    BYTE i; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    // Make sure SSL is not established already 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       return FALSE; 
....................     
....................    // Try to start the session 
....................    MyTCBStub.sslStubID = SSLStartSession(hTCP, buffer, suppDataType); 
....................     
....................    // Make sure a session stub was obtained 
....................    if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................       return FALSE; 
....................  
....................    // Mark connection as handshaking and return 
....................    MyTCBStub.sslReqMessage = SSL_CLIENT_HELLO; 
....................    MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................    MyTCBStub.sslTxHead = MyTCBStub.txHead; 
....................    MyTCBStub.Flags.bSSLHandshaking = 1; 
....................    for(i = 0; i < 5u; i++) 
....................    {// Skip first 5 bytes in TX for the record header 
....................       if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    return TRUE; 
.................... } 
.................... #endif // SSL Client 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPStartSSLServer(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Begins an SSL server session. 
....................  
....................   Description: 
....................    This function sets up an SSL server session when a new connection is 
....................    established on an SSL port. 
....................  
....................   Precondition: 
....................    TCP is initialized and hTCP is already connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to secure 
....................  
....................   Return Values: 
....................    TRUE      - an SSL connection was initiated 
....................    FALSE      - Insufficient SSL resources (stubs) were available 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL_SERVER) 
.................... BOOL TCPStartSSLServer(TCP_SOCKET hTCP) 
.................... { 
....................    BYTE i; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    SyncTCB(); 
....................     
....................    // Make sure SSL is not established already 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       return TRUE; 
....................     
....................    // Try to start the session 
....................    MyTCBStub.sslStubID = SSLStartSession(hTCP, NULL, 0); 
....................     
....................    // Make sure a session stub was obtained 
....................    if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................       return FALSE; 
....................  
....................    // Swap the localPort and localSSLPort 
....................    MyTCBStub.remoteHash.Val = MyTCB.localPort.Val; 
....................    MyTCB.localPort.Val = MyTCB.localSSLPort.Val; 
....................    MyTCB.localSSLPort.Val = MyTCBStub.remoteHash.Val;    
....................  
....................    // Mark connection as handshaking and return 
....................    MyTCBStub.sslReqMessage = SSL_NO_MESSAGE; 
....................    MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................    MyTCBStub.sslTxHead = MyTCBStub.txHead; 
....................    MyTCBStub.Flags.bSSLHandshaking = 1; 
....................    for(i = 0; i < 5u; i++) 
....................    {// Skip first 5 bytes in TX for the record header 
....................       if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    return TRUE; 
.................... } 
.................... #endif // SSL Client 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPAddSSLListener(TCP_SOCKET hTCP, WORD port) 
....................  
....................   Summary: 
....................    Listens for SSL connection on a specific port. 
....................  
....................   Description: 
....................    This function adds an additional listening port to a TCP connection.   
....................    Connections made on this alternate port will be secured via SSL. 
....................  
....................   Precondition: 
....................    TCP is initialized and hTCP is listening. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to secure 
....................    port      - SSL port to listen on 
....................  
....................   Return Values: 
....................    TRUE      - SSL port was added. 
....................    FALSE      - The socket was not a listening socket. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL_SERVER) 
.................... BOOL TCPAddSSLListener(TCP_SOCKET hTCP, WORD port) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    if(MyTCBStub.smState != TCP_LISTEN) 
....................       return FALSE; 
....................     
....................    SyncTCB(); 
....................     
....................    MyTCB.localSSLPort.Val = port; 
....................    MyTCBStub.sslTxHead = port; 
....................  
....................    return TRUE; 
.................... } 
.................... #endif // SSL Server 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPRequestSSLMessage(TCP_SOCKET hTCP, BYTE msg) 
....................  
....................   Summary: 
....................    Requests an SSL message to be transmitted. 
....................  
....................   Description: 
....................    This function is called to request that a specific SSL message be 
....................    transmitted.  This message should only be called by the SSL module. 
....................     
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to use 
....................    msg         - One of the SSL_MESSAGE types to transmit. 
....................  
....................   Return Values: 
....................    TRUE      - The message was requested. 
....................    FALSE      - Another message is already pending transmission. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... BOOL TCPRequestSSLMessage(TCP_SOCKET hTCP, BYTE msg) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    if(msg == SSL_NO_MESSAGE || MyTCBStub.sslReqMessage == SSL_NO_MESSAGE) 
....................    { 
....................       MyTCBStub.sslReqMessage = msg; 
....................       return TRUE; 
....................    } 
....................     
....................    return FALSE; 
.................... } 
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPSSLIsHandshaking(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines if an SSL session is still handshaking. 
....................  
....................   Description: 
....................    Call this function after calling TCPStartSSLClient until FALSE is 
....................    returned.  Then your application may continue with its normal data 
....................    transfer (which is now secured). 
....................     
....................   Precondition: 
....................    TCP is initialized and hTCP is connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to check 
....................  
....................   Return Values: 
....................    TRUE      - SSL handshake is still progressing 
....................    FALSE      - SSL handshake has completed 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... BOOL TCPSSLIsHandshaking(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    return MyTCBStub.Flags.bSSLHandshaking;    
.................... } 
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPIsSSL(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines if a TCP connection is secured with SSL. 
....................  
....................   Description: 
....................    Call this function to determine whether or not a TCP connection is  
....................    secured with SSL. 
....................     
....................   Precondition: 
....................    TCP is initialized and hTCP is connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to check 
....................  
....................   Return Values: 
....................    TRUE      - Connection is secured via SSL 
....................    FALSE      - Connection is not secured 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... BOOL TCPIsSSL(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................       return FALSE; 
....................     
....................    return TRUE; 
.................... } 
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLHandshakeComplete(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Clears the SSL handshake flag. 
....................  
....................   Description: 
....................    This function clears the flag indicating that an SSL handshake is 
....................    complete. 
....................     
....................   Precondition: 
....................    TCP is initialized and hTCP is connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to set 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLHandshakeComplete(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    MyTCBStub.Flags.bSSLHandshaking = 0; 
.................... } 
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLDecryptMAC(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, WORD len) 
....................  
....................   Summary: 
....................    Decrypts and MACs data arriving via SSL. 
....................  
....................   Description: 
....................    This function decrypts data in the TCP buffer and calculates the MAC over 
....................    the data.  All data is left in the exact same location in the TCP buffer. 
....................    It is called to help process incoming SSL records. 
....................     
....................   Precondition: 
....................    TCP is initialized, hTCP is connected, and ctx's Sbox is loaded. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to decrypt in 
....................    ctx         - ARCFOUR encryption context to use 
....................    len       - Number of bytes to crypt 
....................    inPlace      - TRUE to write back in place, FALSE to write at end of 
....................                currently visible data. 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLDecryptMAC(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, WORD len) 
.................... { 
....................    PTR_BASE wSrc, wDest, wBlockLen, wTemp; 
....................    BYTE buffer[32]; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    // Set up the pointers 
....................    SyncTCBStub(hTCP); 
....................    wSrc = MyTCBStub.rxTail; 
....................    wDest = wSrc; 
....................     
....................    // Handle 32 bytes at a time 
....................    while(len) 
....................    { 
....................       // Determine how many bytes we can read 
....................       wBlockLen = sizeof(buffer); 
....................       if(wBlockLen > len) // Don't do more than we should 
....................          wBlockLen = len; 
....................        
....................       // Read those bytes to a buffer 
....................       if(wSrc + wBlockLen > MyTCBStub.bufferEnd) 
....................       {// Two part read 
....................          wTemp = MyTCBStub.bufferEnd - wSrc + 1; 
....................          TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, wSrc, MyTCBStub.vMemoryMedium, wTemp); 
....................          TCPRAMCopy((PTR_BASE)buffer+wTemp, TCP_PIC_RAM, MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, wBlockLen - wTemp); 
....................          wSrc = MyTCBStub.bufferRxStart + wBlockLen - wTemp; 
....................       } 
....................       else 
....................       { 
....................          TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, wSrc, MyTCBStub.vMemoryMedium, wBlockLen); 
....................          wSrc += wBlockLen; 
....................       } 
....................        
....................       // Decrypt and hash 
....................       ARCFOURCrypt(ctx, buffer, wBlockLen); 
....................       SSLMACAdd(buffer, wBlockLen); 
....................        
....................       // Write decrypted bytes back 
....................       if(wDest + wBlockLen > MyTCBStub.bufferEnd) 
....................       {// Two part write 
....................          wTemp = MyTCBStub.bufferEnd - wDest + 1; 
....................          TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, wTemp); 
....................          TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer+wTemp, TCP_PIC_RAM, wBlockLen - wTemp); 
....................          wDest = MyTCBStub.bufferRxStart + wBlockLen - wTemp; 
....................       } 
....................       else 
....................       { 
....................          TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, wBlockLen); 
....................          wDest += wBlockLen; 
....................       } 
....................        
....................       // Update the length remaining 
....................       len -= wBlockLen; 
....................    } 
.................... }    
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLInPlaceMACEncrypt(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx,  
....................                            BYTE* MACSecret, WORD len) 
....................  
....................   Summary: 
....................    Encrypts and MACs data in place in the TCP TX buffer. 
....................  
....................   Description: 
....................    This function encrypts data in the TCP buffer while calcuating a MAC.   
....................    When encryption is finished, the MAC is appended to the buffer and  
....................    the record will be ready to transmit. 
....................     
....................   Precondition: 
....................    TCP is initialized, hTCP is connected, and ctx's Sbox is loaded. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to encrypt in 
....................    ctx         - ARCFOUR encryption context to use 
....................    MACSecret   - MAC encryption secret to use 
....................    len       - Number of bytes to crypt 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLInPlaceMACEncrypt(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, BYTE* MACSecret, WORD len) 
.................... { 
....................    PTR_BASE pos; 
....................    WORD blockLen; 
....................    BYTE buffer[32]; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    // Set up the pointers 
....................    SyncTCBStub(hTCP); 
....................    pos = MyTCBStub.txHead; 
....................    for(blockLen = 0; blockLen < 5u; blockLen++) 
....................    {// Skips first 5 bytes for the header 
....................       if(++pos >= MyTCBStub.bufferRxStart) 
....................          pos = MyTCBStub.bufferTxStart; 
....................    } 
....................     
....................    // Handle 32 bytes at a time 
....................    while(len) 
....................    { 
....................       // Determine how many bytes we can read 
....................       blockLen = sizeof(buffer); 
....................       if(blockLen > len) // Don't do more than we should 
....................          blockLen = len; 
....................       if(blockLen > MyTCBStub.bufferRxStart - pos) // Don't pass the end 
....................          blockLen = MyTCBStub.bufferRxStart - pos; 
....................        
....................       // Read those bytes to a buffer 
....................       TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, pos, MyTCBStub.vMemoryMedium, blockLen); 
....................        
....................       // Hash and encrypt 
....................       SSLMACAdd(buffer, blockLen); 
....................       ARCFOURCrypt(ctx, buffer, blockLen); 
....................        
....................       // Put them back 
....................       TCPRAMCopy(pos, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, blockLen); 
....................        
....................       // Update the pointers 
....................       pos += blockLen; 
....................       len -= blockLen; 
....................       if(pos >= MyTCBStub.bufferRxStart) 
....................          pos = MyTCBStub.bufferTxStart; 
....................    } 
....................     
....................    // Calculate and add the MAC 
....................    SSLMACCalc(MACSecret, buffer); 
....................    ARCFOURCrypt(ctx, buffer, 16); 
....................  
....................    // Write the MAC to the TX FIFO 
....................    // Can't use TCPPutArray here because TCPIsPutReady() saves 16 bytes for the MAC 
....................    // TCPPut* functions use this to prevent writing too much data.  Therefore, the 
....................    // functionality is duplicated here. 
....................     
....................    len = 16; 
....................    blockLen = 0; 
....................    // See if we need a two part put 
....................    if(MyTCBStub.sslTxHead + len >= MyTCBStub.bufferRxStart) 
....................    { 
....................       blockLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead; 
....................       TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, blockLen); 
....................       len -= blockLen; 
....................       MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................     
....................    TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&buffer[blockLen], TCP_PIC_RAM, len); 
....................    MyTCBStub.sslTxHead += len; 
....................  
.................... }    
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLPutRecordHeader(TCP_SOCKET hTCP, BYTE* hdr, BOOL recDone) 
....................  
....................   Summary: 
....................    Writes an SSL record header and sends an SSL record. 
....................  
....................   Description: 
....................    This function writes an SSL record header to the pending TCP SSL data,  
....................    then indicates that the data is ready to be sent by moving the txHead 
....................    pointer. 
....................     
....................    If the record is complete, set recDone to TRUE.  The sslTxHead  
....................    pointer will be moved forward 5 bytes to leave space for a future  
....................    record header.  If the record is only partially sent, use FALSE and 
....................    to leave the pointer where it is so that more data can be added 
....................    to the record.  Partial records can only be used for the  
....................    SERVER_CERTIFICATE handshake message. 
....................     
....................   Precondition: 
....................    TCP is initialized, and hTCP is connected with an active SSL session. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to write the header and transmit with 
....................    hdr         - Record header (5 bytes) to send or NULL to just  
....................               move the pointerctx 
....................    recDone      - TRUE if the record is done, FALSE otherwise 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLPutRecordHeader(TCP_SOCKET hTCP, BYTE* hdr, BOOL recDone) 
.................... { 
....................    BYTE i; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    // Set up the pointers 
....................    SyncTCBStub(hTCP); 
....................     
....................    // Write the header if needed 
....................    if(hdr) 
....................    {// This is a new record, so insert the header 
....................       for(i = 0; i < 5u; i++) 
....................       { 
....................          TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)hdr+i, TCP_PIC_RAM, sizeof(BYTE)); 
....................          if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart) 
....................             MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................       } 
....................    } 
....................     
....................    // Move the txHead pointer to indicate what data is ready 
....................    // Also, flush just the header, then all the data.  This shotguns two  
....................    // packets down the line, therefore causing immediate ACKs by the  
....................    // remote node.  Reconnect handshakes are as much as 60% faster now. 
....................    TCPFlush(hTCP); 
....................    MyTCBStub.txHead = MyTCBStub.sslTxHead; 
....................    TCPFlush(hTCP); 
....................     
....................    // If this record is done, move the sslTxHead forward 
....................    // to accomodate the next record header 
....................    if(recDone) 
....................    { 
....................       for(i = 0; i < 5u; i++) 
....................       {// Skip first 5 bytes in TX for the record header 
....................          if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................             MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................       } 
....................    } 
.................... }    
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPSSLGetPendingTxSize(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines how many bytes are pending for a future SSL record. 
....................  
....................   Description: 
....................    This function determines how many bytes are pending for a future SSL 
....................    record. 
....................     
....................   Precondition: 
....................    TCP is initialized, and hTCP is connected with an active SSL connection. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to check 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... WORD TCPSSLGetPendingTxSize(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    // Non-SSL connections have no pending SSL data 
....................    //if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................    //   return 0; 
....................           
....................    // Determine how many bytes are waiting to be written in this record 
....................    if(MyTCBStub.sslTxHead > MyTCBStub.txHead) 
....................       return MyTCBStub.sslTxHead - MyTCBStub.txHead - 5; 
....................    else 
....................       return (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.txHead - MyTCBStub.sslTxHead - 1) - 5; 
.................... } 
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLHandleIncoming(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Hands newly arrive TCP data to the SSL module for processing. 
....................  
....................   Description: 
....................    This function processes incoming TCP data as an SSL record and  
....................    performs any necessary repositioning and decrypting. 
....................     
....................   Precondition: 
....................    TCP is initialized, and hTCP is connected with an active SSL session. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to handle incoming data on 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLHandleIncoming(TCP_SOCKET hTCP) 
.................... { 
....................    PTR_BASE prevRxTail, nextRxHead, startRxTail, wSrc, wDest; 
....................    WORD wToMove, wLen, wSSLBytesThatPoofed, wDecryptedBytes; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    // Sync the stub 
....................    SyncTCBStub(hTCP); 
....................  
....................    // If new data is waiting 
....................    if(MyTCBStub.sslRxHead != MyTCBStub.rxHead) 
....................    { 
....................       // Reconfigure pointers for SSL use 
....................       prevRxTail = MyTCBStub.rxTail; 
....................       nextRxHead = MyTCBStub.rxHead; 
....................       MyTCBStub.rxTail = MyTCBStub.rxHead; 
....................       MyTCBStub.rxHead = MyTCBStub.sslRxHead; 
....................        
....................       do 
....................       { 
....................          startRxTail = MyTCBStub.rxTail; 
....................  
....................          // Handle incoming data.  This function performs deframing of the  
....................          // SSL records, decryption, and MAC verification. 
....................          wSSLBytesThatPoofed = TCPIsGetReady(hTCP); 
....................          wDecryptedBytes = SSLRxRecord(hTCP, MyTCBStub.sslStubID); 
....................          wSSLBytesThatPoofed -= TCPIsGetReady(hTCP); 
....................  
....................          // Now need to move data to fill the SSL header/MAC/padding hole,  
....................          // if there is one 
....................          if(wSSLBytesThatPoofed) 
....................          {    
....................             // Sync the TCP so we can see if there is a TCP hole 
....................             SyncTCB(); 
....................  
....................             // Calculate how big the SSL hole is 
....................             if(MyTCB.sHoleSize == -1) 
....................             {// Just need to move pending SSL data 
....................                wToMove = TCPIsGetReady(hTCP); 
....................             } 
....................             else 
....................             {// A TCP hole exists, so move all data 
....................                wToMove = TCPIsGetReady(hTCP) + MyTCB.sHoleSize + MyTCB.wFutureDataSize; 
....................             } 
....................              
....................             // Start with the destination as the startRxTail and source as current rxTail 
....................             wDest = startRxTail; 
....................             wSrc = MyTCBStub.rxTail; 
....................              
....................             // If data exists between the end of the buffer and  
....................             // the destination, then move it forward 
....................             if(wSrc > wDest) 
....................             { 
....................                wLen = MyTCBStub.bufferEnd - wSrc + 1; 
....................                if(wLen > wToMove) 
....................                   wLen = wToMove; 
....................                TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium,  
....................                         wSrc, MyTCBStub.vMemoryMedium, wLen); 
....................                wDest += wLen; 
....................                wSrc = MyTCBStub.bufferRxStart; 
....................                wToMove -= wLen; 
....................             } 
....................              
....................             // If data remains to be moved, fill in to end of buffer 
....................             if(wToMove) 
....................             { 
....................                wLen = MyTCBStub.bufferEnd - wDest + 1; 
....................                if(wLen > wToMove) 
....................                   wLen = wToMove; 
....................                TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium,  
....................                         wSrc, MyTCBStub.vMemoryMedium, wLen); 
....................                wDest = MyTCBStub.bufferRxStart; 
....................                wSrc += wLen; 
....................                wToMove -= wLen; 
....................             } 
....................              
....................             // If data still remains, copy from from front + len to front 
....................             if(wToMove) 
....................             { 
....................                TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, 
....................                         wSrc, MyTCBStub.vMemoryMedium, wToMove); 
....................             } 
....................  
....................             // Since bytes poofed, we need to move the head pointers  
....................             // backwards by an equal amount. 
....................             MyTCBStub.rxHead -= wSSLBytesThatPoofed; 
....................             if(MyTCBStub.rxHead < MyTCBStub.bufferRxStart) 
....................                MyTCBStub.rxHead += MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................             MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................          } 
....................              
....................          // Move tail pointer forward by the number of decrypted bytes ready  
....................          // for the application (but not poofed bytes) 
....................          MyTCBStub.rxTail = startRxTail + wDecryptedBytes; 
....................          if(MyTCBStub.rxTail > MyTCBStub.bufferEnd) 
....................             MyTCBStub.rxTail -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................          nextRxHead += wDecryptedBytes; 
....................           
....................          // Loop until SSLRxRecord() runs out of data and stops doing  
....................          // anything 
....................       } while(wSSLBytesThatPoofed || (startRxTail != MyTCBStub.rxTail)); 
....................  
....................       // Restore TCP buffer pointers to point to the decrypted application data  
....................       // only 
....................       if(nextRxHead > MyTCBStub.bufferEnd) 
....................          nextRxHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................       MyTCBStub.rxTail = prevRxTail; 
....................       MyTCBStub.rxHead = nextRxHead; 
....................    } 
.................... }    
.................... #endif 
....................  
....................  
.................... #endif //#if defined(STACK_USE_TCP) 
....................  
....................     
....................    void TCPTouch(TCP_SOCKET s) 
....................    { 
....................       SyncTCBStub(s); 
....................       if(MyTCBStub.smState == TCP_ESTABLISHED) 
....................       { 
....................          MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
....................          SyncTCB(); 
....................       } 
....................    } 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
....................    #include "_DNS.c" //ccs had to rename this driver to not conflict an s7600 driver in the default include path - a bug in the compiler 
.................... /********************************************************************* 
....................  * 
....................  *	Domain Name System (DNS) Client 
....................  *  Module for Microchip TCP/IP Stack 
....................  *	 -Provides hostname to IP address translation 
....................  *	 -Reference: RFC 1035 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        DNS.c 
....................  * Dependencies:    UDP, ARP, Tick 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date		Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder     7/31/06		Original 
....................  * Howard Schlunder		10/09/06	Added DNSBeginUsage(), DNSEndUsage()  
....................  *									module ownership semaphore 
....................  * Howard Schlunder		08/28/09	Fixed name compression parsing bug 
....................  * Darren Rook          12/19/12 Renamed MySocket to MyDNSSocket so 
....................  *                                  this file can be #included. 
....................  *                               Renamed Flags to DNSFlags. 
....................  *                               Renamed file to _DNS.c to not intefere 
....................  *                                  with DNS.c that comes with compiler. 
....................  ********************************************************************/ 
.................... #define __DNS_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_DNS) 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	Constants and Global Variables 
....................   ***************************************************************************/ 
....................  
.................... #define DNS_PORT		53u					// Default port for DNS resolutions 
.................... #define DNS_TIMEOUT		(TICK_SECOND*1)		// Elapsed time after which a DNS resolution is considered to have timed out 
....................  
.................... static UDP_SOCKET MyDNSSocket = INVALID_UDP_SOCKET;	// UDP socket to use for DNS queries 
.................... static BYTE *DNSHostName;							// Host name in RAM to look up 
.................... static ROM BYTE *DNSHostNameROM;					// Host name in ROM to look up 
.................... static BYTE RecordType;								// Record type being queried 
.................... static NODE_INFO ResolvedInfo;						// Node information about the resolved node 
....................  
.................... // Semaphore flags for the DNS module 
.................... static union 
.................... { 
.................... 	BYTE Val; 
.................... 	struct 
.................... 	{ 
.................... 		unsigned char DNSInUse 		: 1;	// Indicates the DNS module is in use 
.................... 		unsigned char AddressValid	: 1;	// Indicates that the address resolution is valid and complete 
.................... 		unsigned char filler 		: 6; 
.................... 	} bits; 
.................... } DNSFlags = {0x00}; 
....................  
.................... // State machine for a DNS query 
.................... static enum 
.................... { 
.................... 	DNS_START = 0, 				// Initial state to reset client state variables 
.................... 	DNS_ARP_START_RESOLVE,		// Send ARP resolution of DNS server or gateway MAC address 
.................... 	DNS_ARP_RESOLVE,			// Wait for response to ARP request 
.................... 	DNS_OPEN_SOCKET,			// Open UDP socket 
.................... 	DNS_QUERY,					// Send DNS query to DNS server 
.................... 	DNS_GET_RESULT,				// Wait for response from DNS server 
.................... 	DNS_FAIL,					// ARP or DNS server not responding 
.................... 	DNS_DONE					// DNS query is finished 
.................... } smDNS = DNS_DONE; 
....................  
.................... // Structure for the DNS header 
.................... typedef struct 
.................... { 
.................... 	WORD_VAL TransactionID; 
.................... 	WORD_VAL Flags; 
.................... 	WORD_VAL Questions; 
.................... 	WORD_VAL Answers; 
.................... 	WORD_VAL AuthoritativeRecords; 
.................... 	WORD_VAL AdditionalRecords; 
.................... } DNS_HEADER; 
....................  
.................... typedef struct 
.................... { 
.................... 	// Response name is first, but it is variable length and must be retrieved using the DNSDiscardName() function 
.................... 	WORD_VAL	ResponseType; 
.................... 	WORD_VAL	ResponseClass; 
.................... 	DWORD_VAL	ResponseTTL; 
.................... 	WORD_VAL	ResponseLen; 
.................... } DNS_ANSWER_HEADER; 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	Function Prototypes 
....................   ***************************************************************************/ 
....................  
.................... static void DNSPutString(BYTE* String); 
.................... static void DNSDiscardName(void); 
....................  
.................... #if defined(__18CXX) 
.................... 	static void DNSPutROMString(ROM BYTE* String); 
.................... #else 
.................... 	// Non-ROM alias for C30/C32 
.................... 	#define DNSPutROMString(a)	DNSPutString((BYTE*)a) 
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	BOOL DNSBeginUsage(void) 
....................  
....................   Summary: 
.................... 	Claims access to the DNS module. 
.................... 	 
....................   Description: 
.................... 	This function acts as a semaphore to obtain usage of the DNS module. 
.................... 	Call this function and ensure that it returns TRUE before calling any 
.................... 	other DNS APIs.  Call DNSEndUsage when this application no longer  
.................... 	needs the DNS module so that other applications may make use of it. 
....................  
....................   Precondition: 
.................... 	Stack is initialized. 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Return Values: 
....................   	TRUE - No other DNS resolutions are in progress and the calling 
....................   			application has sucessfully taken ownership of the DNS module 
....................   	FALSE - The DNS module is currently in use.  Yield to the stack and  
....................   			attempt this call again later. 
....................   	 
....................   Remarks: 
.................... 	Ensure that DNSEndUsage is always called once your application has 
.................... 	obtained control of the DNS module.  If this is not done, the stack 
.................... 	will hang for all future applications requiring DNS access. 
....................   ***************************************************************************/ 
.................... BOOL DNSBeginUsage(void) 
.................... { 
.................... 	if(DNSFlags.bits.DNSInUse) 
*
02A5A:  MOVLB  2
02A5C:  BTFSS  x00.0
02A5E:  BRA    2A66
.................... 		return FALSE; 
02A60:  MOVLW  00
02A62:  MOVWF  01
02A64:  BRA    2A6C
....................  
.................... 	DNSFlags.bits.DNSInUse = TRUE; 
02A66:  BSF    x00.0
.................... 	return TRUE; 
02A68:  MOVLW  01
02A6A:  MOVWF  01
02A6C:  MOVLB  0
02A6E:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	BOOL DNSEndUsage(void) 
....................  
....................   Summary: 
.................... 	Releases control of the DNS module. 
.................... 	 
....................   Description: 
.................... 	This function acts as a semaphore to obtain usage of the DNS module. 
.................... 	Call this function when this application no longer needs the DNS  
.................... 	module so that other applications may make use of it. 
....................  
....................   Precondition: 
.................... 	DNSBeginUsage returned TRUE on a previous call. 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Return Values: 
....................   	TRUE - The address to the host name was successfully resolved. 
....................   	FALSE - The DNS failed or the address does not exist. 
....................   	 
....................   Remarks: 
.................... 	Ensure that DNSEndUsage is always called once your application has 
.................... 	obtained control of the DNS module.  If this is not done, the stack 
.................... 	will hang for all future applications requiring DNS access. 
....................   ***************************************************************************/ 
.................... BOOL DNSEndUsage(void) 
.................... { 
.................... 	if(MyDNSSocket != INVALID_UDP_SOCKET) 
*
0293A:  MOVLB  1
0293C:  INCFSZ xF0,W
0293E:  BRA    2942
02940:  BRA    2950
.................... 	{ 
.................... 		UDPClose(MyDNSSocket); 
02942:  MOVFF  1F0,270
02946:  MOVLB  0
02948:  CALL   0C0A
.................... 		MyDNSSocket = INVALID_UDP_SOCKET; 
0294C:  MOVLB  1
0294E:  SETF   xF0
.................... 	} 
.................... 	smDNS = DNS_DONE; 
02950:  MOVLW  07
02952:  MOVLB  2
02954:  MOVWF  x01
.................... 	DNSFlags.bits.DNSInUse = FALSE; 
02956:  BCF    x00.0
....................  
.................... 	return DNSFlags.bits.AddressValid; 
02958:  MOVLW  00
0295A:  BTFSC  x00.1
0295C:  MOVLW  01
0295E:  MOVWF  01
02960:  MOVLB  0
02962:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	void DNSResolve(BYTE* Hostname, BYTE Type) 
....................  
....................   Summary: 
.................... 	Begins resolution of an address. 
.................... 	 
....................   Description: 
.................... 	This function attempts to resolve a host name to an IP address.  When  
.................... 	called, it starts the DNS state machine.  Call DNSIsResolved repeatedly 
.................... 	to determine if the resolution is complete. 
.................... 	 
.................... 	Only one DNS resoultion may be executed at a time.  The Hostname must  
.................... 	not be modified in memory until the resolution is complete. 
....................  
....................   Precondition: 
.................... 	DNSBeginUsage returned TRUE on a previous call. 
....................  
....................   Parameters: 
.................... 	Hostname - A pointer to the null terminated string specifiying the 
.................... 		host for which to resolve an IP. 
.................... 	RecordType - DNS_TYPE_A or DNS_TYPE_MX depending on what type of 
.................... 		record resolution is desired. 
....................  
....................   Returns: 
....................   	None 
....................   	 
....................   Remarks: 
.................... 	This function requires access to one UDP socket.  If none are available, 
.................... 	MAX_UDP_SOCKETS may need to be increased. 
....................   ***************************************************************************/ 
.................... void DNSResolve(BYTE* Hostname, BYTE Type) 
.................... { 
.................... 	if(StringToIPAddress(Hostname, &ResolvedInfo.IPAddr)) 
*
02E2C:  MOVFF  256,259
02E30:  MOVFF  255,258
02E34:  MOVLW  01
02E36:  MOVLB  2
02E38:  MOVWF  x5B
02E3A:  MOVLW  F6
02E3C:  MOVWF  x5A
02E3E:  MOVLB  0
02E40:  BRA    2C84
02E42:  MOVF   01,F
02E44:  BZ    2E52
.................... 	{ 
.................... 		DNSFlags.bits.AddressValid = TRUE; 
02E46:  MOVLB  2
02E48:  BSF    x00.1
.................... 		smDNS = DNS_DONE; 
02E4A:  MOVLW  07
02E4C:  MOVWF  x01
.................... 	} 
02E4E:  BRA    2E6A
02E50:  MOVLB  0
.................... 	else 
.................... 	{	 
.................... 		DNSHostName = Hostname; 
02E52:  MOVFF  256,1F2
02E56:  MOVFF  255,1F1
.................... 		DNSHostNameROM = NULL; 
02E5A:  MOVLB  1
02E5C:  CLRF   xF4
02E5E:  CLRF   xF3
.................... 		smDNS = DNS_START; 
02E60:  MOVLB  2
02E62:  CLRF   x01
.................... 		RecordType = Type; 
02E64:  MOVFF  257,1F5
.................... 		DNSFlags.bits.AddressValid = FALSE; 
02E68:  BCF    x00.1
.................... 	} 
02E6A:  MOVLB  0
02E6C:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	void DNSResolveROM(ROM BYTE* Hostname, BYTE Type) 
....................  
....................   Summary: 
.................... 	Begins resolution of an address. 
.................... 	 
....................   Description: 
.................... 	This function attempts to resolve a host name to an IP address.  When  
.................... 	called, it starts the DNS state machine.  Call DNSIsResolved repeatedly 
.................... 	to determine if the resolution is complete. 
.................... 	 
.................... 	Only one DNS resoultion may be executed at a time.  The Hostname must  
.................... 	not be modified in memory until the resolution is complete. 
....................  
....................   Precondition: 
.................... 	DNSBeginUsage returned TRUE on a previous call. 
....................  
....................   Parameters: 
.................... 	Hostname - A pointer to the null terminated string specifiying the 
.................... 		host for which to resolve an IP. 
.................... 	RecordType - DNS_TYPE_A or DNS_TYPE_MX depending on what type of 
.................... 		record resolution is desired. 
....................  
....................   Returns: 
....................   	None 
....................   	 
....................   Remarks: 
.................... 	This function requires access to one UDP socket.  If none are available, 
.................... 	MAX_UDP_SOCKETS may need to be increased. 
.................... 	 
.................... 	This function is aliased to DNSResolve on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... void DNSResolveROM(ROM BYTE* Hostname, BYTE Type) 
.................... { 
.................... 	if(ROMStringToIPAddress(Hostname, &ResolvedInfo.IPAddr)) 
*
02C42:  MOVFF  258,25B
02C46:  MOVFF  257,25A
02C4A:  MOVLW  01
02C4C:  MOVLB  2
02C4E:  MOVWF  x5D
02C50:  MOVLW  F6
02C52:  MOVWF  x5C
02C54:  MOVLB  0
02C56:  BRA    2A8E
02C58:  MOVF   01,F
02C5A:  BZ    2C68
.................... 	{ 
.................... 		DNSFlags.bits.AddressValid = TRUE; 
02C5C:  MOVLB  2
02C5E:  BSF    x00.1
.................... 		smDNS = DNS_DONE; 
02C60:  MOVLW  07
02C62:  MOVWF  x01
.................... 	} 
02C64:  BRA    2C80
02C66:  MOVLB  0
.................... 	else 
.................... 	{	 
.................... 		DNSHostName = NULL; 
02C68:  MOVLB  1
02C6A:  CLRF   xF2
02C6C:  CLRF   xF1
.................... 		DNSHostNameROM = Hostname; 
02C6E:  MOVFF  258,1F4
02C72:  MOVFF  257,1F3
.................... 		smDNS = DNS_START; 
02C76:  MOVLB  2
02C78:  CLRF   x01
.................... 		RecordType = Type; 
02C7A:  MOVFF  259,1F5
.................... 		DNSFlags.bits.AddressValid = FALSE; 
02C7E:  BCF    x00.1
.................... 	} 
02C80:  MOVLB  0
02C82:  RETURN 0
.................... } 
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	BOOL DNSIsResolved(IP_ADDR* HostIP) 
....................  
....................   Summary: 
.................... 	Determines if the DNS resolution is complete and provides the IP. 
.................... 	 
....................   Description: 
.................... 	Call this function to determine if the DNS resolution of an address has 
.................... 	been completed.  If so, the resolved address will be provided in HostIP. 
....................  
....................   Precondition: 
.................... 	DNSResolve or DNSResolveROM has been called. 
....................  
....................   Parameters: 
.................... 	HostIP - A pointer to an IP_ADDR structure in which to store the  
.................... 		resolved IP address once resolution is complete. 
....................  
....................   Return Values: 
....................   	TRUE - The DNS client has obtained an IP, or the DNS process 
....................   		has encountered an error.  HostIP will be 0.0.0.0 on error.  Possible  
....................   		errors include server timeout (i.e. DNS server not available), hostname  
....................   		not in the DNS, or DNS server errors. 
....................   	FALSE - The resolution process is still in progress. 
....................   ***************************************************************************/ 
.................... BOOL DNSIsResolved(IP_ADDR* HostIP) 
.................... { 
.................... 	static DWORD		StartTime; 
.................... 	static WORD_VAL		SentTransactionID __attribute__((persistent)); 
.................... 	static BYTE			vARPAttemptCount; 
.................... 	static BYTE			vDNSAttemptCount; 
.................... 	BYTE 				i; 
.................... 	WORD_VAL			w; 
.................... 	DNS_HEADER			DNSHeader; 
.................... 	DNS_ANSWER_HEADER	DNSAnswerHeader; 
....................  
.................... 	switch(smDNS) 
*
03B56:  MOVLB  2
03B58:  MOVF   x01,W
03B5A:  ADDLW  F8
03B5C:  BTFSC  FD8.0
03B5E:  GOTO   4312
03B62:  ADDLW  08
03B64:  MOVLB  0
03B66:  GOTO   431A
.................... 	{ 
.................... 		case DNS_START: 
.................... 			vARPAttemptCount = 0; 
03B6A:  MOVLB  2
03B6C:  CLRF   x08
.................... 			vDNSAttemptCount = 0; 
03B6E:  CLRF   x09
03B70:  MOVLB  0
.................... 			// No break; 
....................  
.................... 		case DNS_ARP_START_RESOLVE: 
.................... 			ARPResolve(&AppConfig.PrimaryDNSServer); 
03B72:  MOVLB  2
03B74:  CLRF   x71
03B76:  MOVLW  35
03B78:  MOVWF  x70
03B7A:  MOVLB  0
03B7C:  CALL   3048
.................... 			vARPAttemptCount++; 
03B80:  MOVLB  2
03B82:  INCF   x08,F
.................... 			StartTime = TickGet(); 
03B84:  MOVLB  0
03B86:  CALL   1734
03B8A:  MOVFF  03,205
03B8E:  MOVFF  02,204
03B92:  MOVFF  01,203
03B96:  MOVFF  00,202
.................... 			smDNS = DNS_ARP_RESOLVE; 
03B9A:  MOVLW  02
03B9C:  MOVLB  2
03B9E:  MOVWF  x01
.................... 			break; 
03BA0:  GOTO   4312
....................  
.................... 		case DNS_ARP_RESOLVE: 
.................... 			if(!ARPIsResolved(&AppConfig.PrimaryDNSServer, &ResolvedInfo.MACAddr)) 
03BA4:  MOVLB  2
03BA6:  CLRF   x71
03BA8:  MOVLW  35
03BAA:  MOVWF  x70
03BAC:  MOVLW  01
03BAE:  MOVWF  x73
03BB0:  MOVLW  FA
03BB2:  MOVWF  x72
03BB4:  MOVLB  0
03BB6:  CALL   30FC
03BBA:  MOVF   01,F
03BBC:  BNZ   3C0E
.................... 			{ 
.................... 				if(TickGet() - StartTime > DNS_TIMEOUT) 
03BBE:  CALL   1734
03BC2:  MOVFF  03,273
03BC6:  MOVFF  02,272
03BCA:  MOVFF  01,271
03BCE:  MOVFF  00,270
03BD2:  MOVLB  2
03BD4:  MOVF   x02,W
03BD6:  SUBWF  x70,F
03BD8:  MOVF   x03,W
03BDA:  SUBWFB x71,F
03BDC:  MOVF   x04,W
03BDE:  SUBWFB x72,F
03BE0:  MOVF   x05,W
03BE2:  SUBWFB x73,F
03BE4:  BNZ   3BFA
03BE6:  MOVF   x72,F
03BE8:  BNZ   3BFA
03BEA:  MOVF   x71,W
03BEC:  SUBLW  97
03BEE:  BC    3C08
03BF0:  XORLW  FF
03BF2:  BNZ   3BFA
03BF4:  MOVF   x70,W
03BF6:  SUBLW  97
03BF8:  BC    3C08
.................... 					smDNS = (vARPAttemptCount >= 3u) ? DNS_FAIL : DNS_ARP_START_RESOLVE; 
03BFA:  MOVF   x08,W
03BFC:  SUBLW  02
03BFE:  BC    3C04
03C00:  MOVLW  06
03C02:  BRA    3C06
03C04:  MOVLW  01
03C06:  MOVWF  x01
.................... 				break; 
03C08:  GOTO   4312
03C0C:  MOVLB  0
.................... 			} 
.................... 			ResolvedInfo.IPAddr.Val = AppConfig.PrimaryDNSServer.Val; 
03C0E:  MOVFF  38,1F9
03C12:  MOVFF  37,1F8
03C16:  MOVFF  36,1F7
03C1A:  MOVFF  35,1F6
.................... 			smDNS = DNS_OPEN_SOCKET; 
03C1E:  MOVLW  03
03C20:  MOVLB  2
03C22:  MOVWF  x01
03C24:  MOVLB  0
.................... 			// No break: DNS_OPEN_SOCKET is the correct next state 
.................... 		 
.................... 		case DNS_OPEN_SOCKET: 
.................... 			//MyDNSSocket = UDPOpen(0, &ResolvedInfo, DNS_PORT); 
.................... 			 
.................... 			MyDNSSocket = UDPOpenEx((DWORD)(PTR_BASE)&ResolvedInfo,UDP_OPEN_NODE_INFO,0, DNS_PORT); 
03C26:  MOVLW  01
03C28:  MOVLB  2
03C2A:  MOVWF  x71
03C2C:  MOVLW  F6
03C2E:  MOVWF  x70
03C30:  CLRF   x75
03C32:  CLRF   x74
03C34:  MOVFF  271,273
03C38:  MOVWF  x72
03C3A:  MOVFF  275,279
03C3E:  MOVFF  274,278
03C42:  MOVFF  271,277
03C46:  MOVWF  x76
03C48:  MOVLW  04
03C4A:  MOVWF  x7A
03C4C:  CLRF   x7C
03C4E:  CLRF   x7B
03C50:  CLRF   x7E
03C52:  MOVLW  35
03C54:  MOVWF  x7D
03C56:  MOVLB  0
03C58:  GOTO   31F0
03C5C:  MOVFF  01,1F0
.................... 			if(MyDNSSocket == INVALID_UDP_SOCKET) 
03C60:  MOVLB  1
03C62:  INCFSZ xF0,W
03C64:  BRA    3C6C
.................... 				break; 
03C66:  MOVLB  2
03C68:  BRA    4312
03C6A:  MOVLB  1
....................  
.................... 			smDNS = DNS_QUERY; 
03C6C:  MOVLW  04
03C6E:  MOVLB  2
03C70:  MOVWF  x01
03C72:  MOVLB  0
.................... 			// No need to break, we can immediately start resolution 
.................... 			 
.................... 		case DNS_QUERY: 
.................... 			if(!UDPIsPutReady(MyDNSSocket)) 
03C74:  MOVFF  1F0,270
03C78:  GOTO   344E
03C7C:  MOVF   01,W
03C7E:  IORWF  02,W
03C80:  BNZ   3C88
.................... 				break; 
03C82:  MOVLB  2
03C84:  BRA    4312
03C86:  MOVLB  0
.................... 			 
.................... 			// Put DNS query here 
.................... 			SentTransactionID.Val++; 
03C88:  MOVLB  2
03C8A:  INCF   x06,F
03C8C:  BTFSC  FD8.2
03C8E:  INCF   x07,F
.................... 			UDPPut(SentTransactionID.v[1]);// User chosen transaction ID 
03C90:  MOVFF  207,276
03C94:  MOVLB  0
03C96:  RCALL  349C
.................... 			UDPPut(SentTransactionID.v[0]); 
03C98:  MOVFF  206,276
03C9C:  CALL   349C
.................... 			UDPPut(0x01);		// Standard query with recursion 
03CA0:  MOVLW  01
03CA2:  MOVLB  2
03CA4:  MOVWF  x76
03CA6:  MOVLB  0
03CA8:  CALL   349C
.................... 			UDPPut(0x00);	 
03CAC:  MOVLB  2
03CAE:  CLRF   x76
03CB0:  MOVLB  0
03CB2:  CALL   349C
.................... 			UDPPut(0x00);		// 0x0001 questions 
03CB6:  MOVLB  2
03CB8:  CLRF   x76
03CBA:  MOVLB  0
03CBC:  CALL   349C
.................... 			UDPPut(0x01); 
03CC0:  MOVLW  01
03CC2:  MOVLB  2
03CC4:  MOVWF  x76
03CC6:  MOVLB  0
03CC8:  CALL   349C
.................... 			UDPPut(0x00);		// 0x0000 answers 
03CCC:  MOVLB  2
03CCE:  CLRF   x76
03CD0:  MOVLB  0
03CD2:  CALL   349C
.................... 			UDPPut(0x00); 
03CD6:  MOVLB  2
03CD8:  CLRF   x76
03CDA:  MOVLB  0
03CDC:  CALL   349C
.................... 			UDPPut(0x00);		// 0x0000 name server resource records 
03CE0:  MOVLB  2
03CE2:  CLRF   x76
03CE4:  MOVLB  0
03CE6:  CALL   349C
.................... 			UDPPut(0x00); 
03CEA:  MOVLB  2
03CEC:  CLRF   x76
03CEE:  MOVLB  0
03CF0:  CALL   349C
.................... 			UDPPut(0x00);		// 0x0000 additional records 
03CF4:  MOVLB  2
03CF6:  CLRF   x76
03CF8:  MOVLB  0
03CFA:  CALL   349C
.................... 			UDPPut(0x00); 
03CFE:  MOVLB  2
03D00:  CLRF   x76
03D02:  MOVLB  0
03D04:  CALL   349C
....................  
.................... 			// Put hostname string to resolve 
.................... 			if(DNSHostName) 
03D08:  MOVLB  1
03D0A:  MOVF   xF1,W
03D0C:  IORWF  xF2,W
03D0E:  BZ    3D22
.................... 				DNSPutString(DNSHostName); 
03D10:  MOVFF  1F2,271
03D14:  MOVFF  1F1,270
03D18:  MOVLB  0
03D1A:  BRA    3576
03D1C:  MOVLB  0
03D1E:  BRA    3D2E
03D20:  MOVLB  1
.................... 			else 
.................... 				DNSPutROMString(DNSHostNameROM); 
03D22:  MOVFF  1F4,271
03D26:  MOVFF  1F3,270
03D2A:  MOVLB  0
03D2C:  BRA    370A
....................  
.................... 			UDPPut(0x00);		// Type: DNS_TYPE_A A (host address) or DNS_TYPE_MX for mail exchange 
03D2E:  MOVLB  2
03D30:  CLRF   x76
03D32:  MOVLB  0
03D34:  CALL   349C
.................... 			UDPPut(RecordType); 
03D38:  MOVFF  1F5,276
03D3C:  CALL   349C
.................... 			UDPPut(0x00);		// Class: IN (Internet) 
03D40:  MOVLB  2
03D42:  CLRF   x76
03D44:  MOVLB  0
03D46:  CALL   349C
.................... 			UDPPut(0x01); 
03D4A:  MOVLW  01
03D4C:  MOVLB  2
03D4E:  MOVWF  x76
03D50:  MOVLB  0
03D52:  CALL   349C
....................  
.................... 			UDPFlush(); 
03D56:  BRA    37DC
.................... 			StartTime = TickGet(); 
03D58:  CALL   1734
03D5C:  MOVFF  03,205
03D60:  MOVFF  02,204
03D64:  MOVFF  01,203
03D68:  MOVFF  00,202
.................... 			smDNS = DNS_GET_RESULT; 
03D6C:  MOVLW  05
03D6E:  MOVLB  2
03D70:  MOVWF  x01
.................... 			break; 
03D72:  BRA    4312
....................  
.................... 		case DNS_GET_RESULT: 
.................... 			if(!UDPIsGetReady(MyDNSSocket)) 
03D74:  MOVFF  1F0,270
03D78:  BRA    397C
03D7A:  MOVF   01,W
03D7C:  IORWF  02,W
03D7E:  BNZ   3DC4
.................... 			{ 
.................... 				if(TickGet() - StartTime > DNS_TIMEOUT) 
03D80:  CALL   1734
03D84:  MOVFF  03,273
03D88:  MOVFF  02,272
03D8C:  MOVFF  01,271
03D90:  MOVFF  00,270
03D94:  MOVLB  2
03D96:  MOVF   x02,W
03D98:  SUBWF  x70,F
03D9A:  MOVF   x03,W
03D9C:  SUBWFB x71,F
03D9E:  MOVF   x04,W
03DA0:  SUBWFB x72,F
03DA2:  MOVF   x05,W
03DA4:  SUBWFB x73,F
03DA6:  BNZ   3DBC
03DA8:  MOVF   x72,F
03DAA:  BNZ   3DBC
03DAC:  MOVF   x71,W
03DAE:  SUBLW  97
03DB0:  BC    3DC0
03DB2:  XORLW  FF
03DB4:  BNZ   3DBC
03DB6:  MOVF   x70,W
03DB8:  SUBLW  97
03DBA:  BC    3DC0
.................... 					smDNS = DNS_FAIL; 
03DBC:  MOVLW  06
03DBE:  MOVWF  x01
.................... 				break; 
03DC0:  BRA    4312
03DC2:  MOVLB  0
.................... 			} 
....................  
.................... 			// Retrieve the DNS header and de-big-endian it 
.................... 			UDPGet(&DNSHeader.TransactionID.v[1]); 
03DC4:  MOVLW  02
03DC6:  MOVLB  2
03DC8:  MOVWF  x72
03DCA:  MOVLW  5B
03DCC:  MOVWF  x71
03DCE:  MOVLB  0
03DD0:  RCALL  39BC
.................... 			UDPGet(&DNSHeader.TransactionID.v[0]); 
03DD2:  MOVLW  02
03DD4:  MOVLB  2
03DD6:  MOVWF  x72
03DD8:  MOVLW  5A
03DDA:  MOVWF  x71
03DDC:  MOVLB  0
03DDE:  RCALL  39BC
....................  
.................... 			// Throw this packet away if it isn't in response to our last query 
.................... 			if(DNSHeader.TransactionID.Val != SentTransactionID.Val) 
03DE0:  MOVLB  2
03DE2:  MOVF   x06,W
03DE4:  SUBWF  x5A,W
03DE6:  BNZ   3DEE
03DE8:  MOVF   x07,W
03DEA:  SUBWF  x5B,W
03DEC:  BZ    3DF6
.................... 			{ 
.................... 				UDPDiscard(); 
03DEE:  MOVLB  0
03DF0:  RCALL  3A6E
.................... 				break; 
03DF2:  MOVLB  2
03DF4:  BRA    4312
.................... 			} 
....................  
.................... 			UDPGet(&DNSHeader.Flags.v[1]); 
03DF6:  MOVLW  02
03DF8:  MOVWF  x72
03DFA:  MOVLW  5D
03DFC:  MOVWF  x71
03DFE:  MOVLB  0
03E00:  RCALL  39BC
.................... 			UDPGet(&DNSHeader.Flags.v[0]); 
03E02:  MOVLW  02
03E04:  MOVLB  2
03E06:  MOVWF  x72
03E08:  MOVLW  5C
03E0A:  MOVWF  x71
03E0C:  MOVLB  0
03E0E:  RCALL  39BC
.................... 			UDPGet(&DNSHeader.Questions.v[1]); 
03E10:  MOVLW  02
03E12:  MOVLB  2
03E14:  MOVWF  x72
03E16:  MOVLW  5F
03E18:  MOVWF  x71
03E1A:  MOVLB  0
03E1C:  RCALL  39BC
.................... 			UDPGet(&DNSHeader.Questions.v[0]); 
03E1E:  MOVLW  02
03E20:  MOVLB  2
03E22:  MOVWF  x72
03E24:  MOVLW  5E
03E26:  MOVWF  x71
03E28:  MOVLB  0
03E2A:  RCALL  39BC
.................... 			UDPGet(&DNSHeader.Answers.v[1]); 
03E2C:  MOVLW  02
03E2E:  MOVLB  2
03E30:  MOVWF  x72
03E32:  MOVLW  61
03E34:  MOVWF  x71
03E36:  MOVLB  0
03E38:  RCALL  39BC
.................... 			UDPGet(&DNSHeader.Answers.v[0]); 
03E3A:  MOVLW  02
03E3C:  MOVLB  2
03E3E:  MOVWF  x72
03E40:  MOVLW  60
03E42:  MOVWF  x71
03E44:  MOVLB  0
03E46:  RCALL  39BC
.................... 			UDPGet(&DNSHeader.AuthoritativeRecords.v[1]); 
03E48:  MOVLW  02
03E4A:  MOVLB  2
03E4C:  MOVWF  x72
03E4E:  MOVLW  63
03E50:  MOVWF  x71
03E52:  MOVLB  0
03E54:  RCALL  39BC
.................... 			UDPGet(&DNSHeader.AuthoritativeRecords.v[0]); 
03E56:  MOVLW  02
03E58:  MOVLB  2
03E5A:  MOVWF  x72
03E5C:  MOVLW  62
03E5E:  MOVWF  x71
03E60:  MOVLB  0
03E62:  RCALL  39BC
.................... 			UDPGet(&DNSHeader.AdditionalRecords.v[1]); 
03E64:  MOVLW  02
03E66:  MOVLB  2
03E68:  MOVWF  x72
03E6A:  MOVLW  65
03E6C:  MOVWF  x71
03E6E:  MOVLB  0
03E70:  RCALL  39BC
.................... 			UDPGet(&DNSHeader.AdditionalRecords.v[0]); 
03E72:  MOVLW  02
03E74:  MOVLB  2
03E76:  MOVWF  x72
03E78:  MOVLW  64
03E7A:  MOVWF  x71
03E7C:  MOVLB  0
03E7E:  RCALL  39BC
....................  
.................... 			// Remove all questions (queries) 
.................... 			while(DNSHeader.Questions.Val--) 
03E80:  MOVLB  2
03E82:  MOVFF  25F,03
03E86:  MOVF   x5E,W
03E88:  BTFSC  FD8.2
03E8A:  DECF   x5F,F
03E8C:  DECF   x5E,F
03E8E:  IORWF  03,W
03E90:  BZ    3ED2
.................... 			{ 
.................... 				DNSDiscardName(); 
03E92:  MOVLB  0
03E94:  RCALL  3B0C
.................... 				UDPGet(&w.v[1]);		// Question type 
03E96:  MOVLW  02
03E98:  MOVLB  2
03E9A:  MOVWF  x72
03E9C:  MOVLW  59
03E9E:  MOVWF  x71
03EA0:  MOVLB  0
03EA2:  RCALL  39BC
.................... 				UDPGet(&w.v[0]); 
03EA4:  MOVLW  02
03EA6:  MOVLB  2
03EA8:  MOVWF  x72
03EAA:  MOVLW  58
03EAC:  MOVWF  x71
03EAE:  MOVLB  0
03EB0:  RCALL  39BC
.................... 				UDPGet(&w.v[1]);		// Question class 
03EB2:  MOVLW  02
03EB4:  MOVLB  2
03EB6:  MOVWF  x72
03EB8:  MOVLW  59
03EBA:  MOVWF  x71
03EBC:  MOVLB  0
03EBE:  RCALL  39BC
.................... 				UDPGet(&w.v[0]); 
03EC0:  MOVLW  02
03EC2:  MOVLB  2
03EC4:  MOVWF  x72
03EC6:  MOVLW  58
03EC8:  MOVWF  x71
03ECA:  MOVLB  0
03ECC:  RCALL  39BC
03ECE:  BRA    3E80
03ED0:  MOVLB  2
.................... 			} 
.................... 			 
.................... 			// Scan through answers 
.................... 			while(DNSHeader.Answers.Val--) 
03ED2:  MOVFF  261,03
03ED6:  MOVF   x60,W
03ED8:  BTFSC  FD8.2
03EDA:  DECF   x61,F
03EDC:  DECF   x60,F
03EDE:  IORWF  03,W
03EE0:  BTFSC  FD8.2
03EE2:  BRA    3FF2
.................... 			{				 
.................... 				DNSDiscardName();					// Throw away response name 
03EE4:  MOVLB  0
03EE6:  RCALL  3B0C
.................... 				UDPGet(&DNSAnswerHeader.ResponseType.v[1]);		// Response type 
03EE8:  MOVLW  02
03EEA:  MOVLB  2
03EEC:  MOVWF  x72
03EEE:  MOVLW  67
03EF0:  MOVWF  x71
03EF2:  MOVLB  0
03EF4:  RCALL  39BC
.................... 				UDPGet(&DNSAnswerHeader.ResponseType.v[0]); 
03EF6:  MOVLW  02
03EF8:  MOVLB  2
03EFA:  MOVWF  x72
03EFC:  MOVLW  66
03EFE:  MOVWF  x71
03F00:  MOVLB  0
03F02:  RCALL  39BC
.................... 				UDPGet(&DNSAnswerHeader.ResponseClass.v[1]);	// Response class 
03F04:  MOVLW  02
03F06:  MOVLB  2
03F08:  MOVWF  x72
03F0A:  MOVLW  69
03F0C:  MOVWF  x71
03F0E:  MOVLB  0
03F10:  RCALL  39BC
.................... 				UDPGet(&DNSAnswerHeader.ResponseClass.v[0]); 
03F12:  MOVLW  02
03F14:  MOVLB  2
03F16:  MOVWF  x72
03F18:  MOVLW  68
03F1A:  MOVWF  x71
03F1C:  MOVLB  0
03F1E:  RCALL  39BC
.................... 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[3]);		// Time to live 
03F20:  MOVLW  02
03F22:  MOVLB  2
03F24:  MOVWF  x72
03F26:  MOVLW  6D
03F28:  MOVWF  x71
03F2A:  MOVLB  0
03F2C:  RCALL  39BC
.................... 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[2]); 
03F2E:  MOVLW  02
03F30:  MOVLB  2
03F32:  MOVWF  x72
03F34:  MOVLW  6C
03F36:  MOVWF  x71
03F38:  MOVLB  0
03F3A:  RCALL  39BC
.................... 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[1]); 
03F3C:  MOVLW  02
03F3E:  MOVLB  2
03F40:  MOVWF  x72
03F42:  MOVLW  6B
03F44:  MOVWF  x71
03F46:  MOVLB  0
03F48:  RCALL  39BC
.................... 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[0]); 
03F4A:  MOVLW  02
03F4C:  MOVLB  2
03F4E:  MOVWF  x72
03F50:  MOVLW  6A
03F52:  MOVWF  x71
03F54:  MOVLB  0
03F56:  RCALL  39BC
.................... 				UDPGet(&DNSAnswerHeader.ResponseLen.v[1]);		// Response length 
03F58:  MOVLW  02
03F5A:  MOVLB  2
03F5C:  MOVWF  x72
03F5E:  MOVLW  6F
03F60:  MOVWF  x71
03F62:  MOVLB  0
03F64:  RCALL  39BC
.................... 				UDPGet(&DNSAnswerHeader.ResponseLen.v[0]); 
03F66:  MOVLW  02
03F68:  MOVLB  2
03F6A:  MOVWF  x72
03F6C:  MOVLW  6E
03F6E:  MOVWF  x71
03F70:  MOVLB  0
03F72:  RCALL  39BC
....................  
.................... 				// Make sure that this is a 4 byte IP address, response type A or MX, class 1 
.................... 				// Check if this is Type A or MX 
.................... 				if( DNSAnswerHeader.ResponseType.Val	== 0x0001u && 
.................... 					DNSAnswerHeader.ResponseClass.Val	== 0x0001u && // Internet class 
.................... 					DNSAnswerHeader.ResponseLen.Val		== 0x0004u) 
03F74:  MOVLB  2
03F76:  DECFSZ x66,W
03F78:  BRA    3FCE
03F7A:  MOVF   x67,F
03F7C:  BNZ   3FCE
03F7E:  DECFSZ x68,W
03F80:  BRA    3FCE
03F82:  MOVF   x69,F
03F84:  BNZ   3FCE
03F86:  MOVF   x6E,W
03F88:  SUBLW  04
03F8A:  BNZ   3FCE
03F8C:  MOVF   x6F,F
03F8E:  BNZ   3FCE
.................... 				{ 
.................... 					DNSFlags.bits.AddressValid = TRUE; 
03F90:  BSF    x00.1
.................... 					UDPGet(&ResolvedInfo.IPAddr.v[0]); 
03F92:  MOVLW  01
03F94:  MOVWF  x72
03F96:  MOVLW  F6
03F98:  MOVWF  x71
03F9A:  MOVLB  0
03F9C:  RCALL  39BC
.................... 					UDPGet(&ResolvedInfo.IPAddr.v[1]); 
03F9E:  MOVLW  01
03FA0:  MOVLB  2
03FA2:  MOVWF  x72
03FA4:  MOVLW  F7
03FA6:  MOVWF  x71
03FA8:  MOVLB  0
03FAA:  RCALL  39BC
.................... 					UDPGet(&ResolvedInfo.IPAddr.v[2]); 
03FAC:  MOVLW  01
03FAE:  MOVLB  2
03FB0:  MOVWF  x72
03FB2:  MOVLW  F8
03FB4:  MOVWF  x71
03FB6:  MOVLB  0
03FB8:  RCALL  39BC
.................... 					UDPGet(&ResolvedInfo.IPAddr.v[3]); 
03FBA:  MOVLW  01
03FBC:  MOVLB  2
03FBE:  MOVWF  x72
03FC0:  MOVLW  F9
03FC2:  MOVWF  x71
03FC4:  MOVLB  0
03FC6:  RCALL  39BC
.................... 					goto DoneSearchingRecords; 
03FC8:  BRA    423E
.................... 				} 
03FCA:  BRA    3FEE
03FCC:  MOVLB  2
.................... 				else 
.................... 				{ 
.................... 					while(DNSAnswerHeader.ResponseLen.Val--) 
03FCE:  MOVFF  26F,03
03FD2:  MOVF   x6E,W
03FD4:  BTFSC  FD8.2
03FD6:  DECF   x6F,F
03FD8:  DECF   x6E,F
03FDA:  IORWF  03,W
03FDC:  BZ    3FEE
.................... 					{ 
.................... 						UDPGet(&i); 
03FDE:  MOVLW  02
03FE0:  MOVWF  x72
03FE2:  MOVLW  57
03FE4:  MOVWF  x71
03FE6:  MOVLB  0
03FE8:  RCALL  39BC
03FEA:  MOVLB  2
03FEC:  BRA    3FCE
.................... 					} 
.................... 				} 
03FEE:  MOVLB  2
03FF0:  BRA    3ED2
.................... 			} 
....................  
.................... 			// Remove all Authoritative Records 
.................... 			while(DNSHeader.AuthoritativeRecords.Val--) 
03FF2:  MOVFF  263,03
03FF6:  MOVF   x62,W
03FF8:  BTFSC  FD8.2
03FFA:  DECF   x63,F
03FFC:  DECF   x62,F
03FFE:  IORWF  03,W
04000:  BTFSC  FD8.2
04002:  BRA    4112
.................... 			{ 
.................... 				DNSDiscardName();					// Throw away response name 
04004:  MOVLB  0
04006:  RCALL  3B0C
.................... 				UDPGet(&DNSAnswerHeader.ResponseType.v[1]);		// Response type 
04008:  MOVLW  02
0400A:  MOVLB  2
0400C:  MOVWF  x72
0400E:  MOVLW  67
04010:  MOVWF  x71
04012:  MOVLB  0
04014:  RCALL  39BC
.................... 				UDPGet(&DNSAnswerHeader.ResponseType.v[0]); 
04016:  MOVLW  02
04018:  MOVLB  2
0401A:  MOVWF  x72
0401C:  MOVLW  66
0401E:  MOVWF  x71
04020:  MOVLB  0
04022:  RCALL  39BC
.................... 				UDPGet(&DNSAnswerHeader.ResponseClass.v[1]);	// Response class 
04024:  MOVLW  02
04026:  MOVLB  2
04028:  MOVWF  x72
0402A:  MOVLW  69
0402C:  MOVWF  x71
0402E:  MOVLB  0
04030:  RCALL  39BC
.................... 				UDPGet(&DNSAnswerHeader.ResponseClass.v[0]); 
04032:  MOVLW  02
04034:  MOVLB  2
04036:  MOVWF  x72
04038:  MOVLW  68
0403A:  MOVWF  x71
0403C:  MOVLB  0
0403E:  RCALL  39BC
.................... 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[3]);		// Time to live 
04040:  MOVLW  02
04042:  MOVLB  2
04044:  MOVWF  x72
04046:  MOVLW  6D
04048:  MOVWF  x71
0404A:  MOVLB  0
0404C:  RCALL  39BC
.................... 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[2]); 
0404E:  MOVLW  02
04050:  MOVLB  2
04052:  MOVWF  x72
04054:  MOVLW  6C
04056:  MOVWF  x71
04058:  MOVLB  0
0405A:  RCALL  39BC
.................... 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[1]); 
0405C:  MOVLW  02
0405E:  MOVLB  2
04060:  MOVWF  x72
04062:  MOVLW  6B
04064:  MOVWF  x71
04066:  MOVLB  0
04068:  RCALL  39BC
.................... 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[0]); 
0406A:  MOVLW  02
0406C:  MOVLB  2
0406E:  MOVWF  x72
04070:  MOVLW  6A
04072:  MOVWF  x71
04074:  MOVLB  0
04076:  RCALL  39BC
.................... 				UDPGet(&DNSAnswerHeader.ResponseLen.v[1]);		// Response length 
04078:  MOVLW  02
0407A:  MOVLB  2
0407C:  MOVWF  x72
0407E:  MOVLW  6F
04080:  MOVWF  x71
04082:  MOVLB  0
04084:  RCALL  39BC
.................... 				UDPGet(&DNSAnswerHeader.ResponseLen.v[0]); 
04086:  MOVLW  02
04088:  MOVLB  2
0408A:  MOVWF  x72
0408C:  MOVLW  6E
0408E:  MOVWF  x71
04090:  MOVLB  0
04092:  RCALL  39BC
....................  
.................... 				// Make sure that this is a 4 byte IP address, response type A or MX, class 1 
.................... 				// Check if this is Type A 
.................... 				if( DNSAnswerHeader.ResponseType.Val	== 0x0001u && 
.................... 					DNSAnswerHeader.ResponseClass.Val	== 0x0001u && // Internet class 
.................... 					DNSAnswerHeader.ResponseLen.Val		== 0x0004u) 
04094:  MOVLB  2
04096:  DECFSZ x66,W
04098:  BRA    40EE
0409A:  MOVF   x67,F
0409C:  BNZ   40EE
0409E:  DECFSZ x68,W
040A0:  BRA    40EE
040A2:  MOVF   x69,F
040A4:  BNZ   40EE
040A6:  MOVF   x6E,W
040A8:  SUBLW  04
040AA:  BNZ   40EE
040AC:  MOVF   x6F,F
040AE:  BNZ   40EE
.................... 				{ 
.................... 					DNSFlags.bits.AddressValid = TRUE; 
040B0:  BSF    x00.1
.................... 					UDPGet(&ResolvedInfo.IPAddr.v[0]); 
040B2:  MOVLW  01
040B4:  MOVWF  x72
040B6:  MOVLW  F6
040B8:  MOVWF  x71
040BA:  MOVLB  0
040BC:  RCALL  39BC
.................... 					UDPGet(&ResolvedInfo.IPAddr.v[1]); 
040BE:  MOVLW  01
040C0:  MOVLB  2
040C2:  MOVWF  x72
040C4:  MOVLW  F7
040C6:  MOVWF  x71
040C8:  MOVLB  0
040CA:  RCALL  39BC
.................... 					UDPGet(&ResolvedInfo.IPAddr.v[2]); 
040CC:  MOVLW  01
040CE:  MOVLB  2
040D0:  MOVWF  x72
040D2:  MOVLW  F8
040D4:  MOVWF  x71
040D6:  MOVLB  0
040D8:  RCALL  39BC
.................... 					UDPGet(&ResolvedInfo.IPAddr.v[3]); 
040DA:  MOVLW  01
040DC:  MOVLB  2
040DE:  MOVWF  x72
040E0:  MOVLW  F9
040E2:  MOVWF  x71
040E4:  MOVLB  0
040E6:  RCALL  39BC
.................... 					goto DoneSearchingRecords; 
040E8:  BRA    423E
.................... 				} 
040EA:  BRA    410E
040EC:  MOVLB  2
.................... 				else 
.................... 				{ 
.................... 					while(DNSAnswerHeader.ResponseLen.Val--) 
040EE:  MOVFF  26F,03
040F2:  MOVF   x6E,W
040F4:  BTFSC  FD8.2
040F6:  DECF   x6F,F
040F8:  DECF   x6E,F
040FA:  IORWF  03,W
040FC:  BZ    410E
.................... 					{ 
.................... 						UDPGet(&i); 
040FE:  MOVLW  02
04100:  MOVWF  x72
04102:  MOVLW  57
04104:  MOVWF  x71
04106:  MOVLB  0
04108:  RCALL  39BC
0410A:  MOVLB  2
0410C:  BRA    40EE
.................... 					} 
.................... 				} 
0410E:  MOVLB  2
04110:  BRA    3FF2
.................... 			} 
....................  
.................... 			// Remove all Additional Records 
.................... 			while(DNSHeader.AdditionalRecords.Val--) 
04112:  MOVFF  265,03
04116:  MOVF   x64,W
04118:  BTFSC  FD8.2
0411A:  DECF   x65,F
0411C:  DECF   x64,F
0411E:  IORWF  03,W
04120:  BTFSC  FD8.2
04122:  BRA    423C
.................... 			{ 
.................... 				DNSDiscardName();					// Throw away response name 
04124:  MOVLB  0
04126:  RCALL  3B0C
.................... 				UDPGet(&DNSAnswerHeader.ResponseType.v[1]);		// Response type 
04128:  MOVLW  02
0412A:  MOVLB  2
0412C:  MOVWF  x72
0412E:  MOVLW  67
04130:  MOVWF  x71
04132:  MOVLB  0
04134:  RCALL  39BC
.................... 				UDPGet(&DNSAnswerHeader.ResponseType.v[0]); 
04136:  MOVLW  02
04138:  MOVLB  2
0413A:  MOVWF  x72
0413C:  MOVLW  66
0413E:  MOVWF  x71
04140:  MOVLB  0
04142:  RCALL  39BC
.................... 				UDPGet(&DNSAnswerHeader.ResponseClass.v[1]);	// Response class 
04144:  MOVLW  02
04146:  MOVLB  2
04148:  MOVWF  x72
0414A:  MOVLW  69
0414C:  MOVWF  x71
0414E:  MOVLB  0
04150:  RCALL  39BC
.................... 				UDPGet(&DNSAnswerHeader.ResponseClass.v[0]); 
04152:  MOVLW  02
04154:  MOVLB  2
04156:  MOVWF  x72
04158:  MOVLW  68
0415A:  MOVWF  x71
0415C:  MOVLB  0
0415E:  RCALL  39BC
.................... 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[3]);		// Time to live 
04160:  MOVLW  02
04162:  MOVLB  2
04164:  MOVWF  x72
04166:  MOVLW  6D
04168:  MOVWF  x71
0416A:  MOVLB  0
0416C:  RCALL  39BC
.................... 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[2]); 
0416E:  MOVLW  02
04170:  MOVLB  2
04172:  MOVWF  x72
04174:  MOVLW  6C
04176:  MOVWF  x71
04178:  MOVLB  0
0417A:  RCALL  39BC
.................... 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[1]); 
0417C:  MOVLW  02
0417E:  MOVLB  2
04180:  MOVWF  x72
04182:  MOVLW  6B
04184:  MOVWF  x71
04186:  MOVLB  0
04188:  RCALL  39BC
.................... 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[0]); 
0418A:  MOVLW  02
0418C:  MOVLB  2
0418E:  MOVWF  x72
04190:  MOVLW  6A
04192:  MOVWF  x71
04194:  MOVLB  0
04196:  RCALL  39BC
.................... 				UDPGet(&DNSAnswerHeader.ResponseLen.v[1]);		// Response length 
04198:  MOVLW  02
0419A:  MOVLB  2
0419C:  MOVWF  x72
0419E:  MOVLW  6F
041A0:  MOVWF  x71
041A2:  MOVLB  0
041A4:  RCALL  39BC
.................... 				UDPGet(&DNSAnswerHeader.ResponseLen.v[0]); 
041A6:  MOVLW  02
041A8:  MOVLB  2
041AA:  MOVWF  x72
041AC:  MOVLW  6E
041AE:  MOVWF  x71
041B0:  MOVLB  0
041B2:  RCALL  39BC
....................  
.................... 				// Make sure that this is a 4 byte IP address, response type A or MX, class 1 
.................... 				// Check if this is Type A 
.................... 				if( DNSAnswerHeader.ResponseType.Val	== 0x0001u && 
.................... 					DNSAnswerHeader.ResponseClass.Val	== 0x0001u && // Internet class 
.................... 					DNSAnswerHeader.ResponseLen.Val		== 0x0004u) 
041B4:  MOVLB  2
041B6:  DECFSZ x66,W
041B8:  BRA    4216
041BA:  MOVF   x67,F
041BC:  BNZ   4216
041BE:  DECFSZ x68,W
041C0:  BRA    4216
041C2:  MOVF   x69,F
041C4:  BNZ   4216
041C6:  MOVF   x6E,W
041C8:  SUBLW  04
041CA:  BNZ   4216
041CC:  MOVF   x6F,F
041CE:  BNZ   4216
.................... 				{ 
.................... 					DNSFlags.bits.AddressValid = TRUE; 
041D0:  BSF    x00.1
.................... 					UDPGet(&ResolvedInfo.IPAddr.v[0]); 
041D2:  MOVLW  01
041D4:  MOVWF  x72
041D6:  MOVLW  F6
041D8:  MOVWF  x71
041DA:  MOVLB  0
041DC:  CALL   39BC
.................... 					UDPGet(&ResolvedInfo.IPAddr.v[1]); 
041E0:  MOVLW  01
041E2:  MOVLB  2
041E4:  MOVWF  x72
041E6:  MOVLW  F7
041E8:  MOVWF  x71
041EA:  MOVLB  0
041EC:  CALL   39BC
.................... 					UDPGet(&ResolvedInfo.IPAddr.v[2]); 
041F0:  MOVLW  01
041F2:  MOVLB  2
041F4:  MOVWF  x72
041F6:  MOVLW  F8
041F8:  MOVWF  x71
041FA:  MOVLB  0
041FC:  CALL   39BC
.................... 					UDPGet(&ResolvedInfo.IPAddr.v[3]); 
04200:  MOVLW  01
04202:  MOVLB  2
04204:  MOVWF  x72
04206:  MOVLW  F9
04208:  MOVWF  x71
0420A:  MOVLB  0
0420C:  CALL   39BC
.................... 					goto DoneSearchingRecords; 
04210:  BRA    423E
.................... 				} 
04212:  BRA    4238
04214:  MOVLB  2
.................... 				else 
.................... 				{ 
.................... 					while(DNSAnswerHeader.ResponseLen.Val--) 
04216:  MOVFF  26F,03
0421A:  MOVF   x6E,W
0421C:  BTFSC  FD8.2
0421E:  DECF   x6F,F
04220:  DECF   x6E,F
04222:  IORWF  03,W
04224:  BZ    4238
.................... 					{ 
.................... 						UDPGet(&i); 
04226:  MOVLW  02
04228:  MOVWF  x72
0422A:  MOVLW  57
0422C:  MOVWF  x71
0422E:  MOVLB  0
04230:  CALL   39BC
04234:  MOVLB  2
04236:  BRA    4216
.................... 					} 
.................... 				} 
04238:  MOVLB  2
0423A:  BRA    4112
0423C:  MOVLB  0
.................... 			} 
....................  
.................... DoneSearchingRecords: 
....................  
.................... 			UDPDiscard(); 
0423E:  RCALL  3A6E
.................... 			UDPClose(MyDNSSocket); 
04240:  MOVFF  1F0,270
04244:  CALL   0C0A
.................... 			MyDNSSocket = INVALID_UDP_SOCKET; 
04248:  MOVLB  1
0424A:  SETF   xF0
.................... 			smDNS = DNS_DONE; 
0424C:  MOVLW  07
0424E:  MOVLB  2
04250:  MOVWF  x01
04252:  MOVLB  0
.................... 			// No break, DNS_DONE is the correct step 
....................  
.................... 		case DNS_DONE: 
.................... 			// Return 0.0.0.0 if DNS resolution failed, otherwise return the  
.................... 			// resolved IP address 
.................... 			if(!DNSFlags.bits.AddressValid) 
04254:  MOVLB  2
04256:  BTFSC  x00.1
04258:  BRA    4266
.................... 				ResolvedInfo.IPAddr.Val = 0; 
0425A:  MOVLB  1
0425C:  CLRF   xF9
0425E:  CLRF   xF8
04260:  CLRF   xF7
04262:  CLRF   xF6
04264:  MOVLB  2
.................... 			HostIP->Val = ResolvedInfo.IPAddr.Val; 
04266:  MOVFF  255,FE9
0426A:  MOVFF  256,FEA
0426E:  MOVFF  1F6,FEF
04272:  MOVFF  1F7,FEC
04276:  MOVFF  1F8,FEC
0427A:  MOVFF  1F9,FEC
.................... 			return TRUE; 
0427E:  MOVLW  01
04280:  MOVWF  01
04282:  BRA    4316
04284:  MOVLB  0
....................  
.................... 		case DNS_FAIL: 
.................... 			// If 3 attempts or more, quit 
.................... 			if(vDNSAttemptCount >= 2u) 
04286:  MOVLB  2
04288:  MOVF   x09,W
0428A:  SUBLW  01
0428C:  BC    42AE
.................... 			{ 
.................... 				// Return an invalid IP address 0.0.0.0 if we can't finish ARP or DNS query step 
.................... 				HostIP->Val = 0x00000000; 
0428E:  MOVFF  255,FE9
04292:  MOVFF  256,FEA
04296:  MOVF   FEE,F
04298:  MOVF   FEE,F
0429A:  CLRF   FEC
0429C:  MOVF   FED,F
0429E:  CLRF   FEF
042A0:  MOVF   FED,F
042A2:  CLRF   FEF
042A4:  MOVF   FED,F
042A6:  CLRF   FEF
.................... 				return TRUE; 
042A8:  MOVLW  01
042AA:  MOVWF  01
042AC:  BRA    4316
.................... 			} 
.................... 			vDNSAttemptCount++; 
042AE:  INCF   x09,F
....................  
.................... 			// Swap primary and secondary DNS servers if there is a secondary DNS server programmed 
.................... 			if(AppConfig.SecondaryDNSServer.Val) 
042B0:  MOVF   39,F
042B2:  BNZ   42C0
042B4:  MOVF   3A,F
042B6:  BNZ   42C0
042B8:  MOVF   3B,F
042BA:  BNZ   42C0
042BC:  MOVF   3C,F
042BE:  BZ    430E
.................... 			{ 
.................... 				AppConfig.PrimaryDNSServer.Val ^= AppConfig.SecondaryDNSServer.Val; 
042C0:  MOVF   39,W
042C2:  XORWF  35,F
042C4:  MOVF   3A,W
042C6:  XORWF  36,F
042C8:  MOVF   3B,W
042CA:  XORWF  37,F
042CC:  MOVF   3C,W
042CE:  XORWF  38,F
.................... 				AppConfig.SecondaryDNSServer.Val ^= AppConfig.PrimaryDNSServer.Val; 
042D0:  MOVF   35,W
042D2:  XORWF  39,F
042D4:  MOVF   36,W
042D6:  XORWF  3A,F
042D8:  MOVF   37,W
042DA:  XORWF  3B,F
042DC:  MOVF   38,W
042DE:  XORWF  3C,F
.................... 				AppConfig.PrimaryDNSServer.Val ^= AppConfig.SecondaryDNSServer.Val; 
042E0:  MOVF   39,W
042E2:  XORWF  35,F
042E4:  MOVF   3A,W
042E6:  XORWF  36,F
042E8:  MOVF   3B,W
042EA:  XORWF  37,F
042EC:  MOVF   3C,W
042EE:  XORWF  38,F
....................  
.................... 				// Start another ARP resolution for the secondary server (now primary) 
.................... 				vARPAttemptCount = 0; 
042F0:  CLRF   x08
.................... 				if(MyDNSSocket != INVALID_UDP_SOCKET) 
042F2:  MOVLB  1
042F4:  INCFSZ xF0,W
042F6:  BRA    42FA
042F8:  BRA    4308
.................... 				{ 
.................... 					UDPClose(MyDNSSocket); 
042FA:  MOVFF  1F0,270
042FE:  MOVLB  0
04300:  CALL   0C0A
.................... 					MyDNSSocket = INVALID_UDP_SOCKET; 
04304:  MOVLB  1
04306:  SETF   xF0
.................... 				} 
.................... 				smDNS = DNS_ARP_START_RESOLVE; 
04308:  MOVLW  01
0430A:  MOVLB  2
0430C:  MOVWF  x01
.................... 			} 
....................  
.................... 			break; 
0430E:  BRA    4312
04310:  MOVLB  2
....................  
.................... 	} 
.................... 	 
.................... 	return FALSE; 
04312:  MOVLW  00
04314:  MOVWF  01
04316:  MOVLB  0
04318:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	static void DNSPutString(BYTE* String) 
....................  
....................   Summary: 
.................... 	Writes a string to the DNS socket. 
.................... 	 
....................   Description: 
.................... 	This function writes a string to the DNS socket, ensuring that it is 
.................... 	properly formatted. 
....................  
....................   Precondition: 
.................... 	UDP socket is obtained and ready for writing. 
....................  
....................   Parameters: 
.................... 	String - the string to write to the UDP socket. 
....................  
....................   Returns: 
....................   	None 
....................   ***************************************************************************/ 
.................... static void DNSPutString(BYTE* String) 
.................... { 
.................... 	BYTE *RightPtr; 
.................... 	BYTE i; 
.................... 	BYTE Len; 
....................  
.................... 	RightPtr = String; 
*
03576:  MOVFF  271,273
0357A:  MOVFF  270,272
....................  
.................... 	while(1) 
.................... 	{ 
.................... 		do 
.................... 		{ 
.................... 			i = *RightPtr++; 
0357E:  MOVLB  2
03580:  MOVFF  273,03
03584:  MOVF   x72,W
03586:  INCF   x72,F
03588:  BTFSC  FD8.2
0358A:  INCF   x73,F
0358C:  MOVWF  FE9
0358E:  MOVFF  03,FEA
03592:  MOVFF  FEF,274
.................... 		} while((i != 0x00u) && (i != '.') && (i != '/') && (i != ',') && (i != '>')); 
03596:  MOVF   x74,F
03598:  BZ    35B2
0359A:  MOVF   x74,W
0359C:  SUBLW  2E
0359E:  BZ    35B2
035A0:  MOVF   x74,W
035A2:  SUBLW  2F
035A4:  BZ    35B2
035A6:  MOVF   x74,W
035A8:  SUBLW  2C
035AA:  BZ    35B2
035AC:  MOVF   x74,W
035AE:  SUBLW  3E
035B0:  BNZ   3580
.................... 	 
.................... 		// Put the length and data 
.................... 		// Also, skip over the '.' in the input string 
.................... 		Len = (BYTE)(RightPtr-String-1); 
035B2:  MOVF   x70,W
035B4:  SUBWF  x72,W
035B6:  MOVWF  x76
035B8:  MOVF   x71,W
035BA:  SUBWFB x73,W
035BC:  MOVWF  x77
035BE:  MOVLW  01
035C0:  SUBWF  x76,W
035C2:  MOVWF  00
035C4:  MOVLW  00
035C6:  SUBWFB x77,W
035C8:  MOVFF  00,275
.................... 		UDPPut(Len); 
035CC:  MOVFF  275,276
035D0:  MOVLB  0
035D2:  RCALL  349C
.................... 		String += UDPPutArray(String, Len) + 1; 
035D4:  MOVFF  271,277
035D8:  MOVFF  270,276
035DC:  MOVLB  2
035DE:  CLRF   x79
035E0:  MOVFF  275,278
035E4:  MOVLB  0
035E6:  BRA    34F2
035E8:  MOVFF  01,276
035EC:  MOVLW  01
035EE:  MOVLB  2
035F0:  ADDWF  01,W
035F2:  MOVWF  01
035F4:  MOVLW  00
035F6:  ADDWFC 02,W
035F8:  MOVWF  03
035FA:  MOVF   01,W
035FC:  ADDWF  x70,F
035FE:  MOVF   03,W
03600:  ADDWFC x71,F
....................  
.................... 		if(i == 0x00u || i == '/' || i == ',' || i == '>') 
03602:  MOVF   x74,F
03604:  BZ    3618
03606:  MOVF   x74,W
03608:  SUBLW  2F
0360A:  BZ    3618
0360C:  MOVF   x74,W
0360E:  SUBLW  2C
03610:  BZ    3618
03612:  MOVF   x74,W
03614:  SUBLW  3E
03616:  BNZ   361A
.................... 			break; 
03618:  BRA    361C
0361A:  BRA    3580
.................... 	} 
.................... 	 
.................... 	// Put the string null terminator character (zero length label) 
.................... 	UDPPut(0x00); 
0361C:  CLRF   x76
0361E:  MOVLB  0
03620:  RCALL  349C
03622:  GOTO   3D2E (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	static void DNSPutROMString(ROM BYTE* String) 
....................  
....................   Summary: 
.................... 	Writes a ROM string to the DNS socket. 
.................... 	 
....................   Description: 
.................... 	This function writes a string to the DNS socket, ensuring that it is 
.................... 	properly formatted. 
....................  
....................   Precondition: 
.................... 	UDP socket is obtained and ready for writing. 
....................  
....................   Parameters: 
.................... 	String - the string to write to the UDP socket. 
....................  
....................   Returns: 
....................   	None 
....................    
....................   Remarks: 
....................   	This function is aliased to DNSPutString on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... static void DNSPutROMString(ROM BYTE* String) 
.................... { 
.................... 	ROM BYTE *RightPtr; 
.................... 	BYTE i; 
.................... 	BYTE Len; 
....................  
.................... 	RightPtr = String; 
*
0370A:  MOVFF  271,273
0370E:  MOVFF  270,272
....................  
.................... 	while(1) 
.................... 	{ 
.................... 		do 
.................... 		{ 
.................... 			i = *RightPtr++; 
03712:  MOVLB  2
03714:  MOVFF  273,03
03718:  MOVF   x72,W
0371A:  INCF   x72,F
0371C:  BTFSC  FD8.2
0371E:  INCF   x73,F
03720:  MOVWF  FF6
03722:  MOVFF  03,FF7
03726:  CLRF   FF8
03728:  MOVLW  02
0372A:  MOVWF  FEA
0372C:  MOVLW  74
0372E:  MOVWF  FE9
03730:  CLRF   x82
03732:  MOVLW  01
03734:  MOVWF  x81
03736:  MOVLB  0
03738:  CALL   2A70
.................... 		} while((i != 0x00u) && (i != '.') && (i != '/') && (i != ',') && (i != '>')); 
0373C:  MOVLB  2
0373E:  MOVF   x74,F
03740:  BZ    375A
03742:  MOVF   x74,W
03744:  SUBLW  2E
03746:  BZ    375A
03748:  MOVF   x74,W
0374A:  SUBLW  2F
0374C:  BZ    375A
0374E:  MOVF   x74,W
03750:  SUBLW  2C
03752:  BZ    375A
03754:  MOVF   x74,W
03756:  SUBLW  3E
03758:  BNZ   3714
.................... 	 
.................... 		// Put the length and data 
.................... 		// Also, skip over the '.' in the input string 
.................... 		Len = (BYTE)(RightPtr-String-1); 
0375A:  MOVF   x70,W
0375C:  SUBWF  x72,W
0375E:  MOVWF  00
03760:  MOVF   x71,W
03762:  SUBWFB x73,W
03764:  MOVWF  03
03766:  MOVFF  00,276
0376A:  MOVLW  01
0376C:  SUBWF  00,W
0376E:  MOVWF  00
03770:  MOVLW  00
03772:  SUBWFB 03,W
03774:  MOVFF  00,275
.................... 		UDPPut(Len); 
03778:  MOVFF  275,276
0377C:  MOVLB  0
0377E:  RCALL  349C
.................... 		String += UDPPutROMArray(String, Len) + 1; 
03780:  MOVFF  271,277
03784:  MOVFF  270,276
03788:  MOVLB  2
0378A:  CLRF   x79
0378C:  MOVFF  275,278
03790:  MOVLB  0
03792:  BRA    3688
03794:  MOVFF  01,276
03798:  MOVLW  01
0379A:  MOVLB  2
0379C:  ADDWF  01,W
0379E:  MOVWF  01
037A0:  MOVLW  00
037A2:  ADDWFC 02,W
037A4:  MOVWF  03
037A6:  MOVF   01,W
037A8:  ADDWF  x70,W
037AA:  MOVWF  01
037AC:  MOVF   x71,W
037AE:  ADDWFC 03,F
037B0:  MOVFF  01,270
037B4:  MOVFF  03,271
....................  
.................... 		if(i == 0x00u || i == '/' || i == ',' || i == '>') 
037B8:  MOVF   x74,F
037BA:  BZ    37CE
037BC:  MOVF   x74,W
037BE:  SUBLW  2F
037C0:  BZ    37CE
037C2:  MOVF   x74,W
037C4:  SUBLW  2C
037C6:  BZ    37CE
037C8:  MOVF   x74,W
037CA:  SUBLW  3E
037CC:  BNZ   37D0
.................... 			break; 
037CE:  BRA    37D2
037D0:  BRA    3714
.................... 	} 
.................... 	 
.................... 	// Put the string terminator character (zero length label) 
.................... 	UDPPut(0x00); 
037D2:  CLRF   x76
037D4:  MOVLB  0
037D6:  RCALL  349C
037D8:  GOTO   3D2E (RETURN)
.................... } 
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	static void DNSDiscardName(void) 
....................  
....................   Summary: 
.................... 	Reads a name string or string pointer from the DNS socket and discards it. 
.................... 	 
....................   Description: 
.................... 	This function reads a name string from the DNS socket.  Each string  
.................... 	consists of a series of labels.  Each label consists of a length prefix  
.................... 	byte, followed by the label bytes.  At the end of the string, a zero length  
.................... 	label is found as termination.  If name compression is used, this function  
.................... 	will automatically detect the pointer and discard it. 
....................  
....................   Precondition: 
.................... 	UDP socket is obtained and ready for reading a DNS name 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	None 
....................   ***************************************************************************/ 
.................... static void DNSDiscardName(void) 
.................... { 
.................... 	BYTE i; 
....................  
.................... 	while(1) 
.................... 	{ 
.................... 		// Get first byte which will tell us if this is a 16-bit pointer or the  
.................... 		// length of the first of a series of labels 
.................... 		if(!UDPGet(&i)) 
*
03B0C:  MOVLW  02
03B0E:  MOVLB  2
03B10:  MOVWF  x72
03B12:  MOVLW  70
03B14:  MOVWF  x71
03B16:  MOVLB  0
03B18:  RCALL  39BC
03B1A:  MOVF   01,F
03B1C:  BNZ   3B20
.................... 			return; 
03B1E:  BRA    3B54
.................... 		 
.................... 		// Check if this is a pointer, if so, get the reminaing 8 bits and return 
.................... 		if((i & 0xC0u) == 0xC0u) 
03B20:  MOVLB  2
03B22:  MOVF   x70,W
03B24:  ANDLW  C0
03B26:  SUBLW  C0
03B28:  BNZ   3B3A
.................... 		{ 
.................... 			UDPGet(&i); 
03B2A:  MOVLW  02
03B2C:  MOVWF  x72
03B2E:  MOVLW  70
03B30:  MOVWF  x71
03B32:  MOVLB  0
03B34:  RCALL  39BC
.................... 			return; 
03B36:  BRA    3B54
03B38:  MOVLB  2
.................... 		} 
....................  
.................... 		// Exit once we reach a zero length label 
.................... 		if(i == 0u)					 
03B3A:  MOVF   x70,F
03B3C:  BNZ   3B44
.................... 			return; 
03B3E:  MOVLB  0
03B40:  BRA    3B54
03B42:  MOVLB  2
....................  
.................... 		// Discard complete label 
.................... 		UDPGetArray(NULL, i);		 
03B44:  CLRF   x72
03B46:  CLRF   x71
03B48:  CLRF   x74
03B4A:  MOVFF  270,273
03B4E:  MOVLB  0
03B50:  BRA    3A86
03B52:  BRA    3B0C
.................... 	} 
03B54:  RETURN 0
.................... } 
....................  
....................  
.................... #endif	//#if defined(STACK_USE_DNS) 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS) 
....................    #include "MPFS.c" 
.................... #endif 
....................  
.................... #if (defined(STACK_USE_HTTP2) || defined(STACK_USE_HTTP2_SERVER)) && !defined(__HTTP2_C) 
....................     #include "HTTP2.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_HTTP) || defined(STACK_USE_HTTP_SERVER) 
....................     #include "HTTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP1_SERVER) 
....................    #include "ccs_HTTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    #include "ccs_HTTP2.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP) && !defined(__SMTP_C) 
....................    #include "smtp.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SMTP) 
....................    #include "ccs_SMTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
....................    #include "SNTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    #include "ccs_SNTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TWITTER) 
....................    #include "ccs_twitter.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
....................    #include "TFTPc.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_TFTP_SERVER) 
....................    #include "ccs_TFTPs.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) && !defined(__ANNOUNCE_C) 
....................    #include "Announce.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
....................    #include "MPFS2.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_GRATUITOUS_ARP) 
....................    #include "ccs_gratarp.c" 
.................... #endif 
....................  
.................... #if defined(__18CXX) 
....................    #include "p18cxxx.c" 
.................... // CCS PCH C Compiler to Microchip C18 Compiler compatability layer. 
....................  
.................... #ifndef __P18CXXXX_C__ 
.................... #define __P18CXXXX_C__ 
....................  
.................... #include "p18cxxx.h" 
.................... // CCS PCH C Compiler to Microchip C18 Compiler compatability layer. 
....................  
.................... #ifndef __P18CXXXX_H__ 
.................... #define __P18CXXXX_H__ 
....................  
.................... #ifndef __18CXX 
.................... #define __18CXX 
.................... #endif 
....................  
.................... //#zero_local_ram 
.................... #zero_ram 
....................  
....................  
.................... #device PASS_STRINGS=IN_RAM 
.................... #device CONST=READ_ONLY 
....................  
.................... #case 
.................... #type signed 
.................... #type short=16 int=16 long=32 
....................  
.................... #define _asm #asm 
.................... #define _endasm #endasm 
....................  
.................... /* usualy 
.................... #define GetSystemClock()      getenv("CLOCK") 
.................... #define GetInstructionClock()   (GetSystemClock()/4) 
.................... #define GetPeripheralClock()   (unsigned int32)GetInstructionClock() 
.................... */ 
....................  
.................... #if getenv("DEVICE") == "PIC18F97J60" 
....................  #define __18F97J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F96J65" 
....................  #define __18F96J65) 
.................... #elif getenv("DEVICE") == "PIC18F96J60" 
....................  #define __18F96J60 
.................... #elif getenv("DEVICE") == "PIC18F87J60" 
....................  #define __18F87J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J60" 
....................  #define __18F86J60 
.................... #elif getenv("DEVICE") == "PIC18F67J60" 
....................  #define __18F67J60 
....................  #include "PIC18F67J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F66J65" 
....................  #define __18F66J65 
.................... #elif getenv("DEVICE") == "PIC18F66J60" 
....................  #define __18F66J60 
.................... #elif getenv("DEVICE") == "PIC18F67K22" 
....................  #define __18F67K22 
....................  #include "PIC18F67K22_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F4620" 
....................  #define __18F4620 
....................  #include "PIC18F4620_registers.h" 
.................... #else 
....................    #error Do this for your chip 
.................... #endif 
....................  
.................... #if defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) 
....................    #reserve 0xE80:0xEFF 
....................    #reserve 0xF00:0xFFF 
.................... #endif 
....................  
.................... #if defined(TRUE) 
....................    #undef TRUE 
.................... #endif 
....................  
.................... #if defined(FALSE) 
....................    #undef FALSE 
.................... #endif 
....................  
.................... #if defined(BYTE) 
....................    #undef BYTE 
.................... #endif 
....................  
....................       #define Reset()            reset_cpu() 
....................         #define far 
....................         #define ClrWdt()         restart_wdt() 
....................       #define Nop()            delay_cycles(1)       
....................  
.................... #define __CCS__ 
....................  
.................... //signed int8 memcmppgm2ram(void * s1, rom char *s2, unsigned int8 n); 
.................... signed int8 strcmppgm2ram(char *s1, __ADDRESS__ s2); 
.................... char *strchrpgm(__ADDRESS__ s, unsigned int8 c); 
.................... char *strstrrampgm(char *s1, __ADDRESS__ s2); 
.................... unsigned int8 strlenpgm(__ADDRESS__ s); 
.................... void memcpypgm2ram(unsigned int8 *d, __ADDRESS__ s, unsigned int16 n); 
.................... //char* strupr(char *s);   now in string.h 
.................... void strcpypgm2ram(char *d, __ADDRESS__ s); 
.................... #endif 
....................  
.................... /* STRING.H already has this exact function 
.................... signed int8 memcmppgm2ram(void * s1, rom char *s2, unsigned int8 n) 
.................... { 
....................   #if 1 
....................    char *su1; 
....................    rom char *su2; 
....................     
....................    for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
....................    { 
....................       if(*su1!=*su2) 
....................          return ((*su1<*su2)?-1:+1); 
....................    } 
....................    return 0; 
....................   #else 
....................    #error///warning memcmppgm2ram disabled 
....................   #endif 
.................... }*/ 
....................  
.................... #if 0 //this is in string.h and helpers.c 
.................... char* strupr(char *s) 
.................... { 
....................    char *p; 
....................     
....................    p=s; 
....................     
....................    while(*p) 
....................    { 
....................       *p = toupper(*p++); 
....................    } 
....................    return(s); 
.................... } 
.................... #endif 
....................  
.................... void memcpypgm2ram(unsigned int8 *d, __ADDRESS__ s, unsigned int16 n) 
.................... { 
....................    //printf("ROM_0x%LX-to-0x%LX ", d, s); 
....................   #if (getenv("PROGRAM_MEMORY") > 0x10000) 
....................    #warning temporary ccs bug fix 
....................    s |= 0x10000; 
....................   #endif 
....................    read_program_memory(s, d, n); 
.................... } 
....................  
.................... void strcpypgm2ram(char *d, __ADDRESS__ s) 
.................... { 
....................    char c; 
....................    do 
....................    { 
....................       memcpypgm2ram(&c, s++, 1); 
....................       *d++ = c; 
....................    } while(c); 
.................... } 
....................  
.................... #if 0 
.................... signed int8 strcmppgm2ram(char *s1, rom char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... char *strchrpgm(rom char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
....................  
.................... char *strstrrampgm(char *s1, rom char *s2) 
.................... { 
....................    char *s; 
....................    rom char *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... unsigned int8 strlenpgm(rom char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
.................... #endif   //if 0 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... int1 DHCPBoundOrDisabled(void) 
.................... { 
....................   #if defined(STACK_USE_DHCP_CLIENT) 
....................    return(!DHCPIsEnabled(0) || DHCPIsBound(0)); 
....................   #else 
....................    return(TRUE); 
....................   #endif 
.................... } 
....................  
.................... int1 IsLinked(void) 
.................... { 
....................   #if STACK_USE_WIFI && defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    if (AppConfig.networkType == WF_ADHOC) 
....................    { 
....................       return(MACIsLinked() && g_WifiAdhocIsConn); 
....................    } 
....................   #endif 
....................     
....................    return(MACIsLinked() && DHCPBoundOrDisabled()); 
.................... } 
....................  
.................... #if defined(STACK_USE_MPFS) 
.................... MPFS _MpfsEofLoc; 
....................  
.................... unsigned int16 MPFSGetBytes(unsigned int8 *pDest, unsigned int16 n) 
.................... { 
....................    unsigned int16 ret = 0; 
....................    unsigned int16 i; 
....................    unsigned int8 *p; 
....................    int1 escaped = FALSE; 
....................     
....................    p = pDest; 
....................     
....................    debug_mpfs2(debug_putc, "\r\nMPFSGetBytes() START %LX ", _currentHandle); 
....................     
....................    while(n) 
....................    { 
....................       HTTP_INTERRUPT_TASKS(); 
....................        
....................       debug_mpfs2(debug_putc, "n=%LX ", n); 
....................        
....................       _MpfsEofLoc = _currentHandle; 
....................      #if defined(MPFS_USE_SPI_FLASH) 
....................       SPIFlashReadArray(_currentHandle, pDest, n); 
....................      #else 
....................       memcpypgm2ram(pDest, _currentHandle, n); //__ccs__ change because MPFS isn't rom pointer 
....................      #endif 
....................  
....................       _currentHandle += n; 
....................  
....................       //debug_array("START", pDest, n); 
....................  
....................       i = n; 
....................       n = 0; 
....................        
....................       while(i--) 
....................       { 
....................          _MpfsEofLoc++; 
....................          if (escaped || (*pDest == MPFS_DLE)) 
....................          { 
....................             if (!escaped) 
....................             { 
....................                n++; 
....................             } 
....................              
....................             if (escaped || i) 
....................             { 
....................                if (!escaped) 
....................                { 
....................                   debug_mpfs2(debug_putc, "! "); 
....................                   memmove(pDest, pDest+1, i); 
....................                   _MpfsEofLoc++; 
....................                   i--; 
....................                } 
....................                ret++; 
....................                escaped = FALSE; 
....................             } 
....................             else 
....................             { 
....................                escaped = TRUE; 
....................                pDest--; //counter pDest++ below, since we need to start saving new bytes here 
....................             } 
....................          } 
....................          else if(*pDest == MPFS_ETX) 
....................          { 
....................             _MpfsEofLoc--; 
....................             debug_mpfs2(debug_putc, "EOF %LX ", _MpfsEofLoc); 
....................             _currentHandle = MPFS_INVALID; 
....................             n = 0; 
....................             break; 
....................          } 
....................          else 
....................          { 
....................             ret++; 
....................          } 
....................          pDest++; 
....................       } 
....................    } 
....................    //debug_array("STOP", p, ret);    
....................  
....................    return(ret); 
.................... } 
.................... #ENDIF 
....................  
.................... #if STACK_USE_WIFI 
....................  
.................... //extern int1 g_WifiTempDisFlag; 
.................... //extern TICK g_WifiTempDisTick; 
.................... //extern int1 g_wifiConnected; 
.................... extern int1 g_WifiConnectFail; 
....................  
.................... // see StackTsk2.h for documentation 
.................... #if 0 
.................... int1 MyWFisConnected(void) 
.................... { 
....................    int1 ret = FALSE; 
....................  
....................   #if defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    if (AppConfig.networkType == WF_ADHOC) 
....................    { 
....................       if ( 
....................             g_WifiAdhocIsConn && 
....................             ((TickGet() - g_WifiAdhocTickConn) > WIFI_ADHOC_CONNECTION_TIMER) 
....................          ) 
....................       { 
....................          g_WifiAdhocIsConn = FALSE; 
....................       } 
....................       return(g_WifiAdhocIsConn); 
....................    } 
....................   #endif 
....................  
....................    if (g_wifiConnected) 
....................    { 
....................       ret = TRUE; 
....................    } 
....................    else if (!g_WifiConnectFail) 
....................    { 
....................       if (g_WifiTempDisFlag) 
....................       { 
....................          if ((TickGet() - g_WifiTempDisTick) < ((TICK)5*TICKS_PER_SECOND)) 
....................          { 
....................             ret = TRUE; 
....................          } 
....................          else 
....................          { 
....................             g_WifiTempDisFlag = FALSE; 
....................          } 
....................       } 
....................    } 
....................  
....................    return(ret); 
.................... } 
.................... #endif 
....................  
.................... unsigned int8 g_connectionProfileID = 0xFF;  //used to communicate with the connection profile on the WiFi module 
....................  
.................... unsigned int8 WIFI_channelList[16]; 
.................... unsigned int8 WIFI_numChannelsInList; 
.................... unsigned int8 WIFI_region; 
....................  
.................... // this option will force the connection profile to be closed and reopened 
.................... // if we do not get a connection within this time.  might fix an errata that 
.................... // says WPA/WPA2 will lockup instead of sending an event. 
.................... #define WIFI_FORCE_RECONNECT_TICK   (TICK)(TICKS_PER_SECOND * 120)  //might be too short for WPA/WPA2 phrase 
....................  
.................... #ifndef wifi_debug 
.................... #define wifi_debug(a,b,c,d,e,f,g,h,i) 
.................... #endif 
....................  
.................... // this was based off of WF_Connect() in Microchip's demo application. 
.................... void WIFIConnectTask(void) 
.................... { 
....................    #if !defined(APP_GENERIC_SCRATCH) 
....................       char WIFIConnectTask_Scratch[6]; 
....................    #else 
....................       #define WIFIConnectTask_Scratch  APP_GENERIC_SCRATCH 
....................    #endif 
....................     
....................   #if defined(WIFI_FORCE_RECONNECT_TICK) 
....................    static TICK fTick; 
....................   #endif 
....................  
....................   #if defined(LED_CONNECTION_ON) || defined(LED_ACTIVITY_ON) 
....................    static TICK l; 
....................    // if you have both LED_CONNECTION_ON and LED_ACTIVITY_ON (2 WIFI LEDs),  
....................    //    then one LED is used for flickering on traffic and another is used to  
....................    //    show connection state. 
....................    // if you only have LED_CONNECTION_ON (only 1 WIFI LED), then WIFI  
....................    //    connection status and wifi traffic flickering is shared on the same 
....................    //    LED. 
....................    // this routine below handles the traffic led flickering.  the LED was 
....................    //    turned off in the TCP/IP stack, this routine turns it back on every 
....................    //    200ms. 
....................    if ((TickGet() - l) >= TICKS_PER_SECOND/5) 
....................    { 
....................       l = TickGet(); 
....................        
....................      #if defined(LED_ACTIVITY_ON) 
....................       LED_ACTIVITY_OFF(); 
....................      #else 
....................       if (IsLinked()) 
....................       { 
....................          LED_CONNECTION_ON(); 
....................       } 
....................       else 
....................       { 
....................          LED_CONNECTION_OFF(); 
....................       } 
....................      #endif 
....................    } 
....................   #endif 
....................  
....................   #if defined(LED_CONNECTION_ON) && defined(LED_ACTIVITY_ON) 
....................    // handle the connection status LED if you have 2 WIFI LEDs. 
....................    if (IsLinked()) 
....................    { 
....................       LED_CONNECTION_ON(); 
....................    } 
....................    else 
....................    { 
....................       LED_CONNECTION_OFF(); 
....................    } 
....................   #endif 
....................  
....................   #if STACK_USE_WIFI && defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    if (AppConfig.networkType == WF_ADHOC) 
....................    { 
....................       if ( 
....................             g_WifiAdhocIsConn && 
....................             ((TickGet() - g_WifiAdhocTickConn) > WIFI_ADHOC_CONNECTION_TIMER) 
....................          ) 
....................       { 
....................          g_WifiAdhocIsConn = FALSE; 
....................       } 
....................    } 
....................   #endif 
....................  
....................   #if defined(WIFI_FORCE_RECONNECT_TICK) 
....................    if ( 
....................          (AppConfig.networkType != WF_ADHOC) && 
....................          (g_connectionProfileID != 0xFF) 
....................       ) 
....................    { 
....................       if (IsLinked()) 
....................       { 
....................          fTick = TickGet(); 
....................       } 
....................       else if ((TickGet() - fTick) > WIFI_FORCE_RECONNECT_TICK) 
....................       { 
....................         #if defined(STACK_IS_CCS_EXAMPLE) 
....................          fprintf(STREAM_UI, "\r\nLong WIFI connection timeout, reseting module"); 
....................         #endif 
....................          delay_ms(200); 
....................          MACInit(); 
....................          delay_ms(200); 
....................          g_connectionProfileID = 0xFF; 
....................         #if defined(WIFI_EXTRA_LINK_STATUS) 
....................          g_LastWifiEvent = 20; 
....................         #endif 
....................       } 
....................    } 
....................   #endif 
....................  
....................    if (g_connectionProfileID == 0xFF) 
....................    { 
....................       g_WifiConnectFail = FALSE; 
....................        
....................       WF_CPCreate(&g_connectionProfileID); 
....................        
....................       if (g_connectionProfileID != 0xFF) 
....................       { 
....................         #if defined(WIFI_GET_VERSION_INFO) 
....................          WF_GetDeviceInfo(&WIFI_GET_VERSION_INFO); 
....................         #endif 
....................  
....................          g_WifiConnectFail = TRUE; 
....................  
....................          WF_CPSetSsid(g_connectionProfileID,  
....................                     AppConfig.MySSID,  
....................                     AppConfig.SsidLength); 
....................           
....................          memset(WIFIConnectTask_Scratch, 0xFF, 6); 
....................          WF_CPSetBssid(g_connectionProfileID, WIFIConnectTask_Scratch); 
....................  
....................          WF_CPSetNetworkType(g_connectionProfileID, AppConfig.networkType); 
....................           
....................          if(AppConfig.networkType == WF_ADHOC) 
....................          { 
....................             WF_CPSetAdHocBehavior(g_connectionProfileID, AppConfig.adhocBehavior); 
....................          } 
....................  
....................          WF_CASetScanType(MY_DEFAULT_SCAN_TYPE);   // was WF_ACTIVE_SCAN 
....................  
....................          WF_CASetChannelList(WIFI_channelList, WIFI_numChannelsInList); //was AppConfig.channelList, AppConfig.numChannelsInList 
....................  
....................          WF_SetRegionalDomain(WIFI_region);  //was AppConfig.region 
....................           
....................          WF_CASetListRetryCount(MY_DEFAULT_LIST_RETRY_COUNT);  // was WF_RETRY_FOREVER 
....................           
....................          WF_CASetEventNotificationAction(MY_DEFAULT_EVENT_NOTIFICATION_LIST); // was WF_NOTIFY_ALL_EVENTS 
....................           
....................          WF_CASetBeaconTimeout(MY_DEFAULT_BEACON_TIMEOUT); 
....................  
....................          WF_CASetBeaconTimeoutAction(WF_ATTEMPT_TO_RECONNECT); 
....................           
....................          WF_CASetDeauthAction(WF_ATTEMPT_TO_RECONNECT); 
....................  
....................        #if defined(DERIVE_KEY_FROM_PASSPHRASE_IN_HOST) 
....................            if (AppConfig.SecurityMode == WF_SECURITY_WPA_WITH_PASS_PHRASE 
....................                || AppConfig.SecurityMode == WF_SECURITY_WPA2_WITH_PASS_PHRASE 
....................                || AppConfig.SecurityMode == WF_SECURITY_WPA_AUTO_WITH_PASS_PHRASE) { 
....................                WF_ConvPassphrase2Key(AppConfig.SecurityKeyLength, AppConfig.SecurityKey, 
....................                    AppConfig.SsidLength, AppConfig.MySSID); 
....................                AppConfig.SecurityMode--; 
....................                AppConfig.SecurityKeyLength = 32; 
....................            } 
....................        #if defined (MRF24WG) 
....................            else if (AppConfig.SecurityMode == WF_SECURITY_WPS_PUSH_BUTTON 
....................                        || AppConfig.SecurityMode == WF_SECURITY_WPS_PIN) { 
....................                WF_YieldPassphrase2Host();     
....................            } 
....................        #endif    /* defined (MRF24WG) */ 
....................        #endif    /* defined(DERIVE_KEY_FROM_PASSPHRASE_IN_HOST) */ 
....................  
....................          WF_CPSetSecurity(g_connectionProfileID, 
....................                         AppConfig.SecurityMode, 
....................                         0, //AppConfig.WepKeyIndex, //AppConfig.WepKeyIndex,   /* only used if WEP enabled */ 
....................                         AppConfig.SecurityKey, 
....................                         AppConfig.SecurityKeyLength);       
....................   
....................       #if (MY_DEFAULT_WIFI_SECURITY_WEP_KEYTYPE!=WF_SECURITY_WEP_SHAREDKEY) 
....................         #if !defined(MRF24WG) 
....................          if (gRFModuleVer1209orLater) 
....................         #endif 
....................          { 
....................             // If WEP security is used, set WEP Key Type.  The default WEP Key Type is Shared Key. 
....................             if ((AppConfig.SecurityMode == WF_SECURITY_WEP_40) || (AppConfig.SecurityMode == WF_SECURITY_WEP_104)) 
....................             { 
....................                 WF_CPSetWepKeyType(g_connectionProfileID, MY_DEFAULT_WIFI_SECURITY_WEP_KEYTYPE); 
....................             } 
....................          } 
....................         #endif 
....................  
....................        #ifndef WF_FORCE_NO_PS_POLL 
....................        #if MY_DEFAULT_PS_POLL == WF_ENABLED 
....................            WF_PsPollEnable(TRUE); 
....................        #if !defined(MRF24WG)  
....................            if (gRFModuleVer1209orLater) 
....................                WFEnableDeferredPowerSave(); 
....................        #endif    // !defined(MRF24WG) 
....................        #else     // MY_DEFAULT_PS_POLL != WF_ENABLED 
....................            WF_PsPollDisable(); 
....................        #endif    // MY_DEFAULT_PS_POLL == WF_ENABLED 
....................     
....................        #ifdef WF_AGGRESSIVE_PS 
....................        #if !defined(MRF24WG) 
....................            if (gRFModuleVer1209orLater) 
....................                WFEnableAggressivePowerSave(); 
....................        #endif 
....................        #endif 
....................        #endif 
....................       } 
....................    } 
....................  
....................    if(g_WifiConnectFail) 
....................    { 
....................       wifi_debug(debug_putc, "Start WiFi Connect PROF=%u\r\n", g_connectionProfileID); 
....................       
....................      #if defined(STACK_IS_CCS_EXAMPLE) 
....................       fprintf(STREAM_UI, "\r\nStart WiFi Connect"); 
....................      #endif 
....................       
....................      #if defined(WIFI_FORCE_RECONNECT_TICK) 
....................       fTick = TickGet(); 
....................      #endif 
....................  
....................      #if defined(WF_FORCE_NO_PS_POLL) 
....................       WF_CCS_PsPollDisable(); 
....................      #endif 
....................     
....................       WF_CMConnect(g_connectionProfileID); 
....................    } 
....................     
....................    g_WifiConnectFail = 0; 
.................... } 
....................  
.................... void LinkTraffic(int1 isTx) 
.................... { 
....................   #if defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    if (!isTx && (AppConfig.networkType == WF_ADHOC)) 
....................    { 
....................       g_WifiAdhocIsConn = TRUE; 
....................       g_WifiAdhocTickConn = TickGet(); 
....................    } 
....................   #endif 
....................  
....................    // these LEDs are desribed in WIFIConnectTask() 
....................   #if defined(LED_ACTIVITY_ON) 
....................    LED_ACTIVITY_ON(); 
....................   #elif defined(LED_CONNECTION_ON) 
....................    LED_CONNECTION_OFF(); 
....................   #endif 
.................... } 
....................  
....................  
.................... #if defined(WF_FORCE_NO_PS_POLL) 
.................... #if defined(WF_USE_POWER_SAVE_FUNCTIONS) 
....................    #error dont use both at the same time 
.................... #endif 
.................... typedef struct pwrModeRequestStruct 
.................... { 
....................     UINT8 mode; 
....................     UINT8 wake; 
....................     UINT8 rcvDtims; 
....................     UINT8 reserved;            /* pad byte */ 
.................... } tWFPwrModeReq; 
....................  
.................... static void SendPowerModeMsg(tWFPwrModeReq *p_powerMode) 
.................... { 
....................     UINT8 hdr[2]; 
....................      
....................     hdr[0] = WF_MGMT_REQUEST_TYPE; 
....................     hdr[1] = WF_SET_POWER_MODE_SUBTYPE; 
....................  
....................     SendMgmtMsg(hdr, 
....................                 sizeof(hdr), 
....................                (UINT8 *)p_powerMode, 
....................                sizeof(tWFPwrModeReq)); 
....................  
....................     /* wait for mgmt response, free buffer after it comes in (no data to read) */ 
....................    WaitForMgmtResponse(WF_SET_POWER_MODE_SUBTYPE, FREE_MGMT_BUFFER); 
....................      
.................... }  
....................  
.................... void WF_CCS_PsPollDisable(void) 
.................... { 
....................    tWFPwrModeReq   pwrModeReq; 
....................      
....................     pwrModeReq.mode     = 1;  //PS_POLL_DISABLED; 
....................     pwrModeReq.wake     = 1; 
....................     pwrModeReq.rcvDtims = 1; 
....................     SendPowerModeMsg(&pwrModeReq); 
....................  
....................     //SetPowerSaveState(WF_PS_OFF); //not really needed, sets a global for their statemachine 
....................  
....................     WFConfigureLowPowerMode(WF_LOW_POWER_MODE_OFF);  
.................... } 
.................... #endif   //WF_FORCE_NO_PS_POLL 
....................  
.................... #endif //STACK_USE_WIFI 
....................  
.................... #if defined(__DO_DEBUG_MPFS2) 
.................... void debug_array(char *str, char *p, unsigned int16 n) 
.................... { 
....................    char c; 
....................    debug_mpfs2(debug_putc, "\r\n%s %LX ", str, n); 
....................    while(n--) 
....................    { 
....................       c = *p++; 
....................       if ((c >= ' ') && (c <= '}')) 
....................       { 
....................          debug_mpfs2(debug_putc, "%c", c); 
....................       } 
....................       else 
....................       { 
....................          debug_mpfs2(debug_putc, "+%X", c); 
....................       } 
....................    } 
....................    debug_mpfs2(debug_putc, " "); 
.................... } 
.................... #else 
.................... #define debug_array(str, p, n) 
.................... #endif 
....................  
.................... // if you call TickGet() from an ISR, this may be a lock-up condition. 
.................... // this is a morph of GetTickCopy() and TickUpdate() that works from an ISR. 
.................... // only works on PIC18. 
.................... #if defined(__PCH__) 
.................... TICK TickGetSafe(void) 
.................... { 
....................    BYTE myTickReading[6]; 
....................    do 
....................    { 
....................       if(INTCONbits.TMR0IF) 
....................       { 
....................          dwInternalTicks++; 
....................          INTCONbits.TMR0IF = 0; 
....................       } 
....................       myTickReading[0] = TMR0L; 
....................       myTickReading[1] = TMR0H; 
....................       *((DWORD*)&myTickReading[2]) = dwInternalTicks; 
....................    } while(INTCONbits.TMR0IF); 
....................     
....................    return *((DWORD*)&myTickReading[0]); 
.................... } 
.................... #endif 
....................  
.................... // this used to be called GenerateRandomBYTE() in an older CCS port of Helpers.c 
.................... BYTE GenerateRandomByteFromTimers(void) 
.................... { 
....................    BYTE rand; 
....................     
....................   #if getenv("TIMER0") && !defined(__PCD__) 
....................    rand+=get_timer0(); 
....................   #endif 
....................    
....................   #if getenv("TIMER1") 
....................    rand+=get_timer1(); 
....................   #endif 
....................    
....................   #if getenv("TIMER2") 
....................    rand+=get_timer2(); 
....................   #endif 
....................    
....................   #if getenv("TIMER3") 
....................    rand+=get_timer3(); 
....................   #endif 
....................    
....................   #if getenv("TIMER4") 
....................    rand+=get_timer4(); 
....................   #endif 
....................    
....................   #if getenv("TIMER5") 
....................    rand+=get_timer5(); 
....................   #endif 
....................    
....................    return(rand); 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................    Assigns the MAC address of the unit. 
....................    This is removed when using WIFI, so it will use the MAC address of the 
....................    WIFI module.  You can still override the MAC address of the WIFI module 
....................    if you remove the conditional compilation option. 
.................... */ 
.................... void MACAddrInit(void) 
.................... { 
....................   #if !STACK_USE_WIFI 
....................    MY_MAC_BYTE1=0; 
*
001C6:  CLRF   56
....................    MY_MAC_BYTE2=2; 
001C8:  MOVLW  02
001CA:  MOVWF  57
....................    MY_MAC_BYTE3=3; 
001CC:  MOVLW  03
001CE:  MOVWF  58
....................    MY_MAC_BYTE4=4; 
001D0:  MOVLW  04
001D2:  MOVWF  59
....................    MY_MAC_BYTE5=5; 
001D4:  MOVLW  05
001D6:  MOVWF  5A
....................    MY_MAC_BYTE6=7; 
001D8:  MOVLW  07
001DA:  MOVWF  5B
....................   #endif 
001DC:  GOTO   0232 (RETURN)
.................... } 
....................  
.................... void IPAddrInit(void)  
.................... { 
....................    //IP address of this unit 
....................    MY_IP_BYTE1=192; 
001E0:  MOVLW  C0
001E2:  MOVWF  29
....................    MY_IP_BYTE2=168; 
001E4:  MOVLW  A8
001E6:  MOVWF  2A
....................    MY_IP_BYTE3=100; 
001E8:  MOVLW  64
001EA:  MOVWF  2B
....................    MY_IP_BYTE4=7; 
001EC:  MOVLW  07
001EE:  MOVWF  2C
....................  
....................    //network gateway 
....................    MY_GATE_BYTE1=192; 
001F0:  MOVLW  C0
001F2:  MOVWF  31
....................    MY_GATE_BYTE2=168; 
001F4:  MOVLW  A8
001F6:  MOVWF  32
....................    MY_GATE_BYTE3=100; 
001F8:  MOVLW  64
001FA:  MOVWF  33
....................    MY_GATE_BYTE4=1; 
001FC:  MOVLW  01
001FE:  MOVWF  34
....................  
....................    //subnet mask 
....................    MY_MASK_BYTE1=255; 
00200:  SETF   2D
....................    MY_MASK_BYTE2=255; 
00202:  SETF   2E
....................    MY_MASK_BYTE3=255; 
00204:  SETF   2F
....................    MY_MASK_BYTE4=0; 
00206:  CLRF   30
....................    
....................   #if defined(STACK_USE_DNS) 
....................    AppConfig.PrimaryDNSServer.v[0] = 192; 
00208:  MOVLW  C0
0020A:  MOVWF  35
....................    AppConfig.PrimaryDNSServer.v[1] = 168; 
0020C:  MOVLW  A8
0020E:  MOVWF  36
....................    AppConfig.PrimaryDNSServer.v[2] = 100; 
00210:  MOVLW  64
00212:  MOVWF  37
....................    AppConfig.PrimaryDNSServer.v[3] = 1; 
00214:  MOVLW  01
00216:  MOVWF  38
....................   #endif 
00218:  GOTO   0234 (RETURN)
.................... } 
....................  
.................... char ExampleIPDatagram[] = { 
....................    0x45, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
....................    0x64, 0x11, 0x2A, 0x9D, 0x0A, 0x0B, 0x0C, 0x0D, 
....................    0x0A, 0x0B, 0x0C, 0x0E 
.................... }; 
....................  
.................... char ExampleUDPPacket[] = { 
....................    0x04, 0x00, 0x04, 0x01, 0x00, 0x0C, 0x00, 0x00, 
....................    0x01, 0x02, 0x03, 0x04 
.................... }; 
....................  
.................... void MACToString(char *str, MAC_ADDR *mac) 
.................... { 
....................    sprintf(str, "%X:%X:%X:%X:%X:%X", mac->v[0], mac->v[1], mac->v[2], mac->v[3], mac->v[4], mac->v[5]); 
.................... } 
....................  
.................... void IPToString(char *str, IP_ADDR *ip) 
.................... { 
....................    sprintf(str, "%u.%u.%u.%u", ip->v[0], ip->v[1], ip->v[2], ip->v[3]); 
.................... } 
....................  
.................... /****************************************************************************** 
....................  * If using the newest stack, options for WiFi should be set in WF_Config.h 
....................  *****************************************************************************/ 
.................... #if STACK_USE_WIFI 
....................  
.................... #include "tcpip/StackTsk2.c" 
....................  
.................... #if !STACK_USE_CCS_INI 
.................... // initialize WIFI settings using harcoded values 
.................... void WIFI_Init(void) 
.................... { 
....................    unsigned int8 chans[] = MY_DEFAULT_CHANNEL_LIST; 
....................     
....................    g_connectionProfileID = 0xFF; 
....................     
....................    WIFI_numChannelsInList = sizeof(chans); 
....................    memcpy(WIFI_channelList, chans, WIFI_numChannelsInList); 
....................    WIFI_region = MY_DEFAULT_REGION; 
....................  
....................    // If MAC address is all zero's, then set it to the default MAC address. 
....................    // If the MAC address is the default MAC address, the stack will then use 
....................    // MAC internal to the WIFI module. 
....................    MAC_ADDR blankMac; 
....................    memset(&blankMac, 0x00, sizeof(MAC_ADDR)); 
....................    if (memcmp(&AppConfig.MyMACAddr, &blankMac, sizeof(MAC_ADDR)) == 0) 
....................    { 
....................       memcpy(&AppConfig.MyMACAddr, &MchpDefaultMacAddress, sizeof(MAC_ADDR)); 
....................    } 
....................     
....................    // Load the default SSID Name 
....................    strcpy(AppConfig.MySSID, MY_DEFAULT_SSID_NAME); 
....................    AppConfig.SsidLength = strlen(AppConfig.MySSID); 
....................  
....................    AppConfig.SecurityMode = MY_DEFAULT_WIFI_SECURITY_MODE; 
....................    AppConfig.WepKeyIndex  = MY_DEFAULT_WEP_KEY_INDEX; 
....................    
....................   #if (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_OPEN) 
....................       memset(AppConfig.SecurityKey, 0x00, sizeof(AppConfig.SecurityKey)); 
....................  
....................   #elif MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WEP_40 
....................       strcpy(AppConfig.SecurityKey, MY_DEFAULT_WEP_KEYS_40); 
....................  
....................   #elif MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WEP_104 
....................     strcpy(AppConfig.SecurityKey, MY_DEFAULT_WEP_KEYS_104); 
....................      
....................   #elif (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA_WITH_KEY)       || \ 
....................         (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA2_WITH_KEY)      || \ 
....................         (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA_AUTO_WITH_KEY) 
....................     strcpy(AppConfig.SecurityKey, MY_DEFAULT_PSK); 
....................  
....................   #elif (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA_WITH_PASS_PHRASE)     || \ 
....................         (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA2_WITH_PASS_PHRASE)    || \ 
....................         (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA_AUTO_WITH_PASS_PHRASE) 
....................       strcpy(AppConfig.SecurityKey, MY_DEFAULT_PSK_PHRASE); 
....................  
....................   #else  
....................       #error No security defined 
....................   #endif 
....................      
....................     AppConfig.networkType = MY_DEFAULT_NETWORK_TYPE; 
....................     AppConfig.adhocBehavior = MY_DEFAULT_ADHOC_BEHAVIOR; 
....................      
....................     AppConfig.SecurityKeyLength = strlen(AppConfig.SecurityKey); 
.................... } 
.................... #else  
.................... #define WIFI_Init()  g_connectionProfileID = 0xFF  //taken care of by CCS_INI 
.................... #endif   //!STACK_USE_CCS_INI 
.................... #endif   //!WIFI 
....................  
.................... void Init(void) 
.................... { 
....................    init_user_io(); 
*
0022E:  BRA    0178
....................   
....................    MACAddrInit(); //used by CCS TCP/IP examples 
00230:  BRA    01C6
....................     
....................    IPAddrInit();  //used by CCS TCP/IP examples 
00232:  BRA    01E0
....................     
....................    TickInit(); 
00234:  BRA    021C
....................     
....................     
....................   #if STACK_USE_WIFI 
....................    delay_ms(50); //let the tick get a value for seeding rand 
....................    srand(TickGet() * get_timer0()); //seed random value for channel 
....................    WIFI_Init(); 
....................   #endif 
....................     
....................   #if defined(__PCH__) 
....................    enable_interrupts(GLOBAL); //used by TICK and WIFI 
00236:  MOVLW  C0
00238:  IORWF  FF2,F
....................   #else 
....................    enable_interrupts(INTR_GLOBAL); 
....................   #endif 
....................  
....................   #if STACK_USE_CCS_INI 
0023A:  GOTO   8218 (RETURN)
....................    EEInit(); 
....................  
....................    //printf("\r\n\nMAGIC RD = %X\r\n\n", EERead8(EE_MAGIC)); 
....................  
....................    if (EERead8(EE_MAGIC) != DEF_MAGIC) 
....................    { 
....................       printf(UserPutc, "\r\n\nResetting EEPROM...\r\n\n"); 
....................       EEPROMToDefaults(); 
....................    } 
....................  
....................    EELoadSettings();    
....................    
....................    UIInit(); 
....................   #endif 
.................... } 
....................  
.................... #if STACK_USE_CCS_INI 
....................    #include "ee.c" 
....................    #include "ccsui.c" 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... #int_addrerr FAST 
.................... void IsrAdrerr(void) 
.................... { 
....................    int16 w[16]; 
....................    int16 h,l; 
....................    int32 val; 
....................   #asm 
....................    POP.S 
....................    POP h; 
....................    POP l; 
....................   #endasm 
....................     
....................    w[0] = WREG0; 
....................    w[1] = WREG1; 
....................    w[2] = WREG2; 
....................    w[3] = WREG3; 
....................    w[4] = WREG4; 
....................    w[5] = WREG5; 
....................    w[6] = WREG6; 
....................    w[7] = WREG7; 
....................    w[8] = WREG8; 
....................    w[9] = WREG9; 
....................    w[10] = WREG10; 
....................    w[11] = WREG11; 
....................    w[12] = WREG12; 
....................    w[13] = WREG13; 
....................    w[14] = WREG14; 
....................    w[15] = WREG15; 
....................     
....................     
....................    h &= 0x00FF; 
....................     
....................    val = make32(h, l); 
....................    val -= 2; 
....................     
....................    // this address might be off by 2 bytes 
....................     
....................    printf("\r\n\nADDRESS FAULT 0x%LX ", val); 
....................    for (l=0;l<16;l++) 
....................    { 
....................       printf("W%U:%LX ", l, w[l]); 
....................    } 
....................    printf("\r\n"); 
....................  
....................    while(TRUE); 
.................... } 
.................... #int_stackerr 
.................... void IsrStackerr(void) 
.................... { 
....................    printf("\r\n\n*** STACKERR ***\r\n\n"); 
....................    for(;;) {} 
.................... } 
.................... #endif 
....................  
....................  
.................... #define EXAMPLE_TCP_PORT   (unsigned int16)1000 
....................  
.................... //this function is called by MyTCPTask() when the specified socket is connected 
.................... //to the PC running the TCPSERVER.EXE demo. 
.................... //returns TRUE if BUTTON2 was pressed, therefore we must disconnect the socket 
.................... int8 TCPConnectedTask(TCP_SOCKET socket) { 
....................    char c; 
....................    static int8 counter; 
....................    char str[20]; 
....................    static int8 button1_held; 
....................  
....................    if (TCPIsGetReady(socket)) { 
*
07E22:  MOVFF  249,264
07E26:  RCALL  791C
07E28:  MOVF   01,W
07E2A:  IORWF  02,W
07E2C:  BZ    7E66
....................       printf(lcd_putc,"\f"); 
07E2E:  MOVLW  0C
07E30:  MOVLB  2
07E32:  MOVWF  x61
07E34:  MOVLB  0
07E36:  CALL   04AC
....................       while (TCPGet(socket, &c)) { 
07E3A:  MOVFF  249,25F
07E3E:  MOVLW  02
07E40:  MOVLB  2
07E42:  MOVWF  x61
07E44:  MOVLW  4A
07E46:  MOVWF  x60
07E48:  MOVLB  0
07E4A:  BRA    799C
07E4C:  MOVF   01,F
07E4E:  BZ    7E5A
....................          lcd_putc(c); 
07E50:  MOVFF  24A,261
07E54:  CALL   04AC
07E58:  BRA    7E3A
....................       } 
....................       printf(lcd_putc, "\n\rSOCKET ACTIVE"); 
07E5A:  MOVLW  BA
07E5C:  MOVWF  FF6
07E5E:  MOVLW  00
07E60:  MOVWF  FF7
07E62:  CALL   055C
....................    } 
....................  
.................... //when button 1 is pressed: send message over TCP 
.................... //when button 2 is pressed: disconnect socket 
....................    if (BUTTON1_PRESSED() && !button1_held && TCPIsPutReady(socket)) { 
07E66:  BSF    F92.4
07E68:  BTFSC  F80.4
07E6A:  BRA    7EE8
07E6C:  MOVLB  2
07E6E:  MOVF   x2D,F
07E70:  BTFSC  FD8.2
07E72:  BRA    7E78
07E74:  MOVLB  0
07E76:  BRA    7EE8
07E78:  MOVFF  249,26B
07E7C:  MOVLB  0
07E7E:  RCALL  7A4C
07E80:  MOVF   01,W
07E82:  IORWF  02,W
07E84:  BZ    7EE8
....................       button1_held=TRUE; 
07E86:  MOVLW  01
07E88:  MOVLB  2
07E8A:  MOVWF  x2D
....................       sprintf(str,"BUTTON C=%U",counter++); 
07E8C:  MOVF   x2C,W
07E8E:  INCF   x2C,F
07E90:  MOVWF  x5F
07E92:  MOVLW  02
07E94:  MOVWF  x2B
07E96:  MOVLW  4B
07E98:  MOVWF  x2A
07E9A:  MOVLW  CA
07E9C:  MOVWF  FF6
07E9E:  MOVLW  00
07EA0:  MOVWF  FF7
07EA2:  MOVLW  09
07EA4:  MOVWF  x60
07EA6:  MOVLB  0
07EA8:  BRA    7B1A
07EAA:  MOVFF  25F,260
07EAE:  MOVLW  1B
07EB0:  MOVLB  2
07EB2:  MOVWF  x61
07EB4:  MOVLB  0
07EB6:  BRA    7B70
....................       TCPPutArray(socket,str,strlen(str)); 
07EB8:  MOVLW  02
07EBA:  MOVLB  2
07EBC:  MOVWF  x60
07EBE:  MOVLW  4B
07EC0:  MOVWF  x5F
07EC2:  MOVLB  0
07EC4:  BRA    7BEE
07EC6:  MOVFF  01,25F
07ECA:  MOVFF  249,260
07ECE:  MOVLW  02
07ED0:  MOVLB  2
07ED2:  MOVWF  x62
07ED4:  MOVLW  4B
07ED6:  MOVWF  x61
07ED8:  CLRF   x64
07EDA:  MOVFF  01,263
07EDE:  MOVLB  0
07EE0:  BRA    7C68
....................       TCPFlush(socket); 
07EE2:  MOVFF  249,26B
07EE6:  RCALL  7C2A
....................    } 
....................    if (!BUTTON1_PRESSED()) { 
07EE8:  BSF    F92.4
07EEA:  BTFSS  F80.4
07EEC:  BRA    7EF4
....................       button1_held=FALSE; 
07EEE:  MOVLB  2
07EF0:  CLRF   x2D
07EF2:  MOVLB  0
....................    } 
....................   #if defined(BUTTON2_PRESSED()) 
....................    if (BUTTON2_PRESSED()) { 
....................       return(TRUE); 
....................    } 
....................   #endif 
....................    return(FALSE); 
.................... } 
07EF4:  MOVLW  00
07EF6:  MOVWF  01
07EF8:  GOTO   8024 (RETURN)
....................  
.................... void MyTCPTask(void) 
.................... { 
....................    static TICK lastTick; 
....................    static TCP_SOCKET socket=INVALID_SOCKET; 
....................    static enum { 
....................       MYTCP_STATE_CONNECT=0, MYTCP_STATE_CONNECT_WAIT, 
....................       MYTCP_STATE_CONNECTED, MYTCP_STATE_DISCONNECT, 
....................       MYTCP_STATE_FORCE_DISCONNECT 
....................    } state=0; 
....................    TICK currTick; 
....................    int8 dis; 
....................    static char server[] = MY_DEST_SERVER; 
....................  
....................    currTick=TickGet(); 
....................  
07EFC:  CALL   1734
07F00:  MOVFF  03,247
07F04:  MOVFF  02,246
07F08:  MOVFF  01,245
07F0C:  MOVFF  00,244
....................    switch (state)  
....................    { 
07F10:  MOVLB  2
07F12:  MOVF   x33,W
07F14:  ADDLW  FB
07F16:  BTFSC  FD8.0
07F18:  BRA    80DA
07F1A:  ADDLW  05
07F1C:  MOVLB  0
07F1E:  GOTO   80E0
....................       case MYTCP_STATE_CONNECT: 
....................         #if defined(BUTTON2_PRESSED()) 
....................          if (BUTTON2_PRESSED())  
....................             break;   //wait until release 
....................         #endif   
....................          printf(lcd_putc,"\fCONNECTING TO\n\r%s", server); 
....................          socket = TCPOpen(server, TCP_OPEN_RAM_HOST, EXAMPLE_TCP_PORT, TCP_PURPOSE_DEFAULT); 
....................          if (socket!=INVALID_SOCKET) { 
07F22:  MOVLW  D6
07F24:  MOVWF  FF6
07F26:  MOVLW  00
07F28:  MOVWF  FF7
07F2A:  MOVLW  10
07F2C:  MOVLB  2
07F2E:  MOVWF  x49
07F30:  MOVLB  0
07F32:  CALL   766E
07F36:  MOVLW  02
07F38:  MOVWF  FEA
07F3A:  MOVLW  34
07F3C:  MOVWF  FE9
07F3E:  CALL   7698
....................             lastTick=TickGet(); 
07F42:  MOVLB  2
07F44:  CLRF   x4C
07F46:  CLRF   x4B
07F48:  MOVLW  02
07F4A:  MOVWF  x4A
07F4C:  MOVLW  34
07F4E:  MOVWF  x49
07F50:  MOVLW  01
07F52:  MOVWF  x4D
07F54:  MOVLW  03
07F56:  MOVWF  x4F
07F58:  MOVLW  E8
07F5A:  MOVWF  x4E
07F5C:  MOVLW  09
07F5E:  MOVWF  x50
07F60:  MOVLB  0
07F62:  GOTO   76BE
07F66:  MOVFF  01,232
....................             state=MYTCP_STATE_CONNECT_WAIT; 
07F6A:  MOVLB  2
07F6C:  MOVF   x32,W
07F6E:  SUBLW  FE
07F70:  BZ    7F90
....................          } 
07F72:  MOVLB  0
07F74:  CALL   1734
07F78:  MOVFF  03,231
07F7C:  MOVFF  02,230
07F80:  MOVFF  01,22F
07F84:  MOVFF  00,22E
....................          else { 
07F88:  MOVLW  01
07F8A:  MOVLB  2
07F8C:  MOVWF  x33
....................             printf(lcd_putc,"\fSOCKET ERROR"); 
07F8E:  BRA    7FA0
....................          } 
....................          break; 
07F90:  MOVLW  EA
07F92:  MOVWF  FF6
07F94:  MOVLW  00
07F96:  MOVWF  FF7
07F98:  MOVLB  0
07F9A:  CALL   055C
07F9E:  MOVLB  2
....................  
....................       case MYTCP_STATE_CONNECT_WAIT: 
07FA0:  BRA    80DA
....................          if (TCPIsConnected(socket))  
....................          { 
....................             state=MYTCP_STATE_CONNECTED; 
07FA2:  MOVFF  232,249
07FA6:  RCALL  78EE
07FA8:  MOVF   01,F
07FAA:  BZ    7FD2
....................             printf(lcd_putc,"\fCONNECTED TO\n\r%s", server); 
....................          } 
07FAC:  MOVLW  02
07FAE:  MOVLB  2
07FB0:  MOVWF  x33
....................          else if (TickGetDiff(currTick, lastTick) > (TICKS_PER_SECOND * 10))  
07FB2:  MOVLW  F8
07FB4:  MOVWF  FF6
07FB6:  MOVLW  00
07FB8:  MOVWF  FF7
07FBA:  MOVLW  0F
07FBC:  MOVWF  x49
07FBE:  MOVLB  0
07FC0:  CALL   766E
07FC4:  MOVLW  02
07FC6:  MOVWF  FEA
07FC8:  MOVLW  34
07FCA:  MOVWF  FE9
07FCC:  CALL   7698
....................          { 
07FD0:  BRA    8010
....................             state=MYTCP_STATE_FORCE_DISCONNECT; 
07FD2:  MOVLB  2
07FD4:  MOVF   x2E,W
07FD6:  SUBWF  x44,W
07FD8:  MOVWF  x49
07FDA:  MOVF   x2F,W
07FDC:  SUBWFB x45,W
07FDE:  MOVWF  x4A
07FE0:  MOVF   x30,W
07FE2:  SUBWFB x46,W
07FE4:  MOVWF  x4B
07FE6:  MOVF   x31,W
07FE8:  SUBWFB x47,W
07FEA:  MOVWF  x4C
07FEC:  MOVF   x4C,F
07FEE:  BNZ   800A
07FF0:  MOVF   x4B,W
07FF2:  SUBLW  04
07FF4:  BC    800E
07FF6:  XORLW  FF
07FF8:  BNZ   800A
07FFA:  MOVF   x4A,W
07FFC:  SUBLW  F4
07FFE:  BC    800E
08000:  XORLW  FF
08002:  BNZ   800A
08004:  MOVF   x49,W
08006:  SUBLW  E6
08008:  BC    800E
....................          } 
....................          break; 
0800A:  MOVLW  04
0800C:  MOVWF  x33
0800E:  MOVLB  0
....................  
....................       case MYTCP_STATE_CONNECTED: 
08010:  MOVLB  2
08012:  BRA    80DA
....................          if (TCPIsConnected(socket)) { 
....................             dis=TCPConnectedTask(socket); 
....................             if (dis) { 
08014:  MOVFF  232,249
08018:  RCALL  78EE
0801A:  MOVF   01,F
0801C:  BZ    8046
....................                state=MYTCP_STATE_DISCONNECT; 
0801E:  MOVFF  232,249
08022:  BRA    7E22
08024:  MOVFF  01,248
....................                lastTick=currTick; 
08028:  MOVLB  2
0802A:  MOVF   x48,F
0802C:  BZ    8042
....................             } 
0802E:  MOVLW  03
08030:  MOVWF  x33
....................          } 
08032:  MOVFF  247,231
08036:  MOVFF  246,230
0803A:  MOVFF  245,22F
0803E:  MOVFF  244,22E
....................          else { 
....................             printf(lcd_putc,"\fDISCONNECTED"); 
08042:  BRA    8056
08044:  MOVLB  0
....................             state=MYTCP_STATE_CONNECT; 
....................          } 
08046:  MOVLW  0A
08048:  MOVWF  FF6
0804A:  MOVLW  01
0804C:  MOVWF  FF7
0804E:  CALL   055C
....................          break; 
08052:  MOVLB  2
08054:  CLRF   x33
....................  
....................       case MYTCP_STATE_DISCONNECT: 
08056:  BRA    80DA
....................          printf(lcd_putc,"\fDISCONNECT FROM\n\r%s", server); 
....................          if (TCPIsPutReady(socket)) { 
....................             state=MYTCP_STATE_FORCE_DISCONNECT; 
08058:  MOVLW  18
0805A:  MOVWF  FF6
0805C:  MOVLW  01
0805E:  MOVWF  FF7
08060:  MOVLW  12
08062:  MOVLB  2
08064:  MOVWF  x49
08066:  MOVLB  0
08068:  CALL   766E
0806C:  MOVLW  02
0806E:  MOVWF  FEA
08070:  MOVLW  34
08072:  MOVWF  FE9
08074:  CALL   7698
....................          } 
08078:  MOVFF  232,26B
0807C:  RCALL  7A4C
0807E:  MOVF   01,W
08080:  IORWF  02,W
08082:  BZ    808C
....................          else if (TickGetDiff(currTick, lastTick) > (TICKS_PER_SECOND * 10)) { 
08084:  MOVLW  04
08086:  MOVLB  2
08088:  MOVWF  x33
....................             state=MYTCP_STATE_FORCE_DISCONNECT; 
0808A:  BRA    80C8
....................          } 
0808C:  MOVLB  2
0808E:  MOVF   x2E,W
08090:  SUBWF  x44,W
08092:  MOVWF  x49
08094:  MOVF   x2F,W
08096:  SUBWFB x45,W
08098:  MOVWF  x4A
0809A:  MOVF   x30,W
0809C:  SUBWFB x46,W
0809E:  MOVWF  x4B
080A0:  MOVF   x31,W
080A2:  SUBWFB x47,W
080A4:  MOVWF  x4C
080A6:  MOVF   x4C,F
080A8:  BNZ   80C4
080AA:  MOVF   x4B,W
080AC:  SUBLW  04
080AE:  BC    80C8
080B0:  XORLW  FF
080B2:  BNZ   80C4
080B4:  MOVF   x4A,W
080B6:  SUBLW  F4
080B8:  BC    80C8
080BA:  XORLW  FF
080BC:  BNZ   80C4
080BE:  MOVF   x49,W
080C0:  SUBLW  E6
080C2:  BC    80C8
....................          break; 
080C4:  MOVLW  04
080C6:  MOVWF  x33
....................  
....................       case MYTCP_STATE_FORCE_DISCONNECT: 
080C8:  BRA    80DA
....................          TCPDisconnect(socket); 
....................          state=MYTCP_STATE_CONNECT; 
....................          break; 
080CA:  MOVFF  232,255
080CE:  CALL   2964
....................    } 
080D2:  MOVLB  2
080D4:  CLRF   x33
.................... } 
080D6:  BRA    80DA
080D8:  MOVLB  2
....................  
080DA:  MOVLB  0
080DC:  GOTO   823E (RETURN)
.................... void main(void)  
.................... {   
....................    Init(); 
*
0810E:  CLRF   FF8
08110:  BCF    FD0.7
08112:  BSF    07.7
08114:  MOVLW  7E
08116:  MOVWF  00
08118:  MOVLW  10
0811A:  MOVWF  01
0811C:  MOVLW  02
0811E:  MOVWF  FE9
08120:  MOVLW  00
08122:  MOVWF  FEA
08124:  CLRF   FEE
08126:  DECFSZ 00,F
08128:  BRA    8124
0812A:  DECFSZ 01,F
0812C:  BRA    8124
0812E:  CLRF   16
08130:  BSF    FB8.3
08132:  MOVLW  11
08134:  MOVWF  FAF
08136:  MOVLW  04
08138:  MOVWF  FB0
0813A:  MOVLW  A6
0813C:  MOVWF  FAC
0813E:  MOVLW  90
08140:  MOVWF  FAB
08142:  MOVLB  1
08144:  BCF    x0D.0
08146:  MOVLW  41
08148:  MOVWF  x11
0814A:  MOVLW  FE
0814C:  MOVWF  x10
0814E:  MOVLW  9F
08150:  MOVWF  x0F
08152:  MOVLW  9E
08154:  MOVWF  x0E
08156:  CLRF   x19
08158:  CLRF   x18
0815A:  CLRF   x17
0815C:  CLRF   x16
0815E:  CLRF   x26
08160:  CLRF   x25
08162:  BCF    x0D.2
08164:  SETF   x3C
08166:  SETF   x42
08168:  MOVLW  FE
0816A:  MOVWF  x8A
0816C:  MOVWF  xE3
0816E:  SETF   xF0
08170:  MOVLW  07
08172:  MOVLB  2
08174:  MOVWF  x01
08176:  CLRF   x2B
08178:  CLRF   x2A
0817A:  MOVLW  FE
0817C:  MOVWF  x32
0817E:  CLRF   x33
08180:  MOVF   FC1,W
08182:  ANDLW  C0
08184:  IORLW  0F
08186:  MOVWF  FC1
08188:  MOVLW  07
0818A:  MOVWF  FB4
0818C:  BRA    81D4
0818E:  DATA 06,00
08190:  DATA 23,09
08192:  DATA 00,FA
08194:  DATA 00,FA
08196:  DATA 00,01
08198:  DATA 02,00
0819A:  DATA 00,04
0819C:  DATA 02,0A
0819E:  DATA 45,00
081A0:  DATA 00,20
081A2:  DATA 04,C0
081A4:  DATA 00,18
081A6:  DATA 80,64
081A8:  DATA 11,2A
081AA:  DATA 9D,0A
081AC:  DATA 0B,0C
081AE:  DATA 0D,0A
081B0:  DATA 0B,0C
081B2:  DATA 0E,04
081B4:  DATA 00,04
081B6:  DATA 01,00
081B8:  DATA 0C,00
081BA:  DATA 00,01
081BC:  DATA 02,03
081BE:  DATA 04,10
081C0:  DATA 02,34
081C2:  DATA 31,39
081C4:  DATA 32,2E
081C6:  DATA 31,36
081C8:  DATA 38,2E
081CA:  DATA 31,30
081CC:  DATA 30,2E
081CE:  DATA 31,34
081D0:  DATA 35,00
081D2:  DATA 00,00
081D4:  MOVLW  00
081D6:  MOVWF  FF8
081D8:  MOVLW  81
081DA:  MOVWF  FF7
081DC:  MOVLW  8E
081DE:  MOVWF  FF6
081E0:  TBLRD*+
081E2:  MOVF   FF5,W
081E4:  MOVWF  00
081E6:  XORLW  00
081E8:  BZ    8210
081EA:  TBLRD*+
081EC:  MOVF   FF5,W
081EE:  MOVWF  01
081F0:  BTFSC  FE8.7
081F2:  BRA    81FE
081F4:  ANDLW  0F
081F6:  MOVWF  FEA
081F8:  TBLRD*+
081FA:  MOVFF  FF5,FE9
081FE:  BTFSC  01.6
08200:  TBLRD*+
08202:  BTFSS  01.6
08204:  TBLRD*+
08206:  MOVFF  FF5,FEE
0820A:  DCFSNZ 00,F
0820C:  BRA    81E0
0820E:  BRA    8202
08210:  CLRF   FF8
....................     
....................    printf("\r\n\nCCS TCP/IP TUTORIAL, EXAMPLE 13 (TCP CLIENT)\r\n"); 
08212:  MOVLB  0
08214:  GOTO   022E
....................     
....................    lcd_init(); 
08218:  MOVLW  2E
0821A:  MOVWF  FF6
0821C:  MOVLW  01
0821E:  MOVWF  FF7
08220:  GOTO   023E
....................  
....................    printf(lcd_putc,"\fCCS TCP TUTORIAL\n\rINIT"); 
08224:  GOTO   03D6
....................  
....................    StackInit(); 
08228:  MOVLW  60
0822A:  MOVWF  FF6
0822C:  MOVLW  01
0822E:  MOVWF  FF7
08230:  CALL   055C
....................        
....................    while(TRUE)  
08234:  GOTO   1642
....................    { 
....................       StackTask(); 
....................  
....................      #if STACK_USE_WIFI 
08238:  GOTO   74FA
....................       WIFIConnectTask();   //uses hardcoded ap/router info 
....................  
....................       //don't attempt anything else TCP/IP related if not connected. 
....................       if (!MyWFisConnected()) 
....................          continue; 
....................      #endif 
....................       
....................       MyTCPTask(); 
....................    } 
.................... } 
0823C:  BRA    7EFC
0823E:  BRA    8238
....................  
....................  
08240:  SLEEP 

Configuration Fuses:
   Word  1: C600   H4 FCMEN IESO
   Word  2: 1E1E   PUT BROWNOUT BORV21 NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
