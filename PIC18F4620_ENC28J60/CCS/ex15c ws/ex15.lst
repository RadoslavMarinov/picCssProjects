CCS PCH C Compiler, Version 5.015, 5967               19-май-14 19:04

               Filename:   D:\Projects\PIC18F4620_ENC28J60\CCS\ex15c ws\ex15.lst

               ROM used:   38276 bytes (58%)
                           Largest free fragment is 27256
               RAM used:   739 (19%) at main() level
                           913 (23%) worst case
               Stack used: 15 locations (13 in main + 2 for interrupts)
               Stack size: 31

*
00000:  GOTO   9092
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  00,0E
0003C:  MOVFF  01,0F
00040:  MOVFF  02,10
00044:  MOVFF  03,11
00048:  BTFSS  FF2.5
0004A:  GOTO   0054
0004E:  BTFSC  FF2.2
00050:  GOTO   00B0
00054:  MOVFF  0E,00
00058:  MOVFF  0F,01
0005C:  MOVFF  10,02
00060:  MOVFF  11,03
00064:  MOVFF  0C,FE9
00068:  MOVFF  07,FEA
0006C:  BSF    07.7
0006E:  MOVFF  08,FE1
00072:  MOVFF  09,FE2
00076:  MOVFF  0A,FD9
0007A:  MOVFF  0B,FDA
0007E:  MOVFF  12,FF3
00082:  MOVFF  13,FF4
00086:  MOVFF  14,FFA
0008A:  MOVF   04,W
0008C:  MOVFF  06,FE0
00090:  MOVFF  05,FD8
00094:  RETFIE 0
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // ex15.c - Example 15 from the Embedded Internet/Embedded Ethernet tutorial 
.................... // 
.................... // A webserver that accepts GET and POST commands. 
.................... // 
.................... // See ex_st_webserver2.c for a more complicated webserver example that 
.................... // uses MPFS filesystem. 
.................... // 
.................... // NOTE: Change the code in IPAddrInit() to your desired IP address, which 
.................... //       is based on your network. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // force enabling of LCD library.  if hardware doesn't have LCD hardware, 
.................... // then it will use RS232/Serial for lcd_putc(). 
.................... #define STACK_USE_PICDEM_LCD     1 
....................  
.................... #define STACK_USE_CCS_INI  0 
....................  
.................... #define STACK_USE_ICMP_SERVER 
.................... #define STACK_USE_TCP 
.................... #define STACK_USE_CCS_HTTP1_SERVER 
....................  
.................... #define HTTP_NUM_SOCKETS   1 
....................  
.................... // configure TCP stack for the correct number of sockets and RAM needed. 
.................... #define TCP_CONFIGURATION  HTTP_NUM_SOCKETS   //tell TCPIPConfig.h to not include default TCPSocketInitializer[] array. 
.................... // See ex13b.c for comments. 
.................... #define TCP_ETH_RAM_SIZE   2100 
....................  
.................... #include "ccstcpip.h" 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // ccstcpip.h - Common code shared among all Embedded Internet/Embedded 
.................... // Ethernet tutorial book examples. 
.................... // 
.................... // If you are using a CCS Embedded Ethernet Board (labeled PICENS, which 
.................... // has an MCP ENC28J60) then define STACK_USE_CCS_PICENS to TRUE. 
.................... // 
.................... // If you are using a CCS Embedded Internet Board (labeled PICNET, which 
.................... // has a Realtek RTL8019AS and a 56K Modem) then define STACK_USE_CCS_PICNET 
.................... // to TRUE. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // 10/25/06 
.................... //  - Added STACK_USE_CCS_PICEEC 
.................... //  - ExamplePacket[] UDP header length fixed 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #define STACK_USE_CCS_EWLWIFIB      0 //18f67k22 + mrf24wb0m 
.................... #define STACK_USE_CCS_EWLWIFIG      0 //18f67k22 + mrf24wg0m 
.................... #define STACK_USE_CCS_PICEEC        0 //18f67j60 
.................... #define STACK_USE_CCS_PICENS        1 //18f4620 + enc28j60 
.................... #define STACK_USE_PIC24FJGA110_ENC28     0 //explorer 16, PIC24FJ256GA110, ENC28J60.  unfortunately with this combinatin you cannot use ENC28J60 and 25LC256 at same time 
.................... #define STACK_USE_PIC24FJGA010_ENC28     0 //explorer 16, PIC24FJ128GA010, ENC28J60. 
.................... #define STACK_USE_CCS_EWL5V_REV5    0 //ezWebLynx 5V (REV5), 18f67k22 + enc28j60 
.................... #define STACK_USE_CCS_EWL3V         0 //ezWebLynx 3V, 18f67j60 
.................... //#define STACK_USE_CCS_PICNET        0 //18f6722 + realtek 
....................  
.................... #define STACK_IS_CCS_EXAMPLE 
....................  
.................... /* not working right now 
.................... #define STACK_USE_CCS_PICNET        0 //18f6722 + realtek 
.................... #define STACK_USE_CCS_EWL5V         0 //ezWebLynx 5V 
.................... #define STACK_USE_CCS_EWL5V_REV2    0 //ezWebLynx 5V (REV2) 
.................... */ 
....................  
.................... #if STACK_USE_CCS_EWLWIFIB || STACK_USE_CCS_EWLWIFIG 
....................    #define WF_DEBUG  
....................    #define STACK_USE_WIFI 1 
....................    #if STACK_USE_CCS_EWLWIFIG 
....................       #define MRF24WG 
....................    #endif 
.................... #else 
....................    #define STACK_USE_WIFI 0 
.................... #endif 
....................  
.................... #define LCD_EXTENDED_NEWLINE  //configuration for lcd.c driver/library 
....................   
.................... #if STACK_USE_CCS_EWLWIFIB || STACK_USE_CCS_EWLWIFIG 
....................    #include <18F67K22.h> 
....................    #device HIGH_INTS = TRUE 
....................    #include "tcpip\p18cxxx.h" 
....................     
....................    #reserve 0xF16:0xFFF   //SFR 
....................    #use delay(clock=64M, XTAL=16M) 
....................     
....................    //took out fuses 12/13/11 
....................    //#fuses HSH 
....................    //#fuses PLLEN 
....................    //#fuses MCLR 
....................     
....................    #use rs232(baud=9600, uart1, stream=STREAM_UI, errors) 
....................  
....................    #define wf_debug_printf printf 
....................    void wf_debug_putc(char c) {putc(c);} 
....................  
....................    void lcd_putc(char c) 
....................    { 
....................      #if STACK_USE_PICDEM_LCD 
....................        if (c == '\f') 
....................          printf("\r\n\n"); 
....................        else 
....................          putc(c); 
....................      #endif 
....................    } 
....................    #define lcd_init() 
....................    #ifndef STACK_USE_PICDEM_LCD 
....................       #define STACK_USE_PICDEM_LCD 0   // no hardware LCD support 
....................    #endif 
....................      
....................    #define LED_ON       output_high 
....................    #define LED_OFF      output_low 
....................    #define USER_LED1    PIN_G3                 //input1 
....................    #define USER_LED2    PIN_G4                 //input2 
....................    #define USER_LED3    PIN_F3                 //input3 
....................    #define STANDARD_ADC_STRING  "AN9" 
....................    #define STANDARD_ADC_CHANNEL 9              //input4 
....................    #define BUTTON1_PRESSED() (input(PIN_F5))   //input5 
....................    #define BUTTON2_PRESSED() (input(PIN_A5))   //input6 
....................  
....................    // more gpio / hardware definitions hiding in HardwareProfile.h 
....................  
....................    // macros used by CCS's WIFIConnectTask() 
....................    #define LED_WIFI  PIN_E0 
....................    #define LED_CONNECTION_ON()   output_drive(LED_WIFI);   output_high(LED_WIFI) 
....................    #define LED_CONNECTION_OFF()   output_drive(LED_WIFI);   output_low(LED_WIFI) 
....................     
....................    void init_user_io(void) 
....................    { 
....................       setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_2); 
....................       setup_adc_ports(sAN9); 
....................       set_adc_channel(STANDARD_ADC_CHANNEL); 
....................        
....................       output_drive(USER_LED1); 
....................       output_drive(USER_LED2); 
....................       output_float(PIN_G4); 
....................       output_float(PIN_G3); 
....................       LED_OFF(USER_LED1); 
....................       LED_OFF(USER_LED2); 
....................       LED_CONNECTION_OFF(); 
....................    } 
....................           
....................    #define __AT45DB_D__ 
....................    #define FLASH_SELECT PIN_D2 
....................    #define FLASH_CLOCK  PIN_D6 
....................    #define FLASH_DI     PIN_D4 
....................    #define FLASH_DO     PIN_D5 
....................    #define FLASH_BUFFER_SIZE    264 
....................    #define FLASH_BUFFER_COUNT   4096 
....................    #include "at45db.c"  
....................        
....................    #define __SPIFLASH_H    //prevent spiflash.h from being loaded/used 
....................    #define SPIFlashReadArray(dwAddress, pData, wLen)  ext_flash_read(dwAddress, pData, wLen) 
....................    #define SPIFlashInit()                             init_ext_flash() 
....................    #define SPIFlashBeginWrite(addy)                   ext_flash_startWrite(addy) 
....................    #define SPIFlashWrite(d)                           ext_flash_continuousWrite(d) 
....................    #define SPIFlashStopWrite()                        ext_flash_flushWrites() 
....................    #define SPIFlashWriteBytes(dwAddress, pData, wLen) ext_flash_writeBytes(dwAddress, pData, wLen) 
....................     
....................    // if you want TCP/IP settings saved to internal EEPROM, then comment 
....................    // out the next few lines: 
....................    #define EEInit SPIFlashInit 
....................    #define EEReadBytes(dst, src, len)  SPIFlashReadArray(src, dst, len) 
....................    #define EEWriteBytes(dst, src, len) SPIFlashWriteBytes(dst, src, len) 
....................     
.................... #elif STACK_USE_PIC24FJGA010_ENC28 
....................    #include <24FJ128GA010.h> 
....................    //#device ICD=TRUE 
....................    #device ADC=8 
....................    #include "tcpip\p24fxxxx.h"   //C30 to CCS compatability layer 
....................    #use delay(clock=32MHz) 
....................    #fuses PR_PLL, XT                 //cw2 
....................    #fuses NOWDT, NOJTAG             //cw1 
....................     
....................    //pin_f13 = rts 
....................    //pin_f12 = cts 
....................    #use rs232(baud=9600, uart2, stream=STREAM_UI, errors) 
....................     
....................    #define BUTTON1_PRESSED()  (!input(PIN_D6))  //marked S3 on PCB 
....................    #define USER_LED1    PIN_A0   //marked D3 on PCB 
....................    #define USER_LED2    PIN_A1   //marked D4 on PCB 
....................    #define USER_LED3    PIN_A2   //marked D5 on PCB 
....................    #define LED_ON       output_high 
....................    #define LED_OFF      output_low 
....................    #define STANDARD_ADC_STRING  "AN5" 
....................    #define STANDARD_ADC_CHANNEL 5   //rb5/an5 
....................         
....................    #define LCD_ENABLE_PIN  PIN_D4 
....................    #define LCD_RS_PIN      PIN_B15 
....................    #define LCD_RW_PIN      PIN_D5 
....................    #define LCD_DATA4       PIN_E4 
....................    #define LCD_DATA5       PIN_E5 
....................    #define LCD_DATA6       PIN_E6 
....................    #define LCD_DATA7       PIN_E7 
....................     
....................    #ifndef STACK_USE_PICDEM_LCD 
....................       #define STACK_USE_PICDEM_LCD 1 
....................    #endif 
....................    #if STACK_USE_PICDEM_LCD 
....................       #include "lcd.c"    
....................    #endif 
....................    
....................    #define ENC_CS_IO       LATDbits.LATD14 
....................    #define ENC_CS_TRIS     TRISDbits.TRISD14 
....................    #define ENC_RST_IO      LATDbits.LATD15 
....................    #define ENC_RST_TRIS    TRISDbits.TRISD15 
....................    #define ENC_SPI_IF         IFS0bits.SPI1IF 
....................    #define ENC_SPICON1        SPI1CON1 
....................    #define ENC_SPICON2        SPI1CON2 
....................    #define ENC_SPISTAT        SPI1STAT 
....................    #define ENC_SSPBUF         SPI1BUF 
....................    #define ENC_SPICON1bits    SPI1CON1bits 
....................    #define ENC_SPICON2bits    SPI1CON2bits 
....................    #define ENC_SPISTATbits    SPI1STATbits 
....................    //!INT pin is RE9/INT2 
....................  
....................    void init_user_io(void)  
....................    { 
....................       setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_2); 
....................       setup_adc_ports(sAN5); 
....................       set_adc_channel(STANDARD_ADC_CHANNEL); 
....................        
....................       output_drive(USER_LED1); 
....................       output_drive(USER_LED2); 
....................       output_drive(USER_LED3); 
....................       LED_OFF(USER_LED1); 
....................       LED_OFF(USER_LED2); 
....................       LED_OFF(USER_LED3); 
....................    } 
....................    // 25LC256 
.................... //#define debug_ee  printf 
.................... //void debug_ee_putc(char c) {putc(c);} 
....................    #define EEPROM_SELECT PIN_D12 
....................    #define EEPROM_CLK    PIN_G6 
....................    #define EEPROM_DI     PIN_G7 
....................    #define EEPROM_DO     PIN_G8 
....................    #include "25lc256.c" 
....................     
....................    #define __SPIFLASH_H    //prevent spiflash.h from being loaded/used 
....................    #define SPIFlashReadArray(dwAddress, pData, wLen)  read_ext_eeprom_bytes(pData, dwAddress, wLen) 
....................    #define SPIFlashInit()                             init_ext_eeprom() 
....................    EEPROM_ADDRESS g_SpiFlashCurrWrite; 
....................    #define SPIFlashBeginWrite(addy)                   g_SpiFlashCurrWrite=addy 
....................    #define SPIFlashWrite(d)                           write_ext_eeprom(g_SpiFlashCurrWrite++, d) 
....................    #define SPIFlashStopWrite() 
....................    #define SPIFlashWriteBytes(dwAddress, pData, wLen) write_ext_eeprom_bytes(dwAddress, pData, wLen) 
....................     
....................    // if you want TCP/IP settings saved to internal EEPROM, then comment 
....................    // out the next few lines: 
....................    #define EEInit SPIFlashInit 
....................    #define EEReadBytes(dst, src, len)  SPIFlashReadArray(src, dst, len) 
....................    #define EEWriteBytes(dst, src, len) SPIFlashWriteBytes(dst, src, len); SPIFlashStopWrite() 
....................     
....................     
.................... #elif STACK_USE_PIC24FJGA110_ENC28 
....................    #include <24FJ256GA110.h> 
....................    //#device ICD=TRUE 
....................    #device ADC=8 
....................    #include "tcpip\p24fxxxx.h" 
....................    #use delay(clock=32MHz) 
....................    #fuses PR_PLL, XT                 //cw2 
....................    #fuses NOWDT, NOJTAG, ICSP2      //cw1 
....................     
....................    #pin_select U2TX=PIN_F5 
....................    #pin_select U2RX=PIN_F4 
....................    //pin_f13 = rts 
....................    //pin_f12 = cts 
....................    #use rs232(baud=9600, uart2, stream=STREAM_UI, errors) 
....................     
....................    #define BUTTON1_PRESSED()  (!input(PIN_D6))  //marked S3 on PCB 
....................    #define USER_LED1    PIN_A0   //marked D3 on PCB 
....................    #define USER_LED2    PIN_A1   //marked D4 on PCB 
....................    #define USER_LED3    PIN_A2   //marked D5 on PCB 
....................    #define LED_ON       output_high 
....................    #define LED_OFF      output_low 
....................    #define STANDARD_ADC_STRING  "AN5" 
....................    #define STANDARD_ADC_CHANNEL 5   //rb5/an5 
....................         
....................    #define LCD_ENABLE_PIN  PIN_D4 
....................    #define LCD_RS_PIN      PIN_B15 
....................    #define LCD_RW_PIN      PIN_D5 
....................    #define LCD_DATA4       PIN_E4 
....................    #define LCD_DATA5       PIN_E5 
....................    #define LCD_DATA6       PIN_E6 
....................    #define LCD_DATA7       PIN_E7 
....................     
....................    #ifndef STACK_USE_PICDEM_LCD 
....................       #define STACK_USE_PICDEM_LCD 1 
....................    #endif 
....................    #if STACK_USE_PICDEM_LCD 
....................       #include "lcd.c"    
....................    #endif 
....................    
....................    // When using 24FJ256GA110, due to an errata with SPI1 we must use SPI2. 
....................    // so when inserting the ENC28J60 PICTail into the Explorer 16, insert 
....................    // it into the second slot.  The definitions below are for the second 
....................    // slot. 
....................    //ENC28J60 INT is mapped to RA15, but not used by software 
....................    #pin_select SDO2=PIN_G8 
....................    #pin_select SDI2=PIN_G7 
....................    #pin_select SCK2OUT=PIN_G6 
....................    #define ENC_CS_IO       LATFbits.LATF12    
....................    #define ENC_CS_TRIS     TRISFbits.TRISF12 
....................    #define ENC_RST_IO      LATFbits.LATF13 
....................    #define ENC_RST_TRIS    TRISFbits.TRISF13 
....................    #define ENC_SPI_IF         IFS2bits.SPI2IF 
....................    #define ENC_SPICON1        SPI2CON1 
....................    #define ENC_SPICON2        SPI2CON2 
....................    #define ENC_SPISTAT        SPI2STAT 
....................    #define ENC_SSPBUF         SPI2BUF 
....................    #define ENC_SPICON1bits    SPI2CON1bits 
....................    #define ENC_SPICON2bits    SPI2CON2bits 
....................    #define ENC_SPISTATbits    SPI2STATbits 
....................  
....................    void init_user_io(void)  
....................    { 
....................       setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_2); 
....................       setup_adc_ports(sAN5); 
....................       set_adc_channel(STANDARD_ADC_CHANNEL); 
....................        
....................       output_drive(USER_LED1); 
....................       output_drive(USER_LED2); 
....................       output_drive(USER_LED3); 
....................       LED_OFF(USER_LED1); 
....................       LED_OFF(USER_LED2); 
....................       LED_OFF(USER_LED3); 
....................    } 
....................  
.................... #elif STACK_USE_CCS_PICEEC 
....................    #include <18F67J60.h> 
....................    #include "tcpip\p18cxxx.h" 
....................    #reserve 0xE80:0xEFF   //SFR 
....................    #reserve 0xF00:0xFFF   //SFR 
....................    #use delay(clock=41666667) 
....................    #fuses NOWDT, NODEBUG, H4_SW, NOIESO, NOFCMEN, PRIMARY, ETHLED 
....................     
....................    #use rs232(baud=9600, uart1, stream=STREAM_UI, errors) 
....................        
....................    //#include "tcpip/elcd.c" //removed, use standard lcd.c that has #define'able pins 
....................    #define BUTTON1_PRESSED()  (!input(PIN_A4)) 
....................    #define USER_LED1    PIN_B3 
....................    #define USER_LED2    PIN_B4 
....................    #define USER_LED3    PIN_B5 
....................    #define LED_ON       output_low 
....................    #define LED_OFF      output_high 
....................    #define STANDARD_ADC_STRING  "AN2" 
....................    #define STANDARD_ADC_CHANNEL 2 
....................  
....................    #define LCD_ENABLE_PIN  PIN_F3 
....................    #define LCD_RS_PIN      PIN_F1 
....................    #define LCD_RW_PIN      PIN_F2 
....................    #define LCD_DATA4       PIN_F4 
....................    #define LCD_DATA5       PIN_F5 
....................    #define LCD_DATA6       PIN_F6 
....................    #define LCD_DATA7       PIN_F7 
....................     
....................    #ifndef STACK_USE_PICDEM_LCD 
....................       #define STACK_USE_PICDEM_LCD 1 
....................    #endif 
....................    #if STACK_USE_PICDEM_LCD 
....................       #include "lcd.c" 
....................    #endif 
....................     
....................    void init_user_io(void)  
....................    { 
....................       setup_oscillator(OSC_PLL_5_DIV_3 | OSC_NORMAL); 
....................       restart_wdt(); 
....................       delay_ms(144); 
....................       restart_wdt(); 
....................        
....................       setup_adc(ADC_CLOCK_INTERNAL); 
....................       setup_adc_ports(AN0_TO_AN2); 
....................       set_adc_channel(STANDARD_ADC_CHANNEL); 
....................        
....................       setup_comparator(NC_NC_NC_NC); 
....................        
....................       output_drive(PIN_A1);   //ethernet led 
....................       output_drive(PIN_A0);   //ethernet led 
....................        
....................       output_drive(USER_LED1); 
....................       output_drive(USER_LED2); 
....................       output_drive(USER_LED3); 
....................       LED_OFF(USER_LED1); 
....................       LED_OFF(USER_LED2); 
....................       LED_OFF(USER_LED3); 
....................    } 
....................     
....................    #define EEPROM_SELECT   PIN_C1  //o 
....................    #define EEPROM_DI       PIN_C5  //o 
....................    #define EEPROM_DO       PIN_C4  //i 
....................    #define EEPROM_CLK      PIN_C3  //o 
....................    #define EEPROM_USE_SPI  1 
....................    #include "AT25256.C" 
....................  
....................    #define __SPIFLASH_H    //prevent spiflash.h from being loaded/used 
....................    #define SPIFlashReadArray(dwAddress, pData, wLen)  read_ext_eeprom_buf(dwAddress, pData, wLen) 
....................    #define SPIFlashInit()                             init_ext_eeprom() 
....................    EEPROM_ADDRESS g_SpiFlashCurrWrite; 
....................    #define SPIFlashBeginWrite(addy)                   g_SpiFlashCurrWrite=addy 
....................    #define SPIFlashWrite(d)                           write_ext_eeprom(g_SpiFlashCurrWrite++, d) 
....................    #define SPIFlashStopWrite() 
....................    #define SPIFlashWriteBytes(dwAddress, pData, wLen) write_ext_eeprom_buf(dwAddress, pData, wLen) 
....................     
....................    // if you want TCP/IP settings saved to internal EEPROM, then comment 
....................    // out the next few lines: 
....................    #define EEInit SPIFlashInit 
....................    #define EEReadBytes(dst, src, len)  SPIFlashReadArray(src, dst, len) 
....................    #define EEWriteBytes(dst, src, len) SPIFlashWriteBytes(dst, src, len); SPIFlashStopWrite() 
....................  
.................... #elif STACK_USE_CCS_PICENS 
....................    #include <18F4620.h> 
.................... //////////// Standard Header file for the PIC18F4620 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4620 
*
000B6:  DATA 48,54
000B8:  DATA 54,50
000BA:  DATA 2F,31
000BC:  DATA 2E,30
000BE:  DATA 20,25
000C0:  DATA 4C,55
000C2:  DATA 20,00
000C4:  DATA 4E,6F
000C6:  DATA 74,20
000C8:  DATA 66,6F
000CA:  DATA 75,6E
000CC:  DATA 64,00
000CE:  DATA 53,65
000D0:  DATA 72,76
000D2:  DATA 65,72
000D4:  DATA 20,45
000D6:  DATA 72,72
000D8:  DATA 6F,72
000DA:  DATA 00,00
000DC:  DATA 0D,0A
000DE:  DATA 43,6F
000E0:  DATA 6E,74
000E2:  DATA 65,6E
000E4:  DATA 74,2D
000E6:  DATA 54,79
000E8:  DATA 70,65
000EA:  DATA 3A,20
000EC:  DATA 00,00
000EE:  DATA 74,65
000F0:  DATA 78,74
000F2:  DATA 2F,68
000F4:  DATA 74,6D
000F6:  DATA 6C,00
000F8:  DATA 0D,0A
000FA:  DATA 0D,0A
000FC:  DATA 00,00
000FE:  DATA 0D,0A
00100:  DATA 52,65
00102:  DATA 71,75
00104:  DATA 65,73
00106:  DATA 74,20
00108:  DATA 25,73
0010A:  DATA 20,00
0010C:  DATA 28,46
0010E:  DATA 49,4C
00110:  DATA 45,3D
00112:  DATA 25,30
00114:  DATA 78,4C
00116:  DATA 58,29
00118:  DATA 00,00
0011A:  DATA 28,46
0011C:  DATA 69,6C
0011E:  DATA 65,20
00120:  DATA 4E,6F
00122:  DATA 74,20
00124:  DATA 46,6F
00126:  DATA 75,6E
00128:  DATA 64,29
0012A:  DATA 00,00
0012C:  DATA 3C,42
0012E:  DATA 3E,25
00130:  DATA 73,20
00132:  DATA 3D,20
00134:  DATA 3C,2F
00136:  DATA 42,3E
00138:  DATA 25,6C
0013A:  DATA 75,00
0013C:  DATA 41,4E
0013E:  DATA 30,00
00140:  DATA 0D,0A
00142:  DATA 43,47
00144:  DATA 49,20
00146:  DATA 46,49
00148:  DATA 4C,45
0014A:  DATA 3D,25
0014C:  DATA 4C,44
0014E:  DATA 20,4B
00150:  DATA 45,59
00152:  DATA 3D,25
00154:  DATA 53,20
00156:  DATA 56,41
00158:  DATA 4C,3D
0015A:  DATA 25,53
0015C:  DATA 00,00
0015E:  DATA 0C,57
00160:  DATA 65,62
00162:  DATA 73,65
00164:  DATA 72,76
00166:  DATA 65,72
00168:  DATA 0A,0D
0016A:  DATA 4E,6F
0016C:  DATA 20,4D
0016E:  DATA 41,43
00170:  DATA 20,4C
00172:  DATA 69,6E
00174:  DATA 6B,00
00176:  DATA 0C,44
00178:  DATA 48,43
0017A:  DATA 50,20
0017C:  DATA 44,69
0017E:  DATA 73,61
00180:  DATA 62,6C
00182:  DATA 65,64
00184:  DATA 0A,0D
00186:  DATA 25,75
00188:  DATA 2E,25
0018A:  DATA 75,2E
0018C:  DATA 25,75
0018E:  DATA 2E,25
00190:  DATA 75,00
00192:  DATA 0C,57
00194:  DATA 65,62
00196:  DATA 73,65
00198:  DATA 72,76
0019A:  DATA 65,72
0019C:  DATA 0A,0D
0019E:  DATA 44,48
001A0:  DATA 43,50
001A2:  DATA 20,4E
001A4:  DATA 6F,74
001A6:  DATA 20,42
001A8:  DATA 6F,75
001AA:  DATA 6E,64
001AC:  DATA 00,00
001AE:  DATA 0D,0A
001B0:  DATA 0A,43
001B2:  DATA 43,53
001B4:  DATA 20,54
001B6:  DATA 43,50
001B8:  DATA 2F,49
001BA:  DATA 50,20
001BC:  DATA 54,55
001BE:  DATA 54,4F
001C0:  DATA 52,49
001C2:  DATA 41,4C
001C4:  DATA 2C,20
001C6:  DATA 45,58
001C8:  DATA 41,4D
001CA:  DATA 50,4C
001CC:  DATA 45,20
001CE:  DATA 31,35
001D0:  DATA 20,28
001D2:  DATA 48,54
001D4:  DATA 54,50
001D6:  DATA 20,53
001D8:  DATA 45,52
001DA:  DATA 56,45
001DC:  DATA 52,29
001DE:  DATA 0D,0A
001E0:  DATA 00,00
001E2:  DATA 0C,43
001E4:  DATA 43,53
001E6:  DATA 20,43
001E8:  DATA 47,49
001EA:  DATA 20,45
001EC:  DATA 78,61
001EE:  DATA 6D,70
001F0:  DATA 6C,65
001F2:  DATA 0A,0D
001F4:  DATA 49,6E
001F6:  DATA 69,74
001F8:  DATA 20,53
001FA:  DATA 74,61
001FC:  DATA 63,6B
001FE:  DATA 2E,2E
00200:  DATA 2E,00
00202:  DATA 0D,0A
00204:  DATA 0A,43
00206:  DATA 43,53
00208:  DATA 20,43
0020A:  DATA 47,49
0020C:  DATA 20,45
0020E:  DATA 78,61
00210:  DATA 6D,70
00212:  DATA 6C,65
00214:  DATA 0D,0A
00216:  DATA 57,61
00218:  DATA 69,74
0021A:  DATA 69,6E
0021C:  DATA 67,00
*
002D4:  TBLRD*+
002D6:  MOVF   FF5,F
002D8:  BZ    02F4
002DA:  MOVFF  FF6,2F3
002DE:  MOVFF  FF7,2F4
002E2:  MOVF   FF5,W
002E4:  BTFSS  F9E.4
002E6:  BRA    02E4
002E8:  MOVWF  FAD
002EA:  MOVFF  2F3,FF6
002EE:  MOVFF  2F4,FF7
002F2:  BRA    02D4
002F4:  RETURN 0
*
005F8:  TBLRD*+
005FA:  MOVF   FF5,F
005FC:  BZ    0616
005FE:  MOVFF  FF6,2E3
00602:  MOVFF  FF7,2E4
00606:  MOVFF  FF5,31A
0060A:  RCALL  0548
0060C:  MOVFF  2E3,FF6
00610:  MOVFF  2E4,FF7
00614:  BRA    05F8
00616:  RETURN 0
*
00C8A:  TSTFSZ 01
00C8C:  BRA    0C94
00C8E:  TSTFSZ 02
00C90:  BRA    0C96
00C92:  BRA    0CA2
00C94:  INCF   02,F
00C96:  MOVFF  00,FEE
00C9A:  DECFSZ 01,F
00C9C:  BRA    0C96
00C9E:  DECFSZ 02,F
00CA0:  BRA    0C96
00CA2:  GOTO   1480 (RETURN)
*
02B50:  MOVLB  3
02B52:  MOVF   x20,W
02B54:  MULWF  x22
02B56:  MOVFF  FF3,01
02B5A:  MOVFF  FF4,00
02B5E:  MULWF  x23
02B60:  MOVF   FF3,W
02B62:  ADDWF  00,F
02B64:  MOVF   x21,W
02B66:  MULWF  x22
02B68:  MOVF   FF3,W
02B6A:  ADDWFC 00,W
02B6C:  MOVWF  02
02B6E:  MOVLB  0
02B70:  RETURN 0
*
05C32:  TBLRD*+
05C34:  MOVFF  FF6,2E4
05C38:  MOVFF  FF7,2E5
05C3C:  MOVFF  FF5,31A
05C40:  CALL   0548
05C44:  MOVFF  2E4,FF6
05C48:  MOVFF  2E5,FF7
05C4C:  MOVLB  2
05C4E:  DECFSZ xE3,F
05C50:  BRA    5C54
05C52:  BRA    5C58
05C54:  MOVLB  0
05C56:  BRA    5C32
05C58:  MOVLB  0
05C5A:  GOTO   5D52 (RETURN)
05C5E:  MOVLB  3
05C60:  MOVF   x23,W
05C62:  CLRF   01
05C64:  SUBWF  x22,W
05C66:  BC    5C6E
05C68:  MOVFF  322,00
05C6C:  BRA    5C86
05C6E:  CLRF   00
05C70:  MOVLW  08
05C72:  MOVWF  x24
05C74:  RLCF   x22,F
05C76:  RLCF   00,F
05C78:  MOVF   x23,W
05C7A:  SUBWF  00,W
05C7C:  BTFSC  FD8.0
05C7E:  MOVWF  00
05C80:  RLCF   01,F
05C82:  DECFSZ x24,F
05C84:  BRA    5C74
05C86:  MOVLB  0
05C88:  RETURN 0
05C8A:  MOVF   01,W
05C8C:  MOVFF  2E3,322
05C90:  MOVLW  64
05C92:  MOVLB  3
05C94:  MOVWF  x23
05C96:  MOVLB  0
05C98:  RCALL  5C5E
05C9A:  MOVFF  00,2E3
05C9E:  MOVF   01,W
05CA0:  MOVLW  30
05CA2:  BNZ   5CB4
05CA4:  MOVLB  2
05CA6:  BTFSS  xE4.1
05CA8:  BRA    5CC8
05CAA:  BTFSC  xE4.3
05CAC:  BRA    5CC8
05CAE:  BTFSC  xE4.4
05CB0:  MOVLW  20
05CB2:  BRA    5CBC
05CB4:  MOVLB  2
05CB6:  BCF    xE4.3
05CB8:  BCF    xE4.4
05CBA:  BSF    xE4.0
05CBC:  ADDWF  01,F
05CBE:  MOVFF  01,31A
05CC2:  MOVLB  0
05CC4:  CALL   0548
05CC8:  MOVFF  2E3,322
05CCC:  MOVLW  0A
05CCE:  MOVLB  3
05CD0:  MOVWF  x23
05CD2:  MOVLB  0
05CD4:  RCALL  5C5E
05CD6:  MOVFF  00,2E3
05CDA:  MOVF   01,W
05CDC:  MOVLW  30
05CDE:  BNZ   5CF0
05CE0:  MOVLB  2
05CE2:  BTFSC  xE4.3
05CE4:  BRA    5CFC
05CE6:  BTFSS  xE4.0
05CE8:  BRA    5CFC
05CEA:  BTFSC  xE4.4
05CEC:  MOVLW  20
05CEE:  MOVLB  0
05CF0:  ADDWF  01,F
05CF2:  MOVFF  01,31A
05CF6:  CALL   0548
05CFA:  MOVLB  2
05CFC:  MOVLW  30
05CFE:  ADDWF  xE3,F
05D00:  MOVFF  2E3,31A
05D04:  MOVLB  0
05D06:  CALL   0548
05D0A:  RETURN 0
*
061B0:  MOVLB  3
061B2:  CLRF   x4A
061B4:  CLRF   x4B
061B6:  MOVLW  01
061B8:  MOVWF  x4C
061BA:  CLRF   FDA
061BC:  CLRF   FD9
061BE:  MOVLW  03
061C0:  MOVWF  x4F
061C2:  MOVLW  42
061C4:  MOVWF  x4E
061C6:  MOVLW  03
061C8:  MOVWF  FEA
061CA:  MOVLW  46
061CC:  MOVWF  FE9
061CE:  MOVFF  34F,FE2
061D2:  MOVFF  34E,FE1
061D6:  MOVFF  34C,34D
061DA:  BCF    FD8.0
061DC:  MOVF   FE5,W
061DE:  MULWF  FEE
061E0:  MOVF   FF3,W
061E2:  ADDWFC x4A,F
061E4:  MOVF   FF4,W
061E6:  ADDWFC x4B,F
061E8:  DECFSZ x4D,F
061EA:  BRA    61DA
061EC:  MOVFF  34A,FDE
061F0:  MOVFF  34B,34A
061F4:  CLRF   x4B
061F6:  BTFSC  FD8.0
061F8:  INCF   x4B,F
061FA:  INCF   x4E,F
061FC:  BTFSC  FD8.2
061FE:  INCF   x4F,F
06200:  INCF   x4C,F
06202:  MOVF   x4C,W
06204:  SUBLW  05
06206:  BNZ   61C6
06208:  MOVLB  0
0620A:  RETURN 0
*
06836:  TBLRD*+
06838:  MOVFF  FF6,319
0683C:  MOVFF  FF7,31A
06840:  MOVF   FF5,W
06842:  BTFSS  F9E.4
06844:  BRA    6842
06846:  MOVWF  FAD
06848:  MOVFF  319,FF6
0684C:  MOVFF  31A,FF7
06850:  MOVLB  3
06852:  DECFSZ x18,F
06854:  BRA    6858
06856:  BRA    685C
06858:  MOVLB  0
0685A:  BRA    6836
0685C:  MOVLB  0
0685E:  RETURN 0
06860:  MOVF   FEF,F
06862:  BZ    6884
06864:  MOVFF  FEA,319
06868:  MOVFF  FE9,318
0686C:  MOVF   FEF,W
0686E:  BTFSS  F9E.4
06870:  BRA    686E
06872:  MOVWF  FAD
06874:  MOVFF  319,FEA
06878:  MOVFF  318,FE9
0687C:  INCF   FE9,F
0687E:  BTFSC  FD8.2
06880:  INCF   FEA,F
06882:  BRA    6860
06884:  RETURN 0
*
069B8:  MOVLB  2
069BA:  BTFSC  xF4.7
069BC:  BRA    69DE
069BE:  MOVLW  0F
069C0:  MOVWF  00
069C2:  SWAPF  xF3,W
069C4:  ANDWF  00,F
069C6:  MOVLW  0A
069C8:  SUBWF  00,W
069CA:  BC    69D2
069CC:  MOVLW  30
069CE:  ADDWF  00,F
069D0:  BRA    69D6
069D2:  MOVF   xF4,W
069D4:  ADDWF  00,F
069D6:  MOVF   00,W
069D8:  BTFSS  F9E.4
069DA:  BRA    69D8
069DC:  MOVWF  FAD
069DE:  MOVLW  0F
069E0:  ANDWF  xF3,F
069E2:  MOVLW  0A
069E4:  SUBWF  xF3,W
069E6:  BC    69EC
069E8:  MOVLW  30
069EA:  BRA    69F0
069EC:  BCF    xF4.7
069EE:  MOVF   xF4,W
069F0:  ADDWF  xF3,F
069F2:  MOVF   xF3,W
069F4:  BTFSS  F9E.4
069F6:  BRA    69F4
069F8:  MOVWF  FAD
069FA:  MOVLB  0
069FC:  GOTO   6ADE (RETURN)
*
06B16:  BTFSC  FD8.1
06B18:  BRA    6B22
06B1A:  MOVLW  03
06B1C:  MOVWF  FEA
06B1E:  MOVLW  2C
06B20:  MOVWF  FE9
06B22:  CLRF   00
06B24:  CLRF   01
06B26:  CLRF   02
06B28:  CLRF   03
06B2A:  MOVLB  3
06B2C:  CLRF   x2C
06B2E:  CLRF   x2D
06B30:  CLRF   x2E
06B32:  CLRF   x2F
06B34:  MOVF   x2B,W
06B36:  IORWF  x2A,W
06B38:  IORWF  x29,W
06B3A:  IORWF  x28,W
06B3C:  BZ    6B96
06B3E:  MOVLW  20
06B40:  MOVWF  x30
06B42:  BCF    FD8.0
06B44:  RLCF   x24,F
06B46:  RLCF   x25,F
06B48:  RLCF   x26,F
06B4A:  RLCF   x27,F
06B4C:  RLCF   x2C,F
06B4E:  RLCF   x2D,F
06B50:  RLCF   x2E,F
06B52:  RLCF   x2F,F
06B54:  MOVF   x2B,W
06B56:  SUBWF  x2F,W
06B58:  BNZ   6B6A
06B5A:  MOVF   x2A,W
06B5C:  SUBWF  x2E,W
06B5E:  BNZ   6B6A
06B60:  MOVF   x29,W
06B62:  SUBWF  x2D,W
06B64:  BNZ   6B6A
06B66:  MOVF   x28,W
06B68:  SUBWF  x2C,W
06B6A:  BNC   6B8A
06B6C:  MOVF   x28,W
06B6E:  SUBWF  x2C,F
06B70:  MOVF   x29,W
06B72:  BTFSS  FD8.0
06B74:  INCFSZ x29,W
06B76:  SUBWF  x2D,F
06B78:  MOVF   x2A,W
06B7A:  BTFSS  FD8.0
06B7C:  INCFSZ x2A,W
06B7E:  SUBWF  x2E,F
06B80:  MOVF   x2B,W
06B82:  BTFSS  FD8.0
06B84:  INCFSZ x2B,W
06B86:  SUBWF  x2F,F
06B88:  BSF    FD8.0
06B8A:  RLCF   00,F
06B8C:  RLCF   01,F
06B8E:  RLCF   02,F
06B90:  RLCF   03,F
06B92:  DECFSZ x30,F
06B94:  BRA    6B42
06B96:  MOVFF  32C,FEF
06B9A:  MOVFF  32D,FEC
06B9E:  MOVFF  32E,FEC
06BA2:  MOVFF  32F,FEC
06BA6:  MOVLB  0
06BA8:  RETURN 0
06BAA:  MOVF   FE9,W
06BAC:  MOVLB  3
06BAE:  MOVWF  x1C
06BB0:  BTFSS  x1B.7
06BB2:  BRA    6BCE
06BB4:  DECF   x1C,F
06BB6:  BSF    x1C.5
06BB8:  COMF   x18,F
06BBA:  COMF   x19,F
06BBC:  COMF   x1A,F
06BBE:  COMF   x1B,F
06BC0:  INCF   x18,F
06BC2:  BTFSC  FD8.2
06BC4:  INCF   x19,F
06BC6:  BTFSC  FD8.2
06BC8:  INCF   x1A,F
06BCA:  BTFSC  FD8.2
06BCC:  INCF   x1B,F
06BCE:  MOVLW  3B
06BD0:  MOVWF  x23
06BD2:  MOVLW  9A
06BD4:  MOVWF  x22
06BD6:  MOVLW  CA
06BD8:  MOVWF  x21
06BDA:  CLRF   x20
06BDC:  MOVLW  0A
06BDE:  MOVWF  x1E
06BE0:  BSF    FD8.1
06BE2:  MOVLW  03
06BE4:  MOVWF  FEA
06BE6:  MOVLW  18
06BE8:  MOVWF  FE9
06BEA:  MOVFF  31B,327
06BEE:  MOVFF  31A,326
06BF2:  MOVFF  319,325
06BF6:  MOVFF  318,324
06BFA:  MOVFF  323,32B
06BFE:  MOVFF  322,32A
06C02:  MOVFF  321,329
06C06:  MOVFF  320,328
06C0A:  MOVLB  0
06C0C:  RCALL  6B16
06C0E:  MOVF   01,W
06C10:  MOVF   00,F
06C12:  BNZ   6C3A
06C14:  MOVLB  3
06C16:  MOVF   x1E,W
06C18:  XORLW  01
06C1A:  BTFSS  FD8.2
06C1C:  BRA    6C22
06C1E:  MOVLB  0
06C20:  BRA    6C3A
06C22:  MOVF   x1C,W
06C24:  BZ    6C40
06C26:  ANDLW  0F
06C28:  SUBWF  x1E,W
06C2A:  BZ    6C2E
06C2C:  BC    6C7E
06C2E:  BTFSC  x1C.7
06C30:  BRA    6C7E
06C32:  BTFSC  x1C.6
06C34:  BRA    6C40
06C36:  MOVLW  20
06C38:  BRA    6C74
06C3A:  MOVLW  20
06C3C:  MOVLB  3
06C3E:  ANDWF  x1C,F
06C40:  BTFSS  x1C.5
06C42:  BRA    6C58
06C44:  BCF    x1C.5
06C46:  MOVFF  00,31C
06C4A:  MOVLW  2D
06C4C:  BTFSS  F9E.4
06C4E:  BRA    6C4C
06C50:  MOVWF  FAD
06C52:  MOVFF  31C,00
06C56:  CLRF   x1C
06C58:  MOVLW  30
06C5A:  BTFSS  x1C.5
06C5C:  BRA    6C74
06C5E:  BCF    x1C.5
06C60:  MOVFF  00,31C
06C64:  MOVLW  2D
06C66:  BTFSS  F9E.4
06C68:  BRA    6C66
06C6A:  MOVWF  FAD
06C6C:  MOVFF  31C,00
06C70:  CLRF   x1C
06C72:  MOVLW  30
06C74:  ADDWF  00,F
06C76:  MOVF   00,W
06C78:  BTFSS  F9E.4
06C7A:  BRA    6C78
06C7C:  MOVWF  FAD
06C7E:  BCF    FD8.1
06C80:  MOVFF  323,327
06C84:  MOVFF  322,326
06C88:  MOVFF  321,325
06C8C:  MOVFF  320,324
06C90:  CLRF   x2B
06C92:  CLRF   x2A
06C94:  CLRF   x29
06C96:  MOVLW  0A
06C98:  MOVWF  x28
06C9A:  MOVLB  0
06C9C:  RCALL  6B16
06C9E:  MOVFF  03,323
06CA2:  MOVFF  02,322
06CA6:  MOVFF  01,321
06CAA:  MOVFF  00,320
06CAE:  MOVLB  3
06CB0:  DECFSZ x1E,F
06CB2:  BRA    6BE0
06CB4:  MOVLB  0
06CB6:  GOTO   7134 (RETURN)
06CBA:  MOVLB  3
06CBC:  MOVF   x24,W
06CBE:  XORWF  x26,W
06CC0:  ANDLW  80
06CC2:  MOVWF  x28
06CC4:  BTFSS  x24.7
06CC6:  BRA    6CD2
06CC8:  COMF   x23,F
06CCA:  COMF   x24,F
06CCC:  INCF   x23,F
06CCE:  BTFSC  FD8.2
06CD0:  INCF   x24,F
06CD2:  BTFSS  x26.7
06CD4:  BRA    6CE0
06CD6:  COMF   x25,F
06CD8:  COMF   x26,F
06CDA:  INCF   x25,F
06CDC:  BTFSC  FD8.2
06CDE:  INCF   x26,F
06CE0:  MOVF   x23,W
06CE2:  MULWF  x25
06CE4:  MOVFF  FF3,01
06CE8:  MOVFF  FF4,00
06CEC:  MULWF  x26
06CEE:  MOVF   FF3,W
06CF0:  ADDWF  00,F
06CF2:  MOVF   x24,W
06CF4:  MULWF  x25
06CF6:  MOVF   FF3,W
06CF8:  ADDWFC 00,W
06CFA:  MOVWF  02
06CFC:  BTFSS  x28.7
06CFE:  BRA    6D0A
06D00:  COMF   01,F
06D02:  COMF   02,F
06D04:  INCF   01,F
06D06:  BTFSC  FD8.2
06D08:  INCF   02,F
06D0A:  MOVLB  0
06D0C:  GOTO   6E3C (RETURN)
*
06FA4:  MOVFF  2BC,FEA
06FA8:  MOVFF  2BB,FE9
06FAC:  MOVLB  3
06FAE:  MOVFF  324,FEF
06FB2:  INCF   FE9,F
06FB4:  BTFSC  FD8.2
06FB6:  INCF   FEA,F
06FB8:  CLRF   FEF
06FBA:  MOVLB  2
06FBC:  INCF   xBB,F
06FBE:  BTFSC  FD8.2
06FC0:  INCF   xBC,F
06FC2:  MOVLB  0
06FC4:  RETURN 0
06FC6:  MOVF   01,W
06FC8:  MOVFF  320,322
06FCC:  MOVLW  64
06FCE:  MOVLB  3
06FD0:  MOVWF  x23
06FD2:  MOVLB  0
06FD4:  CALL   5C5E
06FD8:  MOVFF  00,320
06FDC:  MOVF   01,W
06FDE:  MOVLW  30
06FE0:  BNZ   6FF2
06FE2:  MOVLB  3
06FE4:  BTFSS  x21.1
06FE6:  BRA    7006
06FE8:  BTFSC  x21.3
06FEA:  BRA    7006
06FEC:  BTFSC  x21.4
06FEE:  MOVLW  20
06FF0:  BRA    6FFA
06FF2:  MOVLB  3
06FF4:  BCF    x21.3
06FF6:  BCF    x21.4
06FF8:  BSF    x21.0
06FFA:  ADDWF  01,F
06FFC:  MOVFF  01,324
07000:  MOVLB  0
07002:  RCALL  6FA4
07004:  MOVLB  3
07006:  MOVFF  320,322
0700A:  MOVLW  0A
0700C:  MOVWF  x23
0700E:  MOVLB  0
07010:  CALL   5C5E
07014:  MOVFF  00,320
07018:  MOVF   01,W
0701A:  MOVLW  30
0701C:  BNZ   702E
0701E:  MOVLB  3
07020:  BTFSC  x21.3
07022:  BRA    7038
07024:  BTFSS  x21.0
07026:  BRA    7038
07028:  BTFSC  x21.4
0702A:  MOVLW  20
0702C:  MOVLB  0
0702E:  ADDWF  01,F
07030:  MOVFF  01,324
07034:  RCALL  6FA4
07036:  MOVLB  3
07038:  MOVLW  30
0703A:  ADDWF  x20,F
0703C:  MOVFF  320,324
07040:  MOVLB  0
07042:  RCALL  6FA4
07044:  RETURN 0
*
070E4:  MOVF   FEF,F
070E6:  BZ    7108
070E8:  MOVFF  FEA,319
070EC:  MOVFF  FE9,318
070F0:  MOVFF  FEF,31A
070F4:  CALL   0548
070F8:  MOVFF  319,FEA
070FC:  MOVFF  318,FE9
07100:  INCF   FE9,F
07102:  BTFSC  FD8.2
07104:  INCF   FEA,F
07106:  BRA    70E4
07108:  RETURN 0
*
078AA:  TBLRD*+
078AC:  MOVFF  FF6,2FD
078B0:  MOVFF  FF7,2FE
078B4:  MOVFF  FF5,31A
078B8:  RCALL  7898
078BA:  MOVFF  2FD,FF6
078BE:  MOVFF  2FE,FF7
078C2:  MOVLB  2
078C4:  DECFSZ xFC,F
078C6:  BRA    78CA
078C8:  BRA    78CE
078CA:  MOVLB  0
078CC:  BRA    78AA
078CE:  MOVLB  0
078D0:  GOTO   812C (RETURN)
078D4:  MOVFF  FEA,306
078D8:  MOVFF  FE9,305
078DC:  MOVLB  2
078DE:  SWAPF  xFD,W
078E0:  IORLW  F0
078E2:  MOVLB  3
078E4:  MOVWF  x01
078E6:  ADDWF  x01,F
078E8:  ADDLW  E2
078EA:  MOVWF  x02
078EC:  ADDLW  32
078EE:  MOVWF  x04
078F0:  MOVLB  2
078F2:  MOVF   xFD,W
078F4:  ANDLW  0F
078F6:  MOVLB  3
078F8:  ADDWF  x02,F
078FA:  ADDWF  x02,F
078FC:  ADDWF  x04,F
078FE:  ADDLW  E9
07900:  MOVWF  x03
07902:  ADDWF  x03,F
07904:  ADDWF  x03,F
07906:  MOVLB  2
07908:  SWAPF  xFC,W
0790A:  ANDLW  0F
0790C:  MOVLB  3
0790E:  ADDWF  x03,F
07910:  ADDWF  x04,F
07912:  RLCF   x03,F
07914:  RLCF   x04,F
07916:  COMF   x04,F
07918:  RLCF   x04,F
0791A:  MOVLB  2
0791C:  MOVF   xFC,W
0791E:  ANDLW  0F
07920:  MOVLB  3
07922:  ADDWF  x04,F
07924:  RLCF   x01,F
07926:  MOVLW  07
07928:  MOVWF  x00
0792A:  MOVLW  0A
0792C:  DECF   x03,F
0792E:  ADDWF  x04,F
07930:  BNC   792C
07932:  DECF   x02,F
07934:  ADDWF  x03,F
07936:  BNC   7932
07938:  DECF   x01,F
0793A:  ADDWF  x02,F
0793C:  BNC   7938
0793E:  DECF   x00,F
07940:  ADDWF  x01,F
07942:  BNC   793E
07944:  MOVLW  03
07946:  MOVWF  FEA
07948:  CLRF   FE9
0794A:  MOVLW  07
0794C:  ANDWF  x05,W
0794E:  BCF    x05.6
07950:  ADDWF  FE9,F
07952:  MOVLW  00
07954:  ADDWFC FEA,F
07956:  MOVF   FE9,W
07958:  SUBLW  04
0795A:  BNZ   7964
0795C:  MOVF   FEA,W
0795E:  SUBLW  03
07960:  BNZ   7964
07962:  BSF    x05.6
07964:  MOVF   FEF,W
07966:  MOVWF  00
07968:  BNZ   797A
0796A:  BTFSC  x05.6
0796C:  BRA    797A
0796E:  BTFSC  x05.4
07970:  BRA    799C
07972:  BTFSC  x05.3
07974:  BRA    797A
07976:  MOVLW  20
07978:  BRA    7980
0797A:  BSF    x05.3
0797C:  BCF    x05.4
0797E:  MOVLW  30
07980:  ADDWF  00,F
07982:  MOVFF  FEA,2FD
07986:  MOVFF  FE9,2FC
0798A:  MOVFF  00,31A
0798E:  MOVLB  0
07990:  RCALL  7898
07992:  MOVFF  2FD,FEA
07996:  MOVFF  2FC,FE9
0799A:  MOVLB  3
0799C:  MOVF   FEE,W
0799E:  BTFSS  x05.6
079A0:  BRA    7956
079A2:  MOVLB  0
079A4:  GOTO   813C (RETURN)
079A8:  TBLRD*+
079AA:  MOVF   FF5,F
079AC:  BZ    79C6
079AE:  MOVFF  FF6,2FC
079B2:  MOVFF  FF7,2FD
079B6:  MOVFF  FF5,31A
079BA:  RCALL  7898
079BC:  MOVFF  2FC,FF6
079C0:  MOVFF  2FD,FF7
079C4:  BRA    79A8
079C6:  RETURN 0
079C8:  MOVF   FEF,F
079CA:  BZ    79EA
079CC:  MOVFF  FEA,2FD
079D0:  MOVFF  FE9,2FC
079D4:  MOVFF  FEF,31A
079D8:  RCALL  7898
079DA:  MOVFF  2FD,FEA
079DE:  MOVFF  2FC,FE9
079E2:  INCF   FE9,F
079E4:  BTFSC  FD8.2
079E6:  INCF   FEA,F
079E8:  BRA    79C8
079EA:  GOTO   81F0 (RETURN)
*
07AB6:  MOVFF  31F,01
07ABA:  MOVFF  31E,00
07ABE:  TSTFSZ 00
07AC0:  INCF   01,F
07AC2:  TBLRD*+
07AC4:  MOVFF  FF5,FEE
07AC8:  DECFSZ 00,F
07ACA:  BRA    7AC2
07ACC:  DECFSZ 01,F
07ACE:  BRA    7AC2
07AD0:  CLRF   FF8
07AD2:  RETURN 0
*
07D58:  BTFSC  FD8.1
07D5A:  BRA    7D64
07D5C:  MOVLW  03
07D5E:  MOVWF  FEA
07D60:  MOVLW  27
07D62:  MOVWF  FE9
07D64:  MOVLB  3
07D66:  MOVF   x22,W
07D68:  XORWF  x26,W
07D6A:  ANDLW  80
07D6C:  MOVWF  x2C
07D6E:  BTFSS  x22.7
07D70:  BRA    7D88
07D72:  COMF   x1F,F
07D74:  COMF   x20,F
07D76:  COMF   x21,F
07D78:  COMF   x22,F
07D7A:  INCF   x1F,F
07D7C:  BTFSC  FD8.2
07D7E:  INCF   x20,F
07D80:  BTFSC  FD8.2
07D82:  INCF   x21,F
07D84:  BTFSC  FD8.2
07D86:  INCF   x22,F
07D88:  BTFSS  x26.7
07D8A:  BRA    7DA2
07D8C:  COMF   x23,F
07D8E:  COMF   x24,F
07D90:  COMF   x25,F
07D92:  COMF   x26,F
07D94:  INCF   x23,F
07D96:  BTFSC  FD8.2
07D98:  INCF   x24,F
07D9A:  BTFSC  FD8.2
07D9C:  INCF   x25,F
07D9E:  BTFSC  FD8.2
07DA0:  INCF   x26,F
07DA2:  CLRF   00
07DA4:  CLRF   01
07DA6:  CLRF   02
07DA8:  CLRF   03
07DAA:  CLRF   x27
07DAC:  CLRF   x28
07DAE:  CLRF   x29
07DB0:  CLRF   x2A
07DB2:  MOVF   x26,W
07DB4:  IORWF  x25,W
07DB6:  IORWF  x24,W
07DB8:  IORWF  x23,W
07DBA:  BZ    7E14
07DBC:  MOVLW  20
07DBE:  MOVWF  x2B
07DC0:  BCF    FD8.0
07DC2:  RLCF   x1F,F
07DC4:  RLCF   x20,F
07DC6:  RLCF   x21,F
07DC8:  RLCF   x22,F
07DCA:  RLCF   x27,F
07DCC:  RLCF   x28,F
07DCE:  RLCF   x29,F
07DD0:  RLCF   x2A,F
07DD2:  MOVF   x26,W
07DD4:  SUBWF  x2A,W
07DD6:  BNZ   7DE8
07DD8:  MOVF   x25,W
07DDA:  SUBWF  x29,W
07DDC:  BNZ   7DE8
07DDE:  MOVF   x24,W
07DE0:  SUBWF  x28,W
07DE2:  BNZ   7DE8
07DE4:  MOVF   x23,W
07DE6:  SUBWF  x27,W
07DE8:  BNC   7E08
07DEA:  MOVF   x23,W
07DEC:  SUBWF  x27,F
07DEE:  MOVF   x24,W
07DF0:  BTFSS  FD8.0
07DF2:  INCFSZ x24,W
07DF4:  SUBWF  x28,F
07DF6:  MOVF   x25,W
07DF8:  BTFSS  FD8.0
07DFA:  INCFSZ x25,W
07DFC:  SUBWF  x29,F
07DFE:  MOVF   x26,W
07E00:  BTFSS  FD8.0
07E02:  INCFSZ x26,W
07E04:  SUBWF  x2A,F
07E06:  BSF    FD8.0
07E08:  RLCF   00,F
07E0A:  RLCF   01,F
07E0C:  RLCF   02,F
07E0E:  RLCF   03,F
07E10:  DECFSZ x2B,F
07E12:  BRA    7DC0
07E14:  BTFSS  x2C.7
07E16:  BRA    7E2E
07E18:  COMF   00,F
07E1A:  COMF   01,F
07E1C:  COMF   02,F
07E1E:  COMF   03,F
07E20:  INCF   00,F
07E22:  BTFSC  FD8.2
07E24:  INCF   01,F
07E26:  BTFSC  FD8.2
07E28:  INCF   02,F
07E2A:  BTFSC  FD8.2
07E2C:  INCF   03,F
07E2E:  MOVFF  327,FEF
07E32:  MOVFF  328,FEC
07E36:  MOVFF  329,FEC
07E3A:  MOVFF  32A,FEC
07E3E:  MOVLB  0
07E40:  GOTO   7FD8 (RETURN)
07E44:  TBLRD*+
07E46:  MOVFF  FF6,31C
07E4A:  MOVFF  FF7,31D
07E4E:  MOVFF  FF5,324
07E52:  CALL   6FA4
07E56:  MOVFF  31C,FF6
07E5A:  MOVFF  31D,FF7
07E5E:  MOVLB  3
07E60:  DECFSZ x1B,F
07E62:  BRA    7E66
07E64:  BRA    7E6A
07E66:  MOVLB  0
07E68:  BRA    7E44
07E6A:  MOVLB  0
07E6C:  RETURN 0
07E6E:  TBLRD*+
07E70:  MOVF   FF5,F
07E72:  BZ    7E8E
07E74:  MOVFF  FF6,31B
07E78:  MOVFF  FF7,31C
07E7C:  MOVFF  FF5,324
07E80:  CALL   6FA4
07E84:  MOVFF  31B,FF6
07E88:  MOVFF  31C,FF7
07E8C:  BRA    7E6E
07E8E:  GOTO   8006 (RETURN)
07E92:  MOVFF  FEA,323
07E96:  MOVFF  FE9,322
07E9A:  MOVLB  3
07E9C:  SWAPF  x1C,W
07E9E:  IORLW  F0
07EA0:  MOVWF  x1E
07EA2:  ADDWF  x1E,F
07EA4:  ADDLW  E2
07EA6:  MOVWF  x1F
07EA8:  ADDLW  32
07EAA:  MOVWF  x21
07EAC:  MOVF   x1C,W
07EAE:  ANDLW  0F
07EB0:  ADDWF  x1F,F
07EB2:  ADDWF  x1F,F
07EB4:  ADDWF  x21,F
07EB6:  ADDLW  E9
07EB8:  MOVWF  x20
07EBA:  ADDWF  x20,F
07EBC:  ADDWF  x20,F
07EBE:  SWAPF  x1B,W
07EC0:  ANDLW  0F
07EC2:  ADDWF  x20,F
07EC4:  ADDWF  x21,F
07EC6:  RLCF   x20,F
07EC8:  RLCF   x21,F
07ECA:  COMF   x21,F
07ECC:  RLCF   x21,F
07ECE:  MOVF   x1B,W
07ED0:  ANDLW  0F
07ED2:  ADDWF  x21,F
07ED4:  RLCF   x1E,F
07ED6:  MOVLW  07
07ED8:  MOVWF  x1D
07EDA:  MOVLW  0A
07EDC:  DECF   x20,F
07EDE:  ADDWF  x21,F
07EE0:  BNC   7EDC
07EE2:  DECF   x1F,F
07EE4:  ADDWF  x20,F
07EE6:  BNC   7EE2
07EE8:  DECF   x1E,F
07EEA:  ADDWF  x1F,F
07EEC:  BNC   7EE8
07EEE:  DECF   x1D,F
07EF0:  ADDWF  x1E,F
07EF2:  BNC   7EEE
07EF4:  MOVLW  03
07EF6:  MOVWF  FEA
07EF8:  MOVLW  1D
07EFA:  MOVWF  FE9
07EFC:  MOVLW  07
07EFE:  ANDWF  x22,W
07F00:  BCF    x22.6
07F02:  ADDWF  FE9,F
07F04:  MOVLW  00
07F06:  ADDWFC FEA,F
07F08:  MOVF   FE9,W
07F0A:  SUBLW  21
07F0C:  BNZ   7F16
07F0E:  MOVF   FEA,W
07F10:  SUBLW  03
07F12:  BNZ   7F16
07F14:  BSF    x22.6
07F16:  MOVF   FEF,W
07F18:  MOVWF  00
07F1A:  BNZ   7F2C
07F1C:  BTFSC  x22.6
07F1E:  BRA    7F2C
07F20:  BTFSC  x22.4
07F22:  BRA    7F50
07F24:  BTFSC  x22.3
07F26:  BRA    7F2C
07F28:  MOVLW  20
07F2A:  BRA    7F32
07F2C:  BSF    x22.3
07F2E:  BCF    x22.4
07F30:  MOVLW  30
07F32:  ADDWF  00,F
07F34:  MOVFF  FEA,31C
07F38:  MOVFF  FE9,31B
07F3C:  MOVFF  00,324
07F40:  MOVLB  0
07F42:  CALL   6FA4
07F46:  MOVFF  31C,FEA
07F4A:  MOVFF  31B,FE9
07F4E:  MOVLB  3
07F50:  MOVF   FEE,W
07F52:  BTFSS  x22.6
07F54:  BRA    7F08
07F56:  MOVLB  0
07F58:  GOTO   8026 (RETURN)
....................  
.................... #list 
....................  
....................    #include "tcpip\p18cxxx.h" 
.................... // CCS PCH C Compiler to Microchip C18 Compiler compatability layer. 
....................  
.................... #ifndef __P18CXXXX_H__ 
.................... #define __P18CXXXX_H__ 
....................  
.................... #ifndef __18CXX 
.................... #define __18CXX 
.................... #endif 
....................  
.................... //#zero_local_ram 
.................... #zero_ram 
....................  
....................  
.................... #device PASS_STRINGS=IN_RAM 
.................... #device CONST=READ_ONLY 
....................  
.................... #case 
.................... #type signed 
.................... #type short=16 int=16 long=32 
....................  
.................... #define _asm #asm 
.................... #define _endasm #endasm 
....................  
.................... /* usualy 
.................... #define GetSystemClock()      getenv("CLOCK") 
.................... #define GetInstructionClock()   (GetSystemClock()/4) 
.................... #define GetPeripheralClock()   (unsigned int32)GetInstructionClock() 
.................... */ 
....................  
.................... #if getenv("DEVICE") == "PIC18F97J60" 
....................  #define __18F97J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F96J65" 
....................  #define __18F96J65) 
.................... #elif getenv("DEVICE") == "PIC18F96J60" 
....................  #define __18F96J60 
.................... #elif getenv("DEVICE") == "PIC18F87J60" 
....................  #define __18F87J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J60" 
....................  #define __18F86J60 
.................... #elif getenv("DEVICE") == "PIC18F67J60" 
....................  #define __18F67J60 
....................  #include "PIC18F67J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F66J65" 
....................  #define __18F66J65 
.................... #elif getenv("DEVICE") == "PIC18F66J60" 
....................  #define __18F66J60 
.................... #elif getenv("DEVICE") == "PIC18F67K22" 
....................  #define __18F67K22 
....................  #include "PIC18F67K22_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F4620" 
....................  #define __18F4620 
....................  #include "PIC18F4620_registers.h" 
.................... #byte TOSU = 0xFFF 
....................  
.................... #byte TOSH = 0xFFE 
....................  
.................... #byte TOSL = 0xFFD 
....................  
.................... struct STKPTRBITS { 
....................    unsigned int STKPTR0:1; 
....................    unsigned int STKPTR1:1; 
....................    unsigned int STKPTR2:1; 
....................    unsigned int STKPTR3:1; 
....................    unsigned int STKPTR4:1; 
....................    unsigned int :1; 
....................    unsigned int STKUNF:1; 
....................    unsigned int STKFUL:1; 
.................... } STKPTRbits; 
.................... #byte STKPTRbits = 0xFFC 
.................... #byte STKPTR = 0xFFC 
....................  
.................... #byte PCLATU = 0xFFB 
....................  
.................... #byte PCLATH = 0xFFA 
....................  
.................... #byte PCL = 0xFF9 
....................  
.................... struct TBLPTRUBITS { 
....................    unsigned int TBLPTRU0:1; 
....................    unsigned int TBLPTRU1:1; 
....................    unsigned int TBLPTRU2:1; 
....................    unsigned int TBLPTRU3:1; 
....................    unsigned int TBLPTRU4:1; 
....................    unsigned int ACSS:1; 
.................... } TBLPTRUbits; 
.................... #byte TBLPTRUbits = 0xFF8 
.................... #byte TBLPTRU = 0xFF8 
....................  
.................... #byte TBLPTRH = 0xFF7 
....................  
.................... #byte TBLPTRL = 0xFF6 
....................  
.................... #byte TABLAT = 0xFF5 
....................  
.................... #byte PRODH = 0xFF4 
....................  
.................... #byte PRODL = 0xFF3 
....................  
.................... struct INTCONBITS { 
....................    unsigned int RBIF:1; 
....................    unsigned int INT0IF:1; 
....................    unsigned int TMR0IF:1; 
....................    unsigned int RBIE:1; 
....................    unsigned int INT0IE:1; 
....................    unsigned int TMR0IE:1; 
....................    unsigned int PEIE_GIEL:1; 
....................    unsigned int GIE_GIEH:1; 
.................... } INTCONbits; 
.................... #byte INTCONbits = 0xFF2 
.................... #byte INTCON = 0xFF2 
....................  
.................... struct INTCON2BITS { 
....................    unsigned int RBIP:1; 
....................    unsigned int :1; 
....................    unsigned int TMR0IP:1; 
....................    unsigned int :1; 
....................    unsigned int INTEDG4:1; 
....................    unsigned int INTEDG5:1; 
....................    unsigned int INTEDG6:1; 
....................    unsigned int RBPU:1; 
.................... } INTCON2bits; 
.................... #byte INTCON2bits = 0xFF1 
.................... #byte INTCON2 = 0xFF1 
....................  
.................... struct INTCON3BITS { 
....................    unsigned int INT1IF:1; 
....................    unsigned int INT2IF:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IE:1; 
....................    unsigned int INT2IE:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IP:1; 
....................    unsigned int INT2IP:1; 
.................... } INTCON3bits; 
.................... #byte INTCON3bits = 0xFF0 
.................... #byte INTCON3 = 0xFF0 
....................  
.................... #byte INDF0 = 0xFEF 
....................  
.................... #byte POSTINC0 = 0xFEE 
....................  
.................... #byte POSTDEC0 = 0xFED 
....................  
.................... #byte PREINC0 = 0xFEC 
....................  
.................... #byte PLUSW0 = 0xFEB 
....................  
.................... #byte FSR0H = 0xFEA 
....................  
.................... #byte FSR0L = 0xFE9 
....................  
.................... #byte WREG = 0xFE8 
....................  
.................... #byte INDF1 = 0xFE7 
....................  
.................... #byte POSTINC1 = 0xFE6 
....................  
.................... #byte POSTDEC1 = 0xFE5 
....................  
.................... #byte PREINC1 = 0xFE4 
....................  
.................... #byte PLUSW1 = 0xFE3 
....................  
.................... #byte FSR1H = 0xFE2 
....................  
.................... #byte FSR1L = 0xFE1 
....................  
.................... #byte BSR = 0xFE0 
....................  
.................... #byte INDF2 = 0xFDF 
....................  
.................... #byte POSTINC2 = 0xFDE 
....................  
.................... #byte POSTDEC2 = 0xFDD 
....................  
.................... #byte PREINC2 = 0xFDC 
....................  
.................... #byte PLUSW2 = 0xFDB 
....................  
.................... #byte FSR2H = 0xFDA 
....................  
.................... #byte FSR2L = 0xFD9 
....................  
.................... struct STATUSBITS { 
....................    unsigned int C:1; 
....................    unsigned int DC:1; 
....................    unsigned int Z:1; 
....................    unsigned int OV:1; 
....................    unsigned int N:1; 
.................... } STATUSbits; 
.................... #byte STATUSbits = 0xFD8 
.................... #byte STATUS = 0xFD8 
....................  
.................... #byte TMR0H = 0xFD7 
....................  
.................... #byte TMR0L = 0xFD6 
....................  
.................... struct T0CONBITS { 
....................    unsigned int T0PS0:1; 
....................    unsigned int T0PS1:1; 
....................    unsigned int T0PS2:1; 
....................    unsigned int PSA:1; 
....................    unsigned int T0SE:1; 
....................    unsigned int T0CS:1; 
....................    unsigned int T08BIT:1; 
....................    unsigned int TMR0ON:1; 
.................... } T0CONbits; 
.................... #byte T0CONbits = 0xFD5 
.................... #byte T0CON = 0xFD5 
....................  
.................... struct OSCCONBITS { 
....................    unsigned int SCS0:1; 
....................    unsigned int SCS1:1; 
....................    unsigned int IOFS:1; 
....................    unsigned int OSTS:1; 
....................    unsigned int IRCF4:1; 
....................    unsigned int IRCF5:1; 
....................    unsigned int IRCF6:1; 
....................    unsigned int IDLEN:1; 
.................... } OSCCONbits; 
.................... #byte OSCCONbits = 0xFD3 
.................... #byte OSCCON = 0xFD3 
....................  
.................... struct HLVDCONBITS { 
....................    unsigned int HLVDL0:1; 
....................    unsigned int HLVDL1:1; 
....................    unsigned int HLVDL2:1; 
....................    unsigned int HLVDL3:1; 
....................    unsigned int HLVDEN:1; 
....................    unsigned int IVRST:1; 
....................    unsigned int :1; 
....................    unsigned int VDIRMAG:1; 
.................... } HLVDCONbits; 
.................... #byte HLVDCONbits = 0xFD2 
.................... #byte HLVDCON = 0xFD2 
....................  
.................... struct WDTCONBITS { 
....................    unsigned int SWDTEN:1; 
.................... } WDTCONbits; 
.................... #byte WDTCONbits = 0xFD1 
.................... #byte WDTCON = 0xFD1 
....................  
.................... struct RCONBITS { 
....................    unsigned int BOR:1; 
....................    unsigned int POR:1; 
....................    unsigned int PD:1; 
....................    unsigned int TO:1; 
....................    unsigned int RI:1; 
....................    unsigned int :1; 
....................    unsigned int SBOREN:1; 
....................    unsigned int IPEN:1; 
.................... } RCONbits; 
.................... #byte RCONbits = 0xFD0 
.................... #byte RCON = 0xFD0 
....................  
.................... #byte TMR1H = 0xFCF 
....................  
.................... #byte TMR1L = 0xFCE 
....................  
.................... struct T1CONBITS { 
....................    unsigned int TMR1ON:1; 
....................    unsigned int TMR1CS:1; 
....................    unsigned int T1SYNC:1; 
....................    unsigned int T1OSCEN:1; 
....................    unsigned int T1CKPS4:1; 
....................    unsigned int T1CKPS5:1; 
....................    unsigned int T1RUN:1; 
....................    unsigned int RD16:1; 
.................... } T1CONbits; 
.................... #byte T1CONbits = 0xFCD 
.................... #byte T1CON = 0xFCD 
....................  
.................... #byte TMR2 = 0xFCC 
....................  
.................... #byte PR2 = 0xFCB 
....................  
.................... struct T2CONBITS { 
....................    unsigned int T2CKPS0:1; 
....................    unsigned int T2CKPS1:1; 
....................    unsigned int TMR2ON:1; 
....................    unsigned int TOUTPS:4; 
.................... } T2CONbits; 
.................... #byte T2CONbits = 0xFCA 
.................... #byte T2CON = 0xFCA 
....................  
.................... #byte SSPBUF = 0xFC9 
....................  
.................... #byte SSPADD = 0xFC8 
....................  
.................... struct SSPSTATBITS { 
....................    unsigned int BF:1; 
....................    unsigned int UA:1; 
....................    unsigned int R:1; 
....................    unsigned int S:1; 
....................    unsigned int P:1; 
....................    unsigned int D:1; 
....................    unsigned int CKE:1; 
....................    unsigned int SMP:1; 
.................... } SSPSTATbits; 
.................... #byte SSPSTATbits = 0xFC7 
.................... #byte SSPSTAT = 0xFC7 
....................  
.................... struct SSPCON1BITS { 
....................    unsigned int SSPM0:1; 
....................    unsigned int SSPM1:1; 
....................    unsigned int SSPM2:1; 
....................    unsigned int SSPM3:1; 
....................    unsigned int CKP:1; 
....................    unsigned int SSPEN:1; 
....................    unsigned int SSPOV:1; 
....................    unsigned int WCOL:1; 
.................... } SSPCON1bits; 
.................... #byte SSPCON1bits = 0xFC6 
.................... #byte SSPCON1 = 0xFC6 
....................  
.................... struct SSPCON2BITS { 
....................    unsigned int SEN:1; 
....................    unsigned int RSEN:1; 
....................    unsigned int PEN:1; 
....................    unsigned int RCEN:1; 
....................    unsigned int ACKEN:1; 
....................    unsigned int ACKDT:1; 
....................    unsigned int ACKSTAT:1; 
....................    unsigned int GCEN:1; 
.................... } SSPCON2bits; 
.................... #byte SSPCON2bits = 0xFC5 
.................... #byte SSPCON2 = 0xFC5 
....................  
.................... #byte ADRESH = 0xFC4 
....................  
.................... #byte ADRESL = 0xFC3 
....................  
.................... struct ADCON0BITS { 
....................    unsigned int ADON:1; 
....................    unsigned int GO:1; 
....................    unsigned int CHS:4; 
.................... } ADCON0bits; 
.................... #byte ADCON0bits = 0xFC2 
.................... #byte ADCON0 = 0xFC2 
....................  
.................... struct ADCON1BITS { 
....................    unsigned int PCFG0:1; 
....................    unsigned int PCFG1:1; 
....................    unsigned int PCFG2:1; 
....................    unsigned int PCFG3:1; 
....................    unsigned int VCFG4:1; 
....................    unsigned int VCFG1:1; 
.................... } ADCON1bits; 
.................... #byte ADCON1bits = 0xFC1 
.................... #byte ADCON1 = 0xFC1 
....................  
.................... struct ADCON2BITS { 
....................    unsigned int ADCS0:1; 
....................    unsigned int ADCS1:1; 
....................    unsigned int ADCS2:1; 
....................    unsigned int ACQT3:1; 
....................    unsigned int ACQT4:1; 
....................    unsigned int ACQT2:1; 
....................    unsigned int :1; 
....................    unsigned int ADFM:1; 
.................... } ADCON2bits; 
.................... #byte ADCON2bits = 0xFC0 
.................... #byte ADCON2 = 0xFC0 
....................  
.................... #byte CCPR1H = 0xFBF 
....................  
.................... #byte CCPR1L = 0xFBE 
....................  
.................... struct CCP1CONBITS { 
....................    unsigned int CCP1M0:1; 
....................    unsigned int CCP1M1:1; 
....................    unsigned int CCP1M2:1; 
....................    unsigned int CCP1M3:1; 
....................    unsigned int DC1B4:1; 
....................    unsigned int DC1B5:1; 
....................    unsigned int P1M6:1; 
....................    unsigned int P1M1:1; 
.................... } CCP1CONbits; 
.................... #byte CCP1CONbits = 0xFBD 
.................... #byte CCP1CON = 0xFBD 
....................  
.................... #byte CCPR2H = 0xFBC 
....................  
.................... #byte CCPR2L = 0xFBB 
....................  
.................... struct CCP2CONBITS { 
....................    unsigned int CCP2M0:1; 
....................    unsigned int CCP2M1:1; 
....................    unsigned int CCP2M2:1; 
....................    unsigned int CCP2M3:1; 
....................    unsigned int DC2B4:1; 
....................    unsigned int DC2B1:1; 
.................... } CCP2CONbits; 
.................... #byte CCP2CONbits = 0xFBA 
.................... #byte CCP2CON = 0xFBA 
....................  
.................... struct BAUDCONBITS { 
....................    unsigned int ABDEN:1; 
....................    unsigned int WUE:1; 
....................    unsigned int :1; 
....................    unsigned int BRG1:1; 
....................    unsigned int TXCKP:1; 
....................    unsigned int RXDTP:1; 
....................    unsigned int RCIDL:1; 
....................    unsigned int ABDOVF:1; 
.................... } BAUDCONbits; 
.................... #byte BAUDCONbits = 0xFB8 
.................... #byte BAUDCON = 0xFB8 
....................  
.................... struct PWM1CONBITS { 
....................    unsigned int PDC0:1; 
....................    unsigned int PDC1:1; 
....................    unsigned int PDC2:1; 
....................    unsigned int PDC3:1; 
....................    unsigned int PDC4:1; 
....................    unsigned int PDC5:1; 
....................    unsigned int PDC6:1; 
....................    unsigned int PRSEN:1; 
.................... } PWM1CONbits; 
.................... #byte PWM1CONbits = 0xFB7 
.................... #byte PWM1CON = 0xFB7 
....................  
.................... struct ECCP1ASBITS { 
....................    unsigned int PSSBD0:1; 
....................    unsigned int PSSBD1:1; 
....................    unsigned int PSSAC2:1; 
....................    unsigned int PSSAC3:1; 
....................    unsigned int ECCPAS4:1; 
....................    unsigned int ECCPAS5:1; 
....................    unsigned int ECCPAS6:1; 
....................    unsigned int ECCPASE:1; 
.................... } ECCP1ASbits; 
.................... #byte ECCP1ASbits = 0xFB6 
.................... #byte ECCP1AS = 0xFB6 
....................  
.................... struct CVRCONBITS { 
....................    unsigned int CVR0:1; 
....................    unsigned int CVR1:1; 
....................    unsigned int CVR2:1; 
....................    unsigned int CVR3:1; 
....................    unsigned int CVRSS:1; 
....................    unsigned int CVRR:1; 
....................    unsigned int CVROE:1; 
....................    unsigned int CVREN:1; 
.................... } CVRCONbits; 
.................... #byte CVRCONbits = 0xFB5 
.................... #byte CVRCON = 0xFB5 
....................  
.................... struct CMCONBITS { 
....................    unsigned int CM0:1; 
....................    unsigned int CM1:1; 
....................    unsigned int CM2:1; 
....................    unsigned int CIS:1; 
....................    unsigned int C1INV:1; 
....................    unsigned int C2INV:1; 
....................    unsigned int C1OUT:1; 
....................    unsigned int C2OUT:1; 
.................... } CMCONbits; 
.................... #byte CMCONbits = 0xFB4 
.................... #byte CMCON = 0xFB4 
....................  
.................... #byte TMR3H = 0xFB3 
....................  
.................... #byte TMR3L = 0xFB2 
....................  
.................... struct T3CONBITS { 
....................    unsigned int TMR3ON:1; 
....................    unsigned int TMR3CS:1; 
....................    unsigned int T3SYNC:1; 
....................    unsigned int T3CCP3:1; 
....................    unsigned int T3CKPS4:1; 
....................    unsigned int T3CKPS5:1; 
....................    unsigned int T3CCP6:1; 
....................    unsigned int RD16:1; 
.................... } T3CONbits; 
.................... #byte T3CONbits = 0xFB1 
.................... #byte T3CON = 0xFB1 
....................  
.................... #byte SPBRGH = 0xFB0 
....................  
.................... #byte SPBRG = 0xFAF 
....................  
.................... #byte RCREG = 0xFAE 
....................  
.................... #byte TXREG = 0xFAD 
....................  
.................... struct TXSTABITS { 
....................    unsigned int TX9D:1; 
....................    unsigned int TRMT:1; 
....................    unsigned int BRGH:1; 
....................    unsigned int SENDB:1; 
....................    unsigned int SYNC:1; 
....................    unsigned int TXEN:1; 
....................    unsigned int TX:1; 
....................    unsigned int CSRC:1; 
.................... } TXSTAbits; 
.................... #byte TXSTAbits = 0xFAC 
.................... #byte TXSTA = 0xFAC 
....................  
.................... struct RCSTABITS { 
....................    unsigned int RX9D:1; 
....................    unsigned int OERR:1; 
....................    unsigned int FERR:1; 
....................    unsigned int ADDEN:1; 
....................    unsigned int CREN:1; 
....................    unsigned int SREN:1; 
....................    unsigned int RX:1; 
....................    unsigned int SPEN:1; 
.................... } RCSTAbits; 
.................... #byte RCSTAbits = 0xFAB 
.................... #byte RCSTA = 0xFAB 
....................  
.................... #byte EEADRH = 0xFAA 
....................  
.................... #byte EEADR = 0xFA9 
....................  
.................... #byte EEDATA = 0xFA8 
....................  
.................... #byte EECON2 = 0xFA7 
....................  
.................... struct EECON1BITS { 
....................    unsigned int RD:1; 
....................    unsigned int WR:1; 
....................    unsigned int WREN:1; 
....................    unsigned int WRERR:1; 
....................    unsigned int FREE:1; 
....................    unsigned int :1; 
....................    unsigned int CFGS:1; 
....................    unsigned int EEPGD:1; 
.................... } EECON1bits; 
.................... #byte EECON1bits = 0xFA6 
.................... #byte EECON1 = 0xFA6 
....................  
.................... struct IPR2BITS { 
....................    unsigned int CCP2IP:1; 
....................    unsigned int TMR3IP:1; 
....................    unsigned int HLVDIP:1; 
....................    unsigned int BCLIP:1; 
....................    unsigned int EEIP:1; 
....................    unsigned int :1; 
....................    unsigned int CMIP:1; 
....................    unsigned int OSCFIP:1; 
.................... } IPR2bits; 
.................... #byte IPR2bits = 0xFA2 
.................... #byte IPR2 = 0xFA2 
....................  
.................... struct PIR2BITS { 
....................    unsigned int CCP2IF:1; 
....................    unsigned int TMR3IF:1; 
....................    unsigned int HLVDIF:1; 
....................    unsigned int BCLIF:1; 
....................    unsigned int EEIF:1; 
....................    unsigned int :1; 
....................    unsigned int CMIF:1; 
....................    unsigned int OSCFIF:1; 
.................... } PIR2bits; 
.................... #byte PIR2bits = 0xFA1 
.................... #byte PIR2 = 0xFA1 
....................  
.................... struct PIE2BITS { 
....................    unsigned int CCP2IE:1; 
....................    unsigned int TMR3IE:1; 
....................    unsigned int HLVDIE:1; 
....................    unsigned int BCLIE:1; 
....................    unsigned int EEIE:1; 
....................    unsigned int :1; 
....................    unsigned int CMIE:1; 
....................    unsigned int OSCFIE:1; 
.................... } PIE2bits; 
.................... #byte PIE2bits = 0xFA0 
.................... #byte PIE2 = 0xFA0 
....................  
.................... struct IPR1BITS { 
....................    unsigned int TMR1IP:1; 
....................    unsigned int TMR2IP:1; 
....................    unsigned int CCP1IP:1; 
....................    unsigned int SSPIP:1; 
....................    unsigned int TXIP:1; 
....................    unsigned int RCIP:1; 
....................    unsigned int ADIP:1; 
....................    unsigned int PSPIP:1; 
.................... } IPR1bits; 
.................... #byte IPR1bits = 0xF9F 
.................... #byte IPR1 = 0xF9F 
....................  
.................... struct PIR1BITS { 
....................    unsigned int TMR1IF:1; 
....................    unsigned int TMR2IF:1; 
....................    unsigned int CCP1IF:1; 
....................    unsigned int SSPIF:1; 
....................    unsigned int TXIF:1; 
....................    unsigned int RCIF:1; 
....................    unsigned int ADIF:1; 
....................    unsigned int PSPIF:1; 
.................... } PIR1bits; 
.................... #byte PIR1bits = 0xF9E 
.................... #byte PIR1 = 0xF9E 
....................  
.................... struct PIE1BITS { 
....................    unsigned int TMR1IE:1; 
....................    unsigned int TMR2IE:1; 
....................    unsigned int CCP1IE:1; 
....................    unsigned int SSPIE:1; 
....................    unsigned int TXIE:1; 
....................    unsigned int RCIE:1; 
....................    unsigned int ADIE:1; 
....................    unsigned int PSPIE:1; 
.................... } PIE1bits; 
.................... #byte PIE1bits = 0xF9D 
.................... #byte PIE1 = 0xF9D 
....................  
.................... struct OSCTUNEBITS { 
....................    unsigned int TUN0:1; 
....................    unsigned int TUN1:1; 
....................    unsigned int TUN2:1; 
....................    unsigned int TUN3:1; 
....................    unsigned int TUN4:1; 
....................    unsigned int :1; 
....................    unsigned int PLLEN:1; 
....................    unsigned int INTSRC:1; 
.................... } OSCTUNEbits; 
.................... #byte OSCTUNEbits = 0xF9B 
.................... #byte OSCTUNE = 0xF9B 
....................  
.................... struct TRISEBITS { 
....................    unsigned int TRISE0:1; 
....................    unsigned int TRISE1:1; 
....................    unsigned int TRISE2:1; 
....................    unsigned int :1; 
....................    unsigned int PSPMODE:1; 
....................    unsigned int IBOV:1; 
....................    unsigned int OBF:1; 
....................    unsigned int IBF:1; 
.................... } TRISEbits; 
.................... #byte TRISEbits = 0xF96 
.................... #byte TRISE = 0xF96 
....................  
.................... struct TRISDBITS { 
....................    unsigned int TRISD0:1; 
....................    unsigned int TRISD1:1; 
....................    unsigned int TRISD2:1; 
....................    unsigned int TRISD3:1; 
....................    unsigned int TRISD4:1; 
....................    unsigned int TRISD5:1; 
....................    unsigned int TRISD6:1; 
....................    unsigned int TRISD7:1; 
.................... } TRISDbits; 
.................... #byte TRISDbits = 0xF95 
.................... #byte TRISD = 0xF95 
....................  
.................... struct TRISCBITS { 
....................    unsigned int TRISC0:1; 
....................    unsigned int TRISC1:1; 
....................    unsigned int TRISC2:1; 
....................    unsigned int TRISC3:1; 
....................    unsigned int TRISC4:1; 
....................    unsigned int TRISC5:1; 
....................    unsigned int TRISC6:1; 
....................    unsigned int TRISC7:1; 
.................... } TRISCbits; 
.................... #byte TRISCbits = 0xF94 
.................... #byte TRISC = 0xF94 
....................  
.................... struct TRISBBITS { 
....................    unsigned int TRISB0:1; 
....................    unsigned int TRISB1:1; 
....................    unsigned int TRISB2:1; 
....................    unsigned int TRISB3:1; 
....................    unsigned int TRISB4:1; 
....................    unsigned int TRISB5:1; 
....................    unsigned int TRISB6:1; 
....................    unsigned int TRISB7:1; 
.................... } TRISBbits; 
.................... #byte TRISBbits = 0xF93 
.................... #byte TRISB = 0xF93 
....................  
.................... struct TRISABITS { 
....................    unsigned int TRISA0:1; 
....................    unsigned int TRISA1:1; 
....................    unsigned int TRISA2:1; 
....................    unsigned int TRISA3:1; 
....................    unsigned int TRISA4:1; 
....................    unsigned int TRISA5:1; 
....................    unsigned int TRISA6:1; 
....................    unsigned int TRISA7:1; 
.................... } TRISAbits; 
.................... #byte TRISAbits = 0xF92 
.................... #byte TRISA = 0xF92 
....................  
.................... struct LATEBITS { 
....................    unsigned int LATE0:1; 
....................    unsigned int LATE1:1; 
....................    unsigned int LATE2:1; 
....................    unsigned int LATE3:1; 
....................    unsigned int LATE4:1; 
....................    unsigned int LATE5:1; 
....................    unsigned int LATE6:1; 
....................    unsigned int LATE7:1; 
.................... } LATEbits; 
.................... #byte LATEbits = 0xF8D 
.................... #byte LATE = 0xF8D 
....................  
.................... struct LATDBITS { 
....................    unsigned int LATD0:1; 
....................    unsigned int LATD1:1; 
....................    unsigned int LATD2:1; 
....................    unsigned int LATD3:1; 
....................    unsigned int LATD4:1; 
....................    unsigned int LATD5:1; 
....................    unsigned int LATD6:1; 
....................    unsigned int LATD7:1; 
.................... } LATDbits; 
.................... #byte LATDbits = 0xF8C 
.................... #byte LATD = 0xF8C 
....................  
.................... struct LATCBITS { 
....................    unsigned int LATC0:1; 
....................    unsigned int LATC1:1; 
....................    unsigned int LATC2:1; 
....................    unsigned int LATC3:1; 
....................    unsigned int LATC4:1; 
....................    unsigned int LATC5:1; 
....................    unsigned int LATC6:1; 
....................    unsigned int LATC7:1; 
.................... } LATCbits; 
.................... #byte LATCbits = 0xF8B 
.................... #byte LATC = 0xF8B 
....................  
.................... struct LATBBITS { 
....................    unsigned int LATB0:1; 
....................    unsigned int LATB1:1; 
....................    unsigned int LATB2:1; 
....................    unsigned int LATB3:1; 
....................    unsigned int LATB4:1; 
....................    unsigned int LATB5:1; 
....................    unsigned int LATB6:1; 
....................    unsigned int LATB7:1; 
.................... } LATBbits; 
.................... #byte LATBbits = 0xF8A 
.................... #byte LATB = 0xF8A 
....................  
.................... struct LATABITS { 
....................    unsigned int LATA0:1; 
....................    unsigned int LATA1:1; 
....................    unsigned int LATA2:1; 
....................    unsigned int LATA3:1; 
....................    unsigned int LATA4:1; 
....................    unsigned int LATA5:1; 
....................    unsigned int LATA6:1; 
....................    unsigned int LATA7:1; 
.................... } LATAbits; 
.................... #byte LATAbits = 0xF89 
.................... #byte LATA = 0xF89 
....................  
.................... struct PORTEBITS { 
....................    unsigned int RE0:1; 
....................    unsigned int RE1:1; 
....................    unsigned int RE2:1; 
....................    unsigned int RE3:1; 
....................    unsigned int RE4:1; 
....................    unsigned int RE5:1; 
....................    unsigned int RE6:1; 
....................    unsigned int RE7:1; 
.................... } PORTEbits; 
.................... #byte PORTEbits = 0xF84 
.................... #byte PORTE = 0xF84 
....................  
.................... struct PORTDBITS { 
....................    unsigned int RD0:1; 
....................    unsigned int RD1:1; 
....................    unsigned int RD2:1; 
....................    unsigned int RD3:1; 
....................    unsigned int RD4:1; 
....................    unsigned int RD5:1; 
....................    unsigned int RD6:1; 
....................    unsigned int RD7:1; 
.................... } PORTDbits; 
.................... #byte PORTDbits = 0xF83 
.................... #byte PORTD = 0xF83 
....................  
.................... struct PORTCBITS { 
....................    unsigned int RC0:1; 
....................    unsigned int RC1:1; 
....................    unsigned int RC2:1; 
....................    unsigned int RC3:1; 
....................    unsigned int RC4:1; 
....................    unsigned int RC5:1; 
....................    unsigned int RC6:1; 
....................    unsigned int RC7:1; 
.................... } PORTCbits; 
.................... #byte PORTCbits = 0xF82 
.................... #byte PORTC = 0xF82 
....................  
.................... struct PORTBBITS { 
....................    unsigned int RB0:1; 
....................    unsigned int RB1:1; 
....................    unsigned int RB2:1; 
....................    unsigned int RB3:1; 
....................    unsigned int RB4:1; 
....................    unsigned int RB5:1; 
....................    unsigned int RB6:1; 
....................    unsigned int RB7:1; 
.................... } PORTBbits; 
.................... #byte PORTBbits = 0xF81 
.................... #byte PORTB = 0xF81 
....................  
.................... struct PORTABITS { 
....................    unsigned int RA0:1; 
....................    unsigned int RA1:1; 
....................    unsigned int RA2:1; 
....................    unsigned int RA3:1; 
....................    unsigned int RA4:1; 
....................    unsigned int RA5:1; 
....................    unsigned int RA6:1; 
....................    unsigned int RA7:1; 
.................... } PORTAbits; 
.................... #byte PORTAbits = 0xF80 
.................... #byte PORTA = 0xF80 
....................  
....................  
.................... #else 
....................    #error Do this for your chip 
.................... #endif 
....................  
.................... #if defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) 
....................    #reserve 0xE80:0xEFF 
....................    #reserve 0xF00:0xFFF 
.................... #endif 
....................  
.................... #if defined(TRUE) 
....................    #undef TRUE 
.................... #endif 
....................  
.................... #if defined(FALSE) 
....................    #undef FALSE 
.................... #endif 
....................  
.................... #if defined(BYTE) 
....................    #undef BYTE 
.................... #endif 
....................  
....................       #define Reset()            reset_cpu() 
....................         #define far 
....................         #define ClrWdt()         restart_wdt() 
....................       #define Nop()            delay_cycles(1)       
....................  
.................... #define __CCS__ 
....................  
.................... //signed int8 memcmppgm2ram(void * s1, rom char *s2, unsigned int8 n); 
.................... signed int8 strcmppgm2ram(char *s1, __ADDRESS__ s2); 
.................... char *strchrpgm(__ADDRESS__ s, unsigned int8 c); 
.................... char *strstrrampgm(char *s1, __ADDRESS__ s2); 
.................... unsigned int8 strlenpgm(__ADDRESS__ s); 
.................... void memcpypgm2ram(unsigned int8 *d, __ADDRESS__ s, unsigned int16 n); 
.................... //char* strupr(char *s);   now in string.h 
.................... void strcpypgm2ram(char *d, __ADDRESS__ s); 
.................... #endif 
....................  
....................    #use delay(clock=40000000) 
*
002F6:  MOVLW  03
002F8:  MOVWF  FEA
002FA:  MOVLW  1B
002FC:  MOVWF  FE9
002FE:  MOVF   FEF,W
00300:  BZ    031E
00302:  MOVLW  0C
00304:  MOVWF  01
00306:  CLRF   00
00308:  DECFSZ 00,F
0030A:  BRA    0308
0030C:  DECFSZ 01,F
0030E:  BRA    0306
00310:  MOVLW  F7
00312:  MOVWF  00
00314:  DECFSZ 00,F
00316:  BRA    0314
00318:  BRA    031A
0031A:  DECFSZ FEF,F
0031C:  BRA    0302
0031E:  RETURN 0
....................    #fuses H4, NOWDT, NOLVP, NODEBUG  
....................     
....................    #use rs232(baud=9600, uart1, stream=STREAM_UI, errors) 
....................        
....................    #define BUTTON1_PRESSED()  (!input(PIN_A4)) 
....................    #define USER_LED1    PIN_A5 
....................    #define USER_LED2    PIN_B4 
....................    #define USER_LED3    PIN_B5 
....................    #define LED_ON       output_low 
....................    #define LED_OFF      output_high 
....................    #define STANDARD_ADC_STRING  "AN0" 
....................    #define STANDARD_ADC_CHANNEL 0 
....................     
....................    #define LCD_ENABLE_PIN  PIN_E2 
....................    #define LCD_RS_PIN      PIN_E0 
....................    #define LCD_RW_PIN      PIN_E1 
....................    #define LCD_DATA4       PIN_D4 
....................    #define LCD_DATA5       PIN_D5 
....................    #define LCD_DATA6       PIN_D6 
....................    #define LCD_DATA7       PIN_D7 
....................     
....................    #ifndef STACK_USE_PICDEM_LCD 
....................       #define STACK_USE_PICDEM_LCD 1 
....................    #endif 
....................    #if STACK_USE_PICDEM_LCD 
....................       #include "lcd.c" 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
003C0:  BSF    F95.4
....................    output_float(LCD_DATA5); 
003C2:  BSF    F95.5
....................    output_float(LCD_DATA6); 
003C4:  BSF    F95.6
....................    output_float(LCD_DATA7); 
003C6:  BSF    F95.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
003C8:  BSF    F8D.1
003CA:  BCF    F96.1
....................    delay_cycles(1); 
003CC:  NOP   
....................    lcd_output_enable(1); 
003CE:  BSF    F8D.2
003D0:  BCF    F96.2
....................    delay_cycles(1); 
003D2:  NOP   
....................    high = lcd_read_nibble(); 
003D4:  RCALL  036A
003D6:  MOVFF  01,323
....................        
....................    lcd_output_enable(0); 
003DA:  BCF    F8D.2
003DC:  BCF    F96.2
....................    delay_cycles(1); 
003DE:  NOP   
....................    lcd_output_enable(1); 
003E0:  BSF    F8D.2
003E2:  BCF    F96.2
....................    delay_us(1); 
003E4:  MOVLW  02
003E6:  MOVWF  00
003E8:  DECFSZ 00,F
003EA:  BRA    03E8
003EC:  BRA    03EE
003EE:  NOP   
....................    low = lcd_read_nibble(); 
003F0:  RCALL  036A
003F2:  MOVFF  01,322
....................        
....................    lcd_output_enable(0); 
003F6:  BCF    F8D.2
003F8:  BCF    F96.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
003FA:  BCF    F95.4
....................    output_drive(LCD_DATA5); 
003FC:  BCF    F95.5
....................    output_drive(LCD_DATA6); 
003FE:  BCF    F95.6
....................    output_drive(LCD_DATA7); 
00400:  BCF    F95.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
00402:  MOVLB  3
00404:  SWAPF  x23,W
00406:  MOVWF  00
00408:  MOVLW  F0
0040A:  ANDWF  00,F
0040C:  MOVF   00,W
0040E:  IORWF  x22,W
00410:  MOVWF  01
00412:  MOVLB  0
00414:  GOTO   0424 (RETURN)
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
0036A:  MOVLB  3
0036C:  CLRF   x24
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
0036E:  BSF    F95.4
00370:  MOVLW  00
00372:  BTFSC  F83.4
00374:  MOVLW  01
00376:  IORWF  x24,F
....................    n |= input(LCD_DATA5) << 1; 
00378:  BSF    F95.5
0037A:  MOVLW  00
0037C:  BTFSC  F83.5
0037E:  MOVLW  01
00380:  MOVWF  00
00382:  BCF    FD8.0
00384:  RLCF   00,F
00386:  MOVF   00,W
00388:  IORWF  x24,F
....................    n |= input(LCD_DATA6) << 2; 
0038A:  BSF    F95.6
0038C:  MOVLW  00
0038E:  BTFSC  F83.6
00390:  MOVLW  01
00392:  MOVWF  00
00394:  RLCF   00,F
00396:  RLCF   00,F
00398:  MOVLW  FC
0039A:  ANDWF  00,F
0039C:  MOVF   00,W
0039E:  IORWF  x24,F
....................    n |= input(LCD_DATA7) << 3; 
003A0:  BSF    F95.7
003A2:  MOVLW  00
003A4:  BTFSC  F83.7
003A6:  MOVLW  01
003A8:  MOVWF  00
003AA:  RLCF   00,F
003AC:  RLCF   00,F
003AE:  RLCF   00,F
003B0:  MOVLW  F8
003B2:  ANDWF  00,F
003B4:  MOVF   00,W
003B6:  IORWF  x24,F
....................     
....................    return(n); 
003B8:  MOVFF  324,01
....................   #else 
003BC:  MOVLB  0
003BE:  RETURN 0
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
00320:  MOVLB  3
00322:  BTFSC  x23.0
00324:  BRA    032A
00326:  BCF    F8C.4
00328:  BRA    032C
0032A:  BSF    F8C.4
0032C:  BCF    F95.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0032E:  BTFSC  x23.1
00330:  BRA    0336
00332:  BCF    F8C.5
00334:  BRA    0338
00336:  BSF    F8C.5
00338:  BCF    F95.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
0033A:  BTFSC  x23.2
0033C:  BRA    0342
0033E:  BCF    F8C.6
00340:  BRA    0344
00342:  BSF    F8C.6
00344:  BCF    F95.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
00346:  BTFSC  x23.3
00348:  BRA    034E
0034A:  BCF    F8C.7
0034C:  BRA    0350
0034E:  BSF    F8C.7
00350:  BCF    F95.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
00352:  NOP   
....................    lcd_output_enable(1); 
00354:  BSF    F8D.2
00356:  BCF    F96.2
....................    delay_us(2); 
00358:  MOVLW  06
0035A:  MOVWF  00
0035C:  DECFSZ 00,F
0035E:  BRA    035C
00360:  NOP   
....................    lcd_output_enable(0); 
00362:  BCF    F8D.2
00364:  BCF    F96.2
00366:  MOVLB  0
00368:  RETURN 0
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
00418:  BCF    F96.2
....................    lcd_rs_tris(); 
0041A:  BCF    F96.0
....................    lcd_rw_tris(); 
0041C:  BCF    F96.1
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0041E:  BCF    F8D.0
00420:  BCF    F96.0
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
00422:  BRA    03C0
00424:  MOVFF  01,322
00428:  MOVLB  3
0042A:  BTFSS  01.7
0042C:  BRA    0432
0042E:  MOVLB  0
00430:  BRA    0422
....................    lcd_output_rs(address); 
00432:  MOVF   x20,F
00434:  BNZ   043A
00436:  BCF    F8D.0
00438:  BRA    043C
0043A:  BSF    F8D.0
0043C:  BCF    F96.0
....................    delay_cycles(1); 
0043E:  NOP   
....................    lcd_output_rw(0); 
00440:  BCF    F8D.1
00442:  BCF    F96.1
....................    delay_cycles(1); 
00444:  NOP   
....................    lcd_output_enable(0); 
00446:  BCF    F8D.2
00448:  BCF    F96.2
....................    lcd_send_nibble(n >> 4); 
0044A:  SWAPF  x21,W
0044C:  MOVWF  x22
0044E:  MOVLW  0F
00450:  ANDWF  x22,F
00452:  MOVFF  322,323
00456:  MOVLB  0
00458:  RCALL  0320
....................    lcd_send_nibble(n & 0xf); 
0045A:  MOVLB  3
0045C:  MOVF   x21,W
0045E:  ANDLW  0F
00460:  MOVWF  x22
00462:  MOVWF  x23
00464:  MOVLB  0
00466:  RCALL  0320
00468:  RETURN 0
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
0046A:  MOVLW  28
0046C:  MOVLB  2
0046E:  MOVWF  xE4
00470:  MOVLW  0C
00472:  MOVWF  xE5
00474:  MOVLW  01
00476:  MOVWF  xE6
00478:  MOVLW  06
0047A:  MOVWF  xE7
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0047C:  BCF    F8D.2
0047E:  BCF    F96.2
....................    lcd_output_rs(0); 
00480:  BCF    F8D.0
00482:  BCF    F96.0
....................    lcd_output_rw(0); 
00484:  BCF    F8D.1
00486:  BCF    F96.1
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
00488:  BCF    F95.4
....................    output_drive(LCD_DATA5); 
0048A:  BCF    F95.5
....................    output_drive(LCD_DATA6); 
0048C:  BCF    F95.6
....................    output_drive(LCD_DATA7); 
0048E:  BCF    F95.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
00490:  BCF    F96.2
....................    lcd_rs_tris(); 
00492:  BCF    F96.0
....................    lcd_rw_tris(); 
00494:  BCF    F96.1
....................  #endif 
....................      
....................    delay_ms(15); 
00496:  MOVLW  0F
00498:  MOVLB  3
0049A:  MOVWF  x1B
0049C:  MOVLB  0
0049E:  RCALL  02F6
....................    for(i=1;i<=3;++i) 
004A0:  MOVLW  01
004A2:  MOVLB  2
004A4:  MOVWF  xE3
004A6:  MOVF   xE3,W
004A8:  SUBLW  03
004AA:  BNC   04C6
....................    { 
....................        lcd_send_nibble(3); 
004AC:  MOVLW  03
004AE:  MOVLB  3
004B0:  MOVWF  x23
004B2:  MOVLB  0
004B4:  RCALL  0320
....................        delay_ms(5); 
004B6:  MOVLW  05
004B8:  MOVLB  3
004BA:  MOVWF  x1B
004BC:  MOVLB  0
004BE:  RCALL  02F6
004C0:  MOVLB  2
004C2:  INCF   xE3,F
004C4:  BRA    04A6
....................    } 
....................     
....................    lcd_send_nibble(2); 
004C6:  MOVLW  02
004C8:  MOVLB  3
004CA:  MOVWF  x23
004CC:  MOVLB  0
004CE:  RCALL  0320
....................    delay_ms(5); 
004D0:  MOVLW  05
004D2:  MOVLB  3
004D4:  MOVWF  x1B
004D6:  MOVLB  0
004D8:  RCALL  02F6
....................    for(i=0;i<=3;++i) 
004DA:  MOVLB  2
004DC:  CLRF   xE3
004DE:  MOVF   xE3,W
004E0:  SUBLW  03
004E2:  BNC   0508
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
004E4:  CLRF   03
004E6:  MOVF   xE3,W
004E8:  ADDLW  E4
004EA:  MOVWF  FE9
004EC:  MOVLW  02
004EE:  ADDWFC 03,W
004F0:  MOVWF  FEA
004F2:  MOVFF  FEF,2E8
004F6:  MOVLB  3
004F8:  CLRF   x20
004FA:  MOVFF  2E8,321
004FE:  MOVLB  0
00500:  RCALL  0418
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
00502:  MOVLB  2
00504:  INCF   xE3,F
00506:  BRA    04DE
....................    g_LcdX = 0; 
00508:  CLRF   17
....................    g_LcdY = 0; 
0050A:  CLRF   18
....................   #endif 
0050C:  MOVLB  0
0050E:  GOTO   91DE (RETURN)
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
00512:  MOVLB  3
00514:  DECFSZ x1D,W
00516:  BRA    051A
00518:  BRA    0520
....................       address=LCD_LINE_TWO; 
0051A:  MOVLW  40
0051C:  MOVWF  x1E
0051E:  BRA    0522
....................    else 
....................       address=0; 
00520:  CLRF   x1E
....................       
....................    address+=x-1; 
00522:  MOVLW  01
00524:  SUBWF  x1C,W
00526:  ADDWF  x1E,F
....................    lcd_send_byte(0,0x80|address); 
00528:  MOVF   x1E,W
0052A:  IORLW  80
0052C:  MOVWF  x1F
0052E:  CLRF   x20
00530:  MOVWF  x21
00532:  MOVLB  0
00534:  RCALL  0418
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
....................    g_LcdX = x - 1; 
00536:  MOVLW  01
00538:  MOVLB  3
0053A:  SUBWF  x1C,W
0053C:  MOVWF  17
....................    g_LcdY = y - 1; 
0053E:  MOVLW  01
00540:  SUBWF  x1D,W
00542:  MOVWF  18
....................   #endif 
00544:  MOVLB  0
00546:  RETURN 0
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
00548:  MOVLB  3
0054A:  MOVF   x1A,W
0054C:  XORLW  07
0054E:  MOVLB  0
00550:  BZ    0564
00552:  XORLW  0B
00554:  BZ    0572
00556:  XORLW  01
00558:  BZ    058E
0055A:  XORLW  07
0055C:  BZ    05A4
0055E:  XORLW  02
00560:  BZ    05D2
00562:  BRA    05E0
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
00564:  MOVLW  01
00566:  MOVLB  3
00568:  MOVWF  x1C
0056A:  MOVWF  x1D
0056C:  MOVLB  0
0056E:  RCALL  0512
00570:  BRA    05F6
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
00572:  MOVLB  3
00574:  CLRF   x20
00576:  MOVLW  01
00578:  MOVWF  x21
0057A:  MOVLB  0
0057C:  RCALL  0418
....................                      delay_ms(2); 
0057E:  MOVLW  02
00580:  MOVLB  3
00582:  MOVWF  x1B
00584:  MOVLB  0
00586:  RCALL  02F6
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
00588:  CLRF   17
....................                      g_LcdY = 0; 
0058A:  CLRF   18
....................                     #endif 
....................                      break; 
0058C:  BRA    05F6
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
0058E:  MOVLW  01
00590:  ADDWF  18,W
00592:  MOVLB  3
00594:  MOVWF  x1B
00596:  MOVLW  01
00598:  MOVWF  x1C
0059A:  MOVFF  31B,31D
0059E:  MOVLB  0
005A0:  RCALL  0512
005A2:  BRA    05F6
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
005A4:  MOVF   17,W
005A6:  INCF   17,F
005A8:  SUBLW  13
005AA:  BNC   05BC
....................          { 
....................             lcd_send_byte(1, ' '); 
005AC:  MOVLW  01
005AE:  MOVLB  3
005B0:  MOVWF  x20
005B2:  MOVLW  20
005B4:  MOVWF  x21
005B6:  MOVLB  0
005B8:  RCALL  0418
005BA:  BRA    05A4
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
005BC:  MOVLW  02
005BE:  ADDWF  18,W
005C0:  MOVLB  3
005C2:  MOVWF  x1B
005C4:  MOVLW  01
005C6:  MOVWF  x1C
005C8:  MOVFF  31B,31D
005CC:  MOVLB  0
005CE:  RCALL  0512
....................          break; 
005D0:  BRA    05F6
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
005D2:  MOVLB  3
005D4:  CLRF   x20
005D6:  MOVLW  10
005D8:  MOVWF  x21
005DA:  MOVLB  0
005DC:  RCALL  0418
005DE:  BRA    05F6
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
005E0:  MOVF   17,W
005E2:  SUBLW  13
005E4:  BNC   05F6
....................          { 
....................             lcd_send_byte(1, c); 
005E6:  MOVLW  01
005E8:  MOVLB  3
005EA:  MOVWF  x20
005EC:  MOVFF  31A,321
005F0:  MOVLB  0
005F2:  RCALL  0418
....................             g_LcdX++; 
005F4:  INCF   17,F
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
....................      #endif 
....................    } 
005F6:  RETURN 0
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................    #endif 
....................     
....................    #define ENC_CS_IO       LATDbits.LATD1 
....................    #define ENC_CS_TRIS     TRISDbits.TRISD1 
....................    #define ENC_SCK_TRIS    TRISCbits.TRISC3 
....................    #define ENC_SDO_TRIS    TRISCbits.TRISC5 
....................    #define ENC_SDI_TRIS    TRISCbits.TRISC4 
....................    #define ENC_SPI_IF         PIR1bits.SSPIF 
....................    #define ENC_SPICON1        SSPCON1bits 
....................    #define ENC_SPISTATbits    SSPSTATbits 
....................    #define ENC_SSPBUF         SSPBUF 
....................     
....................    void init_user_io(void)  
....................    { 
....................       setup_adc(ADC_CLOCK_INTERNAL); 
*
0021E:  MOVF   FC0,W
00220:  ANDLW  C0
00222:  IORLW  07
00224:  MOVWF  FC0
00226:  BCF    FC0.7
00228:  BSF    FC2.0
....................       setup_adc_ports(AN0); 
0022A:  MOVF   FC1,W
0022C:  ANDLW  C0
0022E:  IORLW  0E
00230:  MOVWF  FC1
....................       set_adc_channel(STANDARD_ADC_CHANNEL); 
00232:  MOVLW  00
00234:  MOVWF  01
00236:  MOVF   FC2,W
00238:  ANDLW  C3
0023A:  IORWF  01,W
0023C:  MOVWF  FC2
....................        
....................       setup_comparator(NC_NC_NC_NC); 
0023E:  MOVLW  07
00240:  MOVWF  FB4
00242:  MOVF   F92,W
00244:  MOVWF  F92
00246:  MOVLW  20
00248:  MOVWF  00
0024A:  DECFSZ 00,F
0024C:  BRA    024A
0024E:  BRA    0250
00250:  NOP   
00252:  MOVF   FB4,W
00254:  BCF    FA1.6
....................        
....................       output_drive(USER_LED1); 
00256:  BCF    F92.5
....................       output_drive(USER_LED2); 
00258:  BCF    F93.4
....................       output_drive(USER_LED3); 
0025A:  BCF    F93.5
....................       LED_OFF(USER_LED1); 
0025C:  BCF    F92.5
0025E:  BSF    F89.5
....................       LED_OFF(USER_LED2); 
00260:  BCF    F93.4
00262:  BSF    F8A.4
....................       LED_OFF(USER_LED3); 
00264:  BCF    F93.5
00266:  BSF    F8A.5
00268:  GOTO   02C6 (RETURN)
....................    } 
....................     
....................    #define EEPROM_SELECT     PIN_B3 
....................    #define EEPROM_DI         PIN_C5 
....................    #define EEPROM_DO         PIN_C4 
....................    #define EEPROM_CLK        PIN_C3 
....................    #define EEPROM_USE_SPI    1 
....................    #include "AT25256.C" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for an ATMEL25128 or ATMEL25256                         //// 
.................... ////    ATMEL25128 has 16,384 (or 13bits of addressing) locations      //// 
.................... ////    ATMEL25256 has 32,768 words of 8 bits                          //// 
.................... ////                                                                   //// 
.................... ////   Uses software (bit banging on the port pins)                    //// 
.................... ////                                                                   //// 
.................... ////                     Pin Layout                                    //// 
.................... ////   ATMEL EEPROM pin     to      Microchip MCU Pin                  //// 
.................... ////   ----------------             -----------------                  //// 
.................... ////   1 (CS)                       PortB 0                            //// 
.................... ////   2 (SO)                       PortC 4                            //// 
.................... ////   3 (WP)                       +5V                                //// 
.................... ////   4 (GND)                      GND                                //// 
.................... ////   5 (SI)                       PortC 5                            //// 
.................... ////   6 (SCK)                      PortC 3                            //// 
.................... ////   7 (HOLD)                     +5V                                //// 
.................... ////   8 (VCC)                      +5V                                //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the unsigned int8 d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the unsigned int8 d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   b = ext_eerpom_ready();  Returns TRUE if the eeprom is ready    //// 
.................... ////                            to receive opcodes                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef EEPROM_SELECT 
.................... #define EEPROM_SELECT PIN_B0 
.................... #define EEPROM_DI     PIN_C5 
.................... #define EEPROM_DO     PIN_C4 
.................... #define EEPROM_CLK    PIN_C3 
.................... #endif 
....................  
.................... #ifndef EEPROM_ADDRESS 
.................... #define EEPROM_ADDRESS long 
.................... #endif 
....................  
.................... #byte SSPSTAT=0x94 
.................... #byte SSPCON=0x14 
....................  
.................... void init_ext_eeprom() { 
....................    int1 i; 
....................  
....................    output_low(EEPROM_DI); 
....................    output_low(EEPROM_CLK); 
....................    output_high(EEPROM_SELECT);   //at25256 is cs active LOW 
....................    i=input(EEPROM_DO); 
.................... } 
....................  
.................... BOOLEAN ext_eeprom_ready() { 
....................    unsigned int8 cmd[1],i,data; 
....................  
....................    cmd[0] = 0x05;         //rdsr opcode 
....................  
....................    output_low(EEPROM_SELECT); 
....................  
....................    for(i=1;i<=8;++i) { 
....................       output_bit(EEPROM_DI, shift_left(cmd,1,0)); 
....................       output_high(EEPROM_CLK);      //data latches 
....................       output_low(EEPROM_CLK);      //back to idle 
....................    } 
....................  
....................    for(i=1;i<=8;++i) { 
....................         output_high(EEPROM_CLK);      //data latches 
....................         shift_left(&data,1,input(EEPROM_DO)); 
....................         output_low(EEPROM_CLK);              //back to idle 
....................    } 
....................    output_high(EEPROM_SELECT); 
....................    return (!(bit_test(data, 0))); 
.................... } 
....................  
....................  
.................... void write_ext_eeprom(EEPROM_ADDRESS address, unsigned int8 data) { 
....................  
....................    unsigned int8 cmd[4]; 
....................    unsigned int8 i; 
....................    cmd[2]=((address>>8)&(0xFF));   //address msb (16bit addressing) 
....................    cmd[1]=address-cmd[2];      //address lsb 
....................  
....................    do {} while (!(ext_eeprom_ready())); //wait until the eeprom is out of the previous write state, if applicable 
....................  
....................    cmd[0]=0x06; 
....................    output_low(EEPROM_SELECT); //cs is active low 
....................    for(i=1;i<=8;++i) { 
....................       output_bit(EEPROM_DI, shift_left(cmd,1,0)); 
....................       output_high(EEPROM_CLK);      //data latches 
....................       output_low(EEPROM_CLK);      //back to idle 
....................    } 
....................    output_high(EEPROM_SELECT); 
....................  
....................    cmd[0]=data; 
....................    cmd[3]=0x02;      //write opcode 
....................    output_low(EEPROM_SELECT); 
....................    for(i=1;i<=32;++i) { 
....................       output_bit(EEPROM_DI, shift_left(cmd,4,0)); 
....................       output_high(EEPROM_CLK);      //data latches 
....................       output_low(EEPROM_CLK);      //back to idle 
....................    } 
....................  
....................    output_high(EEPROM_SELECT); 
.................... } 
....................  
....................  
.................... unsigned int8 read_ext_eeprom(EEPROM_ADDRESS address) { 
....................    unsigned int8 i,data; 
....................    unsigned int8 cmd[3]; 
....................    cmd[2]=0x03;            //read opcode 
....................    cmd[1]=((address>>8)&(0xFF)); 
....................    cmd[0]=address-cmd[1]; 
....................  
....................    do {} while (!(ext_eeprom_ready())); //wait until the eeprom is out of the previous write state, if applicable 
....................    output_low(EEPROM_SELECT); 
....................    for(i=1;i<=24;++i) { 
....................       output_bit(EEPROM_DI, shift_left(cmd,3,0)); 
....................       output_high(EEPROM_CLK);      //data latches 
....................       output_low(EEPROM_CLK);      //back to idle 
....................    } 
....................  
....................    for(i=1;i<=8;++i) { 
....................         output_high(EEPROM_CLK);      //data latches 
....................         shift_left(&data,1,input(EEPROM_DO)); 
....................         output_low(EEPROM_CLK);              //back to idle 
....................    } 
....................  
....................    output_high(EEPROM_SELECT); 
....................  
....................    return(data); 
.................... } 
....................  
....................     
....................    #define __SPIFLASH_H    //prevent spiflash.h from being loaded/used 
....................    #define SPIFlashReadArray(dwAddress, pData, wLen)  read_ext_eeprom_buf(dwAddress, pData, wLen) 
....................    #define SPIFlashInit()                             init_ext_eeprom() 
....................    EEPROM_ADDRESS g_SpiFlashCurrWrite; 
....................    #define SPIFlashBeginWrite(addy)                   g_SpiFlashCurrWrite=addy 
....................    #define SPIFlashWrite(d)                           write_ext_eeprom(g_SpiFlashCurrWrite++, d) 
....................    #define SPIFlashStopWrite() 
....................    #define SPIFlashWriteBytes(dwAddress, pData, wLen) write_ext_eeprom_buf(dwAddress, pData, wLen) 
....................     
....................    // if you want TCP/IP settings saved to internal EEPROM, then comment 
....................    // out the next few lines: 
....................    #define EEInit SPIFlashInit 
....................    #define EEReadBytes(dst, src, len)  SPIFlashReadArray(src, dst, len) 
....................    #define EEWriteBytes(dst, src, len) SPIFlashWriteBytes(dst, src, len); SPIFlashStopWrite() 
....................  
.................... #elif STACK_USE_CCS_EWL3V 
....................    #include <18F67J60.h> 
....................    #include "tcpip\p18cxxx.h" 
....................    #reserve 0xE80:0xEFF   //SFR 
....................    #reserve 0xF00:0xFFF   //SFR 
....................    #use delay(clock=41666667) 
....................    #fuses NOWDT, NODEBUG, H4_SW, NOIESO, NOFCMEN, PRIMARY, ETHLED 
....................   
....................    #use rs232(baud=9600, uart1, stream=STREAM_UI, errors)  
....................  
....................    void lcd_putc(char c) 
....................    { 
....................      #if STACK_USE_PICDEM_LCD 
....................        if (c == '\f') 
....................          printf("\r\n\n"); 
....................        else 
....................          putc(c); 
....................      #endif 
....................    } 
....................    #define lcd_init() 
....................    #ifndef STACK_USE_PICDEM_LCD 
....................       #define STACK_USE_PICDEM_LCD 0   // no hardware LCD support 
....................    #endif 
....................     
....................    #define LED_ON       output_high 
....................    #define LED_OFF      output_low 
....................    #define USER_LED1    PIN_F1                 //input1 
....................    #define USER_LED2    PIN_F2                 //input2 
....................    #define USER_LED3    PIN_F3                 //input3 
....................    #define STANDARD_ADC_STRING  "AN9" 
....................    #define STANDARD_ADC_CHANNEL 9              //input4 
....................    #define BUTTON1_PRESSED() (input(PIN_F5))   //input5 
....................    #define BUTTON2_PRESSED() (input(PIN_F6))   //input6 
....................  
....................    void init_user_io(void) 
....................    { 
....................       setup_oscillator(OSC_PLL_5_DIV_3 | OSC_NORMAL); 
....................       restart_wdt(); 
....................       delay_ms(144); 
....................       restart_wdt(); 
....................     
....................       setup_adc(ADC_CLOCK_INTERNAL); 
....................       setup_adc_ports(AN0_TO_AN9); 
....................       set_adc_channel(STANDARD_ADC_CHANNEL); 
....................        
....................       setup_comparator(NC_NC_NC_NC); 
....................  
....................       output_drive(USER_LED1); 
....................       output_drive(USER_LED2); 
....................       output_drive(USER_LED3); 
....................       LED_OFF(USER_LED1); 
....................       LED_OFF(USER_LED2); 
....................       LED_OFF(USER_LED3); 
....................    } 
....................      
....................    #define __AT45DB_B__ 
....................    #define FLASH_SELECT PIN_C2 
....................    #define FLASH_CLOCK  PIN_C3 
....................    #define FLASH_DI     PIN_C5 
....................    #define FLASH_DO     PIN_C4 
....................    #define FLASH_BUFFER_SIZE    264     //bytes per page 
....................    #define FLASH_BUFFER_COUNT   4096   //page count 
....................    #include "at45db.c"  
....................        
....................    #define __SPIFLASH_H    //prevent spiflash.h from being loaded/used 
....................    #define SPIFlashReadArray(dwAddress, pData, wLen)  ext_flash_read(dwAddress, pData, wLen) 
....................    #define SPIFlashInit()                             init_ext_flash() 
....................    #define SPIFlashBeginWrite(addy)                   ext_flash_startWrite(addy) 
....................    #define SPIFlashWrite(d)                           ext_flash_continuousWrite(d) 
....................    #define SPIFlashStopWrite()                        ext_flash_flushWrites() 
....................    #define SPIFlashWriteBytes(dwAddress, pData, wLen) ext_flash_writeBytes(dwAddress, pData, wLen) 
....................     
....................    // if you want TCP/IP settings saved to internal EEPROM, then comment 
....................    // out the next few lines: 
....................    #define EEInit SPIFlashInit 
....................    #define EEReadBytes(dst, src, len)  SPIFlashReadArray(src, dst, len) 
....................    #define EEWriteBytes(dst, src, len) SPIFlashWriteBytes(dst, src, len)  
....................     
.................... #elif STACK_USE_CCS_EWL5V_REV5 
....................    #include <18F67K22.h> 
....................    #include "tcpip\p18cxxx.h" 
....................    #reserve 0xF16:0xFFF   //SFR 
....................    #use delay(clock=64M, XTAL=16M) 
....................     
....................    #use rs232(baud=9600, uart1, stream=STREAM_UI, errors) 
....................  
....................    void lcd_putc(char c) 
....................    { 
....................      #if STACK_USE_PICDEM_LCD 
....................        if (c == '\f') 
....................          printf("\r\n\n"); 
....................        else 
....................          putc(c); 
....................      #endif 
....................    } 
....................    #define lcd_init() 
....................    #ifndef STACK_USE_PICDEM_LCD 
....................       #define STACK_USE_PICDEM_LCD 0   // no hardware LCD support 
....................    #endif 
....................      
....................    #define LED_ON       output_high 
....................    #define LED_OFF      output_low 
....................    #define USER_LED1    PIN_G3                 //input1 
....................    #define USER_LED2    PIN_G4                 //input2 
....................    #define USER_LED3    PIN_A2                 //input3 
....................    #define STANDARD_ADC_STRING  "AN3" 
....................    #define STANDARD_ADC_CHANNEL 3              //input4 
....................    #define BUTTON1_PRESSED() (input(PIN_A5))   //input5 
....................    #define BUTTON2_PRESSED() (input(PIN_B5))   //input6 
....................  
....................    #define ENC_CS_IO       LATFbits.LATF2    
....................    #define ENC_CS_TRIS     TRISFbits.TRISF2 
....................    #define ENC_SCK_TRIS    TRISCbits.TRISC3 
....................    #define ENC_SDO_TRIS    TRISCbits.TRISC5 
....................    #define ENC_SDI_TRIS    TRISCbits.TRISC4 
....................    #define ENC_RST_IO      LATDbits.LATD0 
....................    #define ENC_RST_TRIS    TRISDbits.TRISD0 
....................    #define ENC_SPI_IF         PIR1bits.SSP1IF 
....................    #define ENC_SPICON1        SSP1CON1bits   //SPI1CON1 
....................    #define ENC_SPICON2        SPI1CON2 
....................    #define ENC_SPISTAT        SPI1STAT 
....................    #define ENC_SSPBUF         SSP1BUF        //SPI1BUF 
....................    #define ENC_SPICON1bits    SPI1CON1bits 
....................    #define ENC_SPICON2bits    SPI1CON2bits 
....................    #define ENC_SPISTATbits    SSP1STATbits   //SPI1STATbits   
....................  
....................    void init_user_io(void) 
....................    { 
....................       setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_2); 
....................       setup_adc_ports(sAN3); 
....................       set_adc_channel(STANDARD_ADC_CHANNEL); 
....................       output_drive(USER_LED1); 
....................       output_drive(USER_LED2); 
....................       output_drive(USER_LED3); 
....................       LED_OFF(USER_LED1); 
....................       LED_OFF(USER_LED2); 
....................       LED_OFF(USER_LED3); 
....................    } 
....................     
....................    #define __AT45DB_D__ 
....................    #define FLASH_SELECT PIN_F1 
....................    #define FLASH_CLOCK  PIN_D6 
....................    #define FLASH_DO     PIN_D5   //MISO 
....................    #define FLASH_DI     PIN_D4   //MOSI 
....................    #define FLASH_BUFFER_SIZE    264 
....................    #define FLASH_BUFFER_COUNT   4096 
....................    #include "at45db.c" 
....................        
....................    #define __SPIFLASH_H    //prevent spiflash.h from being loaded/used 
....................    #define SPIFlashReadArray(dwAddress, pData, wLen)  ext_flash_read(dwAddress, pData, wLen) 
....................    #define SPIFlashInit()                             init_ext_flash() 
....................    #define SPIFlashBeginWrite(addy)                   ext_flash_startWrite(addy) 
....................    #define SPIFlashWrite(d)                           ext_flash_continuousWrite(d) 
....................    #define SPIFlashStopWrite()                        ext_flash_flushWrites() 
....................    #define SPIFlashWriteBytes(dwAddress, pData, wLen) ext_flash_writeBytes(dwAddress, pData, wLen) 
....................     
....................    // if you want TCP/IP settings saved to internal EEPROM, then comment 
....................    // out the next few lines: 
....................    #define EEInit SPIFlashInit 
....................    #define EEReadBytes(dst, src, len)  SPIFlashReadArray(src, dst, len) 
....................    #define EEWriteBytes(dst, src, len) SPIFlashWriteBytes(dst, src, len) 
....................  
.................... /* currently working on this - not functional */ 
.................... #elif STACK_USE_CCS_PICNET 
....................    #include <18F6722.h> 
....................    #include "tcpip\p18cxxx.h" 
....................    // SFR? 
....................    #use delay (clock=40000000) 
....................    #fuses H4, NOLVP, NOWDT, NODEBUG 
....................     
....................    #use rs232(baud=9600, uart1, stream=STREAM_UI, errors) 
....................  
....................    #define STACK_USE_PICDEM_LCD TRUE 
....................    #define BUTTON1_PRESSED()  (!input(PIN_B0)) 
....................    #define BUTTON2_PRESSED()  (!input(PIN_B1)) 
....................    #define USER_LED1    PIN_B2 
....................    #define USER_LED2    PIN_B4 
....................    #define LED_ON       output_low 
....................    #define LED_OFF      output_high 
....................    #define STANDARD_ADC_STRING  "AN0" 
....................    #define STANDARD_ADC_CHANNEL 0 
....................    #define SECONDARY_ADC_STRING "AN1" 
....................    #define SECONDARY_ADC_CHANNEL 1 
....................     
....................    #define LCD_ENABLE_PIN  PIN_D0 
....................    #define LCD_RS_PIN      PIN_D1 
....................    #define LCD_RW_PIN      PIN_D2 
....................    #define LCD_DATA4       PIN_D4 
....................    #define LCD_DATA5       PIN_D5 
....................    #define LCD_DATA6       PIN_D6 
....................    #define LCD_DATA7       PIN_D7 
....................     
....................    #ifndef STACK_USE_PICDEM_LCD 
....................       #define STACK_USE_PICDEM_LCD 1 
....................    #endif 
....................    #if STACK_USE_PICDEM_LCD 
....................       #include "lcd.c" 
....................    #endif 
....................     
....................    void init_user_io(void) { 
....................       setup_adc(ADC_CLOCK_INTERNAL ); 
....................       setup_adc_ports(ANALOG_AN0_TO_AN1); 
....................       set_adc_channel(STANDARD_ADC_CHANNEL); 
....................       //*0xF92=*0xF92 | 3;            //a0 and a1 input (for ADC) 
....................       //*0xF93=(*0xF93 & 0xEB) | 3;   //B0 and B1 input, B2 and B4 output 
....................       output_drive(USER_LED1); 
....................       output_drive(USER_LED2); 
....................       LED_OFF(USER_LED1); 
....................       LED_OFF(USER_LED2); 
....................    } 
....................  
.................... #else 
....................  #error You need to define your custom hardware 
.................... #endif 
....................  
.................... #ifndef LED_ACTIVITY_BLINK 
.................... #define LED_ACTIVITY_BLINK() 
.................... #endif 
....................  
.................... #if !STACK_USE_PICDEM_LCD 
....................    #define lcd_putc(c) 
....................    #define lcd_init() 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_WIFI 
....................    #define STACK_USE_CCS_GRATUITOUS_ARP 
....................     
....................    #define WIFI_CCS_RESET_ON_MODULE_HANG 
....................     
....................    #define WF_USE_TX_POWER_CONTROL_FUNCTIONS 
....................  
....................    #define WF_FORCE_NO_PS_POLL 
....................      
....................    //#define FORCE_ADHOC_ACTIVATED !input(PIN_G4)     //a certain button press can force ad hoc mode regardless of EE setting 
....................     
....................    #define STACK_USE_DNS_SERVER   //strongly recommended if using ad-hoc mode 
....................    #define STACK_USE_DHCP_SERVER  //strongly recommended if using ad-hoc mode 
.................... #endif 
....................  
.................... #ifndef STACK_USE_CCS_INI 
....................  #define STACK_USE_CCS_INI 0 
....................  #define UITask() 
.................... #endif 
....................  
.................... #if STACK_USE_CCS_INI 
....................    #define STACK_USE_DHCP_CLIENT 
.................... #endif 
....................  
.................... // clock definitions required by Microchip's TCP/IP Stack. 
.................... #if defined(__PCH__) //pic18 
....................    #define GetSystemClock()      getenv("CLOCK") 
....................    #define GetInstructionClock()   (GetSystemClock()/4) 
....................    #define GetPeripheralClock()   (unsigned int32)GetInstructionClock() 
.................... #else //pic24,dspic30,dspic33f 
....................    #define GetSystemClock()       getenv("CLOCK") 
....................    #define GetInstructionClock()  (GetSystemClock()/2) 
....................    #define GetPeripheralClock()   (GetSystemClock()/2) 
.................... #endif 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define MIN(a,b)  ((a > b) ? b : a) 
....................  
.................... #include "tcpip/StackTsk2.h" 
.................... // 'glue' file for using Microchip's TCP/IP stack inside CCS C Compiler without 
.................... // a linker.   
.................... // Also includes some macros/defines for porting older V3 stack to this current 
.................... // stack. 
.................... // Also provides extra routines written by CCS to improve the stack. 
....................  
.................... #ifndef __CCS_STACKTSK2_H__ 
.................... #define __CCS_STACKTSK2_H__ 
....................  
.................... #if !defined(debug_mpfs2) 
....................  #define debug_mpfs2(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) 
.................... #else 
....................  #define __DO_DEBUG_MPFS2 
.................... #endif 
....................  
.................... #if defined(__PCH__) && !defined(__18CXX) 
....................  #define __18CXX 
.................... #endif 
....................  
.................... #define SIZEOF_MAC_HEADER 14 
....................  
.................... // override delay.c/delay.h with CCS compatible code 
.................... #define __DELAY_H 
.................... #define Delay10us(x) delay_us((uint16_t)10*(uint16_t)x) 
.................... #define DelayMs(x)   delay_ms(x) 
....................  
.................... #define __WF_DEBUG_STRINGS_H  //don't include this file 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
*
06648:  MOVFF  30D,313
0664C:  MOVFF  30C,312
....................    sc2=s2; 
06650:  MOVFF  30F,315
06654:  MOVFF  30E,314
....................    if(sc2<sc1 && sc1 <sc2 +n) 
06658:  MOVLB  3
0665A:  MOVF   x15,W
0665C:  SUBWF  x13,W
0665E:  BNC   66DC
06660:  BNZ   6668
06662:  MOVF   x12,W
06664:  SUBWF  x14,W
06666:  BC    66DC
06668:  MOVF   x10,W
0666A:  ADDWF  x14,W
0666C:  MOVWF  01
0666E:  MOVF   x11,W
06670:  ADDWFC x15,W
06672:  MOVWF  03
06674:  MOVF   x13,W
06676:  SUBWF  03,W
06678:  BNC   66DC
0667A:  BNZ   6682
0667C:  MOVF   01,W
0667E:  SUBWF  x12,W
06680:  BC    66DC
....................       for(sc1+=n,sc2+=n;0<n;--n) 
06682:  MOVF   x10,W
06684:  ADDWF  x12,F
06686:  MOVF   x11,W
06688:  ADDWFC x13,F
0668A:  MOVF   x10,W
0668C:  ADDWF  x14,F
0668E:  MOVF   x11,W
06690:  ADDWFC x15,F
06692:  MOVF   x11,F
06694:  BNZ   669C
06696:  MOVF   x10,W
06698:  SUBLW  00
0669A:  BC    66DA
....................          *--sc1=*--sc2; 
0669C:  MOVF   x12,W
0669E:  BTFSC  FD8.2
066A0:  DECF   x13,F
066A2:  DECF   x12,F
066A4:  MOVFF  312,316
066A8:  MOVFF  313,317
066AC:  MOVF   x14,W
066AE:  BTFSC  FD8.2
066B0:  DECF   x15,F
066B2:  DECF   x14,F
066B4:  MOVFF  315,03
066B8:  MOVFF  314,FE9
066BC:  MOVFF  315,FEA
066C0:  MOVFF  FEF,318
066C4:  MOVFF  313,FEA
066C8:  MOVFF  312,FE9
066CC:  MOVFF  318,FEF
066D0:  MOVF   x10,W
066D2:  BTFSC  FD8.2
066D4:  DECF   x11,F
066D6:  DECF   x10,F
066D8:  BRA    6692
066DA:  BRA    6724
....................    else 
....................       for(;0<n;--n) 
066DC:  MOVF   x11,F
066DE:  BNZ   66E6
066E0:  MOVF   x10,W
066E2:  SUBLW  00
066E4:  BC    6724
....................          *sc1++=*sc2++; 
066E6:  MOVFF  313,03
066EA:  MOVF   x12,W
066EC:  INCF   x12,F
066EE:  BTFSC  FD8.2
066F0:  INCF   x13,F
066F2:  MOVWF  x16
066F4:  MOVFF  03,317
066F8:  MOVFF  315,03
066FC:  MOVF   x14,W
066FE:  INCF   x14,F
06700:  BTFSC  FD8.2
06702:  INCF   x15,F
06704:  MOVWF  FE9
06706:  MOVFF  03,FEA
0670A:  MOVFF  FEF,318
0670E:  MOVFF  317,FEA
06712:  MOVFF  316,FE9
06716:  MOVFF  318,FEF
0671A:  MOVF   x10,W
0671C:  BTFSC  FD8.2
0671E:  DECF   x11,F
06720:  DECF   x10,F
06722:  BRA    66DC
....................   return s1; 
06724:  MOVFF  30C,01
06728:  MOVFF  30D,02
0672C:  MOVLB  0
0672E:  GOTO   681A (RETURN)
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
060E0:  MOVLB  2
060E2:  MOVFF  2EB,FE9
060E6:  MOVFF  2EC,FEA
060EA:  MOVFF  FEF,2EF
060EE:  MOVFF  2EE,03
060F2:  MOVFF  2ED,FE9
060F6:  MOVFF  2EE,FEA
060FA:  MOVF   FEF,W
060FC:  SUBWF  xEF,W
060FE:  BNZ   612A
....................       if (*s1 == '\0') 
06100:  MOVFF  2EC,03
06104:  MOVFF  2EB,FE9
06108:  MOVFF  03,FEA
0610C:  MOVF   FEF,F
0610E:  BNZ   6116
....................          return(0); 
06110:  MOVLW  00
06112:  MOVWF  01
06114:  BRA    615E
06116:  MOVFF  2EC,03
0611A:  MOVF   xEB,W
0611C:  INCF   xEB,F
0611E:  BTFSC  FD8.2
06120:  INCF   xEC,F
06122:  INCF   xED,F
06124:  BTFSC  FD8.2
06126:  INCF   xEE,F
06128:  BRA    60E2
....................    return((*s1 < *s2) ? -1: 1); 
0612A:  MOVFF  2EC,03
0612E:  MOVFF  2EB,FE9
06132:  MOVFF  2EC,FEA
06136:  MOVFF  FEF,2EF
0613A:  MOVFF  2EE,03
0613E:  MOVFF  2ED,FE9
06142:  MOVFF  2EE,FEA
06146:  MOVF   FEF,W
06148:  XORLW  80
0614A:  MOVWF  00
0614C:  MOVF   xEF,W
0614E:  XORLW  80
06150:  SUBWF  00,W
06152:  BZ    615A
06154:  BNC   615A
06156:  MOVLW  FF
06158:  BRA    615C
0615A:  MOVLW  01
0615C:  MOVWF  01
0615E:  MOVLB  0
06160:  RETURN 0
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
06162:  MOVFF  341,344
....................    for(su=s;0<n;++su,--n) 
06166:  MOVFF  340,346
0616A:  MOVFF  33F,345
0616E:  MOVLB  3
06170:  MOVF   x43,F
06172:  BNZ   617A
06174:  MOVF   x42,W
06176:  SUBLW  00
06178:  BC    61A6
....................       if(*su==uc) 
0617A:  MOVFF  346,03
0617E:  MOVFF  345,FE9
06182:  MOVFF  346,FEA
06186:  MOVF   x44,W
06188:  SUBWF  FEF,W
0618A:  BNZ   6196
....................       return su; 
0618C:  MOVFF  345,01
06190:  MOVFF  346,02
06194:  BRA    61AC
06196:  INCF   x45,F
06198:  BTFSC  FD8.2
0619A:  INCF   x46,F
0619C:  MOVF   x42,W
0619E:  BTFSC  FD8.2
061A0:  DECF   x43,F
061A2:  DECF   x42,F
061A4:  BRA    6170
....................    return NULL; 
061A6:  MOVLW  00
061A8:  MOVWF  01
061AA:  MOVWF  02
061AC:  MOVLB  0
061AE:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
05FB6:  MOVFF  2F8,2FC
05FBA:  MOVFF  2F7,2FB
05FBE:  MOVFF  2FC,03
05FC2:  MOVLB  2
05FC4:  MOVFF  2FB,FE9
05FC8:  MOVFF  2FC,FEA
05FCC:  MOVF   FEF,F
05FCE:  BZ    6024
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
05FD0:  MOVFF  2FA,2FE
05FD4:  MOVFF  2F9,2FD
05FD8:  MOVFF  2FE,03
05FDC:  MOVFF  2FD,FE9
05FE0:  MOVFF  2FE,FEA
05FE4:  MOVF   FEF,F
05FE6:  BZ    6018
....................          if (*sc1 == *sc2) 
05FE8:  MOVFF  2FB,FE9
05FEC:  MOVFF  2FC,FEA
05FF0:  MOVFF  FEF,2FF
05FF4:  MOVFF  2FE,03
05FF8:  MOVFF  2FD,FE9
05FFC:  MOVFF  2FE,FEA
06000:  MOVF   FEF,W
06002:  SUBWF  xFF,W
06004:  BNZ   6010
....................             return(sc1); 
06006:  MOVFF  2FB,01
0600A:  MOVFF  2FC,02
0600E:  BRA    602A
06010:  INCF   xFD,F
06012:  BTFSC  FD8.2
06014:  INCF   xFE,F
06016:  BRA    5FD8
06018:  INCF   xFB,F
0601A:  BTFSC  FD8.2
0601C:  INCF   xFC,F
0601E:  MOVLB  0
06020:  BRA    5FBE
06022:  MOVLB  2
....................    return(0); 
06024:  MOVLW  00
06026:  MOVWF  01
06028:  MOVWF  02
0602A:  MOVLB  0
0602C:  GOTO   60A2 (RETURN)
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
05F26:  MOVFF  2F8,2FC
05F2A:  MOVFF  2F7,2FB
05F2E:  MOVFF  2FC,03
05F32:  MOVLB  2
05F34:  MOVFF  2FB,FE9
05F38:  MOVFF  2FC,FEA
05F3C:  MOVF   FEF,F
05F3E:  BZ    5FA0
....................       for (sc2 = s2; ; sc2++) 
05F40:  MOVFF  2FA,2FE
05F44:  MOVFF  2F9,2FD
....................     if (*sc2 == '\0') 
05F48:  MOVFF  2FE,03
05F4C:  MOVFF  2FD,FE9
05F50:  MOVFF  2FE,FEA
05F54:  MOVF   FEF,F
05F56:  BNZ   5F6C
....................        return(sc1 - s1); 
05F58:  MOVF   xF7,W
05F5A:  SUBWF  xFB,W
05F5C:  MOVWF  00
05F5E:  MOVF   xF8,W
05F60:  SUBWFB xFC,W
05F62:  MOVWF  03
05F64:  MOVFF  00,01
05F68:  BRA    5FB0
05F6A:  BRA    5F8C
....................          else if (*sc1 == *sc2) 
05F6C:  MOVFF  2FB,FE9
05F70:  MOVFF  2FC,FEA
05F74:  MOVFF  FEF,2FF
05F78:  MOVFF  2FE,03
05F7C:  MOVFF  2FD,FE9
05F80:  MOVFF  2FE,FEA
05F84:  MOVF   FEF,W
05F86:  SUBWF  xFF,W
05F88:  BNZ   5F8C
....................             break; 
05F8A:  BRA    5F94
05F8C:  INCF   xFD,F
05F8E:  BTFSC  FD8.2
05F90:  INCF   xFE,F
05F92:  BRA    5F48
05F94:  INCF   xFB,F
05F96:  BTFSC  FD8.2
05F98:  INCF   xFC,F
05F9A:  MOVLB  0
05F9C:  BRA    5F2E
05F9E:  MOVLB  2
....................    return(sc1 - s1); 
05FA0:  MOVF   xF7,W
05FA2:  SUBWF  xFB,W
05FA4:  MOVWF  00
05FA6:  MOVF   xF8,W
05FA8:  SUBWFB xFC,W
05FAA:  MOVWF  03
05FAC:  MOVFF  00,01
05FB0:  MOVLB  0
05FB2:  GOTO   6060 (RETURN)
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
*
06030:  MOVLB  2
06032:  MOVF   xEF,W
06034:  IORWF  xF0,W
06036:  BZ    6040
06038:  MOVFF  2F0,03
0603C:  MOVF   xEF,W
0603E:  BRA    6046
06040:  MOVFF  1E,03
06044:  MOVF   1D,W
06046:  MOVWF  xF3
06048:  MOVFF  03,2F4
....................    beg += strspn(beg, s2); 
0604C:  MOVFF  2F4,2F8
06050:  MOVFF  2F3,2F7
06054:  MOVFF  2F2,2FA
06058:  MOVFF  2F1,2F9
0605C:  MOVLB  0
0605E:  BRA    5F26
06060:  MOVF   01,W
06062:  MOVLB  2
06064:  ADDWF  xF3,F
06066:  MOVLW  00
06068:  ADDWFC xF4,F
....................    if (*beg == '\0') 
0606A:  MOVFF  2F4,03
0606E:  MOVFF  2F3,FE9
06072:  MOVFF  2F4,FEA
06076:  MOVF   FEF,F
06078:  BNZ   608E
....................    { 
....................       *save = ' '; 
0607A:  MOVFF  1D,FE9
0607E:  MOVFF  1E,FEA
06082:  MOVLW  20
06084:  MOVWF  FEF
....................       return(0); 
06086:  MOVLW  00
06088:  MOVWF  01
0608A:  MOVWF  02
0608C:  BRA    60DC
....................    } 
....................    end = strpbrk(beg, s2); 
0608E:  MOVFF  2F4,2F8
06092:  MOVFF  2F3,2F7
06096:  MOVFF  2F2,2FA
0609A:  MOVFF  2F1,2F9
0609E:  MOVLB  0
060A0:  BRA    5FB6
060A2:  MOVFF  02,2F6
060A6:  MOVFF  01,2F5
....................    if (*end != '\0') 
060AA:  MOVFF  2F6,03
060AE:  MOVLB  2
060B0:  MOVFF  2F5,FE9
060B4:  MOVFF  2F6,FEA
060B8:  MOVF   FEF,F
060BA:  BZ    60CC
....................    { 
....................       *end = '\0'; 
060BC:  MOVFF  2F5,FE9
060C0:  MOVFF  2F6,FEA
060C4:  CLRF   FEF
....................       end++; 
060C6:  INCF   xF5,F
060C8:  BTFSC  FD8.2
060CA:  INCF   xF6,F
....................    } 
....................    save = end; 
060CC:  MOVFF  2F6,1E
060D0:  MOVFF  2F5,1D
....................    return(beg); 
060D4:  MOVFF  2F3,01
060D8:  MOVFF  2F4,02
060DC:  MOVLB  0
060DE:  RETURN 0
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
0660E:  MOVFF  31C,31E
06612:  MOVFF  31B,31D
06616:  MOVFF  31E,03
0661A:  MOVLB  3
0661C:  MOVFF  31D,FE9
06620:  MOVFF  31E,FEA
06624:  MOVF   FEF,F
06626:  BZ    6634
06628:  INCF   x1D,F
0662A:  BTFSC  FD8.2
0662C:  INCF   x1E,F
0662E:  MOVLB  0
06630:  BRA    6616
06632:  MOVLB  3
....................    return(sc - s); 
06634:  MOVF   x1B,W
06636:  SUBWF  x1D,W
06638:  MOVWF  00
0663A:  MOVF   x1C,W
0663C:  SUBWFB x1E,W
0663E:  MOVWF  03
06640:  MOVFF  00,01
06644:  MOVLB  0
06646:  RETURN 0
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
*
06886:  MOVLB  3
06888:  MOVFF  318,FE9
0688C:  MOVFF  319,FEA
06890:  MOVFF  FEF,31C
06894:  MOVFF  31B,03
06898:  MOVFF  31A,FE9
0689C:  MOVFF  31B,FEA
068A0:  MOVF   FEF,W
068A2:  SUBWF  x1C,W
068A4:  BZ    6956
068A6:  MOVFF  319,03
068AA:  MOVFF  318,FE9
068AE:  MOVFF  319,FEA
068B2:  MOVFF  FEF,31C
068B6:  BTFSC  x1C.7
068B8:  BRA    68CA
068BA:  MOVF   x1C,W
068BC:  SUBLW  40
068BE:  BC    68CA
068C0:  BTFSC  x1C.7
068C2:  BRA    68DE
068C4:  MOVF   x1C,W
068C6:  SUBLW  5A
068C8:  BC    68DE
068CA:  BTFSC  x1C.7
068CC:  BRA    6980
068CE:  MOVF   x1C,W
068D0:  SUBLW  60
068D2:  BC    6980
068D4:  BTFSC  x1C.7
068D6:  BRA    68DE
068D8:  MOVF   x1C,W
068DA:  SUBLW  7A
068DC:  BNC   6980
068DE:  MOVFF  31B,03
068E2:  MOVFF  31A,FE9
068E6:  MOVFF  31B,FEA
068EA:  MOVFF  FEF,31C
068EE:  BTFSC  x1C.7
068F0:  BRA    6902
068F2:  MOVF   x1C,W
068F4:  SUBLW  40
068F6:  BC    6902
068F8:  BTFSC  x1C.7
068FA:  BRA    6916
068FC:  MOVF   x1C,W
068FE:  SUBLW  5A
06900:  BC    6916
06902:  BTFSC  x1C.7
06904:  BRA    6980
06906:  MOVF   x1C,W
06908:  SUBLW  60
0690A:  BC    6980
0690C:  BTFSC  x1C.7
0690E:  BRA    6916
06910:  MOVF   x1C,W
06912:  SUBLW  7A
06914:  BNC   6980
06916:  MOVFF  318,FE9
0691A:  MOVFF  319,FEA
0691E:  MOVFF  FEF,31C
06922:  MOVFF  31B,03
06926:  MOVFF  31A,FE9
0692A:  MOVFF  31B,FEA
0692E:  MOVLW  20
06930:  ADDWF  FEF,W
06932:  SUBWF  x1C,W
06934:  BZ    6956
06936:  MOVFF  31A,FE9
0693A:  MOVFF  31B,FEA
0693E:  MOVFF  FEF,31C
06942:  MOVFF  319,03
06946:  MOVFF  318,FE9
0694A:  MOVFF  319,FEA
0694E:  MOVLW  20
06950:  ADDWF  FEF,W
06952:  SUBWF  x1C,W
06954:  BNZ   6980
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
06956:  MOVFF  319,03
0695A:  MOVFF  318,FE9
0695E:  MOVFF  319,FEA
06962:  MOVF   FEF,F
06964:  BNZ   696C
....................        return(0); 
06966:  MOVLW  00
06968:  MOVWF  01
0696A:  BRA    69B4
0696C:  MOVFF  319,03
06970:  MOVF   x18,W
06972:  INCF   x18,F
06974:  BTFSC  FD8.2
06976:  INCF   x19,F
06978:  INCF   x1A,F
0697A:  BTFSC  FD8.2
0697C:  INCF   x1B,F
0697E:  BRA    6888
....................  return((*s1 < *s2) ? -1: 1); 
06980:  MOVFF  319,03
06984:  MOVFF  318,FE9
06988:  MOVFF  319,FEA
0698C:  MOVFF  FEF,31C
06990:  MOVFF  31B,03
06994:  MOVFF  31A,FE9
06998:  MOVFF  31B,FEA
0699C:  MOVF   FEF,W
0699E:  XORLW  80
069A0:  MOVWF  00
069A2:  MOVF   x1C,W
069A4:  XORLW  80
069A6:  SUBWF  00,W
069A8:  BZ    69B0
069AA:  BNC   69B0
069AC:  MOVLW  FF
069AE:  BRA    69B2
069B0:  MOVLW  01
069B2:  MOVWF  01
069B4:  MOVLB  0
069B6:  RETURN 0
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
06D10:  MOVLB  3
06D12:  CLRF   x21
06D14:  CLRF   x20
....................    sign = 0; 
06D16:  CLRF   x1D
06D18:  CLRF   x1C
....................    base = 10; 
06D1A:  CLRF   x1F
06D1C:  MOVLW  0A
06D1E:  MOVWF  x1E
....................    result = 0; 
06D20:  CLRF   x1B
06D22:  CLRF   x1A
....................  
....................    if (!s) 
06D24:  MOVF   x18,W
06D26:  IORWF  x19,W
06D28:  BNZ   6D32
....................       return 0; 
06D2A:  MOVLW  00
06D2C:  MOVWF  01
06D2E:  MOVWF  02
06D30:  BRA    6FA0
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
06D32:  MOVFF  321,03
06D36:  MOVF   x20,W
06D38:  INCF   x20,F
06D3A:  BTFSC  FD8.2
06D3C:  INCF   x21,F
06D3E:  MOVWF  x23
06D40:  MOVF   x18,W
06D42:  ADDWF  x23,W
06D44:  MOVWF  FE9
06D46:  MOVF   x19,W
06D48:  ADDWFC 03,W
06D4A:  MOVWF  FEA
06D4C:  MOVFF  FEF,322
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
06D50:  MOVF   x22,W
06D52:  SUBLW  2D
06D54:  BNZ   6D7C
....................    { 
....................       sign = 1;         // Set the sign to negative 
06D56:  CLRF   x1D
06D58:  MOVLW  01
06D5A:  MOVWF  x1C
....................       c = s[index++]; 
06D5C:  MOVFF  321,03
06D60:  MOVF   x20,W
06D62:  INCF   x20,F
06D64:  BTFSC  FD8.2
06D66:  INCF   x21,F
06D68:  MOVWF  x23
06D6A:  MOVF   x18,W
06D6C:  ADDWF  x23,W
06D6E:  MOVWF  FE9
06D70:  MOVF   x19,W
06D72:  ADDWFC 03,W
06D74:  MOVWF  FEA
06D76:  MOVFF  FEF,322
....................    } 
06D7A:  BRA    6DA0
....................    else if (c == '+') 
06D7C:  MOVF   x22,W
06D7E:  SUBLW  2B
06D80:  BNZ   6DA0
....................    { 
....................       c = s[index++]; 
06D82:  MOVFF  321,03
06D86:  MOVF   x20,W
06D88:  INCF   x20,F
06D8A:  BTFSC  FD8.2
06D8C:  INCF   x21,F
06D8E:  MOVWF  x23
06D90:  MOVF   x18,W
06D92:  ADDWF  x23,W
06D94:  MOVWF  FE9
06D96:  MOVF   x19,W
06D98:  ADDWFC 03,W
06D9A:  MOVWF  FEA
06D9C:  MOVFF  FEF,322
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
06DA0:  BTFSC  x22.7
06DA2:  BRA    6F7C
06DA4:  MOVF   x22,W
06DA6:  SUBLW  2F
06DA8:  BTFSC  FD8.0
06DAA:  BRA    6F7C
06DAC:  BTFSC  x22.7
06DAE:  BRA    6DB8
06DB0:  MOVF   x22,W
06DB2:  SUBLW  39
06DB4:  BTFSS  FD8.0
06DB6:  BRA    6F7C
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
06DB8:  MOVF   x22,W
06DBA:  SUBLW  30
06DBC:  BNZ   6E0C
06DBE:  MOVF   x18,W
06DC0:  ADDWF  x20,W
06DC2:  MOVWF  FE9
06DC4:  MOVF   x19,W
06DC6:  ADDWFC x21,W
06DC8:  MOVWF  FEA
06DCA:  MOVF   FEF,W
06DCC:  SUBLW  78
06DCE:  BZ    6DE2
06DD0:  MOVF   x18,W
06DD2:  ADDWF  x20,W
06DD4:  MOVWF  FE9
06DD6:  MOVF   x19,W
06DD8:  ADDWFC x21,W
06DDA:  MOVWF  FEA
06DDC:  MOVF   FEF,W
06DDE:  SUBLW  58
06DE0:  BNZ   6E0C
....................       { 
....................          base = 16; 
06DE2:  CLRF   x1F
06DE4:  MOVLW  10
06DE6:  MOVWF  x1E
....................          index++; 
06DE8:  INCF   x20,F
06DEA:  BTFSC  FD8.2
06DEC:  INCF   x21,F
....................          c = s[index++]; 
06DEE:  MOVFF  321,03
06DF2:  MOVF   x20,W
06DF4:  INCF   x20,F
06DF6:  BTFSC  FD8.2
06DF8:  INCF   x21,F
06DFA:  MOVWF  x23
06DFC:  MOVF   x18,W
06DFE:  ADDWF  x23,W
06E00:  MOVWF  FE9
06E02:  MOVF   x19,W
06E04:  ADDWFC 03,W
06E06:  MOVWF  FEA
06E08:  MOVFF  FEF,322
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
06E0C:  MOVF   x1E,W
06E0E:  SUBLW  0A
06E10:  BNZ   6E78
06E12:  MOVF   x1F,F
06E14:  BNZ   6E78
....................       { 
....................          while (c >= '0' && c <= '9') 
06E16:  BTFSC  x22.7
06E18:  BRA    6E76
06E1A:  MOVF   x22,W
06E1C:  SUBLW  2F
06E1E:  BC    6E76
06E20:  BTFSC  x22.7
06E22:  BRA    6E2A
06E24:  MOVF   x22,W
06E26:  SUBLW  39
06E28:  BNC   6E76
....................          { 
....................             result = 10*result + (c - '0'); 
06E2A:  CLRF   x24
06E2C:  MOVLW  0A
06E2E:  MOVWF  x23
06E30:  MOVFF  31B,326
06E34:  MOVFF  31A,325
06E38:  MOVLB  0
06E3A:  BRA    6CBA
06E3C:  MOVLW  30
06E3E:  MOVLB  3
06E40:  SUBWF  x22,W
06E42:  CLRF   03
06E44:  BTFSC  FE8.7
06E46:  DECF   03,F
06E48:  ADDWF  01,W
06E4A:  MOVWF  x1A
06E4C:  MOVF   03,W
06E4E:  ADDWFC 02,W
06E50:  MOVWF  x1B
....................             c = s[index++]; 
06E52:  MOVFF  321,03
06E56:  MOVF   x20,W
06E58:  INCF   x20,F
06E5A:  BTFSC  FD8.2
06E5C:  INCF   x21,F
06E5E:  MOVWF  x23
06E60:  MOVFF  03,324
06E64:  MOVF   x18,W
06E66:  ADDWF  x23,W
06E68:  MOVWF  FE9
06E6A:  MOVF   x19,W
06E6C:  ADDWFC 03,W
06E6E:  MOVWF  FEA
06E70:  MOVFF  FEF,322
06E74:  BRA    6E16
....................          } 
....................       } 
06E76:  BRA    6F7C
....................       else if (base == 16)    // The number is a hexa number 
06E78:  MOVF   x1E,W
06E7A:  SUBLW  10
06E7C:  BTFSS  FD8.2
06E7E:  BRA    6F7C
06E80:  MOVF   x1F,F
06E82:  BTFSS  FD8.2
06E84:  BRA    6F7C
....................       { 
....................          c = toupper(c); 
06E86:  BTFSC  x22.7
06E88:  BRA    6EA0
06E8A:  MOVF   x22,W
06E8C:  SUBLW  60
06E8E:  BC    6EA0
06E90:  BTFSC  x22.7
06E92:  BRA    6E9A
06E94:  MOVF   x22,W
06E96:  SUBLW  7A
06E98:  BNC   6EA0
06E9A:  MOVF   x22,W
06E9C:  ANDLW  DF
06E9E:  BRA    6EA2
06EA0:  MOVF   x22,W
06EA2:  MOVWF  x22
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
06EA4:  BTFSC  x22.7
06EA6:  BRA    6EB8
06EA8:  MOVF   x22,W
06EAA:  SUBLW  2F
06EAC:  BC    6EB8
06EAE:  BTFSC  x22.7
06EB0:  BRA    6ECC
06EB2:  MOVF   x22,W
06EB4:  SUBLW  39
06EB6:  BC    6ECC
06EB8:  BTFSC  x22.7
06EBA:  BRA    6F7C
06EBC:  MOVF   x22,W
06EBE:  SUBLW  40
06EC0:  BC    6F7C
06EC2:  BTFSC  x22.7
06EC4:  BRA    6ECC
06EC6:  MOVF   x22,W
06EC8:  SUBLW  46
06ECA:  BNC   6F7C
....................          { 
....................             if (c >= '0' && c <= '9') 
06ECC:  BTFSC  x22.7
06ECE:  BRA    6F10
06ED0:  MOVF   x22,W
06ED2:  SUBLW  2F
06ED4:  BC    6F10
06ED6:  BTFSC  x22.7
06ED8:  BRA    6EE0
06EDA:  MOVF   x22,W
06EDC:  SUBLW  39
06EDE:  BNC   6F10
....................                result = (result << 4) + (c - '0'); 
06EE0:  RLCF   x1A,W
06EE2:  MOVWF  x23
06EE4:  RLCF   x1B,W
06EE6:  MOVWF  x24
06EE8:  RLCF   x23,F
06EEA:  RLCF   x24,F
06EEC:  RLCF   x23,F
06EEE:  RLCF   x24,F
06EF0:  RLCF   x23,F
06EF2:  RLCF   x24,F
06EF4:  MOVLW  F0
06EF6:  ANDWF  x23,F
06EF8:  MOVLW  30
06EFA:  SUBWF  x22,W
06EFC:  CLRF   03
06EFE:  MOVWF  00
06F00:  BTFSC  FE8.7
06F02:  DECF   03,F
06F04:  ADDWF  x23,W
06F06:  MOVWF  x1A
06F08:  MOVF   03,W
06F0A:  ADDWFC x24,W
06F0C:  MOVWF  x1B
06F0E:  BRA    6F3E
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
06F10:  RLCF   x1A,W
06F12:  MOVWF  x23
06F14:  RLCF   x1B,W
06F16:  MOVWF  x24
06F18:  RLCF   x23,F
06F1A:  RLCF   x24,F
06F1C:  RLCF   x23,F
06F1E:  RLCF   x24,F
06F20:  RLCF   x23,F
06F22:  RLCF   x24,F
06F24:  MOVLW  F0
06F26:  ANDWF  x23,F
06F28:  MOVLW  41
06F2A:  SUBWF  x22,W
06F2C:  ADDLW  0A
06F2E:  CLRF   03
06F30:  BTFSC  FE8.7
06F32:  DECF   03,F
06F34:  ADDWF  x23,W
06F36:  MOVWF  x1A
06F38:  MOVF   03,W
06F3A:  ADDWFC x24,W
06F3C:  MOVWF  x1B
....................  
....................             c = s[index++]; 
06F3E:  MOVF   x21,W
06F40:  MOVWF  03
06F42:  MOVF   x20,W
06F44:  INCF   x20,F
06F46:  BTFSC  FD8.2
06F48:  INCF   x21,F
06F4A:  MOVWF  x23
06F4C:  MOVF   x18,W
06F4E:  ADDWF  x23,W
06F50:  MOVWF  FE9
06F52:  MOVF   x19,W
06F54:  ADDWFC 03,W
06F56:  MOVWF  FEA
06F58:  MOVFF  FEF,322
....................             c = toupper(c); 
06F5C:  BTFSC  x22.7
06F5E:  BRA    6F76
06F60:  MOVF   x22,W
06F62:  SUBLW  60
06F64:  BC    6F76
06F66:  BTFSC  x22.7
06F68:  BRA    6F70
06F6A:  MOVF   x22,W
06F6C:  SUBLW  7A
06F6E:  BNC   6F76
06F70:  MOVF   x22,W
06F72:  ANDLW  DF
06F74:  BRA    6F78
06F76:  MOVF   x22,W
06F78:  MOVWF  x22
06F7A:  BRA    6EA4
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
06F7C:  DECFSZ x1C,W
06F7E:  BRA    6F98
06F80:  MOVF   x1D,F
06F82:  BNZ   6F98
06F84:  MOVF   x1E,W
06F86:  SUBLW  0A
06F88:  BNZ   6F98
06F8A:  MOVF   x1F,F
06F8C:  BNZ   6F98
....................        result = -result; 
06F8E:  COMF   x1A,F
06F90:  COMF   x1B,F
06F92:  INCF   x1A,F
06F94:  BTFSC  FD8.2
06F96:  INCF   x1B,F
....................  
....................    return(result); 
06F98:  MOVFF  31A,01
06F9C:  MOVFF  31B,02
06FA0:  MOVLB  0
06FA2:  RETURN 0
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
07304:  MOVLB  2
07306:  CLRF   xF8
07308:  CLRF   xF7
....................    sign = 0; 
0730A:  CLRF   xF4
0730C:  CLRF   xF3
....................    base = 10; 
0730E:  CLRF   xF6
07310:  MOVLW  0A
07312:  MOVWF  xF5
....................    result = 0; 
07314:  CLRF   xF2
07316:  CLRF   xF1
07318:  CLRF   xF0
0731A:  CLRF   xEF
....................  
....................    if (!s) 
0731C:  MOVF   xED,W
0731E:  IORWF  xEE,W
07320:  BNZ   732C
....................       return 0; 
07322:  CLRF   00
07324:  CLRF   01
07326:  CLRF   02
07328:  CLRF   03
0732A:  BRA    764A
....................    c = s[index++]; 
0732C:  MOVFF  2F8,03
07330:  MOVF   xF7,W
07332:  INCF   xF7,F
07334:  BTFSC  FD8.2
07336:  INCF   xF8,F
07338:  MOVWF  xFA
0733A:  MOVF   xED,W
0733C:  ADDWF  xFA,W
0733E:  MOVWF  FE9
07340:  MOVF   xEE,W
07342:  ADDWFC 03,W
07344:  MOVWF  FEA
07346:  MOVFF  FEF,2F9
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0734A:  MOVF   xF9,W
0734C:  SUBLW  2D
0734E:  BNZ   7376
....................    { 
....................       sign = 1;         // Set the sign to negative 
07350:  CLRF   xF4
07352:  MOVLW  01
07354:  MOVWF  xF3
....................       c = s[index++]; 
07356:  MOVFF  2F8,03
0735A:  MOVF   xF7,W
0735C:  INCF   xF7,F
0735E:  BTFSC  FD8.2
07360:  INCF   xF8,F
07362:  MOVWF  xFA
07364:  MOVF   xED,W
07366:  ADDWF  xFA,W
07368:  MOVWF  FE9
0736A:  MOVF   xEE,W
0736C:  ADDWFC 03,W
0736E:  MOVWF  FEA
07370:  MOVFF  FEF,2F9
....................    } 
07374:  BRA    739A
....................    else if (c == '+') 
07376:  MOVF   xF9,W
07378:  SUBLW  2B
0737A:  BNZ   739A
....................    { 
....................       c = s[index++]; 
0737C:  MOVFF  2F8,03
07380:  MOVF   xF7,W
07382:  INCF   xF7,F
07384:  BTFSC  FD8.2
07386:  INCF   xF8,F
07388:  MOVWF  xFA
0738A:  MOVF   xED,W
0738C:  ADDWF  xFA,W
0738E:  MOVWF  FE9
07390:  MOVF   xEE,W
07392:  ADDWFC 03,W
07394:  MOVWF  FEA
07396:  MOVFF  FEF,2F9
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0739A:  BTFSC  xF9.7
0739C:  BRA    7612
0739E:  MOVF   xF9,W
073A0:  SUBLW  2F
073A2:  BTFSC  FD8.0
073A4:  BRA    7612
073A6:  BTFSC  xF9.7
073A8:  BRA    73B2
073AA:  MOVF   xF9,W
073AC:  SUBLW  39
073AE:  BTFSS  FD8.0
073B0:  BRA    7612
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
073B2:  MOVF   xF9,W
073B4:  SUBLW  30
073B6:  BNZ   7406
073B8:  MOVF   xED,W
073BA:  ADDWF  xF7,W
073BC:  MOVWF  FE9
073BE:  MOVF   xEE,W
073C0:  ADDWFC xF8,W
073C2:  MOVWF  FEA
073C4:  MOVF   FEF,W
073C6:  SUBLW  78
073C8:  BZ    73DC
073CA:  MOVF   xED,W
073CC:  ADDWF  xF7,W
073CE:  MOVWF  FE9
073D0:  MOVF   xEE,W
073D2:  ADDWFC xF8,W
073D4:  MOVWF  FEA
073D6:  MOVF   FEF,W
073D8:  SUBLW  58
073DA:  BNZ   7406
....................       { 
....................          base = 16; 
073DC:  CLRF   xF6
073DE:  MOVLW  10
073E0:  MOVWF  xF5
....................          index++; 
073E2:  INCF   xF7,F
073E4:  BTFSC  FD8.2
073E6:  INCF   xF8,F
....................          c = s[index++]; 
073E8:  MOVFF  2F8,03
073EC:  MOVF   xF7,W
073EE:  INCF   xF7,F
073F0:  BTFSC  FD8.2
073F2:  INCF   xF8,F
073F4:  MOVWF  xFA
073F6:  MOVF   xED,W
073F8:  ADDWF  xFA,W
073FA:  MOVWF  FE9
073FC:  MOVF   xEE,W
073FE:  ADDWFC 03,W
07400:  MOVWF  FEA
07402:  MOVFF  FEF,2F9
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
07406:  MOVF   xF5,W
07408:  SUBLW  0A
0740A:  BNZ   74AC
0740C:  MOVF   xF6,F
0740E:  BNZ   74AC
....................       { 
....................          while (c >= '0' && c <= '9') 
07410:  BTFSC  xF9.7
07412:  BRA    74AA
07414:  MOVF   xF9,W
07416:  SUBLW  2F
07418:  BC    74AA
0741A:  BTFSC  xF9.7
0741C:  BRA    7424
0741E:  MOVF   xF9,W
07420:  SUBLW  39
07422:  BNC   74AA
....................          { 
....................             result = 10*result + (c - '0'); 
07424:  MOVLB  3
07426:  CLRF   x45
07428:  CLRF   x44
0742A:  CLRF   x43
0742C:  MOVLW  0A
0742E:  MOVWF  x42
07430:  MOVFF  2F2,349
07434:  MOVFF  2F1,348
07438:  MOVFF  2F0,347
0743C:  MOVFF  2EF,346
07440:  MOVLB  0
07442:  CALL   61B0
07446:  MOVFF  03,2FD
0744A:  MOVFF  02,2FC
0744E:  MOVFF  01,2FB
07452:  MOVFF  00,2FA
07456:  MOVLW  30
07458:  MOVLB  2
0745A:  SUBWF  xF9,W
0745C:  MOVWF  00
0745E:  CLRF   01
07460:  CLRF   02
07462:  CLRF   03
07464:  BTFSS  FE8.7
07466:  BRA    746E
07468:  DECF   01,F
0746A:  DECF   02,F
0746C:  DECF   03,F
0746E:  MOVF   00,W
07470:  ADDWF  xFA,W
07472:  MOVWF  xEF
07474:  MOVF   01,W
07476:  ADDWFC xFB,W
07478:  MOVWF  xF0
0747A:  MOVF   02,W
0747C:  ADDWFC xFC,W
0747E:  MOVWF  xF1
07480:  MOVF   03,W
07482:  ADDWFC xFD,W
07484:  MOVWF  xF2
....................             c = s[index++]; 
07486:  MOVFF  2F8,03
0748A:  MOVF   xF7,W
0748C:  INCF   xF7,F
0748E:  BTFSC  FD8.2
07490:  INCF   xF8,F
07492:  MOVWF  xFA
07494:  MOVFF  03,2FB
07498:  MOVF   xED,W
0749A:  ADDWF  xFA,W
0749C:  MOVWF  FE9
0749E:  MOVF   xEE,W
074A0:  ADDWFC 03,W
074A2:  MOVWF  FEA
074A4:  MOVFF  FEF,2F9
074A8:  BRA    7410
....................          } 
....................       } 
074AA:  BRA    7612
....................       else if (base == 16)    // The number is a hexa number 
074AC:  MOVF   xF5,W
074AE:  SUBLW  10
074B0:  BTFSS  FD8.2
074B2:  BRA    7612
074B4:  MOVF   xF6,F
074B6:  BTFSS  FD8.2
074B8:  BRA    7612
....................       { 
....................          c = toupper(c); 
074BA:  BTFSC  xF9.7
074BC:  BRA    74D4
074BE:  MOVF   xF9,W
074C0:  SUBLW  60
074C2:  BC    74D4
074C4:  BTFSC  xF9.7
074C6:  BRA    74CE
074C8:  MOVF   xF9,W
074CA:  SUBLW  7A
074CC:  BNC   74D4
074CE:  MOVF   xF9,W
074D0:  ANDLW  DF
074D2:  BRA    74D6
074D4:  MOVF   xF9,W
074D6:  MOVWF  xF9
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
074D8:  BTFSC  xF9.7
074DA:  BRA    74EC
074DC:  MOVF   xF9,W
074DE:  SUBLW  2F
074E0:  BC    74EC
074E2:  BTFSC  xF9.7
074E4:  BRA    7504
074E6:  MOVF   xF9,W
074E8:  SUBLW  39
074EA:  BC    7504
074EC:  BTFSC  xF9.7
074EE:  BRA    7612
074F0:  MOVF   xF9,W
074F2:  SUBLW  40
074F4:  BTFSC  FD8.0
074F6:  BRA    7612
074F8:  BTFSC  xF9.7
074FA:  BRA    7504
074FC:  MOVF   xF9,W
074FE:  SUBLW  46
07500:  BTFSS  FD8.0
07502:  BRA    7612
....................          { 
....................             if (c >= '0' && c <= '9') 
07504:  BTFSC  xF9.7
07506:  BRA    7574
07508:  MOVF   xF9,W
0750A:  SUBLW  2F
0750C:  BC    7574
0750E:  BTFSC  xF9.7
07510:  BRA    7518
07512:  MOVF   xF9,W
07514:  SUBLW  39
07516:  BNC   7574
....................                result = (result << 4) + (c - '0'); 
07518:  RLCF   xEF,W
0751A:  MOVWF  xFB
0751C:  RLCF   xF0,W
0751E:  MOVWF  xFC
07520:  RLCF   xF1,W
07522:  MOVWF  xFD
07524:  RLCF   xF2,W
07526:  MOVWF  xFE
07528:  RLCF   xFB,F
0752A:  RLCF   xFC,F
0752C:  RLCF   xFD,F
0752E:  RLCF   xFE,F
07530:  RLCF   xFB,F
07532:  RLCF   xFC,F
07534:  RLCF   xFD,F
07536:  RLCF   xFE,F
07538:  RLCF   xFB,F
0753A:  RLCF   xFC,F
0753C:  RLCF   xFD,F
0753E:  RLCF   xFE,F
07540:  MOVLW  F0
07542:  ANDWF  xFB,F
07544:  MOVLW  30
07546:  SUBWF  xF9,W
07548:  MOVWF  00
0754A:  CLRF   01
0754C:  CLRF   02
0754E:  CLRF   03
07550:  BTFSS  FE8.7
07552:  BRA    755A
07554:  DECF   01,F
07556:  DECF   02,F
07558:  DECF   03,F
0755A:  MOVF   00,W
0755C:  ADDWF  xFB,W
0755E:  MOVWF  xEF
07560:  MOVF   01,W
07562:  ADDWFC xFC,W
07564:  MOVWF  xF0
07566:  MOVF   02,W
07568:  ADDWFC xFD,W
0756A:  MOVWF  xF1
0756C:  MOVF   03,W
0756E:  ADDWFC xFE,W
07570:  MOVWF  xF2
07572:  BRA    75D0
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
07574:  RLCF   xEF,W
07576:  MOVWF  xFB
07578:  RLCF   xF0,W
0757A:  MOVWF  xFC
0757C:  RLCF   xF1,W
0757E:  MOVWF  xFD
07580:  RLCF   xF2,W
07582:  MOVWF  xFE
07584:  RLCF   xFB,F
07586:  RLCF   xFC,F
07588:  RLCF   xFD,F
0758A:  RLCF   xFE,F
0758C:  RLCF   xFB,F
0758E:  RLCF   xFC,F
07590:  RLCF   xFD,F
07592:  RLCF   xFE,F
07594:  RLCF   xFB,F
07596:  RLCF   xFC,F
07598:  RLCF   xFD,F
0759A:  RLCF   xFE,F
0759C:  MOVLW  F0
0759E:  ANDWF  xFB,F
075A0:  MOVLW  41
075A2:  SUBWF  xF9,W
075A4:  ADDLW  0A
075A6:  MOVWF  00
075A8:  CLRF   01
075AA:  CLRF   02
075AC:  CLRF   03
075AE:  BTFSS  FE8.7
075B0:  BRA    75B8
075B2:  DECF   01,F
075B4:  DECF   02,F
075B6:  DECF   03,F
075B8:  MOVF   00,W
075BA:  ADDWF  xFB,W
075BC:  MOVWF  xEF
075BE:  MOVF   01,W
075C0:  ADDWFC xFC,W
075C2:  MOVWF  xF0
075C4:  MOVF   02,W
075C6:  ADDWFC xFD,W
075C8:  MOVWF  xF1
075CA:  MOVF   03,W
075CC:  ADDWFC xFE,W
075CE:  MOVWF  xF2
....................  
....................             c = s[index++];c = toupper(c); 
075D0:  MOVFF  2F8,03
075D4:  MOVF   xF7,W
075D6:  INCF   xF7,F
075D8:  BTFSC  FD8.2
075DA:  INCF   xF8,F
075DC:  MOVWF  xFA
075DE:  MOVFF  03,2FB
075E2:  MOVF   xED,W
075E4:  ADDWF  xFA,W
075E6:  MOVWF  FE9
075E8:  MOVF   xEE,W
075EA:  ADDWFC 03,W
075EC:  MOVWF  FEA
075EE:  MOVFF  FEF,2F9
075F2:  BTFSC  xF9.7
075F4:  BRA    760C
075F6:  MOVF   xF9,W
075F8:  SUBLW  60
075FA:  BC    760C
075FC:  BTFSC  xF9.7
075FE:  BRA    7606
07600:  MOVF   xF9,W
07602:  SUBLW  7A
07604:  BNC   760C
07606:  MOVF   xF9,W
07608:  ANDLW  DF
0760A:  BRA    760E
0760C:  MOVF   xF9,W
0760E:  MOVWF  xF9
07610:  BRA    74D8
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
07612:  MOVF   xF5,W
07614:  SUBLW  0A
07616:  BNZ   763A
07618:  MOVF   xF6,F
0761A:  BNZ   763A
0761C:  DECFSZ xF3,W
0761E:  BRA    763A
07620:  MOVF   xF4,F
07622:  BNZ   763A
....................       result = -result; 
07624:  COMF   xEF,F
07626:  COMF   xF0,F
07628:  COMF   xF1,F
0762A:  COMF   xF2,F
0762C:  INCF   xEF,F
0762E:  BTFSC  FD8.2
07630:  INCF   xF0,F
07632:  BTFSC  FD8.2
07634:  INCF   xF1,F
07636:  BTFSC  FD8.2
07638:  INCF   xF2,F
....................  
....................    return(result); 
0763A:  MOVFF  2EF,00
0763E:  MOVFF  2F0,01
07642:  MOVFF  2F1,02
07646:  MOVFF  2F2,03
0764A:  MOVLB  0
0764C:  GOTO   8912 (RETURN)
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
*
0620C:  MOVLB  3
0620E:  CLRF   x18
06210:  CLRF   x17
06212:  CLRF   x16
06214:  CLRF   x15
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
06216:  MOVLW  30
06218:  MOVWF  x1A
0621A:  MOVLW  31
0621C:  MOVWF  x1B
0621E:  MOVLW  32
06220:  MOVWF  x1C
06222:  MOVLW  33
06224:  MOVWF  x1D
06226:  MOVLW  34
06228:  MOVWF  x1E
0622A:  MOVLW  35
0622C:  MOVWF  x1F
0622E:  MOVLW  36
06230:  MOVWF  x20
06232:  MOVLW  37
06234:  MOVWF  x21
06236:  MOVLW  38
06238:  MOVWF  x22
0623A:  MOVLW  39
0623C:  MOVWF  x23
0623E:  MOVLW  61
06240:  MOVWF  x24
06242:  MOVLW  62
06244:  MOVWF  x25
06246:  MOVLW  63
06248:  MOVWF  x26
0624A:  MOVLW  64
0624C:  MOVWF  x27
0624E:  MOVLW  65
06250:  MOVWF  x28
06252:  MOVLW  66
06254:  MOVWF  x29
06256:  MOVLW  67
06258:  MOVWF  x2A
0625A:  MOVLW  68
0625C:  MOVWF  x2B
0625E:  MOVLW  69
06260:  MOVWF  x2C
06262:  MOVLW  6A
06264:  MOVWF  x2D
06266:  MOVLW  6B
06268:  MOVWF  x2E
0626A:  MOVLW  6C
0626C:  MOVWF  x2F
0626E:  MOVLW  6D
06270:  MOVWF  x30
06272:  MOVLW  6E
06274:  MOVWF  x31
06276:  MOVLW  6F
06278:  MOVWF  x32
0627A:  MOVLW  70
0627C:  MOVWF  x33
0627E:  MOVLW  71
06280:  MOVWF  x34
06282:  MOVLW  73
06284:  MOVWF  x35
06286:  MOVLW  74
06288:  MOVWF  x36
0628A:  MOVLW  75
0628C:  MOVWF  x37
0628E:  MOVLW  76
06290:  MOVWF  x38
06292:  MOVLW  77
06294:  MOVWF  x39
06296:  MOVLW  78
06298:  MOVWF  x3A
0629A:  MOVLW  79
0629C:  MOVWF  x3B
0629E:  MOVLW  7A
062A0:  MOVWF  x3C
062A2:  CLRF   x3D
....................    for(sc=s;isspace(*sc);++sc); 
062A4:  MOVFF  30A,310
062A8:  MOVFF  309,30F
062AC:  MOVFF  310,03
062B0:  MOVFF  30F,FE9
062B4:  MOVFF  310,FEA
062B8:  MOVF   FEF,W
062BA:  SUBLW  20
062BC:  BNZ   62C6
062BE:  INCF   x0F,F
062C0:  BTFSC  FD8.2
062C2:  INCF   x10,F
062C4:  BRA    62AC
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
062C6:  MOVFF  310,03
062CA:  MOVFF  30F,FE9
062CE:  MOVFF  310,FEA
062D2:  MOVF   FEF,W
062D4:  SUBLW  2D
062D6:  BZ    62EA
062D8:  MOVFF  310,03
062DC:  MOVFF  30F,FE9
062E0:  MOVFF  310,FEA
062E4:  MOVF   FEF,W
062E6:  SUBLW  2B
062E8:  BNZ   6300
062EA:  MOVFF  310,03
062EE:  MOVF   x0F,W
062F0:  INCF   x0F,F
062F2:  BTFSC  FD8.2
062F4:  INCF   x10,F
062F6:  MOVWF  FE9
062F8:  MOVFF  03,FEA
062FC:  MOVF   FEF,W
062FE:  BRA    6302
06300:  MOVLW  2B
06302:  MOVWF  x19
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
06304:  MOVF   x19,W
06306:  SUBLW  2D
06308:  BZ    6324
0630A:  BTFSC  x0E.7
0630C:  BRA    6324
0630E:  DECFSZ x0D,W
06310:  BRA    6316
06312:  MOVF   x0E,F
06314:  BZ    6324
06316:  BTFSC  x0E.7
06318:  BRA    6328
0631A:  MOVF   x0E,F
0631C:  BNZ   6324
0631E:  MOVF   x0D,W
06320:  SUBLW  24
06322:  BC    6328
....................    goto StrtoulGO; 
06324:  BRA    65BE
06326:  BRA    6446
....................  
....................    else if (base) 
06328:  MOVF   x0D,W
0632A:  IORWF  x0E,W
0632C:  BZ    63D2
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
0632E:  MOVF   x0D,W
06330:  SUBLW  10
06332:  BNZ   6376
06334:  MOVF   x0E,F
06336:  BNZ   6376
06338:  MOVFF  310,03
0633C:  MOVFF  30F,FE9
06340:  MOVFF  310,FEA
06344:  MOVF   FEF,W
06346:  SUBLW  30
06348:  BNZ   6376
0634A:  MOVLW  01
0634C:  ADDWF  x0F,W
0634E:  MOVWF  FE9
06350:  MOVLW  00
06352:  ADDWFC x10,W
06354:  MOVWF  FEA
06356:  MOVF   FEF,W
06358:  SUBLW  78
0635A:  BZ    636E
0635C:  MOVLW  01
0635E:  ADDWF  x0F,W
06360:  MOVWF  FE9
06362:  MOVLW  00
06364:  ADDWFC x10,W
06366:  MOVWF  FEA
06368:  MOVF   FEF,W
0636A:  SUBLW  58
0636C:  BNZ   6376
....................          sc+=2; 
0636E:  MOVLW  02
06370:  ADDWF  x0F,F
06372:  MOVLW  00
06374:  ADDWFC x10,F
....................       if(base==8 && *sc =='0') 
06376:  MOVF   x0D,W
06378:  SUBLW  08
0637A:  BNZ   639A
0637C:  MOVF   x0E,F
0637E:  BNZ   639A
06380:  MOVFF  310,03
06384:  MOVFF  30F,FE9
06388:  MOVFF  310,FEA
0638C:  MOVF   FEF,W
0638E:  SUBLW  30
06390:  BNZ   639A
....................          sc+=1; 
06392:  MOVLW  01
06394:  ADDWF  x0F,F
06396:  MOVLW  00
06398:  ADDWFC x10,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
0639A:  MOVF   x0D,W
0639C:  SUBLW  02
0639E:  BNZ   63D0
063A0:  MOVF   x0E,F
063A2:  BNZ   63D0
063A4:  MOVFF  310,03
063A8:  MOVFF  30F,FE9
063AC:  MOVFF  310,FEA
063B0:  MOVF   FEF,W
063B2:  SUBLW  30
063B4:  BNZ   63D0
063B6:  MOVLW  01
063B8:  ADDWF  x0F,W
063BA:  MOVWF  FE9
063BC:  MOVLW  00
063BE:  ADDWFC x10,W
063C0:  MOVWF  FEA
063C2:  MOVF   FEF,W
063C4:  SUBLW  62
063C6:  BNZ   63D0
....................          sc+=2; 
063C8:  MOVLW  02
063CA:  ADDWF  x0F,F
063CC:  MOVLW  00
063CE:  ADDWFC x10,F
....................  
....................    } 
063D0:  BRA    6446
....................    else if(*sc!='0') // base is 0, find base 
063D2:  MOVFF  310,03
063D6:  MOVFF  30F,FE9
063DA:  MOVFF  310,FEA
063DE:  MOVF   FEF,W
063E0:  SUBLW  30
063E2:  BZ    63EC
....................       base=10; 
063E4:  CLRF   x0E
063E6:  MOVLW  0A
063E8:  MOVWF  x0D
063EA:  BRA    6446
....................    else if (sc[1]=='x' || sc[1]=='X') 
063EC:  MOVLW  01
063EE:  ADDWF  x0F,W
063F0:  MOVWF  FE9
063F2:  MOVLW  00
063F4:  ADDWFC x10,W
063F6:  MOVWF  FEA
063F8:  MOVF   FEF,W
063FA:  SUBLW  78
063FC:  BZ    6410
063FE:  MOVLW  01
06400:  ADDWF  x0F,W
06402:  MOVWF  FE9
06404:  MOVLW  00
06406:  ADDWFC x10,W
06408:  MOVWF  FEA
0640A:  MOVF   FEF,W
0640C:  SUBLW  58
0640E:  BNZ   6420
....................       base =16,sc+=2; 
06410:  CLRF   x0E
06412:  MOVLW  10
06414:  MOVWF  x0D
06416:  MOVLW  02
06418:  ADDWF  x0F,F
0641A:  MOVLW  00
0641C:  ADDWFC x10,F
0641E:  BRA    6446
....................    else if(sc[1]=='b') 
06420:  MOVLW  01
06422:  ADDWF  x0F,W
06424:  MOVWF  FE9
06426:  MOVLW  00
06428:  ADDWFC x10,W
0642A:  MOVWF  FEA
0642C:  MOVF   FEF,W
0642E:  SUBLW  62
06430:  BNZ   6440
....................       base=2,sc+=2; 
06432:  CLRF   x0E
06434:  MOVLW  02
06436:  MOVWF  x0D
06438:  ADDWF  x0F,F
0643A:  MOVLW  00
0643C:  ADDWFC x10,F
0643E:  BRA    6446
....................    else 
....................       base=8; 
06440:  CLRF   x0E
06442:  MOVLW  08
06444:  MOVWF  x0D
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
06446:  MOVFF  310,312
0644A:  MOVFF  30F,311
0644E:  MOVFF  310,03
06452:  MOVFF  30F,FE9
06456:  MOVFF  310,FEA
0645A:  MOVF   FEF,W
0645C:  SUBLW  30
0645E:  BNZ   6468
06460:  INCF   x0F,F
06462:  BTFSC  FD8.2
06464:  INCF   x10,F
06466:  BRA    644E
....................    sd=memchr(digits,tolower(*sc),base); 
06468:  MOVFF  310,03
0646C:  MOVFF  30F,FE9
06470:  MOVFF  310,FEA
06474:  MOVFF  FEF,33E
06478:  BTFSC  x3E.7
0647A:  BRA    6492
0647C:  MOVF   x3E,W
0647E:  SUBLW  40
06480:  BC    6492
06482:  BTFSC  x3E.7
06484:  BRA    648C
06486:  MOVF   x3E,W
06488:  SUBLW  5A
0648A:  BNC   6492
0648C:  MOVF   x3E,W
0648E:  IORLW  20
06490:  BRA    6494
06492:  MOVF   x3E,W
06494:  MOVWF  x3E
06496:  MOVLW  03
06498:  MOVWF  x40
0649A:  MOVLW  1A
0649C:  MOVWF  x3F
0649E:  MOVFF  33E,341
064A2:  MOVFF  30E,343
064A6:  MOVFF  30D,342
064AA:  MOVLB  0
064AC:  RCALL  6162
064AE:  MOVFF  02,314
064B2:  MOVFF  01,313
....................    for(; sd!=0; ) 
064B6:  MOVLB  3
064B8:  MOVF   x13,F
064BA:  BNZ   64C2
064BC:  MOVF   x14,F
064BE:  BTFSC  FD8.2
064C0:  BRA    65B2
....................    { 
....................       x=x*base+(int16)(sd-digits); 
064C2:  MOVFF  30D,00
064C6:  MOVFF  30E,01
064CA:  CLRF   02
064CC:  CLRF   03
064CE:  BTFSS  x0E.7
064D0:  BRA    64D6
064D2:  DECF   02,F
064D4:  DECF   03,F
064D6:  MOVFF  03,341
064DA:  MOVFF  02,340
064DE:  MOVFF  01,33F
064E2:  MOVFF  00,33E
064E6:  MOVFF  318,345
064EA:  MOVFF  317,344
064EE:  MOVFF  316,343
064F2:  MOVFF  315,342
064F6:  MOVFF  03,349
064FA:  MOVFF  02,348
064FE:  MOVFF  01,347
06502:  MOVFF  00,346
06506:  MOVLB  0
06508:  RCALL  61B0
0650A:  MOVFF  03,341
0650E:  MOVFF  02,340
06512:  MOVFF  01,33F
06516:  MOVFF  00,33E
0651A:  MOVLW  1A
0651C:  MOVLB  3
0651E:  SUBWF  x13,W
06520:  MOVWF  00
06522:  MOVLW  03
06524:  SUBWFB x14,W
06526:  MOVWF  03
06528:  MOVF   00,W
0652A:  MOVFF  03,01
0652E:  CLRF   02
06530:  CLRF   03
06532:  BTFSS  01.7
06534:  BRA    653A
06536:  DECF   02,F
06538:  DECF   03,F
0653A:  MOVF   x3E,W
0653C:  ADDWF  00,F
0653E:  MOVF   x3F,W
06540:  ADDWFC 01,F
06542:  MOVF   x40,W
06544:  ADDWFC 02,F
06546:  MOVF   x41,W
06548:  ADDWFC 03,F
0654A:  MOVFF  03,318
0654E:  MOVFF  02,317
06552:  MOVFF  01,316
06556:  MOVFF  00,315
....................       ++sc; 
0655A:  INCF   x0F,F
0655C:  BTFSC  FD8.2
0655E:  INCF   x10,F
....................       sd=memchr(digits,tolower(*sc),base); 
06560:  MOVFF  310,03
06564:  MOVFF  30F,FE9
06568:  MOVFF  310,FEA
0656C:  MOVFF  FEF,33E
06570:  BTFSC  x3E.7
06572:  BRA    658A
06574:  MOVF   x3E,W
06576:  SUBLW  40
06578:  BC    658A
0657A:  BTFSC  x3E.7
0657C:  BRA    6584
0657E:  MOVF   x3E,W
06580:  SUBLW  5A
06582:  BNC   658A
06584:  MOVF   x3E,W
06586:  IORLW  20
06588:  BRA    658C
0658A:  MOVF   x3E,W
0658C:  MOVWF  x3E
0658E:  MOVLW  03
06590:  MOVWF  x40
06592:  MOVLW  1A
06594:  MOVWF  x3F
06596:  MOVFF  33E,341
0659A:  MOVFF  30E,343
0659E:  MOVFF  30D,342
065A2:  MOVLB  0
065A4:  RCALL  6162
065A6:  MOVFF  02,314
065AA:  MOVFF  01,313
065AE:  BRA    64B6
065B0:  MOVLB  3
....................    } 
....................    if(s1==sc) 
065B2:  MOVF   x0F,W
065B4:  SUBWF  x11,W
065B6:  BNZ   65E0
065B8:  MOVF   x10,W
065BA:  SUBWF  x12,W
065BC:  BNZ   65E0
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
065BE:  MOVF   x0B,W
065C0:  IORWF  x0C,W
065C2:  BZ    65D6
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
065C4:  MOVFF  30B,FE9
065C8:  MOVFF  30C,FEA
065CC:  MOVFF  30A,FEC
065D0:  MOVF   FED,F
065D2:  MOVFF  309,FEF
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
065D6:  CLRF   00
065D8:  CLRF   01
065DA:  CLRF   02
065DC:  CLRF   03
065DE:  BRA    6608
....................    } 
....................    if (endptr) 
065E0:  MOVF   x0B,W
065E2:  IORWF  x0C,W
065E4:  BZ    65F8
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
065E6:  MOVFF  30B,FE9
065EA:  MOVFF  30C,FEA
065EE:  MOVFF  310,FEC
065F2:  MOVF   FED,F
065F4:  MOVFF  30F,FEF
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
065F8:  MOVFF  315,00
065FC:  MOVFF  316,01
06600:  MOVFF  317,02
06604:  MOVFF  318,03
06608:  MOVLB  0
0660A:  GOTO   67C0 (RETURN)
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... #ifdef BYTE 
.................... #undef BYTE 
.................... #endif 
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
.................... #include "Compiler.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Compiler and hardware specific definitions 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Compiler.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, PIC24E, dsPIC30F, dsPIC33F,  
....................  *               dsPIC33E, PIC32 
....................  * Compiler:        Microchip C32 v1.00 or higher 
....................  *               Microchip C30 v3.01 or higher 
....................  *               Microchip C18 v3.13 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights  
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and  
....................  * distribute:  
....................  * (i)  the Software when embedded on a Microchip microcontroller or  
....................  *      digital signal controller product ("Device") which is  
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c and  
....................  *      ENC28J60.h ported to a non-Microchip device used in  
....................  *      conjunction with a Microchip ethernet controller for the  
....................  *      sole purpose of interfacing with the ethernet controller.  
....................  * 
....................  * You should refer to the license agreement accompanying this  
....................  * Software for additional information regarding your rights and  
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT  
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT  
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A  
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL  
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR  
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF  
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS  
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER  
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT  
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * 10/03/2006   Original, copied from old Compiler.h 
....................  * 11/07/2007   Reorganized and simplified 
....................  * 03/31/2010   Removed dependency on WORD and DWORD typedefs 
....................  * 04/14/2010   Added defines to uniquely identify each compiler 
....................  ********************************************************************/ 
.................... #ifndef __COMPILER_H 
.................... #define __COMPILER_H 
....................  
.................... // Include proper device header file 
.................... #if defined(__18CXX) && !defined(HI_TECH_C)    
....................    // PIC18 processor with Microchip C18 compiler 
....................     #define COMPILER_MPLAB_C18 
....................     #include <p18cxxx.h> 
.................... // CCS PCH C Compiler to Microchip C18 Compiler compatability layer. 
....................  
.................... #ifndef __P18CXXXX_H__ 
.................... #define __P18CXXXX_H__ 
....................  
.................... #ifndef __18CXX 
.................... #define __18CXX 
.................... #endif 
....................  
.................... //#zero_local_ram 
.................... #zero_ram 
....................  
....................  
.................... #device PASS_STRINGS=IN_RAM 
.................... #device CONST=READ_ONLY 
....................  
.................... #case 
.................... #type signed 
.................... #type short=16 int=16 long=32 
....................  
.................... #define _asm #asm 
.................... #define _endasm #endasm 
....................  
.................... /* usualy 
.................... #define GetSystemClock()      getenv("CLOCK") 
.................... #define GetInstructionClock()   (GetSystemClock()/4) 
.................... #define GetPeripheralClock()   (unsigned int32)GetInstructionClock() 
.................... */ 
....................  
.................... #if getenv("DEVICE") == "PIC18F97J60" 
....................  #define __18F97J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F96J65" 
....................  #define __18F96J65) 
.................... #elif getenv("DEVICE") == "PIC18F96J60" 
....................  #define __18F96J60 
.................... #elif getenv("DEVICE") == "PIC18F87J60" 
....................  #define __18F87J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J60" 
....................  #define __18F86J60 
.................... #elif getenv("DEVICE") == "PIC18F67J60" 
....................  #define __18F67J60 
....................  #include "PIC18F67J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F66J65" 
....................  #define __18F66J65 
.................... #elif getenv("DEVICE") == "PIC18F66J60" 
....................  #define __18F66J60 
.................... #elif getenv("DEVICE") == "PIC18F67K22" 
....................  #define __18F67K22 
....................  #include "PIC18F67K22_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F4620" 
....................  #define __18F4620 
....................  #include "PIC18F4620_registers.h" 
.................... #else 
....................    #error Do this for your chip 
.................... #endif 
....................  
.................... #if defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) 
....................    #reserve 0xE80:0xEFF 
....................    #reserve 0xF00:0xFFF 
.................... #endif 
....................  
.................... #if defined(TRUE) 
....................    #undef TRUE 
.................... #endif 
....................  
.................... #if defined(FALSE) 
....................    #undef FALSE 
.................... #endif 
....................  
.................... #if defined(BYTE) 
....................    #undef BYTE 
.................... #endif 
....................  
....................       #define Reset()            reset_cpu() 
....................         #define far 
....................         #define ClrWdt()         restart_wdt() 
....................       #define Nop()            delay_cycles(1)       
....................  
.................... #define __CCS__ 
....................  
.................... //signed int8 memcmppgm2ram(void * s1, rom char *s2, unsigned int8 n); 
.................... signed int8 strcmppgm2ram(char *s1, __ADDRESS__ s2); 
.................... char *strchrpgm(__ADDRESS__ s, unsigned int8 c); 
.................... char *strstrrampgm(char *s1, __ADDRESS__ s2); 
.................... unsigned int8 strlenpgm(__ADDRESS__ s); 
.................... void memcpypgm2ram(unsigned int8 *d, __ADDRESS__ s, unsigned int16 n); 
.................... //char* strupr(char *s);   now in string.h 
.................... void strcpypgm2ram(char *d, __ADDRESS__ s); 
.................... #endif 
....................  
.................... #elif defined(__PICC18__) && defined(HI_TECH_C)    
....................    // PIC18 processor with (Microchip) HI-TECH PICC-18 compiler 
....................    #if !defined(__18CXX) 
....................       #define __18CXX 
....................    #endif 
....................     #define COMPILER_HITECH_PICC18 
....................    #include <htc.h> 
.................... #elif (defined(__PIC24F__) || defined(__PIC24FK__)) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Fxxxx.h> 
.................... #elif defined(__PIC24H__) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24H processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Hxxxx.h> 
.................... #elif defined(__PIC24E__) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24E processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Exxxx.h> 
.................... #elif defined(__dsPIC33F__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC33F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p33Fxxxx.h> 
.................... #elif defined(__dsPIC33E__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC33E processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p33Exxxx.h> 
.................... #elif defined(__dsPIC30F__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC30F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p30fxxxx.h> 
.................... #elif defined(__C30__)      // Microchip C30 compiler, but targeting "generic-16bit" processor. 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p30sim.h> 
....................    // Define some useful inline assembly functions which are normally in the  
....................    // processor header files, but absent from the generic p30sim.h file. 
....................    #if !defined(Nop) 
....................       #define Nop()    __builtin_nop() 
....................       #define ClrWdt() {__asm__ volatile ("clrwdt");} 
....................       #define Sleep()  {__asm__ volatile ("pwrsav #0");} 
....................       #define Idle()   {__asm__ volatile ("pwrsav #1");} 
....................    #endif 
.................... #elif defined(__PIC32MX__)   // Microchip C32 compiler 
....................    #if !defined(__C32__) 
....................       #define __C32__ 
....................    #endif 
....................     #define COMPILER_MPLAB_C32 
....................    #include <p32xxxx.h> 
....................    #include <plib.h> 
.................... #else 
....................    #error Unknown processor or compiler.  See Compiler.h 
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... // Base RAM and ROM pointer types for given architecture 
.................... #if defined(__PCH__) || defined(__PCD__) 
....................    #define PTR_BASE      unsigned int16 
....................    #define ROM_PTR_BASE   unsigned int32 
.................... #elif defined(__PIC32MX__) 
....................    #define PTR_BASE      unsigned long 
....................    #define ROM_PTR_BASE   unsigned long 
.................... #elif defined(__C30__) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned short 
.................... #elif defined(COMPILER_MPLAB_C18) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned short long 
.................... #elif defined(COMPILER_HITECH_PICC18) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned long 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all except Microchip MPLAB C Compiler for PIC18 MCUs (C18) 
.................... #if !defined(COMPILER_MPLAB_C18) 
....................    #define memcmppgm2ram(a,b,c)   memcmp(a,b,c) 
....................    #define strcmppgm2ram(a,b)      strcmp(a,b) 
....................   #if defined(__PCD__) 
....................    #warning temporary 4.121 fix 
....................    #define memcpypgm2ram(a,b,c)   memcpy(a,b|0x8000,c) 
....................   #else 
....................    #define memcpypgm2ram(a,b,c)   memcpy(a,b,c) 
....................   #endif 
....................    #define strcpypgm2ram(a,b)      strcpy(a,b) 
....................    #define strncpypgm2ram(a,b,c)   strncpy(a,b,c) 
....................    #define strstrrampgm(a,b)      strstr(a,b) 
....................    #define   strlenpgm(a)         strlen(a) 
....................    #define strchrpgm(a,b)         strchr(a,b) 
....................    #define strcatpgm2ram(a,b)      strcat(a,b) 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all 8-bit products 
.................... // (PIC18) 
.................... #if defined(__18CXX) 
....................    #define   __attribute__(a) 
....................  
....................     #define FAR                         far 
....................  
....................    // Microchip C18 specific defines 
....................    #if defined(COMPILER_MPLAB_C18) 
....................        #define ROM                    rom 
....................    #endif 
....................     
....................    // HI TECH PICC-18 specific defines 
....................    #if defined(COMPILER_HITECH_PICC18) 
....................        #define ROM                    const 
....................       #define rom 
....................        #define Nop()                  asm("NOP"); 
....................       #define ClrWdt()            asm("CLRWDT"); 
....................        #define Reset()               asm("RESET"); 
....................    #endif 
....................      
.................... // Definitions that apply to all 16-bit and 32-bit products 
.................... // (PIC24F, PIC24H, dsPIC30F, dsPIC33F, and PIC32) 
.................... #else 
....................    #define   ROM                  const 
....................  
....................    // 16-bit specific defines (PIC24F, PIC24H, dsPIC30F, dsPIC33F) 
....................    #if defined(__C30__) && !defined(__PCD__) 
....................       #define Reset()            asm("reset") 
....................         #define FAR                 __attribute__((far)) 
....................    #endif 
....................  
....................    // 32-bit specific defines (PIC32) 
....................    #if defined(__PIC32MX__) 
....................       #define persistent 
....................       #define far 
....................         #define FAR 
....................       #define Reset()            SoftReset() 
....................       #define ClrWdt()         (WDTCONSET = _WDTCON_WDTCLR_MASK) 
....................  
....................       // MPLAB C Compiler for PIC32 MCUs version 1.04 and below don't have a  
....................       // Nop() function. However, version 1.05 has Nop() declared as _nop(). 
....................       #if !defined(Nop) && (__C32_VERSION__ <= 104) 
....................          #define Nop()            asm("nop") 
....................       #endif 
....................    #endif 
.................... #endif 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "HardwareProfile.h" 
.................... // hardwareprofile.h 
....................  
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #if STACK_USE_CCS_EWLWIFIB || STACK_USE_CCS_EWLWIFIG 
....................  
....................    #bit WF_CS_TRIS1   =     0xF96.1 //E1 
....................    #define WF_CS_TRIS WF_CS_TRIS1 
....................    #bit WF_CS_IO     =  0xF8D.1    //LatE1 
....................    #bit WF_SDI_TRIS  =  0xF94.4    // (TRISCbits.TRISC4) 
....................    #bit WF_SCK_TRIS  =  0xF94.3    // (TRISCbits.TRISC3) 
....................    #bit WF_SDO_TRIS  =  0xF94.5    // (TRISCbits.TRISC5) 
....................    #bit WF_RESET_TRIS=  0xF93.1    //(TRISBbits.TRISB1) 
....................    #bit WF_RESET_IO  =  0xF8A.1     //(LATBbits.LATB1)   
....................    #bit WF_INT_TRIS  =  0xF93.0     // (TRISBbits.TRISB0)  // INT1 
....................    #bit WF_INT_IO    =  0xF81.0   //(PORTBbits.RB0)  
....................    #bit WF_HIBERNATE_TRIS= 0xF93.2  //(TRISBbits.TRISB2)  
....................    #bit   WF_HIBERNATE_IO=  0xF81.2    //(PORTBbits.RB2) 
....................     
....................    #bit WF_INT_EDGE  =  0xFF1.6      //(INTCON2bits.INTEDG0) 
....................    #bit WF_INT_IE    =  0xFF2.4   //(INTCONbits.INT0IE) 
....................    #bit WF_INT_IF    =  0xFF2.1   //(INTCONbits.INT0IF) 
....................    #define WF_SSPBUF  (SSP1BUF) 
....................    #define WF_SPISTAT  (SSP1STATbits) 
....................    #define WF_SPISTATbits SSP1STATbits     //(SSP1STATbits) 
....................    #define WF_SPICON1  (SSP1CON1bits) 
....................    #define WF_SPICON1bits WF_SPICON1    // (SSP1CON1bits) 
....................    #define WF_SPICON2  (SSP1CON2bits) 
....................    #bit WF_SPI_IE    =   0xF9D.3  //(PIE1bits.SSPIE) 
....................    #bit WF_SPI_IP    =   0xF9F.3  //(IPR1bits.SSPIP) 
....................    #bit WF_SPI_IF    =   0xF9E.3  //(PIR1bits.SSPIF) 
....................     
.................... #else 
....................  
.................... //#error define necessary hardware for TCPIP stack 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
.................... /* 
....................    TCPIPConfig.h used by all of CCS's TCP/IP examples. 
....................     
....................    Usually you use a Microchip tool to generate one of these files for 
....................    your projects.  But since we are using this .h for many projects, 
....................    some stuff is conditionally compiled out or commented out, and then 
....................    defined in the application code instead. 
.................... */ 
.................... /********************************************************************* 
....................  * 
....................  *   Microchip TCP/IP Stack Demo Application Configuration Header 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIPConfig.h 
....................  * Dependencies:    Microchip TCP/IP Stack 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.10 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.34 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder      10/04/2006   Original 
....................  * Ken Hesky            07/01/2008  Added ZG2100-specific features 
....................  * SG                   03/25/2009  Added ZGLinkMgrII specific features 
....................  ********************************************************************/ 
.................... #ifndef __TCPIPCONFIG_H 
.................... #define __TCPIPCONFIG_H 
....................  
.................... #include "GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... #ifdef BYTE 
.................... #undef BYTE 
.................... #endif 
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
.................... #include "Compiler.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Compiler and hardware specific definitions 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Compiler.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, PIC24E, dsPIC30F, dsPIC33F,  
....................  *               dsPIC33E, PIC32 
....................  * Compiler:        Microchip C32 v1.00 or higher 
....................  *               Microchip C30 v3.01 or higher 
....................  *               Microchip C18 v3.13 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights  
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and  
....................  * distribute:  
....................  * (i)  the Software when embedded on a Microchip microcontroller or  
....................  *      digital signal controller product ("Device") which is  
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c and  
....................  *      ENC28J60.h ported to a non-Microchip device used in  
....................  *      conjunction with a Microchip ethernet controller for the  
....................  *      sole purpose of interfacing with the ethernet controller.  
....................  * 
....................  * You should refer to the license agreement accompanying this  
....................  * Software for additional information regarding your rights and  
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT  
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT  
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A  
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL  
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR  
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF  
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS  
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER  
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT  
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * 10/03/2006   Original, copied from old Compiler.h 
....................  * 11/07/2007   Reorganized and simplified 
....................  * 03/31/2010   Removed dependency on WORD and DWORD typedefs 
....................  * 04/14/2010   Added defines to uniquely identify each compiler 
....................  ********************************************************************/ 
.................... #ifndef __COMPILER_H 
.................... #define __COMPILER_H 
....................  
.................... // Include proper device header file 
.................... #if defined(__18CXX) && !defined(HI_TECH_C)    
....................    // PIC18 processor with Microchip C18 compiler 
....................     #define COMPILER_MPLAB_C18 
....................     #include <p18cxxx.h> 
.................... #elif defined(__PICC18__) && defined(HI_TECH_C)    
....................    // PIC18 processor with (Microchip) HI-TECH PICC-18 compiler 
....................    #if !defined(__18CXX) 
....................       #define __18CXX 
....................    #endif 
....................     #define COMPILER_HITECH_PICC18 
....................    #include <htc.h> 
.................... #elif (defined(__PIC24F__) || defined(__PIC24FK__)) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Fxxxx.h> 
.................... #elif defined(__PIC24H__) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24H processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Hxxxx.h> 
.................... #elif defined(__PIC24E__) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24E processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Exxxx.h> 
.................... #elif defined(__dsPIC33F__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC33F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p33Fxxxx.h> 
.................... #elif defined(__dsPIC33E__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC33E processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p33Exxxx.h> 
.................... #elif defined(__dsPIC30F__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC30F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p30fxxxx.h> 
.................... #elif defined(__C30__)      // Microchip C30 compiler, but targeting "generic-16bit" processor. 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p30sim.h> 
....................    // Define some useful inline assembly functions which are normally in the  
....................    // processor header files, but absent from the generic p30sim.h file. 
....................    #if !defined(Nop) 
....................       #define Nop()    __builtin_nop() 
....................       #define ClrWdt() {__asm__ volatile ("clrwdt");} 
....................       #define Sleep()  {__asm__ volatile ("pwrsav #0");} 
....................       #define Idle()   {__asm__ volatile ("pwrsav #1");} 
....................    #endif 
.................... #elif defined(__PIC32MX__)   // Microchip C32 compiler 
....................    #if !defined(__C32__) 
....................       #define __C32__ 
....................    #endif 
....................     #define COMPILER_MPLAB_C32 
....................    #include <p32xxxx.h> 
....................    #include <plib.h> 
.................... #else 
....................    #error Unknown processor or compiler.  See Compiler.h 
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... #include <stdlib.h> 
.................... #include <string.h> 
....................  
....................  
.................... // Base RAM and ROM pointer types for given architecture 
.................... #if defined(__PCH__) || defined(__PCD__) 
....................    #define PTR_BASE      unsigned int16 
....................    #define ROM_PTR_BASE   unsigned int32 
.................... #elif defined(__PIC32MX__) 
....................    #define PTR_BASE      unsigned long 
....................    #define ROM_PTR_BASE   unsigned long 
.................... #elif defined(__C30__) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned short 
.................... #elif defined(COMPILER_MPLAB_C18) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned short long 
.................... #elif defined(COMPILER_HITECH_PICC18) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned long 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all except Microchip MPLAB C Compiler for PIC18 MCUs (C18) 
.................... #if !defined(COMPILER_MPLAB_C18) 
....................    #define memcmppgm2ram(a,b,c)   memcmp(a,b,c) 
....................    #define strcmppgm2ram(a,b)      strcmp(a,b) 
....................   #if defined(__PCD__) 
....................    #warning temporary 4.121 fix 
....................    #define memcpypgm2ram(a,b,c)   memcpy(a,b|0x8000,c) 
....................   #else 
....................    #define memcpypgm2ram(a,b,c)   memcpy(a,b,c) 
....................   #endif 
....................    #define strcpypgm2ram(a,b)      strcpy(a,b) 
....................    #define strncpypgm2ram(a,b,c)   strncpy(a,b,c) 
....................    #define strstrrampgm(a,b)      strstr(a,b) 
....................    #define   strlenpgm(a)         strlen(a) 
....................    #define strchrpgm(a,b)         strchr(a,b) 
....................    #define strcatpgm2ram(a,b)      strcat(a,b) 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all 8-bit products 
.................... // (PIC18) 
.................... #if defined(__18CXX) 
....................    #define   __attribute__(a) 
....................  
....................     #define FAR                         far 
....................  
....................    // Microchip C18 specific defines 
....................    #if defined(COMPILER_MPLAB_C18) 
....................        #define ROM                    rom 
....................    #endif 
....................     
....................    // HI TECH PICC-18 specific defines 
....................    #if defined(COMPILER_HITECH_PICC18) 
....................        #define ROM                    const 
....................       #define rom 
....................        #define Nop()                  asm("NOP"); 
....................       #define ClrWdt()            asm("CLRWDT"); 
....................        #define Reset()               asm("RESET"); 
....................    #endif 
....................      
.................... // Definitions that apply to all 16-bit and 32-bit products 
.................... // (PIC24F, PIC24H, dsPIC30F, dsPIC33F, and PIC32) 
.................... #else 
....................    #define   ROM                  const 
....................  
....................    // 16-bit specific defines (PIC24F, PIC24H, dsPIC30F, dsPIC33F) 
....................    #if defined(__C30__) && !defined(__PCD__) 
....................       #define Reset()            asm("reset") 
....................         #define FAR                 __attribute__((far)) 
....................    #endif 
....................  
....................    // 32-bit specific defines (PIC32) 
....................    #if defined(__PIC32MX__) 
....................       #define persistent 
....................       #define far 
....................         #define FAR 
....................       #define Reset()            SoftReset() 
....................       #define ClrWdt()         (WDTCONSET = _WDTCON_WDTCLR_MASK) 
....................  
....................       // MPLAB C Compiler for PIC32 MCUs version 1.04 and below don't have a  
....................       // Nop() function. However, version 1.05 has Nop() declared as _nop(). 
....................       #if !defined(Nop) && (__C32_VERSION__ <= 104) 
....................          #define Nop()            asm("nop") 
....................       #endif 
....................    #endif 
.................... #endif 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... // ======================================================================= 
.................... //   Application Options 
.................... // ======================================================================= 
....................  
.................... /* Application Level Module Selection 
....................  *   Uncomment or comment the following lines to enable or 
....................  *   disabled the following high-level application modules. 
....................  */ 
.................... //#define STACK_USE_UART               // Application demo using UART for IP address display and stack configuration 
.................... //#define STACK_USE_UART2TCP_BRIDGE      // UART to TCP Bridge application example 
.................... //#define STACK_USE_IP_GLEANING 
.................... //#define STACK_USE_ICMP_SERVER         // Ping query and response capability 
.................... //#define STACK_USE_ICMP_CLIENT         // Ping transmission capability 
.................... //#define STACK_USE_HTTP_SERVER         // Old HTTP server 
.................... //#define STACK_USE_HTTP2_SERVER         // New HTTP server with POST, Cookies, Authentication, etc. 
.................... //#define STACK_USE_SSL_SERVER         // SSL server socket support (Requires SW300052) 
.................... //#define STACK_USE_SSL_CLIENT         // SSL client socket support (Requires SW300052) 
.................... //#define STACK_USE_AUTO_IP               // Dynamic link-layer IP address automatic configuration protocol 
.................... //#define STACK_USE_DHCP_CLIENT         // Dynamic Host Configuration Protocol client for obtaining IP address and other parameters 
.................... //#define STACK_USE_DHCP_SERVER         // Single host DHCP server 
.................... //#define STACK_USE_FTP_SERVER         // File Transfer Protocol (old) 
.................... //#define STACK_USE_SMTP_CLIENT         // Simple Mail Transfer Protocol for sending email 
.................... //#define STACK_USE_SNMP_SERVER         // Simple Network Management Protocol v2C Community Agent 
.................... //#define STACK_USE_SNMPV3_SERVER         // Simple Network Management Protocol v3 Agent 
.................... //#define STACK_USE_TFTP_CLIENT         // Trivial File Transfer Protocol client 
.................... //#define STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE   // HTTP Client example in GenericTCPClient.c 
.................... //#define STACK_USE_GENERIC_TCP_SERVER_EXAMPLE   // ToUpper server example in GenericTCPServer.c 
.................... //#define STACK_USE_TELNET_SERVER         // Telnet server 
.................... //#define STACK_USE_ANNOUNCE            // Microchip Embedded Ethernet Device Discoverer server/client 
.................... //#define STACK_USE_DNS               // Domain Name Service Client for resolving hostname strings to IP addresses 
.................... //#define STACK_USE_DNS_SERVER         // Domain Name Service Server for redirection to the local device 
.................... //#define STACK_USE_NBNS               // NetBIOS Name Service Server for repsonding to NBNS hostname broadcast queries 
.................... //#define STACK_USE_REBOOT_SERVER         // Module for resetting this PIC remotely.  Primarily useful for a Bootloader. 
.................... //#define STACK_USE_SNTP_CLIENT         // Simple Network Time Protocol for obtaining current date/time from Internet 
.................... //#define STACK_USE_UDP_PERFORMANCE_TEST   // Module for testing UDP TX performance characteristics.  NOTE: Enabling this will cause a huge amount of UDP broadcast packets to flood your network on the discard port.  Use care when enabling this on production networks, especially with VPNs (could tunnel broadcast traffic across a limited bandwidth connection). 
.................... //#define STACK_USE_TCP_PERFORMANCE_TEST   // Module for testing TCP TX performance characteristics 
.................... //#define STACK_USE_DYNAMICDNS_CLIENT      // Dynamic DNS client updater module 
.................... //#define STACK_USE_BERKELEY_API         // Berekely Sockets APIs are available 
.................... //#define STACK_USE_ZEROCONF_LINK_LOCAL   // Zeroconf IPv4 Link-Local Addressing 
.................... //#define STACK_USE_ZEROCONF_MDNS_SD      // Zeroconf mDNS and mDNS service discovery 
....................  
....................  
.................... // ======================================================================= 
.................... //   Data Storage Options 
.................... // ======================================================================= 
....................  
.................... /* MPFS Configuration 
....................  *   MPFS is automatically included when required for other 
....................  *   applications.  If your custom application requires it 
....................  *   otherwise, uncomment the appropriate selection. 
....................  */ 
.................... //#define STACK_USE_MPFS 
.................... //#define STACK_USE_MPFS2 
....................  
.................... /* MPFS Storage Location 
....................  *   If html pages are stored in internal program memory, 
....................  *   comment both MPFS_USE_EEPROM and MPFS_USE_SPI_FLASH, then 
....................  *   include an MPFS image (.c or .s file) in the project. 
....................  *   If html pages are stored in external memory, uncomment the 
....................  *   appropriate definition. 
....................  * 
....................  *   Supported serial flash parts include the SST25VFxxxB series. 
....................  */ 
.................... //#define MPFS_USE_EEPROM 
.................... //#define MPFS_USE_SPI_FLASH 
....................  
.................... /* EEPROM Addressing Selection 
....................  *   If using the 1Mbit EEPROM, uncomment this line 
....................  */ 
.................... //#define USE_EEPROM_25LC1024 
....................  
.................... /* EEPROM Reserved Area 
....................  *   Number of EEPROM bytes to be reserved before MPFS storage starts. 
....................  *   These bytes host application configurations such as IP Address, 
....................  *   MAC Address, and any other required variables. 
....................  * 
....................  *   For MPFS Classic, this setting must match the Reserved setting 
....................  *    on the Advanced Settings page of the MPFS2 Utility. 
....................  */ 
.................... //#define MPFS_RESERVE_BLOCK            #error do this 
....................  
.................... /* MPFS File Handles 
....................  *   Maximum number of simultaneously open MPFS2 files. 
....................  *   For MPFS Classic, this has no effect. 
....................  */ 
.................... //#define MAX_MPFS_HANDLES            (7ul) 
....................  
....................  
.................... // ======================================================================= 
.................... //   Network Addressing Options 
.................... // ======================================================================= 
....................  
.................... /* Default Network Configuration 
....................  *   These settings are only used if data is not found in EEPROM. 
....................  *   To clear EEPROM, hold BUTTON0, reset the board, and continue 
....................  *   holding until the LEDs flash.  Release, and reset again. 
....................  */ 
.................... #define MY_DEFAULT_HOST_NAME            "CCS_EXAMPLES" 
....................  
.................... /*#define MY_DEFAULT_MAC_BYTE1            (0x00)   // Use the default of 00-04-A3-00-00-00 
.................... #define MY_DEFAULT_MAC_BYTE2            (0x04)   // if using an ENCX24J600, MRF24WB0M, or 
.................... #define MY_DEFAULT_MAC_BYTE3            (0xA3)   // PIC32MX6XX/7XX internal Ethernet  
.................... #define MY_DEFAULT_MAC_BYTE4            (0x00)   // controller and wish to use the  
.................... #define MY_DEFAULT_MAC_BYTE5            (0x00)   // internal factory programmed MAC 
.................... #define MY_DEFAULT_MAC_BYTE6            (0x00)   // address instead. */ 
....................  
.................... #define MY_DEFAULT_MAC_BYTE1            (0x00)   // Use the default of 00-04-A3-00-00-00 
.................... #define MY_DEFAULT_MAC_BYTE2            (0x20)   // if using an ENCX24J600, MRF24WB0M, or 
.................... #define MY_DEFAULT_MAC_BYTE3            (0x30)   // PIC32MX6XX/7XX internal Ethernet  
.................... #define MY_DEFAULT_MAC_BYTE4            (0x40)   // controller and wish to use the  
.................... #define MY_DEFAULT_MAC_BYTE5            (0x50)   // internal factory programmed MAC 
.................... #define MY_DEFAULT_MAC_BYTE6            (0x60)   // address instead. 
....................  
.................... #define MY_DEFAULT_IP_ADDR_BYTE1        (192ul) 
.................... #define MY_DEFAULT_IP_ADDR_BYTE2        (168ul) 
.................... #define MY_DEFAULT_IP_ADDR_BYTE3        (100ul) 
.................... #define MY_DEFAULT_IP_ADDR_BYTE4        (120ul) 
....................  
.................... #define MY_DEFAULT_MASK_BYTE1           (255ul) 
.................... #define MY_DEFAULT_MASK_BYTE2           (255ul) 
.................... #define MY_DEFAULT_MASK_BYTE3           (255ul) 
.................... #define MY_DEFAULT_MASK_BYTE4           (0ul) 
....................  
.................... #define MY_DEFAULT_GATE_BYTE1           (192ul) 
.................... #define MY_DEFAULT_GATE_BYTE2           (168ul) 
.................... #define MY_DEFAULT_GATE_BYTE3           (100ul) 
.................... #define MY_DEFAULT_GATE_BYTE4           (1ul) 
....................  
.................... #define MY_DEFAULT_PRIMARY_DNS_BYTE1   (192ul) 
.................... #define MY_DEFAULT_PRIMARY_DNS_BYTE2   (168ul) 
.................... #define MY_DEFAULT_PRIMARY_DNS_BYTE3   (100ul) 
.................... #define MY_DEFAULT_PRIMARY_DNS_BYTE4   (1ul) 
....................  
.................... #define MY_DEFAULT_SECONDARY_DNS_BYTE1   (0ul) 
.................... #define MY_DEFAULT_SECONDARY_DNS_BYTE2   (0ul) 
.................... #define MY_DEFAULT_SECONDARY_DNS_BYTE3   (0ul) 
.................... #define MY_DEFAULT_SECONDARY_DNS_BYTE4   (0ul) 
....................  
.................... // ======================================================================= 
.................... //   PIC32MX7XX/6XX MAC Layer Options 
.................... //   If not using a PIC32MX7XX/6XX device, ignore this section. 
.................... // ======================================================================= 
.................... /*#define   ETH_CFG_LINK         0      // set to 1 if you need to config the link to specific following parameters 
....................                               // otherwise the default connection will be attempted 
....................                               // depending on the selected PHY 
....................    #define   ETH_CFG_AUTO      1      // use auto negotiation 
....................    #define   ETH_CFG_10         1      // use/advertise 10 Mbps capability 
....................    #define   ETH_CFG_100         1      // use/advertise 100 Mbps capability 
....................    #define   ETH_CFG_HDUPLEX      1      // use/advertise half duplex capability 
....................    #define   ETH_CFG_FDUPLEX      1      // use/advertise full duplex capability 
....................    #define   ETH_CFG_AUTO_MDIX   1      // use/advertise auto MDIX capability 
....................    #define   ETH_CFG_SWAP_MDIX   1      // use swapped MDIX. else normal MDIX 
....................  
.................... #define EMAC_TX_DESCRIPTORS      2      // number of the TX descriptors to be created 
.................... #define EMAC_RX_DESCRIPTORS      8      // number of the RX descriptors and RX buffers to be created 
....................  
.................... #define   EMAC_RX_BUFF_SIZE      1536   // size of a RX buffer. should be multiple of 16 
....................                               // this is the size of all receive buffers processed by the ETHC 
....................                               // The size should be enough to accomodate any network received packet 
....................                               // If the packets are larger, they will have to take multiple RX buffers 
....................                               // The current implementation does not handle this situation right now and the packet is discarded. 
.................... */ 
....................  
.................... // ======================================================================= 
.................... //   Transport Layer Options 
.................... // ======================================================================= 
....................  
.................... /* Transport Layer Configuration 
....................  *   The following low level modules are automatically enabled 
....................  *   based on module selections above.  If your custom module 
....................  *   requires them otherwise, enable them here. 
....................  */ 
.................... //#define STACK_USE_TCP 
.................... //#define STACK_USE_UDP 
....................  
.................... /* Client Mode Configuration 
....................  *   Uncomment following line if this stack will be used in CLIENT 
....................  *   mode.  In CLIENT mode, some functions specific to client operation 
....................  *   are enabled. 
....................  */ 
.................... #define STACK_CLIENT_MODE 
....................  
.................... /* TCP Socket Memory Allocation 
....................  *   TCP needs memory to buffer incoming and outgoing data.  The 
....................  *   amount and medium of storage can be allocated on a per-socket 
....................  *   basis using the example below as a guide. 
....................  */ 
....................    // Allocate how much total RAM (in bytes) you want to allocate 
....................    // for use by your TCP TCBs, RX FIFOs, and TX FIFOs. 
....................   #ifndef TCP_ETH_RAM_SIZE 
....................    #define TCP_ETH_RAM_SIZE                 (8192ul) 
....................   #endif 
....................    #define TCP_PIC_RAM_SIZE                 (0ul) 
....................    #define TCP_SPI_RAM_SIZE                 (0ul) 
....................    #define TCP_SPI_RAM_BASE_ADDRESS         (0x00) 
....................  
....................    // Define names of socket types 
....................    #define TCP_SOCKET_TYPES 
....................       #define TCP_PURPOSE_GENERIC_TCP_CLIENT 0 
....................       #define TCP_PURPOSE_GENERIC_TCP_SERVER 1 
....................       #define TCP_PURPOSE_TELNET 2 
....................       #define TCP_PURPOSE_FTP_COMMAND 3 
....................       #define TCP_PURPOSE_FTP_DATA 4 
....................       #define TCP_PURPOSE_TCP_PERFORMANCE_TX 5 
....................       #define TCP_PURPOSE_TCP_PERFORMANCE_RX 6 
....................       #define TCP_PURPOSE_UART_2_TCP_BRIDGE 7 
....................       #define TCP_PURPOSE_HTTP_SERVER 8 
....................       #define TCP_PURPOSE_DEFAULT 9 
....................       #define TCP_PURPOSE_BERKELEY_SERVER 10 
....................       #define TCP_PURPOSE_BERKELEY_CLIENT 11 
....................    #define END_OF_TCP_SOCKET_TYPES 
....................  
....................    //changed the check here because it was set up for linking, not static compiling 
....................       typedef struct 
....................       { 
....................          BYTE vSocketPurpose; 
....................          BYTE vMemoryMedium; 
....................          WORD wTXBufferSize; 
....................          WORD wRXBufferSize;       
....................       } TCPSocketInitializer_t; 
....................      #if defined(STACK_USE_TCP) && defined(TCP_CONFIGURATION) 
....................       //ccs bug, wouldn't let me extern empty brace 
....................       extern TCPSocketInitializer_t TCPSocketInitializer[TCP_CONFIGURATION]; 
....................      #endif 
....................    #if defined(STACK_USE_TCP) && !defined(TCP_CONFIGURATION) 
....................       // Define what types of sockets are needed, how many of 
....................       // each to include, where their TCB, TX FIFO, and RX FIFO 
....................       // should be stored, and how big the RX and TX FIFOs should 
....................       // be.  Making this initializer bigger or smaller defines 
....................       // how many total TCP sockets are available. 
....................       // 
....................       // Each socket requires up to 56 bytes of PIC RAM and 
....................       // 48+(TX FIFO size)+(RX FIFO size) bytes of TCP_*_RAM each. 
....................       // 
....................       // Note: The RX FIFO must be at least 1 byte in order to 
....................       // receive SYN and FIN messages required by TCP.  The TX 
....................       // FIFO can be zero if desired. 
....................       #define TCP_CONFIGURATION  1 
....................       //REMOVED ROM prefix -Tim 
....................       TCPSocketInitializer_t TCPSocketInitializer[TCP_CONFIGURATION] = 
....................       { 
....................           {TCP_PURPOSE_DEFAULT, TCP_ETH_RAM, 250, 250} 
....................       }; 
....................       #define END_OF_TCP_CONFIGURATION 
....................    #endif  
....................  
.................... #ifndef MAX_HTTP_CONNECTIONS 
....................    #define  MAX_HTTP_CONNECTIONS 1 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
....................    #define MAX_UDP_SOCKETS 7 
.................... #endif    
....................     
.................... /* UDP Socket Configuration 
....................  *   Define the maximum number of available UDP Sockets, and whether 
....................  *   or not to include a checksum on packets being transmitted. 
....................  */ 
.................... //#define MAX_UDP_SOCKETS           
.................... //#define UDP_USE_TX_CHECKSUM      // This slows UDP TX performance by nearly 50%, except when using the ENCX24J600 or PIC32MX6XX/7XX, which have a super fast DMA and incurs virtually no speed pentalty. 
....................  
....................  
.................... /* Berkeley API Sockets Configuration 
....................  *   Note that each Berkeley socket internally uses one TCP or UDP socket 
....................  *   defined by MAX_UDP_SOCKETS and the TCPSocketInitializer[] array. 
....................  *   Therefore, this number MUST be less than or equal to MAX_UDP_SOCKETS + the 
....................  *   number of TCP sockets defined by the TCPSocketInitializer[] array 
....................  *   (i.e. sizeof(TCPSocketInitializer)/sizeof(TCPSocketInitializer[0])). 
....................  *   This define has no effect if STACK_USE_BERKELEY_API is not defined and 
....................  *   Berkeley Sockets are disabled.  Set this value as low as your application 
....................  *   requires to avoid waisting RAM. 
....................  */ 
.................... //#define BSD_SOCKET_COUNT (5u) 
....................  
....................  
.................... // ======================================================================= 
.................... //   Application-Specific Options 
.................... // ======================================================================= 
....................  
.................... // -- HTTP2 Server options ----------------------------------------------- 
....................  
....................    // Maximum numbers of simultaneous HTTP connections allowed. 
....................    // Each connection consumes 2 bytes of RAM and a TCP socket 
....................    //#define MAX_HTTP_CONNECTIONS   (2u) 
....................  
....................    // Optional setting to use PIC RAM instead of Ethernet/Wi-Fi RAM for 
....................    // storing HTTP Connection Context variables (HTTP_CONN structure for each  
....................    // HTTP connection).  Undefining this macro results in the Ethernet/Wi-Fi  
....................    // RAM being used (minimum PIC RAM usage, lower performance).  Defining  
....................    // this macro results in PIC RAM getting used (higher performance, but uses  
....................    // PIC RAM).  This option should not be enabled on PIC18 devices.  The  
....................    // performance increase of having this option defined is only apparent when  
....................    // the HTTP server is servicing multiple connections simultaneously. 
....................    //#define HTTP_SAVE_CONTEXT_IN_PIC_RAM 
....................  
....................    // Indicate what file to serve when no specific one is requested 
....................    //#define HTTP_DEFAULT_FILE      "index.htm" 
....................    //#define HTTPS_DEFAULT_FILE      "index.htm" 
....................    //#define HTTP_DEFAULT_LEN      (10u)      // For buffer overrun protection. 
....................                                     // Set to longest length of above two strings. 
....................  
....................    // Configure MPFS over HTTP updating 
....................    // Comment this line to disable updating via HTTP 
....................    //#define HTTP_MPFS_UPLOAD      "mpfsupload" 
....................    //#define HTTP_MPFS_UPLOAD_REQUIRES_AUTH   // Require password for MPFS uploads 
....................       // Certain firewall and router combinations cause the MPFS2 Utility to fail 
....................       // when uploading.  If this happens, comment out this definition. 
....................  
....................    // Define which HTTP modules to use 
....................    // If not using a specific module, comment it to save resources 
....................    //#define HTTP_USE_POST               // Enable POST support 
....................    //#define HTTP_USE_COOKIES            // Enable cookie support 
....................    //#define HTTP_USE_AUTHENTICATION         // Enable basic authentication support 
....................  
....................    //#define HTTP_NO_AUTH_WITHOUT_SSL      // Uncomment to require SSL before requesting a password 
....................  
....................     // Define the listening port for the HTTP server 
....................      //#define HTTP_PORT               (80u) 
....................     
....................     // Define the listening port for the HTTPS server (if STACK_USE_SSL_SERVER is enabled) 
....................    //#define HTTPS_PORT            (443u) 
....................     
....................     // Define the maximum data length for reading cookie and GET/POST arguments (bytes) 
....................    //#define HTTP_MAX_DATA_LEN      (%HTTP_MAX_DATA_LEN%) 
....................     
....................     // Define the minimum number of bytes free in the TX FIFO before executing callbacks 
....................    //#define HTTP_MIN_CALLBACK_FREE   (16u) 
.................... // -- SSL Options -------------------------------------------------------- 
....................  
....................    //#define MAX_SSL_CONNECTIONS      (2ul)   // Maximum connections via SSL 
....................    //#define MAX_SSL_SESSIONS      (2ul)   // Max # of cached SSL sessions 
....................    //#define MAX_SSL_BUFFERS         (4ul)   // Max # of SSL buffers (2 per socket) 
....................    //#define MAX_SSL_HASHES         (5ul)   // Max # of SSL hashes  (2 per, plus 1 to avoid deadlock) 
....................  
....................    // Bits in SSL RSA key.  This parameter is used for SSL sever 
....................    // connections only.  The only valid value is 512 bits (768 and 1024 
....................    // bits do not work at this time).  Note, however, that SSL client 
....................    // operations do currently work up to 1024 bit RSA key length. 
....................    #define SSL_RSA_KEY_SIZE      (512ul) 
....................  
....................  
.................... // -- Telnet Options ----------------------------------------------------- 
....................  
....................    // Number of simultaneously allowed Telnet sessions.  Note that you 
....................    // must have an equal number of TCP_PURPOSE_TELNET type TCP sockets 
....................    // declared in the TCPSocketInitializer[] array above for multiple 
....................    // connections to work.  If fewer sockets are available than this 
....................    // definition, then the the lesser of the two quantities will be the 
....................    // actual limit. 
....................    //#define MAX_TELNET_CONNECTIONS   (1u) 
....................  
....................    // Default local listening port for the Telnet server.  Port 23 is the 
....................    // protocol default. 
....................    //#define TELNET_PORT            23 
....................  
....................    // Default local listening port for the Telnet server when SSL secured. 
....................    // Port 992 is the telnets protocol default. 
....................    //#define TELNETS_PORT         992 
....................  
....................    // Force all connecting clients to be SSL secured and connected via 
....................    // TELNETS_PORT.  Connections on port TELNET_PORT will be ignored.  If 
....................    // STACK_USE_SSL_SERVER is undefined, this entire setting is ignored 
....................    // (server will accept unsecured connections on TELNET_PORT and won't even 
....................    // listen on TELNETS_PORT). 
....................    //#define TELNET_REJECT_UNSECURED 
....................  
....................    // Default username and password required to login to the Telnet server. 
....................    //#define TELNET_USERNAME         "admin" 
....................    //#define TELNET_PASSWORD         "microchip" 
....................  
....................  
.................... // -- SNMP Options ------------------------------------------------------- 
....................  
....................    // Comment following line if SNMP TRAP support is needed 
....................    //#define SNMP_TRAP_DISABLED 
....................  
....................    //#define SNMP_STACK_USE_V2_TRAP 
....................    #if defined(STACK_USE_SNMPV3_SERVER) 
....................       #define SNMP_V1_V2_TRAP_WITH_SNMPV3 
....................    #endif 
....................  
....................    // This is the maximum length for community string. 
....................    // Application must ensure that this length is observed. 
....................    // SNMP module adds one byte extra after SNMP_COMMUNITY_MAX_LEN 
....................    // for adding '\0' NULL character. 
....................    //#define SNMP_COMMUNITY_MAX_LEN     (8u) 
....................    //#define SNMP_MAX_COMMUNITY_SUPPORT   (3u) 
....................    //#define NOTIFY_COMMUNITY_LEN      (SNMP_COMMUNITY_MAX_LEN) 
....................  
....................    // Default SNMPv2C community names.  These can be overridden at run time if 
....................    // alternate strings are present in external EEPROM or Flash (actual 
....................    // strings are stored in AppConfig.readCommunity[] and 
....................    // AppConfig.writeCommunity[] arrays).  These strings are case sensitive. 
....................    // An empty string means disabled (not matchable). 
....................    // For application security, these default community names should not be 
....................    // used, but should all be disabled to force the end user to select unique 
....................    // community names.  These defaults are provided only to make it easier to 
....................    // start development.  Specifying more strings than 
....................    // SNMP_MAX_COMMUNITY_SUPPORT will result in the later strings being 
....................    // ignored (but still wasting program memory).  Specifying fewer strings is 
....................    // legal, as long as at least one is present.  A string larger than 
....................    // SNMP_COMMUNITY_MAX_LEN bytes will be ignored. 
....................    //#define SNMP_READ_COMMUNITIES      {"public", "read", ""} 
....................    //#define END_OF_SNMP_READ_COMMUNITIES 
....................    //#define SNMP_WRITE_COMMUNITIES        {"private", "write", "public"} 
....................    //#define END_OF_SNMP_WRITE_COMMUNITIES 
.................... #endif 
....................  
....................  
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definitions 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    Compiler.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,  
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,  
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook/CCS      WIFI networkType added to AppConfig, hopefully 
....................  *                         this doesn't conflict with EZ_CONFIG_STORE.  
....................  *                      WIFI adhocBehavior added to AppConfig. 
....................  ********************************************************************/ 
.................... #ifndef __STACK_TSK_H 
.................... #define __STACK_TSK_H 
....................  
.................... #if defined (WF_CS_TRIS) 
....................     #include "WF_Config.h"      
.................... #endif 
....................  
.................... // Check for potential configuration errors in "TCPIPConfig.h" 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 ) 
.................... #error Invalid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... // Check for potential configuration errors in "TCPIPConfig.h" 
.................... #if (MAX_HTTP_CONNECTIONS <= 0 || MAX_HTTP_CONNECTIONS > 255 ) 
.................... #error Invalid MAX_HTTP_CONNECTIONS value specified. 
.................... #endif 
....................  
.................... // Structure to contain a MAC address 
.................... typedef struct __attribute__((__packed__)) 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... // Definition to represent an IP address 
.................... #define IP_ADDR      DWORD_VAL 
....................  
.................... // Address structure for a node 
.................... typedef struct __attribute__((__packed__)) 
.................... { 
....................     IP_ADDR     IPAddr; 
....................     MAC_ADDR    MACAddr; 
.................... } NODE_INFO; 
....................  
.................... // Application-dependent structure used to contain address information 
.................... typedef struct __attribute__((__packed__)) appConfigStruct  
.................... { 
....................    IP_ADDR      MyIPAddr;               // IP address 
....................    IP_ADDR      MyMask;                 // Subnet mask 
....................    IP_ADDR      MyGateway;              // Default Gateway 
....................    IP_ADDR      PrimaryDNSServer;       // Primary DNS Server 
....................    IP_ADDR      SecondaryDNSServer;     // Secondary DNS Server 
....................    IP_ADDR      DefaultIPAddr;          // Default IP address 
....................    IP_ADDR      DefaultMask;            // Default subnet mask 
....................    BYTE      NetBIOSName[16];        // NetBIOS name 
....................    struct 
....................    { 
....................       unsigned char : 6; 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    } Flags;                            // Flag structure 
....................    MAC_ADDR   MyMACAddr;              // Application MAC address 
....................  
.................... #if defined(WF_CS_TRIS) 
....................    BYTE      MySSID[32];             // Wireless SSID (if using MRF24W) 
....................    BYTE        SsidLength;             // number of bytes in SSID 
....................    BYTE        SecurityMode;           // WF_SECURITY_OPEN or one of the other security modes 
....................    BYTE        SecurityKey[64];        // WiFi Security key, or passphrase.    
....................    BYTE        SecurityKeyLength;      // number of bytes in security key (can be 0) 
....................    BYTE        WepKeyIndex;            // WEP key index (only valid for WEP) 
....................    BYTE        networkType; 
....................    BYTE        adhocBehavior; 
....................     #if defined(EZ_CONFIG_STORE) // WLAN configuration data stored to NVM 
....................     BYTE        dataValid; 
....................     //BYTE        networkType; 
....................     BYTE        saveSecurityInfo;       // Save 32-byte PSK 
....................     #endif 
.................... #endif 
....................     
.................... #if defined(STACK_USE_SNMP_SERVER) || defined(STACK_USE_SNMPV3_SERVER) 
....................    // SNMPv2C Read community names 
....................    // SNMP_COMMUNITY_MAX_LEN (8) + 1 null termination byte 
....................    BYTE readCommunity[SNMP_MAX_COMMUNITY_SUPPORT][SNMP_COMMUNITY_MAX_LEN+1];  
....................  
....................    // SNMPv2C Write community names 
....................    // SNMP_COMMUNITY_MAX_LEN (8) + 1 null termination byte 
....................    BYTE writeCommunity[SNMP_MAX_COMMUNITY_SUPPORT][SNMP_COMMUNITY_MAX_LEN+1]; 
....................  
....................    UINT32 SnmpEngineBootRcrd; 
.................... #endif 
....................  
.................... } APP_CONFIG; 
....................  
.................... #ifndef THIS_IS_STACK_APPLICATION 
....................     extern APP_CONFIG AppConfig; 
.................... #endif 
....................  
....................  
.................... void StackInit(void); 
.................... void StackTask(void); 
.................... void StackApplications(void); 
.................... #endif 
....................  
.................... #include "TCPIP Stack/Helpers.h" 
.................... /********************************************************************* 
....................  Header file for Helpers.c 
....................   
....................  FileName:      Helpers.h 
....................  Dependencies:  See INCLUDES section 
....................  Processor:     PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:      Microchip C18, C30, C32 
....................  Company:       Microchip Technology, Inc. 
....................  
....................  Software License Agreement 
....................  
....................  Copyright (C) 2002-2011 Microchip Technology Inc.  All rights 
....................  reserved. 
....................  
....................  Microchip licenses to you the right to use, modify, copy, and 
....................  distribute: 
....................  (i)  the Software when embedded on a Microchip microcontroller or 
....................       digital signal controller product ("Device") which is 
....................       integrated into Licensee's product; or 
....................  (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
.................... 		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
.................... 		used in conjunction with a Microchip ethernet controller for 
.................... 		the sole purpose of interfacing with the ethernet controller. 
....................  
....................  You should refer to the license agreement accompanying this 
....................  Software for additional information regarding your rights and 
....................  obligations. 
....................  
....................  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  
....................  ******************************************************************** 
....................  File Description: 
....................   
....................  Change History: 
....................   
....................   Rev         Description 
....................   ----------  ------------------------------------------------------- 
....................   1.0 - 5.31  Initial release 
....................   5.36        Updated compile time check for ultoa(); 
....................  ********************************************************************/ 
.................... #ifndef __HELPERS_H 
.................... #define __HELPERS_H 
....................  
....................  
.................... #if !defined(__18CXX) || defined(HI_TECH_C) 
.................... 	char *strupr(char* s); 
.................... #endif 
....................  
.................... // Implement consistent ultoa() function 
.................... #if (defined(__PIC32MX__) && (__C32_VERSION__ < 112)) || (defined (__C30__) && (__C30_VERSION__ < 325)) || defined(__C30_LEGACY_LIBC__) || defined(__C32_LEGACY_LIBC__) 
.................... 	// C32 < 1.12 and C30 < v3.25 need this 2 parameter stack implemented function 
.................... 	void ultoa(DWORD Value, BYTE* Buffer); 
.................... #elif defined(__18CXX) && !defined(HI_TECH_C) 
.................... 	// C18 already has a 2 parameter ultoa() function 
.................... 	#include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #else 
.................... 	// HI-TECH PICC-18 PRO 9.63, C30 v3.25+, and C32 v1.12+ already have a ultoa() stdlib  
.................... 	// library function, but it requires 3 parameters.  The TCP/IP Stack  
.................... 	// assumes the C18 style 2 parameter ultoa() function, so we shall  
.................... 	// create a macro to automatically convert the code. 
.................... 	#include <stdlib.h> 
.................... 	#define ultoa(val,buf)	ultoa((char*)(buf),(val),10) 
.................... #endif 
....................  
.................... #if defined(DEBUG) 
.................... 	#define DebugPrint(a)	{putrsUART(a);} 
.................... #else 
.................... 	#define DebugPrint(a) 
.................... #endif 
....................  
.................... DWORD	LFSRSeedRand(DWORD dwSeed); 
.................... WORD	LFSRRand(void); 
.................... DWORD	GenerateRandomDWORD(void); 
.................... void 	uitoa(WORD Value, BYTE* Buffer); 
.................... void 	UnencodeURL(BYTE* URL); 
.................... WORD 	Base64Decode(BYTE* cSourceData, WORD wSourceLen, BYTE* cDestData, WORD wDestLen); 
.................... WORD	Base64Encode(BYTE* cSourceData, WORD wSourceLen, BYTE* cDestData, WORD wDestLen); 
.................... BOOL	StringToIPAddress(BYTE* str, IP_ADDR* IPAddress); 
.................... BYTE 	ReadStringUART(BYTE* Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
.................... signed char stricmppgm2ram(BYTE* a, ROM BYTE* b); 
.................... char * 	strnchr(const char *searchString, size_t count, char c); 
.................... size_t  strncpy_m(char* destStr, size_t destSize, int nStrings, ...); 
....................  
.................... #if defined(__18CXX) 
.................... 	BOOL	ROMStringToIPAddress(ROM BYTE* str, IP_ADDR* IPAddress); 
.................... #else 
.................... 	// Non-ROM variant for C30 and C32 
.................... 	#define ROMStringToIPAddress(a,b)	StringToIPAddress((BYTE*)a,b) 
.................... #endif 
....................  
....................  
.................... WORD    swaps(WORD v); 
....................  
.................... #if defined(__C32__) 
.................... DWORD   __attribute__((nomips16)) swapl(DWORD v); 
.................... #else 
.................... DWORD   swapl(DWORD v); 
.................... #endif 
....................  
.................... WORD    CalcIPChecksum(BYTE* buffer, WORD len); 
....................  
....................  
.................... #if defined(__18CXX) 
.................... 	DWORD leftRotateDWORD(DWORD val, BYTE bits); 
.................... #else 
.................... 	// Rotations are more efficient in C30 and C32 
.................... 	#define leftRotateDWORD(x, n) (((x) << (n)) | ((x) >> (32-(n)))) 
.................... #endif 
....................  
.................... void FormatNetBIOSName(BYTE Name[16]); 
....................  
....................  
.................... // Protocols understood by the ExtractURLFields() function.  IMPORTANT: If you  
.................... // need to reorder these (change their constant values), you must also reorder  
.................... // the constant arrays in ExtractURLFields(). 
.................... typedef enum 
.................... { 
.................... 	PROTOCOL_HTTP = 0u, 
.................... 	PROTOCOL_HTTPS, 
.................... 	PROTOCOL_MMS, 
.................... 	PROTOCOL_RTSP 
.................... } PROTOCOLS; 
....................  
.................... BYTE ExtractURLFields(BYTE *vURL, PROTOCOLS *protocol, BYTE *vUsername, WORD *wUsernameLen, BYTE *vPassword, WORD *wPasswordLen, BYTE *vHostname, WORD *wHostnameLen, WORD *wPort, BYTE *vFilePath, WORD *wFilePathLen); 
.................... SHORT Replace(BYTE *vExpression, ROM BYTE *vFind, ROM BYTE *vReplacement, WORD wMaxLen, BOOL bSearchCaseInsensitive); 
....................  
.................... #endif 
....................  
.................... #include "TCPIP Stack/Delay.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  General Delay rouines 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Delay.h 
....................  * Dependencies:    Compiler.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/9/02  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     6/10/02 Fixed C18 ms and us routines 
....................  * Howard Schlunder		4/04/06	Changed for C30 
....................  ********************************************************************/ 
.................... #ifndef __DELAY_H 
.................... #define __DELAY_H 
....................  
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
.................... #if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 	#include <delays.h> 
.................... #endif 
....................  
.................... #if !defined(GetInstructionClock) 
.................... 	#error GetInstructionClock() must be defined. 
.................... #endif 
....................  
.................... #if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 	#define Delay10us(us)		Delay10TCYx(((GetInstructionClock()/1000000)*(us))) 
.................... 	#define DelayMs(ms)												\ 
.................... 	do																\ 
.................... 	{																\ 
.................... 		unsigned int _iTemp = (ms); 								\ 
.................... 		while(_iTemp--)												\ 
.................... 			Delay1KTCYx((GetInstructionClock()+999999)/1000000);	\ 
.................... 	} while(0) 
....................  
.................... #elif defined(__C30__) || defined(__C32__) 
.................... 	void Delay10us(DWORD dwCount); 
.................... 	void DelayMs(WORD ms); 
....................  
.................... #else 
.................... 	#define Delay10us(x)			\ 
.................... 	do 								\ 
.................... 	{								\ 
.................... 		unsigned long _dcnt;		\ 
.................... 		_dcnt=x*((unsigned long)(0.00001/(1.0/GetInstructionClock())/6));	\ 
.................... 		while(_dcnt--);				\ 
.................... 	} while(0) 
.................... 	void DelayMs(WORD ms); 
.................... #endif 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "TCPIP Stack/Tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  ********************************************************************/ 
.................... #ifndef __TICK_H 
.................... #define __TICK_H 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... // All TICKS are stored as 32-bit unsigned integers. 
.................... // This is deprecated since it conflicts with other TICK definitions used in  
.................... // other Microchip software libraries and therefore poses a merge and maintence  
.................... // problem.  Instead of using the TICK data type, just use the base DWORD data  
.................... // type instead. 
.................... typedef __attribute__((__deprecated__)) DWORD TICK; 
....................  
.................... // This value is used by TCP and other modules to implement timeout actions. 
.................... // For this definition, the Timer must be initialized to use a 1:256 prescalar  
.................... // in Tick.c.  If using a 32kHz watch crystal as the time base, modify the  
.................... // Tick.c file to use no prescalar. 
.................... #define TICKS_PER_SECOND		((GetPeripheralClock()+128ull)/256ull)	// Internal core clock drives timer with 1:256 prescaler 
.................... //#define TICKS_PER_SECOND		(32768ul)								// 32kHz crystal drives timer with no scalar 
....................  
.................... // Represents one second in Ticks 
.................... #define TICK_SECOND				((QWORD)TICKS_PER_SECOND) 
.................... // Represents one minute in Ticks 
.................... #define TICK_MINUTE				((QWORD)TICKS_PER_SECOND*60ull) 
.................... // Represents one hour in Ticks 
.................... #define TICK_HOUR				((QWORD)TICKS_PER_SECOND*3600ull) 
....................  
....................  
.................... void TickInit(void); 
.................... DWORD TickGet(void); 
.................... DWORD TickGetDiv256(void); 
.................... DWORD TickGetDiv64K(void); 
.................... DWORD TickConvertToMilliseconds(DWORD dwTickValue); 
.................... void TickUpdate(void); 
....................  
.................... #endif 
....................  
.................... #include "TCPIP Stack/MAC.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  ********************************************************************/ 
.................... #ifndef __MAC_H 
.................... #define __MAC_H 
....................  
.................... #include "HardwareProfile.h" 
.................... // hardwareprofile.h 
....................  
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #if STACK_USE_CCS_EWLWIFIB || STACK_USE_CCS_EWLWIFIG 
....................  
....................    #bit WF_CS_TRIS1   =     0xF96.1 //E1 
....................    #define WF_CS_TRIS WF_CS_TRIS1 
....................    #bit WF_CS_IO     =  0xF8D.1    //LatE1 
....................    #bit WF_SDI_TRIS  =  0xF94.4    // (TRISCbits.TRISC4) 
....................    #bit WF_SCK_TRIS  =  0xF94.3    // (TRISCbits.TRISC3) 
....................    #bit WF_SDO_TRIS  =  0xF94.5    // (TRISCbits.TRISC5) 
....................    #bit WF_RESET_TRIS=  0xF93.1    //(TRISBbits.TRISB1) 
....................    #bit WF_RESET_IO  =  0xF8A.1     //(LATBbits.LATB1)   
....................    #bit WF_INT_TRIS  =  0xF93.0     // (TRISBbits.TRISB0)  // INT1 
....................    #bit WF_INT_IO    =  0xF81.0   //(PORTBbits.RB0)  
....................    #bit WF_HIBERNATE_TRIS= 0xF93.2  //(TRISBbits.TRISB2)  
....................    #bit   WF_HIBERNATE_IO=  0xF81.2    //(PORTBbits.RB2) 
....................     
....................    #bit WF_INT_EDGE  =  0xFF1.6      //(INTCON2bits.INTEDG0) 
....................    #bit WF_INT_IE    =  0xFF2.4   //(INTCONbits.INT0IE) 
....................    #bit WF_INT_IF    =  0xFF2.1   //(INTCONbits.INT0IF) 
....................    #define WF_SSPBUF  (SSP1BUF) 
....................    #define WF_SPISTAT  (SSP1STATbits) 
....................    #define WF_SPISTATbits SSP1STATbits     //(SSP1STATbits) 
....................    #define WF_SPICON1  (SSP1CON1bits) 
....................    #define WF_SPICON1bits WF_SPICON1    // (SSP1CON1bits) 
....................    #define WF_SPICON2  (SSP1CON2bits) 
....................    #bit WF_SPI_IE    =   0xF9D.3  //(PIE1bits.SSPIE) 
....................    #bit WF_SPI_IP    =   0xF9F.3  //(IPR1bits.SSPIP) 
....................    #bit WF_SPI_IF    =   0xF9E.3  //(PIR1bits.SSPIF) 
....................     
.................... #else 
....................  
.................... //#error define necessary hardware for TCPIP stack 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #if defined(WF_CS_TRIS) 
....................    // Do not use the DMA and other goodies that Microchip Ethernet modules have 
....................    #define NON_MCHP_MAC 
.................... #endif 
....................  
.................... #if defined(ENC_CS_TRIS) && defined(WF_CS_TRIS) 
....................    #error "Error in HardwareProfile.h.  Must select either the ENC28J60 or the MRF24WB10 but not both ENC_CS_TRIS and WF_CS_TRIS." 
.................... #endif 
.................... #if defined(ENC100_INTERFACE_MODE) && defined(WF_CS_TRIS) 
....................    #error "Error in HardwareProfile.h.  Must select either the ENCX24J600 or the MRF24WB10 but not both ENC100_INTERFACE_MODE and WF_CS_TRIS." 
.................... #endif 
.................... #if defined(ENC100_INTERFACE_MODE) && defined(ENC_CS_TRIS) 
....................    #error "Error in HardwareProfile.h.  Must select either the ENC28J60 or the ENCX24J600 but not both ENC_CS_TRIS and ENC100_INTERFACE_MODE." 
.................... #endif 
....................  
....................  
....................  
.................... #if !defined(ENC_CS_TRIS) && !defined(WF_CS_TRIS) && !defined(ENC100_INTERFACE_MODE) && \ 
....................     (defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) || \ 
....................      defined(_18F97J60) ||  defined(_18F96J65) ||  defined(_18F96J60) ||  defined(_18F87J60) ||  defined(_18F86J65) ||  defined(_18F86J60) ||  defined(_18F67J60) ||  defined(_18F66J65) ||  defined(_18F66J60)) 
....................    #include "TCPIP Stack/ETH97J60.h" 
.................... #elif defined(ENC_CS_TRIS) || defined(WF_CS_TRIS) 
....................    #include "TCPIP Stack/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  ********************************************************************/ 
....................  
.................... #ifndef __ENC28J60_H 
.................... #define __ENC28J60_H 
.................... #include "GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... #ifdef BYTE 
.................... #undef BYTE 
.................... #endif 
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		WORD	 		ByteCount; 
.................... 		unsigned char	CollisionCount:4; 
.................... 		unsigned char	CRCError:1; 
.................... 		unsigned char	LengthCheckError:1; 
.................... 		unsigned char	LengthOutOfRange:1; 
.................... 		unsigned char	Done:1; 
.................... 		unsigned char	Multicast:1; 
.................... 		unsigned char	Broadcast:1; 
.................... 		unsigned char	PacketDefer:1; 
.................... 		unsigned char	ExcessiveDefer:1; 
.................... 		unsigned char	MaximumCollisions:1; 
.................... 		unsigned char	LateCollision:1; 
.................... 		unsigned char	Giant:1; 
.................... 		unsigned char	Underrun:1; 
.................... 		WORD 	 		BytesTransmittedOnWire; 
.................... 		unsigned char	ControlFrame:1; 
.................... 		unsigned char	PAUSEControlFrame:1; 
.................... 		unsigned char	BackpressureApplied:1; 
.................... 		unsigned char	VLANTaggedFrame:1; 
.................... 		unsigned char	Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	BYTE v[4]; 
.................... 	struct { 
.................... 		WORD	 		ByteCount; 
.................... 		unsigned char	PreviouslyIgnored:1; 
.................... 		unsigned char	RXDCPreviouslySeen:1; 
.................... 		unsigned char	CarrierPreviouslySeen:1; 
.................... 		unsigned char	CodeViolation:1; 
.................... 		unsigned char	CRCError:1; 
.................... 		unsigned char	LengthCheckError:1; 
.................... 		unsigned char	LengthOutOfRange:1; 
.................... 		unsigned char	ReceiveOk:1; 
.................... 		unsigned char	Multicast:1; 
.................... 		unsigned char	Broadcast:1; 
.................... 		unsigned char	DribbleNibble:1; 
.................... 		unsigned char	ControlFrame:1; 
.................... 		unsigned char	PauseControlFrame:1; 
.................... 		unsigned char	UnsupportedOpcode:1; 
.................... 		unsigned char	VLANType:1; 
.................... 		unsigned char	Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG  
.................... { 
.................... 	BYTE Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char :1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char BUFER:1; 
.................... 		unsigned char INT:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char :3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
.................... 		 
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
.................... 		 
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
.................... 		 
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
.................... 		 
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDREN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDREN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
.................... 		 
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char :1; 
.................... 	} MACON4bits; 
.................... 		 
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char :6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
.................... 		 
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char :5; 
.................... 	} MISTATbits; 
.................... 		 
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char :5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char :5; 
.................... 	} ECOCONbits2; 
.................... 		 
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char :5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char :5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	WORD Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		unsigned :8; 
.................... 		unsigned PDPXMD:1; 
.................... 		unsigned :2; 
.................... 		unsigned PPWRSV:1; 
.................... 		unsigned :2; 
.................... 		unsigned PLOOPBK:1; 
.................... 		unsigned PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		unsigned :1; 
.................... 		unsigned JBSTAT:1; 
.................... 		unsigned LLSTAT:1; 
.................... 		unsigned :5; 
.................... 		unsigned :3; 
.................... 		unsigned PHDPX:1; 
.................... 		unsigned PFDPX:1; 
.................... 		unsigned :3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		unsigned PREV0:1; 
.................... 		unsigned PREV1:1; 
.................... 		unsigned PREV2:1; 
.................... 		unsigned PREV3:1; 
.................... 		unsigned PPN0:1; 
.................... 		unsigned PPN1:1; 
.................... 		unsigned PPN2:1; 
.................... 		unsigned PPN3:1; 
.................... 		unsigned PPN4:1; 
.................... 		unsigned PPN5:1; 
.................... 		unsigned PID19:1; 
.................... 		unsigned PID20:1; 
.................... 		unsigned PID21:1; 
.................... 		unsigned PID22:1; 
.................... 		unsigned PID23:1; 
.................... 		unsigned PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		unsigned PREV:4; 
.................... 		unsigned PPNL:4; 
.................... 		unsigned PPNH:2; 
.................... 		unsigned PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		unsigned :8; 
.................... 		unsigned HDLDIS:1; 
.................... 		unsigned :1; 
.................... 		unsigned JABBER:1; 
.................... 		unsigned :2; 
.................... 		unsigned TXDIS:1; 
.................... 		unsigned FRCLNK:1; 
.................... 		unsigned :1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		unsigned :5; 
.................... 		unsigned PLRITY:1; 
.................... 		unsigned :2; 
.................... 		unsigned :1; 
.................... 		unsigned DPXSTAT:1; 
.................... 		unsigned LSTAT:1; 
.................... 		unsigned COLSTAT:1; 
.................... 		unsigned RXSTAT:1; 
.................... 		unsigned TXSTAT:1; 
.................... 		unsigned :2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		unsigned :1; 
.................... 		unsigned PGEIE:1; 
.................... 		unsigned :2; 
.................... 		unsigned PLNKIE:1; 
.................... 		unsigned :3; 
.................... 		unsigned :8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		unsigned :2; 
.................... 		unsigned PGIF:1; 
.................... 		unsigned :1; 
.................... 		unsigned PLNKIF:1; 
.................... 		unsigned :3; 
.................... 		unsigned :8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		unsigned :1; 
.................... 		unsigned STRCH:1; 
.................... 		unsigned LFRQ0:1; 
.................... 		unsigned LFRQ1:1; 
.................... 		unsigned LBCFG0:1; 
.................... 		unsigned LBCFG1:1; 
.................... 		unsigned LBCFG2:1; 
.................... 		unsigned LBCFG3:1; 
.................... 		unsigned LACFG0:1; 
.................... 		unsigned LACFG1:1; 
.................... 		unsigned LACFG2:1; 
.................... 		unsigned LACFG3:1; 
.................... 		unsigned :4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		unsigned :1; 
.................... 		unsigned STRCH:1; 
.................... 		unsigned LFRQ:2; 
.................... 		unsigned LBCFG:4; 
.................... 		unsigned LACFG:4; 
.................... 		unsigned :4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
.................... 	 
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFER		(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
.................... 	 
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
.................... 	 
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
.................... 	 
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
.................... 	 
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
.................... 	 
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDREN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
.................... 	 
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
.................... 	 
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
.................... 	 
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
.................... 	 
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
.................... #elif defined(ENC100_INTERFACE_MODE) 
....................    #include "TCPIP Stack/ENCX24J600.h" 
....................    #define PHYREG WORD 
.................... #elif defined(__PIC32MX__) && defined(_ETH) 
....................    // extra includes for PIC32MX with embedded ETH Controller 
.................... #else 
....................    #error No Ethernet/WiFi controller defined in HardwareProfile.h.  Defines for an ENC28J60, ENC424J600/624J600, or WiFi MRF24WB10 must be present. 
.................... #endif 
....................  
....................  
.................... #define MAC_TX_BUFFER_SIZE         (1500ul) 
....................  
.................... // A generic structure representing the Ethernet header starting all Ethernet 
.................... // frames 
.................... typedef struct   
.................... #if defined(__CCS__) 
.................... __attribute__((packed)) 
.................... #else 
.................... __attribute__((aligned(2), packed)) 
.................... #endif 
.................... { 
....................    MAC_ADDR        DestMACAddr; 
....................    MAC_ADDR        SourceMACAddr; 
....................    WORD_VAL        Type; 
.................... } ETHER_HEADER; 
....................  
....................  
.................... #define MAC_IP         (0x00u) 
.................... #define MAC_ARP        (0x06u) 
.................... #define MAC_UNKNOWN    (0xFFu) 
....................  
....................  
.................... #if !defined(STACK_USE_HTTP2_SERVER) 
....................    #define RESERVED_HTTP_MEMORY 0ul 
.................... #endif 
....................  
.................... #if !defined(STACK_USE_SSL) 
....................    #define RESERVED_SSL_MEMORY 0ul 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #define MAX_PACKET_SIZE     (1514ul) 
.................... #endif 
....................  
.................... // MAC RAM definitions 
.................... #if defined(ENC100_INTERFACE_MODE) 
....................    #define RESERVED_CRYPTO_MEMORY   (128ul) 
....................    #define RAMSIZE         (24*1024ul) 
....................    #define TXSTART       (0x0000ul) 
....................    #define RXSTART       ((TXSTART + 1518ul + TCP_ETH_RAM_SIZE + RESERVED_HTTP_MEMORY + RESERVED_SSL_MEMORY + RESERVED_CRYPTO_MEMORY + 1ul) & 0xFFFE) 
....................    #define   RXSTOP         (RAMSIZE-1ul) 
....................    #define RXSIZE         (RXSTOP-RXSTART+1ul) 
....................    #define BASE_TX_ADDR   (TXSTART) 
....................    #define BASE_TCB_ADDR   (BASE_TX_ADDR + 1518ul) 
....................    #define BASE_HTTPB_ADDR (BASE_TCB_ADDR + TCP_ETH_RAM_SIZE) 
....................    #define BASE_SSLB_ADDR   (BASE_HTTPB_ADDR + RESERVED_HTTP_MEMORY) 
....................    #define BASE_CRYPTOB_ADDR   (BASE_SSLB_ADDR + RESERVED_SSL_MEMORY) 
.................... #elif defined(WF_CS_TRIS) 
....................    #define RAMSIZE       (14170ul - 8192ul - RESERVED_HTTP_MEMORY - RESERVED_SSL_MEMORY) 
....................    #define TXSTART       (RAMSIZE - (4ul + MAX_PACKET_SIZE + 4ul)) 
....................    #define RXSTART       (0ul) 
....................    #define RXSTOP         ((TXSTART-2ul) | 0x0001ul) 
....................    #define RXSIZE         (RXSTOP-RXSTART+1ul) 
....................    #define BASE_TX_ADDR   (TXSTART + 4ul) 
....................    #define BASE_SCRATCH_ADDR (BASE_TX_ADDR + (MAX_PACKET_SIZE + 4ul)) 
....................    #define BASE_HTTPB_ADDR  (BASE_SCRATCH_ADDR) 
....................    #define BASE_SSLB_ADDR   (BASE_HTTPB_ADDR + RESERVED_HTTP_MEMORY) 
....................    #define BASE_TCB_ADDR   (BASE_SSLB_ADDR + RESERVED_SSL_MEMORY) 
.................... #elif defined(__PIC32MX__) && defined(_ETH) && !defined(ENC_CS_TRIS) 
....................    #define BASE_TX_ADDR   (MACGetTxBaseAddr()) 
....................    #define BASE_HTTPB_ADDR   (MACGetHttpBaseAddr()) 
....................    #define BASE_SSLB_ADDR   (MACGetSslBaseAddr()) 
....................    #define RXSIZE         (EMAC_RX_BUFF_SIZE) 
....................    #define RAMSIZE         (2*RXSIZE)   // not used but silences the compiler 
.................... #else   // ENC28J60 or PIC18F97J60 family internal Ethernet controller 
....................    #define RAMSIZE         (8*1024ul) 
....................    #define TXSTART       (RAMSIZE - (1ul+1518ul+7ul) - TCP_ETH_RAM_SIZE - RESERVED_HTTP_MEMORY - RESERVED_SSL_MEMORY) 
....................    #define RXSTART         (0ul)                  // Should be an even memory address; must be 0 for errata 
....................    #define   RXSTOP         ((TXSTART-2ul) | 0x0001ul)   // Odd for errata workaround 
....................    #define RXSIZE         (RXSTOP-RXSTART+1ul) 
....................    #define BASE_TX_ADDR   (TXSTART + 1ul) 
....................    #define BASE_TCB_ADDR   (BASE_TX_ADDR + (1514ul+7ul)) 
....................    #define BASE_HTTPB_ADDR (BASE_TCB_ADDR + TCP_ETH_RAM_SIZE) 
....................    #define BASE_SSLB_ADDR   (BASE_HTTPB_ADDR + RESERVED_HTTP_MEMORY) 
.................... #endif 
....................  
.................... #if (RXSIZE < 1400) || (RXSIZE > RAMSIZE) 
....................    #error Warning, Ethernet RX buffer is tiny.  Reduce TCP socket count, the size of each TCP socket, or move sockets to a different RAM 
.................... #endif 
....................  
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void   MACEDPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... #if defined(ENC_CS_TRIS) || defined(ENC100_INTERFACE_MODE) || \ 
....................    (defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) || \ 
....................      defined(_18F97J60) ||  defined(_18F96J65) ||  defined(_18F96J60) ||  defined(_18F87J60) ||  defined(_18F86J65) ||  defined(_18F86J60) ||  defined(_18F67J60) ||  defined(_18F66J65) ||  defined(_18F66J60)) 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... #endif 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
.................... // ENC28J60 specific 
.................... void   SetCLKOUT(BYTE NewConfig); 
.................... BYTE   GetCLKOUT(void); 
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
....................  
.................... void MACInit(void); 
.................... void MACProcess(void); 
.................... BOOL MACIsLinked(void); 
....................  
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void MACSetReadPtrInRx(WORD offset); 
.................... PTR_BASE MACSetWritePtr(PTR_BASE address); 
.................... PTR_BASE MACSetReadPtr(PTR_BASE address); 
.................... BYTE MACGet(void); 
.................... WORD MACGetArray(BYTE *val, WORD len); 
.................... void MACDiscardRx(void); 
.................... WORD MACGetFreeRxSize(void); 
.................... void MACMemCopyAsync(PTR_BASE destAddr, PTR_BASE sourceAddr, WORD len); 
.................... BOOL MACIsMemCopyDone(void); 
....................  
.................... void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen); 
.................... BOOL MACIsTxReady(void); 
.................... void MACPut(BYTE val); 
.................... void MACPutArray(BYTE *val, WORD len); 
.................... void MACFlush(void); 
....................  
....................  
.................... // ROM function variants for PIC18 
.................... #if defined(__18CXX) 
....................    void MACPutROMArray(ROM BYTE *val, WORD len); 
.................... #else 
....................    #define MACPutROMArray(a,b)   MACPutArray((BYTE*)a,b) 
.................... #endif 
....................  
.................... // PIC32MX with embedded ETHC functions 
.................... #if defined(__PIC32MX__) && defined(_ETH) 
....................    PTR_BASE MACGetTxBaseAddr(void); 
....................    PTR_BASE MACGetHttpBaseAddr(void); 
....................    PTR_BASE MACGetSslBaseAddr(void); 
.................... #endif 
....................  
....................     
.................... #endif 
....................  
.................... #include "TCPIP Stack/IP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  ********************************************************************/ 
.................... #ifndef __IP_H 
.................... #define __IP_H 
....................  
....................  
.................... #define IP_PROT_ICMP    (1u) 
.................... #define IP_PROT_TCP     (6u) 
.................... #define IP_PROT_UDP     (17u) 
....................  
....................  
.................... // IP packet header definition 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
.................... } IP_HEADER; 
....................  
.................... // IP Pseudo header as defined by RFC 793 (needed for TCP and UDP  
.................... // checksum calculations/verification) 
.................... typedef struct _PSEUDO_HEADER 
.................... { 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................     BYTE Zero; 
....................     BYTE Protocol; 
....................     WORD Length; 
.................... } PSEUDO_HEADER; 
....................  
.................... #define SwapPseudoHeader(h)  (h.Length = swaps(h.Length)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady()       MACIsTxReady() 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(b) MACSetWritePtr(b + BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by  
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset  
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "TCPIP Stack/ARP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder      8/17/06   Combined ARP.h and ARPTsk.h into ARP.h 
....................  ********************************************************************/ 
.................... #ifndef __ARP_H 
.................... #define __ARP_H 
....................  
.................... #ifdef STACK_CLIENT_MODE 
....................    void ARPInit(void); 
.................... #else 
....................    #define ARPInit() 
.................... #endif 
....................  
.................... #define ARP_OPERATION_REQ       0x0001u      // Operation code indicating an ARP Request 
.................... #define ARP_OPERATION_RESP      0x0002u      // Operation code indicating an ARP Response 
....................  
.................... #define HW_ETHERNET             (0x0001u)   // ARP Hardware type as defined by IEEE 802.3 
.................... #define ARP_IP                  (0x0800u)   // ARP IP packet type as defined by IEEE 802.3 
....................  
....................  
.................... // ARP packet structure 
.................... typedef struct  
.................... #if defined(__CCS__) 
.................... __attribute__((packed)) 
.................... #else 
.................... __attribute__((aligned(2), packed)) 
.................... #endif 
.................... { 
....................     WORD        HardwareType;   // Link-layer protocol type (Ethernet is 1). 
....................     WORD        Protocol;       // The upper-layer protocol issuing an ARP request (0x0800 for IPv4).. 
....................     BYTE        MACAddrLen;     // MAC address length (6). 
....................     BYTE        ProtocolLen;    // Length of addresses used in the upper-layer protocol (4). 
....................     WORD        Operation;      // The operation the sender is performing (ARP_REQ or ARP_RESP). 
....................     MAC_ADDR    SenderMACAddr;  // The sender's hardware (MAC) address. 
....................     IP_ADDR     SenderIPAddr;   // The sender's IP address. 
....................     MAC_ADDR    TargetMACAddr;  // The target node's hardware (MAC) address. 
....................     IP_ADDR     TargetIPAddr;   // The target node's IP address. 
.................... } ARP_PACKET; 
....................  
.................... BOOL ARPProcess(void); 
.................... void ARPResolve(IP_ADDR* IPAddr); 
.................... BOOL ARPIsResolved(IP_ADDR* IPAddr, MAC_ADDR* MACAddr); 
.................... void SwapARPPacket(ARP_PACKET* p); 
....................  
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................    /* API specific Definitions */ 
....................    #define ARP_REQ       0x0001u      // Operation code indicating an ARP Request 
....................    #define ARP_RESP      0x0002u      // Operation code indicating an ARP Response 
....................  
....................    struct arp_app_callbacks { 
....................        BOOL used; 
....................        void (*ARPPkt_notify)(DWORD SenderIPAddr, DWORD TargetIPAddr,  
....................                              MAC_ADDR* SenderMACAddr, MAC_ADDR* TargetMACAddr, BYTE op_req); 
....................    }; 
....................    CHAR ARPRegisterCallbacks(struct arp_app_callbacks *app); 
....................    BOOL ARPDeRegisterCallbacks(CHAR id); 
.................... #endif 
....................    BOOL ARPSendPkt(DWORD SrcIPAddr, DWORD DestIPAddr, BYTE op_req ); 
.................... #endif 
....................  
....................  
....................  
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... /********************************************************************* 
....................  * 
....................  *               External serial data EEPROM Access Defs. 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        XEEPROM.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/20/02     Original (Rev. 1.0) 
.................... ********************************************************************/ 
.................... #ifndef __XEEPROM_H 
.................... #define __XEEPROM_H 
....................  
.................... #include "HardwareProfile.h" 
.................... // hardwareprofile.h 
....................  
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #if STACK_USE_CCS_EWLWIFIB || STACK_USE_CCS_EWLWIFIG 
....................  
....................    #bit WF_CS_TRIS1   =     0xF96.1 //E1 
....................    #define WF_CS_TRIS WF_CS_TRIS1 
....................    #bit WF_CS_IO     =  0xF8D.1    //LatE1 
....................    #bit WF_SDI_TRIS  =  0xF94.4    // (TRISCbits.TRISC4) 
....................    #bit WF_SCK_TRIS  =  0xF94.3    // (TRISCbits.TRISC3) 
....................    #bit WF_SDO_TRIS  =  0xF94.5    // (TRISCbits.TRISC5) 
....................    #bit WF_RESET_TRIS=  0xF93.1    //(TRISBbits.TRISB1) 
....................    #bit WF_RESET_IO  =  0xF8A.1     //(LATBbits.LATB1)   
....................    #bit WF_INT_TRIS  =  0xF93.0     // (TRISBbits.TRISB0)  // INT1 
....................    #bit WF_INT_IO    =  0xF81.0   //(PORTBbits.RB0)  
....................    #bit WF_HIBERNATE_TRIS= 0xF93.2  //(TRISBbits.TRISB2)  
....................    #bit   WF_HIBERNATE_IO=  0xF81.2    //(PORTBbits.RB2) 
....................     
....................    #bit WF_INT_EDGE  =  0xFF1.6      //(INTCON2bits.INTEDG0) 
....................    #bit WF_INT_IE    =  0xFF2.4   //(INTCONbits.INT0IE) 
....................    #bit WF_INT_IF    =  0xFF2.1   //(INTCONbits.INT0IF) 
....................    #define WF_SSPBUF  (SSP1BUF) 
....................    #define WF_SPISTAT  (SSP1STATbits) 
....................    #define WF_SPISTATbits SSP1STATbits     //(SSP1STATbits) 
....................    #define WF_SPICON1  (SSP1CON1bits) 
....................    #define WF_SPICON1bits WF_SPICON1    // (SSP1CON1bits) 
....................    #define WF_SPICON2  (SSP1CON2bits) 
....................    #bit WF_SPI_IE    =   0xF9D.3  //(PIE1bits.SSPIE) 
....................    #bit WF_SPI_IP    =   0xF9F.3  //(IPR1bits.SSPIP) 
....................    #bit WF_SPI_IF    =   0xF9E.3  //(PIR1bits.SSPIF) 
....................     
.................... #else 
....................  
.................... //#error define necessary hardware for TCPIP stack 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... typedef BOOL XEE_RESULT; 
.................... #define XEE_SUCCESS FALSE 
....................  
.................... #if defined(EEPROM_CS_TRIS)	 
.................... 	void XEEInit(void); 
.................... 	XEE_RESULT XEEBeginWrite(DWORD address); 
.................... 	XEE_RESULT XEEWrite(BYTE val); 
.................... 	void XEEWriteArray(BYTE *val, WORD wLen); 
.................... 	XEE_RESULT XEEEndWrite(void); 
.................... 	XEE_RESULT XEEBeginRead(DWORD address); 
.................... 	BYTE XEERead(void); 
.................... 	XEE_RESULT XEEReadArray(DWORD address, BYTE *buffer, WORD length); 
.................... 	XEE_RESULT XEEEndRead(void); 
.................... 	BOOL XEEIsBusy(void); 
.................... #else 
.................... 	// If you get any of these linker errors, it means that you either have an  
.................... 	// error in your HardwareProfile.h or TCPIPConfig.h definitions.  The code  
.................... 	// is attempting to call a function that can't possibly work because you  
.................... 	// have not specified what pins and SPI module the physical SPI EEPROM chip  
.................... 	// is connected to.  Alternatively, if you don't have an SPI EERPOM chip, it  
.................... 	// means you have enabled a stack feature that requires SPI EEPROM hardware. 
.................... 	// In this case, you need to edit TCPIPConfig.h and disable this stack  
.................... 	// feature.  The linker error tells you which object file this error was  
.................... 	// generated from.  It should be a clue as to what feature you need to  
.................... 	// disable. 
.................... 	void 		You_cannot_call_the_XEEInit_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEBeginWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void 		You_cannot_call_the_XEEWriteArray_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEEndWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEBeginRead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	BYTE 		You_cannot_call_the_XEERead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEReadArray_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEEndRead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	BOOL 		You_cannot_call_the_XEEIsBusy_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	#define XEEInit()				You_cannot_call_the_XEEInit_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEBeginWrite(a) 		You_cannot_call_the_XEEBeginWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEWrite(a)				You_cannot_call_the_XEEWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEWriteArray(a,b)		You_cannot_call_the_XEEWriteArray_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEEndWrite()			You_cannot_call_the_XEEEndWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEBeginRead(a)			You_cannot_call_the_XEEBeginRead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEERead(a)				You_cannot_call_the_XEERead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEReadArray(a, b, c)	You_cannot_call_the_XEEReadArray_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEEndRead()			You_cannot_call_the_XEEEndRead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEIsBusy()				You_cannot_call_the_XEEIsBusy_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... #endif 
....................  
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... /********************************************************************* 
....................  * 
....................  *  SPI Flash Memory Driver Header 
....................  *	- Tested to be compatible with SST25VF016B 
....................  *  - Expected compatibility with other SST (Microchip) SST25 series  
....................  *    devices 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        SPIFlash.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * E. Wood				3/20/08	Original 
.................... ********************************************************************/ 
.................... #ifndef __SPIFLASH_H 
.................... #define __SPIFLASH_H 
....................  
.................... #include "HardwareProfile.h" 
....................  
.................... #define SPI_FLASH_SECTOR_SIZE		(4096ul) 
.................... #define SPI_FLASH_PAGE_SIZE			(0ul)		// SST has no page boundary requirements 
....................  
.................... #define SPI_FLASH_SECTOR_MASK		(SPI_FLASH_SECTOR_SIZE - 1) 
....................  
....................  
.................... #if defined(SPIFLASH_CS_TRIS) 
.................... 	void SPIFlashInit(void);		 
.................... 	void SPIFlashReadArray(DWORD dwAddress, BYTE *vData, WORD wLen); 
.................... 	void SPIFlashBeginWrite(DWORD dwAddr); 
.................... 	void SPIFlashWrite(BYTE vData); 
.................... 	void SPIFlashWriteArray(BYTE *vData, WORD wLen); 
.................... 	void SPIFlashEraseSector(DWORD dwAddr); 
.................... #else 
.................... 	// If you get any of these linker errors, it means that you either have an  
.................... 	// error in your HardwareProfile.h or TCPIPConfig.h definitions.  The code  
.................... 	// is attempting to call a function that can't possibly work because you  
.................... 	// have not specified what pins and SPI module the physical SPI Flash chip  
.................... 	// is connected to.  Alternatively, if you don't have an SPI Flash chip, it  
.................... 	// means you have enabled a stack feature that requires SPI Flash hardware. 
.................... 	// In this case, you need to edit TCPIPConfig.h and disable this stack  
.................... 	// feature.  The linker error tells you which object file this error was  
.................... 	// generated from.  It should be a clue as to what feature you need to  
.................... 	// disable. 
.................... 	void You_cannot_call_the_SPIFlashInit_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashReadArray_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashBeginWrite_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashWrite_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashWriteArray_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashEraseSector_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	#define SPIFlashInit()				You_cannot_call_the_SPIFlashInit_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashReadArray(a,b,c)	You_cannot_call_the_SPIFlashReadArray_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashBeginWrite(a)		You_cannot_call_the_SPIFlashBeginWrite_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashWrite(a)			You_cannot_call_the_SPIFlashWrite_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashWriteArray(a,b)		You_cannot_call_the_SPIFlashWriteArray_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashEraseSector(a)		You_cannot_call_the_SPIFlashEraseSector_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... #endif 
....................  
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/SPIRAM.h" 
.................... /********************************************************************* 
....................  * 
....................  * Data SPI RAM Access Routines 
....................  *  -Tested with AMI Semiconductor N256S0830HDA 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        SPIRAM.h 
....................  * Dependencies:    Compiler.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * \file SPIRAM.h 
....................  * \author Howard Henry Schlunder 
....................  * \date 25 July 2007 
.................... ********************************************************************/ 
.................... #ifndef __SPIRAM_H 
.................... #define __SPIRAM_H 
....................  
.................... #include "HardwareProfile.h" 
.................... // hardwareprofile.h 
....................  
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #if STACK_USE_CCS_EWLWIFIB || STACK_USE_CCS_EWLWIFIG 
....................  
....................    #bit WF_CS_TRIS1   =     0xF96.1 //E1 
....................    #define WF_CS_TRIS WF_CS_TRIS1 
....................    #bit WF_CS_IO     =  0xF8D.1    //LatE1 
....................    #bit WF_SDI_TRIS  =  0xF94.4    // (TRISCbits.TRISC4) 
....................    #bit WF_SCK_TRIS  =  0xF94.3    // (TRISCbits.TRISC3) 
....................    #bit WF_SDO_TRIS  =  0xF94.5    // (TRISCbits.TRISC5) 
....................    #bit WF_RESET_TRIS=  0xF93.1    //(TRISBbits.TRISB1) 
....................    #bit WF_RESET_IO  =  0xF8A.1     //(LATBbits.LATB1)   
....................    #bit WF_INT_TRIS  =  0xF93.0     // (TRISBbits.TRISB0)  // INT1 
....................    #bit WF_INT_IO    =  0xF81.0   //(PORTBbits.RB0)  
....................    #bit WF_HIBERNATE_TRIS= 0xF93.2  //(TRISBbits.TRISB2)  
....................    #bit   WF_HIBERNATE_IO=  0xF81.2    //(PORTBbits.RB2) 
....................     
....................    #bit WF_INT_EDGE  =  0xFF1.6      //(INTCON2bits.INTEDG0) 
....................    #bit WF_INT_IE    =  0xFF2.4   //(INTCONbits.INT0IE) 
....................    #bit WF_INT_IF    =  0xFF2.1   //(INTCONbits.INT0IF) 
....................    #define WF_SSPBUF  (SSP1BUF) 
....................    #define WF_SPISTAT  (SSP1STATbits) 
....................    #define WF_SPISTATbits SSP1STATbits     //(SSP1STATbits) 
....................    #define WF_SPICON1  (SSP1CON1bits) 
....................    #define WF_SPICON1bits WF_SPICON1    // (SSP1CON1bits) 
....................    #define WF_SPICON2  (SSP1CON2bits) 
....................    #bit WF_SPI_IE    =   0xF9D.3  //(PIE1bits.SSPIE) 
....................    #bit WF_SPI_IP    =   0xF9F.3  //(IPR1bits.SSPIP) 
....................    #bit WF_SPI_IF    =   0xF9E.3  //(PIR1bits.SSPIF) 
....................     
.................... #else 
....................  
.................... //#error define necessary hardware for TCPIP stack 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #if defined(SPIRAM_CS_TRIS) 
.................... 	void SPIRAMInit(void); 
.................... 	void SPIRAMGetArray(WORD wAddress, BYTE *vData, WORD wLength); 
.................... 	void SPIRAMPutArray(WORD wAddress, BYTE *vData, WORD wLength); 
.................... 	 
.................... 	#define SPIRAMPutString(a,b)			SPIRAMPutArray(a, strlen((char*)b)) 
.................... 	 
.................... 	#if defined(__18CXX) 
.................... 		void SPIRAMPutROMArray(WORD wAddress, ROM BYTE *vData, WORD wLength); 
.................... 		#define SPIRAMPutROMString(a,b)		SPIRAMPutROMArray(a, strlenpgm((ROM char*)b)) 
.................... 	#else 
.................... 		#define SPIRAMPutROMString(a,b)		SPIRAMPutArray(a, strlen((char*)b)) 
.................... 		#define SPIRAMPutROMArray(a,b,c)	SPIRAMPutROMArray(a, b, c) 
.................... 	#endif 
.................... #else 
.................... 	// If you get any of these linker errors, it means that you either have an  
.................... 	// error in your HardwareProfile.h or TCPIPConfig.h definitions.  The code  
.................... 	// is attempting to call a function that can't possibly work because you  
.................... 	// have not specified what pins and SPI module the physical SPI SRAM chip  
.................... 	// is connected to.  Alternatively, if you don't have an SPI SRAM chip, it  
.................... 	// means you have enabled a stack feature that requires SPI SRAM hardware. 
.................... 	// In this case, you need to edit TCPIPConfig.h and disable this stack  
.................... 	// feature.  The linker error tells you which object file this error was  
.................... 	// generated from.  It should be a clue as to what feature you need to  
.................... 	// disable. 
.................... 	void You_cannot_call_the_SPIRAMInit_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMGetArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMPutArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMPutString_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMPutROMArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMPutROMString_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	#define SPIRAMInit()				You_cannot_call_the_SPIRAMInit_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMGetArray(a,b,c)		You_cannot_call_the_SPIRAMGetArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMPutArray(a,b,c)		You_cannot_call_the_SPIRAMPutArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMPutString(a,b)		You_cannot_call_the_SPIRAMPutString_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMPutROMArray(a,b,c)	You_cannot_call_the_SPIRAMPutROMArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMPutROMString(a,b)		You_cannot_call_the_SPIRAMPutROMString_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... #endif 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCP.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    	Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01  	Original        (Rev 1.0) 
....................  * Howard Schlunder		11/30/06	See "TCPIP Stack Version.txt" file 
....................  ********************************************************************/ 
.................... #ifndef __TCP_HITECH_WORKAROUND_H 
.................... #define __TCP_HITECH_WORKAROUND_H 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	Type Definitions 
....................   ***************************************************************************/ 
....................  
.................... // A TCP_SOCKET is stored as a single BYTE 
.................... typedef BYTE TCP_SOCKET; 
....................  
.................... #define INVALID_SOCKET      (0xFE)	// The socket is invalid or could not be opened 
.................... #define UNKNOWN_SOCKET      (0xFF)	// The socket is not known 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	State Machine Variables 
....................   ***************************************************************************/ 
....................  
.................... // TCP States as defined by RFC 793 
.................... typedef enum 
.................... { 
.................... 	TCP_GET_DNS_MODULE,		// Special state for TCP client mode sockets 
.................... 	TCP_DNS_RESOLVE,		// Special state for TCP client mode sockets 
.................... 	TCP_GATEWAY_SEND_ARP,	// Special state for TCP client mode sockets 
.................... 	TCP_GATEWAY_GET_ARP,	// Special state for TCP client mode sockets 
....................  
....................     TCP_LISTEN,				// Socket is listening for connections 
....................     TCP_SYN_SENT,			// A SYN has been sent, awaiting an SYN+ACK 
....................     TCP_SYN_RECEIVED,		// A SYN has been received, awaiting an ACK 
....................     TCP_ESTABLISHED,		// Socket is connected and connection is established 
....................     TCP_FIN_WAIT_1,			// FIN WAIT state 1 
....................     TCP_FIN_WAIT_2,			// FIN WAIT state 2 
....................     TCP_CLOSING,			// Socket is closing 
.................... //	TCP_TIME_WAIT, state is not implemented 
.................... 	TCP_CLOSE_WAIT,			// Waiting to close the socket 
....................     TCP_LAST_ACK,			// The final ACK has been sent 
....................     TCP_CLOSED,				// Socket is idle and unallocated 
....................  
....................     TCP_CLOSED_BUT_RESERVED	// Special state for TCP client mode sockets.  Socket is idle, but still allocated pending application closure of the handle. 
.................... } TCP_STATE; 
....................  
.................... typedef enum 
.................... { 
.................... 	SSL_NONE = 0,			// No security is enabled 
.................... 	SSL_HANDSHAKING,		// Handshake is progressing (no application data allowed) 
.................... 	SSL_ESTABLISHED,		// Connection is established and secured 
.................... 	SSL_CLOSED				// Connection has been closed (no applicaiton data is allowed) 
.................... } SSL_STATE; 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	TCB Definitions 
....................   ***************************************************************************/ 
....................  
.................... // TCP Control Block (TCB) stub data storage.  Stubs are stored in local PIC RAM for speed. 
.................... // Current size is 34 bytes (PIC18), 36 bytes (PIC24/dsPIC), or 56 (PIC32) 
.................... typedef struct 
.................... { 
.................... 	PTR_BASE bufferTxStart;		// First byte of TX buffer 
.................... 	PTR_BASE bufferRxStart;		// First byte of RX buffer.  TX buffer ends 1 byte prior 
.................... 	PTR_BASE bufferEnd;			// Last byte of RX buffer 
.................... 	PTR_BASE txHead;			// Head pointer for TX 
.................... 	PTR_BASE txTail;			// Tail pointer for TX 
.................... 	PTR_BASE rxHead;			// Head pointer for RX 
.................... 	PTR_BASE rxTail;			// Tail pointer for RX 
....................     DWORD eventTime;			// Packet retransmissions, state changes 
.................... 	WORD eventTime2;			// Window updates, automatic transmission 
.................... 	union 
.................... 	{ 
.................... 		WORD delayedACKTime;	// Delayed Acknowledgement timer 
.................... 		WORD closeWaitTime;		// TCP_CLOSE_WAIT timeout timer 
.................... 	} OverlappedTimers; 
....................     TCP_STATE smState;			// State of this socket 
....................     struct 
....................     { 
.................... 	    unsigned char vUnackedKeepalives : 3;		// Count of how many keepalives have been sent with no response 
....................         unsigned char bServer : 1;					// Socket should return to listening state when closed 
.................... 		unsigned char bTimerEnabled	: 1;			// Timer is enabled 
.................... 		unsigned char bTimer2Enabled : 1;			// Second timer is enabled 
.................... 		unsigned char bDelayedACKTimerEnabled : 1;	// DelayedACK timer is enabled 
.................... 		unsigned char bOneSegmentReceived : 1;		// A segment has been received 
.................... 		unsigned char bHalfFullFlush : 1;			// Flush is for being half full 
.................... 		unsigned char bTXASAP : 1;					// Transmit as soon as possible (for Flush) 
.................... 		unsigned char bTXASAPWithoutTimerReset : 1;	// Transmit as soon as possible (for Flush), but do not reset retransmission timers 
.................... 		unsigned char bTXFIN : 1;					// FIN needs to be transmitted 
.................... 		unsigned char bSocketReset : 1;				// Socket has been reset (self-clearing semaphore) 
.................... 		unsigned char bSSLHandshaking : 1;			// Socket is in an SSL handshake 
.................... 		unsigned char filler : 2;					// Future expansion 
....................     } Flags; 
.................... 	WORD_VAL remoteHash;	// Consists of remoteIP, remotePort, localPort for connected sockets.  It is a localPort number only for listening server sockets. 
....................  
....................     #if defined(STACK_USE_SSL) 
....................     PTR_BASE sslTxHead;		// Position of data being written in next SSL application record 
....................     						//   Also serves as cache of localSSLPort when smState = TCP_LISTENING 
....................     PTR_BASE sslRxHead;		// Position of incoming data not yet handled by SSL 
....................     BYTE sslStubID;			// Which sslStub is associated with this connection 
....................     BYTE sslReqMessage;		// Currently requested SSL message 
....................     #endif 
....................  
.................... 	BYTE vMemoryMedium;		// Which memory medium the TCB is actually stored 
.................... 	 
.................... } TCB_STUB; 
....................  
.................... // Remainder of TCP Control Block data. 
.................... // The rest of the TCB is stored in Ethernet buffer RAM or elsewhere as defined by vMemoryMedium. 
.................... // Current size is 41 (PIC18), 42 (PIC24/dsPIC), or 48 bytes (PIC32) 
.................... typedef struct 
.................... { 
.................... 	DWORD		retryInterval;			// How long to wait before retrying transmission 
.................... 	DWORD		MySEQ;					// Local sequence number 
.................... 	DWORD		RemoteSEQ;				// Remote sequence number 
.................... 	PTR_BASE	txUnackedTail;			// TX tail pointer for data that is not yet acked 
....................     WORD_VAL	remotePort;				// Remote port number 
....................     WORD_VAL	localPort;				// Local port number 
.................... 	WORD		remoteWindow;			// Remote window size 
.................... 	WORD		wFutureDataSize;		// How much out-of-order data has been received 
.................... 	union 
.................... 	{ 
.................... 		NODE_INFO	niRemoteMACIP;		// 10 bytes for MAC and IP address 
.................... 		DWORD		dwRemoteHost;		// RAM or ROM pointer to a hostname string (ex: "www.microchip.com") 
.................... 	} remote; 
.................... 	SHORT		sHoleSize;				// Size of the hole, or -1 for none exists.  (0 indicates hole has just been filled) 
....................     struct 
....................     { 
....................         unsigned char bFINSent : 1;		// A FIN has been sent 
.................... 		unsigned char bSYNSent : 1;		// A SYN has been sent 
.................... 		unsigned char bRemoteHostIsROM : 1;	// Remote host is stored in ROM 
.................... 		unsigned char bRXNoneACKed1 : 1;	// A duplicate ACK was likely received 
.................... 		unsigned char bRXNoneACKed2 : 1;	// A second duplicate ACK was likely received 
.................... 		unsigned char filler : 3;		// future use 
....................     } flags; 
.................... 	WORD		wRemoteMSS;				// Maximum Segment Size option advirtised by the remote node during initial handshaking 
....................     #if defined(STACK_USE_SSL) 
....................     WORD_VAL	localSSLPort;			// Local SSL port number (for listening sockets) 
....................     #endif 
.................... 	BYTE		retryCount;				// Counter for transmission retries 
.................... 	BYTE		vSocketPurpose;			// Purpose of socket (as defined in TCPIPConfig.h) 
.................... } TCB; 
....................  
.................... // Information about a socket 
.................... typedef struct 
.................... { 
.................... 	NODE_INFO remote;		// NODE_INFO structure for remote node 
.................... 	WORD_VAL remotePort;	// Port number associated with remote node 
.................... } SOCKET_INFO; 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	Function Declarations 
....................   ***************************************************************************/ 
....................  
.................... void TCPInit(void); 
.................... SOCKET_INFO* TCPGetRemoteInfo(TCP_SOCKET hTCP); 
.................... BOOL TCPWasReset(TCP_SOCKET hTCP); 
.................... BOOL TCPIsConnected(TCP_SOCKET hTCP); 
.................... void TCPDisconnect(TCP_SOCKET hTCP); 
.................... void TCPClose(TCP_SOCKET hTCP); 
.................... WORD TCPIsPutReady(TCP_SOCKET hTCP); 
.................... BOOL TCPPut(TCP_SOCKET hTCP, BYTE byte); 
.................... WORD TCPPutArray(TCP_SOCKET hTCP, BYTE* Data, WORD Len); 
.................... BYTE* TCPPutString(TCP_SOCKET hTCP, BYTE* Data); 
.................... WORD TCPIsGetReady(TCP_SOCKET hTCP); 
.................... WORD TCPGetRxFIFOFree(TCP_SOCKET hTCP); 
.................... BOOL TCPGet(TCP_SOCKET hTCP, BYTE* byte); 
.................... WORD TCPGetArray(TCP_SOCKET hTCP, BYTE* buffer, WORD count); 
.................... BYTE TCPPeek(TCP_SOCKET hTCP, WORD wStart); 
.................... WORD TCPPeekArray(TCP_SOCKET hTCP, BYTE *vBuffer, WORD wLen, WORD wStart); 
.................... WORD TCPFindEx(TCP_SOCKET hTCP, BYTE cFind, WORD wStart, WORD wSearchLen, BOOL bTextCompare); 
.................... WORD TCPFindArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare); 
.................... void TCPDiscard(TCP_SOCKET hTCP); 
.................... BOOL TCPProcess(NODE_INFO* remote, IP_ADDR* localIP, WORD len); 
.................... void TCPTick(void); 
.................... void TCPFlush(TCP_SOCKET hTCP); 
....................  
.................... // Create a server socket and ignore dwRemoteHost. 
.................... #define TCP_OPEN_SERVER		0u 
.................... #if defined(STACK_CLIENT_MODE) 
.................... 	#if defined(STACK_USE_DNS) 
.................... 		// Create a client socket and use dwRemoteHost as a RAM pointer to a hostname string. 
.................... 		#define TCP_OPEN_RAM_HOST	1u 
.................... 		// Create a client socket and use dwRemoteHost as a ROM pointer to a hostname string. 
.................... 		#define TCP_OPEN_ROM_HOST	2u 
.................... 	#else 
.................... 		// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_RAM_HOST while the DNS client module is not enabled.  
.................... 		#define TCP_OPEN_RAM_HOST	You_need_to_enable_STACK_USE_DNS_to_use_TCP_OPEN_RAM_HOST 
.................... 		// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_ROM_HOST while the DNS client module is not enabled.  
.................... 		#define TCP_OPEN_ROM_HOST	You_need_to_enable_STACK_USE_DNS_to_use_TCP_OPEN_ROM_HOST 
.................... 	#endif 
.................... 	// Create a client socket and use dwRemoteHost as a literal IP address. 
.................... 	#define TCP_OPEN_IP_ADDRESS	3u 
.................... 	// Create a client socket and use dwRemoteHost as a pointer to a NODE_INFO structure containing the exact remote IP address and MAC address to use. 
.................... 	#define TCP_OPEN_NODE_INFO	4u 
.................... #else 
.................... 	// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_RAM_HOST while STACK_CLIENT_MODE feature is not enabled.  
.................... 	#define TCP_OPEN_RAM_HOST	You_need_to_enable_STACK_CLIENT_MODE_to_use_TCP_OPEN_RAM_HOST 
.................... 	// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_ROM_HOST while STACK_CLIENT_MODE feature is not enabled.  
.................... 	#define TCP_OPEN_ROM_HOST	You_need_to_enable_STACK_CLIENT_MODE_to_use_TCP_OPEN_ROM_HOST 
.................... 	// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_IP_ADDRESS while STACK_CLIENT_MODE feature is not enabled.  
.................... 	#define TCP_OPEN_IP_ADDRESS	You_need_to_enable_STACK_CLIENT_MODE_to_use_TCP_OPEN_IP_ADDRESS 
.................... 	// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_NODE_INFO while STACK_CLIENT_MODE feature is not enabled.  
.................... 	#define TCP_OPEN_NODE_INFO	You_need_to_enable_STACK_CLIENT_MODE_to_use_TCP_OPEN_NODE_INFO 
.................... #endif 
.................... TCP_SOCKET TCPOpen(DWORD dwRemoteHost, BYTE vRemoteHostType, WORD wPort, BYTE vSocketPurpose); 
....................  
.................... #if defined(__18CXX) 
.................... 	WORD TCPFindROMArrayEx(TCP_SOCKET hTCP, ROM BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare); 
....................  
.................... 	/***************************************************************************** 
.................... 	  Summary: 
.................... 		Alias to TCPFindROMArrayEx with no length parameter. 
.................... 	 
.................... 	  Description: 
.................... 		This function is an alias to TCPFindROMArrayEx with no length parameter.   
.................... 		It is provided for backwards compatibility with an older API. 
.................... 	  ***************************************************************************/ 
.................... 	#define TCPFindROMArray(a,b,c,d,e)		TCPFindROMArrayEx(a,b,c,d,0,e) 
.................... 	 
.................... 	WORD TCPPutROMArray(TCP_SOCKET hTCP, ROM BYTE* Data, WORD Len); 
.................... 	ROM BYTE* TCPPutROMString(TCP_SOCKET hTCP, ROM BYTE* Data); 
.................... #else 
.................... 	#define TCPFindROMArray(a,b,c,d,e) 		TCPFindArray(a,(BYTE*)b,c,d,e) 
.................... 	#define TCPFindROMArrayEx(a,b,c,d,e,f) 	TCPFindArrayEx(a,(BYTE*)b,c,d,e,f) 
.................... 	#define TCPPutROMArray(a,b,c)			TCPPutArray(a,(BYTE*)b,c) 
.................... 	#define TCPPutROMString(a,b)			TCPPutString(a,(BYTE*)b) 
.................... #endif 
....................  
.................... WORD TCPGetTxFIFOFull(TCP_SOCKET hTCP); 
.................... // Alias to TCPIsGetReady provided for API completeness 
.................... #define TCPGetRxFIFOFull(a)					TCPIsGetReady(a) 
.................... // Alias to TCPIsPutReady provided for API completeness 
.................... #define TCPGetTxFIFOFree(a) 				TCPIsPutReady(a) 
....................  
.................... #define TCP_ADJUST_GIVE_REST_TO_RX	0x01u	// Resize flag: extra bytes go to RX  
.................... #define TCP_ADJUST_GIVE_REST_TO_TX	0x02u	// Resize flag: extra bytes go to TX 
.................... #define TCP_ADJUST_PRESERVE_RX		0x04u	// Resize flag: attempt to preserve RX buffer 
.................... #define TCP_ADJUST_PRESERVE_TX		0x08u	// Resize flag: attempt to preserve TX buffer 
.................... BOOL TCPAdjustFIFOSize(TCP_SOCKET hTCP, WORD wMinRXSize, WORD wMinTXSize, BYTE vFlags); 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... BOOL TCPStartSSLClient(TCP_SOCKET hTCP, BYTE* host); 
.................... BOOL TCPStartSSLClientEx(TCP_SOCKET hTCP, BYTE* host, void * buffer, BYTE suppDataType); 
.................... BOOL TCPStartSSLServer(TCP_SOCKET hTCP); 
.................... BOOL TCPAddSSLListener(TCP_SOCKET hTCP, WORD port); 
.................... BOOL TCPRequestSSLMessage(TCP_SOCKET hTCP, BYTE msg); 
.................... BOOL TCPSSLIsHandshaking(TCP_SOCKET hTCP); 
.................... BOOL TCPIsSSL(TCP_SOCKET hTCP); 
.................... void TCPSSLHandshakeComplete(TCP_SOCKET hTCP); 
.................... void TCPSSLDecryptMAC(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, WORD len); 
.................... void TCPSSLInPlaceMACEncrypt(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, BYTE* MACSecret, WORD len); 
.................... void TCPSSLPutRecordHeader(TCP_SOCKET hTCP, BYTE* hdr, BOOL recDone); 
.................... WORD TCPSSLGetPendingTxSize(TCP_SOCKET hTCP); 
.................... void TCPSSLHandleIncoming(TCP_SOCKET hTCP); 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Summary: 
.................... 	Alias to TCPFindEx with no length parameter. 
....................  
....................   Description: 
.................... 	This function is an alias to TCPFindEx with no length parameter.  It is 
.................... 	provided for backwards compatibility with an older API. 
....................   ***************************************************************************/ 
.................... #define TCPFind(a,b,c,d)					TCPFindEx(a,b,c,0,d) 
....................  
....................  
.................... /***************************************************************************** 
....................   Summary: 
.................... 	Alias to TCPFindArrayEx with no length parameter. 
....................  
....................   Description: 
.................... 	This function is an alias to TCPFindArrayEx with no length parameter.  It is 
.................... 	provided for backwards compatibility with an older API. 
....................   ***************************************************************************/ 
.................... #define TCPFindArray(a,b,c,d,e)				TCPFindArrayEx(a,b,c,d,0,e) 
....................  
.................... /***************************************************************************** 
....................   Summary: 
.................... 	Alias to TCPOpen as a server. 
....................  
....................   Description: 
.................... 	This function is an alias to TCPOpen for server sockets.  It is provided 
.................... 	for backwards compatibility with older versions of the stack.  New 
.................... 	applications should use the TCPOpen API instead. 
....................   ***************************************************************************/ 
.................... #define TCPListen(port)			TCPOpen(0, TCP_OPEN_SERVER, port, TCP_PURPOSE_DEFAULT) 
....................  
.................... /***************************************************************************** 
....................   Summary: 
.................... 	Alias to TCPOpen as a client. 
....................  
....................   Description: 
.................... 	This function is an alias to TCPOpen for client sockets.  It is provided 
.................... 	for backwards compatibility with older versions of the stack.  New 
.................... 	applications should use the TCPOpen API instead. 
....................   ***************************************************************************/ 
.................... #define TCPConnect(remote,port)	TCPOpen((DWORD)remote, TCP_OPEN_NODE_INFO, port, TCP_PURPOSE_DEFAULT) 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    	Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		03/16/07	Original 
....................  ********************************************************************/ 
.................... #ifndef __ICMP_H 
.................... #define __ICMP_H 
....................  
.................... void ICMPProcess(NODE_INFO *remote, WORD len); 
....................  
.................... BOOL ICMPBeginUsage(void); 
.................... void ICMPSendPing(DWORD dwRemoteIP); 
.................... void ICMPSendPingToHost(BYTE * szRemoteHost); 
.................... LONG ICMPGetReply(void); 
.................... void ICMPEndUsage(void); 
....................  
.................... #if defined(__18CXX) 
.................... 	void ICMPSendPingToHostROM(ROM BYTE * szRemoteHost); 
.................... #else 
.................... 	#define ICMPSendPingToHostROM(a) 	ICMPSendPingToHost((BYTE*)(a)) 
.................... #endif 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #if defined(MRF24WG) 
....................  #define WF_DisplayModuleAssertInfo() 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_CCS_HTTP1_SERVER) 
....................    #include "ccs_HTTP.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                     /// 
.................... ///                              HTTP.H                                 /// 
.................... ///                                                                     /// 
.................... /// Simple webserver for the Microchip TCP/IP stack.                    /// 
.................... /// NOTE: THIS IS A DIFFERENT HTTP.H THAN WHAT MICROCHIP PROVIDES       /// 
.................... ///                                                                     /// 
.................... /// See HTTP.C for documenation                                         /// 
.................... ///                                                                     /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef HTTP_USE_CHUNKS 
.................... #define HTTP_USE_CHUNKS   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_DOUBLE_ESCAPE 
.................... #define HTTP_USE_DOUBLE_ESCAPE   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_CONTENT_TYPE 
.................... #define HTTP_USE_CONTENT_TYPE   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_PORT 
.................... #define HTTP_PORT             80 
.................... #endif 
....................  
.................... #ifndef HTTP_NUM_SOCKETS 
.................... #define HTTP_NUM_SOCKETS      1 
.................... #endif 
....................  
.................... #ifndef HTTP_GET_PARAM_MAX_SIZE 
.................... #define HTTP_GET_PARAM_MAX_SIZE  254 
.................... #endif 
....................  
.................... void HTTPInit(void); 
.................... void HTTPServer(void); 
....................  
.................... //**** CALLBACKS START ******/// 
....................  
.................... /// the following three functions are callbacks and 
.................... /// must be written in your main application!!!  see the documentation above 
.................... /// for more help. 
....................  
.................... #if HTTP_USE_CONTENT_TYPE 
....................  void http_get_page(char *file_str, unsigned int32 *retAddress, char *retStr); 
.................... #else 
....................  unsigned int32 http_get_page(char *file_str); 
.................... #endif 
....................  
.................... unsigned int8 http_format_char(unsigned int32 file, char id, char *str, unsigned int8 max_ret); 
.................... void http_exec_cgi(unsigned int32 file, char *key, char *val); 
....................  
.................... //**** CALLBACKS END ******/// 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    #include "ccs_HTTP2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_TWITTER) 
....................    #include "ccs_twitter.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SMTP) 
....................    #include "ccs_SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_TFTP_SERVER) 
....................    #include "ccs_TFTPs.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    #include "ccs_SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_GRATUITOUS_ARP) 
....................    #include "ccs_gratarp.h" 
.................... #endif 
....................  
.................... #define TickGetDiff(a, b)  (a-b) 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................        #if !defined(STACK_USE_DNS) 
....................            #define STACK_USE_DNS 
....................        #endif 
....................        #if !defined(STACK_USE_UDP) 
....................            #define STACK_USE_UDP 
....................        #endif        
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    #ifndef STACK_USE_MPFS 
....................       #define STACK_USE_MPFS 
....................     #endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    #if !defined(STACK_CLIENT_MODE) 
....................        #define STACK_CLIENT_MODE 
....................    #endif 
.................... #endif 
....................  
.................... #if STACK_USE_WIFI 
....................    // if defined, MyWFIsConnected() won't return TRUE in AdHoc mode until after 
....................    // it receives some IP traffic.  It will then stay connected until after 5 
....................    // minutes of no activity. 
....................    #define WIFI_ADHOC_CONNECTION_TIMER ((TICK)TICKS_PER_SECOND * 300) 
....................     
....................    #if defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    extern int1 g_WifiAdhocIsConn; 
....................    extern TICK g_WifiAdhocTickConn; 
....................    #endif 
....................     
....................    extern unsigned int8 WIFI_channelList[16]; 
....................    extern unsigned int8 WIFI_numChannelsInList; 
....................    extern unsigned int8 WIFI_region; 
....................    extern int1 g_WifiConnectFail; 
....................     
....................    // this is similar to MACIsLinked() and WFisConnected().  this one has some 
....................    // filters and extra UI logic to better represent link status to the user. 
....................    // use this for UI displays. 
....................    // REMOVED - Use IsLinked() instead 
....................    //int1 MyWFisConnected(void); 
....................     
....................    // This routine does a few things: 
....................    //  * Reset WIFI unit if no it goes a long time without a connection, 
....................    //       because old modules would hang on WPA connect failure. 
....................    //  * Ad-Hoc connection timer support (WIFI_ADHOC_CONNECTION_TIMER) 
....................    //  * LED Traffic flickering and LED connection status 
....................    void WIFIConnectTask(void); 
....................     
....................    #if defined(WF_FORCE_NO_PS_POLL) 
....................       void WF_CCS_PsPollDisable(void); 
....................    #endif 
.................... #endif 
....................  
.................... int1 DHCPBoundOrDisabled(void); 
....................  
.................... // A higher level version of MACIsLinked(). 
.................... //  - returns FALSE if MACIsLinked() is TRUE -but- DHCP is enabled and not 
.................... //       bound. 
.................... //  - returns FALSE in WIFI if using AdHoc mode and it has been a while 
.................... //       since no traffic 
.................... //  - else, returns MACIsLinked() 
.................... int1 IsLinked(void); 
....................  
.................... //this macro called by stack when new tcp/ip traffic tx/rx. 
.................... #if STACK_USE_WIFI 
....................    #define STACK_USE_CCS_TX_EVENT()  LinkTraffic(TRUE) 
....................    #define STACK_USE_CCS_RX_EVENT()  LinkTraffic(FALSE) 
....................    void LinkTraffic(int1 isTx); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS) 
....................    #include "TCPIP Stack/mpfs.h" 
....................     
....................    extern MPFS _MpfsEofLoc; 
....................     
....................    //returns number of bytes read before EOF. 
....................    //if it returns n then no EOF. 
....................    unsigned int16 MPFSGetBytes(unsigned int8 *pDest, unsigned int16 n); 
.................... #endif 
....................  
.................... #if defined(__PCH__) 
.................... TICK TickGetSafe(void); 
.................... #endif 
....................  
.................... BYTE GenerateRandomByteFromTimers(void); 
....................  
.................... #endif 
....................  
....................  
.................... #if STACK_USE_CCS_INI 
....................    #include "ee.h" 
....................    #include "ccsui.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS) 
....................    #if !defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)  
....................       #if defined(__PCD__) 
....................          #import(RAW, file="mpfs/mpfsimg.bin", location=MPFS_Start, bpi=2) 
....................       #else 
....................          #import(RAW, file="mpfs/mpfsimg.bin", location=MPFS_Start) 
....................       #endif 
....................    #endif 
.................... #endif 
....................  
....................  
.................... void DebugPutc(char c) 
.................... { 
....................    fputc(c, STREAM_UI); 
.................... } 
....................  
.................... //#define debug_tftp   printf 
.................... //#define debug_tftp_putc DebugPutc 
....................  
.................... //#define debug_html         printf 
.................... //#define debug_html_putc    DebugPutc 
....................  
.................... //#define debug_mpfs         printf 
.................... //#define debug_mpfs_putc    DebugPutc 
....................  
.................... //#define debug_enc28j60  printf 
.................... //#define debug_enc28j60_putc  DebugPutc 
.................... //void MACToString(char *str, MAC_ADDR *mac); 
....................  
.................... //#define debug_dhcp   printf 
.................... //#define debug_dhcp_putc DebugPutc 
....................  
.................... //#define debug_tcp printf 
.................... //#define debug_tcp_putc  DebugPutc 
....................  
.................... #include "tcpip/StackTsk2.c" 
.................... // 'glue' file for using Microchip's TCP/IP stack inside CCS C Compiler without 
.................... // a linker.   
.................... // Also includes some macros/defines for porting older V3 stack to this current 
.................... // stack. 
.................... // Also provides extra routines written by CCS to improve the stack. 
.................... // 
.................... // __DISABLE_WIFI_INTERRUPT__ was supported in an older 5.3x version of the 
.................... // stack, but it is currently not supported anymore. 
....................  
.................... #ifndef __CCS_STACKTSK2_C__ 
.................... #define __CCS_STACKTSK2_C__ 
....................  
.................... #if defined(__DISABLE_WIFI_INTERRUPT__) 
....................    #error This has been removed. 
.................... #endif 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if defined(__PCH__) 
.................... #int_timer0 NOCLEAR 
.................... void ISRTimer0(void) 
.................... { 
....................    TickUpdate(); 
*
000B0:  BRA    0096
.................... } 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) && !defined(__DISABLE_WIFI_INTERRUPT__) 
.................... #int_EXT HIGH NOCLEAR 
....................    void ISREXT0(void) 
....................    { 
....................          WFEintISR(); 
....................        
....................    } 
.................... #endif 
....................  
.................... #if defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    int1 g_WifiAdhocIsConn = FALSE; 
....................    TICK g_WifiAdhocTickConn; 
....................    #define WIFIAdhocConnectionPing()   g_WifiAdhocIsConn=TRUE; g_WifiAdhocTickConn=TickGet() 
....................    #define WIFIAdhocConnectionReset()  g_WifiAdhocIsConn = FALSE 
.................... #endif 
....................  
.................... #include "StackTsk.c" 
.................... /********************************************************************* 
....................  * 
....................  *   TCP/IP Stack Manager 
....................  *  Module for Microchip TCP/IP Stack 
....................  *    -Handles internal RX packet pre-processing prior to dispatching  
....................  *    to upper application layers. 
....................  *    -Reference: AN833 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.c 
....................  * Dependencies:    ARP, IP, Network layer interface (ENC28J60.c,  
....................  *               ETH97J60.c, ENCX24J600.c, or WFMac.c) 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  * 
....................  * Darren Rook/CCS       4/13/11    Added some CCS modules (see STACK_USE_CCS_*) 
....................  *                                  Added STACK_USE_CCS_RX_EVENT() macro on TCP/IP traffic.  
.................... ********************************************************************/ 
.................... #define __STACKTSK_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
000B2:  GOTO   0054
.................... #if defined( WF_CS_TRIS ) 
....................     #if defined( WF_CONFIG_CONSOLE ) 
....................         #include "TCPIP Stack/WFConsole.h" 
....................     #endif 
....................     #if defined( STACK_USE_EZ_CONFIG ) || defined( EZ_CONFIG_SCAN ) 
....................         #include "TCPIP Stack/WFEasyConfig.h" 
....................     #endif 
....................    #include "TCPIP Stack/WFApi.h" 
.................... #endif 
....................  
.................... // Stack FSM states. 
.................... typedef enum 
.................... { 
....................     SM_STACK_IDLE, 
....................     SM_STACK_MAC, 
....................     SM_STACK_IP, 
....................     SM_STACK_ARP, 
....................     SM_STACK_TCP, 
....................     SM_STACK_UDP 
.................... } SM_STACK; 
.................... static SM_STACK smStack; 
....................  
.................... NODE_INFO remoteNode; 
....................  
.................... #if defined (WF_CS_TRIS) && defined (STACK_USE_DHCP_CLIENT) 
.................... BOOL g_DhcpRenew = FALSE; 
.................... extern void SetDhcpProgressState(void); 
.................... UINT32 g_DhcpRetryTimer = 0; 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componets are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines are used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void) 
.................... { 
....................    static BOOL once = FALSE; 
....................     smStack                     = SM_STACK_IDLE; 
*
02AE8:  CLRF   5C
....................  
.................... #if defined(STACK_USE_IP_GLEANING) || defined(STACK_USE_DHCP_CLIENT) 
....................     /* 
....................      * If DHCP or IP Gleaning is enabled, 
....................      * startup in Config Mode. 
....................      */ 
....................     AppConfig.Flags.bInConfigMode = TRUE; 
....................  
.................... #endif 
....................  
.................... #if defined (WF_CS_TRIS) && defined (STACK_USE_DHCP_CLIENT) 
....................    g_DhcpRenew = FALSE; 
....................    g_DhcpRetryTimer = 0; 
.................... #endif 
....................  
....................    if (!once) { 
02AEA:  BTFSC  67.0
02AEC:  BRA    2B18
....................       // Seed the LFSRRand() function 
....................       LFSRSeedRand(GenerateRandomDWORD()); 
02AEE:  CALL   06F4
02AF2:  MOVFF  03,2E6
02AF6:  MOVFF  02,2E5
02AFA:  MOVFF  01,2E4
02AFE:  MOVFF  00,2E3
02B02:  MOVFF  03,307
02B06:  MOVFF  02,306
02B0A:  MOVFF  01,305
02B0E:  MOVFF  00,304
02B12:  CALL   0692
....................       once = TRUE; 
02B16:  BSF    67.0
....................    } 
....................  
....................     MACInit(); 
02B18:  GOTO   0A54
....................  
.................... #if defined (WF_AGGRESSIVE_PS) && defined (WF_CS_TRIS) 
....................    WFEnableAggressivePowerSave(); 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) && defined(STACK_USE_EZ_CONFIG) && !defined(__18CXX) 
....................     WFEasyConfigInit(); 
.................... #endif     
....................  
....................     ARPInit(); 
02B1C:  GOTO   0C72
....................  
.................... #if defined(STACK_USE_UDP) 
....................     UDPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
....................     TCPInit(); 
02B20:  GOTO   1436
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
....................    BerkeleySocketInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
....................     HTTPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
....................    RSAInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
....................     SSLInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) && defined(STACK_USE_MPFS2) 
....................     FTPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
....................    SNMPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) 
....................    DHCPInit(0); 
....................     if(!AppConfig.Flags.bIsDHCPEnabled) 
....................     { 
....................         DHCPDisable(0); 
....................     } 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     AutoIPInit(0); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
....................    DDNSInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
....................    RandomInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SMTP) 
....................    SMTPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    NTPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_GRATUITOUS_ARP) 
....................    GratArpInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP1_SERVER) || defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    HTTPInit(); 
02B24:  BRA    2A70
.................... #endif 
....................  
....................    #if defined(STACK_USE_CCS_TFTP_SERVER) 
02B26:  GOTO   91EE (RETURN)
....................    TFTPSInit(); 
....................    #endif 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically to 
....................  *                  ensure timely responses. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void) 
.................... { 
....................     WORD dataCount; 
....................     IP_ADDR tempLocalIP; 
....................    BYTE cFrameType; 
....................    BYTE cIPFrameType; 
....................  
....................     
....................     #if defined( WF_CS_TRIS ) 
....................         // This task performs low-level MAC processing specific to the MRF24W 
....................         MACProcess(); 
....................         #if defined( STACK_USE_EZ_CONFIG ) && !defined(__18CXX) 
....................             WFEasyConfigMgr(); 
....................         #endif 
....................          
....................        #if defined(STACK_USE_DHCP_CLIENT) 
....................            // Normally, an application would not include  DHCP module 
....................            // if it is not enabled. But in case some one wants to disable 
....................            // DHCP module at run-time, remember to not clear our IP 
....................            // address if link is removed. 
....................            if(AppConfig.Flags.bIsDHCPEnabled) 
....................            { 
....................               if(g_DhcpRenew == TRUE) 
....................               { 
....................                  g_DhcpRenew = FALSE; 
....................                   AppConfig.MyIPAddr.Val = AppConfig.DefaultIPAddr.Val; 
....................                  AppConfig.MyMask.Val = AppConfig.DefaultMask.Val; 
....................                  AppConfig.Flags.bInConfigMode = TRUE; 
....................                  DHCPInit(0); 
....................                g_DhcpRetryTimer = (UINT32)TickGet(); 
....................               } else { 
....................                  if (g_DhcpRetryTimer && TickGet() - g_DhcpRetryTimer >= TICKS_PER_SECOND * 8) { 
....................                   DHCPInit(0); 
....................                   g_DhcpRetryTimer = (UINT32)TickGet(); 
....................                  } 
....................               } 
....................             
....................               // DHCP must be called all the time even after IP configuration is 
....................               // discovered. 
....................               // DHCP has to account lease expiration time and renew the configuration 
....................               // time. 
....................               DHCPTask(); 
....................                
....................               if(DHCPIsBound(0)) { 
....................                  AppConfig.Flags.bInConfigMode = FALSE; 
....................                g_DhcpRetryTimer = 0; 
....................               } 
....................            } 
....................        #endif // STACK_USE_DHCP_CLIENT 
....................          
....................     #endif // WF_CS_TRIS 
....................  
....................  
....................    #if defined(STACK_USE_DHCP_CLIENT) && !defined(WF_CS_TRIS) 
....................    // Normally, an application would not include  DHCP module 
....................    // if it is not enabled. But in case some one wants to disable 
....................    // DHCP module at run-time, remember to not clear our IP 
....................    // address if link is removed. 
....................    if(AppConfig.Flags.bIsDHCPEnabled) 
....................    { 
....................       static BOOL bLastLinkState = FALSE; 
....................       BOOL bCurrentLinkState; 
....................        
....................       bCurrentLinkState = MACIsLinked(); 
....................       if(bCurrentLinkState != bLastLinkState) 
....................       { 
....................          bLastLinkState = bCurrentLinkState; 
....................          if(!bCurrentLinkState) 
....................          { 
....................             AppConfig.MyIPAddr.Val = AppConfig.DefaultIPAddr.Val; 
....................             AppConfig.MyMask.Val = AppConfig.DefaultMask.Val; 
....................             AppConfig.Flags.bInConfigMode = TRUE; 
....................             DHCPInit(0); 
....................          } 
....................       } 
....................     
....................       // DHCP must be called all the time even after IP configuration is 
....................       // discovered. 
....................       // DHCP has to account lease expiration time and renew the configuration 
....................       // time. 
....................       DHCPTask(); 
....................        
....................       if(DHCPIsBound(0)) 
....................          AppConfig.Flags.bInConfigMode = FALSE; 
....................    } 
....................    #endif 
....................     
....................  
....................     #if defined (STACK_USE_AUTO_IP) 
....................     AutoIPTasks(); 
....................     #endif 
....................  
....................    #if defined(STACK_USE_TCP) 
....................    // Perform all TCP time related tasks (retransmit, send acknowledge, close connection, etc) 
....................    TCPTick(); 
*
05A20:  GOTO   2FFE
....................    #endif 
....................  
....................  
....................    #if defined(STACK_USE_UDP) 
....................    UDPTask(); 
....................    #endif 
....................  
....................   #if defined(STACK_USE_CCS_GRATUITOUS_ARP) 
....................    GratArpTask(); 
....................   #endif 
....................  
....................    // Process as many incomming packets as we can 
....................    while(1) 
....................    { 
....................       //if using the random module, generate entropy 
....................       #if defined(STACK_USE_RANDOM) 
....................          RandomAdd(remoteNode.MACAddr.v[5]); 
....................       #endif 
....................  
....................       // We are about to fetch a new packet, make sure that the  
....................       // UDP module knows that any old RX data it has laying  
....................       // around will now be gone. 
....................       #if defined(STACK_USE_UDP) 
....................          UDPDiscard(); 
....................       #endif 
....................  
....................       // Fetch a packet (throws old one away, if not thrown away  
....................       // yet) 
....................       if(!MACGetHeader(&remoteNode.MACAddr, &cFrameType)) 
05A24:  MOVLB  2
05A26:  CLRF   xEC
05A28:  MOVLW  61
05A2A:  MOVWF  xEB
05A2C:  MOVLW  02
05A2E:  MOVWF  xEE
05A30:  MOVLW  E9
05A32:  MOVWF  xED
05A34:  MOVLB  0
05A36:  GOTO   397E
05A3A:  MOVF   01,F
05A3C:  BNZ   5A40
....................          break; 
05A3E:  BRA    5B56
....................  
....................       // When using a WiFi module, filter out all incoming packets that have  
....................       // the same source MAC address as our own MAC address.  This is to  
....................       // prevent receiving and passing our own broadcast packets up to other  
....................       // layers and avoid, for example, having our own gratuitous ARPs get  
....................       // answered by ourself. 
....................       #if defined(WF_CS_TRIS) 
....................          if(memcmp((void*)&remoteNode.MACAddr, (void*)&AppConfig.MyMACAddr, 6) == 0u) 
....................             continue; 
....................       #endif 
....................        
....................       #if defined(STACK_USE_CCS_RX_EVENT) 
....................       STACK_USE_CCS_RX_EVENT();  //__CCS__ 
....................       #endif 
....................        
....................       // Dispatch the packet to the appropriate handler 
....................       switch(cFrameType) 
05A40:  MOVLB  2
05A42:  MOVF   xE9,W
05A44:  XORLW  06
05A46:  MOVLB  0
05A48:  BZ    5A50
05A4A:  XORLW  06
05A4C:  BZ    5A56
05A4E:  BRA    5B54
....................       { 
....................          case MAC_ARP: 
....................             ARPProcess(); 
05A50:  GOTO   3AD6
....................             break; 
05A54:  BRA    5B54
....................     
....................          case MAC_IP: 
....................             if(!IPGetHeader(&tempLocalIP, &remoteNode, &cIPFrameType, &dataCount)) 
05A56:  MOVLW  02
05A58:  MOVLB  2
05A5A:  MOVWF  xEC
05A5C:  MOVLW  E5
05A5E:  MOVWF  xEB
05A60:  CLRF   xEE
05A62:  MOVLW  5D
05A64:  MOVWF  xED
05A66:  MOVLW  02
05A68:  MOVWF  xF0
05A6A:  MOVLW  EA
05A6C:  MOVWF  xEF
05A6E:  MOVLW  02
05A70:  MOVWF  xF2
05A72:  MOVLW  E3
05A74:  MOVWF  xF1
05A76:  MOVLB  0
05A78:  GOTO   3D20
05A7C:  MOVF   01,F
05A7E:  BNZ   5A82
....................                break; 
05A80:  BRA    5B54
....................  
....................             #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................             if(cIPFrameType == IP_PROT_ICMP) 
05A82:  MOVLB  2
05A84:  DECFSZ xEA,W
05A86:  BRA    5B2E
....................             { 
....................                #if defined(STACK_USE_IP_GLEANING) 
....................                if(AppConfig.Flags.bInConfigMode && AppConfig.Flags.bIsDHCPEnabled) 
....................                { 
....................                   // According to "IP Gleaning" procedure, 
....................                   // when we receive an ICMP packet with a valid 
....................                   // IP address while we are still in configuration 
....................                   // mode, accept that address as ours and conclude 
....................                   // configuration mode. 
....................                   if(tempLocalIP.Val != 0xffffffff) 
....................                   { 
....................                      AppConfig.Flags.bInConfigMode = FALSE; 
....................                      AppConfig.MyIPAddr = tempLocalIP; 
....................                   } 
....................                } 
....................                #endif 
....................  
....................                // Process this ICMP packet if it the destination IP address matches our address or one of the broadcast IP addressees 
....................                if( (tempLocalIP.Val == AppConfig.MyIPAddr.Val) || 
....................                   (tempLocalIP.Val == 0xFFFFFFFF) || 
.................... #if defined(STACK_USE_ZEROCONF_LINK_LOCAL) || defined(STACK_USE_ZEROCONF_MDNS_SD) 
....................                                                 (tempLocalIP.Val == 0xFB0000E0) || 
.................... #endif 
....................                   (tempLocalIP.Val == ((AppConfig.MyIPAddr.Val & AppConfig.MyMask.Val) | ~AppConfig.MyMask.Val))) 
05A88:  MOVF   29,W
05A8A:  SUBWF  xE5,W
05A8C:  BNZ   5AA0
05A8E:  MOVF   2A,W
05A90:  SUBWF  xE6,W
05A92:  BNZ   5AA0
05A94:  MOVF   2B,W
05A96:  SUBWF  xE7,W
05A98:  BNZ   5AA0
05A9A:  MOVF   2C,W
05A9C:  SUBWF  xE8,W
05A9E:  BZ    5B12
05AA0:  INCFSZ xE5,W
05AA2:  BRA    5AB2
05AA4:  INCFSZ xE6,W
05AA6:  BRA    5AB2
05AA8:  INCFSZ xE7,W
05AAA:  BRA    5AB2
05AAC:  INCFSZ xE8,W
05AAE:  BRA    5AB2
05AB0:  BRA    5B12
05AB2:  MOVF   29,W
05AB4:  ANDWF  2D,W
05AB6:  MOVWF  xEB
05AB8:  MOVF   2A,W
05ABA:  ANDWF  2E,W
05ABC:  MOVWF  xEC
05ABE:  MOVF   2B,W
05AC0:  ANDWF  2F,W
05AC2:  MOVWF  xED
05AC4:  MOVF   2C,W
05AC6:  ANDWF  30,W
05AC8:  MOVWF  xEE
05ACA:  MOVFF  2D,00
05ACE:  COMF   00,F
05AD0:  MOVFF  2E,01
05AD4:  COMF   01,F
05AD6:  MOVFF  2F,02
05ADA:  COMF   02,F
05ADC:  MOVFF  30,03
05AE0:  COMF   03,F
05AE2:  MOVF   00,W
05AE4:  IORWF  xEB,W
05AE6:  MOVWF  00
05AE8:  MOVF   01,W
05AEA:  IORWF  xEC,W
05AEC:  MOVWF  01
05AEE:  MOVF   02,W
05AF0:  IORWF  xED,W
05AF2:  MOVWF  02
05AF4:  MOVF   03,W
05AF6:  IORWF  xEE,W
05AF8:  MOVWF  03
05AFA:  MOVF   00,W
05AFC:  SUBWF  xE5,W
05AFE:  BNZ   5B28
05B00:  MOVF   01,W
05B02:  SUBWF  xE6,W
05B04:  BNZ   5B28
05B06:  MOVF   02,W
05B08:  SUBWF  xE7,W
05B0A:  BNZ   5B28
05B0C:  MOVF   03,W
05B0E:  SUBWF  xE8,W
05B10:  BNZ   5B28
....................                { 
....................                   ICMPProcess(&remoteNode, dataCount); 
05B12:  CLRF   xEC
05B14:  MOVLW  5D
05B16:  MOVWF  xEB
05B18:  MOVFF  2E4,2EE
05B1C:  MOVFF  2E3,2ED
05B20:  MOVLB  0
05B22:  GOTO   3E20
05B26:  MOVLB  2
....................                } 
....................  
....................                break; 
05B28:  MOVLB  0
05B2A:  BRA    5B54
05B2C:  MOVLB  2
....................             } 
....................             #endif 
....................              
....................             #if defined(STACK_USE_TCP) 
....................             if(cIPFrameType == IP_PROT_TCP) 
05B2E:  MOVF   xEA,W
05B30:  SUBLW  06
05B32:  BNZ   5B52
....................             { 
....................                TCPProcess(&remoteNode, &tempLocalIP, dataCount); 
05B34:  CLRF   xEC
05B36:  MOVLW  5D
05B38:  MOVWF  xEB
05B3A:  MOVLW  02
05B3C:  MOVWF  xEE
05B3E:  MOVLW  E5
05B40:  MOVWF  xED
05B42:  MOVFF  2E4,2F0
05B46:  MOVFF  2E3,2EF
05B4A:  MOVLB  0
05B4C:  BRA    5898
....................                break; 
05B4E:  BRA    5B54
05B50:  MOVLB  2
....................             } 
....................             #endif 
....................              
....................             #if defined(STACK_USE_UDP) 
....................             if(cIPFrameType == IP_PROT_UDP) 
....................             { 
....................                // Stop processing packets if we came upon a UDP frame with application data in it 
....................                if(UDPProcess(&remoteNode, &tempLocalIP, dataCount)) 
....................                   return; 
....................             } 
....................             #endif 
....................  
....................             break; 
05B52:  MOVLB  0
....................       } 
05B54:  BRA    5A24
....................    } 
05B56:  GOTO   9200 (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackApplications(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Calls all loaded application modules. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called periodically to 
....................  *                  ensure timely responses. 
....................  * 
....................  ********************************************************************/ 
.................... void StackApplications(void) 
.................... { 
....................    #if defined(STACK_USE_HTTP2_SERVER) 
....................    HTTPServer(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_FTP_SERVER) && defined(STACK_USE_MPFS2) 
....................    FTPServer(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_SNMP_SERVER) 
....................    SNMPTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_ANNOUNCE) 
....................    DiscoveryTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_NBNS) 
....................    NBNSTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_DHCP_SERVER) 
....................    DHCPServerTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_DNS_SERVER) 
....................    DNSServerTask(); 
....................    #endif 
....................     
....................    #if defined (STACK_USE_DYNAMICDNS_CLIENT) 
....................    DDNSTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_TELNET_SERVER) 
....................    TelnetTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_REBOOT_SERVER) 
....................    RebootTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_SNTP_CLIENT) 
....................    SNTPClient(); 
....................    #endif 
....................  
....................    #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
....................    UDPPerformanceTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
....................    TCPPerformanceTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_SMTP_CLIENT) 
....................    SMTPTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_UART2TCP_BRIDGE) 
....................    UART2TCPBridgeTask(); 
....................    #endif 
....................  
....................    #if defined(STACK_USE_CCS_SMTP) 
....................    SMTPTask(); 
....................    #endif    
....................  
....................    #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    NTPTask(); 
....................    #endif 
....................  
....................    #if defined(STACK_USE_CCS_HTTP1_SERVER) || defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    HTTPServer(); 
*
0908A:  GOTO   842E
....................    #endif 
....................     
....................    #if defined(STACK_USE_CCS_TFTP_SERVER) 
....................    TFTPSTask(); 
....................    #endif 
....................  
....................    #if defined(STACK_USE_TWITTER)   //should be renamed STACK_USE_CCS_TWITTER 
0908E:  GOTO   9206 (RETURN)
....................    TwitterTask();         // processes TCP tasks including the Tweet tasks 
....................    #endif    
.................... } 
....................  
.................... #if defined(WF_CS_TRIS) && defined(STACK_USE_DHCP_CLIENT) 
.................... void RenewDhcp(void) 
.................... { 
....................     g_DhcpRenew = TRUE; 
....................     SetDhcpProgressState(); 
.................... }     
....................      
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "Helpers.c" 
.................... /********************************************************************* 
....................   
....................  Helper Functions for Microchip TCPIP Stack 
....................   
....................  FileName:      Helpers.c 
....................  Dependencies:  See INCLUDES section 
....................  Processor:     PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:      Microchip C18, C30, C32 
....................  Company:       Microchip Technology, Inc. 
....................  
....................  Software License Agreement 
....................  
....................  Copyright (C) 2002-2011 Microchip Technology Inc.  All rights 
....................  reserved. 
....................  
....................  Microchip licenses to you the right to use, modify, copy, and 
....................  distribute: 
....................  (i)  the Software when embedded on a Microchip microcontroller or 
....................       digital signal controller product ("Device") which is 
....................       integrated into Licensee's product; or 
....................  (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................       ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................       used in conjunction with a Microchip ethernet controller for 
....................       the sole purpose of interfacing with the ethernet controller. 
....................  
....................  You should refer to the license agreement accompanying this 
....................  Software for additional information regarding your rights and 
....................  obligations. 
....................  
....................  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  
....................  ******************************************************************** 
....................  File Description: 
....................   
....................  Change History: 
....................   
....................   Rev         Description 
....................   ----------  ------------------------------------------------------- 
....................   1.0 - 5.31  Initial release; Rewritten CalcIPChecksum() to avoid 
....................               multi-byte shift operation; Added hexatob(), 
....................               btohexa_high(), and btohexa_low(); Optimized swapl(); 
....................               Added leftRotateDWORD() 
....................   5.36        Updated compile time check for ultoa(); 
....................  
....................    DARREN ROOK/CCS   Remove leftRotateDWORD() 
....................  
....................  ********************************************************************/ 
.................... #define __HELPERS_C 
....................  
.................... #include <stdarg.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDARG 
....................  
.................... #define _STDARG 
....................  
.................... typedef char * va_list; 
....................  
.................... #define va_start(a,b)  a=_VA_LIST 
.................... #define va_arg(a,b)    *(b *)_va_arg(a) 
.................... #define va_end 
.................... #define nargs          _nargs(&_va_list) 
....................  
.................... int8 _nargs(int8 * ptr) { 
....................   int8 n; 
....................  
....................   n=0; 
....................   while(*ptr) { 
....................     n++; 
....................     ptr+=*ptr; 
....................   } 
....................   return(n); 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
....................  
.................... // Default Random Number Generator seed. 0x41FE9F9E corresponds to calling LFSRSeedRand(1) 
.................... static DWORD dwLFSRRandSeed = 0x41FE9F9E; 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    DWORD LFSRSeedRand(DWORD dwSeed) 
....................  
....................   Summary: 
....................    Seeds the LFSR random number generator invoked by the LFSRRand() function.   
....................    The prior seed is returned. 
....................  
....................   Description: 
....................    Seeds the LFSR random number generator invoked by the LFSRRand() function.   
....................    The prior seed is returned. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    wSeed - The new 32-bit seed value to assign to the LFSR. 
....................  
....................   Returns: 
....................      The last seed in use.  This can be saved and restored by a subsequent call  
....................    to LFSRSeedRand() if you wish to use LFSRRand() in multiple contexts  
....................    without disrupting the random number sequence from the alternative  
....................    context.  For example, if App 1 needs a given sequence of random numbers  
....................    to perform a test, if you save and restore the seed in App 2, it is  
....................    possible for App 2 to not disrupt the random number sequence provided to  
....................    App 1, even if the number of times App 2 calls LFSRRand() varies. 
....................       
....................   Side Effects: 
....................    None 
....................     
....................   Remarks: 
....................    Upon initial power up, the internal seed is initialized to 0x1.  Using a  
....................    dwSeed value of 0x0 will return the same sequence of random numbers as  
....................    using the seed of 0x1. 
....................   ***************************************************************************/ 
.................... DWORD LFSRSeedRand(DWORD dwSeed) 
.................... { 
....................    DWORD dwOldSeed; 
....................    BYTE i; 
....................  
....................    // Save original seed to be returned later 
....................    dwOldSeed = dwLFSRRandSeed; 
*
00692:  MOVFF  6B,30B
00696:  MOVFF  6A,30A
0069A:  MOVFF  69,309
0069E:  MOVFF  68,308
....................  
....................    // Ensure zero isn't selected as a seed value, this would result in all  
....................    // 0x0000 output values from the LFSR 
....................    if(dwSeed == 0u) 
006A2:  MOVLB  3
006A4:  MOVF   x04,F
006A6:  BNZ   06BE
006A8:  MOVF   x05,F
006AA:  BNZ   06BE
006AC:  MOVF   x06,F
006AE:  BNZ   06BE
006B0:  MOVF   x07,F
006B2:  BNZ   06BE
....................       dwSeed = 1; 
006B4:  CLRF   x07
006B6:  CLRF   x06
006B8:  CLRF   x05
006BA:  MOVLW  01
006BC:  MOVWF  x04
....................        
....................    // Set the new seed 
....................    dwLFSRRandSeed = dwSeed; 
006BE:  MOVFF  307,6B
006C2:  MOVFF  306,6A
006C6:  MOVFF  305,69
006CA:  MOVFF  304,68
....................     
....................    // Run the LFSR a few times to get rid of obvious start up artifacts for  
....................    // seed values that don't have many set bits. 
....................    for(i = 0; i < 16; i++) 
006CE:  CLRF   x0C
006D0:  MOVF   x0C,W
006D2:  SUBLW  0F
006D4:  BNC   06E0
....................       LFSRRand(); 
006D6:  MOVLB  0
006D8:  RCALL  0618
006DA:  MOVLB  3
006DC:  INCF   x0C,F
006DE:  BRA    06D0
....................     
....................    // Return saved old seed 
....................    return dwOldSeed; 
006E0:  MOVFF  308,00
006E4:  MOVFF  309,01
006E8:  MOVFF  30A,02
006EC:  MOVFF  30B,03
006F0:  MOVLB  0
006F2:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD LFSRRand(void) 
....................  
....................   Summary: 
....................    Returns a pseudo-random 16-bit unsigned integer in the range from 0  
....................    to 65535 (0x0000 to 0xFFFF). 
....................  
....................   Description: 
....................    Returns a pseudo-random 16-bit unsigned integer in the range from 0  
....................    to 65535 (0x0000 to 0xFFFF).  The random number is generated using a  
....................    Linear Feedback Shift Register (LFSR) type pseudo-random number generator  
....................    algorithm.  The LFSR can be seeded by calling the LFSRSeedRand() function 
....................    to generate the same sequence of random numbers as a prior string of calls. 
....................     
....................    The internal LFSR will repeat after 2^32-1 iterations. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................      Random 16-bit unsigned integer. 
....................       
....................   Side Effects: 
....................    The internal LFSR seed is updated so that the next call to LFSRRand()  
....................    will return a different random number. 
....................     
....................   Remarks: 
....................    None 
....................   ***************************************************************************/ 
.................... WORD LFSRRand(void) 
.................... { 
....................    BYTE i; 
....................     
....................    // Taps: 32 31 29 1 
....................    // Characteristic polynomial: x^32 + x^31 + x^29 + x + 1 
....................    // Repeat 15 times to make the shift pattern less obvious 
....................    for(i = 0; i < 15; i++) 
*
00618:  MOVLB  3
0061A:  CLRF   x3A
0061C:  MOVF   x3A,W
0061E:  SUBLW  0E
00620:  BNC   0686
....................       dwLFSRRandSeed = (dwLFSRRandSeed >> 1) ^ ((0ul - (dwLFSRRandSeed & 1ul)) & 0xD0000001ul); 
00622:  BCF    FD8.0
00624:  RRCF   6B,W
00626:  MOVWF  x3F
00628:  RRCF   6A,W
0062A:  MOVWF  x3E
0062C:  RRCF   69,W
0062E:  MOVWF  x3D
00630:  RRCF   68,W
00632:  MOVWF  x3C
00634:  MOVF   68,W
00636:  ANDLW  01
00638:  MOVWF  00
0063A:  CLRF   01
0063C:  CLRF   02
0063E:  CLRF   03
00640:  MOVLW  00
00642:  BSF    FD8.0
00644:  SUBFWB 00,W
00646:  MOVWF  x40
00648:  MOVLW  00
0064A:  SUBFWB 01,W
0064C:  MOVWF  x41
0064E:  MOVLW  00
00650:  SUBFWB 02,W
00652:  MOVWF  x42
00654:  MOVLW  00
00656:  SUBFWB 03,W
00658:  MOVWF  x43
0065A:  MOVF   x40,W
0065C:  ANDLW  01
0065E:  MOVWF  00
00660:  CLRF   01
00662:  CLRF   02
00664:  MOVF   x43,W
00666:  ANDLW  D0
00668:  MOVWF  03
0066A:  MOVF   00,W
0066C:  XORWF  x3C,W
0066E:  MOVWF  68
00670:  MOVF   01,W
00672:  XORWF  x3D,W
00674:  MOVWF  69
00676:  MOVF   02,W
00678:  XORWF  x3E,W
0067A:  MOVWF  6A
0067C:  MOVF   03,W
0067E:  XORWF  x3F,W
00680:  MOVWF  6B
00682:  INCF   x3A,F
00684:  BRA    061C
....................  
....................    // Return 16-bits as pseudo-random number 
....................    return (WORD)dwLFSRRandSeed; 
00686:  MOVFF  68,01
0068A:  MOVFF  69,02
0068E:  MOVLB  0
00690:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    DWORD GenerateRandomDWORD(void) 
....................  
....................   Summary: 
....................    Generates a random DWORD. 
....................  
....................   Description: 
....................    This function generates a random 32-bit integer.  It collects 
....................    randomness by comparing the A/D converter's internal R/C oscillator 
....................    clock with our main system clock.  By passing collected entropy to the 
....................    LFSRSeedRand()/LFSRRand() functions, the output is normalized (deskewed)  
....................    in the hopes of meeting statistical randomness tests. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................      Random 32-bit number. 
....................       
....................   Side Effects: 
....................    This function uses the A/D converter (and so you must disable  
....................    interrupts if you use the A/D converted in your ISR).  The LFSRRand()  
....................    function will be reseeded, and Timer0 (PIC18) and Timer1 (PIC24,  
....................    dsPIC, and PIC32) will be used.  TMR#H:TMR#L will have a new value. 
....................    Note that this is the same timer used by the Tick module. 
....................     
....................   Remarks: 
....................    This function times out after 1 second of attempting to generate the  
....................    random DWORD.  In such a case, the output may not be truly random.   
....................    Typically, this function executes in around 500,000 instruction cycles. 
....................     
....................    The intent of this function is to produce statistically random and 
....................    cryptographically secure random number.  Whether or not this is true on 
....................    all (or any) devices/voltages/temperatures is not tested. 
....................   ***************************************************************************/ 
.................... DWORD GenerateRandomDWORD(void) 
.................... { 
....................    BYTE vBitCount; 
....................    WORD w, wTime, wLastValue; 
....................    DWORD dwTotalTime; 
....................    union 
....................    { 
....................       DWORD   dw; 
....................       WORD   w[2]; 
....................    } randomResult; 
....................  
.................... #if defined __18CXX    
.................... { 
....................    BYTE ADCON0Save, ADCON2Save; 
....................    BYTE T0CONSave, TMR0HSave, TMR0LSave; 
....................  
....................    // Save hardware SFRs 
....................    ADCON0Save = ADCON0; 
*
006F4:  MOVFF  FC2,2FD
....................    ADCON2Save = ADCON2; 
006F8:  MOVFF  FC0,2FE
....................    T0CONSave = T0CON; 
006FC:  MOVFF  FD5,2FF
....................    TMR0LSave = TMR0L; 
00700:  MOVFF  FD6,301
....................    TMR0HSave = TMR0H; 
00704:  MOVFF  FD7,300
....................  
....................    // Set up Timer and A/D converter module 
....................    ADCON0 = 0x01;   // Turn on the A/D module 
00708:  MOVLW  01
0070A:  MOVWF  FC2
....................    ADCON2 = 0x3F;   // 20 Tad acquisition, Frc A/D clock used for conversion 
0070C:  MOVLW  3F
0070E:  MOVWF  FC0
....................    T0CON = 0x88;   // TMR0ON = 1, no prescalar 
00710:  MOVLW  88
00712:  MOVWF  FD5
....................    vBitCount = 0; 
00714:  MOVLB  2
00716:  CLRF   xEE
....................    dwTotalTime = 0; 
00718:  CLRF   xF8
0071A:  CLRF   xF7
0071C:  CLRF   xF6
0071E:  CLRF   xF5
....................    wLastValue = 0; 
00720:  CLRF   xF4
00722:  CLRF   xF3
....................    randomResult.dw = LFSRRand(); 
00724:  MOVLB  0
00726:  RCALL  0618
00728:  MOVLB  2
0072A:  CLRF   xFC
0072C:  CLRF   xFB
0072E:  MOVFF  02,2FA
00732:  MOVFF  01,2F9
....................    while(1) 
....................    { 
....................       // Time the duration of an A/D acquisition and conversion 
....................       TMR0H = 0x00; 
00736:  CLRF   FD7
....................       TMR0L = 0x00; 
00738:  CLRF   FD6
....................       ADCON0bits.GO = 1; 
0073A:  BSF    FC2.1
....................       ClrWdt(); 
0073C:  CLRWDT
....................       while(ADCON0bits.GO); 
0073E:  BTFSC  FC2.1
00740:  BRA    073E
....................       ((BYTE*)&wTime)[0] = TMR0L; 
00742:  MOVFF  FD6,2F1
....................       ((BYTE*)&wTime)[1] = TMR0H; 
00746:  MOVFF  FD7,2F2
....................       w = LFSRRand(); 
0074A:  MOVLB  0
0074C:  RCALL  0618
0074E:  MOVFF  02,2F0
00752:  MOVFF  01,2EF
....................     
....................       // Wait no longer than 1 second obtaining entropy 
....................       dwTotalTime += wTime; 
00756:  MOVLB  2
00758:  MOVF   xF1,W
0075A:  ADDWF  xF5,F
0075C:  MOVF   xF2,W
0075E:  ADDWFC xF6,F
00760:  MOVLW  00
00762:  ADDWFC xF7,F
00764:  ADDWFC xF8,F
....................       if(dwTotalTime >= GetInstructionClock()) 
00766:  MOVF   xF8,F
00768:  BNZ   0784
0076A:  MOVF   xF7,W
0076C:  SUBLW  97
0076E:  BC    07A2
00770:  XORLW  FF
00772:  BNZ   0784
00774:  MOVF   xF6,W
00776:  SUBLW  95
00778:  BC    07A2
0077A:  XORLW  FF
0077C:  BNZ   0784
0077E:  MOVF   xF5,W
00780:  SUBLW  7F
00782:  BC    07A2
....................       { 
....................          randomResult.w[0] ^= LFSRRand(); 
00784:  MOVLB  0
00786:  RCALL  0618
00788:  MOVF   01,W
0078A:  MOVLB  2
0078C:  XORWF  xF9,F
0078E:  MOVF   02,W
00790:  XORWF  xFA,F
....................          randomResult.w[1] ^= LFSRRand(); 
00792:  MOVLB  0
00794:  RCALL  0618
00796:  MOVF   01,W
00798:  MOVLB  2
0079A:  XORWF  xFB,F
0079C:  MOVF   02,W
0079E:  XORWF  xFC,F
....................          break; 
007A0:  BRA    081C
....................       } 
....................     
....................       // Keep sampling if minimal entropy was likely obtained this round 
....................       if(wLastValue == wTime) 
007A2:  MOVF   xF1,W
007A4:  SUBWF  xF3,W
007A6:  BNZ   07B0
007A8:  MOVF   xF2,W
007AA:  SUBWF  xF4,W
007AC:  BNZ   07B0
....................          continue; 
007AE:  BRA    0736
....................     
....................       // Add this entropy into the pseudo random number generator by reseeding 
....................       LFSRSeedRand(w + (wLastValue - wTime)); 
007B0:  MOVF   xF1,W
007B2:  SUBWF  xF3,W
007B4:  MOVWF  00
007B6:  MOVF   xF2,W
007B8:  SUBWFB xF4,W
007BA:  MOVWF  03
007BC:  MOVF   00,W
007BE:  ADDWF  xEF,W
007C0:  MOVLB  3
007C2:  MOVWF  x02
007C4:  MOVF   03,W
007C6:  MOVLB  2
007C8:  ADDWFC xF0,W
007CA:  MOVLB  3
007CC:  MOVWF  x03
007CE:  CLRF   x07
007D0:  CLRF   x06
007D2:  MOVWF  x05
007D4:  MOVFF  302,304
007D8:  MOVLB  0
007DA:  RCALL  0692
....................       wLastValue = wTime; 
007DC:  MOVFF  2F2,2F4
007E0:  MOVFF  2F1,2F3
....................     
....................       // Accumulate at least 32 bits of randomness over time 
....................       randomResult.dw <<= 1; 
007E4:  BCF    FD8.0
007E6:  MOVLB  2
007E8:  RLCF   xF9,F
007EA:  RLCF   xFA,F
007EC:  RLCF   xFB,F
007EE:  RLCF   xFC,F
....................       if(LFSRRand() & 0x0080) 
007F0:  MOVLB  0
007F2:  RCALL  0618
007F4:  MOVFF  02,303
007F8:  MOVFF  01,302
007FC:  MOVLB  3
007FE:  MOVF   01,W
00800:  ANDLW  80
00802:  MOVWF  00
00804:  CLRF   03
00806:  MOVF   00,W
00808:  IORWF  03,W
0080A:  BZ    0812
....................          randomResult.w[0] |= 0x1; 
0080C:  MOVLB  2
0080E:  BSF    xF9.0
00810:  MOVLB  3
....................     
....................       // See if we've collected a fair amount of entropy and can quit early 
....................       if(++vBitCount == 0u) 
00812:  MOVLB  2
00814:  INCF   xEE,F
00816:  BNZ   081A
....................          break; 
00818:  BRA    081C
0081A:  BRA    0736
....................    } 
....................  
....................    // Restore hardware SFRs 
....................    ADCON0 = ADCON0Save; 
0081C:  MOVFF  2FD,FC2
....................    ADCON2 = ADCON2Save; 
00820:  MOVFF  2FE,FC0
....................    TMR0H = TMR0HSave; 
00824:  MOVFF  300,FD7
....................    TMR0L = TMR0LSave; 
00828:  MOVFF  301,FD6
....................    T0CON = T0CONSave; 
0082C:  MOVFF  2FF,FD5
.................... } 
.................... #else 
.................... { 
....................    WORD AD1CON1Save, AD1CON2Save, AD1CON3Save; 
....................    WORD T1CONSave, PR1Save; 
....................  
....................    // Save hardware SFRs 
....................    AD1CON1Save = AD1CON1; 
....................    AD1CON2Save = AD1CON2; 
....................    AD1CON3Save = AD1CON3; 
....................    T1CONSave = T1CON; 
....................    PR1Save = PR1; 
....................  
....................    // Set up Timer and A/D converter module 
....................    AD1CON1 = 0x0000;      // Turn off the ADC so we can write to it 
....................    AD1CON3 = 0x9F00;      // Frc A/D clock, 31 Tad acquisition 
....................    AD1CON2 = 0x003F;      // Interrupt after every 16th sample/convert 
....................    AD1CON1 = 0x80E4;      // Turn on the A/D module, auto-convert 
....................    T1CON = 0x8000;         // TON = 1, no prescalar 
....................    PR1 = 0xFFFF;         // Don't clear timer early 
....................    vBitCount = 0; 
....................    dwTotalTime = 0; 
....................    wLastValue = 0; 
....................    randomResult.dw = LFSRRand(); 
....................    while(1) 
....................    { 
....................       ClrWdt(); 
....................       #if defined(__C30__) 
....................          while(!IFS0bits.AD1IF); 
....................       #else 
....................          while(!IFS1bits.AD1IF); 
....................       #endif 
....................       wTime = TMR1; 
....................       TMR1 = 0x0000; 
....................  
....................       #if defined(__C30__) 
....................          IFS0bits.AD1IF = 0; 
....................       #else 
....................          IFS1CLR = _IFS1_AD1IF_MASK; 
....................       #endif 
....................       w = LFSRRand(); 
....................     
....................       // Wait no longer than 1 second obtaining entropy 
....................       dwTotalTime += wTime; 
....................       if(dwTotalTime >= GetInstructionClock()) 
....................       { 
....................          randomResult.w[0] ^= LFSRRand(); 
....................          randomResult.w[1] ^= LFSRRand(); 
....................          break; 
....................       } 
....................     
....................       // Keep sampling if minimal entropy was likely obtained this round 
....................       if(wLastValue == wTime) 
....................          continue; 
....................     
....................       // Add this entropy into the pseudo random number generator by reseeding 
....................       LFSRSeedRand(w + (wLastValue - wTime)); 
....................       wLastValue = wTime; 
....................     
....................       // Accumulate at least 32 bits of randomness over time 
....................       randomResult.dw <<= 1; 
....................       if(LFSRRand() & 0x0080) 
....................          randomResult.w[0] |= 0x1; 
....................     
....................       // See if we've collected a fair amount of entropy and can quit early 
....................       if(++vBitCount == 0u) 
....................          break; 
....................    } 
....................  
....................  
....................    // Restore hardware SFRs 
....................    AD1CON1 = 0x0000;      // Turn off the ADC so we can write to it 
....................    AD1CON3 = AD1CON3Save; 
....................    AD1CON2 = AD1CON2Save; 
....................    AD1CON1 = AD1CON1Save; 
....................    T1CON = T1CONSave; 
....................    PR1 = PR1Save; 
.................... } 
.................... #endif 
....................  
....................    return randomResult.dw; 
00830:  MOVFF  2F9,00
00834:  MOVFF  2FA,01
00838:  MOVFF  2FB,02
0083C:  MOVFF  2FC,03
00840:  MOVLB  0
00842:  RETURN 0
.................... } 
....................  
....................  
.................... #if defined(STACK_USE_HTTP_SERVER) 
.................... /***************************************************************************** 
....................   Function: 
....................    void UnencodeURL(BYTE* URL) 
....................  
....................   Summary: 
....................    Decodes a URL-encoded string. 
....................  
....................   Description: 
....................    This function is deprecated except for use with HTTP Classic.  It 
....................    attempts to decode a URL encoded string, converting all hex escape 
....................    sequences into a literal byte.  However, it is inefficient over long 
....................    strings and does not handle URL-encoded data strings ('&' and '='). 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    URL - the null-terminated string to decode 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... void UnencodeURL(BYTE* URL) 
.................... { 
....................    BYTE *Right, *Copy; 
....................    WORD_VAL Number; 
....................  
....................    while((Right = (BYTE*)strchr((char*)URL, '%'))) 
....................    { 
....................       // Make sure the string is long enough 
....................       if(Right[1] == '\0') 
....................          break; 
....................       if(Right[2] == '\0') 
....................          break; 
....................  
....................       // Update the string in place 
....................       Number.v[0] = Right[2]; 
....................       Number.v[1] = Right[1]; 
....................       *Right++ = hexatob(Number); 
....................       URL = Right; 
....................  
....................       // Remove two blank spots by shifting all remaining characters right two 
....................       Copy = Right + 2; 
....................       while((*Right++ = *Copy++)); 
....................    } 
.................... }           
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL StringToIPAddress(BYTE* str, IP_ADDR* IPAddress) 
....................  
....................   Summary: 
....................    Converts a string to an IP address 
....................  
....................   Description: 
....................    This function parses a dotted-quad decimal IP address string into an  
....................    IP_ADDR struct.  The output result is big-endian. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    str - Pointer to a dotted-quad IP address string 
....................    IPAddress - Pointer to IP_ADDR in which to store the result 
....................  
....................   Return Values: 
....................      TRUE - an IP address was successfully decoded 
....................      FALSE - no IP address could be found, or the format was incorrect 
....................   ***************************************************************************/ 
.................... BOOL StringToIPAddress(BYTE* str, IP_ADDR* IPAddress) 
.................... { 
....................    DWORD_VAL dwVal; 
....................    BYTE i, charLen, currentOctet; 
....................  
....................    charLen = 0; 
....................    currentOctet = 0; 
....................    dwVal.Val = 0; 
....................    while((i = *str++)) 
....................    { 
....................       if(currentOctet > 3u) 
....................          break; 
....................  
....................       i -= '0'; 
....................        
....................  
....................       // Validate the character is a numerical digit or dot, depending on location 
....................       if(charLen == 0u) 
....................       { 
....................          if(i > 9u) 
....................             return FALSE; 
....................       } 
....................       else if(charLen == 3u) 
....................       { 
....................          if(i != (BYTE)('.' - '0')) 
....................             return FALSE; 
....................  
....................          if(dwVal.Val > 0x00020505ul) 
....................             return FALSE; 
....................  
....................          IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................          charLen = 0; 
....................          dwVal.Val = 0; 
....................          continue; 
....................       } 
....................       else 
....................       { 
....................          if(i == (BYTE)('.' - '0')) 
....................          { 
....................             if(dwVal.Val > 0x00020505ul) 
....................                return FALSE; 
....................  
....................             IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................             charLen = 0; 
....................             dwVal.Val = 0; 
....................             continue; 
....................          } 
....................          if(i > 9u) 
....................             return FALSE; 
....................       } 
....................  
....................       charLen++; 
....................       dwVal.Val <<= 8; 
....................       dwVal.v[0] = i; 
....................    } 
....................  
....................    // Make sure the very last character is a valid termination character  
....................    // (i.e., not more hostname, which could be legal and not an IP  
....................    // address as in "10.5.13.233.picsaregood.com" 
....................    if(i != 0u && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t' && i != ':') 
....................       return FALSE; 
....................  
....................    // Verify and convert the last octet and return the result 
....................    if(dwVal.Val > 0x00020505ul) 
....................       return FALSE; 
....................  
....................    IPAddress->v[3] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................  
....................    return TRUE; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL ROMStringToIPAddress(ROM BYTE* str, IP_ADDR* IPAddress) 
....................  
....................   Summary: 
....................    Converts a string to an IP address 
....................  
....................   Description: 
....................    This function parses a dotted-quad decimal IP address string into an  
....................    IP_ADDR struct.  The output result is big-endian. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    str - Pointer to a dotted-quad IP address string 
....................    IPAddress - Pointer to IP_ADDR in which to store the result 
....................  
....................   Return Values: 
....................      TRUE - an IP address was successfully decoded 
....................      FALSE - no IP address could be found, or the format was incorrect 
....................    
....................   Remarks: 
....................    This function is aliased to StringToIPAddress on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... BOOL ROMStringToIPAddress(ROM BYTE* str, IP_ADDR* IPAddress) 
.................... { 
....................    DWORD_VAL dwVal; 
....................    BYTE i, charLen, currentOctet; 
....................  
....................    charLen = 0; 
....................    currentOctet = 0; 
....................    dwVal.Val = 0; 
....................    while(i = *str++) 
....................    { 
....................       if(currentOctet > 3u) 
....................          break; 
....................  
....................       i -= '0'; 
....................        
....................  
....................       // Validate the character is a numerical digit or dot, depending on location 
....................       if(charLen == 0u) 
....................       { 
....................          if(i > 9u) 
....................             return FALSE; 
....................       } 
....................       else if(charLen == 3u) 
....................       { 
....................          if(i != (BYTE)('.' - '0')) 
....................             return FALSE; 
....................  
....................          if(dwVal.Val > 0x00020505ul) 
....................             return FALSE; 
....................  
....................          IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................          charLen = 0; 
....................          dwVal.Val = 0; 
....................          continue; 
....................       } 
....................       else 
....................       { 
....................          if(i == (BYTE)('.' - '0')) 
....................          { 
....................             if(dwVal.Val > 0x00020505ul) 
....................                return FALSE; 
....................  
....................             IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................             charLen = 0; 
....................             dwVal.Val = 0; 
....................             continue; 
....................          } 
....................          if(i > 9u) 
....................             return FALSE; 
....................       } 
....................  
....................       charLen++; 
....................       dwVal.Val <<= 8; 
....................       dwVal.v[0] = i; 
....................    } 
....................  
....................    // Make sure the very last character is a valid termination character  
....................    // (i.e., not more hostname, which could be legal and not an IP  
....................    // address as in "10.5.13.233.picsaregood.com" 
....................    if(i != 0u && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t') 
....................       return FALSE; 
....................  
....................    // Verify and convert the last octet and return the result 
....................    if(dwVal.Val > 0x00020505ul) 
....................       return FALSE; 
....................  
....................    IPAddress->v[3] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................  
....................    return TRUE; 
.................... } 
.................... #endif 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD Base64Decode(BYTE* cSourceData, WORD wSourceLen,  
....................                   BYTE* cDestData, WORD wDestLen) 
....................  
....................   Description: 
....................    Decodes a Base-64 array to its literal representation. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    cSourceData - Pointer to a string of Base-64 encoded data 
....................    wSourceLen   - Length of the Base-64 source data 
....................    cDestData   - Pointer to write the decoded data 
....................    wSourceLen   - Maximum length that can be written to cDestData 
....................  
....................   Returns: 
....................      Number of decoded bytes written to cDestData. 
....................    
....................   Remarks: 
....................    This function is binary safe and will ignore invalid characters (CR, LF,  
....................    etc).  If cSourceData is equal to cDestData, the data will be converted 
....................    in-place.  If cSourceData is not equal to cDestData, but the regions  
....................    overlap, the behavior is undefined. 
....................     
....................    Decoded data is always at least 1/4 smaller than the source data. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_BASE64_DECODE) 
.................... WORD Base64Decode(BYTE* cSourceData, WORD wSourceLen, BYTE* cDestData, WORD wDestLen) 
.................... { 
....................    BYTE i; 
....................    BYTE vByteNumber; 
....................    WORD wBytesOutput; 
....................  
....................    vByteNumber = 0; 
....................    wBytesOutput = 0; 
....................  
....................    // Loop over all provided bytes 
....................    while(wSourceLen--) 
....................    { 
....................       // Fetch a Base64 byte and decode it to the original 6 bits 
....................       i = *cSourceData++; 
....................       if(i >= 'A' && i <= 'Z')   // Regular data 
....................          i -= 'A' - 0; 
....................       else if(i >= 'a' && i <= 'z') 
....................          i -= 'a' - 26; 
....................       else if(i >= '0' && i <= '9') 
....................          i -= '0' - 52; 
....................       else if(i == '+' || i == '-') 
....................          i = 62; 
....................       else if(i == '/' || i == '_') 
....................          i = 63; 
....................       else                   // Skip all padding (=) and non-Base64 characters 
....................          continue; 
....................  
....................  
....................       // Write the 6 bits to the correct destination location(s) 
....................       if(vByteNumber == 0u) 
....................       { 
....................          vByteNumber++; 
....................          if(wBytesOutput >= wDestLen) 
....................             break; 
....................          wBytesOutput++; 
....................          *cDestData = i << 2; 
....................       } 
....................       else if(vByteNumber == 1u) 
....................       { 
....................          vByteNumber++; 
....................          *cDestData++ |= i >> 4; 
....................          if(wBytesOutput >= wDestLen) 
....................             break; 
....................          wBytesOutput++; 
....................          *cDestData = i << 4; 
....................       } 
....................       else if(vByteNumber == 2u) 
....................       { 
....................          vByteNumber++; 
....................          *cDestData++ |= i >> 2; 
....................          if(wBytesOutput >= wDestLen) 
....................             break; 
....................          wBytesOutput++; 
....................          *cDestData = i << 6; 
....................       } 
....................       else 
....................       { 
....................          vByteNumber = 0; 
....................          *cDestData++ |= i; 
....................       } 
....................    } 
....................  
....................    return wBytesOutput; 
.................... } 
.................... #endif   // #if defined(STACK_USE_BASE64_DECODE) 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD Base64Encode(BYTE* cSourceData, WORD wSourceLen, 
....................                   BYTE* cDestData, WORD wDestLen) 
....................  
....................   Description: 
....................    Encodes a binary array to Base-64. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    cSourceData - Pointer to a string of binary data 
....................    wSourceLen   - Length of the binary source data 
....................    cDestData   - Pointer to write the Base-64 encoded data 
....................    wSourceLen   - Maximum length that can be written to cDestData 
....................  
....................   Returns: 
....................      Number of encoded bytes written to cDestData.  This will always be 
....................      a multiple of 4. 
....................    
....................   Remarks: 
....................    Encoding cannot be performed in-place.  If cSourceData overlaps with  
....................    cDestData, the behavior is undefined. 
....................     
....................    Encoded data is always at least 1/3 larger than the source data.  It may 
....................    be 1 or 2 bytes larger than that. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_BASE64_ENCODE) || defined(STACK_USE_SMTP_CLIENT) || defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... WORD Base64Encode(BYTE* cSourceData, WORD wSourceLen, BYTE* cDestData, WORD wDestLen) 
.................... { 
....................    BYTE i, j; 
....................    BYTE vOutput[4]; 
....................    WORD wOutputLen; 
....................  
....................    wOutputLen = 0; 
....................    while(wDestLen >= 4u) 
....................    { 
....................       // Start out treating the output as all padding 
....................       vOutput[0] = 0xFF; 
....................       vOutput[1] = 0xFF; 
....................       vOutput[2] = 0xFF; 
....................       vOutput[3] = 0xFF; 
....................  
....................       // Get 3 input octets and split them into 4 output hextets (6-bits each)  
....................       if(wSourceLen == 0u) 
....................          break; 
....................       i = *cSourceData++; 
....................       wSourceLen--; 
....................       vOutput[0] = (i & 0xFC)>>2; 
....................       vOutput[1] = (i & 0x03)<<4; 
....................       if(wSourceLen) 
....................       { 
....................          i = *cSourceData++; 
....................          wSourceLen--; 
....................          vOutput[1] |= (i & 0xF0)>>4; 
....................          vOutput[2] = (i & 0x0F)<<2; 
....................          if(wSourceLen) 
....................          { 
....................             i = *cSourceData++; 
....................             wSourceLen--; 
....................             vOutput[2] |= (i & 0xC0)>>6; 
....................             vOutput[3] = i & 0x3F; 
....................          } 
....................       } 
....................     
....................       // Convert hextets into Base 64 alphabet and store result 
....................       for(i = 0; i < 4u; i++) 
....................       { 
....................          j = vOutput[i]; 
....................  
....................          if(j <= 25u) 
....................             j += 'A' - 0; 
....................          else if(j <= 51u) 
....................             j += 'a' - 26; 
....................          else if(j <= 61u) 
....................             j += '0' - 52; 
....................          else if(j == 62u) 
....................             j = '+'; 
....................          else if(j == 63u) 
....................             j = '/'; 
....................          else            // Padding 
....................             j = '='; 
....................  
....................          *cDestData++ = j; 
....................       } 
....................  
....................       // Update counters 
....................       wDestLen -= 4; 
....................       wOutputLen += 4; 
....................    } 
....................  
....................    return wOutputLen; 
.................... } 
.................... #endif // #if defined(STACK_USE_BASE64_ENCODE) || defined(STACK_USE_SMTP) || defined(STACK_USE_DYNAMICDNS_CLIENT) 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void uitoa(WORD Value, BYTE* Buffer) 
....................  
....................   Summary: 
....................    Converts an unsigned integer to a decimal string. 
....................     
....................   Description: 
....................    Converts a 16-bit unsigned integer to a null-terminated decimal string. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    Value   - The number to be converted 
....................    Buffer   - Pointer in which to store the converted string 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... void uitoa(WORD Value, BYTE* Buffer) 
.................... { 
....................    BYTE i; 
....................    WORD Digit; 
....................    WORD Divisor; 
....................    BOOL Printed = FALSE; 
....................  
....................    if(Value) 
....................    { 
....................       for(i = 0, Divisor = 10000; i < 5u; i++) 
....................       { 
....................          Digit = Value/Divisor; 
....................          if(Digit || Printed) 
....................          { 
....................             *Buffer++ = '0' + Digit; 
....................             Value -= Digit*Divisor; 
....................             Printed = TRUE; 
....................          } 
....................          Divisor /= 10; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       *Buffer++ = '0'; 
....................    } 
....................  
....................    *Buffer = '\0'; 
.................... }              
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ultoa(DWORD Value, BYTE* Buffer) 
....................  
....................   Summary: 
....................    Converts an unsigned integer to a decimal string. 
....................     
....................   Description: 
....................    Converts a 32-bit unsigned integer to a null-terminated decimal string. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    Value   - The number to be converted 
....................    Buffer   - Pointer in which to store the converted string 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... // HI-TECH PICC-18 PRO 9.63, C30 v3.25, and C32 v1.12 already have a ultoa() library function 
.................... // C18 already has a ultoa() function that more-or-less matches this one 
.................... // C32 < 1.12 and C30 < v3.25 need this function 
.................... #if (defined(__PIC32MX__) && (__C32_VERSION__ < 112)) || (defined (__C30__) && (__C30_VERSION__ < 325)) || defined(__C30_LEGACY_LIBC__) || defined(__C32_LEGACY_LIBC__) 
.................... void ultoa(DWORD Value, BYTE* Buffer) 
.................... { 
....................    BYTE i; 
....................    DWORD Digit; 
....................    DWORD Divisor; 
....................    BOOL Printed = FALSE; 
....................  
....................    if(Value) 
....................    { 
....................       for(i = 0, Divisor = 1000000000; i < 10; i++) 
....................       { 
....................          Digit = Value/Divisor; 
....................          if(Digit || Printed) 
....................          { 
....................             *Buffer++ = '0' + Digit; 
....................             Value -= Digit*Divisor; 
....................             Printed = TRUE; 
....................          } 
....................          Divisor /= 10; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       *Buffer++ = '0'; 
....................    } 
....................  
....................    *Buffer = '\0'; 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE hexatob(WORD_VAL AsciiChars) 
....................  
....................   Summary: 
....................    Converts a hex string to a single byte. 
....................     
....................   Description: 
....................    Converts a two-character ASCII hex string to a single packed byte. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    AsciiChars - WORD_VAL where .v[0] is the ASCII value for the lower nibble 
....................                and .v[1] is the ASCII value for the upper nibble.  Each 
....................                must range from '0'-'9', 'A'-'F', or 'a'-'f'. 
....................  
....................   Returns: 
....................      Resulting packed byte 0x00 - 0xFF. 
....................   ***************************************************************************/ 
.................... BYTE hexatob(WORD_VAL AsciiChars) 
.................... { 
....................    // Convert lowercase to uppercase 
....................    if(AsciiChars.v[1] > 'F') 
....................       AsciiChars.v[1] -= 'a'-'A'; 
....................    if(AsciiChars.v[0] > 'F') 
....................       AsciiChars.v[0] -= 'a'-'A'; 
....................  
....................    // Convert 0-9, A-F to 0x0-0xF 
....................    if(AsciiChars.v[1] > '9') 
....................       AsciiChars.v[1] -= 'A' - 10; 
....................    else 
....................       AsciiChars.v[1] -= '0'; 
....................  
....................    if(AsciiChars.v[0] > '9') 
....................       AsciiChars.v[0] -= 'A' - 10; 
....................    else 
....................       AsciiChars.v[0] -= '0'; 
....................  
....................    // Concatenate 
....................    return (AsciiChars.v[1]<<4) |  AsciiChars.v[0]; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE btohexa_high(BYTE b) 
....................  
....................   Summary: 
....................    Converts the upper nibble of a binary value to a hexadecimal ASCII byte. 
....................  
....................   Description: 
....................    Converts the upper nibble of a binary value to a hexadecimal ASCII byte. 
....................    For example, btohexa_high(0xAE) will return 'A'. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    b - the byte to convert 
....................  
....................   Returns: 
....................      The upper hexadecimal ASCII byte '0'-'9' or 'A'-'F'. 
....................   ***************************************************************************/ 
.................... BYTE btohexa_high(BYTE b) 
.................... { 
....................    b >>= 4; 
....................    return (b>0x9u) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE btohexa_high(BYTE b) 
....................  
....................   Summary: 
....................    Converts the lower nibble of a binary value to a hexadecimal ASCII byte. 
....................  
....................   Description: 
....................    Converts the lower nibble of a binary value to a hexadecimal ASCII byte. 
....................    For example, btohexa_high(0xAE) will return 'E'. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    b - the byte to convert 
....................  
....................   Returns: 
....................      The lower hexadecimal ASCII byte '0'-'9' or 'A'-'F'. 
....................   ***************************************************************************/ 
.................... BYTE btohexa_low(BYTE b) 
.................... { 
....................    b &= 0x0F; 
....................    return (b>9u) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    signed char stricmppgm2ram(BYTE* a, ROM BYTE* b) 
....................  
....................   Summary: 
....................    Case-insensitive comparison of a string in RAM to a string in ROM. 
....................  
....................   Description: 
....................    Performs a case-insensitive comparison of a string in RAM to a string 
....................    in ROM.  This function performs identically to strcmppgm2ram, except that 
....................    the comparison is not case-sensitive. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    a - Pinter to tring in RAM 
....................    b - Pointer to string in ROM 
....................  
....................   Return Values: 
....................      \-1 - a < b 
....................      0   - a = b 
....................      1   - a > b 
....................   ***************************************************************************/ 
.................... signed char stricmppgm2ram(BYTE* a, ROM BYTE* b) 
.................... { 
....................    BYTE cA, cB; 
....................     
....................    // Load first two characters 
....................    cA = *a; 
....................    cB = *b; 
....................     
....................    // Loop until one string terminates 
....................    while(cA != '\0' && cB != '\0') 
....................    { 
....................       // Shift case if necessary 
....................       if(cA >= 'a' && cA <= 'z') 
....................          cA -= 'a' - 'A'; 
....................       if(cB >= 'a' && cB <= 'z') 
....................          cB -= 'a' - 'A'; 
....................           
....................       // Compare 
....................       if(cA > cB) 
....................          return 1; 
....................       if(cA < cB) 
....................          return -1; 
....................        
....................       // Characters matched, so continue 
....................       a++; 
....................       b++; 
....................       cA = *a; 
....................       cB = *b; 
....................    } 
....................     
....................    // See if one string terminated first 
....................    if(cA > cB) 
....................       return 1; 
....................    if(cA < cB) 
....................       return -1; 
....................        
....................    // Strings match 
....................    return 0; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD swaps(WORD v) 
....................  
....................   Description: 
....................    Swaps the endian-ness of a WORD. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    v - the WORD to swap 
....................  
....................   Returns: 
....................    The swapped version of v. 
....................   ***************************************************************************/ 
.................... WORD swaps(WORD v) 
.................... { 
....................    WORD_VAL t; 
....................    BYTE b; 
....................  
....................    t.Val   = v; 
*
01796:  MOVFF  380,382
0179A:  MOVFF  37F,381
....................    b       = t.v[1]; 
0179E:  MOVFF  382,383
....................    t.v[1]  = t.v[0]; 
017A2:  MOVFF  381,382
....................    t.v[0]  = b; 
017A6:  MOVFF  383,381
....................  
....................    return t.Val; 
017AA:  MOVLB  3
017AC:  MOVFF  381,01
017B0:  MOVFF  382,02
017B4:  MOVLB  0
017B6:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    DWORD swapl(DWORD v) 
....................  
....................   Description: 
....................    Swaps the endian-ness of a DWORD. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    v - the DWORD to swap 
....................  
....................   Returns: 
....................    The swapped version of v. 
....................   ***************************************************************************/ 
.................... #if defined(__C32__) 
.................... DWORD   __attribute__((nomips16)) swapl(DWORD v) 
.................... #else 
.................... DWORD swapl(DWORD v) 
.................... #endif 
.................... { 
....................    // Swap bytes 0 and 3 
....................    ((DWORD_VAL*)&v)->v[0] ^= ((DWORD_VAL*)&v)->v[3]; 
017B8:  MOVLW  03
017BA:  MOVLB  3
017BC:  MOVWF  x6D
017BE:  MOVLW  68
017C0:  MOVWF  01
017C2:  MOVFF  36D,FEA
017C6:  MOVWF  FE9
017C8:  MOVFF  FEF,370
017CC:  MOVLW  03
017CE:  MOVWF  x72
017D0:  MOVLW  68
017D2:  MOVWF  x71
017D4:  MOVLW  03
017D6:  ADDWF  x71,W
017D8:  MOVWF  FE9
017DA:  MOVLW  00
017DC:  ADDWFC x72,W
017DE:  MOVWF  FEA
017E0:  MOVF   FEF,W
017E2:  XORWF  x70,W
017E4:  MOVFF  36D,FEA
017E8:  MOVFF  01,FE9
017EC:  MOVWF  FEF
....................    ((DWORD_VAL*)&v)->v[3] ^= ((DWORD_VAL*)&v)->v[0]; 
017EE:  MOVLW  03
017F0:  MOVWF  x6D
017F2:  MOVLW  68
017F4:  MOVWF  x6C
017F6:  MOVLW  03
017F8:  ADDWF  x6C,W
017FA:  MOVWF  01
017FC:  MOVLW  00
017FE:  ADDWFC x6D,W
01800:  MOVWF  03
01802:  MOVWF  FEA
01804:  MOVFF  01,FE9
01808:  MOVFF  FEF,370
0180C:  MOVLW  03
0180E:  MOVWF  x72
01810:  MOVLW  68
01812:  MOVWF  FE9
01814:  MOVFF  372,FEA
01818:  MOVF   FEF,W
0181A:  XORWF  x70,W
0181C:  MOVFF  03,FEA
01820:  MOVFF  01,FE9
01824:  MOVWF  FEF
....................    ((DWORD_VAL*)&v)->v[0] ^= ((DWORD_VAL*)&v)->v[3]; 
01826:  MOVLW  03
01828:  MOVWF  x6D
0182A:  MOVLW  68
0182C:  MOVWF  01
0182E:  MOVFF  36D,FEA
01832:  MOVWF  FE9
01834:  MOVFF  FEF,370
01838:  MOVLW  03
0183A:  MOVWF  x72
0183C:  MOVLW  68
0183E:  MOVWF  x71
01840:  MOVLW  03
01842:  ADDWF  x71,W
01844:  MOVWF  FE9
01846:  MOVLW  00
01848:  ADDWFC x72,W
0184A:  MOVWF  FEA
0184C:  MOVF   FEF,W
0184E:  XORWF  x70,W
01850:  MOVFF  36D,FEA
01854:  MOVFF  01,FE9
01858:  MOVWF  FEF
....................  
....................    // Swap bytes 1 and 2 
....................    ((DWORD_VAL*)&v)->v[1] ^= ((DWORD_VAL*)&v)->v[2]; 
0185A:  MOVLW  03
0185C:  MOVWF  x6D
0185E:  MOVLW  68
01860:  MOVWF  x6C
01862:  MOVLW  01
01864:  ADDWF  x6C,W
01866:  MOVWF  01
01868:  MOVLW  00
0186A:  ADDWFC x6D,W
0186C:  MOVWF  03
0186E:  MOVWF  FEA
01870:  MOVFF  01,FE9
01874:  MOVFF  FEF,370
01878:  MOVLW  03
0187A:  MOVWF  x72
0187C:  MOVLW  68
0187E:  MOVWF  x71
01880:  MOVLW  02
01882:  ADDWF  x71,W
01884:  MOVWF  FE9
01886:  MOVLW  00
01888:  ADDWFC x72,W
0188A:  MOVWF  FEA
0188C:  MOVF   FEF,W
0188E:  XORWF  x70,W
01890:  MOVFF  03,FEA
01894:  MOVFF  01,FE9
01898:  MOVWF  FEF
....................    ((DWORD_VAL*)&v)->v[2] ^= ((DWORD_VAL*)&v)->v[1]; 
0189A:  MOVLW  03
0189C:  MOVWF  x6D
0189E:  MOVLW  68
018A0:  MOVWF  x6C
018A2:  MOVLW  02
018A4:  ADDWF  x6C,W
018A6:  MOVWF  01
018A8:  MOVLW  00
018AA:  ADDWFC x6D,W
018AC:  MOVWF  03
018AE:  MOVWF  FEA
018B0:  MOVFF  01,FE9
018B4:  MOVFF  FEF,370
018B8:  MOVLW  03
018BA:  MOVWF  x72
018BC:  MOVLW  68
018BE:  MOVWF  x71
018C0:  MOVLW  01
018C2:  ADDWF  x71,W
018C4:  MOVWF  FE9
018C6:  MOVLW  00
018C8:  ADDWFC x72,W
018CA:  MOVWF  FEA
018CC:  MOVF   FEF,W
018CE:  XORWF  x70,W
018D0:  MOVFF  03,FEA
018D4:  MOVFF  01,FE9
018D8:  MOVWF  FEF
....................    ((DWORD_VAL*)&v)->v[1] ^= ((DWORD_VAL*)&v)->v[2]; 
018DA:  MOVLW  03
018DC:  MOVWF  x6D
018DE:  MOVLW  68
018E0:  MOVWF  x6C
018E2:  MOVLW  01
018E4:  ADDWF  x6C,W
018E6:  MOVWF  01
018E8:  MOVLW  00
018EA:  ADDWFC x6D,W
018EC:  MOVWF  03
018EE:  MOVWF  FEA
018F0:  MOVFF  01,FE9
018F4:  MOVFF  FEF,370
018F8:  MOVLW  03
018FA:  MOVWF  x72
018FC:  MOVLW  68
018FE:  MOVWF  x71
01900:  MOVLW  02
01902:  ADDWF  x71,W
01904:  MOVWF  FE9
01906:  MOVLW  00
01908:  ADDWFC x72,W
0190A:  MOVWF  FEA
0190C:  MOVF   FEF,W
0190E:  XORWF  x70,W
01910:  MOVFF  03,FEA
01914:  MOVFF  01,FE9
01918:  MOVWF  FEF
....................  
....................    return v; 
0191A:  MOVFF  368,00
0191E:  MOVFF  369,01
01922:  MOVFF  36A,02
01926:  MOVFF  36B,03
0192A:  MOVLB  0
0192C:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD CalcIPChecksum(BYTE* buffer, WORD count) 
....................  
....................   Summary: 
....................    Calculates an IP checksum value. 
....................  
....................   Description: 
....................    This function calculates an IP checksum over an array of input data.  The 
....................    checksum is the 16-bit one's complement of one's complement sum of all  
....................    words in the data (with zero-padding if an odd number of bytes are  
....................    summed).  This checksum is defined in RFC 793. 
....................  
....................   Precondition: 
....................    buffer is WORD aligned (even memory address) on 16- and 32-bit PICs. 
....................  
....................   Parameters: 
....................    buffer - pointer to the data to be checksummed 
....................    count  - number of bytes to be checksummed 
....................  
....................   Returns: 
....................    The calculated checksum. 
....................     
....................   Internal: 
....................    This function could be improved to do 32-bit sums on PIC32 platforms. 
....................   ***************************************************************************/ 
.................... WORD CalcIPChecksum(BYTE* buffer, WORD count) 
.................... { 
....................    WORD i; 
....................    WORD *val; 
....................    union 
....................    { 
....................       WORD w[2]; 
....................       DWORD dw; 
....................    } sum; 
....................  
....................    i = count >> 1; 
*
01B4A:  BCF    FD8.0
01B4C:  MOVLB  3
01B4E:  RRCF   x7E,W
01B50:  MOVWF  x80
01B52:  RRCF   x7D,W
01B54:  MOVWF  x7F
....................    val = (WORD*)buffer; 
01B56:  MOVFF  37C,382
01B5A:  MOVFF  37B,381
....................  
....................    // Calculate the sum of all words 
....................    sum.dw = 0x00000000ul; 
01B5E:  CLRF   x86
01B60:  CLRF   x85
01B62:  CLRF   x84
01B64:  CLRF   x83
....................    while(i--) 
01B66:  MOVFF  380,03
01B6A:  MOVF   x7F,W
01B6C:  BTFSC  FD8.2
01B6E:  DECF   x80,F
01B70:  DECF   x7F,F
01B72:  IORWF  03,W
01B74:  BZ    1BB2
....................       sum.dw += (DWORD)*val++; 
01B76:  MOVFF  382,03
01B7A:  MOVFF  381,00
01B7E:  MOVLW  02
01B80:  ADDWF  x81,F
01B82:  BTFSC  FD8.0
01B84:  INCF   x82,F
01B86:  MOVFF  00,FE9
01B8A:  MOVFF  03,FEA
01B8E:  MOVFF  FEC,03
01B92:  MOVF   FED,F
01B94:  MOVFF  FEF,00
01B98:  MOVFF  03,01
01B9C:  CLRF   02
01B9E:  CLRF   03
01BA0:  MOVF   00,W
01BA2:  ADDWF  x83,F
01BA4:  MOVF   01,W
01BA6:  ADDWFC x84,F
01BA8:  MOVF   02,W
01BAA:  ADDWFC x85,F
01BAC:  MOVF   03,W
01BAE:  ADDWFC x86,F
01BB0:  BRA    1B66
....................  
....................    // Add in the sum of the remaining byte, if present 
....................    if(count & 0x1) 
01BB2:  MOVF   x7D,W
01BB4:  ANDLW  01
01BB6:  MOVWF  00
01BB8:  CLRF   03
01BBA:  MOVF   00,W
01BBC:  IORWF  03,W
01BBE:  BZ    1BE6
....................       sum.dw += (DWORD)*(BYTE*)val; 
01BC0:  MOVFF  382,03
01BC4:  MOVFF  381,FE9
01BC8:  MOVFF  382,FEA
01BCC:  MOVFF  FEF,00
01BD0:  CLRF   01
01BD2:  CLRF   02
01BD4:  CLRF   03
01BD6:  MOVF   00,W
01BD8:  ADDWF  x83,F
01BDA:  MOVF   01,W
01BDC:  ADDWFC x84,F
01BDE:  MOVF   02,W
01BE0:  ADDWFC x85,F
01BE2:  MOVF   03,W
01BE4:  ADDWFC x86,F
....................  
....................    // Do an end-around carry (one's complement arrithmatic) 
....................    sum.dw = (DWORD)sum.w[0] + (DWORD)sum.w[1]; 
01BE6:  CLRF   x8A
01BE8:  CLRF   x89
01BEA:  MOVFF  384,388
01BEE:  MOVFF  383,387
01BF2:  MOVFF  385,00
01BF6:  MOVFF  386,01
01BFA:  CLRF   02
01BFC:  CLRF   03
01BFE:  MOVF   x85,W
01C00:  ADDWF  x83,W
01C02:  MOVWF  x83
01C04:  MOVF   x86,W
01C06:  ADDWFC x84,W
01C08:  MOVWF  x84
01C0A:  MOVF   02,W
01C0C:  ADDWFC x89,W
01C0E:  MOVWF  x85
01C10:  MOVF   03,W
01C12:  ADDWFC x8A,W
01C14:  MOVWF  x86
....................  
....................    // Do another end-around carry in case if the prior add  
....................    // caused a carry out 
....................    sum.w[0] += sum.w[1]; 
01C16:  MOVF   x85,W
01C18:  ADDWF  x83,F
01C1A:  MOVF   x86,W
01C1C:  ADDWFC x84,F
....................  
....................    // Return the resulting checksum 
....................    return ~sum.w[0]; 
01C1E:  MOVFF  384,03
01C22:  COMF   03,F
01C24:  MOVF   x83,W
01C26:  XORLW  FF
01C28:  MOVWF  01
01C2A:  MOVFF  03,02
01C2E:  MOVLB  0
01C30:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    char* strupr(char* s) 
....................  
....................   Summary: 
....................    Converts a string to uppercase. 
....................  
....................   Description: 
....................    This function converts strings to uppercase on platforms that do not 
....................    already have this function defined.  All lower-case characters are 
....................    converted, an characters not included in 'a'-'z' are left as-is. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    s - the null-terminated string to be converted. 
....................  
....................   Returns: 
....................    Pointer to the initial string. 
....................   ***************************************************************************/ 
.................... #if (!defined(__PCD__) && !defined(__18CXX)) || defined(HI_TECH_C) 
.................... char* strupr(char* s) 
.................... { 
....................    char c; 
....................    char *t; 
....................  
....................    t = s; 
....................    while( (c = *t) ) 
....................    { 
....................       if(c >= 'a' && c <= 'z') 
....................       { 
....................          *t -= ('a' - 'A'); 
....................       } 
....................       t++; 
....................    } 
....................    return s; 
.................... } 
.................... #endif 
....................  
.................... #if defined(__18CXX) //&& !defined(__PCH__) 
.................... // Make this variable global for the following function. 
.................... // Hi-Tech PICC18 cannot access local function variables from inline asm. 
.................... DWORD_VAL toRotate;  
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    DWORD leftRotateDWORD(DWORD val, BYTE bits) 
....................  
....................   Summary: 
....................    Left-rotates a DWORD. 
....................  
....................   Description: 
....................    This function rotates the bits in a 32-bit DWORD left by a specific  
....................    number of bits. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    val      - the DWORD to be rotated 
....................    bits   - the number of bits by which to shift 
....................  
....................   Returns: 
....................    Rotated DWORD value. 
....................     
....................   Remarks: 
....................    This function is only implemented on 8-bit platforms for now.  The  
....................    8-bit compilers generate excessive code for this function, while C30 
....................    and C32 already generate compact code.  Those compilers are served 
....................    by a macro defined in Helpers.h. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... DWORD leftRotateDWORD(DWORD val, BYTE bits) 
.................... { 
....................    BYTE i, t; 
....................    //DWORD_VAL toRotate; 
....................    toRotate.Val = val; 
....................     
....................    for(i = bits; i >= 8u; i -= 8) 
....................    { 
....................       t = toRotate.v[3]; 
....................       toRotate.v[3] = toRotate.v[2]; 
....................       toRotate.v[2] = toRotate.v[1]; 
....................       toRotate.v[1] = toRotate.v[0]; 
....................       toRotate.v[0] = t; 
....................    } 
....................     
....................     
....................    #if defined(HI_TECH_C) 
....................    for(; i != 0; i--) 
....................    { 
....................       asm("movlb (_toRotate)>>8"); 
....................       //asm("bcf _STATUS,0,C"); 
....................       asm("bcf 0xFD8,0,C");      // HI-TECH PICC-18 PRO 9.63PL1 doesn't define _STATUS 
....................       asm("btfsc (_toRotate)&0ffh+3,7,B"); 
....................       //asm("bsf _STATUS,0,C"); 
....................       asm("bsf 0xFD8,0,C");      // HI-TECH PICC-18 PRO 9.63PL1 doesn't define _STATUS 
....................       asm("rlcf (_toRotate)&0ffh+0,F,B"); 
....................       asm("rlcf (_toRotate)&0ffh+1,F,B"); 
....................       asm("rlcf (_toRotate)&0ffh+2,F,B"); 
....................       asm("rlcf (_toRotate)&0ffh+3,F,B"); 
....................    } 
....................    #else 
....................    for(; i != 0u; i--) 
....................    { 
....................       _asm 
....................       movlb toRotate 
....................       bcf STATUS,0,0 
....................       btfsc toRotate+3,7,1 
....................       bsf STATUS,0,0 
....................       rlcf toRotate+0,1,1 
....................       rlcf toRotate+1,1,1 
....................       rlcf toRotate+2,1,1 
....................       rlcf toRotate+3,1,1 
....................       _endasm 
....................    } 
....................    #endif 
....................     
....................    return toRotate.Val; 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void FormatNetBIOSName(BYTE Name[]) 
....................  
....................   Summary: 
....................    Formats a string to a valid NetBIOS name. 
....................  
....................   Description: 
....................    This function formats a string to a valid NetBIOS name.  Names will be 
....................    exactly 16 characters, as defined by the NetBIOS spec.  The 16th  
....................    character will be a 0x00 byte, while the other 15 will be the  
....................    provided string, padded with spaces as necessary. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    Name - the string to format as a NetBIOS name.  This parameter must have 
....................      at least 16 bytes allocated. 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... void FormatNetBIOSName(BYTE Name[]) 
.................... { 
....................    BYTE i; 
....................  
....................    Name[15] = '\0'; 
....................    strupr((char*)Name); 
....................    i = 0; 
....................    while(i < 15u) 
....................    { 
....................       if(Name[i] == '\0') 
....................       { 
....................          while(i < 15u) 
....................          { 
....................             Name[i++] = ' '; 
....................          } 
....................          break; 
....................       } 
....................       i++; 
....................    } 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    char * strnchr(const char *searchString, size_t count, char c) 
....................  
....................   Summary: 
....................    Searches a string up to a specified number of characters for a specific  
....................    character. 
....................  
....................   Description: 
....................    Searches a string up to a specified number of characters for a specific  
....................    character.  The string is searched forward and the first occurance  
....................    location is returned.  If the search character is not present in the  
....................    string, or if the maximum character count is reached first, then a NULL  
....................    pointer is returned. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    searchString - Pointer to a null terminated string to search.  If count is  
....................       less than the string size, then the string need not be null terminated. 
....................    count - Maximum number of characters to search before aborting. 
....................    c - Character to search for 
....................     
....................   Returns: 
....................    Pointer to the first occurance of the character c in the string  
....................    searchString.  If the character is not found or the maximum count is  
....................    reached, a NULL pointer is returned. 
....................   ***************************************************************************/ 
.................... char * strnchr(const char *searchString, size_t count, char c) 
.................... { 
....................    char c2; 
....................     
....................    while(count--) 
....................    { 
....................       c2  = *searchString++; 
....................       if(c2 == 0u) 
....................          return NULL; 
....................       if(c2 == c) 
....................          return (char*)--searchString; 
....................    } 
....................    return NULL; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    char* strncpy_m(char* destStr, size_t destSize, int nStrings, ...) 
....................  
....................   Summary: 
....................    Copies multiple strings to a destination 
....................  
....................   Description: 
....................    Copies multiple strings to a destination 
....................     but doesn't copy more than destSize characters. 
....................     Useful where the destination is actually an array and an extra \0 
....................     won't be appended to overflow the buffer 
....................      
....................   Precondition: 
....................    - valid string pointers 
....................     - destSize should be > 0 
....................  
....................   Parameters: 
....................    destStr - Pointer to a string to be initialized with the multiple strings provided as arguments. 
....................  
....................     destSize    - the maximum size of the destStr field, that cannot be exceeded. 
....................                   An \0 won't be appended if the resulting size is > destSize 
....................  
....................     nStrings    - number of string parameters to be copied into destStr 
....................  
....................     ...         - variable number of arguments 
....................      
....................     
....................   Returns: 
....................    Length of the destination string, terminating \0 (if exists) not included 
....................   ***************************************************************************/ 
.................... size_t strncpy_m(char* destStr, size_t destSize, int nStrings, ...) 
.................... { 
....................     va_list     args; 
....................     const char* str; 
....................     char*       end; 
....................     size_t      len; 
....................  
....................     destStr[0] = '\0'; 
....................     end = destStr + destSize - 1; 
....................     *end = '\0'; 
....................     len = 0; 
....................      
....................     va_start( args, nStrings ); 
....................      
....................     while(nStrings--) 
....................     { 
....................         if(*end) 
....................         {   // if already full don't calculate strlen outside the string area 
....................             len = destSize; 
....................             break; 
....................         } 
....................          
....................         str = va_arg(args, const char*); 
....................         strncpy(destStr + len, str, destSize - len); 
....................         len += strlen(str); 
....................     } 
....................  
....................     va_end( args ); 
....................      
....................     return len; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE ExtractURLFields(BYTE *vURL,  
....................                     PROTOCOLS *protocol,  
....................                     BYTE *vUsername, WORD *wUsernameLen,  
....................                     BYTE *vPassword, WORD *wPasswordLen,  
....................                     BYTE *vHostname, WORD *wHostnameLen,  
....................                     WORD *wPort,  
....................                     BYTE *vFilePath, WORD *wFilePathLen) 
....................  
....................   Summary: 
....................    Extracts all parameters from an URL string (ex:  
....................    "http://admin:passwd@www.microchip.com:8080/myfile.gif" is split into  
....................    {PROTOCOL_HTTP, "admin", "passwd", "www.microchip.com", 8080, "/myfile.gif"}. 
....................  
....................   Description: 
....................    Extracts all parameters from an URL string (ex:  
....................    "http://admin:passwd@www.microchip.com:8080/myfile.gif" is split into  
....................    {PROTOCOL_HTTP, "admin", "passwd", "www.microchip.com", 8080, "/myfile.gif"}. 
....................     
....................    The URL string can be null terminated, or alternatively could be terminated  
....................    by a carriage return or line feed. 
....................     
....................    If the protocol is unrecognized or the protocol is recognized but the URL  
....................    is malformed, than an error is safely returned.  For more information on  
....................    URL/URI interpretation see RFC 2396. 
....................  
....................   Precondition: 
....................    This function is commented out by default to save code space because  
....................    it is not used by any current stack features.  However, if you want to use  
....................    it, go ahead and uncomment it.  It has been tested, so it (should) work  
....................    correctly. 
....................  
....................   Parameters: 
....................    vURL -   Pointer to null terminated URL to decode and extract from.  This  
....................       parameter is required and needs to have the minimum RFC 1738 components  
....................       in it (protocol and hostname). 
....................        
....................    protocol - Optional pointer to a PROTOCOLS enum to retrieve the decoded  
....................       protocol type.  If this parameter is unneeded, specify a NULL pointer.   
....................       The protocol is a required part of the URL, so it must always be  
....................       present.  The protocol also determines what scheme all other parameters  
....................       are decoded using, so the function will fail if an unrecognized  
....................       protocol is provided.  The PROTOCOLS enum members show all of the  
....................       currently supported protocols for this function. 
....................        
....................       <p>For the example URL provided in the function description,  
....................       PROTOCOL_HTTP would be returned for this field. 
....................        
....................    vUsername - Optional pointer to a buffer to write the decoded username  
....................       portion of the URL.  If the URL does not contain a username or a NULL  
....................       pointer is supplied, then this field is ignored. 
....................  
....................       <p>For the example URL provided in the function description, "admin"  
....................       would be returned for this field. 
....................        
....................    wUsernameLen - 
....................       On call\: Optional pointer to a WORD specifying the maximum length of  
....................       the vUsername buffer, including the null terminator character. 
....................        
....................       <p>Upon return\: If wUsernameLen and vUsername are non-NULL, the  
....................       *wUsernameLen WORD is updated with the actual number of characters  
....................       written to the vUsername buffer, including the null terminator  
....................       character.  If vUsername is NULL but wUsernameLen is non-NULL, then no  
....................       characters are copied, but *wUsernameLen will return the number of  
....................       characters required to fit the full username string.  If wUsernameLen  
....................       is NULL, then the username field in the URL, if present, is ignored and  
....................       the vUsername pointer is not used. 
....................        
....................       <p>If zero characters were written, this indicates that the URL did not  
....................       contain a username field.  If one character was written, this indicates  
....................       that a username field was present, but was a zero character string  
....................       (ex\: ""). 
....................         
....................       <p>For the example URL provided in the function description, 6 (0x0006)  
....................       would be returned for this field. 
....................        
....................    vPassword - Optional pointer to a buffer to write the decoded password  
....................       portion of the URL.  If the URL does not contain a password or a NULL  
....................       pointer is supplied, then this field is ignored. 
....................  
....................       <p>For the example URL provided in the function description, "passwd"  
....................       would be returned for this field. 
....................        
....................    wPasswordLen - 
....................       On call\: Optional pointer to a WORD specifying the maximum length of  
....................       the vPassword buffer, including the null terminator character. 
....................        
....................       <p>Upon return\: If wPasswordLen and vPassword are non-NULL, the  
....................       *wPasswordLen WORD is updated with the actual number of characters  
....................       written to the vPassword buffer, including the null terminator  
....................       character.  If vPassword is NULL but wPasswordLen is non-NULL, then no  
....................       characters are copied, but *wPasswordLen will return the number of  
....................       characters required to fit the full password string.  If wPasswordLen  
....................       is NULL, then the password field in the URL, if present, is ignored and  
....................       the vPassword pointer is not used. 
....................        
....................       <p>If zero characters were written, this indicates that the URL did not  
....................       contain a password field.  If one character was written, this indicates  
....................       that a password field was present, but was a zero character string  
....................       (ex\: ""). 
....................         
....................       <p>For the example URL provided in the function description, 7 (0x0007)  
....................       would be returned for this field. 
....................        
....................    vHostname - Optional pointer to a buffer to write the decoded hostname  
....................       portion of the URL.  All Internet URLs must contain a hostname or IP  
....................       address, however, if a NULL pointer is supplied, then this field is  
....................       ignored. 
....................  
....................       <p>For the example URL provided in the function description,  
....................       "www.microchip.com" would be returned for this field.  If the URL was  
....................       "http://192.168.0.1", then this field would be returned as  
....................       "192.168.0.1".   The IP address would not be decoded to a DWORD (use the  
....................       StringToIPAddress() helper function to do this). 
....................        
....................    wHostnameLen - 
....................       On call\: Optional pointer to a WORD specifying the maximum length of  
....................       the vHostname buffer, including the null terminator character. 
....................        
....................       <p>Upon return\: If wHostnameLen and vHostname are non-NULL, the  
....................       *wHostnameLen WORD is updated with the actual number of characters  
....................       written to the vHostname buffer, including the null terminator  
....................       character.  If vHostname is NULL but wHostnameLen is non-NULL, then no  
....................       characters are copied, but *wHostnameLen will return the number of  
....................       characters required to fit the full hostname string.  If wHostnameLen  
....................       is NULL, then the hostname field in the URL, is ignored and the  
....................       vHostname pointer is not used. 
....................        
....................       <p>For the example URL provided in the function description,  
....................       18 (0x0012) would be returned for this field.  If the URL was  
....................       "http://192.168.0.1", then this field would be returned as 12 (0x000C). 
....................        
....................    wPort - Optional pointer to a WORD specifying the TCP or UDP port that the  
....................       server is listening on.  If the port field is absent from the URL, then  
....................       this parameter will specify the default port for the protocol.  For  
....................       example, "http://www.microchip.com" would result in 80 being return as  
....................       the specified port. 
....................         
....................       <p>If the wPort pointer is NULL, then the port field in the URL  
....................       is ignored, if present. 
....................        
....................    vFilePath - Optional pointer to a buffer to write the decoded file path  
....................       portion of the URL.  If a NULL pointer is supplied, then this field is  
....................       ignored.  If a file path is not present in the URL, then "/" will be  
....................       returned in this field.   
....................  
....................       <p>For the example URL provided in the function description,  
....................       "/myfile.gif" would be returned for this field. 
....................        
....................    wFilePathLen - 
....................       On call\: Optional pointer to a WORD specifying the maximum length of  
....................       the vFilePath buffer, including the null terminator character. 
....................        
....................       <p>Upon return\: If wFilePathLen and vFilePath are non-NULL, the  
....................       *wFilePathLen WORD is updated with the actual number of characters  
....................       written to the vFilePath buffer, including the null terminator  
....................       character.  If vFilePath is NULL but wFilePathLen is non-NULL, then no  
....................       characters are copied, but *wFilePathLen will return the number of  
....................       characters required to fit the full file path string.  If wFilePathLen  
....................       is NULL, then the file path field in the URL, if present, is ignored and  
....................       the vFilePath pointer is not used. 
....................        
....................       <p>This function always returns "/" if no file path is present, so 
....................       *wFilePathLen will also be at least 2 characters ('/' and null  
....................       terminator) if the pointer is non-NULL. 
....................     
....................       <p>For the example URL provided in the function description, 12 (0x000C)  
....................       would be returned for this field. 
....................        
....................   Returns: 
....................    Zero on success.  Nonzero indicates an error code.  If a nonzero error code  
....................    is returned, none of the returned buffers or pointer values should be  
....................    treated as valid, but some of them may have been written to.  The following  
....................    are all possible return values. 
....................    <table> 
....................       0   No error 
....................       1   Protocol unknown (additional code needs to be added to  
....................           ExtractURLFields() and the PROTOCOLS enum needs to be updated if  
....................           you want to decode URLs of this protocol type. 
....................       2   URL malformed. Illegal or unknown URL format encountered. 
....................       3   Buffer too small.  One of the input buffer sizes is too small to  
....................           contain the URL parameter. 
....................    </table> 
....................   ***************************************************************************/ 
.................... #if 0    
.................... BYTE ExtractURLFields(BYTE *vURL, PROTOCOLS *protocol, BYTE *vUsername, WORD *wUsernameLen, BYTE *vPassword, WORD *wPasswordLen, BYTE *vHostname, WORD *wHostnameLen, WORD *wPort, BYTE *vFilePath, WORD *wFilePathLen) 
.................... { 
....................    // These two arrays must exactly match up each other and the PROTOCOLS enum  
....................    // elements.  The protocol name strings must also be specified in all  
....................    // lowercase. 
....................    static ROM char * ROM   vProtocolNames[] = {"http", "https", "mms", "rtsp"}; 
....................    static ROM WORD       wProtocolPorts[] = { 80,     443,     1755,  554}; 
....................    WORD w, w2; 
....................    BYTE i, j; 
....................    PROTOCOLS prot; 
....................    BYTE *temp, *temp2; 
....................    WORD wURLLen; 
....................    WORD wLocalPort; 
....................     
....................     
....................    // Calculate how long this URL is 
....................    wURLLen = strlen((char*)vURL); 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, '\r'); 
....................    if(temp) 
....................       wURLLen = temp - vURL; 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, '\n'); 
....................    if(temp) 
....................       wURLLen = temp - vURL; 
....................     
....................  
....................    // Parse starting protocol field 
....................    // Find out how long the protocol name field is 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, ':'); 
....................    if(temp == NULL) 
....................       return 2; 
....................     
....................    // Search protocol list to see if this is a recognized protocol 
....................    for(prot = 0; (BYTE)prot < sizeof(wProtocolPorts)/sizeof(wProtocolPorts[0]); prot++) 
....................    { 
....................       w = strlenpgm(vProtocolNames[prot]); 
....................       if((WORD)(temp - vURL) == w) 
....................       { 
....................          w2 = 0; 
....................          temp2 = vURL; 
....................          while(w) 
....................          { 
....................             i = *temp2++; 
....................             if((i >= 'A') && (i <= 'Z')) 
....................                i += 'a' - 'A'; 
....................             if(i != (BYTE)vProtocolNames[prot][w2++]) 
....................                break; 
....................             w--; 
....................          } 
....................          if(w == 0u) 
....................          { 
....................             if(protocol) 
....................                *protocol = prot; 
....................             break; 
....................          } 
....................       } 
....................    } 
....................  
....................    // If we've search the whole list and didn't find a match, then  
....................    // this protocol is unknown and this URL cannot be parsed. 
....................    if((BYTE)prot >= sizeof(wProtocolPorts)/sizeof(wProtocolPorts[0])) 
....................       return 1; 
....................     
....................    w = temp - vURL + 1; 
....................    vURL += w; 
....................    wURLLen -= w; 
....................  
....................    // Protocols using the authority field all must have a double  
....................    // slash "//" prefix 
....................    if(wURLLen < 2u) 
....................       return 2; 
....................    for(j = 0; j < 2u; j++) 
....................    { 
....................       i = *vURL++; 
....................       if(i != '/') 
....................          return 2; 
....................    } 
....................    wURLLen -= 2; 
....................     
....................  
....................    // Parse username and password fields 
....................    // See if there is a @ sign, indicating that there is at  
....................    // least a username and possibly a password in this URL 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, '@'); 
....................    if(temp == NULL) 
....................    { 
....................       if(wUsernameLen) 
....................          *wUsernameLen = 0; 
....................       if(wPasswordLen) 
....................          *wPasswordLen = 0; 
....................    } 
....................    else 
....................    { 
....................       // If we get down here, there is a user name present, let's  
....................       // see if a password is also present by searching for a  
....................       // colon between the current string position and the @  
....................       // symbol. 
....................       temp2 = (BYTE*)strnchr((char*)vURL, temp - vURL, ':'); 
....................        
....................       // Calculate username length and password length, including  
....................       // null terminator (if the field exists) 
....................       if(temp2 == NULL) 
....................       { 
....................          w = temp - vURL + 1;   // Username 
....................          w2 = 0;               // Password 
....................       } 
....................       else 
....................       { 
....................          w = temp2 - vURL + 1;   // Username 
....................          w2 = temp - temp2;      // Password 
....................       } 
....................        
....................       if(wUsernameLen) 
....................       { 
....................          if(vUsername) 
....................          { 
....................             if(*wUsernameLen < w) 
....................                return 3; 
....................             memcpy((void*)vUsername, (void*)vURL, w - 1); 
....................             vUsername[w-1] = 0; 
....................          } 
....................          *wUsernameLen = w; 
....................       } 
....................     
....................       if(wPasswordLen) 
....................       { 
....................          if(vPassword) 
....................          { 
....................             if(*wPasswordLen < w2) 
....................                return 3; 
....................             if(w2) 
....................             { 
....................                memcpy((void*)vPassword, (void*)temp2+1, w2 - 1); 
....................                vPassword[w2-1] = 0; 
....................             } 
....................          } 
....................          *wPasswordLen = w2; 
....................       } 
....................     
....................       vURL += w; 
....................       wURLLen -= w; 
....................       if(w2) 
....................       { 
....................          vURL += w2; 
....................          wURLLen -= w2; 
....................       } 
....................    } 
....................  
....................  
....................    // Parse hostname field 
....................    // Find the length of the hostname, including NULL  
....................    // terminator 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, ':'); 
....................    temp2 = (BYTE*)strnchr((char*)vURL, wURLLen, '/'); 
....................    if(temp && temp2) 
....................    { 
....................       if(temp > temp2) 
....................          temp = NULL; 
....................    } 
....................    if(temp == NULL) 
....................    { 
....................       temp = temp2; 
....................       if(temp2 == NULL) 
....................          temp = vURL + wURLLen; 
....................    } 
....................    w = temp - vURL + 1; 
....................    if(wHostnameLen) 
....................    { 
....................       if(vHostname) 
....................       { 
....................          if(*wHostnameLen < w) 
....................             return 3; 
....................          memcpy((void*)vHostname, (void*)vURL, w - 1); 
....................          vHostname[w-1] = 0; 
....................       } 
....................       *wHostnameLen = w; 
....................    } 
....................    vURL += w - 1; 
....................    wURLLen -= w - 1; 
....................  
....................  
....................    // Parse port field 
....................    if(*vURL == ':') 
....................    { 
....................       vURL++; 
....................       wURLLen--; 
....................       wLocalPort = 0; 
....................       w = wURLLen; 
....................       temp = (BYTE*)strnchr((char*)vURL, wURLLen, '/'); 
....................       if(temp != NULL) 
....................          w = temp - vURL; 
....................       w2 = w; 
....................       if(wPort) 
....................       { 
....................          while(w--) 
....................          { 
....................             wLocalPort *= 10; 
....................             wLocalPort += *vURL++ - '0'; 
....................          } 
....................          *wPort = wLocalPort; 
....................       } 
....................       else 
....................          vURL += w2; 
....................       wURLLen -= w2; 
....................    } 
....................    else if(wPort) 
....................       *wPort = wProtocolPorts[prot]; 
....................  
....................  
....................    // Parse file path field 
....................    if(wFilePathLen) 
....................    { 
....................       w = ++wURLLen; 
....................       if(wURLLen == 1u) 
....................          w = 2; 
....................       if(vFilePath) 
....................       { 
....................          if(*wFilePathLen < w) 
....................             return 3; 
....................          if(wURLLen == 1u) 
....................             vFilePath[0] = '/'; 
....................          else 
....................             memcpy((void*)vFilePath, (void*)vURL, wURLLen - 1); 
....................          vFilePath[w - 1] = 0; 
....................          *wFilePathLen = w; 
....................          return 0; 
....................       } 
....................       *wFilePathLen = w; 
....................    } 
....................    return 0; 
.................... } 
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    SHORT Replace(BYTE *vExpression, ROM BYTE *vFind, ROM BYTE *vReplacement,  
....................               WORD wMaxLen, BOOL bSearchCaseInsensitive) 
....................  
....................   Summary: 
....................    Replaces all instances of a particular substring with a new string 
....................  
....................   Description: 
....................    Searches a string (vExpression) and replaces all instances of a particular  
....................    substring (vFind) with a new string (vReplacement).  The start offset to  
....................    being searching and a maximum number of replacements can be specified.  The  
....................    search can be performed in a case sensitive or case insensitive manner. 
....................  
....................   Precondition: 
....................    This function is commented out by default to save code space because  
....................    it is not used by any current stack features.  However, if you want to use  
....................    it, go ahead and uncomment it.  It has been tested, so it (should) work  
....................    correctly. 
....................  
....................   Parameters: 
....................    vExpression - Null terminated string to search and make replacements within. 
....................    vFind - Null terminated string to search for. 
....................    vReplacement - Null terminated string to replace all instances of vFind with. 
....................    wMaxLen - Maximum length of the output vExpression string if string  
....................       expansion is going to occur (replacement length is longer than find  
....................       length).  If the replacements will cause this maximum string length to  
....................       be exceeded, then no replacements will be made and a negative result  
....................       will be returned, indicating failure.  If the replacement length is  
....................       shorter or equal to the search length, then this parameter is ignored. 
....................    bSearchCaseInsensitive - Boolean indicating if the search should be  
....................       performed in a case insensitive manner.  Specify TRUE for case  
....................       insensitive searches (slower) or FALSE for case sensitive  
....................       searching (faster). 
....................  
....................   Remarks: 
....................    If the replacement string length is shorter than or equal to the search  
....................    string length and the search string occurs in multiple overlapping  
....................    locations (ex\: expression is "aaa", find is "aa", and replacement is "bb")  
....................    then the first find match occuring when searching from left to right will  
....................    be replaced.  (ex\: output expression will be "bba"). 
....................     
....................    However, if the replacement string length is longer than the search string  
....................    length, the search will occur starting from the end of the string and  
....................    proceed to the beginning (right to left searching).  In this case if the  
....................    expression was "aaa", find was "aa", and replacement was "bbb", then the  
....................    final output expression will be "abbb".   
....................  
....................   Returns: 
....................    If zero or greater, indicates the count of how many replacements were made.   
....................    If less than zero (negative result), indicates that wMaxLen was too small  
....................    to make the necessary replacements.  In this case, no replacements were  
....................    made. 
....................   ***************************************************************************/ 
.................... #if 0 
.................... SHORT Replace(BYTE *vExpression, ROM BYTE *vFind, ROM BYTE *vReplacement, WORD wMaxLen, BOOL bSearchCaseInsensitive) 
.................... { 
....................    WORD wExpressionLen, wFindLen, wFindLenMinusOne, wReplacementLen; 
....................    WORD wFindCount, wReplacementsLeft; 
....................    BYTE i, j; 
....................    BYTE vFirstFindChar; 
....................    WORD wBytesLeft; 
....................    BYTE *vDest; 
....................    BYTE *vExpressionCompare; 
....................    ROM BYTE *vFindCompare; 
....................    WORD w; 
....................  
....................    wFindLen = strlenpgm((ROM char*)vFind); 
....................    if(wFindLen == 0u) 
....................       return 0; 
....................     
....................    wExpressionLen = strlen((char*)vExpression); 
....................    wReplacementLen = strlenpgm((ROM char*)vReplacement); 
....................  
....................    wFindCount = 0; 
....................    wFindLenMinusOne = wFindLen - 1; 
....................    vFirstFindChar = *vFind++; 
....................    if(bSearchCaseInsensitive)   // Convert to all lowercase if needed 
....................       if((vFirstFindChar >= (BYTE)'A') && (vFirstFindChar <= (BYTE)'Z')) 
....................          vFirstFindChar += 'a' - 'A'; 
....................  
....................    // If the replacement string is the same length as the search string, then  
....................    // we can immediately do the needed replacements inline and return. 
....................    if(wFindLen == wReplacementLen) 
....................    { 
....................       for(wBytesLeft = wExpressionLen; wBytesLeft; wBytesLeft--) 
....................       { 
....................          i = *vExpression++; 
....................          if(bSearchCaseInsensitive) 
....................          { 
....................             if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                i += 'a' - 'A'; 
....................             if(i != vFirstFindChar) 
....................                continue; 
....................             vExpressionCompare = vExpression; 
....................             vFindCompare = vFind; 
....................             w = wFindLenMinusOne; 
....................             while(w) 
....................             { 
....................                i = *vExpressionCompare++; 
....................                j = *vFindCompare++; 
....................                if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                   i += 'a' - 'A'; 
....................                if((j >= (BYTE)'A') && (j <= (BYTE)'Z')) 
....................                   j += 'a' - 'A'; 
....................                if(i != j) 
....................                   break; 
....................                w--; 
....................             } 
....................             if(w) 
....................                continue; 
....................          } 
....................          else 
....................          { 
....................             if(i != vFirstFindChar) 
....................                continue; 
....................             if(memcmppgm2ram((void*)vExpression, (ROM void*)vFind, wFindLenMinusOne)) 
....................                continue; 
....................          } 
....................     
....................          memcpypgm2ram((void*)vExpression-1, (ROM void*)vReplacement, wReplacementLen); 
....................          wFindCount++; 
....................          vExpression += wFindLenMinusOne; 
....................          wBytesLeft -= wFindLenMinusOne; 
....................       } 
....................       return wFindCount; 
....................    } 
....................     
....................     
....................    // If the replacement string is shorter than the search string, then we can  
....................    // search from left to right and move the string over as we find occurrences. 
....................    if(wFindLen > wReplacementLen) 
....................    { 
....................       vDest = vExpression; 
....................       for(wBytesLeft = wExpressionLen; wBytesLeft; wBytesLeft--) 
....................       { 
....................          i = *vExpression++; 
....................          *vDest++ = i; 
....................          if(bSearchCaseInsensitive) 
....................          { 
....................             if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                i += 'a' - 'A'; 
....................             if(i != vFirstFindChar) 
....................                continue; 
....................             vExpressionCompare = vExpression; 
....................             vFindCompare = vFind; 
....................             w = wFindLenMinusOne; 
....................             while(w) 
....................             { 
....................                i = *vExpressionCompare++; 
....................                j = *vFindCompare++; 
....................                if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                   i += 'a' - 'A'; 
....................                if((j >= (BYTE)'A') && (j <= (BYTE)'Z')) 
....................                   j += 'a' - 'A'; 
....................                if(i != j) 
....................                   break; 
....................                w--; 
....................             } 
....................             if(w) 
....................                continue; 
....................          } 
....................          else 
....................          { 
....................             if(i != vFirstFindChar) 
....................                continue; 
....................             if(memcmppgm2ram((void*)vExpression, (ROM void*)vFind, wFindLenMinusOne)) 
....................                continue; 
....................          } 
....................     
....................          memcpypgm2ram((void*)vDest-1, (ROM void*)vReplacement, wReplacementLen); 
....................          vDest += wReplacementLen-1; 
....................          wFindCount++; 
....................          vExpression += wFindLenMinusOne; 
....................          wBytesLeft -= wFindLenMinusOne; 
....................       } 
....................       *vDest = 0x00;   // Write new null terminator since the string may have shrunk 
....................       return wFindCount; 
....................    } 
....................     
....................    // If the replacement string is longer than the search string, then we will  
....................    // take a two pass approach.  On the first pass, we will merely count how  
....................    // many replacements to make.  With this we can calculate how long the  
....................    // final string is going to be.  On the second pass, we will search from  
....................    // right to left and expand the string as needed. 
....................  
....................    // Pass 1: count how many occurrences of vFind are in vExpression 
....................    for(wBytesLeft = wExpressionLen; wBytesLeft; wBytesLeft--) 
....................    { 
....................       i = *vExpression++; 
....................       if(bSearchCaseInsensitive) 
....................       { 
....................          if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................             i += 'a' - 'A'; 
....................          if(i != vFirstFindChar) 
....................             continue; 
....................          vExpressionCompare = vExpression; 
....................          vFindCompare = vFind; 
....................          w = wFindLenMinusOne; 
....................          while(w) 
....................          { 
....................             i = *vExpressionCompare++; 
....................             j = *vFindCompare++; 
....................             if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                i += 'a' - 'A'; 
....................             if((j >= (BYTE)'A') && (j <= (BYTE)'Z')) 
....................                j += 'a' - 'A'; 
....................             if(i != j) 
....................                break; 
....................             w--; 
....................          } 
....................          if(w) 
....................             continue; 
....................       } 
....................       else 
....................       { 
....................          if(i != vFirstFindChar) 
....................             continue; 
....................          if(memcmppgm2ram((void*)vExpression, (ROM void*)vFind, wFindLenMinusOne)) 
....................             continue; 
....................       } 
....................  
....................       wFindCount++; 
....................       vExpression += wFindLenMinusOne; 
....................       wBytesLeft -= wFindLenMinusOne; 
....................    } 
....................     
....................    // Return immediately if no replacements are needed 
....................    if(wFindCount == 0u) 
....................       return 0; 
....................  
....................    // Pass 2: make replacements and move string over 
....................    vDest = vExpression + wFindCount * (wReplacementLen - wFindLen); 
....................    if(vDest > vExpression - wExpressionLen + wMaxLen) 
....................       return -1; 
....................    *vDest-- = 0x00;   // Write new null terminator 
....................    vExpression -= 1; 
....................    vFind -= 1; 
....................    vFirstFindChar = vFind[wFindLenMinusOne]; 
....................    if(bSearchCaseInsensitive)   // Convert to all lowercase if needed 
....................       if((vFirstFindChar >= (BYTE)'A') && (vFirstFindChar <= (BYTE)'Z')) 
....................          vFirstFindChar += 'a' - 'A'; 
....................    wReplacementsLeft = wFindCount; 
....................    while(wReplacementsLeft) 
....................    { 
....................       i = *vExpression--; 
....................       *vDest-- = i; 
....................       if(bSearchCaseInsensitive) 
....................       { 
....................          if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................             i += 'a' - 'A'; 
....................          if(i != vFirstFindChar) 
....................             continue; 
....................          vExpressionCompare = vExpression; 
....................          vFindCompare = &vFind[wFindLenMinusOne-1]; 
....................          w = wFindLenMinusOne; 
....................          while(w) 
....................          { 
....................             i = *vExpressionCompare--; 
....................             j = *vFindCompare--; 
....................             if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                i += 'a' - 'A'; 
....................             if((j >= (BYTE)'A') && (j <= (BYTE)'Z')) 
....................                j += 'a' - 'A'; 
....................             if(i != j) 
....................                break; 
....................             w--; 
....................          } 
....................          if(w) 
....................             continue; 
....................       } 
....................       else 
....................       { 
....................          if(i != vFirstFindChar) 
....................             continue; 
....................          if(memcmppgm2ram((void*)vExpression-wFindLenMinusOne, (ROM void*)vFind, wFindLenMinusOne)) 
....................             continue; 
....................       } 
....................       memcpypgm2ram((void*)vDest-wReplacementLen+2, (ROM void*)vReplacement, wReplacementLen); 
....................       vDest -= wReplacementLen-1; 
....................  
....................       vExpression -= wFindLenMinusOne; 
....................       wBytesLeft -= wFindLenMinusOne; 
....................       wReplacementsLeft--; 
....................    } 
....................    return wFindCount; 
.................... } 
.................... #endif 
....................  
.................... //#include "Delay.c" //not needed, we overrode this in StackTsk2.h 
.................... #include "Tick.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for Timekeeping 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.c 
....................  * Dependencies:    Timer 0 (PIC18) or Timer 1 (PIC24F, PIC24H,  
....................  *					dsPIC30F, dsPIC33F, PIC32) 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.10b or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder		6/13/07		Changed to use timer without  
....................  *									writing for perfect accuracy. 
.................... ********************************************************************/ 
.................... #define __TICK_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... // Internal counter to store Ticks.  This variable is incremented in an ISR and  
.................... // therefore must be marked volatile to prevent the compiler optimizer from  
.................... // reordering code to use this value in the main context while interrupts are  
.................... // disabled. 
.................... static volatile DWORD dwInternalTicks = 0; 
....................  
.................... // 6-byte value to store Ticks.  Allows for use over longer periods of time. 
.................... static BYTE vTickReading[6]; 
....................  
.................... static void GetTickCopy(void); 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	void TickInit(void) 
....................  
....................   Summary: 
.................... 	Initializes the Tick manager module. 
....................  
....................   Description: 
.................... 	Configures the Tick module and any necessary hardware resources. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	None 
....................   	 
....................   Remarks: 
.................... 	This function is called only one during lifetime of the application. 
....................   ***************************************************************************/ 
.................... void TickInit(void) 
.................... { 
.................... #if defined(__18CXX) 
.................... 	// Use Timer0 for 8 bit processors 
....................     // Initialize the time 
....................     TMR0H = 0; 
*
002B2:  CLRF   FD7
....................     TMR0L = 0; 
002B4:  CLRF   FD6
....................  
.................... 	// Set up the timer interrupt 
.................... 	INTCON2bits.TMR0IP = 0;		// Low priority 
002B6:  BCF    FF1.2
....................     INTCONbits.TMR0IF = 0; 
002B8:  BCF    FF2.2
....................     INTCONbits.TMR0IE = 1;		// Enable interrupt 
002BA:  BSF    FF2.5
....................  
....................     // Timer0 on, 16-bit, internal timer, 1:256 prescalar 
....................     T0CON = 0x87; 
002BC:  MOVLW  87
002BE:  MOVWF  FD5
....................  
.................... #else 
002C0:  GOTO   02CC (RETURN)
.................... 	// Use Timer 1 for 16-bit and 32-bit processors 
.................... 	// 1:256 prescale 
.................... 	T1CONbits.TCKPS = 3; 
.................... 	// Base 
.................... 	PR1 = 0xFFFF; 
.................... 	// Clear counter 
.................... 	TMR1 = 0; 
....................  
.................... 	// Enable timer interrupt 
.................... 	#if defined(__C30__) 
.................... 		IPC0bits.T1IP = 2;	// Interrupt priority 2 (low) 
.................... 		IFS0bits.T1IF = 0; 
.................... 		IEC0bits.T1IE = 1; 
.................... 	#else 
.................... 		IPC1bits.T1IP = 2;	// Interrupt priority 2 (low) 
.................... 		IFS0CLR = _IFS0_T1IF_MASK; 
.................... 		IEC0SET = _IEC0_T1IE_MASK; 
.................... 	#endif 
....................  
.................... 	// Start timer 
.................... 	T1CONbits.TON = 1; 
.................... #endif 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	static void GetTickCopy(void) 
....................  
....................   Summary: 
.................... 	Reads the tick value. 
....................  
....................   Description: 
.................... 	This function performs an interrupt-safe and synchronized read of the  
.................... 	48-bit Tick value. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	None 
....................   ***************************************************************************/ 
.................... static void GetTickCopy(void) 
.................... { 
.................... 	// Perform an Interrupt safe and synchronized read of the 48-bit  
.................... 	// tick value 
.................... #if defined(__18CXX) 
.................... 	do 
.................... 	{ 
.................... 		INTCONbits.TMR0IE = 1;		// Enable interrupt 
*
015F8:  BSF    FF2.5
.................... 		Nop(); 
015FA:  NOP   
.................... 		INTCONbits.TMR0IE = 0;		// Disable interrupt 
015FC:  BCF    FF2.5
.................... 		vTickReading[0] = TMR0L; 
015FE:  MOVFF  FD6,74
.................... 		vTickReading[1] = TMR0H; 
01602:  MOVFF  FD7,75
.................... 		*((DWORD*)&vTickReading[2]) = dwInternalTicks; 
01606:  MOVLB  3
01608:  CLRF   x61
0160A:  MOVLW  76
0160C:  MOVWF  FE9
0160E:  MOVFF  361,FEA
01612:  MOVFF  70,FEF
01616:  MOVFF  71,FEC
0161A:  MOVFF  72,FEC
0161E:  MOVFF  73,FEC
.................... 	} while(INTCONbits.TMR0IF); 
01622:  BTFSS  FF2.2
01624:  BRA    162A
01626:  MOVLB  0
01628:  BRA    15F8
.................... 	INTCONbits.TMR0IE = 1;			// Enable interrupt 
0162A:  BSF    FF2.5
.................... #elif defined(__C30__) 
0162C:  MOVLB  0
0162E:  RETURN 0
.................... 	do 
.................... 	{ 
.................... 		DWORD dwTempTicks; 
.................... 		 
.................... 		IEC0bits.T1IE = 1;			// Enable interrupt 
.................... 		Nop(); 
.................... 		IEC0bits.T1IE = 0;			// Disable interrupt 
....................  
.................... 		// Get low 2 bytes 
.................... 		((WORD*)vTickReading)[0] = TMR1; 
.................... 		 
.................... 		// Correct corner case where interrupt increments byte[4+] but  
.................... 		// TMR1 hasn't rolled over to 0x0000 yet 
.................... 		dwTempTicks = dwInternalTicks; 
.................... 		if(((WORD*)vTickReading)[0] == 0xFFFFu) 
.................... 			dwTempTicks--; 
.................... 		 
.................... 		// Get high 4 bytes 
.................... 		vTickReading[2] = ((BYTE*)&dwTempTicks)[0]; 
.................... 		vTickReading[3] = ((BYTE*)&dwTempTicks)[1]; 
.................... 		vTickReading[4] = ((BYTE*)&dwTempTicks)[2]; 
.................... 		vTickReading[5] = ((BYTE*)&dwTempTicks)[3]; 
.................... 	} while(IFS0bits.T1IF); 
.................... 	IEC0bits.T1IE = 1;				// Enable interrupt 
.................... #else	// PIC32 
.................... 	do 
.................... 	{ 
.................... 		DWORD dwTempTicks; 
.................... 		 
.................... 		IEC0SET = _IEC0_T1IE_MASK;	// Enable interrupt 
.................... 		Nop(); 
.................... 		IEC0CLR = _IEC0_T1IE_MASK;	// Disable interrupt 
.................... 		 
.................... 		// Get low 2 bytes 
.................... 		((volatile WORD*)vTickReading)[0] = TMR1; 
.................... 		 
.................... 		// Correct corner case where interrupt increments byte[4+] but  
.................... 		// TMR1 hasn't rolled over to 0x0000 yet 
.................... 		dwTempTicks = dwInternalTicks; 
....................  
.................... 		// PIC32MX3XX/4XX devices trigger the timer interrupt when TMR1 == PR1  
.................... 		// (TMR1 prescalar is 0x00), requiring us to undo the ISR's increment  
.................... 		// of the upper 32 bits of our 48 bit timer in the special case when  
.................... 		// TMR1 == PR1 == 0xFFFF.  For other PIC32 families, the ISR is  
.................... 		// triggered when TMR1 increments from PR1 to 0x0000, making no special  
.................... 		// corner case. 
.................... 		#if __PIC32_FEATURE_SET__ <= 460 
.................... 			if(((WORD*)vTickReading)[0] == 0xFFFFu) 
.................... 				dwTempTicks--; 
.................... 		#elif !defined(__PIC32_FEATURE_SET__) 
.................... 			#error __PIC32_FEATURE_SET__ macro must be defined.  You need to download a newer C32 compiler version. 
.................... 		#endif 
.................... 		 
.................... 		// Get high 4 bytes 
.................... 		vTickReading[2] = ((BYTE*)&dwTempTicks)[0]; 
.................... 		vTickReading[3] = ((BYTE*)&dwTempTicks)[1]; 
.................... 		vTickReading[4] = ((BYTE*)&dwTempTicks)[2]; 
.................... 		vTickReading[5] = ((BYTE*)&dwTempTicks)[3]; 
.................... 	} while(IFS0bits.T1IF); 
.................... 	IEC0SET = _IEC0_T1IE_MASK;		// Enable interrupt 
.................... #endif 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	DWORD TickGet(void) 
....................  
....................   Summary: 
.................... 	Obtains the current Tick value. 
....................  
....................   Description: 
.................... 	This function retrieves the current Tick value, allowing timing and 
.................... 	measurement code to be written in a non-blocking fashion.  This function 
.................... 	retrieves the least significant 32 bits of the internal tick counter,  
.................... 	and is useful for measuring time increments ranging from a few  
.................... 	microseconds to a few hours.  Use TickGetDiv256 or TickGetDiv64K for 
.................... 	longer periods of time. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	Lower 32 bits of the current Tick value. 
....................   ***************************************************************************/ 
.................... DWORD TickGet(void) 
.................... { 
.................... 	GetTickCopy(); 
01630:  RCALL  15F8
.................... 	return *((DWORD*)&vTickReading[0]); 
01632:  MOVLB  3
01634:  CLRF   x61
01636:  MOVLW  74
01638:  MOVFF  361,03
0163C:  MOVWF  FE9
0163E:  MOVFF  361,FEA
01642:  MOVFF  FEF,00
01646:  MOVFF  FEC,01
0164A:  MOVFF  FEC,02
0164E:  MOVFF  FEC,03
01652:  MOVLB  0
01654:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	DWORD TickGetDiv256(void) 
....................  
....................   Summary: 
.................... 	Obtains the current Tick value divided by 256. 
....................  
....................   Description: 
.................... 	This function retrieves the current Tick value, allowing timing and 
.................... 	measurement code to be written in a non-blocking fashion.  This function 
.................... 	retrieves the middle 32 bits of the internal tick counter,  
.................... 	and is useful for measuring time increments ranging from a few  
.................... 	minutes to a few weeks.  Use TickGet for shorter periods or TickGetDiv64K 
.................... 	for longer ones. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	Middle 32 bits of the current Tick value. 
....................   ***************************************************************************/ 
.................... DWORD TickGetDiv256(void) 
.................... { 
.................... 	DWORD dw; 
....................  
.................... 	GetTickCopy(); 
*
02B2A:  CALL   15F8
.................... 	((BYTE*)&dw)[0] = vTickReading[1];	// Note: This copy must be done one  
02B2E:  MOVFF  75,336
.................... 	((BYTE*)&dw)[1] = vTickReading[2];	// byte at a time to prevent misaligned  
02B32:  MOVFF  76,337
.................... 	((BYTE*)&dw)[2] = vTickReading[3];	// memory reads, which will reset the PIC. 
02B36:  MOVFF  77,338
.................... 	((BYTE*)&dw)[3] = vTickReading[4]; 
02B3A:  MOVFF  78,339
.................... 	 
.................... 	return dw; 
02B3E:  MOVFF  336,00
02B42:  MOVFF  337,01
02B46:  MOVFF  338,02
02B4A:  MOVFF  339,03
02B4E:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	DWORD TickGetDiv64K(void) 
....................  
....................   Summary: 
.................... 	Obtains the current Tick value divided by 64K. 
....................  
....................   Description: 
.................... 	This function retrieves the current Tick value, allowing timing and 
.................... 	measurement code to be written in a non-blocking fashion.  This function 
.................... 	retrieves the most significant 32 bits of the internal tick counter,  
.................... 	and is useful for measuring time increments ranging from a few  
.................... 	days to a few years, or for absolute time measurements.  Use TickGet or 
.................... 	TickGetDiv256 for shorter periods of time. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	Upper 32 bits of the current Tick value. 
....................   ***************************************************************************/ 
.................... DWORD TickGetDiv64K(void) 
.................... { 
.................... 	DWORD dw; 
....................  
.................... 	GetTickCopy(); 
.................... 	((BYTE*)&dw)[0] = vTickReading[2];	// Note: This copy must be done one  
.................... 	((BYTE*)&dw)[1] = vTickReading[3];	// byte at a time to prevent misaligned  
.................... 	((BYTE*)&dw)[2] = vTickReading[4];	// memory reads, which will reset the PIC. 
.................... 	((BYTE*)&dw)[3] = vTickReading[5]; 
.................... 	 
.................... 	return dw; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	DWORD TickConvertToMilliseconds(DWORD dwTickValue) 
....................  
....................   Summary: 
.................... 	Converts a Tick value or difference to milliseconds. 
....................  
....................   Description: 
.................... 	This function converts a Tick value or difference to milliseconds.  For 
.................... 	example, TickConvertToMilliseconds(32768) returns 1000 when a 32.768kHz  
.................... 	clock with no prescaler drives the Tick module interrupt. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	dwTickValue	- Value to convert to milliseconds 
....................  
....................   Returns: 
....................   	Input value expressed in milliseconds. 
....................  
....................   Remarks: 
.................... 	This function performs division on DWORDs, which is slow.  Avoid using 
.................... 	it unless you absolutely must (such as displaying data to a user).  For 
.................... 	timeout comparisons, compare the current value to a multiple or fraction  
.................... 	of TICK_SECOND, which will be calculated only once at compile time. 
....................   ***************************************************************************/ 
.................... DWORD TickConvertToMilliseconds(DWORD dwTickValue) 
.................... { 
.................... 	return (dwTickValue+(TICKS_PER_SECOND/2000ul))/((DWORD)(TICKS_PER_SECOND/1000ul)); 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	void TickUpdate(void) 
....................  
....................   Description: 
.................... 	Updates the tick value when an interrupt occurs. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	None 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... void TickUpdate(void) 
.................... { 
....................     if(INTCONbits.TMR0IF) 
*
00096:  BTFSS  FF2.2
00098:  BRA    00AC
....................     { 
.................... 		// Increment internal high tick counter 
.................... 		dwInternalTicks++; 
0009A:  MOVLW  01
0009C:  ADDWF  70,F
0009E:  BTFSC  FD8.0
000A0:  INCF   71,F
000A2:  BTFSC  FD8.2
000A4:  INCF   72,F
000A6:  BTFSC  FD8.2
000A8:  INCF   73,F
....................  
.................... 		// Reset interrupt flag 
....................         INTCONbits.TMR0IF = 0; 
000AA:  BCF    FF2.2
....................     } 
000AC:  GOTO   00B2 (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	void _ISR _T1Interrupt(void) 
....................  
....................   Description: 
.................... 	Updates the tick value when an interrupt occurs. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	None 
....................   ***************************************************************************/ 
.................... #elif defined(__PIC32MX__) 
.................... void __attribute((interrupt(ipl2), vector(_TIMER_1_VECTOR), nomips16)) _T1Interrupt(void) 
.................... { 
.................... 	// Increment internal high tick counter 
.................... 	dwInternalTicks++; 
....................  
.................... 	// Reset interrupt flag 
.................... 	IFS0CLR = _IFS0_T1IF_MASK; 
.................... } 
.................... #else 
.................... #if defined(__PCD__)  //__CCS__ __PCH__ __PCD__ ccs added 
.................... #int_timer1 NOCLEAR 
.................... void _T1Interrupt(void) 
.................... #elif __C30_VERSION__ >= 300 
.................... void _ISR __attribute__((__no_auto_psv__)) _T1Interrupt(void) 
.................... #else 
.................... void _ISR _T1Interrupt(void) 
.................... #endif 
.................... { 
.................... 	// Increment internal high tick counter 
.................... 	dwInternalTicks++; 
....................  
.................... 	// Reset interrupt flag 
.................... 	IFS0bits.T1IF = 0; 
.................... } 
.................... #endif 
....................  
.................... #if !defined(ENC_CS_TRIS) && !defined(WF_CS_TRIS) && !defined(ENC100_INTERFACE_MODE) && \ 
....................     (defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) || \ 
....................      defined(_18F97J60) ||  defined(_18F96J65) ||  defined(_18F96J60) ||  defined(_18F87J60) ||  defined(_18F86J65) ||  defined(_18F86J60) ||  defined(_18F67J60) ||  defined(_18F66J65) ||  defined(_18F66J60)) 
....................    #include "ETH97J60.c" 
.................... #elif defined(WF_CS_TRIS) 
....................       #include "WF_Config.c" 
....................       #if defined(WF_USE_SCAN_FUNCTIONS) 
....................          #include "WFScan.c" 
....................       #endif 
....................       #if defined(WF_USE_POWER_SAVE_FUNCTIONS) 
....................          #include "WFPowerSave.c" 
....................       #else 
....................          BOOL GetAppPowerSaveMode(void) {return(TRUE);} 
....................       #endif 
....................       #if defined(WF_USE_TX_POWER_CONTROL_FUNCTIONS) 
....................          #include "WFTxPower.c" 
....................       #endif 
....................       #include "WF_Spi.c" 
....................       #include "WF_Eint.c" 
....................       #include "WFConnectionProfile.c" 
....................       #include "WFConnectionAlgorithm.c" 
....................       #include "WFConnectionManager.c" 
....................       #include "WFEventHandler.c" 
....................       #include "WFInit.c" 
....................      #if defined(MRF24WG) 
....................       #include "WFDriverCom_24G.c" 
....................       #include "WFDriverRaw_24G.c" 
....................       #include "WFMac_24G.c" 
....................       #include "WFMgmtMsg_24G.c" 
....................       #include "WFParamMsg_24G.c"      
....................      #else 
....................       #include "WFDriverCom.c" 
....................       #include "WFDriverRaw.c" 
....................       #include "WFMac.c" 
....................       #include "WFMgmtMsg.c" 
....................       #include "WFParamMsg.c" 
....................      #endif 
.................... #elif defined(ENC_CS_TRIS) 
....................    #include "tcpip\ENC28J60.c" 
.................... /********************************************************************* 
....................  * 
....................  *  Medium Access Control (MAC) Layer for Microchip ENC28J60 
....................  *  Module for Microchip TCP/IP Stack 
....................  *   -Provides access to ENC28J60 Ethernet controller 
....................  *   -Reference: ENC28J60 Data sheet, IEEE 802.3 Standard 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.c 
....................  * Dependencies:    ENC28J60.h 
....................  *                  MAC.h 
....................  *                  string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  Delay.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder     6/28/04 Original 
....................  * Howard Schlunder     10/8/04 Cleanup 
....................  * Howard Schlunder     10/19/04 Small optimizations and more cleanup 
....................  * Howard Schlunder     11/29/04 Added Set/GetCLKOUT 
....................  * Howard Schlunder     12/23/05 Added B1 silicon errata workarounds 
....................  * Howard Schlunder     1/09/06 Added comments and minor mods 
....................  * Howard Schlunder     1/18/06 Added more silicon errata workarounds 
....................  * Howard Schlunder     6/16/06 Synchronized with PIC18F97J60 code 
....................  * Howard Schlunder     7/17/06 Updated TestMemory() for C30 
....................  * Howard Schlunder     8/07/06 Added SetRXHashTableEntry() function 
.................... ********************************************************************/ 
.................... #define __ENC28J60_C 
....................  
.................... #include "HardwareProfile.h" 
.................... // hardwareprofile.h 
....................  
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #if STACK_USE_CCS_EWLWIFIB || STACK_USE_CCS_EWLWIFIG 
....................  
....................    #bit WF_CS_TRIS1   =     0xF96.1 //E1 
....................    #define WF_CS_TRIS WF_CS_TRIS1 
....................    #bit WF_CS_IO     =  0xF8D.1    //LatE1 
....................    #bit WF_SDI_TRIS  =  0xF94.4    // (TRISCbits.TRISC4) 
....................    #bit WF_SCK_TRIS  =  0xF94.3    // (TRISCbits.TRISC3) 
....................    #bit WF_SDO_TRIS  =  0xF94.5    // (TRISCbits.TRISC5) 
....................    #bit WF_RESET_TRIS=  0xF93.1    //(TRISBbits.TRISB1) 
....................    #bit WF_RESET_IO  =  0xF8A.1     //(LATBbits.LATB1)   
....................    #bit WF_INT_TRIS  =  0xF93.0     // (TRISBbits.TRISB0)  // INT1 
....................    #bit WF_INT_IO    =  0xF81.0   //(PORTBbits.RB0)  
....................    #bit WF_HIBERNATE_TRIS= 0xF93.2  //(TRISBbits.TRISB2)  
....................    #bit   WF_HIBERNATE_IO=  0xF81.2    //(PORTBbits.RB2) 
....................     
....................    #bit WF_INT_EDGE  =  0xFF1.6      //(INTCON2bits.INTEDG0) 
....................    #bit WF_INT_IE    =  0xFF2.4   //(INTCONbits.INT0IE) 
....................    #bit WF_INT_IF    =  0xFF2.1   //(INTCONbits.INT0IF) 
....................    #define WF_SSPBUF  (SSP1BUF) 
....................    #define WF_SPISTAT  (SSP1STATbits) 
....................    #define WF_SPISTATbits SSP1STATbits     //(SSP1STATbits) 
....................    #define WF_SPICON1  (SSP1CON1bits) 
....................    #define WF_SPICON1bits WF_SPICON1    // (SSP1CON1bits) 
....................    #define WF_SPICON2  (SSP1CON2bits) 
....................    #bit WF_SPI_IE    =   0xF9D.3  //(PIE1bits.SSPIE) 
....................    #bit WF_SPI_IP    =   0xF9F.3  //(IPR1bits.SSPIP) 
....................    #bit WF_SPI_IF    =   0xF9E.3  //(PIR1bits.SSPIF) 
....................     
.................... #else 
....................  
.................... //#error define necessary hardware for TCPIP stack 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... // Make sure that this hardware profile has an ENC28J60 in it 
.................... #if defined(ENC_CS_TRIS) 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... /** D E F I N I T I O N S ****************************************************/ 
.................... // IMPORTANT SPI NOTE: The code in this file expects that the SPI interrupt 
.................... //      flag (ENC_SPI_IF) be clear at all times.  If the SPI is shared with 
.................... //      other hardware, the other code should clear the ENC_SPI_IF when it is 
.................... //      done using the SPI. 
....................  
.................... // Since the ENC28J60 doesn't support auto-negotiation, full-duplex mode is 
.................... // not compatible with most switches/routers.  If a dedicated network is used 
.................... // where the duplex of the remote node can be manually configured, you may 
.................... // change this configuration.  Otherwise, half duplex should always be used. 
.................... #define HALF_DUPLEX 
.................... //#define FULL_DUPLEX 
.................... //#define LEDB_DUPLEX 
....................  
.................... // Pseudo Functions 
.................... #define LOW(a)                  ((a) & 0xFF) 
.................... #define HIGH(a)                 (((a)>>8) & 0xFF) 
....................  
.................... // ENC28J60 Opcodes (to be ORed with a 5 bit address) 
.................... #define WCR (0x2<<5)            // Write Control Register command 
.................... #define BFS (0x4<<5)            // Bit Field Set command 
.................... #define BFC (0x5<<5)            // Bit Field Clear command 
.................... #define RCR (0x0<<5)            // Read Control Register command 
.................... #define RBM ((0x1<<5) | 0x1A)   // Read Buffer Memory command 
.................... #define WBM ((0x3<<5) | 0x1A)   // Write Buffer Memory command 
.................... #define SR  ((0x7<<5) | 0x1F)   // System Reset command does not use an address. 
....................                                 //   It requires 0x1F, however. 
....................  
.................... // Maximum SPI frequency specified in data sheet 
.................... #define ENC_MAX_SPI_FREQ    (20000000ul)    // Hz 
....................  
.................... #define ETHER_IP    (0x00u) 
.................... #define ETHER_ARP   (0x06u) 
....................  
.................... // A header appended at the start of all RX frames by the hardware 
.................... #if defined(__CCS__) 
.................... typedef struct  __attribute__((packed)) 
.................... #else 
.................... typedef struct  __attribute__((aligned(2), packed)) 
.................... #endif 
.................... { 
....................     WORD            NextPacketPointer; 
....................     RXSTATUS        StatusVector; 
....................  
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ENC_PREAMBLE; 
....................  
....................  
.................... #if defined (__18CXX) 
....................     #define ClearSPIDoneFlag()  {ENC_SPI_IF = 0;} 
....................     #define WaitForDataByte()   {while(!ENC_SPI_IF); ENC_SPI_IF = 0;} 
....................     #define SPI_ON_BIT          (ENC_SPICON1bits.SSPEN) 
.................... #elif defined(__C30__) 
....................     #define ClearSPIDoneFlag() 
....................     static inline __attribute__((__always_inline__)) void WaitForDataByte( void ) 
....................     { 
....................         while ((ENC_SPISTATbits.SPITBF == 1) || (ENC_SPISTATbits.SPIRBF == 0)); 
....................     } 
....................  
....................     #define SPI_ON_BIT          (ENC_SPISTATbits.SPIEN) 
.................... #elif defined( __PIC32MX__ ) 
....................     #define ClearSPIDoneFlag() 
....................     static inline __attribute__((__always_inline__)) void WaitForDataByte( void ) 
....................     { 
....................         while (!ENC_SPISTATbits.SPITBE || !ENC_SPISTATbits.SPIRBF); 
....................     } 
....................  
....................     #define SPI_ON_BIT          (ENC_SPICON1bits.ON) 
.................... #else 
....................     #error Determine SPI flag mechanism 
.................... #endif 
....................  
....................  
.................... // Prototypes of functions intended for MAC layer use only. 
.................... static void BankSel(WORD Register); 
.................... static REG ReadETHReg(BYTE Address); 
.................... static REG ReadMACReg(BYTE Address); 
.................... static void WriteReg(BYTE Address, BYTE Data); 
.................... static void BFCReg(BYTE Address, BYTE Data); 
.................... static void BFSReg(BYTE Address, BYTE Data); 
.................... static void SendSystemReset(void); 
.................... //static void GetRegs(void); 
.................... //void Get8KBRAM(void); 
....................  
.................... // Internal MAC level variables and flags. 
.................... static WORD_VAL NextPacketLocation; 
.................... static WORD_VAL CurrentPacketLocation; 
.................... static BOOL WasDiscarded; 
.................... static BYTE ENCRevID; 
....................  
....................  
.................... //NOTE: All code in this module expects Bank 0 to be currently selected.  If code ever changes the bank, it must restore it to Bank 0 before returning. 
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACInit sets up the PIC's SPI module and all the 
....................  *                  registers in the ENC28J60 so that normal operation can 
....................  *                  begin. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACInit(void) 
.................... { 
....................     BYTE i; 
....................  
....................     // Set up the SPI module on the PIC for communications with the ENC28J60 
....................     ENC_CS_IO = 1; 
*
00A54:  BSF    F8C.1
....................     ENC_CS_TRIS = 0;        // Make the Chip Select pin an output 
00A56:  BCF    F95.1
....................  
.................... #if defined(__18CXX) 
....................     ENC_SCK_TRIS = 0; 
00A58:  BCF    F94.3
....................     ENC_SDO_TRIS = 0; 
00A5A:  BCF    F94.5
....................     ENC_SDI_TRIS = 1; 
00A5C:  BSF    F94.4
.................... #endif 
....................  
....................     // If the RESET pin is connected, take the chip out of reset 
.................... #if defined(ENC_RST_IO) 
....................     ENC_RST_IO      = 1; 
....................     ENC_RST_TRIS    = 0; 
.................... #endif 
....................  
....................     // Set up SPI 
....................     ClearSPIDoneFlag(); 
00A5E:  BCF    F9E.3
.................... #if defined(__18CXX) 
....................     ENC_SPICON1 = 0x20;     // SSPEN bit is set, SPI in master mode, FOSC/4, 
00A60:  MOVLW  20
00A62:  MOVWF  FC6
....................                             //   IDLE state is low level 
....................     ENC_SPISTATbits.CKE = 1;// Transmit data on rising edge of clock 
00A64:  BSF    FC7.6
....................     ENC_SPISTATbits.SMP = 0;// Input sampled at middle of data output time 
00A66:  BCF    FC7.7
.................... #elif defined(__C30__) 
....................     ENC_SPISTAT = 0;        // clear SPI 
....................     #if defined(__PIC24H__) || defined(__dsPIC33F__) || defined(__dsPIC33E__)|| defined(__PIC24E__) 
....................         ENC_SPICON1 = 0x0F;     // 1:1 primary prescale, 5:1 secondary prescale (8MHz  @ 40MIPS) 
....................     //    ENC_SPICON1 = 0x1E;   // 4:1 primary prescale, 1:1 secondary prescale (10MHz @ 40MIPS, Doesn't work.  CLKRDY is incorrectly reported as being clear.  Problem caused by dsPIC33/PIC24H ES silicon bug.) 
....................     #elif defined(__PIC24F__) || defined(__PIC24FK__) 
....................         ENC_SPICON1 = 0x1B;     // 1:1 primary prescale, 2:1 secondary prescale (8MHz  @ 16MIPS) 
....................     #else   // dsPIC30F 
....................         ENC_SPICON1 = 0x17;     // 1:1 primary prescale, 3:1 secondary prescale (10MHz @ 30MIPS) 
....................     #endif 
....................     ENC_SPICON2 = 0; 
....................     ENC_SPICON1bits.CKE = 1; 
....................     ENC_SPICON1bits.MSTEN = 1; 
....................     ENC_SPISTATbits.SPIEN = 1; 
.................... #elif defined(__C32__) 
....................     ENC_SPIBRG = (GetPeripheralClock()-1ul)/2ul/ENC_MAX_SPI_FREQ; 
....................    ENC_SPICON1bits.SMP = 1;   // Delay SDI input sampling (PIC perspective) by 1/2 SPI clock 
....................     ENC_SPICON1bits.CKE = 1; 
....................     ENC_SPICON1bits.MSTEN = 1; 
....................     ENC_SPICON1bits.ON = 1; 
.................... #endif 
....................  
....................     // RESET the entire ENC28J60, clearing all registers 
....................     // Also wait for CLKRDY to become set. 
....................     // Bit 3 in ESTAT is an unimplemented bit.  If it reads out as '1' that 
....................     // means the part is in RESET or there is something wrong with the SPI 
....................     // connection.  This loop makes sure that we can communicate with the 
....................     // ENC28J60 before proceeding. 
....................     do 
....................     { 
....................         SendSystemReset(); 
00A68:  BRA    086E
....................         i = ReadETHReg(ESTAT).Val; 
00A6A:  MOVLW  1D
00A6C:  MOVLB  3
00A6E:  MOVWF  x80
00A70:  MOVLB  0
00A72:  RCALL  08A6
00A74:  MOVFF  01,2E3
....................     } while((i & 0x08) || (~i & ESTAT_CLKRDY)); 
00A78:  MOVLB  2
00A7A:  BTFSS  xE3.3
00A7C:  BRA    0A82
00A7E:  MOVLB  0
00A80:  BRA    0A68
00A82:  MOVF   xE3,W
00A84:  XORLW  FF
00A86:  ANDLW  01
00A88:  BTFSC  FD8.2
00A8A:  BRA    0A90
00A8C:  MOVLB  0
00A8E:  BRA    0A68
....................  
....................     // Start up in Bank 0 and configure the receive buffer boundary pointers 
....................     // and the buffer write protect pointer (receive buffer read pointer) 
....................     WasDiscarded = TRUE; 
00A90:  BSF    67.1
....................     NextPacketLocation.Val = RXSTART; 
00A92:  CLRF   7B
00A94:  CLRF   7A
....................  
....................     WriteReg(ERXSTL, LOW(RXSTART)); 
00A96:  MOVLW  08
00A98:  MOVLB  3
00A9A:  MOVWF  x85
00A9C:  CLRF   x86
00A9E:  MOVLB  0
00AA0:  RCALL  08D0
....................     WriteReg(ERXSTH, HIGH(RXSTART)); 
00AA2:  MOVLW  09
00AA4:  MOVLB  3
00AA6:  MOVWF  x85
00AA8:  CLRF   x86
00AAA:  MOVLB  0
00AAC:  RCALL  08D0
....................     WriteReg(ERXRDPTL, LOW(RXSTOP));    // Write low byte first 
00AAE:  MOVLW  0C
00AB0:  MOVLB  3
00AB2:  MOVWF  x85
00AB4:  MOVLW  D5
00AB6:  MOVWF  x86
00AB8:  MOVLB  0
00ABA:  RCALL  08D0
....................     WriteReg(ERXRDPTH, HIGH(RXSTOP));   // Write high byte last 
00ABC:  MOVLW  0D
00ABE:  MOVLB  3
00AC0:  MOVWF  x85
00AC2:  MOVLW  11
00AC4:  MOVWF  x86
00AC6:  MOVLB  0
00AC8:  RCALL  08D0
....................     WriteReg(ERXNDL, LOW(RXSTOP)); 
00ACA:  MOVLW  0A
00ACC:  MOVLB  3
00ACE:  MOVWF  x85
00AD0:  MOVLW  D5
00AD2:  MOVWF  x86
00AD4:  MOVLB  0
00AD6:  RCALL  08D0
....................     WriteReg(ERXNDH, HIGH(RXSTOP)); 
00AD8:  MOVLW  0B
00ADA:  MOVLB  3
00ADC:  MOVWF  x85
00ADE:  MOVLW  11
00AE0:  MOVWF  x86
00AE2:  MOVLB  0
00AE4:  RCALL  08D0
....................     WriteReg(ETXSTL, LOW(TXSTART)); 
00AE6:  MOVLW  04
00AE8:  MOVLB  3
00AEA:  MOVWF  x85
00AEC:  MOVLW  D6
00AEE:  MOVWF  x86
00AF0:  MOVLB  0
00AF2:  RCALL  08D0
....................     WriteReg(ETXSTH, HIGH(TXSTART)); 
00AF4:  MOVLW  05
00AF6:  MOVLB  3
00AF8:  MOVWF  x85
00AFA:  MOVLW  11
00AFC:  MOVWF  x86
00AFE:  MOVLB  0
00B00:  RCALL  08D0
....................  
....................     // Write a permanant per packet control byte of 0x00 
....................     WriteReg(EWRPTL, LOW(TXSTART)); 
00B02:  MOVLW  02
00B04:  MOVLB  3
00B06:  MOVWF  x85
00B08:  MOVLW  D6
00B0A:  MOVWF  x86
00B0C:  MOVLB  0
00B0E:  RCALL  08D0
....................     WriteReg(EWRPTH, HIGH(TXSTART)); 
00B10:  MOVLW  03
00B12:  MOVLB  3
00B14:  MOVWF  x85
00B16:  MOVLW  11
00B18:  MOVWF  x86
00B1A:  MOVLB  0
00B1C:  RCALL  08D0
....................     MACPut(0x00); 
00B1E:  MOVLB  3
00B20:  CLRF   x83
00B22:  MOVLB  0
00B24:  RCALL  08FA
....................  
....................  
....................     // Enter Bank 1 and configure Receive Filters 
....................     // (No need to reconfigure - Unicast OR Broadcast with CRC checking is 
....................     // acceptable) 
....................     // Write ERXFCON_CRCEN only to ERXFCON to enter promiscuous mode 
....................  
....................     // Promiscious mode example: 
....................     //BankSel(ERXFCON); 
....................     //WriteReg((BYTE)ERXFCON, ERXFCON_CRCEN); 
....................  
....................     // Enter Bank 2 and configure the MAC 
....................     BankSel(MACON1); 
00B26:  MOVLW  02
00B28:  MOVLB  3
00B2A:  MOVWF  x65
00B2C:  CLRF   x64
00B2E:  MOVLB  0
00B30:  RCALL  0948
....................  
....................     // Enable the receive portion of the MAC 
....................     WriteReg((BYTE)MACON1, MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN); 
00B32:  MOVLB  3
00B34:  CLRF   x85
00B36:  MOVLW  0D
00B38:  MOVWF  x86
00B3A:  MOVLB  0
00B3C:  RCALL  08D0
....................  
....................     // Pad packets to 60 bytes, add CRC, and check Type/Length field. 
.................... #if defined(FULL_DUPLEX) 
....................     WriteReg((BYTE)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN | MACON3_FULDPX); 
....................     WriteReg((BYTE)MABBIPG, 0x15); 
.................... #else 
....................     WriteReg((BYTE)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN); 
00B3E:  MOVLW  02
00B40:  MOVLB  3
00B42:  MOVWF  x85
00B44:  MOVLW  32
00B46:  MOVWF  x86
00B48:  MOVLB  0
00B4A:  RCALL  08D0
....................     WriteReg((BYTE)MABBIPG, 0x12); 
00B4C:  MOVLW  04
00B4E:  MOVLB  3
00B50:  MOVWF  x85
00B52:  MOVLW  12
00B54:  MOVWF  x86
00B56:  MOVLB  0
00B58:  RCALL  08D0
.................... #endif 
....................  
....................     // Allow infinite deferals if the medium is continuously busy 
....................     // (do not time out a transmission if the half duplex medium is 
....................     // completely saturated with other people's data) 
....................     WriteReg((BYTE)MACON4, MACON4_DEFER); 
00B5A:  MOVLW  03
00B5C:  MOVLB  3
00B5E:  MOVWF  x85
00B60:  MOVLW  40
00B62:  MOVWF  x86
00B64:  MOVLB  0
00B66:  RCALL  08D0
....................  
....................     // Late collisions occur beyond 63+8 bytes (8 bytes for preamble/start of frame delimiter) 
....................     // 55 is all that is needed for IEEE 802.3, but ENC28J60 B5 errata for improper link pulse 
....................     // collisions will occur less often with a larger number. 
....................     WriteReg((BYTE)MACLCON2, 63); 
00B68:  MOVLW  09
00B6A:  MOVLB  3
00B6C:  MOVWF  x85
00B6E:  MOVLW  3F
00B70:  MOVWF  x86
00B72:  MOVLB  0
00B74:  RCALL  08D0
....................  
....................     // Set non-back-to-back inter-packet gap to 9.6us.  The back-to-back 
....................     // inter-packet gap (MABBIPG) is set by MACSetDuplex() which is called 
....................     // later. 
....................     WriteReg((BYTE)MAIPGL, 0x12); 
00B76:  MOVLW  06
00B78:  MOVLB  3
00B7A:  MOVWF  x85
00B7C:  MOVLW  12
00B7E:  MOVWF  x86
00B80:  MOVLB  0
00B82:  RCALL  08D0
....................     WriteReg((BYTE)MAIPGH, 0x0C); 
00B84:  MOVLW  07
00B86:  MOVLB  3
00B88:  MOVWF  x85
00B8A:  MOVLW  0C
00B8C:  MOVWF  x86
00B8E:  MOVLB  0
00B90:  RCALL  08D0
....................  
....................     // Set the maximum packet size which the controller will accept 
....................     WriteReg((BYTE)MAMXFLL, LOW(6+6+2+1500+4));  // 1518 is the IEEE 802.3 specified limit 
00B92:  MOVLW  0A
00B94:  MOVLB  3
00B96:  MOVWF  x85
00B98:  MOVLW  EE
00B9A:  MOVWF  x86
00B9C:  MOVLB  0
00B9E:  RCALL  08D0
....................     WriteReg((BYTE)MAMXFLH, HIGH(6+6+2+1500+4)); // 1518 is the IEEE 802.3 specified limit 
00BA0:  MOVLW  0B
00BA2:  MOVLB  3
00BA4:  MOVWF  x85
00BA6:  MOVLW  05
00BA8:  MOVWF  x86
00BAA:  MOVLB  0
00BAC:  RCALL  08D0
....................  
....................     // Enter Bank 3 and initialize physical MAC address registers 
....................     BankSel(MAADR1); 
00BAE:  MOVLW  03
00BB0:  MOVLB  3
00BB2:  MOVWF  x65
00BB4:  MOVLW  04
00BB6:  MOVWF  x64
00BB8:  MOVLB  0
00BBA:  RCALL  0948
....................     WriteReg((BYTE)MAADR1, AppConfig.MyMACAddr.v[0]); 
00BBC:  MOVLW  04
00BBE:  MOVLB  3
00BC0:  MOVWF  x85
00BC2:  MOVFF  56,386
00BC6:  MOVLB  0
00BC8:  RCALL  08D0
....................     WriteReg((BYTE)MAADR2, AppConfig.MyMACAddr.v[1]); 
00BCA:  MOVLW  05
00BCC:  MOVLB  3
00BCE:  MOVWF  x85
00BD0:  MOVFF  57,386
00BD4:  MOVLB  0
00BD6:  RCALL  08D0
....................     WriteReg((BYTE)MAADR3, AppConfig.MyMACAddr.v[2]); 
00BD8:  MOVLW  02
00BDA:  MOVLB  3
00BDC:  MOVWF  x85
00BDE:  MOVFF  58,386
00BE2:  MOVLB  0
00BE4:  RCALL  08D0
....................     WriteReg((BYTE)MAADR4, AppConfig.MyMACAddr.v[3]); 
00BE6:  MOVLW  03
00BE8:  MOVLB  3
00BEA:  MOVWF  x85
00BEC:  MOVFF  59,386
00BF0:  MOVLB  0
00BF2:  RCALL  08D0
....................     WriteReg((BYTE)MAADR5, AppConfig.MyMACAddr.v[4]); 
00BF4:  MOVLB  3
00BF6:  CLRF   x85
00BF8:  MOVFF  5A,386
00BFC:  MOVLB  0
00BFE:  RCALL  08D0
....................     WriteReg((BYTE)MAADR6, AppConfig.MyMACAddr.v[5]); 
00C00:  MOVLW  01
00C02:  MOVLB  3
00C04:  MOVWF  x85
00C06:  MOVFF  5B,386
00C0A:  MOVLB  0
00C0C:  RCALL  08D0
....................  
....................     // Disable the CLKOUT output to reduce EMI generation 
....................     WriteReg((BYTE)ECOCON, 0x00);   // Output off (0V) 
00C0E:  MOVLW  15
00C10:  MOVLB  3
00C12:  MOVWF  x85
00C14:  CLRF   x86
00C16:  MOVLB  0
00C18:  RCALL  08D0
....................     //WriteReg((BYTE)ECOCON, 0x01); // 25.000MHz 
....................     //WriteReg((BYTE)ECOCON, 0x03); // 8.3333MHz (*4 with PLL is 33.3333MHz) 
....................  
....................     // Get the Rev ID so that we can implement the correct errata workarounds 
....................     ENCRevID = ReadETHReg((BYTE)EREVID).Val; 
00C1A:  MOVLW  12
00C1C:  MOVLB  3
00C1E:  MOVWF  x80
00C20:  MOVLB  0
00C22:  RCALL  08A6
00C24:  MOVFF  01,7E
....................  
....................     // Disable half duplex loopback in PHY.  Bank bits changed to Bank 2 as a 
....................     // side effect. 
....................     WritePHYReg(PHCON2, PHCON2_HDLDIS); 
00C28:  MOVLW  10
00C2A:  MOVLB  2
00C2C:  MOVWF  xE4
00C2E:  MOVLW  01
00C30:  MOVWF  xE6
00C32:  CLRF   xE5
00C34:  MOVLB  0
00C36:  RCALL  09B4
....................  
....................     // Configure LEDA to display LINK status, LEDB to display TX/RX activity 
....................     SetLEDConfig(0x3472); 
00C38:  MOVLW  14
00C3A:  MOVLB  2
00C3C:  MOVWF  xE4
00C3E:  MOVLW  34
00C40:  MOVWF  xE6
00C42:  MOVLW  72
00C44:  MOVWF  xE5
00C46:  MOVLB  0
00C48:  RCALL  09B4
....................  
....................     // Set the MAC and PHY into the proper duplex state 
.................... #if defined(FULL_DUPLEX) 
....................     WritePHYReg(PHCON1, PHCON1_PDPXMD); 
.................... #elif defined(HALF_DUPLEX) 
....................     WritePHYReg(PHCON1, 0x0000); 
00C4A:  MOVLB  2
00C4C:  CLRF   xE4
00C4E:  CLRF   xE6
00C50:  CLRF   xE5
00C52:  MOVLB  0
00C54:  RCALL  09B4
.................... #else 
....................     // Use the external LEDB polarity to determine weather full or half duplex 
....................     // communication mode should be set. 
....................     { 
....................         REG Register; 
....................         PHYREG PhyReg; 
....................  
....................         // Read the PHY duplex mode 
....................         PhyReg = ReadPHYReg(PHCON1); 
....................         DuplexState = PhyReg.PHCON1bits.PDPXMD; 
....................  
....................         // Set the MAC to the proper duplex mode 
....................         BankSel(MACON3); 
....................         Register = ReadMACReg((BYTE)MACON3); 
....................         Register.MACON3bits.FULDPX = PhyReg.PHCON1bits.PDPXMD; 
....................         WriteReg((BYTE)MACON3, Register.Val); 
....................  
....................         // Set the back-to-back inter-packet gap time to IEEE specified 
....................         // requirements.  The meaning of the MABBIPG value changes with the duplex 
....................         // state, so it must be updated in this function. 
....................         // In full duplex, 0x15 represents 9.6us; 0x12 is 9.6us in half duplex 
....................         WriteReg((BYTE)MABBIPG, PhyReg.PHCON1bits.PDPXMD ? 0x15 : 0x12); 
....................     } 
.................... #endif 
....................  
....................     BankSel(ERDPTL);        // Return to default Bank 0 
00C56:  MOVLB  3
00C58:  CLRF   x65
00C5A:  CLRF   x64
00C5C:  MOVLB  0
00C5E:  RCALL  0948
....................  
....................     // Enable packet reception 
....................     BFSReg(ECON1, ECON1_RXEN); 
00C60:  MOVLW  1F
00C62:  MOVLB  3
00C64:  MOVWF  x7A
00C66:  MOVLW  04
00C68:  MOVWF  x7B
00C6A:  MOVLB  0
00C6C:  RCALL  091E
00C6E:  GOTO   2B1C (RETURN)
.................... }//end MACInit 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsLinked(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: If the PHY reports that a link partner is present 
....................  *                        and the link has been up continuously since the last 
....................  *                        call to MACIsLinked() 
....................  *                  FALSE: If the PHY reports no link partner, or the link went 
....................  *                         down momentarily since the last call to MACIsLinked() 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the PHSTAT1.LLSTAT bit. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsLinked(void) 
.................... { 
....................     // LLSTAT is a latching low link status bit.  Therefore, if the link 
....................     // goes down and comes back up before a higher level stack program calls 
....................     // MACIsLinked(), MACIsLinked() will still return FALSE.  The next 
....................     // call to MACIsLinked() will return TRUE (unless the link goes down 
....................     // again). 
....................     return ReadPHYReg(PHSTAT1).PHSTAT1bits.LLSTAT; 
*
05C16:  MOVLW  01
05C18:  MOVLB  2
05C1A:  MOVWF  xE3
05C1C:  MOVLB  0
05C1E:  BRA    5B5A
05C20:  MOVFF  01,2E3
05C24:  MOVLW  00
05C26:  MOVLB  2
05C28:  BTFSC  01.2
05C2A:  MOVLW  01
05C2C:  MOVWF  01
05C2E:  MOVLB  0
05C30:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsTxReady(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: If no Ethernet transmission is in progress 
....................  *                  FALSE: If a previous transmission was started, and it has 
....................  *                         not completed yet.  While FALSE, the data in the 
....................  *                         transmit buffer and the TXST/TXND pointers must not 
....................  *                         be changed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the ECON1.TXRTS bit 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsTxReady(void) 
.................... { 
....................     return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
*
01656:  MOVLW  1F
01658:  MOVLB  3
0165A:  MOVWF  x80
0165C:  MOVLB  0
0165E:  CALL   08A6
01662:  MOVFF  01,360
01666:  MOVLW  00
01668:  MOVLB  3
0166A:  BTFSC  01.3
0166C:  MOVLW  01
0166E:  XORLW  00
01670:  BZ    1676
01672:  MOVLW  00
01674:  BRA    1678
01676:  MOVLW  01
01678:  MOVWF  01
0167A:  MOVLB  0
0167C:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDiscardRx(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Marks the last received packet (obtained using 
....................  *                  MACGetHeader())as being processed and frees the buffer 
....................  *                  memory associated with it 
....................  * 
....................  * Note:            Is is safe to call this function multiple times between 
....................  *                  MACGetHeader() calls.  Extra packets won't be thrown away 
....................  *                  until MACGetHeader() makes it available. 
....................  *****************************************************************************/ 
.................... void MACDiscardRx(void) 
.................... { 
....................     WORD_VAL NewRXRDLocation; 
....................  
....................     // Make sure the current packet was not already discarded 
....................     if(WasDiscarded) 
*
03920:  BTFSS  67.1
03922:  BRA    3926
....................         return; 
03924:  BRA    397C
....................     WasDiscarded = TRUE; 
03926:  BSF    67.1
....................  
....................     // Decrement the next packet pointer before writing it into 
....................     // the ERXRDPT registers.  This is a silicon errata workaround. 
....................     // RX buffer wrapping must be taken into account if the 
....................     // NextPacketLocation is precisely RXSTART. 
....................     NewRXRDLocation.Val = NextPacketLocation.Val - 1; 
03928:  MOVLW  01
0392A:  SUBWF  7A,W
0392C:  MOVLB  3
0392E:  MOVWF  x16
03930:  MOVLW  00
03932:  SUBWFB 7B,W
03934:  MOVWF  x17
....................     if(NewRXRDLocation.Val > RXSTOP) 
03936:  MOVF   x17,W
03938:  SUBLW  10
0393A:  BC    394E
0393C:  XORLW  FF
0393E:  BNZ   3946
03940:  MOVF   x16,W
03942:  SUBLW  D5
03944:  BC    394E
....................     { 
....................         NewRXRDLocation.Val = RXSTOP; 
03946:  MOVLW  11
03948:  MOVWF  x17
0394A:  MOVLW  D5
0394C:  MOVWF  x16
....................     } 
....................  
....................     // Decrement the RX packet counter register, EPKTCNT 
....................     BFSReg(ECON2, ECON2_PKTDEC); 
0394E:  MOVLW  1E
03950:  MOVWF  x7A
03952:  MOVLW  40
03954:  MOVWF  x7B
03956:  MOVLB  0
03958:  CALL   091E
....................  
....................     // Move the receive read pointer to unwrite-protect the memory used by the 
....................     // last packet.  The writing order is important: set the low byte first, 
....................     // high byte last. 
....................     WriteReg(ERXRDPTL, NewRXRDLocation.v[0]); 
0395C:  MOVLW  0C
0395E:  MOVLB  3
03960:  MOVWF  x85
03962:  MOVFF  316,386
03966:  MOVLB  0
03968:  CALL   08D0
....................     WriteReg(ERXRDPTH, NewRXRDLocation.v[1]); 
0396C:  MOVLW  0D
0396E:  MOVLB  3
03970:  MOVWF  x85
03972:  MOVFF  317,386
03976:  MOVLB  0
03978:  CALL   08D0
0397C:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetFreeRxSize(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          A WORD estimate of how much RX buffer space is free at 
....................  *                  the present time. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetFreeRxSize(void) 
.................... { 
....................     WORD_VAL ReadPT, WritePT; 
....................  
....................     // Read the Ethernet hardware buffer write pointer.  Because packets can be 
....................     // received at any time, it can change between reading the low and high 
....................     // bytes.  A loop is necessary to make certain a proper low/high byte pair 
....................     // is read. 
....................     BankSel(EPKTCNT); 
*
0167E:  MOVLW  01
01680:  MOVLB  3
01682:  MOVWF  x65
01684:  MOVLW  19
01686:  MOVWF  x64
01688:  MOVLB  0
0168A:  CALL   0948
....................     do { 
....................         // Save EPKTCNT in a temporary location 
....................         ReadPT.v[0] = ReadETHReg((BYTE)EPKTCNT).Val; 
0168E:  MOVLW  19
01690:  MOVLB  3
01692:  MOVWF  x80
01694:  MOVLB  0
01696:  CALL   08A6
0169A:  MOVFF  01,360
....................  
....................         BankSel(ERXWRPTL); 
0169E:  MOVLB  3
016A0:  CLRF   x65
016A2:  MOVLW  0E
016A4:  MOVWF  x64
016A6:  MOVLB  0
016A8:  CALL   0948
....................         WritePT.v[0] = ReadETHReg(ERXWRPTL).Val; 
016AC:  MOVLW  0E
016AE:  MOVLB  3
016B0:  MOVWF  x80
016B2:  MOVLB  0
016B4:  CALL   08A6
016B8:  MOVFF  01,362
....................         WritePT.v[1] = ReadETHReg(ERXWRPTH).Val; 
016BC:  MOVLW  0F
016BE:  MOVLB  3
016C0:  MOVWF  x80
016C2:  MOVLB  0
016C4:  CALL   08A6
016C8:  MOVFF  01,363
....................  
....................         BankSel(EPKTCNT); 
016CC:  MOVLW  01
016CE:  MOVLB  3
016D0:  MOVWF  x65
016D2:  MOVLW  19
016D4:  MOVWF  x64
016D6:  MOVLB  0
016D8:  CALL   0948
....................     } while(ReadETHReg((BYTE)EPKTCNT).Val != ReadPT.v[0]); 
016DC:  MOVLW  19
016DE:  MOVLB  3
016E0:  MOVWF  x80
016E2:  MOVLB  0
016E4:  CALL   08A6
016E8:  MOVFF  01,364
016EC:  MOVLB  3
016EE:  MOVF   x60,W
016F0:  SUBWF  01,W
016F2:  BTFSC  FD8.2
016F4:  BRA    16FA
016F6:  MOVLB  0
016F8:  BRA    168E
....................  
....................     // Determine where the write protection pointer is 
....................     BankSel(ERXRDPTL); 
016FA:  CLRF   x65
016FC:  MOVLW  0C
016FE:  MOVWF  x64
01700:  MOVLB  0
01702:  CALL   0948
....................     ReadPT.v[0] = ReadETHReg(ERXRDPTL).Val; 
01706:  MOVLW  0C
01708:  MOVLB  3
0170A:  MOVWF  x80
0170C:  MOVLB  0
0170E:  CALL   08A6
01712:  MOVFF  01,360
....................     ReadPT.v[1] = ReadETHReg(ERXRDPTH).Val; 
01716:  MOVLW  0D
01718:  MOVLB  3
0171A:  MOVWF  x80
0171C:  MOVLB  0
0171E:  CALL   08A6
01722:  MOVFF  01,361
....................  
....................     // Calculate the difference between the pointers, taking care to account 
....................     // for buffer wrapping conditions 
....................     if(WritePT.Val > ReadPT.Val) 
01726:  MOVLB  3
01728:  MOVF   x61,W
0172A:  SUBWF  x63,W
0172C:  BNC   175A
0172E:  BNZ   1736
01730:  MOVF   x62,W
01732:  SUBWF  x60,W
01734:  BC    175A
....................     { 
....................         return (RXSTOP - RXSTART) - (WritePT.Val - ReadPT.Val); 
01736:  MOVF   x60,W
01738:  SUBWF  x62,W
0173A:  MOVWF  00
0173C:  MOVF   x61,W
0173E:  SUBWFB x63,W
01740:  MOVWF  03
01742:  MOVF   00,W
01744:  XORLW  FF
01746:  ADDLW  D6
01748:  MOVWF  00
0174A:  MOVLW  11
0174C:  SUBFWB 03,F
0174E:  MOVFF  00,01
01752:  MOVFF  03,02
01756:  BRA    1790
....................     } 
01758:  BRA    1790
....................     else if(WritePT.Val == ReadPT.Val) 
0175A:  MOVF   x60,W
0175C:  SUBWF  x62,W
0175E:  BNZ   1772
01760:  MOVF   x61,W
01762:  SUBWF  x63,W
01764:  BNZ   1772
....................     { 
....................         return RXSIZE - 1; 
01766:  MOVLW  D5
01768:  MOVWF  01
0176A:  MOVLW  11
0176C:  MOVWF  02
0176E:  BRA    1790
....................     } 
01770:  BRA    1790
....................     else 
....................     { 
....................         return ReadPT.Val - WritePT.Val - 1; 
01772:  MOVF   x62,W
01774:  SUBWF  x60,W
01776:  MOVWF  x64
01778:  MOVF   x63,W
0177A:  SUBWFB x61,W
0177C:  MOVWF  x65
0177E:  MOVLW  01
01780:  SUBWF  x64,W
01782:  MOVWF  00
01784:  MOVLW  00
01786:  SUBWFB x65,W
01788:  MOVWF  03
0178A:  MOVFF  00,01
0178E:  MOVWF  02
....................     } 
01790:  MOVLB  0
01792:  GOTO   26E2 (RETURN)
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           *remote: Location to store the Source MAC address of the 
....................  *                           received frame. 
....................  *                  *type: Location of a BYTE to store the constant 
....................  *                         MAC_UNKNOWN, ETHER_IP, or ETHER_ARP, representing 
....................  *                         the contents of the Ethernet type field. 
....................  * 
....................  * Output:          TRUE: If a packet was waiting in the RX buffer.  The 
....................  *                        remote, and type values are updated. 
....................  *                  FALSE: If a packet was not pending.  remote and type are 
....................  *                         not changed. 
....................  * 
....................  * Side Effects:    Last packet is discarded if MACDiscardRx() hasn't already 
....................  *                  been called. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
.................... { 
....................     ENC_PREAMBLE header; 
....................     BYTE PacketCount; 
....................  
....................     // Test if at least one packet has been received and is waiting 
....................     BankSel(EPKTCNT); 
*
0397E:  MOVLW  01
03980:  MOVLB  3
03982:  MOVWF  x65
03984:  MOVLW  19
03986:  MOVWF  x64
03988:  MOVLB  0
0398A:  CALL   0948
....................     PacketCount = ReadETHReg((BYTE)EPKTCNT).Val; 
0398E:  MOVLW  19
03990:  MOVLB  3
03992:  MOVWF  x80
03994:  MOVLB  0
03996:  CALL   08A6
0399A:  MOVFF  01,303
....................     BankSel(ERDPTL); 
0399E:  MOVLB  3
039A0:  CLRF   x65
039A2:  CLRF   x64
039A4:  MOVLB  0
039A6:  CALL   0948
....................     if(PacketCount == 0u) 
039AA:  MOVLB  3
039AC:  MOVF   x03,F
039AE:  BNZ   39B6
....................         return FALSE; 
039B0:  MOVLW  00
039B2:  MOVWF  01
039B4:  BRA    3AD0
....................  
....................     // Make absolutely certain that any previous packet was discarded 
....................     if(WasDiscarded == FALSE) 
039B6:  BTFSC  67.1
039B8:  BRA    39C6
....................     { 
....................         MACDiscardRx(); 
039BA:  MOVLB  0
039BC:  RCALL  3920
....................         return FALSE; 
039BE:  MOVLW  00
039C0:  MOVWF  01
039C2:  MOVLB  3
039C4:  BRA    3AD0
....................     } 
....................  
....................     // Set the SPI read pointer to the beginning of the next unprocessed packet 
....................     CurrentPacketLocation.Val = NextPacketLocation.Val; 
039C6:  MOVFF  7B,7D
039CA:  MOVFF  7A,7C
....................     WriteReg(ERDPTL, CurrentPacketLocation.v[0]); 
039CE:  CLRF   x85
039D0:  MOVFF  7C,386
039D4:  MOVLB  0
039D6:  CALL   08D0
....................     WriteReg(ERDPTH, CurrentPacketLocation.v[1]); 
039DA:  MOVLW  01
039DC:  MOVLB  3
039DE:  MOVWF  x85
039E0:  MOVFF  7D,386
039E4:  MOVLB  0
039E6:  CALL   08D0
....................  
....................     // Obtain the MAC header from the Ethernet buffer 
....................     MACGetArray((BYTE*)&header, sizeof(header)); 
039EA:  MOVLW  02
039EC:  MOVLB  3
039EE:  MOVWF  x05
039F0:  MOVLW  EF
039F2:  MOVWF  x04
039F4:  MOVFF  305,383
039F8:  MOVWF  x82
039FA:  CLRF   x85
039FC:  MOVLW  14
039FE:  MOVWF  x84
03A00:  MOVLB  0
03A02:  CALL   0E68
....................  
....................     // The EtherType field, like most items transmitted on the Ethernet medium 
....................     // are in big endian. 
....................     header.Type.Val = swaps(header.Type.Val); 
03A06:  MOVFF  302,380
03A0A:  MOVFF  301,37F
03A0E:  CALL   1796
03A12:  MOVFF  02,302
03A16:  MOVFF  01,301
....................  
....................     // Validate the data returned from the ENC28J60.  Random data corruption, 
....................     // such as if a single SPI bit error occurs while communicating or a 
....................     // momentary power glitch could cause this to occur in rare circumstances. 
....................     if(header.NextPacketPointer > RXSTOP || ((BYTE_VAL*)(&header.NextPacketPointer))->bits.b0 || 
....................        header.StatusVector.bits.Zero || 
....................        header.StatusVector.bits.CRCError || 
....................        header.StatusVector.bits.ByteCount > 1518u || 
....................        !header.StatusVector.bits.ReceiveOk) 
03A1A:  MOVLB  2
03A1C:  MOVF   xF0,W
03A1E:  SUBLW  10
03A20:  BC    3A2C
03A22:  XORLW  FF
03A24:  BNZ   3A60
03A26:  MOVF   xEF,W
03A28:  SUBLW  D5
03A2A:  BNC   3A60
03A2C:  MOVLW  02
03A2E:  MOVLB  3
03A30:  MOVWF  x05
03A32:  MOVLW  EF
03A34:  MOVWF  FE9
03A36:  MOVFF  305,FEA
03A3A:  BTFSS  FEF.0
03A3C:  BRA    3A42
03A3E:  MOVLB  2
03A40:  BRA    3A60
03A42:  MOVLB  2
03A44:  BTFSC  xF4.7
03A46:  BRA    3A60
03A48:  BTFSC  xF3.4
03A4A:  BRA    3A60
03A4C:  MOVF   xF2,W
03A4E:  SUBLW  04
03A50:  BC    3A5C
03A52:  XORLW  FF
03A54:  BNZ   3A60
03A56:  MOVF   xF1,W
03A58:  SUBLW  EE
03A5A:  BNC   3A60
03A5C:  BTFSC  xF3.7
03A5E:  BRA    3A62
....................     { 
....................         Reset(); 
03A60:  RESET
....................     } 
....................  
....................     // Save the location where the hardware will write the next packet to 
....................     NextPacketLocation.Val = header.NextPacketPointer; 
03A62:  MOVFF  2F0,7B
03A66:  MOVFF  2EF,7A
....................  
....................     // Return the Ethernet frame's Source MAC address field to the caller 
....................     // This parameter is useful for replying to requests without requiring an 
....................     // ARP cycle. 
....................     memcpy((void*)remote->v, (void*)header.SourceMACAddr.v, sizeof(*remote)); 
03A6A:  MOVFF  2EC,03
03A6E:  MOVFF  2EB,304
03A72:  MOVLB  3
03A74:  MOVFF  2EC,305
03A78:  MOVLW  02
03A7A:  MOVWF  x07
03A7C:  MOVLW  FB
03A7E:  MOVFF  2EC,FEA
03A82:  MOVFF  2EB,FE9
03A86:  MOVFF  307,FE2
03A8A:  MOVWF  FE1
03A8C:  MOVLW  06
03A8E:  MOVWF  01
03A90:  MOVFF  FE6,FEE
03A94:  DECFSZ 01,F
03A96:  BRA    3A90
....................  
....................     // Return a simplified version of the EtherType field to the caller 
....................     *type = MAC_UNKNOWN; 
03A98:  MOVFF  2EE,03
03A9C:  MOVLB  2
03A9E:  MOVF   xED,W
03AA0:  MOVWF  FE9
03AA2:  MOVFF  03,FEA
03AA6:  SETF   FEF
....................     if( (header.Type.v[1] == 0x08u) && 
....................         ((header.Type.v[0] == ETHER_IP) || (header.Type.v[0] == ETHER_ARP)) ) 
03AA8:  MOVLB  3
03AAA:  MOVF   x02,W
03AAC:  SUBLW  08
03AAE:  BNZ   3ACA
03AB0:  MOVF   x01,F
03AB2:  BZ    3ABA
03AB4:  MOVF   x01,W
03AB6:  SUBLW  06
03AB8:  BNZ   3ACA
....................     { 
....................         *type = header.Type.v[0]; 
03ABA:  MOVLB  2
03ABC:  MOVFF  2ED,FE9
03AC0:  MOVFF  2EE,FEA
03AC4:  MOVFF  301,FEF
03AC8:  MOVLB  3
....................     } 
....................  
....................     // Mark this packet as discardable 
....................     WasDiscarded = FALSE; 
03ACA:  BCF    67.1
....................     return TRUE; 
03ACC:  MOVLW  01
03ACE:  MOVWF  01
03AD0:  MOVLB  0
03AD2:  GOTO   5A3A (RETURN)
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen) 
....................  * 
....................  * PreCondition:    MACIsTxReady() must return TRUE. 
....................  * 
....................  * Input:           *remote: Pointer to memory which contains the destination 
....................  *                           MAC address (6 bytes) 
....................  *                  type: The constant ETHER_ARP or ETHER_IP, defining which 
....................  *                        value to write into the Ethernet header's type field. 
....................  *                  dataLen: Length of the Ethernet data payload 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Because of the dataLen parameter, it is probably 
....................  *                  advantagous to call this function immediately before 
....................  *                  transmitting a packet rather than initially when the 
....................  *                  packet is first created.  The order in which the packet 
....................  *                  is constructed (header first or data first) is not 
....................  *                  important. 
....................  *****************************************************************************/ 
.................... void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen) 
.................... { 
....................     // Set the SPI write pointer to the beginning of the transmit buffer (post per packet control byte) 
....................     WriteReg(EWRPTL, LOW(TXSTART+1)); 
*
01D0C:  MOVLW  02
01D0E:  MOVLB  3
01D10:  MOVWF  x85
01D12:  MOVLW  D7
01D14:  MOVWF  x86
01D16:  MOVLB  0
01D18:  CALL   08D0
....................     WriteReg(EWRPTH, HIGH(TXSTART+1)); 
01D1C:  MOVLW  03
01D1E:  MOVLB  3
01D20:  MOVWF  x85
01D22:  MOVLW  11
01D24:  MOVWF  x86
01D26:  MOVLB  0
01D28:  CALL   08D0
....................  
....................     // Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TXSTART; 
01D2C:  MOVLW  E4
01D2E:  MOVLB  3
01D30:  ADDWF  x80,F
01D32:  MOVLW  11
01D34:  ADDWFC x81,F
....................  
....................     // Write the TXND pointer into the registers, given the dataLen given 
....................     WriteReg(ETXNDL, ((WORD_VAL*)&dataLen)->v[0]); 
01D36:  MOVLW  03
01D38:  MOVWF  x83
01D3A:  MOVLW  80
01D3C:  MOVWF  x82
01D3E:  MOVWF  FE9
01D40:  MOVFF  383,FEA
01D44:  MOVFF  FEF,384
01D48:  MOVLW  06
01D4A:  MOVWF  x85
01D4C:  MOVFF  384,386
01D50:  MOVLB  0
01D52:  CALL   08D0
....................     WriteReg(ETXNDH, ((WORD_VAL*)&dataLen)->v[1]); 
01D56:  MOVLW  03
01D58:  MOVLB  3
01D5A:  MOVWF  x83
01D5C:  MOVLW  80
01D5E:  MOVWF  x82
01D60:  MOVLW  01
01D62:  ADDWF  x82,W
01D64:  MOVWF  FE9
01D66:  MOVLW  00
01D68:  ADDWFC x83,W
01D6A:  MOVWF  FEA
01D6C:  MOVFF  FEF,384
01D70:  MOVLW  07
01D72:  MOVWF  x85
01D74:  MOVFF  384,386
01D78:  MOVLB  0
01D7A:  CALL   08D0
....................  
....................     // Set the per-packet control byte and write the Ethernet destination 
....................     // address 
....................     MACPutArray((BYTE*)remote, sizeof(*remote)); 
01D7E:  MOVFF  37E,385
01D82:  MOVFF  37D,384
01D86:  MOVLB  3
01D88:  CLRF   x87
01D8A:  MOVLW  06
01D8C:  MOVWF  x86
01D8E:  MOVLB  0
01D90:  CALL   0DB6
....................  
....................     // Write our MAC address in the Ethernet source field 
....................     MACPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr)); 
01D94:  MOVLB  3
01D96:  CLRF   x83
01D98:  MOVLW  56
01D9A:  MOVWF  x82
01D9C:  MOVFF  383,385
01DA0:  MOVWF  x84
01DA2:  CLRF   x87
01DA4:  MOVLW  06
01DA6:  MOVWF  x86
01DA8:  MOVLB  0
01DAA:  CALL   0DB6
....................  
....................     // Write the appropriate Ethernet Type WORD for the protocol being used 
....................     MACPut(0x08); 
01DAE:  MOVLW  08
01DB0:  MOVLB  3
01DB2:  MOVWF  x83
01DB4:  MOVLB  0
01DB6:  CALL   08FA
....................     MACPut((type == MAC_IP) ? ETHER_IP : ETHER_ARP); 
01DBA:  MOVLB  3
01DBC:  MOVF   x7F,F
01DBE:  BNZ   1DC4
01DC0:  MOVLW  00
01DC2:  BRA    1DC6
01DC4:  MOVLW  06
01DC6:  MOVWF  x82
01DC8:  MOVWF  x83
01DCA:  MOVLB  0
01DCC:  CALL   08FA
01DD0:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACFlush(void) 
....................  * 
....................  * PreCondition:    A packet has been created by calling MACPut() and 
....................  *                  MACPutHeader(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACFlush causes the current TX packet to be sent out on 
....................  *                  the Ethernet medium.  The hardware MAC will take control 
....................  *                  and handle CRC generation, collision retransmission and 
....................  *                  other details. 
....................  * 
....................  * Note:            After transmission completes (MACIsTxReady() returns TRUE), 
....................  *                  the packet can be modified and transmitted again by calling 
....................  *                  MACFlush() again.  Until MACPutHeader() or MACPut() is 
....................  *                  called (in the TX data area), the data in the TX buffer 
....................  *                  will not be corrupted. 
....................  *****************************************************************************/ 
.................... void MACFlush(void) 
.................... { 
....................     // Reset transmit logic if a TX Error has previously occured 
....................     // This is a silicon errata workaround 
....................     BFSReg(ECON1, ECON1_TXRST); 
*
02004:  MOVLW  1F
02006:  MOVLB  3
02008:  MOVWF  x7A
0200A:  MOVLW  80
0200C:  MOVWF  x7B
0200E:  MOVLB  0
02010:  CALL   091E
....................     BFCReg(ECON1, ECON1_TXRST); 
02014:  MOVLW  1F
02016:  MOVLB  3
02018:  MOVWF  x7A
0201A:  MOVLW  80
0201C:  MOVWF  x7B
0201E:  MOVLB  0
02020:  CALL   0844
....................     BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
02024:  MOVLW  1C
02026:  MOVLB  3
02028:  MOVWF  x7A
0202A:  MOVLW  0A
0202C:  MOVWF  x7B
0202E:  MOVLB  0
02030:  CALL   0844
....................  
....................     // Start the transmission 
....................     // After transmission completes (MACIsTxReady() returns TRUE), the packet 
....................     // can be modified and transmitted again by calling MACFlush() again. 
....................     // Until MACPutHeader() is called, the data in the TX buffer will not be 
....................     // corrupted. 
....................     BFSReg(ECON1, ECON1_TXRTS); 
02034:  MOVLW  1F
02036:  MOVLB  3
02038:  MOVWF  x7A
0203A:  MOVLW  08
0203C:  MOVWF  x7B
0203E:  MOVLB  0
02040:  CALL   091E
....................  
....................     // Revision B5 and B7 silicon errata workaround 
....................     if(ENCRevID == 0x05u || ENCRevID == 0x06u) 
02044:  MOVF   7E,W
02046:  SUBLW  05
02048:  BZ    2052
0204A:  MOVF   7E,W
0204C:  SUBLW  06
0204E:  BTFSS  FD8.2
02050:  BRA    2232
....................     { 
....................         WORD AttemptCounter = 0x0000; 
02052:  MOVLB  3
02054:  CLRF   x61
02056:  CLRF   x60
....................         while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF)) && (++AttemptCounter < 1000u)); 
02058:  MOVLW  1C
0205A:  MOVWF  x80
0205C:  MOVLB  0
0205E:  CALL   08A6
02062:  MOVFF  01,36E
02066:  MOVLB  3
02068:  MOVF   01,W
0206A:  ANDLW  0A
0206C:  BNZ   2082
0206E:  INCF   x60,F
02070:  BTFSC  FD8.2
02072:  INCF   x61,F
02074:  MOVF   x61,W
02076:  SUBLW  03
02078:  BNC   2082
0207A:  BNZ   2058
0207C:  MOVF   x60,W
0207E:  SUBLW  E7
02080:  BC    2058
....................         if(ReadETHReg(EIR).EIRbits.TXERIF || (AttemptCounter >= 1000u)) 
02082:  MOVLW  1C
02084:  MOVWF  x80
02086:  MOVLB  0
02088:  CALL   08A6
0208C:  MOVFF  01,36E
02090:  MOVLW  00
02092:  MOVLB  3
02094:  BTFSC  01.1
02096:  MOVLW  01
02098:  XORLW  00
0209A:  BNZ   20B0
0209C:  MOVF   x61,W
0209E:  SUBLW  02
020A0:  BTFSC  FD8.0
020A2:  BRA    2234
020A4:  XORLW  FF
020A6:  BNZ   20B0
020A8:  MOVF   x60,W
020AA:  SUBLW  E7
020AC:  BTFSC  FD8.0
020AE:  BRA    2234
....................         { 
....................             WORD_VAL ReadPtrSave; 
....................             WORD_VAL TXEnd; 
....................             TXSTATUS TXStatus; 
....................             BYTE i; 
....................  
....................             // Cancel the previous transmission if it has become stuck set 
....................             BFCReg(ECON1, ECON1_TXRTS); 
020B0:  MOVLW  1F
020B2:  MOVWF  x7A
020B4:  MOVLW  08
020B6:  MOVWF  x7B
020B8:  MOVLB  0
020BA:  CALL   0844
....................  
....................             // Save the current read pointer (controlled by application) 
....................             ReadPtrSave.v[0] = ReadETHReg(ERDPTL).Val; 
020BE:  MOVLB  3
020C0:  CLRF   x80
020C2:  MOVLB  0
020C4:  CALL   08A6
020C8:  MOVFF  01,362
....................             ReadPtrSave.v[1] = ReadETHReg(ERDPTH).Val; 
020CC:  MOVLW  01
020CE:  MOVLB  3
020D0:  MOVWF  x80
020D2:  MOVLB  0
020D4:  CALL   08A6
020D8:  MOVFF  01,363
....................  
....................             // Get the location of the transmit status vector 
....................             TXEnd.v[0] = ReadETHReg(ETXNDL).Val; 
020DC:  MOVLW  06
020DE:  MOVLB  3
020E0:  MOVWF  x80
020E2:  MOVLB  0
020E4:  CALL   08A6
020E8:  MOVFF  01,364
....................             TXEnd.v[1] = ReadETHReg(ETXNDH).Val; 
020EC:  MOVLW  07
020EE:  MOVLB  3
020F0:  MOVWF  x80
020F2:  MOVLB  0
020F4:  CALL   08A6
020F8:  MOVFF  01,365
....................             TXEnd.Val++; 
020FC:  MOVLB  3
020FE:  INCF   x64,F
02100:  BTFSC  FD8.2
02102:  INCF   x65,F
....................  
....................             // Read the transmit status vector 
....................             WriteReg(ERDPTL, TXEnd.v[0]); 
02104:  CLRF   x85
02106:  MOVFF  364,386
0210A:  MOVLB  0
0210C:  CALL   08D0
....................             WriteReg(ERDPTH, TXEnd.v[1]); 
02110:  MOVLW  01
02112:  MOVLB  3
02114:  MOVWF  x85
02116:  MOVFF  365,386
0211A:  MOVLB  0
0211C:  CALL   08D0
....................             MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
02120:  MOVLW  03
02122:  MOVLB  3
02124:  MOVWF  x6F
02126:  MOVLW  66
02128:  MOVWF  x6E
0212A:  MOVFF  36F,383
0212E:  MOVWF  x82
02130:  CLRF   x85
02132:  MOVLW  07
02134:  MOVWF  x84
02136:  MOVLB  0
02138:  CALL   0E68
....................  
....................             // Implement retransmission if a late collision occured (this can 
....................             // happen on B5 when certain link pulses arrive at the same time 
....................             // as the transmission) 
....................             for(i = 0; i < 16u; i++) 
0213C:  MOVLB  3
0213E:  CLRF   x6D
02140:  MOVF   x6D,W
02142:  SUBLW  0F
02144:  BNC   2216
....................             { 
....................                 if(ReadETHReg(EIR).EIRbits.TXERIF && TXStatus.bits.LateCollision) 
02146:  MOVLW  1C
02148:  MOVWF  x80
0214A:  MOVLB  0
0214C:  CALL   08A6
02150:  MOVFF  01,36E
02154:  MOVLW  00
02156:  MOVLB  3
02158:  BTFSC  01.1
0215A:  MOVLW  01
0215C:  XORLW  00
0215E:  BZ    220C
02160:  BTFSS  x69.5
02162:  BRA    220C
....................                 { 
....................                     // Reset the TX logic 
....................                     BFSReg(ECON1, ECON1_TXRST); 
02164:  MOVLW  1F
02166:  MOVWF  x7A
02168:  MOVLW  80
0216A:  MOVWF  x7B
0216C:  MOVLB  0
0216E:  CALL   091E
....................                     BFCReg(ECON1, ECON1_TXRST); 
02172:  MOVLW  1F
02174:  MOVLB  3
02176:  MOVWF  x7A
02178:  MOVLW  80
0217A:  MOVWF  x7B
0217C:  MOVLB  0
0217E:  CALL   0844
....................                     BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
02182:  MOVLW  1C
02184:  MOVLB  3
02186:  MOVWF  x7A
02188:  MOVLW  0A
0218A:  MOVWF  x7B
0218C:  MOVLB  0
0218E:  CALL   0844
....................  
....................                     // Transmit the packet again 
....................                     BFSReg(ECON1, ECON1_TXRTS); 
02192:  MOVLW  1F
02194:  MOVLB  3
02196:  MOVWF  x7A
02198:  MOVLW  08
0219A:  MOVWF  x7B
0219C:  MOVLB  0
0219E:  CALL   091E
....................                     while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
021A2:  MOVLW  1C
021A4:  MOVLB  3
021A6:  MOVWF  x80
021A8:  MOVLB  0
021AA:  CALL   08A6
021AE:  MOVFF  01,36E
021B2:  MOVLB  3
021B4:  MOVF   01,W
021B6:  ANDLW  0A
021B8:  BTFSS  FD8.2
021BA:  BRA    21C0
021BC:  MOVLB  0
021BE:  BRA    21A2
....................  
....................                     // Cancel the previous transmission if it has become stuck set 
....................                     BFCReg(ECON1, ECON1_TXRTS); 
021C0:  MOVLW  1F
021C2:  MOVWF  x7A
021C4:  MOVLW  08
021C6:  MOVWF  x7B
021C8:  MOVLB  0
021CA:  CALL   0844
....................  
....................                     // Read transmit status vector 
....................                     WriteReg(ERDPTL, TXEnd.v[0]); 
021CE:  MOVLB  3
021D0:  CLRF   x85
021D2:  MOVFF  364,386
021D6:  MOVLB  0
021D8:  CALL   08D0
....................                     WriteReg(ERDPTH, TXEnd.v[1]); 
021DC:  MOVLW  01
021DE:  MOVLB  3
021E0:  MOVWF  x85
021E2:  MOVFF  365,386
021E6:  MOVLB  0
021E8:  CALL   08D0
....................                     MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
021EC:  MOVLW  03
021EE:  MOVLB  3
021F0:  MOVWF  x6F
021F2:  MOVLW  66
021F4:  MOVWF  x6E
021F6:  MOVFF  36F,383
021FA:  MOVWF  x82
021FC:  CLRF   x85
021FE:  MOVLW  07
02200:  MOVWF  x84
02202:  MOVLB  0
02204:  CALL   0E68
....................                 } 
02208:  BRA    2210
0220A:  MOVLB  3
....................                 else 
....................                 { 
....................                     break; 
0220C:  BRA    2216
0220E:  MOVLB  0
....................                 } 
02210:  MOVLB  3
02212:  INCF   x6D,F
02214:  BRA    2140
....................             } 
....................  
....................             // Restore the current read pointer 
....................             WriteReg(ERDPTL, ReadPtrSave.v[0]); 
02216:  CLRF   x85
02218:  MOVFF  362,386
0221C:  MOVLB  0
0221E:  CALL   08D0
....................             WriteReg(ERDPTH, ReadPtrSave.v[1]); 
02222:  MOVLW  01
02224:  MOVLB  3
02226:  MOVWF  x85
02228:  MOVFF  363,386
0222C:  MOVLB  0
0222E:  CALL   08D0
02232:  MOVLB  3
....................         } 
....................     } 
02234:  MOVLB  0
02236:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetReadPtrInRx(WORD offset) 
....................  * 
....................  * PreCondition:    A packet has been obtained by calling MACGetHeader() and 
....................  *                  getting a TRUE result. 
....................  * 
....................  * Input:           offset: WORD specifying how many bytes beyond the Ethernet 
....................  *                          header's type field to relocate the SPI read 
....................  *                          pointer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read pointer are updated.  All calls to 
....................  *                  MACGet() and MACGetArray() will use these new values. 
....................  * 
....................  * Note:            RXSTOP must be statically defined as being > RXSTART for 
....................  *                  this function to work correctly.  In other words, do not 
....................  *                  define an RX buffer which spans the 0x1FFF->0x0000 memory 
....................  *                  boundary. 
....................  *****************************************************************************/ 
.................... void MACSetReadPtrInRx(WORD offset) 
.................... { 
....................     WORD_VAL ReadPT; 
....................  
....................     // Determine the address of the beginning of the entire packet 
....................     // and adjust the address to the desired location 
....................     ReadPT.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
03CD0:  MOVLW  14
03CD2:  ADDWF  7C,W
03CD4:  MOVLB  3
03CD6:  MOVWF  x42
03CD8:  MOVLW  00
03CDA:  ADDWFC 7D,W
03CDC:  MOVWF  x43
03CDE:  MOVF   x3E,W
03CE0:  ADDWF  x42,W
03CE2:  MOVWF  x40
03CE4:  MOVF   x3F,W
03CE6:  ADDWFC x43,W
03CE8:  MOVWF  x41
....................  
....................     // Since the receive buffer is circular, adjust if a wraparound is needed 
....................     if(ReadPT.Val > RXSTOP) 
03CEA:  MOVF   x41,W
03CEC:  SUBLW  10
03CEE:  BC    3D02
03CF0:  XORLW  FF
03CF2:  BNZ   3CFA
03CF4:  MOVF   x40,W
03CF6:  SUBLW  D5
03CF8:  BC    3D02
....................         ReadPT.Val -= RXSIZE; 
03CFA:  MOVLW  D6
03CFC:  SUBWF  x40,F
03CFE:  MOVLW  11
03D00:  SUBWFB x41,F
....................  
....................     // Set the SPI read pointer to the new calculated value 
....................     WriteReg(ERDPTL, ReadPT.v[0]); 
03D02:  CLRF   x85
03D04:  MOVFF  340,386
03D08:  MOVLB  0
03D0A:  CALL   08D0
....................     WriteReg(ERDPTH, ReadPT.v[1]); 
03D0E:  MOVLW  01
03D10:  MOVLB  3
03D12:  MOVWF  x85
03D14:  MOVFF  341,386
03D18:  MOVLB  0
03D1A:  CALL   08D0
03D1E:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        PTR_BASE MACSetWritePtr(PTR_BASE Address) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           Address: Address to seek to 
....................  * 
....................  * Output:          WORD: Old EWRPT location 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI write pointer is updated.  All calls to 
....................  *                  MACPut() and MACPutArray() will use this new value. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PTR_BASE MACSetWritePtr(PTR_BASE address) 
.................... { 
....................     WORD_VAL oldVal; 
....................  
....................     oldVal.v[0] = ReadETHReg(EWRPTL).Val; 
*
00D46:  MOVLW  02
00D48:  MOVLB  3
00D4A:  MOVWF  x80
00D4C:  MOVLB  0
00D4E:  RCALL  08A6
00D50:  MOVFF  01,371
....................     oldVal.v[1] = ReadETHReg(EWRPTH).Val; 
00D54:  MOVLW  03
00D56:  MOVLB  3
00D58:  MOVWF  x80
00D5A:  MOVLB  0
00D5C:  RCALL  08A6
00D5E:  MOVFF  01,372
....................  
....................     // Set the SPI write pointer to the new calculated value 
....................     WriteReg(EWRPTL, ((WORD_VAL*)&address)->v[0]); 
00D62:  MOVLW  03
00D64:  MOVLB  3
00D66:  MOVWF  x74
00D68:  MOVLW  6F
00D6A:  MOVWF  x73
00D6C:  MOVWF  FE9
00D6E:  MOVFF  374,FEA
00D72:  MOVFF  FEF,375
00D76:  MOVLW  02
00D78:  MOVWF  x85
00D7A:  MOVFF  375,386
00D7E:  MOVLB  0
00D80:  RCALL  08D0
....................     WriteReg(EWRPTH, ((WORD_VAL*)&address)->v[1]); 
00D82:  MOVLW  03
00D84:  MOVLB  3
00D86:  MOVWF  x74
00D88:  MOVLW  6F
00D8A:  MOVWF  x73
00D8C:  MOVLW  01
00D8E:  ADDWF  x73,W
00D90:  MOVWF  FE9
00D92:  MOVLW  00
00D94:  ADDWFC x74,W
00D96:  MOVWF  FEA
00D98:  MOVFF  FEF,375
00D9C:  MOVLW  03
00D9E:  MOVWF  x85
00DA0:  MOVFF  375,386
00DA4:  MOVLB  0
00DA6:  RCALL  08D0
....................  
....................     return oldVal.Val; 
00DA8:  MOVLB  3
00DAA:  MOVFF  371,01
00DAE:  MOVFF  372,02
00DB2:  MOVLB  0
00DB4:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        PTR_BASE MACSetReadPtr(PTR_BASE Address) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           Address: Address to seek to 
....................  * 
....................  * Output:          WORD: Old ERDPT value 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI write pointer is updated.  All calls to 
....................  *                  MACPut() and MACPutArray() will use this new value. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PTR_BASE MACSetReadPtr(PTR_BASE address) 
.................... { 
....................     WORD_VAL oldVal; 
....................  
....................     oldVal.v[0] = ReadETHReg(ERDPTL).Val; 
*
00DFC:  MOVLB  3
00DFE:  CLRF   x80
00E00:  MOVLB  0
00E02:  RCALL  08A6
00E04:  MOVFF  01,371
....................     oldVal.v[1] = ReadETHReg(ERDPTH).Val; 
00E08:  MOVLW  01
00E0A:  MOVLB  3
00E0C:  MOVWF  x80
00E0E:  MOVLB  0
00E10:  RCALL  08A6
00E12:  MOVFF  01,372
....................  
....................     // Set the SPI write pointer to the new calculated value 
....................     WriteReg(ERDPTL, ((WORD_VAL*)&address)->v[0]); 
00E16:  MOVLW  03
00E18:  MOVLB  3
00E1A:  MOVWF  x74
00E1C:  MOVLW  6F
00E1E:  MOVWF  x73
00E20:  MOVWF  FE9
00E22:  MOVFF  374,FEA
00E26:  MOVFF  FEF,375
00E2A:  CLRF   x85
00E2C:  MOVFF  375,386
00E30:  MOVLB  0
00E32:  RCALL  08D0
....................     WriteReg(ERDPTH, ((WORD_VAL*)&address)->v[1]); 
00E34:  MOVLW  03
00E36:  MOVLB  3
00E38:  MOVWF  x74
00E3A:  MOVLW  6F
00E3C:  MOVWF  x73
00E3E:  MOVLW  01
00E40:  ADDWF  x73,W
00E42:  MOVWF  FE9
00E44:  MOVLW  00
00E46:  ADDWFC x74,W
00E48:  MOVWF  FEA
00E4A:  MOVFF  FEF,375
00E4E:  MOVLW  01
00E50:  MOVWF  x85
00E52:  MOVFF  375,386
00E56:  MOVLB  0
00E58:  RCALL  08D0
....................  
....................     return oldVal.Val; 
00E5A:  MOVLB  3
00E5C:  MOVFF  371,01
00E60:  MOVFF  372,02
00E64:  MOVLB  0
00E66:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcRxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset  - Number of bytes beyond the beginning of the 
....................  *                          Ethernet data (first byte after the type field) 
....................  *                          where the checksum should begin 
....................  *                  len     - Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by RFC 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcRxChecksum(WORD offset, WORD len) 
.................... { 
....................     WORD_VAL temp; 
....................     WORD_VAL RDSave; 
....................  
....................     // Add the offset requested by firmware plus the Ethernet header 
....................     temp.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
03C24:  MOVLW  14
03C26:  ADDWF  7C,W
03C28:  MOVLB  3
03C2A:  MOVWF  x11
03C2C:  MOVLW  00
03C2E:  ADDWFC 7D,W
03C30:  MOVWF  x12
03C32:  MOVF   x09,W
03C34:  ADDWF  x11,W
03C36:  MOVWF  x0D
03C38:  MOVF   x0A,W
03C3A:  ADDWFC x12,W
03C3C:  MOVWF  x0E
....................     if(temp.Val > RXSTOP)       // Adjust value if a wrap is needed 
03C3E:  MOVF   x0E,W
03C40:  SUBLW  10
03C42:  BC    3C56
03C44:  XORLW  FF
03C46:  BNZ   3C4E
03C48:  MOVF   x0D,W
03C4A:  SUBLW  D5
03C4C:  BC    3C56
....................     { 
....................         temp.Val -= RXSIZE; 
03C4E:  MOVLW  D6
03C50:  SUBWF  x0D,F
03C52:  MOVLW  11
03C54:  SUBWFB x0E,F
....................     } 
....................  
....................     RDSave.v[0] = ReadETHReg(ERDPTL).Val; 
03C56:  CLRF   x80
03C58:  MOVLB  0
03C5A:  CALL   08A6
03C5E:  MOVFF  01,30F
....................     RDSave.v[1] = ReadETHReg(ERDPTH).Val; 
03C62:  MOVLW  01
03C64:  MOVLB  3
03C66:  MOVWF  x80
03C68:  MOVLB  0
03C6A:  CALL   08A6
03C6E:  MOVFF  01,310
....................  
....................     WriteReg(ERDPTL, temp.v[0]); 
03C72:  MOVLB  3
03C74:  CLRF   x85
03C76:  MOVFF  30D,386
03C7A:  MOVLB  0
03C7C:  CALL   08D0
....................     WriteReg(ERDPTH, temp.v[1]); 
03C80:  MOVLW  01
03C82:  MOVLB  3
03C84:  MOVWF  x85
03C86:  MOVFF  30E,386
03C8A:  MOVLB  0
03C8C:  CALL   08D0
....................  
....................     temp.Val = CalcIPBufferChecksum(len); 
03C90:  MOVFF  30C,361
03C94:  MOVFF  30B,360
03C98:  CALL   1EBC
03C9C:  MOVFF  02,30E
03CA0:  MOVFF  01,30D
....................  
....................     WriteReg(ERDPTL, RDSave.v[0]); 
03CA4:  MOVLB  3
03CA6:  CLRF   x85
03CA8:  MOVFF  30F,386
03CAC:  MOVLB  0
03CAE:  CALL   08D0
....................     WriteReg(ERDPTH, RDSave.v[1]); 
03CB2:  MOVLW  01
03CB4:  MOVLB  3
03CB6:  MOVWF  x85
03CB8:  MOVFF  310,386
03CBC:  MOVLB  0
03CBE:  CALL   08D0
....................  
....................     return temp.Val; 
03CC2:  MOVLB  3
03CC4:  MOVFF  30D,01
03CC8:  MOVFF  30E,02
03CCC:  MOVLB  0
03CCE:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    Read buffer pointer set to starting of checksum data 
....................  * 
....................  * Input:           len: Total number of bytes to calculate the checksum over. 
....................  *                       The first byte included in the checksum is the byte 
....................  *                       pointed to by ERDPT, which is updated by calls to 
....................  *                       MACSetReadPtr(), MACGet(), MACGetArray(), 
....................  *                       MACGetHeader(), etc. 
....................  * 
....................  * Output:          16-bit checksum as defined by RFC 793 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself.  The ENC28J60 has a hardware DMA module 
....................  *                  which can calculate the checksum faster than software, so 
....................  *                  this function replaces the CaclIPBufferChecksum() function 
....................  *                  defined in the helpers.c file.  Through the use of 
....................  *                  preprocessor defines, this replacement is automatic. 
....................  * 
....................  * Note:            This function works either in the RX buffer area or the TX 
....................  *                  buffer area.  No validation is done on the len parameter. 
....................  *****************************************************************************/ 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................     WORD_VAL Start; 
....................     DWORD_VAL Checksum = {0x00000000ul}; 
*
01EBC:  MOVLB  3
01EBE:  CLRF   x64
01EC0:  CLRF   x65
01EC2:  CLRF   x66
01EC4:  CLRF   x67
....................     WORD ChunkLen; 
....................     WORD DataBuffer[10]; 
....................     WORD *DataPtr; 
....................  
....................     // Save the SPI read pointer starting address 
....................     Start.v[0] = ReadETHReg(ERDPTL).Val; 
01EC6:  CLRF   x80
01EC8:  MOVLB  0
01ECA:  CALL   08A6
01ECE:  MOVFF  01,362
....................     Start.v[1] = ReadETHReg(ERDPTH).Val; 
01ED2:  MOVLW  01
01ED4:  MOVLB  3
01ED6:  MOVWF  x80
01ED8:  MOVLB  0
01EDA:  CALL   08A6
01EDE:  MOVFF  01,363
....................  
....................     while(len) 
01EE2:  MOVLB  3
01EE4:  MOVF   x60,W
01EE6:  IORWF  x61,W
01EE8:  BZ    1F9A
....................     { 
....................         // Obtain a chunk of data (less SPI overhead compared 
....................         // to requesting one byte at a time) 
....................         ChunkLen = len > sizeof(DataBuffer) ? sizeof(DataBuffer) : len; 
01EEA:  MOVF   x61,F
01EEC:  BNZ   1EF4
01EEE:  MOVF   x60,W
01EF0:  SUBLW  14
01EF2:  BC    1EFA
01EF4:  CLRF   03
01EF6:  MOVLW  14
01EF8:  BRA    1F00
01EFA:  MOVFF  361,03
01EFE:  MOVF   x60,W
01F00:  MOVWF  x68
01F02:  MOVFF  03,369
....................         MACGetArray((BYTE*)DataBuffer, ChunkLen); 
01F06:  MOVLW  03
01F08:  MOVWF  x81
01F0A:  MOVLW  6A
01F0C:  MOVWF  x80
01F0E:  MOVFF  381,383
01F12:  MOVWF  x82
01F14:  MOVFF  369,385
01F18:  MOVFF  368,384
01F1C:  MOVLB  0
01F1E:  CALL   0E68
....................  
....................         len -= ChunkLen; 
01F22:  MOVLB  3
01F24:  MOVF   x68,W
01F26:  SUBWF  x60,F
01F28:  MOVF   x69,W
01F2A:  SUBWFB x61,F
....................  
....................         // Take care of a last odd numbered data byte 
....................         if(((WORD_VAL*)&ChunkLen)->bits.b0) 
01F2C:  MOVLW  03
01F2E:  MOVWF  x81
01F30:  MOVLW  68
01F32:  MOVWF  FE9
01F34:  MOVFF  381,FEA
01F38:  BTFSS  FEF.0
01F3A:  BRA    1F54
....................         { 
....................             ((BYTE*)DataBuffer)[ChunkLen] = 0x00; 
01F3C:  MOVLW  03
01F3E:  MOVWF  x81
01F40:  MOVLW  6A
01F42:  ADDWF  x68,W
01F44:  MOVWF  FE9
01F46:  MOVF   x81,W
01F48:  ADDWFC x69,W
01F4A:  MOVWF  FEA
01F4C:  CLRF   FEF
....................             ChunkLen++; 
01F4E:  INCF   x68,F
01F50:  BTFSC  FD8.2
01F52:  INCF   x69,F
....................         } 
....................  
....................         // Calculate the checksum over this chunk 
....................         DataPtr = DataBuffer; 
01F54:  MOVLW  03
01F56:  MOVWF  x7F
01F58:  MOVLW  6A
01F5A:  MOVWF  x7E
....................         while(ChunkLen) 
01F5C:  MOVF   x68,W
01F5E:  IORWF  x69,W
01F60:  BZ    1F98
....................         { 
....................             Checksum.Val += *DataPtr++; 
01F62:  MOVFF  37F,03
01F66:  MOVFF  37E,00
01F6A:  MOVLW  02
01F6C:  ADDWF  x7E,F
01F6E:  BTFSC  FD8.0
01F70:  INCF   x7F,F
01F72:  MOVFF  00,FE9
01F76:  MOVFF  03,FEA
01F7A:  MOVFF  FEC,03
01F7E:  MOVF   FED,F
01F80:  MOVF   FEF,W
01F82:  ADDWF  x64,F
01F84:  MOVF   03,W
01F86:  ADDWFC x65,F
01F88:  MOVLW  00
01F8A:  ADDWFC x66,F
01F8C:  ADDWFC x67,F
....................             ChunkLen -= 2; 
01F8E:  MOVLW  02
01F90:  SUBWF  x68,F
01F92:  MOVLW  00
01F94:  SUBWFB x69,F
01F96:  BRA    1F5C
....................         } 
01F98:  BRA    1EE4
....................     } 
....................  
....................     // Restore old read pointer location 
....................     WriteReg(ERDPTL, Start.v[0]); 
01F9A:  CLRF   x85
01F9C:  MOVFF  362,386
01FA0:  MOVLB  0
01FA2:  CALL   08D0
....................     WriteReg(ERDPTH, Start.v[1]); 
01FA6:  MOVLW  01
01FA8:  MOVLB  3
01FAA:  MOVWF  x85
01FAC:  MOVFF  363,386
01FB0:  MOVLB  0
01FB2:  CALL   08D0
....................  
....................     // Do an end-around carry (one's complement arrithmatic) 
....................     Checksum.Val = (DWORD)Checksum.w[0] + (DWORD)Checksum.w[1]; 
01FB6:  MOVLB  3
01FB8:  CLRF   x83
01FBA:  CLRF   x82
01FBC:  MOVFF  365,381
01FC0:  MOVFF  364,380
01FC4:  MOVFF  366,00
01FC8:  MOVFF  367,01
01FCC:  CLRF   02
01FCE:  CLRF   03
01FD0:  MOVF   x66,W
01FD2:  ADDWF  x64,W
01FD4:  MOVWF  x64
01FD6:  MOVF   x67,W
01FD8:  ADDWFC x65,W
01FDA:  MOVWF  x65
01FDC:  MOVF   02,W
01FDE:  ADDWFC x82,W
01FE0:  MOVWF  x66
01FE2:  MOVF   03,W
01FE4:  ADDWFC x83,W
01FE6:  MOVWF  x67
....................  
....................     // Do another end-around carry in case if the prior add 
....................     // caused a carry out 
....................     Checksum.w[0] += Checksum.w[1]; 
01FE8:  MOVF   x66,W
01FEA:  ADDWF  x64,F
01FEC:  MOVF   x67,W
01FEE:  ADDWFC x65,F
....................  
....................     // Return the resulting checksum 
....................     return ~Checksum.w[0]; 
01FF0:  MOVFF  365,03
01FF4:  COMF   03,F
01FF6:  MOVF   x64,W
01FF8:  XORLW  FF
01FFA:  MOVWF  01
01FFC:  MOVFF  03,02
02000:  MOVLB  0
02002:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACMemCopyAsync(PTR_BASE destAddr, PTR_BASE sourceAddr, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           destAddr:   Destination address in the Ethernet memory to 
....................  *                              copy to.  If (PTR_BASE)-1 is specified, the  
....................  *                        current EWRPT value will be used instead. 
....................  *                  sourceAddr: Source address to read from.  If (PTR_BASE)-1 is 
....................  *                              specified, the current ERDPT value will be used 
....................  *                              instead. 
....................  *                  len:        Number of bytes to copy 
....................  * 
....................  * Output:          Byte read from the ENC28J60's RAM 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Bytes are asynchrnously transfered within the buffer.  Call 
....................  *                  MACIsMemCopyDone() to see when the transfer is complete. 
....................  * 
....................  * Note:            If a prior transfer is already in progress prior to 
....................  *                  calling this function, this function will block until it 
....................  *                  can start this transfer. 
....................  * 
....................  *                  If (PTR_BASE)-1 is used for the sourceAddr or destAddr 
....................  *                  parameters, then that pointer will get updated with the 
....................  *                  next address after the read or write. 
....................  *****************************************************************************/ 
.................... void MACMemCopyAsync(PTR_BASE destAddr, PTR_BASE sourceAddr, WORD len) 
*
00F08:  MOVLB  3
00F0A:  BCF    x79.0
00F0C:  BCF    x79.1
.................... { 
....................     WORD_VAL ReadSave, WriteSave; 
....................     BOOL UpdateWritePointer = FALSE; 
....................     BOOL UpdateReadPointer = FALSE; 
....................  
....................     if(destAddr == (PTR_BASE)-1) 
00F0E:  INCFSZ x6F,W
00F10:  BRA    0F36
00F12:  INCFSZ x70,W
00F14:  BRA    0F36
....................     { 
....................         UpdateWritePointer = TRUE; 
00F16:  BSF    x79.0
....................         destAddr = ReadETHReg(EWRPTL).Val; 
00F18:  MOVLW  02
00F1A:  MOVWF  x80
00F1C:  MOVLB  0
00F1E:  RCALL  08A6
00F20:  MOVLB  3
00F22:  CLRF   x70
00F24:  MOVFF  01,36F
....................         ((BYTE*)&destAddr)[1] = ReadETHReg(EWRPTH).Val; 
00F28:  MOVLW  03
00F2A:  MOVWF  x80
00F2C:  MOVLB  0
00F2E:  RCALL  08A6
00F30:  MOVFF  01,370
00F34:  MOVLB  3
....................     } 
....................     if(sourceAddr == (PTR_BASE)-1) 
00F36:  INCFSZ x71,W
00F38:  BRA    0F5C
00F3A:  INCFSZ x72,W
00F3C:  BRA    0F5C
....................     { 
....................         UpdateReadPointer = TRUE; 
00F3E:  BSF    x79.1
....................         sourceAddr = ReadETHReg(ERDPTL).Val; 
00F40:  CLRF   x80
00F42:  MOVLB  0
00F44:  RCALL  08A6
00F46:  MOVLB  3
00F48:  CLRF   x72
00F4A:  MOVFF  01,371
....................         ((BYTE*)&sourceAddr)[1] = ReadETHReg(ERDPTH).Val; 
00F4E:  MOVLW  01
00F50:  MOVWF  x80
00F52:  MOVLB  0
00F54:  RCALL  08A6
00F56:  MOVFF  01,372
00F5A:  MOVLB  3
....................     } 
....................  
....................     // Handle special conditions where len == 0 or len == 1 
....................     // The DMA module is not capable of handling those corner cases 
....................     if(len <= 1u) 
00F5C:  MOVF   x74,F
00F5E:  BTFSS  FD8.2
00F60:  BRA    1040
00F62:  MOVF   x73,W
00F64:  SUBLW  01
00F66:  BTFSS  FD8.0
00F68:  BRA    1040
....................     { 
....................         if(!UpdateReadPointer) 
00F6A:  BTFSC  x79.1
00F6C:  BRA    0F88
....................         { 
....................             ReadSave.v[0] = ReadETHReg(ERDPTL).Val; 
00F6E:  CLRF   x80
00F70:  MOVLB  0
00F72:  RCALL  08A6
00F74:  MOVFF  01,375
....................             ReadSave.v[1] = ReadETHReg(ERDPTH).Val; 
00F78:  MOVLW  01
00F7A:  MOVLB  3
00F7C:  MOVWF  x80
00F7E:  MOVLB  0
00F80:  RCALL  08A6
00F82:  MOVFF  01,376
00F86:  MOVLB  3
....................         } 
....................         if(!UpdateWritePointer) 
00F88:  BTFSC  x79.0
00F8A:  BRA    0FA8
....................         { 
....................             WriteSave.v[0] = ReadETHReg(EWRPTL).Val; 
00F8C:  MOVLW  02
00F8E:  MOVWF  x80
00F90:  MOVLB  0
00F92:  RCALL  08A6
00F94:  MOVFF  01,377
....................             WriteSave.v[1] = ReadETHReg(EWRPTH).Val; 
00F98:  MOVLW  03
00F9A:  MOVLB  3
00F9C:  MOVWF  x80
00F9E:  MOVLB  0
00FA0:  RCALL  08A6
00FA2:  MOVFF  01,378
00FA6:  MOVLB  3
....................         } 
....................         WriteReg(ERDPTL, ((BYTE*)&sourceAddr)[0]); 
00FA8:  CLRF   x85
00FAA:  MOVFF  371,386
00FAE:  MOVLB  0
00FB0:  RCALL  08D0
....................         WriteReg(ERDPTH, ((BYTE*)&sourceAddr)[1]); 
00FB2:  MOVLW  01
00FB4:  MOVLB  3
00FB6:  MOVWF  x85
00FB8:  MOVFF  372,386
00FBC:  MOVLB  0
00FBE:  RCALL  08D0
....................         WriteReg(EWRPTL, ((BYTE*)&destAddr)[0]); 
00FC0:  MOVLW  02
00FC2:  MOVLB  3
00FC4:  MOVWF  x85
00FC6:  MOVFF  36F,386
00FCA:  MOVLB  0
00FCC:  RCALL  08D0
....................         WriteReg(EWRPTH, ((BYTE*)&destAddr)[1]); 
00FCE:  MOVLW  03
00FD0:  MOVLB  3
00FD2:  MOVWF  x85
00FD4:  MOVFF  370,386
00FD8:  MOVLB  0
00FDA:  RCALL  08D0
....................         while(len--) 
00FDC:  MOVLB  3
00FDE:  MOVFF  374,03
00FE2:  MOVF   x73,W
00FE4:  BTFSC  FD8.2
00FE6:  DECF   x74,F
00FE8:  DECF   x73,F
00FEA:  IORWF  03,W
00FEC:  BZ    1000
....................             MACPut(MACGet()); 
00FEE:  MOVLB  0
00FF0:  RCALL  0EDE
00FF2:  MOVFF  01,37A
00FF6:  MOVFF  01,383
00FFA:  RCALL  08FA
00FFC:  BRA    0FDC
00FFE:  MOVLB  3
....................         if(!UpdateReadPointer) 
01000:  BTFSC  x79.1
01002:  BRA    101E
....................         { 
....................             WriteReg(ERDPTL, ReadSave.v[0]); 
01004:  CLRF   x85
01006:  MOVFF  375,386
0100A:  MOVLB  0
0100C:  RCALL  08D0
....................             WriteReg(ERDPTH, ReadSave.v[1]); 
0100E:  MOVLW  01
01010:  MOVLB  3
01012:  MOVWF  x85
01014:  MOVFF  376,386
01018:  MOVLB  0
0101A:  RCALL  08D0
0101C:  MOVLB  3
....................         } 
....................         if(!UpdateWritePointer) 
0101E:  BTFSC  x79.0
01020:  BRA    103E
....................         { 
....................             WriteReg(EWRPTL, WriteSave.v[0]); 
01022:  MOVLW  02
01024:  MOVWF  x85
01026:  MOVFF  377,386
0102A:  MOVLB  0
0102C:  RCALL  08D0
....................             WriteReg(EWRPTH, WriteSave.v[1]); 
0102E:  MOVLW  03
01030:  MOVLB  3
01032:  MOVWF  x85
01034:  MOVFF  378,386
01038:  MOVLB  0
0103A:  RCALL  08D0
0103C:  MOVLB  3
....................         } 
....................     } 
0103E:  BRA    1184
....................     else 
....................     { 
....................         if(UpdateWritePointer) 
01040:  BTFSS  x79.0
01042:  BRA    106C
....................         { 
....................             WriteSave.Val = destAddr + len; 
01044:  MOVF   x73,W
01046:  ADDWF  x6F,W
01048:  MOVWF  x77
0104A:  MOVF   x74,W
0104C:  ADDWFC x70,W
0104E:  MOVWF  x78
....................             WriteReg(EWRPTL, WriteSave.v[0]); 
01050:  MOVLW  02
01052:  MOVWF  x85
01054:  MOVFF  377,386
01058:  MOVLB  0
0105A:  RCALL  08D0
....................             WriteReg(EWRPTH, WriteSave.v[1]); 
0105C:  MOVLW  03
0105E:  MOVLB  3
01060:  MOVWF  x85
01062:  MOVFF  378,386
01066:  MOVLB  0
01068:  RCALL  08D0
0106A:  MOVLB  3
....................         } 
....................         len += sourceAddr - 1; 
0106C:  MOVLW  01
0106E:  SUBWF  x71,W
01070:  MOVWF  00
01072:  MOVLW  00
01074:  SUBWFB x72,W
01076:  MOVWF  03
01078:  MOVF   00,W
0107A:  ADDWF  x73,F
0107C:  MOVF   03,W
0107E:  ADDWFC x74,F
....................         while(ReadETHReg(ECON1).ECON1bits.DMAST); 
01080:  MOVLW  1F
01082:  MOVWF  x80
01084:  MOVLB  0
01086:  RCALL  08A6
01088:  MOVFF  01,37A
0108C:  MOVLW  00
0108E:  MOVLB  3
01090:  BTFSC  01.5
01092:  MOVLW  01
01094:  XORLW  00
01096:  BNZ   1080
....................         WriteReg(EDMASTL, ((BYTE*)&sourceAddr)[0]); 
01098:  MOVLW  10
0109A:  MOVWF  x85
0109C:  MOVFF  371,386
010A0:  MOVLB  0
010A2:  RCALL  08D0
....................         WriteReg(EDMASTH, ((BYTE*)&sourceAddr)[1]); 
010A4:  MOVLW  11
010A6:  MOVLB  3
010A8:  MOVWF  x85
010AA:  MOVFF  372,386
010AE:  MOVLB  0
010B0:  RCALL  08D0
....................         WriteReg(EDMADSTL, ((BYTE*)&destAddr)[0]); 
010B2:  MOVLW  14
010B4:  MOVLB  3
010B6:  MOVWF  x85
010B8:  MOVFF  36F,386
010BC:  MOVLB  0
010BE:  RCALL  08D0
....................         WriteReg(EDMADSTH, ((BYTE*)&destAddr)[1]); 
010C0:  MOVLW  15
010C2:  MOVLB  3
010C4:  MOVWF  x85
010C6:  MOVFF  370,386
010CA:  MOVLB  0
010CC:  RCALL  08D0
....................         if((sourceAddr <= RXSTOP) && (len > RXSTOP)) //&& (sourceAddr >= RXSTART)) 
010CE:  MOVLB  3
010D0:  MOVF   x72,W
010D2:  SUBLW  11
010D4:  BNC   10F6
010D6:  BNZ   10DE
010D8:  MOVF   x71,W
010DA:  SUBLW  D5
010DC:  BNC   10F6
010DE:  MOVF   x74,W
010E0:  SUBLW  10
010E2:  BC    10F6
010E4:  XORLW  FF
010E6:  BNZ   10EE
010E8:  MOVF   x73,W
010EA:  SUBLW  D5
010EC:  BC    10F6
....................             len -= RXSIZE; 
010EE:  MOVLW  D6
010F0:  SUBWF  x73,F
010F2:  MOVLW  11
010F4:  SUBWFB x74,F
....................         WriteReg(EDMANDL, ((BYTE*)&len)[0]); 
010F6:  MOVLW  12
010F8:  MOVWF  x85
010FA:  MOVFF  373,386
010FE:  MOVLB  0
01100:  CALL   08D0
....................         WriteReg(EDMANDH, ((BYTE*)&len)[1]); 
01104:  MOVLW  13
01106:  MOVLB  3
01108:  MOVWF  x85
0110A:  MOVFF  374,386
0110E:  MOVLB  0
01110:  CALL   08D0
....................         BFCReg(ECON1, ECON1_CSUMEN); 
01114:  MOVLW  1F
01116:  MOVLB  3
01118:  MOVWF  x7A
0111A:  MOVLW  10
0111C:  MOVWF  x7B
0111E:  MOVLB  0
01120:  CALL   0844
....................         BFSReg(ECON1, ECON1_DMAST); 
01124:  MOVLW  1F
01126:  MOVLB  3
01128:  MOVWF  x7A
0112A:  MOVLW  20
0112C:  MOVWF  x7B
0112E:  MOVLB  0
01130:  CALL   091E
....................         if(UpdateReadPointer) 
01134:  MOVLB  3
01136:  BTFSS  x79.1
01138:  BRA    1184
....................         { 
....................             len++; 
0113A:  INCF   x73,F
0113C:  BTFSC  FD8.2
0113E:  INCF   x74,F
....................             if((sourceAddr <= RXSTOP) && (len > RXSTOP)) //&& (sourceAddr >= RXSTART)) 
01140:  MOVF   x72,W
01142:  SUBLW  11
01144:  BNC   1166
01146:  BNZ   114E
01148:  MOVF   x71,W
0114A:  SUBLW  D5
0114C:  BNC   1166
0114E:  MOVF   x74,W
01150:  SUBLW  10
01152:  BC    1166
01154:  XORLW  FF
01156:  BNZ   115E
01158:  MOVF   x73,W
0115A:  SUBLW  D5
0115C:  BC    1166
....................                 len -= RXSIZE; 
0115E:  MOVLW  D6
01160:  SUBWF  x73,F
01162:  MOVLW  11
01164:  SUBWFB x74,F
....................             WriteReg(ERDPTL, ((BYTE*)&len)[0]); 
01166:  CLRF   x85
01168:  MOVFF  373,386
0116C:  MOVLB  0
0116E:  CALL   08D0
....................             WriteReg(ERDPTH, ((BYTE*)&len)[1]); 
01172:  MOVLW  01
01174:  MOVLB  3
01176:  MOVWF  x85
01178:  MOVFF  374,386
0117C:  MOVLB  0
0117E:  CALL   08D0
01182:  MOVLB  3
....................         } 
....................     } 
01184:  MOVLB  0
01186:  RETURN 0
.................... } 
....................  
.................... BOOL MACIsMemCopyDone(void) 
.................... { 
....................     return !ReadETHReg(ECON1).ECON1bits.DMAST; 
01188:  MOVLW  1F
0118A:  MOVLB  3
0118C:  MOVWF  x80
0118E:  MOVLB  0
01190:  CALL   08A6
01194:  MOVFF  01,36F
01198:  MOVLW  00
0119A:  MOVLB  3
0119C:  BTFSC  01.5
0119E:  MOVLW  01
011A0:  XORLW  00
011A2:  BZ    11A8
011A4:  MOVLW  00
011A6:  BRA    11AA
011A8:  MOVLW  01
011AA:  MOVWF  01
011AC:  MOVLB  0
011AE:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE MACGet() 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Byte read from the ENC28J60's RAM 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACGet returns the byte pointed to by ERDPT and 
....................  *                  increments ERDPT so MACGet() can be called again.  The 
....................  *                  increment will follow the receive buffer wrapping boundary. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE MACGet() 
.................... { 
....................     BYTE Result; 
....................  
....................     ENC_CS_IO = 0; 
*
00EDE:  BCF    F8C.1
....................    ClearSPIDoneFlag(); 
00EE0:  BCF    F9E.3
....................  
....................     #if defined(__C32__) 
....................     { 
....................         // Send the opcode and read a byte in one 16-bit operation 
....................         ENC_SPICON1bits.MODE16 = 1; 
....................         ENC_SSPBUF = RBM<<8 | 0x00; // Send Read Buffer Memory command plus 8 dummy bits to generate clocks for the return result 
....................         WaitForDataByte();          // Wait until WORD is transmitted 
....................         ENC_SPICON1bits.MODE16 = 0; 
....................     } 
....................     #elif defined(__C30__) 
....................     { 
....................         // Send the opcode and read a byte in one 16-bit operation 
....................         ENC_SPISTATbits.SPIEN = 0; 
....................         ENC_SPICON1bits.MODE16 = 1; 
....................         ENC_SPISTATbits.SPIEN = 1; 
....................         ENC_SSPBUF = RBM<<8 | 0x00; // Send Read Buffer Memory command plus 8 dummy bits to generate clocks for the return result 
....................         WaitForDataByte();          // Wait until WORD is transmitted 
....................         ENC_SPISTATbits.SPIEN = 0; 
....................         ENC_SPICON1bits.MODE16 = 0; 
....................         ENC_SPISTATbits.SPIEN = 1; 
....................     } 
....................     #else 
....................     { 
....................         // Send the opcode and read a byte in two 8-bit operations 
....................         ENC_SSPBUF = RBM; 
00EE2:  MOVLW  3A
00EE4:  MOVWF  FC9
....................         WaitForDataByte();      // Wait until opcode/address is transmitted. 
00EE6:  BTFSS  F9E.3
00EE8:  BRA    0EE6
00EEA:  BCF    F9E.3
....................         Result = ENC_SSPBUF; 
00EEC:  MOVFF  FC9,37A
....................  
....................         ENC_SSPBUF = 0;         // Send a dummy byte to receive the register 
00EF0:  CLRF   FC9
....................                                 //   contents. 
....................         WaitForDataByte();      // Wait until register is received. 
00EF2:  BTFSS  F9E.3
00EF4:  BRA    0EF2
00EF6:  BCF    F9E.3
....................     } 
....................     #endif 
....................  
....................     Result = ENC_SSPBUF; 
00EF8:  MOVFF  FC9,37A
....................     ENC_CS_IO = 1; 
00EFC:  BSF    F8C.1
....................  
....................     return Result; 
00EFE:  MOVLB  3
00F00:  MOVFF  37A,01
00F04:  MOVLB  0
00F06:  RETURN 0
.................... }//end MACGet 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           *val: Pointer to storage location 
....................  *                  len:  Number of bytes to read from the data buffer. 
....................  * 
....................  * Output:          Byte(s) of data read from the data buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Burst reads several sequential bytes from the data buffer 
....................  *                  and places them into local memory.  With SPI burst support, 
....................  *                  it performs much faster than multiple MACGet() calls. 
....................  *                  ERDPT is incremented after each byte, following the same 
....................  *                  rules as MACGet(). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetArray(BYTE *val, WORD len) 
.................... { 
.................... // Workaround needed on HPC Explorer (classic) board to prevent interference 
.................... // with I2C temperature sensor on the same SPI wires 
.................... #if defined(__18F8722) || defined(_18F8722) ||  defined(__18F8723) || defined(_18F8723) 
....................     WORD i; 
....................     volatile BYTE Dummy; 
....................  
....................     i = len; 
....................     Dummy = 0xFF; 
....................     ClearSPIDoneFlag(); 
....................     while(i--) 
....................     { 
....................         if(((BYTE_VAL*)&Dummy)->bits.b0) 
....................         { 
....................             // End bust operation 
....................             ENC_CS_IO = 1; 
....................             ((BYTE_VAL*)&Dummy)->bits.b0 = 0; 
....................  
....................             // Start the burst operation 
....................             ENC_CS_IO = 0; 
....................             ENC_SSPBUF = RBM;       // Send the Read Buffer Memory opcode. 
....................             WaitForDataByte();      // Wait until opcode/address is transmitted. 
....................         } 
....................         else 
....................             Dummy = 0xFF; 
....................  
....................         ENC_SSPBUF = 0;     // Send a dummy byte to receive a byte 
....................         if(val) 
....................         { 
....................             WaitForDataByte();  // Wait until byte is received. 
....................             *val++ = ENC_SSPBUF; 
....................         } 
....................         else 
....................         { 
....................             WaitForDataByte();  // Wait until byte is received. 
....................         } 
....................     } 
....................  
....................     ENC_CS_IO = 1; 
....................  
....................     return len; 
.................... #else 
....................     WORD i; 
....................     volatile BYTE Dummy; 
....................  
....................     // Start the burst operation 
....................     ENC_CS_IO = 0; 
*
00E68:  BCF    F8C.1
....................     ClearSPIDoneFlag(); 
00E6A:  BCF    F9E.3
....................     ENC_SSPBUF = RBM;       // Send the Read Buffer Memory opcode. 
00E6C:  MOVLW  3A
00E6E:  MOVWF  FC9
....................     i = 0; 
00E70:  MOVLB  3
00E72:  CLRF   x87
00E74:  CLRF   x86
....................     if(val) 
00E76:  MOVF   x82,W
00E78:  IORWF  x83,W
00E7A:  BZ    0E84
....................         val--; 
00E7C:  MOVF   x82,W
00E7E:  BTFSC  FD8.2
00E80:  DECF   x83,F
00E82:  DECF   x82,F
....................     WaitForDataByte();      // Wait until opcode/address is transmitted. 
00E84:  BTFSS  F9E.3
00E86:  BRA    0E84
00E88:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
00E8A:  MOVFF  FC9,388
....................  
....................     #if defined(__C32__) 
....................     { 
....................         DWORD_VAL dwv; 
....................  
....................         // Read the data, 4 bytes at a time, for as long as possible 
....................         if(len >= 4) 
....................         { 
....................             ENC_SPICON1bits.MODE32 = 1; 
....................             while(1) 
....................             { 
....................                 ENC_SSPBUF = 0x00000000;    // Send a dummy DWORD to generate 32 clocks 
....................                 i += 4; 
....................                 WaitForDataByte();         // Wait until DWORD is transmitted 
....................                 dwv.Val = ENC_SSPBUF; 
....................                 if(val) 
....................                 { 
....................                     *(++val) = dwv.v[3]; 
....................                     *(++val) = dwv.v[2]; 
....................                     *(++val) = dwv.v[1]; 
....................                     *(++val) = dwv.v[0]; 
....................                 } 
....................                 if(len - i < 4) 
....................                     break; 
....................             }; 
....................             ENC_SPICON1bits.MODE32 = 0; 
....................         } 
....................     } 
....................     #elif defined(__C30__) 
....................     { 
....................         WORD_VAL wv; 
....................  
....................         // Read the data, 2 bytes at a time, for as long as possible 
....................         if(len >= 2) 
....................         { 
....................             ENC_SPISTATbits.SPIEN = 0; 
....................             ENC_SPICON1bits.MODE16 = 1; 
....................             ENC_SPISTATbits.SPIEN = 1; 
....................             while(1) 
....................             { 
....................                 ENC_SSPBUF = 0x0000;    // Send a dummy WORD to generate 32 clocks 
....................                 i += 2; 
....................                 WaitForDataByte();      // Wait until WORD is transmitted 
....................                 wv.Val = ENC_SSPBUF; 
....................                 if(val) 
....................                 { 
....................                     *(++val) = wv.v[1]; 
....................                     *(++val) = wv.v[0]; 
....................                 } 
....................                 if(len - i < 2) 
....................                     break; 
....................             }; 
....................             ENC_SPISTATbits.SPIEN = 0; 
....................             ENC_SPICON1bits.MODE16 = 0; 
....................             ENC_SPISTATbits.SPIEN = 1; 
....................         } 
....................     } 
....................     #endif 
....................  
....................     // Read the data 
....................     while(i<len) 
00E8E:  MOVF   x87,W
00E90:  SUBWF  x85,W
00E92:  BNC   0ED0
00E94:  BNZ   0E9C
00E96:  MOVF   x84,W
00E98:  SUBWF  x86,W
00E9A:  BC    0ED0
....................     { 
....................         ENC_SSPBUF = 0;     // Send a dummy byte to receive a byte 
00E9C:  CLRF   FC9
....................         i++; 
00E9E:  INCF   x86,F
00EA0:  BTFSC  FD8.2
00EA2:  INCF   x87,F
....................         if(val) 
00EA4:  MOVF   x82,W
00EA6:  IORWF  x83,W
00EA8:  BZ    0EC4
....................         { 
....................             val++; 
00EAA:  INCF   x82,F
00EAC:  BTFSC  FD8.2
00EAE:  INCF   x83,F
....................             WaitForDataByte();  // Wait until byte is received. 
00EB0:  BTFSS  F9E.3
00EB2:  BRA    0EB0
00EB4:  BCF    F9E.3
....................             *val = ENC_SSPBUF; 
00EB6:  MOVFF  382,FE9
00EBA:  MOVFF  383,FEA
00EBE:  MOVFF  FC9,FEF
....................         } 
00EC2:  BRA    0ECE
....................         else 
....................         { 
....................             WaitForDataByte();  // Wait until byte is received. 
00EC4:  BTFSS  F9E.3
00EC6:  BRA    0EC4
00EC8:  BCF    F9E.3
....................             Dummy = ENC_SSPBUF; 
00ECA:  MOVFF  FC9,388
....................         } 
00ECE:  BRA    0E8E
....................     }; 
....................  
....................     // Terminate the burst operation 
....................     ENC_CS_IO = 1; 
00ED0:  BSF    F8C.1
....................  
....................     return i; 
00ED2:  MOVFF  386,01
00ED6:  MOVFF  387,02
.................... #endif 
00EDA:  MOVLB  0
00EDC:  RETURN 0
.................... }//end MACGetArray 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPut(BYTE val) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           Byte to write into the ENC28J60 buffer memory 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPut outputs the Write Buffer Memory opcode/constant 
....................  *                  (8 bits) and data to write (8 bits) over the SPI. 
....................  *                  EWRPT is incremented after the write. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPut(BYTE val) 
.................... { 
....................     volatile BYTE Dummy; 
....................  
....................     ENC_CS_IO = 0; 
*
008FA:  BCF    F8C.1
....................     ClearSPIDoneFlag(); 
008FC:  BCF    F9E.3
....................  
....................     #if defined(__C32__) 
....................     { 
....................         // Send the Write Buffer Memory and data, in on 16-bit write 
....................         ENC_SPICON1bits.MODE16 = 1; 
....................         ENC_SSPBUF = (WBM<<8) | (WORD)val;  // Start sending the WORD 
....................         WaitForDataByte();                  // Wait until WORD is transmitted 
....................         ENC_SPICON1bits.MODE16 = 0; 
....................     } 
....................     #elif defined(__C30__) 
....................     { 
....................         // Send the Write Buffer Memory and data, in on 16-bit write 
....................         ENC_SPISTATbits.SPIEN = 0; 
....................         ENC_SPICON1bits.MODE16 = 1; 
....................         ENC_SPISTATbits.SPIEN = 1; 
....................         ENC_SSPBUF = (WBM<<8) | (WORD)val;  // Start sending the WORD 
....................         WaitForDataByte();                  // Wait until WORD is transmitted 
....................         ENC_SPISTATbits.SPIEN = 0; 
....................         ENC_SPICON1bits.MODE16 = 0; 
....................         ENC_SPISTATbits.SPIEN = 1; 
....................     } 
....................     #else 
....................     { 
....................         ENC_SSPBUF = WBM;       // Send the opcode and constant. 
008FE:  MOVLW  7A
00900:  MOVWF  FC9
....................         WaitForDataByte();      // Wait until opcode/constant is transmitted. 
00902:  BTFSS  F9E.3
00904:  BRA    0902
00906:  BCF    F9E.3
....................         Dummy = ENC_SSPBUF; 
00908:  MOVFF  FC9,384
....................         ENC_SSPBUF = val;       // Send the byte to be writen. 
0090C:  MOVFF  383,FC9
....................         WaitForDataByte();      // Wait until finished transmitting 
00910:  BTFSS  F9E.3
00912:  BRA    0910
00914:  BCF    F9E.3
....................     } 
....................     #endif 
....................  
....................     Dummy = ENC_SSPBUF; 
00916:  MOVFF  FC9,384
....................     ENC_CS_IO = 1; 
0091A:  BSF    F8C.1
0091C:  RETURN 0
.................... }//end MACPut 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPutArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           *val: Pointer to source of bytes to copy. 
....................  *                  len:  Number of bytes to write to the data buffer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPutArray writes several sequential bytes to the 
....................  *                  ENC28J60 RAM.  It performs faster than multiple MACPut() 
....................  *                  calls.  EWRPT is incremented by len. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPutArray(BYTE *val, WORD len) 
.................... { 
.................... // Workaround needed on HPC Explorer (classic) board to prevent interference 
.................... // with I2C temperature sensor on the same SPI wires 
.................... #if defined(__18F8722) || defined(_18F8722) ||  defined(__18F8723) || defined(_18F8723) 
....................     WORD i; 
....................     volatile BYTE Dummy; 
....................  
....................     i = len; 
....................     Dummy = 0xFF; 
....................     ClearSPIDoneFlag(); 
....................     while(i--) 
....................     { 
....................         if(((BYTE_VAL*)&Dummy)->bits.b0) 
....................         { 
....................             // End bust operation 
....................             ENC_CS_IO = 1; 
....................             ((BYTE_VAL*)&Dummy)->bits.b0 = 0; 
....................  
....................             // Start the burst operation 
....................             ENC_CS_IO = 0; 
....................             ENC_SSPBUF = WBM;       // Send the Read Buffer Memory opcode. 
....................             WaitForDataByte();      // Wait until opcode/address is transmitted. 
....................         } 
....................         else 
....................             Dummy = 0xFF; 
....................  
....................         ENC_SSPBUF = *val++;    // Send byte 
....................         WaitForDataByte();      // Wait until byte is sent 
....................     } 
....................  
....................     ENC_CS_IO = 1; 
....................  
....................     return; 
.................... #else 
....................     volatile BYTE Dummy; 
....................  
....................     // Select the chip and send the proper opcode 
....................     ENC_CS_IO = 0; 
*
00DB6:  BCF    F8C.1
....................     ClearSPIDoneFlag(); 
00DB8:  BCF    F9E.3
....................     ENC_SSPBUF = WBM;       // Send the Write Buffer Memory opcode 
00DBA:  MOVLW  7A
00DBC:  MOVWF  FC9
....................     WaitForDataByte();      // Wait until opcode/constant is transmitted. 
00DBE:  BTFSS  F9E.3
00DC0:  BRA    0DBE
00DC2:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
00DC4:  MOVFF  FC9,388
....................  
....................     #if defined(__C32__) 
....................     { 
....................         DWORD_VAL dwv; 
....................  
....................         // Send the data, 4 bytes at a time, for as long as possible 
....................         if(len >= 4) 
....................         { 
....................             dwv.v[3] = *val++; 
....................             dwv.v[2] = *val++; 
....................             dwv.v[1] = *val++; 
....................             dwv.v[0] = *val++; 
....................             ENC_SPICON1bits.MODE32 = 1; 
....................             while(1) 
....................             { 
....................                 ENC_SSPBUF = dwv.Val;       // Start sending the DWORD 
....................                 len -= 4; 
....................                 if(len < 4) 
....................                     break; 
....................                 dwv.v[3] = *val++; 
....................                 dwv.v[2] = *val++; 
....................                 dwv.v[1] = *val++; 
....................                 dwv.v[0] = *val++; 
....................                 WaitForDataByte();          // Wait until DWORD is transmitted 
....................                 Dummy = ENC_SSPBUF; 
....................             }; 
....................             WaitForDataByte();              // Wait until DWORD is transmitted 
....................             Dummy = ENC_SSPBUF; 
....................             ENC_SPICON1bits.MODE32 = 0; 
....................         } 
....................     } 
....................     #elif defined(__C30__) 
....................     { 
....................         WORD_VAL wv; 
....................  
....................         // Send the data, 2 bytes at a time, for as long as possible 
....................         if(len >= 2) 
....................         { 
....................             wv.v[1] = *val++; 
....................             wv.v[0] = *val++; 
....................             ENC_SPISTATbits.SPIEN = 0; 
....................             ENC_SPICON1bits.MODE16 = 1; 
....................             ENC_SPISTATbits.SPIEN = 1; 
....................             while(1) 
....................             { 
....................                 ENC_SSPBUF = wv.Val;        // Start sending the WORD 
....................                 len -= 2; 
....................                 if(len < 2) 
....................                     break; 
....................                 wv.v[1] = *val++; 
....................                 wv.v[0] = *val++; 
....................                 WaitForDataByte();          // Wait until WORD is transmitted 
....................                 Dummy = ENC_SSPBUF; 
....................             }; 
....................             WaitForDataByte();              // Wait until WORD is transmitted 
....................             Dummy = ENC_SSPBUF; 
....................             ENC_SPISTATbits.SPIEN = 0; 
....................             ENC_SPICON1bits.MODE16 = 0; 
....................             ENC_SPISTATbits.SPIEN = 1; 
....................         } 
....................     } 
....................     #endif 
....................  
....................     // Send the data, one byte at a time 
....................     while(len) 
00DC8:  MOVLB  3
00DCA:  MOVF   x86,W
00DCC:  IORWF  x87,W
00DCE:  BZ    0DF6
....................     { 
....................         ENC_SSPBUF = *val;  // Start sending the byte 
00DD0:  MOVFF  384,FE9
00DD4:  MOVFF  385,FEA
00DD8:  MOVFF  FEF,FC9
....................         val++;              // Increment after writing to ENC_SSPBUF to increase speed 
00DDC:  INCF   x84,F
00DDE:  BTFSC  FD8.2
00DE0:  INCF   x85,F
....................         len--;              // Decrement after writing to ENC_SSPBUF to increase speed 
00DE2:  MOVF   x86,W
00DE4:  BTFSC  FD8.2
00DE6:  DECF   x87,F
00DE8:  DECF   x86,F
....................         WaitForDataByte();  // Wait until byte is transmitted 
00DEA:  BTFSS  F9E.3
00DEC:  BRA    0DEA
00DEE:  BCF    F9E.3
....................         Dummy = ENC_SSPBUF; 
00DF0:  MOVFF  FC9,388
00DF4:  BRA    0DCA
....................     }; 
....................  
....................     // Terminate the burst operation 
....................     ENC_CS_IO = 1; 
00DF6:  BSF    F8C.1
.................... #endif 
00DF8:  MOVLB  0
00DFA:  RETURN 0
.................... }//end MACPutArray 
....................  
....................  
.................... #if defined(__18CXX) 
.................... /****************************************************************************** 
....................  * Function:        void MACPutROMArray(ROM BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           *val: Pointer to source of bytes to copy. 
....................  *                  len:  Number of bytes to write to the data buffer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPutArray writes several sequential bytes to the 
....................  *                  ENC28J60 RAM.  It performs faster than multiple MACPut() 
....................  *                  calls.  EWRPT is incremented by len. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPutROMArray(ROM BYTE *val, WORD len) 
.................... { 
.................... // Workaround needed on HPC Explorer (classic) board to prevent interference 
.................... // with I2C temperature sensor on the same SPI wires 
.................... #if defined(__18F8722) || defined(_18F8722) ||  defined(__18F8723) || defined(_18F8723) 
....................     WORD i; 
....................     volatile BYTE Dummy; 
....................  
....................     i = len; 
....................     Dummy = 0xFF; 
....................     ClearSPIDoneFlag(); 
....................     while(i--) 
....................     { 
....................         if(((BYTE_VAL*)&Dummy)->bits.b0) 
....................         { 
....................             // End bust operation 
....................             ENC_CS_IO = 1; 
....................             ((BYTE_VAL*)&Dummy)->bits.b0 = 0; 
....................  
....................             // Start the burst operation 
....................             ENC_CS_IO = 0; 
....................             ENC_SSPBUF = WBM;       // Send the Read Buffer Memory opcode. 
....................             WaitForDataByte();      // Wait until opcode/address is transmitted. 
....................         } 
....................         else 
....................             Dummy = 0xFF; 
....................  
....................         ENC_SSPBUF = *val++;    // Send byte 
....................         WaitForDataByte();      // Wait until byte is sent 
....................     } 
....................  
....................     ENC_CS_IO = 1; 
....................  
....................     return; 
.................... #else 
....................     volatile BYTE Dummy; 
....................  
....................     // Select the chip and send the proper opcode 
....................     ENC_CS_IO = 0; 
....................     ClearSPIDoneFlag(); 
....................     ENC_SSPBUF = WBM;       // Send the Write Buffer Memory opcode 
....................     WaitForDataByte();      // Wait until opcode/constant is transmitted. 
....................     Dummy = ENC_SSPBUF; 
....................  
....................     // Send the data 
....................     while(len) 
....................     { 
....................         ENC_SSPBUF = *val;  // Start sending the byte 
....................         val++;              // Increment after writing to ENC_SSPBUF to increase speed 
....................         len--;              // Decrement after writing to ENC_SSPBUF to increase speed 
....................         WaitForDataByte();  // Wait until byte is transmitted 
....................         Dummy = ENC_SSPBUF; 
....................     }; 
....................  
....................     // Terminate the burst operation 
....................     ENC_CS_IO = 1; 
.................... #endif 
.................... }//end MACPutROMArray 
.................... #endif 
....................  
.................... /****************************************************************************** 
....................  * Function:        static void SendSystemReset(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SendSystemReset sends the System Reset SPI command to 
....................  *                  the Ethernet controller.  It resets all register contents 
....................  *                  (except for ECOCON) and returns the device to the power 
....................  *                  on default state. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void SendSystemReset(void) 
.................... { 
....................     volatile BYTE Dummy; 
....................  
....................     // Note: The power save feature may prevent the reset from executing, so 
....................     // we must make sure that the device is not in power save before issuing 
....................     // a reset. 
....................     BFCReg(ECON2, ECON2_PWRSV); 
*
0086E:  MOVLW  1E
00870:  MOVLB  3
00872:  MOVWF  x7A
00874:  MOVLW  20
00876:  MOVWF  x7B
00878:  MOVLB  0
0087A:  RCALL  0844
....................  
....................     // Give some opportunity for the regulator to reach normal regulation and 
....................     // have all clocks running 
....................     DelayMs(1); 
0087C:  MOVLW  01
0087E:  MOVLB  3
00880:  MOVWF  x1B
00882:  MOVLB  0
00884:  RCALL  02F6
....................  
....................     // Execute the System Reset command 
....................     ENC_CS_IO = 0; 
00886:  BCF    F8C.1
....................     ClearSPIDoneFlag(); 
00888:  BCF    F9E.3
....................     ENC_SSPBUF = SR; 
0088A:  SETF   FC9
....................     WaitForDataByte();      // Wait until the command is transmitted. 
0088C:  BTFSS  F9E.3
0088E:  BRA    088C
00890:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
00892:  MOVFF  FC9,2E4
....................     ENC_CS_IO = 1; 
00896:  BSF    F8C.1
....................  
....................     // Wait for the oscillator start up timer and PHY to become ready 
....................     DelayMs(1); 
00898:  MOVLW  01
0089A:  MOVLB  3
0089C:  MOVWF  x1B
0089E:  MOVLB  0
008A0:  RCALL  02F6
008A2:  GOTO   0A6A (RETURN)
.................... }//end SendSystemReset 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadETHReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  Bank select bits must be set corresponding to the register 
....................  *                  to read from. 
....................  * 
....................  * Input:           5 bit address of the ETH control register to read from. 
....................  *                    The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's ETH register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadETHReg sends the 8 bit RCR opcode/Address byte over 
....................  *                  the SPI and then retrives the register contents in the 
....................  *                  next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access MAC/MII or PHY 
....................  *                  registers.  Use ReadMACReg() or ReadPHYReg() for that 
....................  *                  purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadETHReg(BYTE Address) 
.................... { 
....................     REG r; 
....................  
....................     // Select the chip and send the Read Control Register opcode/address 
....................     ENC_CS_IO = 0; 
008A6:  BCF    F8C.1
....................     ClearSPIDoneFlag(); 
008A8:  BCF    F9E.3
....................     ENC_SSPBUF = RCR | Address; 
008AA:  MOVLB  3
008AC:  MOVFF  380,FC9
....................  
....................     WaitForDataByte();      // Wait until the opcode/address is transmitted 
008B0:  BTFSS  F9E.3
008B2:  BRA    08B0
008B4:  BCF    F9E.3
....................     r.Val = ENC_SSPBUF; 
008B6:  MOVFF  FC9,381
....................     ENC_SSPBUF = 0;         // Send a dummy byte to receive the register 
008BA:  CLRF   FC9
....................                             //   contents 
....................     WaitForDataByte();      // Wait until the register is received 
008BC:  BTFSS  F9E.3
008BE:  BRA    08BC
008C0:  BCF    F9E.3
....................     r.Val = ENC_SSPBUF; 
008C2:  MOVFF  FC9,381
....................     ENC_CS_IO = 1; 
008C6:  BSF    F8C.1
....................  
....................     return r; 
008C8:  MOVFF  381,01
008CC:  MOVLB  0
008CE:  RETURN 0
.................... }//end ReadETHReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadMACReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  Bank select bits must be set corresponding to the register 
....................  *                  to read from. 
....................  * 
....................  * Input:           5 bit address of the MAC or MII register to read from. 
....................  *                    The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's MAC/MII register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadMACReg sends the 8 bit RCR opcode/Address byte as well 
....................  *                  as a dummy byte over the SPI and then retrives the 
....................  *                  register contents in the last 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access ETH or PHY 
....................  *                  registers.  Use ReadETHReg() or ReadPHYReg() for that 
....................  *                  purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadMACReg(BYTE Address) 
.................... { 
....................     REG r; 
....................  
....................     ENC_CS_IO = 0; 
*
0097E:  BCF    F8C.1
....................     ClearSPIDoneFlag(); 
00980:  BCF    F9E.3
....................     ENC_SSPBUF = RCR | Address; // Send the Read Control Register opcode and 
00982:  MOVLB  2
00984:  MOVFF  2E7,FC9
....................                                 //   address. 
....................     WaitForDataByte();          // Wait until opcode/address is transmitted. 
00988:  BTFSS  F9E.3
0098A:  BRA    0988
0098C:  BCF    F9E.3
....................     r.Val = ENC_SSPBUF; 
0098E:  MOVFF  FC9,2E8
....................     ENC_SSPBUF = 0;             // Send a dummy byte 
00992:  CLRF   FC9
....................     WaitForDataByte();          // Wait for the dummy byte to be transmitted 
00994:  BTFSS  F9E.3
00996:  BRA    0994
00998:  BCF    F9E.3
....................     r.Val = ENC_SSPBUF; 
0099A:  MOVFF  FC9,2E8
....................     ENC_SSPBUF = 0;             // Send another dummy byte to receive the register 
0099E:  CLRF   FC9
....................                                 //   contents. 
....................     WaitForDataByte();          // Wait until register is received. 
009A0:  BTFSS  F9E.3
009A2:  BRA    09A0
009A4:  BCF    F9E.3
....................     r.Val = ENC_SSPBUF; 
009A6:  MOVFF  FC9,2E8
....................     ENC_CS_IO = 1; 
009AA:  BSF    F8C.1
....................  
....................     return r; 
009AC:  MOVFF  2E8,01
009B0:  MOVLB  0
009B2:  RETURN 0
.................... }//end ReadMACReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        ReadPHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to read from. 
....................  * 
....................  * Output:          16 bits of data read from the PHY register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadPHYReg performs an MII read operation.  While in 
....................  *                  progress, it simply polls the MII BUSY bit wasting time 
....................  *                  (10.24us). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PHYREG ReadPHYReg(BYTE Register) 
.................... { 
....................     PHYREG Result; 
....................  
....................     // Set the right address and start the register read operation 
....................     BankSel(MIREGADR); 
*
05B5A:  MOVLW  02
05B5C:  MOVLB  3
05B5E:  MOVWF  x65
05B60:  MOVLW  14
05B62:  MOVWF  x64
05B64:  MOVLB  0
05B66:  CALL   0948
....................     WriteReg((BYTE)MIREGADR, Register); 
05B6A:  MOVLW  14
05B6C:  MOVLB  3
05B6E:  MOVWF  x85
05B70:  MOVFF  2E3,386
05B74:  MOVLB  0
05B76:  CALL   08D0
....................     WriteReg((BYTE)MICMD, MICMD_MIIRD); 
05B7A:  MOVLW  12
05B7C:  MOVLB  3
05B7E:  MOVWF  x85
05B80:  MOVLW  01
05B82:  MOVWF  x86
05B84:  MOVLB  0
05B86:  CALL   08D0
....................  
....................     // Loop to wait until the PHY register has been read through the MII 
....................     // This requires 10.24us 
....................     BankSel(MISTAT); 
05B8A:  MOVLW  03
05B8C:  MOVLB  3
05B8E:  MOVWF  x65
05B90:  MOVLW  0A
05B92:  MOVWF  x64
05B94:  MOVLB  0
05B96:  CALL   0948
....................     while(ReadMACReg((BYTE)MISTAT).MISTATbits.BUSY); 
05B9A:  MOVLW  0A
05B9C:  MOVLB  2
05B9E:  MOVWF  xE7
05BA0:  MOVLB  0
05BA2:  CALL   097E
05BA6:  MOVFF  01,2E6
05BAA:  MOVLW  00
05BAC:  MOVLB  2
05BAE:  BTFSC  01.0
05BB0:  MOVLW  01
05BB2:  XORLW  00
05BB4:  BTFSC  FD8.2
05BB6:  BRA    5BBC
05BB8:  MOVLB  0
05BBA:  BRA    5B9A
....................  
....................     // Stop reading 
....................     BankSel(MIREGADR); 
05BBC:  MOVLW  02
05BBE:  MOVLB  3
05BC0:  MOVWF  x65
05BC2:  MOVLW  14
05BC4:  MOVWF  x64
05BC6:  MOVLB  0
05BC8:  CALL   0948
....................     WriteReg((BYTE)MICMD, 0x00); 
05BCC:  MOVLW  12
05BCE:  MOVLB  3
05BD0:  MOVWF  x85
05BD2:  CLRF   x86
05BD4:  MOVLB  0
05BD6:  CALL   08D0
....................  
....................     // Obtain results and return 
....................     Result.VAL.v[0] = ReadMACReg((BYTE)MIRDL).Val; 
05BDA:  MOVLW  18
05BDC:  MOVLB  2
05BDE:  MOVWF  xE7
05BE0:  MOVLB  0
05BE2:  CALL   097E
05BE6:  MOVFF  01,2E4
....................     Result.VAL.v[1] = ReadMACReg((BYTE)MIRDH).Val; 
05BEA:  MOVLW  19
05BEC:  MOVLB  2
05BEE:  MOVWF  xE7
05BF0:  MOVLB  0
05BF2:  CALL   097E
05BF6:  MOVFF  01,2E5
....................  
....................     BankSel(ERDPTL);    // Return to Bank 0 
05BFA:  MOVLB  3
05BFC:  CLRF   x65
05BFE:  CLRF   x64
05C00:  MOVLB  0
05C02:  CALL   0948
....................     return Result; 
05C06:  MOVLB  2
05C08:  MOVFF  2E4,01
05C0C:  MOVFF  2E5,02
05C10:  MOVLB  0
05C12:  GOTO   5C20 (RETURN)
.................... }//end ReadPHYReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void WriteReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  Bank select bits must be set corresponding to the register 
....................  *                  to modify. 
....................  * 
....................  * Input:           5 bit address of the ETH, MAC, or MII register to modify. 
....................  *                    The top 3 bits must be 0. 
....................  *                  Byte to be written into the register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        WriteReg sends the 8 bit WCR opcode/Address byte over the 
....................  *                  SPI and then sends the data to write in the next 8 SPI 
....................  *                  clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the BFCReg() and 
....................  *                  BFSReg() functions.  It is seperate to maximize speed. 
....................  *                  Unlike the ReadETHReg/ReadMACReg functions, WriteReg() 
....................  *                  can write to any ETH or MAC register.  Writing to PHY 
....................  *                  registers must be accomplished with WritePHYReg(). 
....................  *****************************************************************************/ 
.................... static void WriteReg(BYTE Address, BYTE Data) 
.................... { 
....................     volatile BYTE Dummy; 
....................  
....................     ENC_CS_IO = 0; 
*
008D0:  BCF    F8C.1
....................     ClearSPIDoneFlag(); 
008D2:  BCF    F9E.3
....................  
....................     #if defined(__C32__) 
....................     { 
....................         // Send the Write Buffer Memory and data, in on 16-bit write 
....................         ENC_SPICON1bits.MODE16 = 1; 
....................         ENC_SSPBUF = ((WCR | Address)<<8) | (WORD)Data; // Start sending the WORD 
....................         WaitForDataByte();                  // Wait until WORD is transmitted 
....................         ENC_SPICON1bits.MODE16 = 0; 
....................     } 
....................     #else 
....................     { 
....................         ENC_SSPBUF = WCR | Address; // Send the opcode and address. 
008D4:  MOVLB  3
008D6:  MOVF   x85,W
008D8:  IORLW  40
008DA:  MOVWF  FC9
....................         WaitForDataByte();          // Wait until opcode/constant is transmitted. 
008DC:  BTFSS  F9E.3
008DE:  BRA    08DC
008E0:  BCF    F9E.3
....................         Dummy = ENC_SSPBUF; 
008E2:  MOVFF  FC9,387
....................         ENC_SSPBUF = Data;          // Send the byte to be writen. 
008E6:  MOVFF  386,FC9
....................         WaitForDataByte();          // Wait until finished transmitting 
008EA:  BTFSS  F9E.3
008EC:  BRA    08EA
008EE:  BCF    F9E.3
....................     } 
....................     #endif 
....................  
....................     Dummy = ENC_SSPBUF; 
008F0:  MOVFF  FC9,387
....................  
....................  
....................    // For faster processors (dsPIC), delay for a few clock cycles to ensure  
....................    // the MAC/MII register write Chip Select hold time minimum of 210ns is met. 
....................    #if (GetInstructionClock() > 30000000) 
....................       Nop(); 
....................       Nop(); 
....................    #endif 
....................    #if (GetInstructionClock() > 40000000) 
....................       Nop(); 
....................       Nop(); 
....................    #endif 
....................    #if (GetInstructionClock() > 50000000) 
....................       Nop(); 
....................       Nop(); 
....................    #endif 
....................  
....................    ENC_CS_IO = 1; 
008F4:  BSF    F8C.1
008F6:  MOVLB  0
008F8:  RETURN 0
.................... }//end WriteReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFCReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  Bank select bits must be set corresponding to the register 
....................  *                    to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                    must be 0. 
....................  *                  Byte to be used with the Bit Field Clear operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFCReg sends the 8 bit BFC opcode/Address byte over the 
....................  *                  SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *                  BFSReg() functions.  It is separate to maximize speed. 
....................  *                  BFCReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFCReg(BYTE Address, BYTE Data) 
.................... { 
....................     volatile BYTE Dummy; 
....................  
....................     ENC_CS_IO = 0; 
*
00844:  BCF    F8C.1
....................     ClearSPIDoneFlag(); 
00846:  BCF    F9E.3
....................     ENC_SSPBUF = BFC | Address; // Send the opcode and address. 
00848:  MOVLB  3
0084A:  MOVF   x7A,W
0084C:  IORLW  A0
0084E:  MOVWF  FC9
....................     WaitForDataByte();          // Wait until opcode/address is transmitted. 
00850:  BTFSS  F9E.3
00852:  BRA    0850
00854:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
00856:  MOVFF  FC9,37C
....................     ENC_SSPBUF = Data;          // Send the byte to be writen. 
0085A:  MOVFF  37B,FC9
....................     WaitForDataByte();          // Wait until register is written. 
0085E:  BTFSS  F9E.3
00860:  BRA    085E
00862:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
00864:  MOVFF  FC9,37C
....................     ENC_CS_IO = 1; 
00868:  BSF    F8C.1
0086A:  MOVLB  0
0086C:  RETURN 0
.................... }//end BFCReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFSReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  Bank select bits must be set corresponding to the register 
....................  *                  to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                    must be 0. 
....................  *                  Byte to be used with the Bit Field Set operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFSReg sends the 8 bit BFC opcode/Address byte over the 
....................  *                  SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *                  BFCReg() functions.  It is separate to maximize speed. 
....................  *                  BFSReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFSReg(BYTE Address, BYTE Data) 
.................... { 
....................     volatile BYTE Dummy; 
....................  
....................     ENC_CS_IO = 0; 
*
0091E:  BCF    F8C.1
....................     ClearSPIDoneFlag(); 
00920:  BCF    F9E.3
....................     ENC_SSPBUF = BFS | Address; // Send the opcode and address. 
00922:  MOVLB  3
00924:  MOVF   x7A,W
00926:  IORLW  80
00928:  MOVWF  FC9
....................     WaitForDataByte();          // Wait until opcode/address is transmitted. 
0092A:  BTFSS  F9E.3
0092C:  BRA    092A
0092E:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
00930:  MOVFF  FC9,37C
....................     ENC_SSPBUF = Data;          // Send the byte to be writen. 
00934:  MOVFF  37B,FC9
....................     WaitForDataByte();          // Wait until register is written. 
00938:  BTFSS  F9E.3
0093A:  BRA    0938
0093C:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
0093E:  MOVFF  FC9,37C
....................     ENC_CS_IO = 1; 
00942:  BSF    F8C.1
00944:  MOVLB  0
00946:  RETURN 0
.................... }//end BFSReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WritePHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to write to. 
....................  *                  16 bits of data to write to PHY register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 3 
....................  * 
....................  * Overview:        WritePHYReg performs an MII write operation.  While in 
....................  *                  progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void WritePHYReg(BYTE Register, WORD Data) 
.................... { 
....................     // Write the register address 
....................     BankSel(MIREGADR); 
*
009B4:  MOVLW  02
009B6:  MOVLB  3
009B8:  MOVWF  x65
009BA:  MOVLW  14
009BC:  MOVWF  x64
009BE:  MOVLB  0
009C0:  RCALL  0948
....................     WriteReg((BYTE)MIREGADR, Register); 
009C2:  MOVLW  14
009C4:  MOVLB  3
009C6:  MOVWF  x85
009C8:  MOVFF  2E4,386
009CC:  MOVLB  0
009CE:  RCALL  08D0
....................  
....................     // Write the data 
....................     // Order is important: write low byte first, high byte last 
....................     WriteReg((BYTE)MIWRL, ((WORD_VAL*)&Data)->v[0]); 
009D0:  MOVLW  02
009D2:  MOVLB  2
009D4:  MOVWF  xE8
009D6:  MOVLW  E5
009D8:  MOVWF  xE7
009DA:  MOVWF  FE9
009DC:  MOVFF  2E8,FEA
009E0:  MOVFF  FEF,2E9
009E4:  MOVLW  16
009E6:  MOVLB  3
009E8:  MOVWF  x85
009EA:  MOVFF  2E9,386
009EE:  MOVLB  0
009F0:  RCALL  08D0
....................     WriteReg((BYTE)MIWRH, ((WORD_VAL*)&Data)->v[1]); 
009F2:  MOVLW  02
009F4:  MOVLB  2
009F6:  MOVWF  xE8
009F8:  MOVLW  E5
009FA:  MOVWF  xE7
009FC:  MOVLW  01
009FE:  ADDWF  xE7,W
00A00:  MOVWF  FE9
00A02:  MOVLW  00
00A04:  ADDWFC xE8,W
00A06:  MOVWF  FEA
00A08:  MOVFF  FEF,2E9
00A0C:  MOVLW  17
00A0E:  MOVLB  3
00A10:  MOVWF  x85
00A12:  MOVFF  2E9,386
00A16:  MOVLB  0
00A18:  RCALL  08D0
....................  
....................     // Wait until the PHY register has been written 
....................     BankSel(MISTAT); 
00A1A:  MOVLW  03
00A1C:  MOVLB  3
00A1E:  MOVWF  x65
00A20:  MOVLW  0A
00A22:  MOVWF  x64
00A24:  MOVLB  0
00A26:  RCALL  0948
....................     while(ReadMACReg((BYTE)MISTAT).MISTATbits.BUSY); 
00A28:  MOVLW  0A
00A2A:  MOVLB  2
00A2C:  MOVWF  xE7
00A2E:  MOVLB  0
00A30:  RCALL  097E
00A32:  MOVFF  01,2E7
00A36:  MOVLW  00
00A38:  MOVLB  2
00A3A:  BTFSC  01.0
00A3C:  MOVLW  01
00A3E:  XORLW  00
00A40:  BTFSC  FD8.2
00A42:  BRA    0A48
00A44:  MOVLB  0
00A46:  BRA    0A28
....................  
....................     BankSel(ERDPTL);    // Return to Bank 0 
00A48:  MOVLB  3
00A4A:  CLRF   x65
00A4C:  CLRF   x64
00A4E:  MOVLB  0
00A50:  RCALL  0948
00A52:  RETURN 0
.................... }//end WritePHYReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BankSel 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Register address with the high byte containing the 2 bank 
....................  *                    select 2 bits. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BankSel takes the high byte of a register address and 
....................  *                  changes the bank select bits in ETHCON1 to match. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void BankSel(WORD Register) 
.................... { 
....................     BFCReg(ECON1, ECON1_BSEL1 | ECON1_BSEL0); 
*
00948:  MOVLW  1F
0094A:  MOVLB  3
0094C:  MOVWF  x7A
0094E:  MOVLW  03
00950:  MOVWF  x7B
00952:  MOVLB  0
00954:  RCALL  0844
....................     BFSReg(ECON1, ((WORD_VAL*)&Register)->v[1]); 
00956:  MOVLW  03
00958:  MOVLB  3
0095A:  MOVWF  x67
0095C:  MOVLW  64
0095E:  MOVWF  x66
00960:  MOVLW  01
00962:  ADDWF  x66,W
00964:  MOVWF  FE9
00966:  MOVLW  00
00968:  ADDWFC x67,W
0096A:  MOVWF  FEA
0096C:  MOVFF  FEF,368
00970:  MOVLW  1F
00972:  MOVWF  x7A
00974:  MOVFF  368,37B
00978:  MOVLB  0
0097A:  RCALL  091E
0097C:  RETURN 0
.................... }//end BankSel 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerDown(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerDown puts the ENC28J60 in low power sleep mode. In 
....................  *                  sleep mode, no packets can be transmitted or received. 
....................  *                  All MAC and PHY registers should not be accessed. 
....................  * 
....................  * Note:            If a packet is being transmitted while this function is 
....................  *                  called, this function will block until it is it complete. 
....................  *                  If anything is being received, it will be completed. 
....................  *****************************************************************************/ 
.................... void MACPowerDown(void) 
.................... { 
....................     // Disable packet reception 
....................     BFCReg(ECON1, ECON1_RXEN); 
....................  
....................     // Make sure any last packet which was in-progress when RXEN was cleared 
....................     // is completed 
....................     while(ReadETHReg(ESTAT).ESTATbits.RXBUSY); 
....................  
....................     // If a packet is being transmitted, wait for it to finish 
....................     while(ReadETHReg(ECON1).ECON1bits.TXRTS); 
....................  
....................     // Enter sleep mode 
....................     BFSReg(ECON2, ECON2_PWRSV); 
.................... }//end MACPowerDown 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerUp(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerUp returns the ENC28J60 back to normal operation 
....................  *                  after a previous call to MACPowerDown().  Calling this 
....................  *                  function when already powered up will have no effect. 
....................  * 
....................  * Note:            If a link partner is present, it will take 10s of 
....................  *                  milliseconds before a new link will be established after 
....................  *                  waking up.  While not linked, packets which are 
....................  *                  transmitted will most likely be lost.  MACIsLinked() can 
....................  *                  be called to determine if a link is established. 
....................  *****************************************************************************/ 
.................... void MACPowerUp(void) 
.................... { 
....................     // Leave power down mode 
....................     BFCReg(ECON2, ECON2_PWRSV); 
....................  
....................     // Wait for the 300us Oscillator Startup Timer (OST) to time out.  This 
....................     // delay is required for the PHY module to return to an operational state. 
....................     while(!ReadETHReg(ESTAT).ESTATbits.CLKRDY); 
....................  
....................     // Enable packet reception 
....................     BFSReg(ECON1, ECON1_RXEN); 
.................... }//end MACPowerUp 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void SetCLKOUT(BYTE NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - 0x00: CLKOUT disabled (pin driven low) 
....................  *                              0x01: Divide by 1 (25 MHz) 
....................  *                              0x02: Divide by 2 (12.5 MHz) 
....................  *                              0x03: Divide by 3 (8.333333 MHz) 
....................  *                              0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                              0x05: Divide by 8 (3.125 MHz) 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the ECOCON register. 
....................  *                  The CLKOUT pin will beginning outputting the new frequency 
....................  *                  immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... void SetCLKOUT(BYTE NewConfig) 
.................... { 
....................     BankSel(ECOCON); 
....................     WriteReg((BYTE)ECOCON, NewConfig); 
....................     BankSel(ERDPTL); 
.................... }//end SetCLKOUT 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE GetCLKOUT(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          BYTE - 0x00: CLKOUT disabled (pin driven low) 
....................  *                         0x01: Divide by 1 (25 MHz) 
....................  *                         0x02: Divide by 2 (12.5 MHz) 
....................  *                         0x03: Divide by 3 (8.333333 MHz) 
....................  *                         0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                         0x05: Divide by 8 (3.125 MHz) 
....................  *                         0x06: Reserved 
....................  *                         0x07: Reserved 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the ECOCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE GetCLKOUT(void) 
.................... { 
....................     BYTE i; 
....................  
....................     BankSel(ECOCON); 
....................     i = ReadETHReg((BYTE)ECOCON).Val; 
....................     BankSel(ERDPTL); 
....................     return i; 
.................... }//end GetCLKOUT 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void SetRXHashTableEntry(MAC_ADDR DestMACAddr) 
....................  * 
....................  * PreCondition:    SPI interface must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           DestMACAddr: 6 byte group destination MAC address to allow  
....................  *                         through the Hash Table Filter.  If DestMACAddr  
....................  *                         is set to 00-00-00-00-00-00, then the hash  
....................  *                         table will be cleared of all entries and the  
....................  *                         filter will be disabled. 
....................  * 
....................  * Output:          Sets the appropriate bit in the EHT* registers to allow  
....................  *               packets sent to DestMACAddr to be received and enables the  
....................  *               Hash Table receive filter (if not already). 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Calculates a CRC-32 using polynomial 0x4C11DB7 and then,  
....................  *               using bits 28:23 of the CRC, sets the appropriate bit in  
....................  *               the EHT0-EHT7 registers. 
....................  * 
....................  * Note:            This code is commented out to save code space on systems  
....................  *               that do not need this function.  Change the  
....................  *               "#if STACK_USE_ZEROCONF_MDNS_SD" line to "#if 1" to  
....................  *               uncomment it, assuming you aren't using the Zeroconf module,  
....................  *               which requires mutlicast support and enables this function  
....................  *               automatically. 
....................  * 
....................  *               There is no way to individually unset destination MAC  
....................  *               addresses from the hash table since it is possible to have  
....................  *               a hash collision and therefore multiple MAC addresses  
....................  *               relying on the same hash table bit.  The stack would have  
....................  *               to individually store each 6 byte MAC address to support  
....................  *               this feature, which would waste a lot of RAM and be  
....................  *               unnecessary in most applications.  As a simple compromise,  
....................  *               you can call SetRXHashTableEntry() using a  
....................  *               00-00-00-00-00-00 destination MAC address, which will clear  
....................  *               the entire hash table and disable the hash table filter.   
....................  *               This will allow you to then re-add the necessary  
....................  *               destination address(es). 
....................  * 
....................  *               This function is intended to be used when  
....................  *               ERXFCON.ANDOR == 0 (OR). 
....................  *****************************************************************************/ 
.................... #if defined(STACK_USE_ZEROCONF_MDNS_SD) 
.................... void SetRXHashTableEntry(MAC_ADDR DestMACAddr) 
.................... { 
....................     DWORD_VAL CRC = {0xFFFFFFFF}; 
....................     BYTE HTRegister; 
....................     BYTE i, j; 
....................  
....................    // Select proper bank for ERXFCON and EHT0-EHT7 register access 
....................    BankSel(ERXFCON); 
....................  
....................    // Clear the Hash Table bits and disable the Hash Table Filter if a special  
....................    // 00-00-00-00-00-00 destination MAC address is provided. 
....................    if((DestMACAddr.v[0] | DestMACAddr.v[1] | DestMACAddr.v[2] | DestMACAddr.v[3] | DestMACAddr.v[4] | DestMACAddr.v[5]) == 0x00u) 
....................    { 
....................       // Disable the Hash Table receive filter and clear the hash table 
....................       BFCReg((BYTE)ERXFCON, ERXFCON_HTEN); 
....................       for(i = (BYTE)EHT0; i <= (BYTE)EHT7; i++) 
....................          WriteReg(i, 0x00); 
....................    } 
....................    else 
....................    { 
....................       // Calculate a CRC-32 over the 6 byte MAC address 
....................       // using polynomial 0x4C11DB7 
....................       for(i = 0; i < sizeof(MAC_ADDR); i++) 
....................       { 
....................          BYTE  crcnext; 
....................  
....................          // shift in 8 bits 
....................          for(j = 0; j < 8; j++) 
....................          { 
....................             crcnext = 0; 
....................             if(((BYTE_VAL*)&(CRC.v[3]))->bits.b7) 
....................                crcnext = 1; 
....................             crcnext ^= (((BYTE_VAL*)&DestMACAddr.v[i])->bits.b0); 
....................  
....................             CRC.Val <<= 1; 
....................             if(crcnext) 
....................                CRC.Val ^= 0x4C11DB7; 
....................             // next bit 
....................             DestMACAddr.v[i] >>= 1; 
....................          } 
....................       } 
....................  
....................       // CRC-32 calculated, now extract bits 28:23 
....................       // Bits 25:23 define where within the Hash Table byte the bit needs to be set 
....................       // Bits 28:26 define which of the 8 Hash Table bytes that bits 25:23 apply to 
....................       i = CRC.v[3] & 0x1F; 
....................       HTRegister = (i >> 2) + (BYTE)EHT0; 
....................       i = (i << 1) & 0x06; 
....................       ((BYTE_VAL*)&i)->bits.b0 = ((BYTE_VAL*)&CRC.v[2])->bits.b7; 
....................  
....................       // Set the proper bit in the Hash Table 
....................       BFSReg(HTRegister, 1<<i); 
....................  
....................       // Ensure that the Hash Table receive filter is enabled 
....................       BFSReg((BYTE)ERXFCON, ERXFCON_HTEN); 
....................    } 
....................  
....................     BankSel(ERDPTL);            // Return to Bank 0 
.................... } 
.................... #endif 
....................  
.................... //// GetRegs is a function for debugging purposes only.  It will read all 
.................... //// registers and store them in the PIC's RAM so they can be viewed with 
.................... //// the ICD2. 
.................... //REG Regs[4][32]; 
.................... //void GetRegs(void) 
.................... //{ 
.................... //  BYTE i; 
.................... // 
.................... //  BankSel(0x000); 
.................... //  for(i=0; i<0x1A; i++) 
.................... //      Regs[0][i] = ReadETHReg(i); 
.................... //  for(i=0x1B; i<32; i++) 
.................... //      Regs[0][i] = ReadETHReg(i); 
.................... // 
.................... //  BankSel(0x100); 
.................... //  for(i=0; i<0x1A; i++) 
.................... //      Regs[1][i] = ReadETHReg(i); 
.................... //  for(i=0x1B; i<32; i++) 
.................... //      Regs[1][i] = ReadETHReg(i); 
.................... // 
.................... //  BankSel(0x200); 
.................... //  for(i=0; i<5; i++) 
.................... //      Regs[2][i] = ReadMACReg(i); 
.................... //  Regs[2][5] = ReadETHReg(i); 
.................... //  for(i=6; i<0x0F; i++) 
.................... //      Regs[2][i] = ReadMACReg(i); 
.................... //  Regs[2][0x0F] = ReadETHReg(i); 
.................... //  for(i=0x10; i<0x13; i++) 
.................... //      Regs[2][i] = ReadMACReg(i); 
.................... //  Regs[2][0x13] = ReadETHReg(i); 
.................... //  for(i=0x14; i<0x1A; i++) 
.................... //      Regs[2][i] = ReadMACReg(i); 
.................... //  for(i=0x1B; i<32; i++) 
.................... //      Regs[2][i] = ReadETHReg(i); 
.................... // 
.................... //  BankSel(0x300); 
.................... //  for(i=0; i<0x06; i++) 
.................... //      Regs[3][i] = ReadMACReg(i); 
.................... //  for(i=6; i<0x0A; i++) 
.................... //      Regs[3][i] = ReadETHReg(i); 
.................... //  Regs[3][0x0A] = ReadMACReg(i); 
.................... //  for(i=0x0B; i<0x1A; i++) 
.................... //      Regs[3][i] = ReadETHReg(i); 
.................... //  for(i=0x1B; i<32; i++) 
.................... //      Regs[3][i] = ReadETHReg(i); 
.................... // 
.................... //  Regs[0][0x1A].Val = 0; 
.................... //  Regs[1][0x1A].Val = 0; 
.................... //  Regs[2][0x1A].Val = 0; 
.................... //  Regs[3][0x1A].Val = 0; 
.................... // 
.................... //  BankSel(ERDPTL); 
.................... // 
.................... //  return; 
.................... //} 
....................  
.................... //// Get8KBMem is a function intended for debugging purposes.  It will read all 
.................... //// Ethernet RAM and output it in hex out the UART 
.................... //void Get8KBMem(void) 
.................... //{ 
.................... //  WORD_VAL i; 
.................... //  BYTE v; 
.................... //  WORD_VAL RDSave; 
.................... // 
.................... //  RDSave.v[0] = ReadETHReg(ERDPTL).Val; 
.................... //  RDSave.v[1] = ReadETHReg(ERDPTH).Val; 
.................... // 
.................... //  for(i.Val = 0; i.Val < 8192; i.Val++) 
.................... //  { 
.................... //      WriteReg(ERDPTL, i.v[0]); 
.................... //      WriteReg(ERDPTH, i.v[1]); 
.................... //      v = MACGet(); 
.................... // 
.................... //      putcUART('0'); 
.................... //      while(BusyUART()); 
.................... //      putcUART('x'); 
.................... //      while(BusyUART()); 
.................... //      putcUART(btohexa_high(v)); 
.................... //      while(BusyUART()); 
.................... //      putcUART(btohexa_low(v)); 
.................... //      while(BusyUART()); 
.................... //  } 
.................... // 
.................... //  WriteReg(ERDPTL, RDSave.v[0]); 
.................... //  WriteReg(ERDPTH, RDSave.v[1]); 
.................... // 
.................... //} 
....................  
.................... #endif //#if defined(ENC_CS_TRIS) 
....................  
.................... #elif defined(ENC100_INTERFACE_MODE) 
....................    #include "ENCX24J600.c" 
....................    #define PHYREG WORD 
.................... #elif defined(__PIC32MX__) && defined(_ETH) 
....................    // extra includes for PIC32MX with embedded ETH Controller 
.................... #else 
....................    #error No Ethernet/WiFi controller defined in HardwareProfile.h.  Defines for an ENC28J60, ENC424J600/624J600, or ZeroG ZG2100 must be present. 
.................... #endif 
.................... #include "IP.c" 
.................... /********************************************************************* 
....................  * 
....................  *  Internet Protocol (IP) Version 4 Communications Layer 
....................  *  Module for Microchip TCP/IP Stack 
....................  *   -Provides a transport for TCP, UDP, and ICMP messages 
....................  *	 -Reference: RFC 791 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.c 
....................  * Dependencies:    Network Layer interface (ENC28J60.c, ETH97J60.c,  
....................  *					ENCX24J600.c or WFMac.c) 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder		8/31/04	Beta Rev 0.9 (See version.log for detail) 
....................  * Howard Schlunder		1/5/06	Improved DMA checksum efficiency 
....................  * Darren Rook			9/21/06	Corrected IPHeaderLen not being  
....................  * 								initialized when NON_MCHP_MAC defined. 
....................  ********************************************************************/ 
.................... #define __IP_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... // This is left shifted by 4.  Actual value is 0x04. 
.................... #define IPv4                (0x40u) 
.................... #define IP_VERSION          IPv4 
....................  
.................... // IHL (Internet Header Length) is # of DWORDs in a header. 
.................... // Since, we do not support options, our IP header length will be 
.................... // minimum i.e. 20 bytes : IHL = 20 / 4 = 5. 
.................... #define IP_IHL              (0x05) 
....................  
.................... #define IP_SERVICE_NW_CTRL  (0x07) 
.................... #define IP_SERVICE_IN_CTRL  (0x06) 
.................... #define IP_SERVICE_ECP      (0x05) 
.................... #define IP_SERVICE_OVR      (0x04) 
.................... #define IP_SERVICE_FLASH    (0x03) 
.................... #define IP_SERVICE_IMM      (0x02) 
.................... #define IP_SERVICE_PRIOR    (0x01) 
.................... #define IP_SERVICE_ROUTINE  (0x00) 
....................  
.................... #define IP_SERVICE_N_DELAY  (0x00) 
.................... #define IP_SERCICE_L_DELAY  (0x08) 
.................... #define IP_SERVICE_N_THRPT  (0x00) 
.................... #define IP_SERVICE_H_THRPT  (0x10) 
.................... #define IP_SERVICE_N_RELIB  (0x00) 
.................... #define IP_SERVICE_H_RELIB  (0x20) 
....................  
.................... #define IP_SERVICE          (IP_SERVICE_ROUTINE | IP_SERVICE_N_DELAY) 
....................  
.................... #if defined(STACK_USE_ZEROCONF_MDNS_SD) 
....................   #define MY_IP_TTL           (255)  // Time-To-Live in hops  
....................   // IP TTL is set to 255 for Multicast DNS compatibility. See mDNS-draft-08, section 4. 
.................... #else 
....................   #define MY_IP_TTL           (100)  // Time-To-Live in hops 
.................... #endif 
....................  
....................  
....................  
.................... static WORD _Identifier = 0; 
.................... static BYTE IPHeaderLen; 
....................  
....................  
.................... static void SwapIPHeader(IP_HEADER* h); 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len) 
.................... { 
....................     WORD_VAL    CalcChecksum; 
....................     IP_HEADER   header; 
....................  
.................... #if defined(NON_MCHP_MAC) 
....................     WORD_VAL    ReceivedChecksum; 
....................     WORD        checksums[2]; 
....................     BYTE        optionsLen; 
.................... 	#define MAX_OPTIONS_LEN     (40u)            // As per RFC 791. 
....................     BYTE        options[MAX_OPTIONS_LEN]; 
.................... #endif 
....................  
....................     // Read IP header. 
....................     MACGetArray((BYTE*)&header, sizeof(header)); 
*
03D20:  MOVLW  02
03D22:  MOVLB  3
03D24:  MOVWF  x0A
03D26:  MOVLW  F5
03D28:  MOVWF  x09
03D2A:  MOVFF  30A,383
03D2E:  MOVWF  x82
03D30:  CLRF   x85
03D32:  MOVLW  14
03D34:  MOVWF  x84
03D36:  MOVLB  0
03D38:  CALL   0E68
....................  
....................     // Make sure that this is an IPv4 packet. 
....................     if((header.VersionIHL & 0xf0) != IP_VERSION) 
03D3C:  MOVLB  2
03D3E:  MOVF   xF5,W
03D40:  ANDLW  F0
03D42:  SUBLW  40
03D44:  BZ    3D4C
....................     	return FALSE; 
03D46:  MOVLW  00
03D48:  MOVWF  01
03D4A:  BRA    3E1A
....................  
.................... 	// Throw this packet away if it is a fragment.   
.................... 	// We don't have enough RAM for IP fragment reconstruction. 
.................... 	if(header.FragmentInfo & 0xFF1F) 
03D4C:  MOVF   xFB,W
03D4E:  ANDLW  1F
03D50:  MOVWF  00
03D52:  MOVFF  2FC,03
03D56:  MOVF   00,W
03D58:  IORWF  xFC,W
03D5A:  BZ    3D62
.................... 		return FALSE; 
03D5C:  MOVLW  00
03D5E:  MOVWF  01
03D60:  BRA    3E1A
....................  
.................... 	IPHeaderLen = (header.VersionIHL & 0x0f) << 2; 
03D62:  MOVF   xF5,W
03D64:  ANDLW  0F
03D66:  MOVWF  00
03D68:  RLCF   00,W
03D6A:  MOVLB  0
03D6C:  MOVWF  x81
03D6E:  RLCF   x81,F
03D70:  MOVLW  FC
03D72:  ANDWF  x81,F
....................  
.................... #if !defined(NON_MCHP_MAC) 
.................... 	// Validate the IP header.  If it is correct, the checksum  
.................... 	// will come out to 0x0000 (because the header contains a  
.................... 	// precomputed checksum).  A corrupt header will have a  
.................... 	// nonzero checksum. 
.................... 	CalcChecksum.Val = MACCalcRxChecksum(0, IPHeaderLen); 
03D74:  MOVLB  3
03D76:  CLRF   x0A
03D78:  CLRF   x09
03D7A:  CLRF   x0C
03D7C:  MOVFF  81,30B
03D80:  MOVLB  0
03D82:  RCALL  3C24
03D84:  MOVFF  02,2F4
03D88:  MOVFF  01,2F3
....................  
.................... 	// Seek to the end of the IP header 
.................... 	MACSetReadPtrInRx(IPHeaderLen); 
03D8C:  MOVLB  3
03D8E:  CLRF   x3F
03D90:  MOVFF  81,33E
03D94:  MOVLB  0
03D96:  RCALL  3CD0
....................  
....................     if(CalcChecksum.Val) 
03D98:  MOVLB  2
03D9A:  MOVF   xF3,W
03D9C:  IORWF  xF4,W
03D9E:  BZ    3DA6
.................... #else 
....................     // Calculate options length in this header, if there is any. 
....................     // IHL is in terms of numbers of 32-bit DWORDs; i.e. actual 
....................     // length is 4 times IHL. 
....................     optionsLen = IPHeaderLen - sizeof(header); 
....................  
....................     // If there is any option(s), read it so that we can include them 
....................     // in checksum calculation. 
....................     if ( optionsLen > MAX_OPTIONS_LEN ) 
....................         return FALSE; 
....................  
....................     if ( optionsLen > 0u ) 
....................         MACGetArray(options, optionsLen); 
....................  
....................     // Save header checksum; clear it and recalculate it ourselves. 
....................     ReceivedChecksum.Val = header.HeaderChecksum; 
....................     header.HeaderChecksum = 0; 
....................  
....................     // Calculate checksum of header including options bytes. 
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&header, sizeof(header)); 
....................  
....................     // Calculate Options checksum too, if they are present. 
....................     if ( optionsLen > 0u ) 
....................         checksums[1] = ~CalcIPChecksum((BYTE*)options, optionsLen); 
....................     else 
....................         checksums[1] = 0; 
....................  
....................     CalcChecksum.Val  = CalcIPChecksum((BYTE*)checksums, 
....................                                             2 * sizeof(WORD)); 
....................  
....................     // Make sure that checksum is correct 
....................     if ( ReceivedChecksum.Val != CalcChecksum.Val ) 
.................... #endif 
....................     { 
....................         // Bad packet. The function caller will be notified by means of the FALSE  
....................         // return value and it should discard the packet. 
....................         return FALSE; 
03DA0:  MOVLW  00
03DA2:  MOVWF  01
03DA4:  BRA    3E1A
....................     } 
....................  
....................     // Network to host conversion. 
....................     SwapIPHeader(&header); 
03DA6:  MOVLW  02
03DA8:  MOVLB  3
03DAA:  MOVWF  x7A
03DAC:  MOVLW  F5
03DAE:  MOVWF  x79
03DB0:  MOVLB  0
03DB2:  CALL   1C32
....................  
....................     // If caller is intrested, return destination IP address 
....................     // as seen in this IP header. 
....................     if ( localIP ) 
03DB6:  MOVLB  2
03DB8:  MOVF   xEB,W
03DBA:  IORWF  xEC,W
03DBC:  BZ    3DD6
....................         localIP->Val    = header.DestAddress.Val; 
03DBE:  MOVFF  2EB,FE9
03DC2:  MOVFF  2EC,FEA
03DC6:  MOVFF  305,FEF
03DCA:  MOVFF  306,FEC
03DCE:  MOVFF  307,FEC
03DD2:  MOVFF  308,FEC
....................  
....................     remote->IPAddr.Val  = header.SourceAddress.Val; 
03DD6:  MOVFF  2ED,FE9
03DDA:  MOVF   xEE,W
03DDC:  MOVWF  FEA
03DDE:  MOVFF  301,FEF
03DE2:  MOVFF  302,FEC
03DE6:  MOVFF  303,FEC
03DEA:  MOVFF  304,FEC
....................     *protocol           = header.Protocol; 
03DEE:  MOVFF  2EF,FE9
03DF2:  MOVFF  2F0,FEA
03DF6:  MOVFF  2FE,FEF
....................     *len 				= header.TotalLength - IPHeaderLen; 
03DFA:  MOVFF  2F1,FE9
03DFE:  MOVFF  2F2,FEA
03E02:  MOVLB  0
03E04:  MOVF   x81,W
03E06:  MOVLB  2
03E08:  SUBWF  xF7,W
03E0A:  MOVWF  00
03E0C:  MOVLW  00
03E0E:  SUBWFB xF8,W
03E10:  MOVFF  00,FEF
03E14:  MOVWF  FEC
....................  
....................     return TRUE; 
03E16:  MOVLW  01
03E18:  MOVWF  01
03E1A:  MOVLB  0
03E1C:  GOTO   5A7C (RETURN)
.................... } 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function: WORD IPPutHeader(NODE_INFO *remote, 
....................  *           				  BYTE protocol, 
....................  *                			  WORD len) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           *remote     - Destination node address 
....................  *                  protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          (WORD)0 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  ********************************************************************/ 
.................... WORD IPPutHeader(NODE_INFO *remote, 
....................                  BYTE protocol, 
....................                  WORD len) 
.................... { 
....................     IP_HEADER   header; 
....................      
....................     IPHeaderLen = sizeof(IP_HEADER); 
*
01DD2:  MOVLW  14
01DD4:  MOVWF  x81
....................  
....................     header.VersionIHL       = IP_VERSION | IP_IHL; 
01DD6:  MOVLW  45
01DD8:  MOVLB  3
01DDA:  MOVWF  x65
....................     header.TypeOfService    = IP_SERVICE; 
01DDC:  CLRF   x66
....................     header.TotalLength      = sizeof(header) + len; 
01DDE:  MOVLW  14
01DE0:  ADDWF  x63,W
01DE2:  MOVWF  x67
01DE4:  MOVLW  00
01DE6:  ADDWFC x64,W
01DE8:  MOVWF  x68
....................     header.Identification   = ++_Identifier; 
01DEA:  INCF   7F,F
01DEC:  BTFSS  FD8.2
01DEE:  BRA    1DF6
01DF0:  MOVLB  0
01DF2:  INCF   x80,F
01DF4:  MOVLB  3
01DF6:  MOVFF  80,36A
01DFA:  MOVFF  7F,369
....................     header.FragmentInfo     = 0; 
01DFE:  CLRF   x6C
01E00:  CLRF   x6B
....................     header.TimeToLive       = MY_IP_TTL; 
01E02:  MOVLW  64
01E04:  MOVWF  x6D
....................     header.Protocol         = protocol; 
01E06:  MOVFF  362,36E
....................     header.HeaderChecksum   = 0; 
01E0A:  CLRF   x70
01E0C:  CLRF   x6F
.................... 	header.SourceAddress 	= AppConfig.MyIPAddr; 
01E0E:  MOVFF  2C,374
01E12:  MOVFF  2B,373
01E16:  MOVFF  2A,372
01E1A:  MOVFF  29,371
....................  
....................     header.DestAddress.Val = remote->IPAddr.Val; 
01E1E:  MOVFF  360,FE9
01E22:  MOVFF  361,FEA
01E26:  MOVFF  FEF,375
01E2A:  MOVFF  FEC,376
01E2E:  MOVFF  FEC,377
01E32:  MOVFF  FEC,378
....................  
....................     SwapIPHeader(&header); 
01E36:  MOVLW  03
01E38:  MOVWF  x7A
01E3A:  MOVLW  65
01E3C:  MOVWF  x79
01E3E:  MOVLB  0
01E40:  RCALL  1C32
....................  
....................     header.HeaderChecksum   = CalcIPChecksum((BYTE*)&header, sizeof(header)); 
01E42:  MOVLW  03
01E44:  MOVLB  3
01E46:  MOVWF  x7A
01E48:  MOVLW  65
01E4A:  MOVWF  x79
01E4C:  MOVFF  37A,37C
01E50:  MOVWF  x7B
01E52:  CLRF   x7E
01E54:  MOVLW  14
01E56:  MOVWF  x7D
01E58:  MOVLB  0
01E5A:  RCALL  1B4A
01E5C:  MOVFF  02,370
01E60:  MOVFF  01,36F
....................  
....................     MACPutHeader(&remote->MACAddr, MAC_IP, (sizeof(header)+len)); 
01E64:  MOVLW  04
01E66:  MOVLB  3
01E68:  ADDWF  x60,W
01E6A:  MOVWF  01
01E6C:  MOVLW  00
01E6E:  ADDWFC x61,W
01E70:  MOVWF  03
01E72:  MOVFF  01,379
01E76:  MOVWF  x7A
01E78:  MOVLW  14
01E7A:  ADDWF  x63,W
01E7C:  MOVWF  x7B
01E7E:  MOVLW  00
01E80:  ADDWFC x64,W
01E82:  MOVWF  x7C
01E84:  MOVFF  03,37E
01E88:  MOVFF  01,37D
01E8C:  CLRF   x7F
01E8E:  MOVWF  x81
01E90:  MOVFF  37B,380
01E94:  MOVLB  0
01E96:  RCALL  1D0C
....................     MACPutArray((BYTE*)&header, sizeof(header)); 
01E98:  MOVLW  03
01E9A:  MOVLB  3
01E9C:  MOVWF  x7A
01E9E:  MOVLW  65
01EA0:  MOVWF  x79
01EA2:  MOVFF  37A,385
01EA6:  MOVWF  x84
01EA8:  CLRF   x87
01EAA:  MOVLW  14
01EAC:  MOVWF  x86
01EAE:  MOVLB  0
01EB0:  CALL   0DB6
....................  
....................     return 0x0000; 
01EB4:  MOVLW  00
01EB6:  MOVWF  01
01EB8:  MOVWF  02
01EBA:  RETURN 0
....................  
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by  
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset  
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset)  
.................... { 
.................... 	MACSetReadPtrInRx(Offset+IPHeaderLen); 
*
03F0C:  MOVF   x81,W
03F0E:  MOVLB  3
03F10:  ADDWF  x3A,W
03F12:  MOVWF  x3C
03F14:  MOVLW  00
03F16:  ADDWFC x3B,W
03F18:  MOVWF  x3D
03F1A:  MOVWF  x3F
03F1C:  MOVFF  33C,33E
03F20:  MOVLB  0
03F22:  RCALL  3CD0
03F24:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... static void SwapIPHeader(IP_HEADER* h) 
.................... { 
....................     h->TotalLength      = swaps(h->TotalLength); 
*
01C32:  MOVLW  02
01C34:  MOVLB  3
01C36:  ADDWF  x79,W
01C38:  MOVWF  01
01C3A:  MOVLW  00
01C3C:  ADDWFC x7A,W
01C3E:  MOVWF  03
01C40:  MOVFF  01,37B
01C44:  MOVWF  x7C
01C46:  MOVLW  02
01C48:  ADDWF  x79,W
01C4A:  MOVWF  FE9
01C4C:  MOVLW  00
01C4E:  ADDWFC x7A,W
01C50:  MOVWF  FEA
01C52:  MOVFF  FEC,37E
01C56:  MOVF   FED,F
01C58:  MOVFF  FEF,37D
01C5C:  MOVFF  37E,380
01C60:  MOVFF  37D,37F
01C64:  MOVLB  0
01C66:  RCALL  1796
01C68:  MOVFF  37C,FEA
01C6C:  MOVFF  37B,FE9
01C70:  MOVFF  02,FEC
01C74:  MOVF   FED,F
01C76:  MOVFF  01,FEF
....................     h->Identification   = swaps(h->Identification); 
01C7A:  MOVLW  04
01C7C:  MOVLB  3
01C7E:  ADDWF  x79,W
01C80:  MOVWF  01
01C82:  MOVLW  00
01C84:  ADDWFC x7A,W
01C86:  MOVWF  03
01C88:  MOVFF  01,37B
01C8C:  MOVWF  x7C
01C8E:  MOVLW  04
01C90:  ADDWF  x79,W
01C92:  MOVWF  FE9
01C94:  MOVLW  00
01C96:  ADDWFC x7A,W
01C98:  MOVWF  FEA
01C9A:  MOVFF  FEC,37E
01C9E:  MOVF   FED,F
01CA0:  MOVFF  FEF,37D
01CA4:  MOVFF  37E,380
01CA8:  MOVFF  37D,37F
01CAC:  MOVLB  0
01CAE:  RCALL  1796
01CB0:  MOVFF  37C,FEA
01CB4:  MOVFF  37B,FE9
01CB8:  MOVFF  02,FEC
01CBC:  MOVF   FED,F
01CBE:  MOVFF  01,FEF
....................     h->HeaderChecksum   = swaps(h->HeaderChecksum); 
01CC2:  MOVLW  0A
01CC4:  MOVLB  3
01CC6:  ADDWF  x79,W
01CC8:  MOVWF  01
01CCA:  MOVLW  00
01CCC:  ADDWFC x7A,W
01CCE:  MOVWF  03
01CD0:  MOVFF  01,37B
01CD4:  MOVWF  x7C
01CD6:  MOVLW  0A
01CD8:  ADDWF  x79,W
01CDA:  MOVWF  FE9
01CDC:  MOVLW  00
01CDE:  ADDWFC x7A,W
01CE0:  MOVWF  FEA
01CE2:  MOVFF  FEC,37E
01CE6:  MOVF   FED,F
01CE8:  MOVFF  FEF,37D
01CEC:  MOVFF  37E,380
01CF0:  MOVFF  37D,37F
01CF4:  MOVLB  0
01CF6:  RCALL  1796
01CF8:  MOVFF  37C,FEA
01CFC:  MOVFF  37B,FE9
01D00:  MOVFF  02,FEC
01D04:  MOVF   FED,F
01D06:  MOVFF  01,FEF
01D0A:  RETURN 0
.................... } 
....................  
.................... #include "ARP.c" 
.................... /********************************************************************* 
....................  * 
....................  *   Address Resolution Protocol (ARP) Client and Server 
....................  *  Module for Microchip TCP/IP Stack 
....................  *    -Provides IP address to Ethernet MAC address translation 
....................  *    -Reference: RFC 826 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.c 
....................  * Dependencies:    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  ARP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder      8/17/06   Combined ARP.c and ARPTsk.c into ARP.c;  
....................  *                        rewrote some of it to look more linear 
....................  * Darren Rook/CCS      Added call to GratArpReset() if using STACK_USE_CCS_GRATUITOUS_ARP 
....................  ********************************************************************/ 
.................... #define __ARP_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Constants and Variables 
....................   ***************************************************************************/ 
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... //#define ARP_OPERATION_REQ       0x01u      // Operation code indicating an ARP Request 
.................... //#define ARP_OPERATION_RESP      0x02u      // Operation code indicating an ARP Response 
....................  
.................... #define HW_ETHERNET             (0x0001u)   // ARP Hardware type as defined by IEEE 802.3 
.................... #define ARP_IP                  (0x0800u)   // ARP IP packet type as defined by IEEE 802.3 
.................... #endif 
....................  
.................... #ifdef STACK_CLIENT_MODE 
.................... static NODE_INFO Cache;                  // Cache for one ARP response 
.................... #endif 
....................  
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... #define MAX_REG_APPS            2           // MAX num allowed registrations of Modules/Apps 
.................... static struct arp_app_callbacks reg_apps[MAX_REG_APPS]; // Call-Backs storage for MAX of two Modules/Apps 
.................... /* 
.................... // ARP packet structure 
.................... typedef struct __attribute__((aligned(2), packed)) 
.................... { 
....................     WORD        HardwareType; 
....................     WORD        Protocol; 
....................     BYTE        MACAddrLen; 
....................     BYTE        ProtocolLen; 
....................     WORD        Operation; 
....................     MAC_ADDR    SenderMACAddr; 
....................     IP_ADDR     SenderIPAddr; 
....................     MAC_ADDR    TargetMACAddr; 
....................     IP_ADDR     TargetIPAddr; 
.................... } ARP_PACKET; 
.................... */ 
.................... #endif 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Helper Function Prototypes 
....................   ***************************************************************************/ 
....................  
.................... static BOOL ARPPut(ARP_PACKET* packet); 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Function Implementations 
....................   ***************************************************************************/ 
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... /************ User Application APIs ****************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    CHAR ARPRegisterCallbacks(struct arp_app_callbacks *app) 
....................  
....................   Summary: 
....................    Registering callback with ARP module to get notified about certian events. 
....................     
....................   Description: 
....................      This function allows end user application to register with callbacks, which 
....................     will be called by ARP module to give notification to user-application about  
....................     events occurred at ARP layer. For ex: when a ARP-packet is received, which is 
....................     conflicting with our own pair of addresses (MAC-Address and IP-address). 
....................     This is an extension for zeroconf protocol implementation (ZeroconfLL.c) 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    app - ARP-Application callbacks structure supplied by user-application  
....................      
....................   Returns: 
....................     id > 0 - Returns non-negative value that represents the id of registration 
....................              The same id needs to be used in de-registration 
....................     -1     - When registered applications exceed MAX_REG_APPS and there is no 
....................              free slot for registration 
....................   
....................   ***************************************************************************/ 
.................... CHAR ARPRegisterCallbacks(struct arp_app_callbacks *app) 
.................... { 
....................     BYTE i; 
....................     for(i=0; i<MAX_REG_APPS; i++) 
....................     { 
....................         if(!reg_apps[i].used) 
....................         { 
....................             reg_apps[i].ARPPkt_notify = app->ARPPkt_notify; 
....................             reg_apps[i].used = 1; 
....................             return (i+1); // Return Code. Should be used in deregister. 
....................         } 
....................     } 
....................     return -1; // No space for registration 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL ARPDeRegisterCallbacks(CHAR reg_id) 
....................  
....................   Summary: 
....................    De-Registering callbacks with ARP module that are registered previously. 
....................     
....................   Description: 
....................      This function allows end user-application to de-register with callbacks,  
....................     which were registered previously. 
....................     This is called by user-application, when its no longer interested in  
....................     notifications from ARP-Module. This allows the other application to get  
....................     registered with ARP-module.    
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    reg_id - Registration-id returned in ARPRegisterCallbacks call 
....................      
....................   Returns: 
....................     TRUE  - On success 
....................     FALSE - Failure to indicate invalid reg_id   
....................   ***************************************************************************/  
.................... BOOL ARPDeRegisterCallbacks(CHAR reg_id) 
.................... { 
....................     if(reg_id <= 0 || reg_id > MAX_REG_APPS) 
....................         return FALSE; 
....................  
....................     reg_apps[reg_id-1].used = 0; // To indicate free slot for registration 
....................    return TRUE; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ARPProcessRxPkt(ARP_PACKET* packet) 
....................  
....................   Summary: 
....................    Processes Received-ARP packet (ARP request/Reply). 
....................     
....................   Description: 
....................      This function is to pass-on the ARP-packet to registered application, 
....................     with the notification of Rx-ARP packet.  
....................  
....................   Precondition: 
....................    ARP packet is received completely from MAC 
....................  
....................   Parameters: 
....................    packet - Rx packet to be processed      
....................  
....................   Returns: 
....................     None    
....................   ***************************************************************************/ 
.................... void ARPProcessRxPkt(ARP_PACKET* packet) 
.................... { 
....................     BYTE pass_on = 0; // Flag to indicate whether need to be forwarded 
....................     BYTE i; 
....................  
....................     // Probing Stage 
....................     if(AppConfig.MyIPAddr.Val == 0x00) 
....................     { 
....................         pass_on = 1; // Pass to Registered-Application for further processing         
....................     } 
....................     else if(AppConfig.MyIPAddr.Val) 
....................     { 
....................         /* Late-conflict */ 
....................         if(packet->SenderIPAddr.Val == AppConfig.MyIPAddr.Val) 
....................         { 
....................             pass_on = 1; 
....................         } 
....................     } 
....................     if(pass_on) 
....................     { 
....................      
....................         for(i =0; i< MAX_REG_APPS; i++) 
....................         { 
....................             if(reg_apps[i].used) 
....................             { 
....................                 reg_apps[i].ARPPkt_notify(packet->SenderIPAddr.Val, 
....................                                       packet->TargetIPAddr.Val, 
....................                                       &packet->SenderMACAddr, 
....................                                       &packet->TargetMACAddr, 
....................                                       packet->Operation);                 
....................             } 
....................         } 
....................     } 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ARPSendPkt(IP_ADDR* SrcIPAddr, IP_ADDR* DestIPAddr, int op_req ) 
....................  
....................   Summary: 
....................    Transmits an ARP request/Reply initated by Application or external module. 
....................     
....................   Description: 
....................      This function transmits and ARP request/reply to determine the hardware 
....................      address of a given IP address (or) Announce self-address to all nodes in 
....................     network. Extended for zeroconf protocol.  
....................  
....................   Precondition: 
....................    ARP packet is ready in the MAC buffer. 
....................  
....................   Parameters: 
....................    SrcIPAddr - The Source IP-address  
....................     DestIPAddr - The Destination IP-Address 
....................     op_req     - Operation Request (ARP_REQ/ARP_RESP) 
....................  
....................   Returns: 
....................     TRUE - The ARP packet was generated properly 
....................      FALSE - Not possible return value 
....................  
....................   Remarks: 
....................      This API is to give control over AR-packet to external modules.  
....................   ***************************************************************************/ 
.................... BOOL ARPSendPkt(DWORD SrcIPAddr, DWORD DestIPAddr, BYTE op_req ) 
.................... { 
....................     ARP_PACKET packet; 
....................  
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... #define KS_ARP_IP_MULTICAST_HACK y 
.................... #ifdef KS_ARP_IP_MULTICAST_HACK 
....................    DWORD_VAL *DestAddr = (DWORD_VAL *)&DestIPAddr; 
....................    if ((DestAddr->v[0] >= 224) &&(DestAddr->v[0] <= 239)) { 
....................       // "Resolve" the IP to MAC address mapping for 
....................       // IP multicast address range from 224.0.0.0 to 239.255.255.255 
....................     
....................       Cache.MACAddr.v[0] = 0x01; 
....................       Cache.MACAddr.v[1] = 0x00; 
....................       Cache.MACAddr.v[2] = 0x5E; 
....................       Cache.MACAddr.v[3] = 0x7f & DestAddr->v[1]; 
....................       Cache.MACAddr.v[4] = DestAddr->v[2]; 
....................       Cache.MACAddr.v[5] = DestAddr->v[3]; 
....................     
....................       Cache.IPAddr.Val = DestAddr->Val; 
....................     
....................       return TRUE; 
....................    } 
.................... #endif 
.................... #endif 
....................  
....................     packet.Operation = op_req; 
....................    packet.TargetMACAddr.v[0]   = 0xff; 
....................    packet.TargetMACAddr.v[1]   = 0xff; 
....................    packet.TargetMACAddr.v[2]   = 0xff; 
....................    packet.TargetMACAddr.v[3]   = 0xff; 
....................    packet.TargetMACAddr.v[4]   = 0xff; 
....................    packet.TargetMACAddr.v[5]   = 0xff; 
....................  
....................     packet.TargetIPAddr.Val   = DestIPAddr; 
....................     packet.SenderIPAddr.Val = SrcIPAddr; 
....................  
....................     return ( ARPPut(&packet) ); 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static BOOL ARPPut(ARP_PACKET* packet) 
....................  
....................   Description: 
....................    Writes an ARP packet to the MAC. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    packet - A pointer to an ARP_PACKET structure with correct operation 
....................             and target preconfigured. 
....................  
....................   Return Values: 
....................      TRUE - The ARP packet was generated properly 
....................      FALSE - Not a possible return value 
....................   ***************************************************************************/ 
.................... static BOOL ARPPut(ARP_PACKET* packet) 
.................... { 
....................    while(!MACIsTxReady()); 
*
02D4C:  CALL   1656
02D50:  MOVF   01,F
02D52:  BZ    2D4C
....................    MACSetWritePtr(BASE_TX_ADDR); 
02D54:  MOVLW  11
02D56:  MOVLB  3
02D58:  MOVWF  x70
02D5A:  MOVLW  D7
02D5C:  MOVWF  x6F
02D5E:  MOVLB  0
02D60:  CALL   0D46
....................     
....................  
....................     packet->HardwareType  = HW_ETHERNET; 
02D64:  MOVLB  3
02D66:  MOVFF  30E,FE9
02D6A:  MOVFF  30F,FEA
02D6E:  CLRF   FEC
02D70:  MOVF   FED,F
02D72:  MOVLW  01
02D74:  MOVWF  FEF
....................     packet->Protocol      = ARP_IP; 
02D76:  MOVLW  02
02D78:  ADDWF  x0E,W
02D7A:  MOVWF  FE9
02D7C:  MOVLW  00
02D7E:  ADDWFC x0F,W
02D80:  MOVWF  FEA
02D82:  MOVLW  08
02D84:  MOVWF  FEC
02D86:  MOVF   FED,F
02D88:  CLRF   FEF
....................     packet->MACAddrLen    = sizeof(MAC_ADDR); 
02D8A:  MOVLW  04
02D8C:  ADDWF  x0E,W
02D8E:  MOVWF  FE9
02D90:  MOVLW  00
02D92:  ADDWFC x0F,W
02D94:  MOVWF  FEA
02D96:  MOVLW  06
02D98:  MOVWF  FEF
....................     packet->ProtocolLen   = sizeof(IP_ADDR); 
02D9A:  MOVLW  05
02D9C:  ADDWF  x0E,W
02D9E:  MOVWF  FE9
02DA0:  MOVLW  00
02DA2:  ADDWFC x0F,W
02DA4:  MOVWF  FEA
02DA6:  MOVLW  04
02DA8:  MOVWF  FEF
.................... //    packet->SenderMACAddr = AppConfig.MyMACAddr;   // HI-TECH PICC-18 compiler can't handle this statement, use memcpy() as a workaround 
....................    memcpy(&packet->SenderMACAddr, (void*)&AppConfig.MyMACAddr, sizeof(packet->SenderMACAddr)); 
02DAA:  MOVLW  08
02DAC:  ADDWF  x0E,W
02DAE:  MOVWF  01
02DB0:  MOVLW  00
02DB2:  ADDWFC x0F,W
02DB4:  MOVWF  03
02DB6:  MOVFF  01,310
02DBA:  MOVWF  x11
02DBC:  CLRF   x13
02DBE:  MOVLW  56
02DC0:  MOVFF  03,FEA
02DC4:  MOVFF  01,FE9
02DC8:  MOVFF  313,FE2
02DCC:  MOVWF  FE1
02DCE:  MOVLW  06
02DD0:  MOVWF  01
02DD2:  MOVFF  FE6,FEE
02DD6:  DECFSZ 01,F
02DD8:  BRA    2DD2
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................     //packet->SenderIPAddr  = AppConfig.MyIPAddr; /* Removed for ZCLL, SenderIPAddr should be filled in */ 
.................... #else 
....................     packet->SenderIPAddr  = AppConfig.MyIPAddr; 
02DDA:  MOVLW  0E
02DDC:  ADDWF  x0E,W
02DDE:  MOVWF  FE9
02DE0:  MOVLW  00
02DE2:  ADDWFC x0F,W
02DE4:  MOVWF  FEA
02DE6:  MOVFF  29,FEF
02DEA:  MOVFF  2A,FEC
02DEE:  MOVFF  2B,FEC
02DF2:  MOVFF  2C,FEC
.................... #endif 
....................  
....................     SwapARPPacket(packet); 
02DF6:  MOVFF  30F,311
02DFA:  MOVFF  30E,310
02DFE:  MOVLB  0
02E00:  RCALL  2C72
....................  
....................     MACPutHeader(&packet->TargetMACAddr, MAC_ARP, sizeof(*packet)); 
02E02:  MOVLW  12
02E04:  MOVLB  3
02E06:  ADDWF  x0E,W
02E08:  MOVWF  01
02E0A:  MOVLW  00
02E0C:  ADDWFC x0F,W
02E0E:  MOVWF  03
02E10:  MOVFF  01,310
02E14:  MOVWF  x11
02E16:  MOVWF  x7E
02E18:  MOVFF  01,37D
02E1C:  MOVLW  06
02E1E:  MOVWF  x7F
02E20:  CLRF   x81
02E22:  MOVLW  1C
02E24:  MOVWF  x80
02E26:  MOVLB  0
02E28:  CALL   1D0C
....................     MACPutArray((BYTE*)packet, sizeof(*packet)); 
02E2C:  MOVFF  30F,385
02E30:  MOVFF  30E,384
02E34:  MOVLB  3
02E36:  CLRF   x87
02E38:  MOVLW  1C
02E3A:  MOVWF  x86
02E3C:  MOVLB  0
02E3E:  CALL   0DB6
....................     MACFlush(); 
02E42:  CALL   2004
....................     
....................    return TRUE; 
02E46:  MOVLW  01
02E48:  MOVWF  01
02E4A:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ARPInit(void) 
....................  
....................   Summary: 
....................    Initializes the ARP module. 
....................     
....................   Description: 
....................      Initializes the ARP module.  Call this function once at boot to  
....................      invalidate the cached lookup. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................      None 
....................    
....................   Remarks: 
....................      This function is only required when the stack is a client, and therefore 
....................      is only enabled when STACK_CLIENT_MODE is enabled. 
....................   ***************************************************************************/ 
.................... #ifdef STACK_CLIENT_MODE 
.................... void ARPInit(void) 
.................... { 
....................     Cache.MACAddr.v[0] = 0xff; 
*
00C72:  SETF   x86
....................     Cache.MACAddr.v[1] = 0xff; 
00C74:  SETF   x87
....................     Cache.MACAddr.v[2] = 0xff; 
00C76:  SETF   x88
....................     Cache.MACAddr.v[3] = 0xff; 
00C78:  SETF   x89
....................     Cache.MACAddr.v[4] = 0xff; 
00C7A:  SETF   x8A
....................     Cache.MACAddr.v[5] = 0xff; 
00C7C:  SETF   x8B
....................  
....................    Cache.IPAddr.Val = 0xfffffffful; 
00C7E:  SETF   x85
00C80:  SETF   x84
00C82:  SETF   x83
00C84:  SETF   x82
00C86:  GOTO   2B20 (RETURN)
.................... } 
.................... #endif 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL ARPProcess(void) 
....................  
....................   Summary: 
....................    Processes an incoming ARP packet. 
....................     
....................   Description: 
....................      Retrieves an ARP packet from the MAC buffer and determines if it is a 
....................      response to our request (in which case the ARP is resolved) or if it 
....................      is a request requiring our response (in which case we transmit one.) 
....................  
....................   Precondition: 
....................    ARP packet is ready in the MAC buffer. 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Return Values: 
....................      TRUE - All processing of this ARP packet is complete.  Do not call  
....................            again until a new ARP packet is waiting in the RX buffer. 
....................      FALSE - This function must be called again.  More time is needed to  
....................            send an ARP response. 
....................   ***************************************************************************/ 
.................... BOOL ARPProcess(void) 
.................... { 
....................    ARP_PACKET packet; 
....................    static NODE_INFO Target; 
....................     #if defined(STACK_USE_AUTO_IP) 
....................         BYTE i; 
....................     #endif 
....................    static enum 
....................    { 
....................        SM_ARP_IDLE = 0, 
....................        SM_ARP_REPLY 
....................    } smARP = SM_ARP_IDLE; 
....................  
....................     switch(smARP) 
*
03AD6:  MOVLW  00
03AD8:  BTFSC  67.2
03ADA:  MOVLW  01
03ADC:  XORLW  00
03ADE:  BZ    3AE8
03AE0:  XORLW  01
03AE2:  BTFSC  FD8.2
03AE4:  BRA    3BC8
03AE6:  BRA    3C18
....................     { 
....................        case SM_ARP_IDLE: 
....................          // Obtain the incoming ARP packet 
....................           MACGetArray((BYTE*)&packet, sizeof(packet));       
03AE8:  MOVLW  02
03AEA:  MOVLB  3
03AEC:  MOVWF  x08
03AEE:  MOVLW  EB
03AF0:  MOVWF  x07
03AF2:  MOVFF  308,383
03AF6:  MOVWF  x82
03AF8:  CLRF   x85
03AFA:  MOVLW  1C
03AFC:  MOVWF  x84
03AFE:  MOVLB  0
03B00:  CALL   0E68
....................           MACDiscardRx(); 
03B04:  RCALL  3920
....................           SwapARPPacket(&packet); 
03B06:  MOVLW  02
03B08:  MOVLB  3
03B0A:  MOVWF  x11
03B0C:  MOVLW  EB
03B0E:  MOVWF  x10
03B10:  MOVLB  0
03B12:  CALL   2C72
....................        
....................          // Validate the ARP packet 
....................           if ( packet.HardwareType != HW_ETHERNET     || 
....................                packet.MACAddrLen != sizeof(MAC_ADDR)  || 
....................                packet.ProtocolLen != sizeof(IP_ADDR) ) 
03B16:  MOVLB  2
03B18:  DECFSZ xEB,W
03B1A:  BRA    3B2C
03B1C:  MOVF   xEC,F
03B1E:  BNZ   3B2C
03B20:  MOVF   xEF,W
03B22:  SUBLW  06
03B24:  BNZ   3B2C
03B26:  MOVF   xF0,W
03B28:  SUBLW  04
03B2A:  BZ    3B32
....................           { 
....................                return TRUE; 
03B2C:  MOVLW  01
03B2E:  MOVWF  01
03B30:  BRA    3C1E
....................           } 
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................          ARPProcessRxPkt(&packet); 
.................... #endif 
....................  
.................... #ifdef STACK_USE_AUTO_IP 
....................             if (packet.SenderIPAddr.Val == AppConfig.MyIPAddr.Val) 
....................             { 
....................                 AutoIPConflict(0); 
....................                 return TRUE;                 
....................             } 
.................... #endif 
.................... #ifdef STACK_USE_CCS_GRATUITOUS_ARP 
.................... GratArpReset(); 
.................... #endif 
....................          // Handle incoming ARP responses 
.................... #ifdef STACK_CLIENT_MODE 
....................          if(packet.Operation == ARP_OPERATION_RESP) 
03B32:  MOVF   xF1,W
03B34:  SUBLW  02
03B36:  BNZ   3B6C
03B38:  MOVF   xF2,F
03B3A:  BNZ   3B6C
....................          { 
.................... /*                #if defined(STACK_USE_AUTO_IP) 
....................                 for (i = 0; i < NETWORK_INTERFACES; i++) 
....................                     if (AutoIPConfigIsInProgress(i)) 
....................                         AutoIPConflict(i); 
....................                 #endif*/ 
....................             Cache.MACAddr = packet.SenderMACAddr; 
03B3C:  CLRF   FEA
03B3E:  MOVLW  86
03B40:  MOVWF  FE9
03B42:  MOVLW  02
03B44:  MOVWF  FE2
03B46:  MOVLW  F3
03B48:  MOVWF  FE1
03B4A:  MOVLW  06
03B4C:  MOVWF  01
03B4E:  MOVFF  FE6,FEE
03B52:  DECFSZ 01,F
03B54:  BRA    3B4E
....................             Cache.IPAddr = packet.SenderIPAddr; 
03B56:  MOVFF  2FC,85
03B5A:  MOVFF  2FB,84
03B5E:  MOVFF  2FA,83
03B62:  MOVFF  2F9,82
....................             return TRUE; 
03B66:  MOVLW  01
03B68:  MOVWF  01
03B6A:  BRA    3C1E
....................          } 
.................... #endif 
....................  
....................          // Handle incoming ARP requests for our MAC address 
....................          if(packet.Operation == ARP_OPERATION_REQ) 
03B6C:  DECFSZ xF1,W
03B6E:  BRA    3BC6
03B70:  MOVF   xF2,F
03B72:  BNZ   3BC6
....................          { 
....................             if(packet.TargetIPAddr.Val != AppConfig.MyIPAddr.Val) 
03B74:  MOVF   29,W
03B76:  MOVLB  3
03B78:  SUBWF  x03,W
03B7A:  BNZ   3B8E
03B7C:  MOVF   2A,W
03B7E:  SUBWF  x04,W
03B80:  BNZ   3B8E
03B82:  MOVF   2B,W
03B84:  SUBWF  x05,W
03B86:  BNZ   3B8E
03B88:  MOVF   2C,W
03B8A:  SUBWF  x06,W
03B8C:  BZ    3B98
....................             { 
....................                return TRUE; 
03B8E:  MOVLW  01
03B90:  MOVWF  01
03B92:  MOVLB  2
03B94:  BRA    3C1E
03B96:  MOVLB  3
....................             } 
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................                                /* Fix for Loop-Back suppression: 
....................                                 * For ZCLL-Claim packets, host should not respond. 
....................                                 * Check Sender's MAC-address with own MAC-address and  
....................                                 * if it is matched, response will not be sent back. This 
....................                                 * was leading to flooding of ARP-answeres */ 
....................                                 if(!memcmp (&packet.SenderMACAddr, &AppConfig.MyMACAddr, 6)) 
....................                                 { 
....................                                      putsUART("Loopback answer suppressed \r\n"); 
....................                                      return TRUE; 
....................                                 } 
.................... #endif 
....................                 #if defined(STACK_USE_AUTO_IP) 
....................                 for (i = 0; i < NETWORK_INTERFACES; i++) 
....................                     if (AutoIPConfigIsInProgress(i)) 
....................                     { 
....................                         AutoIPConflict(i); 
....................                         return TRUE; 
....................                     }              
....................                 #endif 
....................             Target.IPAddr = packet.SenderIPAddr; 
03B98:  MOVFF  2FC,8F
03B9C:  MOVFF  2FB,8E
03BA0:  MOVFF  2FA,8D
03BA4:  MOVFF  2F9,8C
....................             Target.MACAddr = packet.SenderMACAddr; 
03BA8:  CLRF   FEA
03BAA:  MOVLW  90
03BAC:  MOVWF  FE9
03BAE:  MOVLW  02
03BB0:  MOVWF  FE2
03BB2:  MOVLW  F3
03BB4:  MOVWF  FE1
03BB6:  MOVLW  06
03BB8:  MOVWF  01
03BBA:  MOVFF  FE6,FEE
03BBE:  DECFSZ 01,F
03BC0:  BRA    3BBA
....................  
....................             smARP = SM_ARP_REPLY; 
03BC2:  BSF    67.2
03BC4:  MOVLB  2
03BC6:  MOVLB  0
....................          } 
....................          // Do not break.  If we get down here, we need to send a reply.    
....................  
....................        case SM_ARP_REPLY: 
....................            packet.Operation      = ARP_OPERATION_RESP; 
03BC8:  MOVLB  2
03BCA:  CLRF   xF2
03BCC:  MOVLW  02
03BCE:  MOVWF  xF1
....................             #if defined(STACK_USE_AUTO_IP) 
....................             if (AutoIPIsConfigured(0)) 
....................             { 
....................                 packet.TargetMACAddr.v[0] = 0xFF; 
....................                 packet.TargetMACAddr.v[1] = 0xFF; 
....................                 packet.TargetMACAddr.v[2] = 0xFF; 
....................                 packet.TargetMACAddr.v[3] = 0xFF; 
....................                 packet.TargetMACAddr.v[4] = 0xFF; 
....................                 packet.TargetMACAddr.v[5] = 0xFF; 
....................             } 
....................             else 
....................             #endif 
....................                packet.TargetMACAddr   = Target.MACAddr; 
03BD0:  MOVWF  FEA
03BD2:  MOVLW  FD
03BD4:  MOVWF  FE9
03BD6:  CLRF   FE2
03BD8:  MOVLW  90
03BDA:  MOVWF  FE1
03BDC:  MOVLW  06
03BDE:  MOVWF  01
03BE0:  MOVFF  FE6,FEE
03BE4:  DECFSZ 01,F
03BE6:  BRA    3BE0
....................            packet.TargetIPAddr      = Target.IPAddr; 
03BE8:  MOVFF  8F,306
03BEC:  MOVFF  8E,305
03BF0:  MOVFF  8D,304
03BF4:  MOVFF  8C,303
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................             packet.SenderIPAddr      = AppConfig.MyIPAddr; 
.................... #endif 
....................  
....................          // Send an ARP response to a previously received request 
....................          if(!ARPPut(&packet)) 
03BF8:  MOVLW  02
03BFA:  MOVLB  3
03BFC:  MOVWF  x0F
03BFE:  MOVLW  EB
03C00:  MOVWF  x0E
03C02:  MOVLB  0
03C04:  CALL   2D4C
03C08:  MOVF   01,F
03C0A:  BNZ   3C16
....................          { 
....................               return FALSE; 
03C0C:  MOVLW  00
03C0E:  MOVWF  01
03C10:  MOVLB  2
03C12:  BRA    3C1E
03C14:  MOVLB  0
....................          } 
....................  
....................          // Begin listening for ARP requests again 
....................          smARP = SM_ARP_IDLE; 
03C16:  BCF    67.2
....................            break; 
....................    } 
....................  
....................     return TRUE; 
03C18:  MOVLW  01
03C1A:  MOVWF  01
03C1C:  MOVLB  2
03C1E:  MOVLB  0
03C20:  GOTO   5B54 (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ARPResolve(IP_ADDR* IPAddr) 
....................  
....................   Summary: 
....................    Transmits an ARP request to resolve an IP address. 
....................     
....................   Description: 
....................      This function transmits and ARP request to determine the hardware 
....................      address of a given IP address. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    IPAddr - The IP address to be resolved.  The address must be specified  
....................           in network byte order (big endian). 
....................  
....................   Returns: 
....................      None 
....................  
....................   Remarks: 
....................      This function is only required when the stack is a client, and therefore 
....................      is only enabled when STACK_CLIENT_MODE is enabled. 
....................  
....................    To retrieve the ARP query result, call the ARPIsResolved() function. 
....................   ***************************************************************************/ 
.................... #ifdef STACK_CLIENT_MODE 
.................... void ARPResolve(IP_ADDR* IPAddr) 
.................... { 
....................     ARP_PACKET packet; 
....................  
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... #define KS_ARP_IP_MULTICAST_HACK y 
.................... #ifdef KS_ARP_IP_MULTICAST_HACK 
....................     if ((IPAddr->v[0] >= 224) &&(IPAddr->v[0] <= 239)) 
....................     { 
....................       // "Resolve" the IP to MAC address mapping for 
....................       // IP multicast address range from 224.0.0.0 to 239.255.255.255 
....................  
....................       Cache.MACAddr.v[0] = 0x01; 
....................       Cache.MACAddr.v[1] = 0x00; 
....................       Cache.MACAddr.v[2] = 0x5E; 
....................       Cache.MACAddr.v[3] = 0x7f & IPAddr->v[1]; 
....................       Cache.MACAddr.v[4] = IPAddr->v[2]; 
....................       Cache.MACAddr.v[5] = IPAddr->v[3]; 
....................  
....................       Cache.IPAddr.Val = IPAddr->Val; 
....................  
....................       return; 
....................    } 
.................... #endif 
.................... #endif 
....................  
....................    packet.Operation            = ARP_OPERATION_REQ; 
*
02E4C:  MOVLB  2
02E4E:  CLRF   xF9
02E50:  MOVLW  01
02E52:  MOVWF  xF8
....................    packet.TargetMACAddr.v[0]   = 0xff; 
02E54:  MOVLB  3
02E56:  SETF   x04
....................    packet.TargetMACAddr.v[1]   = 0xff; 
02E58:  SETF   x05
....................    packet.TargetMACAddr.v[2]   = 0xff; 
02E5A:  SETF   x06
....................    packet.TargetMACAddr.v[3]   = 0xff; 
02E5C:  SETF   x07
....................    packet.TargetMACAddr.v[4]   = 0xff; 
02E5E:  SETF   x08
....................    packet.TargetMACAddr.v[5]   = 0xff; 
02E60:  SETF   x09
....................  
....................  
....................     // ARP query either the IP address directly (on our subnet), or do an ARP query for our Gateway if off of our subnet 
....................    packet.TargetIPAddr         = ((AppConfig.MyIPAddr.Val ^ IPAddr->Val) & AppConfig.MyMask.Val) ? AppConfig.MyGateway : *IPAddr; 
02E62:  MOVLB  2
02E64:  MOVFF  2F0,FE9
02E68:  MOVFF  2F1,FEA
02E6C:  MOVFF  FEF,00
02E70:  MOVFF  FEC,01
02E74:  MOVFF  FEC,02
02E78:  MOVFF  FEC,03
02E7C:  MOVF   00,W
02E7E:  XORWF  29,W
02E80:  MOVLB  3
02E82:  MOVWF  x0E
02E84:  MOVF   01,W
02E86:  XORWF  2A,W
02E88:  MOVWF  x0F
02E8A:  MOVF   02,W
02E8C:  XORWF  2B,W
02E8E:  MOVWF  x10
02E90:  MOVF   03,W
02E92:  XORWF  2C,W
02E94:  MOVWF  x11
02E96:  MOVF   x0E,W
02E98:  ANDWF  2D,W
02E9A:  MOVWF  00
02E9C:  MOVF   x0F,W
02E9E:  ANDWF  2E,W
02EA0:  MOVWF  01
02EA2:  MOVF   x10,W
02EA4:  ANDWF  2F,W
02EA6:  MOVWF  02
02EA8:  MOVF   x11,W
02EAA:  ANDWF  30,W
02EAC:  MOVWF  03
02EAE:  MOVF   00,F
02EB0:  BNZ   2EBE
02EB2:  MOVF   01,F
02EB4:  BNZ   2EBE
02EB6:  MOVF   02,F
02EB8:  BNZ   2EBE
02EBA:  MOVF   03,F
02EBC:  BZ    2ED0
02EBE:  MOVFF  31,00
02EC2:  MOVFF  32,01
02EC6:  MOVFF  33,02
02ECA:  MOVFF  34,03
02ECE:  BRA    2EEA
02ED0:  MOVFF  2F0,FE9
02ED4:  MOVFF  2F1,FEA
02ED8:  MOVFF  FEF,00
02EDC:  MOVFF  FEC,01
02EE0:  MOVFF  FEC,02
02EE4:  MOVFF  FEC,03
02EE8:  MOVLB  3
02EEA:  MOVFF  00,30A
02EEE:  MOVFF  01,30B
02EF2:  MOVFF  02,30C
02EF6:  MOVFF  03,30D
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................    packet.SenderIPAddr         = AppConfig.MyIPAddr; 
.................... #endif 
....................  
....................     ARPPut(&packet); 
02EFA:  MOVLW  02
02EFC:  MOVWF  x0F
02EFE:  MOVLW  F2
02F00:  MOVWF  x0E
02F02:  MOVLB  0
02F04:  RCALL  2D4C
02F06:  GOTO   355C (RETURN)
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL ARPIsResolved(IP_ADDR* IPAddr, MAC_ADDR* MACAddr) 
....................  
....................   Summary: 
....................    Determines if an ARP request has been resolved yet. 
....................     
....................   Description: 
....................      This function checks if an ARP request has been resolved yet, and if 
....................      so, stores the resolved MAC address in the pointer provided. 
....................  
....................   Precondition: 
....................    ARP packet is ready in the MAC buffer. 
....................  
....................   Parameters: 
....................    IPAddr - The IP address to be resolved.  This must match the IP address  
....................           provided to the ARPResolve() function call. 
....................    MACAddr - A buffer to store the corresponding MAC address retrieved from  
....................           the ARP query. 
....................  
....................   Return Values: 
....................      TRUE - The IP address has been resolved and MACAddr MAC address field 
....................          indicates the response. 
....................      FALSE -   The IP address is not yet resolved.  Try calling ARPIsResolved()  
....................          again at a later time.  If you don't get a response after a  
....................          application specific timeout period, you may want to call  
....................          ARPResolve() again to transmit another ARP query (in case if the  
....................          original query or response was lost on the network).  If you never  
....................          receive an ARP response, this may indicate that the IP address  
....................          isn't in use. 
....................  
....................   Remarks: 
....................      This function is only required when the stack is a client, and therefore 
....................      is only enabled when STACK_CLIENT_MODE is enabled. 
....................   ***************************************************************************/ 
.................... #ifdef STACK_CLIENT_MODE 
.................... BOOL ARPIsResolved(IP_ADDR* IPAddr, MAC_ADDR* MACAddr) 
.................... { 
....................     if((Cache.IPAddr.Val == IPAddr->Val) ||  
....................      ((Cache.IPAddr.Val == AppConfig.MyGateway.Val) && ((AppConfig.MyIPAddr.Val ^ IPAddr->Val) & AppConfig.MyMask.Val))) 
02F0A:  MOVLB  2
02F0C:  MOVFF  2F0,FE9
02F10:  MOVFF  2F1,FEA
02F14:  MOVFF  FEF,00
02F18:  MOVFF  FEC,01
02F1C:  MOVFF  FEC,02
02F20:  MOVFF  FEC,03
02F24:  MOVF   00,W
02F26:  MOVLB  0
02F28:  SUBWF  x82,W
02F2A:  BNZ   2F3E
02F2C:  MOVF   01,W
02F2E:  SUBWF  x83,W
02F30:  BNZ   2F3E
02F32:  MOVF   02,W
02F34:  SUBWF  x84,W
02F36:  BNZ   2F3E
02F38:  MOVF   03,W
02F3A:  SUBWF  x85,W
02F3C:  BZ    2FCA
02F3E:  MOVF   31,W
02F40:  SUBWF  x82,W
02F42:  BNZ   2FF2
02F44:  MOVF   32,W
02F46:  SUBWF  x83,W
02F48:  BNZ   2FF2
02F4A:  MOVF   33,W
02F4C:  SUBWF  x84,W
02F4E:  BNZ   2FF2
02F50:  MOVF   34,W
02F52:  SUBWF  x85,W
02F54:  BNZ   2FF2
02F56:  MOVLB  2
02F58:  MOVFF  2F0,FE9
02F5C:  MOVFF  2F1,FEA
02F60:  MOVFF  FEF,00
02F64:  MOVFF  FEC,01
02F68:  MOVFF  FEC,02
02F6C:  MOVFF  FEC,03
02F70:  MOVF   00,W
02F72:  XORWF  29,W
02F74:  MOVWF  xF4
02F76:  MOVF   01,W
02F78:  XORWF  2A,W
02F7A:  MOVWF  xF5
02F7C:  MOVF   02,W
02F7E:  XORWF  2B,W
02F80:  MOVWF  xF6
02F82:  MOVF   03,W
02F84:  XORWF  2C,W
02F86:  MOVWF  xF7
02F88:  MOVF   xF4,W
02F8A:  ANDWF  2D,W
02F8C:  MOVWF  00
02F8E:  MOVF   xF5,W
02F90:  ANDWF  2E,W
02F92:  MOVWF  01
02F94:  MOVF   xF6,W
02F96:  ANDWF  2F,W
02F98:  MOVWF  02
02F9A:  MOVF   xF7,W
02F9C:  ANDWF  30,W
02F9E:  MOVWF  03
02FA0:  MOVF   00,F
02FA2:  BTFSC  FD8.2
02FA4:  BRA    2FAA
02FA6:  MOVLB  0
02FA8:  BRA    2FCA
02FAA:  MOVF   01,F
02FAC:  BTFSC  FD8.2
02FAE:  BRA    2FB4
02FB0:  MOVLB  0
02FB2:  BRA    2FCA
02FB4:  MOVF   02,F
02FB6:  BTFSC  FD8.2
02FB8:  BRA    2FBE
02FBA:  MOVLB  0
02FBC:  BRA    2FCA
02FBE:  MOVF   03,F
02FC0:  BTFSS  FD8.2
02FC2:  BRA    2FC8
02FC4:  MOVLB  0
02FC6:  BRA    2FF2
02FC8:  MOVLB  0
....................     { 
....................         *MACAddr = Cache.MACAddr; 
02FCA:  MOVFF  2F3,03
02FCE:  MOVLB  2
02FD0:  MOVFF  2F2,FE9
02FD4:  MOVFF  2F3,FEA
02FD8:  CLRF   FE2
02FDA:  MOVLW  86
02FDC:  MOVWF  FE1
02FDE:  MOVLW  06
02FE0:  MOVWF  01
02FE2:  MOVFF  FE6,FEE
02FE6:  DECFSZ 01,F
02FE8:  BRA    2FE2
....................         return TRUE; 
02FEA:  MOVLW  01
02FEC:  MOVWF  01
02FEE:  BRA    2FF8
02FF0:  MOVLB  0
....................     } 
....................     return FALSE; 
02FF2:  MOVLW  00
02FF4:  MOVWF  01
02FF6:  MOVLB  2
02FF8:  MOVLB  0
02FFA:  GOTO   3576 (RETURN)
.................... } 
.................... #endif 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void SwapARPPacket(ARP_PACKET* p) 
....................  
....................   Description: 
....................      Swaps endian-ness of header information in an ARP packet. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    p - The ARP packet to be swapped 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... void SwapARPPacket(ARP_PACKET* p) 
.................... { 
....................     p->HardwareType     = swaps(p->HardwareType); 
*
02C72:  MOVLB  3
02C74:  MOVFF  310,01
02C78:  MOVFF  311,03
02C7C:  MOVFF  310,312
02C80:  MOVFF  311,313
02C84:  MOVFF  310,FE9
02C88:  MOVFF  311,FEA
02C8C:  MOVFF  FEC,315
02C90:  MOVF   FED,F
02C92:  MOVFF  FEF,314
02C96:  MOVFF  315,380
02C9A:  MOVFF  314,37F
02C9E:  MOVLB  0
02CA0:  CALL   1796
02CA4:  MOVFF  313,FEA
02CA8:  MOVFF  312,FE9
02CAC:  MOVFF  02,FEC
02CB0:  MOVF   FED,F
02CB2:  MOVFF  01,FEF
....................     p->Protocol         = swaps(p->Protocol); 
02CB6:  MOVLW  02
02CB8:  MOVLB  3
02CBA:  ADDWF  x10,W
02CBC:  MOVWF  01
02CBE:  MOVLW  00
02CC0:  ADDWFC x11,W
02CC2:  MOVWF  03
02CC4:  MOVFF  01,312
02CC8:  MOVWF  x13
02CCA:  MOVLW  02
02CCC:  ADDWF  x10,W
02CCE:  MOVWF  FE9
02CD0:  MOVLW  00
02CD2:  ADDWFC x11,W
02CD4:  MOVWF  FEA
02CD6:  MOVFF  FEC,315
02CDA:  MOVF   FED,F
02CDC:  MOVFF  FEF,314
02CE0:  MOVFF  315,380
02CE4:  MOVFF  314,37F
02CE8:  MOVLB  0
02CEA:  CALL   1796
02CEE:  MOVFF  313,FEA
02CF2:  MOVFF  312,FE9
02CF6:  MOVFF  02,FEC
02CFA:  MOVF   FED,F
02CFC:  MOVFF  01,FEF
....................     p->Operation        = swaps(p->Operation); 
02D00:  MOVLW  06
02D02:  MOVLB  3
02D04:  ADDWF  x10,W
02D06:  MOVWF  01
02D08:  MOVLW  00
02D0A:  ADDWFC x11,W
02D0C:  MOVWF  03
02D0E:  MOVFF  01,312
02D12:  MOVWF  x13
02D14:  MOVLW  06
02D16:  ADDWF  x10,W
02D18:  MOVWF  FE9
02D1A:  MOVLW  00
02D1C:  ADDWFC x11,W
02D1E:  MOVWF  FEA
02D20:  MOVFF  FEC,315
02D24:  MOVF   FED,F
02D26:  MOVFF  FEF,314
02D2A:  MOVFF  315,380
02D2E:  MOVFF  314,37F
02D32:  MOVLB  0
02D34:  CALL   1796
02D38:  MOVFF  313,FEA
02D3C:  MOVFF  312,FE9
02D40:  MOVFF  02,FEC
02D44:  MOVF   FED,F
02D46:  MOVFF  01,FEF
02D4A:  RETURN 0
.................... } 
....................  
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) 
....................    #include "ICMP.c" 
.................... /********************************************************************* 
....................  * 
....................  *  Internet Control Message Protocol (ICMP) Server 
....................  *  Module for Microchip TCP/IP Stack 
....................  *   -Provides "ping" diagnostics 
....................  *	 -Reference: RFC 792 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.c 
....................  * Dependencies:    IP, ARP 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    	Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		03/16/07	Original 
....................  ********************************************************************/ 
.................... #define __ICMP_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................  
.................... #if defined(STACK_USE_ICMP_CLIENT) 
....................  
.................... // ICMP Timeout Value 
.................... #define ICMP_TIMEOUT	(4ul*TICK_SECOND) 
....................  
.................... // ICMP Packet Structure 
.................... typedef struct 
.................... { 
.................... 	BYTE vType; 
.................... 	BYTE vCode; 
.................... 	WORD wChecksum; 
.................... 	WORD wIdentifier; 
.................... 	WORD wSequenceNumber; 
.................... 	WORD wData; 
.................... } ICMP_PACKET; 
....................  
.................... // ICMP Sequence Number 
.................... static WORD wICMPSequenceNumber; 
.................... // ICMP tick timer variable 
.................... static DWORD ICMPTimer; 
....................  
.................... // ICMP Flag structure 
.................... static struct 
.................... { 
.................... 	unsigned char bICMPInUse:1;         // Indicates that the ICMP Client is in use 
.................... 	unsigned char bReplyValid:1;        // Indicates that a correct Ping response to one of our pings was received 
.................... 	unsigned char bRemoteHostIsROM:1;   // Indicates that a remote host name was passed as a ROM pointer argument 
.................... } ICMPFlags = {0x00}; 
....................  
.................... // ICMP Static Variables 
.................... static union 
.................... { 
.................... 	union 
.................... 	{ 
.................... 		ROM BYTE *szROM; 
.................... 		BYTE *szRAM; 
.................... 	} RemoteHost; 
.................... 	NODE_INFO ICMPRemote; 
.................... } StaticVars; 
....................  
.................... // ICMP State Machine Enumeration 
.................... static enum 
.................... { 
.................... 	SM_IDLE = 0, 
.................... 	SM_DNS_SEND_QUERY, 
.................... 	SM_DNS_GET_RESPONSE, 
.................... 	SM_ARP_SEND_QUERY, 
.................... 	SM_ARP_GET_RESPONSE, 
.................... 	SM_ICMP_SEND_ECHO_REQUEST, 
.................... 	SM_ICMP_GET_ECHO_RESPONSE 
.................... } ICMPState; 
....................  
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPProcess(void) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           *remote: Pointer to a NODE_INFO structure of the  
....................  *					ping requester 
....................  *					len: Count of how many bytes the ping header and  
....................  *					payload are in this IP packet 
....................  * 
....................  * Output:          Generates an echo reply, if requested 
....................  *					Validates and sets ICMPFlags.bReplyValid if a  
....................  *					correct ping response to one of ours is received. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPProcess(NODE_INFO *remote, WORD len) 
.................... { 
.................... 	DWORD_VAL dwVal; 
....................  
....................     // Obtain the ICMP header Type, Code, and Checksum fields 
....................     MACGetArray((BYTE*)&dwVal, sizeof(dwVal)); 
*
03E20:  MOVLW  02
03E22:  MOVLB  2
03E24:  MOVWF  xF4
03E26:  MOVLW  EF
03E28:  MOVWF  xF3
03E2A:  MOVFF  2F4,383
03E2E:  MOVFF  FE8,382
03E32:  MOVLB  3
03E34:  CLRF   x85
03E36:  MOVLW  04
03E38:  MOVWF  x84
03E3A:  MOVLB  0
03E3C:  CALL   0E68
.................... 	 
.................... 	// See if this is an ICMP echo (ping) request 
.................... 	if(dwVal.w[0] == 0x0008u) 
03E40:  MOVLB  2
03E42:  MOVF   xEF,W
03E44:  SUBLW  08
03E46:  BNZ   3F06
03E48:  MOVF   xF0,F
03E4A:  BNZ   3F06
.................... 	{ 
.................... 		// Validate the checksum using the Microchip MAC's DMA module 
.................... 		// The checksum data includes the precomputed checksum in the  
.................... 		// header, so a valid packet will always have a checksum of  
.................... 		// 0x0000 if the packet is not disturbed. 
.................... 		if(MACCalcRxChecksum(0+sizeof(IP_HEADER), len)) 
03E4C:  MOVLB  3
03E4E:  CLRF   x0A
03E50:  MOVLW  14
03E52:  MOVWF  x09
03E54:  MOVFF  2EE,30C
03E58:  MOVFF  2ED,30B
03E5C:  MOVLB  0
03E5E:  RCALL  3C24
03E60:  MOVF   01,W
03E62:  IORWF  02,W
03E64:  BZ    3E68
.................... 			return; 
03E66:  BRA    3F04
.................... 	 
.................... 		// Calculate new Type, Code, and Checksum values 
.................... 		dwVal.v[0] = 0x00;	// Type: 0 (ICMP echo/ping reply) 
03E68:  MOVLB  2
03E6A:  CLRF   xEF
.................... 		dwVal.v[2] += 8;	// Subtract 0x0800 from the checksum 
03E6C:  MOVLW  08
03E6E:  ADDWF  xF1,F
.................... 		if(dwVal.v[2] < 8u) 
03E70:  MOVF   xF1,W
03E72:  SUBLW  07
03E74:  BNC   3E7E
.................... 		{ 
.................... 			dwVal.v[3]++; 
03E76:  INCF   xF2,F
.................... 			if(dwVal.v[3] == 0u) 
03E78:  MOVF   xF2,F
03E7A:  BNZ   3E7E
.................... 				dwVal.v[2]++; 
03E7C:  INCF   xF1,F
.................... 		} 
.................... 	 
.................... 	    // Wait for TX hardware to become available (finish transmitting  
.................... 	    // any previous packet) 
.................... 	    while(!IPIsTxReady()); 
03E7E:  MOVLB  0
03E80:  CALL   1656
03E84:  MOVF   01,F
03E86:  BZ    3E80
....................  
.................... 		// Position the write pointer for the next IPPutHeader operation 
.................... 		// NOTE: do not put this before the IPIsTxReady() call for WF compatbility 
.................... 	    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER)); 
03E88:  MOVLW  11
03E8A:  MOVLB  3
03E8C:  MOVWF  x70
03E8E:  MOVLW  E5
03E90:  MOVWF  x6F
03E92:  MOVLB  0
03E94:  CALL   0D46
....................         	 
.................... 		// Create IP header in TX memory 
.................... 		IPPutHeader(remote, IP_PROT_ICMP, len); 
03E98:  MOVFF  2EC,361
03E9C:  MOVFF  2EB,360
03EA0:  MOVLW  01
03EA2:  MOVLB  3
03EA4:  MOVWF  x62
03EA6:  MOVFF  2EE,364
03EAA:  MOVFF  2ED,363
03EAE:  MOVLB  0
03EB0:  CALL   1DD2
.................... 	 
.................... 		// Copy ICMP response into the TX memory 
.................... 		MACPutArray((BYTE*)&dwVal, sizeof(dwVal)); 
03EB4:  MOVLW  02
03EB6:  MOVLB  2
03EB8:  MOVWF  xF4
03EBA:  MOVLW  EF
03EBC:  MOVWF  xF3
03EBE:  MOVFF  2F4,385
03EC2:  MOVFF  FE8,384
03EC6:  MOVLB  3
03EC8:  CLRF   x87
03ECA:  MOVLW  04
03ECC:  MOVWF  x86
03ECE:  MOVLB  0
03ED0:  CALL   0DB6
.................... 		MACMemCopyAsync(-1, -1, len-4); 
03ED4:  MOVLW  04
03ED6:  MOVLB  2
03ED8:  SUBWF  xED,W
03EDA:  MOVWF  xF3
03EDC:  MOVLW  00
03EDE:  SUBWFB xEE,W
03EE0:  MOVWF  xF4
03EE2:  MOVLB  3
03EE4:  SETF   x70
03EE6:  SETF   x6F
03EE8:  SETF   x72
03EEA:  SETF   x71
03EEC:  MOVWF  x74
03EEE:  MOVFF  2F3,373
03EF2:  MOVLB  0
03EF4:  CALL   0F08
.................... 		while(!MACIsMemCopyDone()); 
03EF8:  CALL   1188
03EFC:  MOVF   01,F
03EFE:  BZ    3EF8
.................... 	 
.................... 		// Transmit the echo reply packet 
.................... 	    MACFlush(); 
03F00:  CALL   2004
03F04:  MOVLB  2
.................... 	} 
.................... #if defined(STACK_USE_ICMP_CLIENT) 
03F06:  MOVLB  0
03F08:  GOTO   5B26 (RETURN)
.................... 	else if(dwVal.w[0] == 0x0000u)	// See if this an ICMP Echo reply to our request 
.................... 	{ 
.................... 		// Get the sequence number and identifier fields 
.................... 		MACGetArray((BYTE*)&dwVal, sizeof(dwVal)); 
.................... 		 
.................... 		// See if the identifier matches the one we sent 
.................... 		if(dwVal.w[0] != 0xEFBE)	 
.................... 			return; 
.................... 	 
.................... 		if(dwVal.w[1] != wICMPSequenceNumber) 
.................... 			return; 
....................  
.................... 		// Validate the ICMP checksum field 
.................... 	    IPSetRxBuffer(0); 
.................... 		if(CalcIPBufferChecksum(sizeof(ICMP_PACKET)))	// Two bytes of payload were sent in the echo request 
.................... 			return; 
.................... 		 
.................... 		// Flag that we received the response and stop the timer ticking 
.................... 		ICMPFlags.bReplyValid = 1; 
.................... 		ICMPTimer = TickGet() - ICMPTimer; 
.................... 	} 
.................... #endif 
.................... } 
....................  
.................... #if defined(STACK_USE_ICMP_CLIENT) 
.................... /********************************************************************* 
....................  * Function:        void ICMPSendPing(DWORD dwRemoteIP) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() returned TRUE 
....................  * 
....................  * Input:           dwRemoteIP: IP Address to ping.  Must be stored  
....................  *								big endian.  Ex. 192.168.0.1 should be 
....................  *								passed as 0x0100A8C0. 
....................  * 
....................  * Output:          Begins the process of transmitting an ICMP echo  
....................  *					request.  This normally involves an ARP  
....................  *					resolution procedure first. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPSendPing(DWORD dwRemoteIP) 
.................... { 
.................... 	ICMPFlags.bReplyValid = 0; 
.................... 	ICMPTimer = TickGet(); 
.................... 	StaticVars.ICMPRemote.IPAddr.Val = dwRemoteIP; 
.................... 	ICMPState = SM_ARP_SEND_QUERY; 
.................... } 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... /********************************************************************* 
....................  * Function:        void ICMPSendPingToHost (BYTE * szRemoteHost) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() returned TRUE 
....................  * 
....................  * Input:           szRemoteHost: Host name to ping.  Must be stored  
....................  *								  in RAM if being called by PIC18. 
....................  *								  Ex. www.microchip.com 
....................  * 
....................  * Output:          Begins the process of transmitting an ICMP echo  
....................  *					request.  This normally involves an ARP  
....................  *					resolution procedure first. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPSendPingToHost(BYTE * szRemoteHost) 
.................... { 
.................... 	ICMPFlags.bReplyValid = 0; 
.................... 	ICMPTimer = TickGet(); 
.................... 	ICMPFlags.bRemoteHostIsROM = 0; 
.................... 	StaticVars.RemoteHost.szRAM = szRemoteHost; 
.................... 	ICMPState = SM_DNS_SEND_QUERY; 
.................... } 
....................  
.................... #if defined(__18CXX) 
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPSendPingToHostROM (ROM BYTE * szRemoteHost) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() returned TRUE 
....................  * 
....................  * Input:           szRemoteHost: Host name to ping.  Must be stored  
....................  *								  in ROM. Should only be called by PIC18. 
....................  *								  Ex. www.microchip.com 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Begins the process of transmitting an ICMP echo  
....................  *					request.  This normally involves an ARP  
....................  *					resolution procedure first. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPSendPingToHostROM(ROM BYTE * szRemoteHost) 
.................... { 
.................... 	ICMPFlags.bReplyValid = 0; 
.................... 	ICMPTimer = TickGet(); 
.................... 	ICMPFlags.bRemoteHostIsROM = 1; 
.................... 	StaticVars.RemoteHost.szROM = szRemoteHost; 
.................... 	ICMPState = SM_DNS_SEND_QUERY; 
.................... } 
....................  
.................... #endif 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        LONG ICMPGetReply(void) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() returned TRUE and ICMPSendPing()  
....................  *					was called 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          -3: Could not resolve hostname (DNS timeout or  
....................  *			    	    hostname invalid) 
....................  *					-2: No response received yet 
....................  *					-1: Operation timed out (longer than ICMP_TIMEOUT)  
....................  *						has elapsed. 
....................  *					>=0: Number of TICKs that elapsed between  
....................  *						 initial ICMP transmission and reception of  
....................  *						 a valid echo. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... LONG ICMPGetReply(void) 
.................... { 
.................... 	ICMP_PACKET ICMPPacket; 
....................  
.................... 	switch(ICMPState) 
.................... 	{ 
.................... #if defined(STACK_USE_DNS) 
.................... 		case SM_DNS_SEND_QUERY: 
.................... 			// Obtain DNS module ownership 
.................... 			if(!DNSBeginUsage()) 
.................... 				break; 
.................... 			 
.................... 			// Send DNS query 
.................... 			if(ICMPFlags.bRemoteHostIsROM) 
.................... 				DNSResolveROM(StaticVars.RemoteHost.szROM, DNS_TYPE_A); 
.................... 			else 
.................... 				DNSResolve(StaticVars.RemoteHost.szRAM, DNS_TYPE_A); 
.................... 			 
.................... 			ICMPState = SM_DNS_GET_RESPONSE; 
.................... 			break; 
.................... 				 
.................... 		case SM_DNS_GET_RESPONSE: 
.................... 			// See if DNS is done, and if so, get the remote IP address 
.................... 			if(!DNSIsResolved(&StaticVars.ICMPRemote.IPAddr)) 
.................... 				break; 
.................... 			 
.................... 			// Free the DNS module 
.................... 			DNSEndUsage(); 
.................... 			 
.................... 			// Return error code if the DNS query failed 
.................... 			if(StaticVars.ICMPRemote.IPAddr.Val == 0x00000000ul) 
.................... 			{ 
.................... 				ICMPState = SM_IDLE; 
.................... 				return -3; 
.................... 			} 
....................  
.................... 			ICMPState = SM_ARP_SEND_QUERY;	 
.................... 			// No break;	 
.................... #endif 
....................  
.................... 		case SM_ARP_SEND_QUERY: 
.................... 			ARPResolve(&StaticVars.ICMPRemote.IPAddr); 
.................... 			ICMPState = SM_ARP_GET_RESPONSE; 
.................... 			break; 
.................... 			 
.................... 		case SM_ARP_GET_RESPONSE: 
.................... 			// See if the ARP reponse was successfully received 
.................... 			if(!ARPIsResolved(&StaticVars.ICMPRemote.IPAddr, &StaticVars.ICMPRemote.MACAddr)) 
.................... 				break; 
.................... 			 
.................... 			ICMPState = SM_ICMP_SEND_ECHO_REQUEST; 
.................... 			// No break;  
.................... 		 
.................... 		case SM_ICMP_SEND_ECHO_REQUEST: 
.................... 		    if(!IPIsTxReady()) 
.................... 		    	break; 
....................  
.................... 			// Set up the ping packet 
.................... 			ICMPPacket.vType = 0x08;	// 0x08: Echo (ping) request 
.................... 			ICMPPacket.vCode = 0x00; 
.................... 			ICMPPacket.wChecksum = 0x0000; 
.................... 			ICMPPacket.wIdentifier = 0xEFBE; 
.................... 			wICMPSequenceNumber++;  
.................... 			ICMPPacket.wSequenceNumber = wICMPSequenceNumber; 
.................... 			ICMPPacket.wData = 0x2860; 
.................... 			ICMPPacket.wChecksum = CalcIPChecksum((BYTE*)&ICMPPacket, sizeof(ICMPPacket)); 
.................... 		 
.................... 			// Record the current time.  This will be used as a basis for  
.................... 			// finding the echo response time, which exludes the ARP and DNS  
.................... 			// steps 
.................... 			ICMPTimer = TickGet(); 
....................  
.................... 			// Position the write pointer for the next IPPutHeader operation 
.................... 		    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER)); 
.................... 		 
.................... 			// Create IP header in TX memory 
.................... 			IPPutHeader(&StaticVars.ICMPRemote, IP_PROT_ICMP, sizeof(ICMPPacket)); 
.................... 			MACPutArray((BYTE*)&ICMPPacket, sizeof(ICMPPacket)); 
.................... 			MACFlush(); 
....................  
.................... 			// Echo sent, advance state 
.................... 			ICMPState = SM_ICMP_GET_ECHO_RESPONSE; 
.................... 			break; 
....................  
.................... 		case SM_ICMP_GET_ECHO_RESPONSE: 
.................... 			// See if the echo was successfully received 
.................... 			if(ICMPFlags.bReplyValid) 
.................... 				return (LONG)ICMPTimer; 
.................... 		 
.................... 			break; 
.................... 		 
.................... 		// SM_IDLE or illegal/impossible state: 
.................... 		default: 
.................... 			return -1; 
.................... 	} 
....................  
.................... 	// See if the DNS/ARP/echo request timed out 
.................... 	if(TickGet() - ICMPTimer > ICMP_TIMEOUT) 
.................... 	{ 
.................... 		// Free DNS module if we have it in use 
.................... 		#if defined(STACK_USE_DNS) 
.................... 			if(ICMPState == SM_DNS_GET_RESPONSE) 
.................... 				DNSEndUsage(); 
.................... 		#endif 
.................... 		 
.................... 		// Stop ICMP echo test and return error to caller 
.................... 		ICMPState = SM_IDLE; 
.................... 		return -1; 
.................... 	} 
....................  
.................... 	// Still working.  No response to report yet. 
.................... 	return -2; 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPBeginUsage(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: You have successfully gained ownership of  
....................  *						  the ICMP client module and can now use the  
....................  *						  ICMPSendPing() and ICMPGetReply() functions. 
....................  *					FALSE: Some other application is using the ICMP  
....................  *						   client module.  Calling ICMPSendPing()  
....................  *						   will corrupt the other application's ping  
....................  *						   result. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Claims ownership of the ICMP module. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPBeginUsage(void) 
.................... { 
.................... 	if(ICMPFlags.bICMPInUse) 
.................... 		return FALSE; 
....................  
.................... 	ICMPFlags.bICMPInUse = TRUE; 
.................... 	return TRUE; 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPEndUsage(void) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() was called by you and it  
....................  *					returned TRUE. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Your ownership of the ICMP module is released.   
....................  *					You can no longer use ICMPSendPing(). 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Gives up ownership of the ICMP module. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPEndUsage(void) 
.................... { 
.................... 	ICMPFlags.bICMPInUse = FALSE; 
.................... } 
....................  
.................... #endif //#if defined(STACK_USE_ICMP_CLIENT) 
....................  
.................... #endif //#if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP) 
....................    #include "UDP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) 
....................    #include "DHCP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_SERVER) 
....................    #include "DHCPs.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS_SERVER) 
....................    #include "DNSs.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
....................    #include "TCP.c" 
.................... /********************************************************************* 
....................  * 
....................  *   Transmission Control Protocol (TCP) Communications Layer 
....................  *  Module for Microchip TCP/IP Stack 
....................  *    -Provides reliable, handshaked transport of application stream  
....................  *    oriented data with flow control 
....................  *    -Reference: RFC 793 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCP.c 
....................  * Dependencies:    IP, Tick, Ethernet/WiFi (ENC28J60.c, ETH97J60.c,  
....................  *               ENCX24J600.c, or WFMac.c), ARP (optional),  
....................  *               DNS (optional) 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date       Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01     Original        (Rev 1.0) 
....................  * Howard Schlunder      12/11/06   Changed almost everything to  
....................  *                           better meet RFC 793. 
....................  * Darren Rook          04/14/11 Changed TCP_SOCKET_COUNT to use TCP_CONFIGURATION. 
....................  ********************************************************************/ 
.................... #define __TCP_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_TCP) 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Configuration Parameters 
....................   ***************************************************************************/ 
....................  
.................... // Starting port for client sockets 
.................... #define LOCAL_PORT_START_NUMBER (1024u) 
.................... // End port for client sockets 
.................... #define LOCAL_PORT_END_NUMBER   (5000u) 
....................  
.................... // For debugging only.  Normal applications should never enable these 
.................... //#define DEBUG_GENERATE_TX_LOSS      62257 
.................... //#define DEBUG_GENERATE_RX_LOSS      64225 
....................  
.................... // A lot of pointer dereference code can be removed if you  
.................... // locally copy TCBStubs to an absolute memory location. 
.................... // If you define TCP_OPTIMIZE_FOR_SIZE, local caching will  
.................... // occur and will substantially decrease the entire TCP ROM  
.................... // footprint (up to 35%).  If you leave TCP_OPTIMIZE_FOR_SIZE  
.................... // undefined, the local caching will be disabled.  On PIC18  
.................... // products, this will improve TCP performance/throughput by  
.................... // approximately 15%. 
.................... #define TCP_OPTIMIZE_FOR_SIZE 
....................  
.................... // For smallest size and best throughput, TCP_OPTIMIZE_FOR_SIZE  
.................... // should always be enabled on PIC24/dsPIC products.  On PIC32  
.................... // products there is very little difference and depnds on compiler  
.................... // optimization level 
.................... #if defined(__C30__) && !defined(TCP_OPTIMIZE_FOR_SIZE) 
....................    #define TCP_OPTIMIZE_FOR_SIZE 
.................... #elif defined(__C32__) && defined(TCP_OPTIMIZE_FOR_SIZE) 
....................    #undef TCP_OPTIMIZE_FOR_SIZE 
.................... #endif 
....................  
.................... // TCP Maximum Segment Size for TX.  The TX maximum segment size is actually  
.................... // govered by the remote node's MSS option advirtised during connection  
.................... // establishment.  However, if the remote node specifies an unhandlably large  
.................... // MSS (ex: > Ethernet MTU), this define sets a hard limit so that we don't  
.................... // cause any TX buffer overflows.  If the remote node does not advirtise a MSS  
.................... // option, all TX segments are fixed at 536 bytes maximum. 
.................... #define TCP_MAX_SEG_SIZE_TX         (1460u) 
....................  
.................... // TCP Maximum Segment Size for RX.  This value is advirtised during connection  
.................... // establishment and the remote node should obey it.  This should be set to 536  
.................... // to avoid IP layer fragmentation from causing packet loss.  However, raising  
.................... // its value can enhance performance at the (small) risk of introducing  
.................... // incompatibility with certain special remote nodes (ex: ones connected via a  
.................... // slow dial up modem). 
.................... #define TCP_MAX_SEG_SIZE_RX         (536u) 
....................  
.................... // TCP Timeout and retransmit numbers 
.................... #define TCP_START_TIMEOUT_VAL      ((DWORD)TICK_SECOND*1)   // Timeout to retransmit unacked data 
.................... #define TCP_DELAYED_ACK_TIMEOUT      ((DWORD)TICK_SECOND/10)   // Timeout for delayed-acknowledgement algorithm 
.................... #define TCP_FIN_WAIT_2_TIMEOUT      ((DWORD)TICK_SECOND*5)   // Timeout for FIN WAIT 2 state 
.................... #define TCP_KEEP_ALIVE_TIMEOUT      ((DWORD)TICK_SECOND*10)   // Timeout for keep-alive messages when no traffic is sent 
.................... #define TCP_CLOSE_WAIT_TIMEOUT      ((DWORD)TICK_SECOND/5)   // Timeout for the CLOSE_WAIT state 
.................... #define TCP_MAX_RETRIES             (5u)               // Maximum number of retransmission attempts 
.................... #define TCP_MAX_UNACKED_KEEP_ALIVES   (6u)               // Maximum number of keep-alive messages that can be sent without receiving a response before automatically closing the connection 
.................... #define TCP_MAX_SYN_RETRIES         (2u)   // Smaller than all other retries to reduce SYN flood DoS duration 
....................  
.................... #define TCP_AUTO_TRANSMIT_TIMEOUT_VAL   (TICK_SECOND/25ull)   // Timeout before automatically transmitting unflushed data 
.................... #define TCP_WINDOW_UPDATE_TIMEOUT_VAL   (TICK_SECOND/5ull)   // Timeout before automatically transmitting a window update due to a TCPGet() or TCPGetArray() function call 
....................  
.................... #define TCP_SYN_QUEUE_MAX_ENTRIES   (3u)                // Number of TCP RX SYN packets to save if they cannot be serviced immediately 
.................... #define TCP_SYN_QUEUE_TIMEOUT      ((DWORD)TICK_SECOND*3)   // Timeout for when SYN queue entries are deleted if unserviceable 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    TCP Header Data Types 
....................   ***************************************************************************/ 
....................  
.................... #define FIN     (0x01)      // FIN Flag as defined in RFC 
.................... #define SYN     (0x02)      // SYN Flag as defined in RFC 
.................... #define RST     (0x04)      // Reset Flag as defined in RFC 
.................... #define PSH     (0x08)      // Push Flag as defined in RFC 
.................... #define ACK     (0x10)      // Acknowledge Flag as defined in RFC 
.................... #define URG     (0x20)      // Urgent Flag as defined in RFC 
....................  
.................... // TCP Header Data Structure 
.................... typedef struct 
.................... { 
....................    WORD    SourcePort;      // Local port number 
....................    WORD    DestPort;      // Remote port number 
....................    DWORD   SeqNumber;      // Local sequence number 
....................    DWORD   AckNumber;      // Acknowledging remote sequence number 
....................  
....................    struct 
....................    { 
....................       unsigned char Reserved3      : 4; 
....................       unsigned char Val            : 4; 
....................    } DataOffset;         // Data offset flags nibble 
....................  
....................    union 
....................    { 
....................       struct 
....................       { 
....................          unsigned char flagFIN    : 1; 
....................          unsigned char flagSYN    : 1; 
....................          unsigned char flagRST    : 1; 
....................          unsigned char flagPSH    : 1; 
....................          unsigned char flagACK    : 1; 
....................          unsigned char flagURG    : 1; 
....................          unsigned char Reserved2  : 2; 
....................       } bits; 
....................       BYTE byte; 
....................    } Flags;            // TCP Flags as defined in RFC 
....................  
....................    WORD    Window;         // Local free RX buffer window 
....................    WORD    Checksum;      // Data payload checksum 
....................    WORD    UrgentPointer;   // Urgent pointer 
.................... } TCP_HEADER; 
....................  
.................... #define TCP_OPTIONS_END_OF_LIST     (0x00u)      // End of List TCP Option Flag 
.................... #define TCP_OPTIONS_NO_OP           (0x01u)      // No Op TCP Option 
.................... #define TCP_OPTIONS_MAX_SEG_SIZE    (0x02u)      // Maximum segment size TCP flag 
.................... typedef struct 
.................... { 
....................    BYTE        Kind;                     // Type of option 
....................    BYTE        Length;                     // Length 
....................    WORD_VAL    MaxSegSize;                  // Maximum segment size 
.................... } TCP_OPTIONS;                           // TCP Options data structure                      
....................  
.................... // Structure containing all the important elements of an incomming  
.................... // SYN packet in order to establish a connection at a future time  
.................... // if all sockets on the listening port are already connected to  
.................... // someone 
.................... typedef struct  
.................... { 
....................    NODE_INFO   niSourceAddress;// Remote IP address and MAC address 
....................    WORD      wSourcePort;   // Remote TCP port number that the response SYN needs to be sent to 
....................    DWORD      dwSourceSEQ;   // Remote TCP SEQuence number that must be ACKnowledged when we send our response SYN 
....................    WORD      wDestPort;      // Local TCP port which the original SYN was destined for 
....................    WORD      wTimestamp;      // Timer to expire old SYN packets that can't be serviced at all 
.................... } TCP_SYN_QUEUE; 
....................  
....................  
.................... #if defined(STACK_CLIENT_MODE) 
.................... static WORD NextPort __attribute__((persistent));   // Tracking variable for next local client port number 
.................... #endif 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    TCB Definitions 
....................   ***************************************************************************/ 
....................  
.................... // Determines the number of defined TCP sockets 
.................... //#define TCP_SOCKET_COUNT   (sizeof(TCPSocketInitializer)/sizeof(TCPSocketInitializer[0])) 
.................... #define TCP_SOCKET_COUNT   TCP_CONFIGURATION    //ccs changed 
....................  
.................... #if defined(HI_TECH_C) 
....................    // The initializer forces this large array out of the bss section  
....................    // so we can link correctly. 
....................    #pragma psect bigdata=TCB_uRAM_BIG 
....................    #pragma psect data=TCB_uRAM 
....................    static TCB_STUB TCBStubs[TCP_SOCKET_COUNT] = {'\0'};    
....................    #pragma psect data=ordinary_data_sect 
....................    #pragma psect bigdata=ordinary_data_sect_big 
.................... #else 
....................    // The TCB array is very large.  With the C18 compiler, one must  
....................    // modify the linker script to make an array that spans more than  
....................    // one memory bank.  To do this, make the necessary changes to your  
....................    // processor's linker script (.lkr).  Here is an example showing  
....................    // gpr11 and 128 bytes of gpr12 being combined into one 384 byte  
....................    // block used exclusively by the TCB_uRAM data section: 
....................    // ... 
....................    // //DATABANK   NAME=gpr11      START=0xB00          END=0xBFF 
....................    // //DATABANK   NAME=gpr12      START=0xC00          END=0xCFF 
....................    // DATABANK   NAME=gpr11b     START=0xB00          END=0xC7F           PROTECTED 
....................    // DATABANK   NAME=gpr12      START=0xC80          END=0xCFF 
....................    // ... 
....................    // SECTION    NAME=TCB_uRAM    RAM=gpr11b 
....................    // ... 
....................    #if defined(__18CXX) && !defined(HI_TECH_C)    
....................       #pragma udata TCB_uRAM 
....................    #endif 
....................    static TCB_STUB TCBStubs[TCP_SOCKET_COUNT]; 
....................    #if defined(__18CXX) && !defined(HI_TECH_C)    
....................       #pragma udata               // Return to any other RAM section 
....................    #endif 
.................... #endif 
....................  
.................... static TCB MyTCB;                           // Currently loaded TCB 
.................... static TCP_SOCKET hCurrentTCP = INVALID_SOCKET;      // Current TCP socket 
.................... #if TCP_SYN_QUEUE_MAX_ENTRIES 
....................    #if defined(__18CXX) && !defined(HI_TECH_C)    
....................       #pragma udata SYN_QUEUE_RAM_SECT 
....................    #endif 
....................    static TCP_SYN_QUEUE SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES];   // Array of saved incoming SYN requests that need to be serviced later 
....................    #if defined(__18CXX) && !defined(HI_TECH_C)    
....................       #pragma udata 
....................    #endif 
.................... #endif 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Function Prototypes 
....................   ***************************************************************************/ 
....................  
.................... static void TCPRAMCopy(PTR_BASE wDest, BYTE vDestType, PTR_BASE wSource, BYTE vSourceType, WORD wLength); 
....................  
.................... #if defined(__18CXX) 
....................    static void TCPRAMCopyROM(PTR_BASE wDest, BYTE wDestType, ROM BYTE* wSource, WORD wLength); 
.................... #else 
....................    #define TCPRAMCopyROM(a,b,c,d)   TCPRAMCopy(a,b,c,TCP_PIC_RAM,d) 
.................... #endif 
....................  
.................... static void SendTCP(BYTE vTCPFlags, BYTE vSendFlags); 
.................... static void HandleTCPSeg(TCP_HEADER* h, WORD len); 
.................... static BOOL FindMatchingTCPSocket(TCP_HEADER* h, NODE_INFO* remote); 
.................... static void SwapTCPHeader(TCP_HEADER* header); 
.................... static void CloseSocket(void); 
.................... static void SyncTCB(void); 
....................  
.................... #if defined(WF_CS_TRIS) 
.................... UINT16 WFGetTCBSize(void); 
.................... #endif 
....................  
.................... // Indicates if this packet is a retransmission (no reset) or a new packet (reset required) 
.................... #define SENDTCP_RESET_TIMERS   0x01 
.................... // Instead of transmitting normal data, a garbage octet is transmitted according to RFC 1122 section 4.2.3.6 
.................... #define SENDTCP_KEEP_ALIVE      0x02 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    TCB Optimization Configuration 
....................   ***************************************************************************/ 
....................  
.................... #if defined(TCP_OPTIMIZE_FOR_SIZE) 
....................    static TCB_STUB MyTCBStub; 
....................     
....................    // Flushes MyTCBStub cache and loads up the specified TCB_STUB. 
....................    // Does nothing on cache hit. 
....................    static void SyncTCBStub(TCP_SOCKET hTCP) 
....................    { 
....................       if(hCurrentTCP == hTCP) 
*
00CA6:  MOVLB  3
00CA8:  MOVF   x21,W
00CAA:  MOVLB  0
00CAC:  SUBWF  xDB,W
00CAE:  BNZ   0CB2
....................          return; 
00CB0:  BRA    0D44
....................     
....................       if(hCurrentTCP != INVALID_SOCKET) 
00CB2:  MOVF   xDB,W
00CB4:  SUBLW  FE
00CB6:  BZ    0CF4
....................       { 
....................          // Save the current TCB stub 
....................          memcpy((void*)&TCBStubs[hCurrentTCP], (void*)&MyTCBStub, sizeof(MyTCBStub)); 
00CB8:  MOVF   xDB,W
00CBA:  MULLW  1C
00CBC:  MOVF   FF3,W
00CBE:  CLRF   03
00CC0:  ADDLW  98
00CC2:  MOVWF  01
00CC4:  MOVLW  00
00CC6:  ADDWFC 03,F
00CC8:  MOVFF  01,322
00CCC:  MOVLB  3
00CCE:  MOVFF  03,323
00CD2:  MOVLW  01
00CD4:  MOVWF  x25
00CD6:  MOVLW  18
00CD8:  MOVFF  03,FEA
00CDC:  MOVFF  01,FE9
00CE0:  MOVFF  325,FE2
00CE4:  MOVWF  FE1
00CE6:  MOVLW  1C
00CE8:  MOVWF  01
00CEA:  MOVFF  FE6,FEE
00CEE:  DECFSZ 01,F
00CF0:  BRA    0CEA
00CF2:  MOVLB  0
....................       } 
....................     
....................       hCurrentTCP = hTCP; 
00CF4:  MOVFF  321,DB
....................     
....................       if(hTCP == INVALID_SOCKET) 
00CF8:  MOVLB  3
00CFA:  MOVF   x21,W
00CFC:  SUBLW  FE
00CFE:  BNZ   0D06
....................          return; 
00D00:  MOVLB  0
00D02:  BRA    0D44
00D04:  MOVLB  3
....................     
....................       // Load up the new TCB stub 
....................       memcpy((void*)&MyTCBStub, (void*)&TCBStubs[hTCP], sizeof(MyTCBStub)); 
00D06:  MOVLW  01
00D08:  MOVWF  x23
00D0A:  MOVLW  18
00D0C:  MOVWF  x22
00D0E:  MOVF   x21,W
00D10:  MULLW  1C
00D12:  MOVF   FF3,W
00D14:  CLRF   03
00D16:  ADDLW  98
00D18:  MOVWF  01
00D1A:  MOVLW  00
00D1C:  ADDWFC 03,F
00D1E:  MOVFF  01,324
00D22:  MOVFF  03,325
00D26:  MOVFF  323,FEA
00D2A:  MOVFF  322,FE9
00D2E:  MOVFF  03,FE2
00D32:  MOVFF  01,FE1
00D36:  MOVLW  1C
00D38:  MOVWF  01
00D3A:  MOVFF  FE6,FEE
00D3E:  DECFSZ 01,F
00D40:  BRA    0D3A
00D42:  MOVLB  0
00D44:  RETURN 0
....................    } 
.................... #else 
....................    // Flushes MyTCBStub cache and loads up the specified TCB_STUB. 
....................    // Does nothing on cache hit. 
....................    #define SyncTCBStub(a)   hCurrentTCP = (a) 
....................    // Alias to current TCP stub. 
....................    #define MyTCBStub      TCBStubs[hCurrentTCP] 
.................... #endif 
....................  
....................  
....................  
.................... // Flushes MyTCB cache and loads up the specified TCB. 
.................... // Does nothing on cache hit. 
.................... static void SyncTCB(void) 
.................... { 
....................    static TCP_SOCKET hLastTCB = INVALID_SOCKET; 
....................     
....................    if(hLastTCB == hCurrentTCP) 
*
01296:  MOVF   xDB,W
01298:  MOVLB  1
0129A:  SUBWF  x34,W
0129C:  BNZ   12A0
....................       return; 
0129E:  BRA    1366
....................  
....................    if(hLastTCB != INVALID_SOCKET) 
012A0:  MOVF   x34,W
012A2:  SUBLW  FE
012A4:  BZ    1322
....................    { 
....................       // Save the current TCB 
....................       TCPRAMCopy(TCBStubs[hLastTCB].bufferTxStart - sizeof(MyTCB), TCBStubs[hLastTCB].vMemoryMedium, (PTR_BASE)&MyTCB, TCP_PIC_RAM, sizeof(MyTCB)); 
012A6:  MOVF   x34,W
012A8:  MULLW  1C
012AA:  MOVF   FF3,W
012AC:  MOVLB  3
012AE:  CLRF   x61
012B0:  MOVWF  x60
012B2:  MOVLW  98
012B4:  ADDWF  x60,W
012B6:  MOVWF  FE9
012B8:  MOVLW  00
012BA:  ADDWFC x61,W
012BC:  MOVWF  FEA
012BE:  MOVFF  FEC,363
012C2:  MOVF   FED,F
012C4:  MOVFF  FEF,362
012C8:  MOVLW  27
012CA:  SUBWF  x62,F
012CC:  MOVLW  00
012CE:  SUBWFB x63,F
012D0:  MOVLB  1
012D2:  MOVF   x34,W
012D4:  MULLW  1C
012D6:  MOVF   FF3,W
012D8:  MOVLB  3
012DA:  CLRF   x65
012DC:  MOVWF  x64
012DE:  MOVLW  1B
012E0:  ADDWF  x64,W
012E2:  MOVWF  01
012E4:  MOVLW  00
012E6:  ADDWFC x65,W
012E8:  MOVWF  03
012EA:  MOVF   01,W
012EC:  ADDLW  98
012EE:  MOVWF  FE9
012F0:  MOVLW  00
012F2:  ADDWFC 03,W
012F4:  MOVWF  FEA
012F6:  MOVFF  FEF,364
012FA:  CLRF   x66
012FC:  MOVLW  B4
012FE:  MOVWF  x65
01300:  MOVFF  363,368
01304:  MOVFF  362,367
01308:  MOVFF  364,369
0130C:  MOVFF  366,36B
01310:  MOVWF  x6A
01312:  MOVLW  01
01314:  MOVWF  x6C
01316:  CLRF   x6E
01318:  MOVLW  27
0131A:  MOVWF  x6D
0131C:  MOVLB  0
0131E:  RCALL  11B0
01320:  MOVLB  1
....................    } 
....................  
....................    // Load up the new TCB 
....................    hLastTCB = hCurrentTCP; 
01322:  MOVFF  DB,134
....................    TCPRAMCopy((PTR_BASE)&MyTCB, TCP_PIC_RAM, MyTCBStub.bufferTxStart - sizeof(MyTCB), MyTCBStub.vMemoryMedium, sizeof(MyTCB)); 
01326:  MOVLB  3
01328:  CLRF   x61
0132A:  MOVLW  B4
0132C:  MOVWF  x60
0132E:  MOVLW  27
01330:  MOVLB  1
01332:  SUBWF  x18,W
01334:  MOVLB  3
01336:  MOVWF  x62
01338:  MOVLW  00
0133A:  MOVLB  1
0133C:  SUBWFB x19,W
0133E:  MOVLB  3
01340:  MOVWF  x63
01342:  MOVFF  361,368
01346:  MOVFF  360,367
0134A:  MOVLW  01
0134C:  MOVWF  x69
0134E:  MOVFF  363,36B
01352:  MOVFF  362,36A
01356:  MOVFF  133,36C
0135A:  CLRF   x6E
0135C:  MOVLW  27
0135E:  MOVWF  x6D
01360:  MOVLB  0
01362:  RCALL  11B0
01364:  MOVLB  1
01366:  MOVLB  0
01368:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPInit(void) 
....................  
....................   Summary: 
....................    Initializes the TCP module. 
....................  
....................   Description: 
....................    Initializes the TCP module.  This function sets up the TCP buffers 
....................    in memory and initializes each socket to the CLOSED state.  If 
....................    insufficient memory was allocated for the TCP sockets, the function 
....................    will hang here to be captured by the debugger. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................      None 
....................       
....................   Remarks: 
....................    This function is called only one during lifetime of the application. 
....................   ***************************************************************************/ 
.................... void TCPInit(void) 
*
01436:  MOVLW  17
01438:  MOVLB  2
0143A:  MOVWF  xED
0143C:  MOVLW  C8
0143E:  MOVWF  xEC
.................... { 
....................    BYTE i; 
....................    BYTE vSocketsAllocated; 
....................    WORD wTXSize, wRXSize; 
....................    PTR_BASE ptrBaseAddress; 
....................    BYTE vMedium; 
....................    #if TCP_ETH_RAM_SIZE > 0 
....................    WORD wCurrentETHAddress = TCP_ETH_RAM_BASE_ADDRESS; 
....................    #endif 
....................    #if TCP_PIC_RAM_SIZE > 0 
....................    PTR_BASE ptrCurrentPICAddress = TCP_PIC_RAM_BASE_ADDRESS; 
....................    #endif 
....................    #if TCP_SPI_RAM_SIZE > 0 
....................    WORD wCurrentSPIAddress = TCP_SPI_RAM_BASE_ADDRESS; 
....................    #endif 
....................  
....................    #if defined(STACK_CLIENT_MODE) 
....................       // Initialize NextPort to a random value if it is zero (such as after  
....................       // reset on a PIC32 or PIC18 when the static memory initializer is  
....................       // used).  By starting with a random number, we decrease the risk of  
....................       // reusing a port number that was previously used if the user power  
....................       // cycles the device. 
....................       if(NextPort == 0u) 
01440:  MOVLB  0
01442:  MOVF   x96,F
01444:  BNZ   1466
01446:  MOVF   x97,F
01448:  BNZ   1466
....................          NextPort = (((WORD)GenerateRandomDWORD()) & 0x07FFu) + LOCAL_PORT_START_NUMBER; 
0144A:  CALL   06F4
0144E:  MOVFF  01,2EF
01452:  MOVLW  07
01454:  MOVLB  2
01456:  ANDWF  xEF,F
01458:  MOVFF  00,96
0145C:  MOVLW  04
0145E:  MOVLB  2
01460:  ADDWF  xEF,W
01462:  MOVLB  0
01464:  MOVWF  x97
....................    #endif 
....................  
....................  
....................    // Mark all SYN Queue entries as invalid by zeroing the memory 
....................    #if TCP_SYN_QUEUE_MAX_ENTRIES 
....................       memset((void*)SYNQueue, 0x00, sizeof(SYNQueue)); 
01466:  MOVLB  2
01468:  CLRF   xEF
0146A:  MOVLW  DC
0146C:  MOVWF  xEE
0146E:  MOVFF  2EF,FEA
01472:  MOVWF  FE9
01474:  CLRF   00
01476:  CLRF   02
01478:  MOVLW  3C
0147A:  MOVWF  01
0147C:  MOVLB  0
0147E:  BRA    0C8A
....................    #endif 
....................     
....................    // Allocate all socket FIFO addresses 
....................    vSocketsAllocated = 0; 
01480:  MOVLB  2
01482:  CLRF   xE4
....................    for(i = 0; i < TCP_SOCKET_COUNT; i++) 
01484:  CLRF   xE3
01486:  MOVF   xE3,F
01488:  BTFSS  FD8.2
0148A:  BRA    15F2
....................    { 
....................       // Generate all needed sockets of each type (TCP_PURPOSE_*) 
....................       SyncTCBStub(i); 
0148C:  MOVFF  2E3,321
01490:  MOVLB  0
01492:  RCALL  0CA6
....................     
....................       vMedium = TCPSocketInitializer[i].vMemoryMedium; 
01494:  MOVLB  2
01496:  MOVF   xE3,W
01498:  MULLW  06
0149A:  MOVF   FF3,W
0149C:  CLRF   xEF
0149E:  MOVWF  xEE
014A0:  MOVLW  01
014A2:  ADDWF  xEE,W
014A4:  MOVWF  01
014A6:  MOVLW  00
014A8:  ADDWFC xEF,W
014AA:  MOVWF  03
014AC:  MOVF   01,W
014AE:  ADDLW  23
014B0:  MOVWF  FE9
014B2:  MOVLW  00
014B4:  ADDWFC 03,W
014B6:  MOVWF  FEA
014B8:  MOVFF  FEF,2EB
....................       wTXSize = TCPSocketInitializer[i].wTXBufferSize; 
014BC:  MOVF   xE3,W
014BE:  MULLW  06
014C0:  MOVF   FF3,W
014C2:  CLRF   xEF
014C4:  MOVWF  xEE
014C6:  MOVLW  02
014C8:  ADDWF  xEE,W
014CA:  MOVWF  01
014CC:  MOVLW  00
014CE:  ADDWFC xEF,W
014D0:  MOVWF  03
014D2:  MOVF   01,W
014D4:  ADDLW  23
014D6:  MOVWF  FE9
014D8:  MOVLW  00
014DA:  ADDWFC 03,W
014DC:  MOVWF  FEA
014DE:  MOVFF  FEC,2E6
014E2:  MOVF   FED,F
014E4:  MOVFF  FEF,2E5
....................       wRXSize = TCPSocketInitializer[i].wRXBufferSize; 
014E8:  MOVF   xE3,W
014EA:  MULLW  06
014EC:  MOVF   FF3,W
014EE:  CLRF   xEF
014F0:  MOVWF  xEE
014F2:  MOVLW  04
014F4:  ADDWF  xEE,W
014F6:  MOVWF  01
014F8:  MOVLW  00
014FA:  ADDWFC xEF,W
014FC:  MOVWF  03
014FE:  MOVF   01,W
01500:  ADDLW  23
01502:  MOVWF  FE9
01504:  MOVLW  00
01506:  ADDWFC 03,W
01508:  MOVWF  FEA
0150A:  MOVFF  FEC,2E8
0150E:  MOVF   FED,F
01510:  MOVFF  FEF,2E7
....................     
....................       switch(vMedium) 
01514:  MOVF   xEB,W
01516:  XORLW  00
01518:  MOVLB  0
0151A:  BZ    151E
0151C:  BRA    156C
....................       { 
....................          #if TCP_ETH_RAM_SIZE > 0 
....................          case TCP_ETH_RAM: 
....................             ptrBaseAddress = wCurrentETHAddress; 
0151E:  MOVFF  2ED,2EA
01522:  MOVFF  2EC,2E9
....................             wCurrentETHAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1; 
01526:  MOVLW  27
01528:  MOVLB  2
0152A:  ADDWF  xE5,W
0152C:  MOVWF  xEE
0152E:  MOVLW  00
01530:  ADDWFC xE6,W
01532:  MOVWF  xEF
01534:  MOVLW  01
01536:  ADDWF  xEE,F
01538:  MOVLW  00
0153A:  ADDWFC xEF,F
0153C:  MOVF   xE7,W
0153E:  ADDWF  xEE,F
01540:  MOVF   xE8,W
01542:  ADDWFC xEF,F
01544:  MOVLW  01
01546:  ADDWF  xEE,W
01548:  MOVWF  01
0154A:  MOVLW  00
0154C:  ADDWFC xEF,W
0154E:  MOVWF  03
01550:  MOVF   01,W
01552:  ADDWF  xEC,F
01554:  MOVF   03,W
01556:  ADDWFC xED,F
....................             // Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us. 
....................             // If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in TCPIPConfig.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken. 
.................... #if defined(WF_CS_TRIS) 
....................             while(wCurrentETHAddress > TCP_ETH_RAM_BASE_ADDRESS + WFGetTCBSize()/*TCP_ETH_RAM_SIZE*/); 
.................... #else 
....................             while(wCurrentETHAddress > TCP_ETH_RAM_BASE_ADDRESS + TCP_ETH_RAM_SIZE); 
01558:  MOVF   xED,W
0155A:  SUBLW  1E
0155C:  BC    1568
0155E:  XORLW  FF
01560:  BNZ   1558
01562:  MOVF   xEC,W
01564:  SUBLW  FC
01566:  BNC   1558
.................... #endif 
....................             break; 
01568:  BRA    1570
0156A:  MOVLB  0
....................          #endif 
....................              
....................          #if TCP_PIC_RAM_SIZE > 0 
....................          case TCP_PIC_RAM: 
....................             ptrBaseAddress = ptrCurrentPICAddress; 
....................             ptrCurrentPICAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1; 
....................             // Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us. 
....................             // If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in TCPIPConfig.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken. 
....................             while(ptrCurrentPICAddress > TCP_PIC_RAM_BASE_ADDRESS + TCP_PIC_RAM_SIZE); 
....................             break; 
....................          #endif 
....................              
....................          #if TCP_SPI_RAM_SIZE > 0 
....................          case TCP_SPI_RAM: 
....................             ptrBaseAddress = wCurrentSPIAddress; 
....................             wCurrentSPIAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1; 
....................             // Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us. 
....................             // If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in TCPIPConfig.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken. 
....................             while(wCurrentSPIAddress > TCP_SPI_RAM_BASE_ADDRESS + TCP_SPI_RAM_SIZE); 
....................             break; 
....................          #endif 
....................           
....................          default: 
....................             while(1); // Undefined allocation medium.  Go fix your TCPIPConfig.h TCP memory allocations. 
0156C:  BRA    156C
0156E:  MOVLB  2
....................       } 
....................     
....................       MyTCBStub.vMemoryMedium = vMedium; 
01570:  MOVFF  2EB,133
....................       MyTCBStub.bufferTxStart   = ptrBaseAddress + sizeof(TCB); 
01574:  MOVLW  27
01576:  ADDWF  xE9,W
01578:  MOVLB  1
0157A:  MOVWF  x18
0157C:  MOVLW  00
0157E:  MOVLB  2
01580:  ADDWFC xEA,W
01582:  MOVLB  1
01584:  MOVWF  x19
....................       MyTCBStub.bufferRxStart   = MyTCBStub.bufferTxStart + wTXSize + 1; 
01586:  MOVLB  2
01588:  MOVF   xE5,W
0158A:  MOVLB  1
0158C:  ADDWF  x18,W
0158E:  MOVLB  2
01590:  MOVWF  xEE
01592:  MOVF   xE6,W
01594:  MOVLB  1
01596:  ADDWFC x19,W
01598:  MOVLB  2
0159A:  MOVWF  xEF
0159C:  MOVLW  01
0159E:  ADDWF  xEE,W
015A0:  MOVLB  1
015A2:  MOVWF  x1A
015A4:  MOVLW  00
015A6:  MOVLB  2
015A8:  ADDWFC xEF,W
015AA:  MOVLB  1
015AC:  MOVWF  x1B
....................       MyTCBStub.bufferEnd      = MyTCBStub.bufferRxStart + wRXSize; 
015AE:  MOVLB  2
015B0:  MOVF   xE7,W
015B2:  MOVLB  1
015B4:  ADDWF  x1A,W
015B6:  MOVWF  x1C
015B8:  MOVLB  2
015BA:  MOVF   xE8,W
015BC:  MOVLB  1
015BE:  ADDWFC x1B,W
015C0:  MOVWF  x1D
....................       MyTCBStub.smState      = TCP_CLOSED; 
015C2:  MOVLW  0D
015C4:  MOVWF  x2E
....................       MyTCBStub.Flags.bServer   = FALSE; 
015C6:  BCF    x2F.3
....................       #if defined(STACK_USE_SSL) 
....................       MyTCBStub.sslStubID = SSL_INVALID_ID; 
....................       #endif       
....................  
....................       SyncTCB(); 
015C8:  MOVLB  0
015CA:  RCALL  1296
....................       MyTCB.vSocketPurpose = TCPSocketInitializer[i].vSocketPurpose; 
015CC:  MOVLB  2
015CE:  MOVF   xE3,W
015D0:  MULLW  06
015D2:  MOVF   FF3,W
015D4:  CLRF   xEF
015D6:  MOVWF  xEE
015D8:  MOVLW  23
015DA:  ADDWF  xEE,W
015DC:  MOVWF  FE9
015DE:  MOVLW  00
015E0:  ADDWFC xEF,W
015E2:  MOVWF  FEA
015E4:  MOVFF  FEF,DA
....................       CloseSocket(); 
015E8:  MOVLB  0
015EA:  RCALL  136A
015EC:  MOVLB  2
015EE:  INCF   xE3,F
015F0:  BRA    1486
....................    } 
015F2:  MOVLB  0
015F4:  GOTO   2B24 (RETURN)
.................... } 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Connection Management Functions 
....................   ***************************************************************************/ 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    TCP_SOCKET TCPOpen(DWORD dwRemoteHost, BYTE vRemoteHostType, WORD wPort, BYTE vSocketPurpose) 
....................      
....................   Summary: 
....................     Opens a TCP socket for listening or as a client. 
....................  
....................   Description: 
....................     Provides a unified method for opening TCP sockets. This function can 
....................     open both client and server sockets. For client sockets, it can accept 
....................     a host name string to query in DNS, an IP address as a string, an IP 
....................     address in binary form, or a previously resolved NODE_INFO structure 
....................     containing the remote IP address and associated MAC address. When a 
....................     host name or IP address only is provided, the TCP module will 
....................     internally perform the necessary DNS and/or ARP resolution steps before 
....................     reporting that the TCP socket is connected (via a call to 
....................     TCPISConnected returning TRUE). Server sockets ignore this destination 
....................     parameter and listen only on the indicated port. 
....................      
....................     The vSocketPurpose field allows sockets to be opened with varying 
....................     buffer size parameters and memory storage mediums. This field 
....................     corresponds to pre-defined sockets allocated in the 
....................     TCPSocketInitializer[] array in TCPIPConfig.h. The TCPIPConfig.h file 
....................     can be edited using the TCP/IP Configuration Wizard. 
....................      
....................     Sockets are statically allocated on boot, but can be claimed with this 
....................     \function and freed using TCPDisconnect or TCPClose (for client 
....................     sockets). Server sockets can be freed using TCPClose only (calls to 
....................     TCPDisconnect will return server sockets to the listening state, 
....................     allowing reuse). 
....................  
....................   Conditions: 
....................     TCP is initialized. 
....................  
....................   Input: 
....................     dwRemoteHost -     For client sockets only. Provide a pointer to a 
....................                        null\-terminated string of the remote host name (ex\: 
....................                        "www.microchip.com" or "192.168.1.123"), a literal 
....................                        destination IP address (ex\: 0x7B01A8C0 or an IP_ADDR 
....................                        data type), or a pointer to a NODE_INFO structure 
....................                        with the remote IP address and remote node or gateway 
....................                        MAC address specified. If a string is provided, note 
....................                        that it must be statically allocated in memory and 
....................                        cannot be modified or deallocated until 
....................                        TCPIsConnected returns TRUE.<p />This parameter is 
....................                        ignored for server sockets. 
....................     vRemoteHostType -  Any one of the following flags to identify the 
....................                        meaning of the dwRemoteHost parameter\: 
....................                        * TCP_OPEN_SERVER &#45; Open a server socket and 
....................                          ignore the dwRemoteHost parameter. 
....................                        * TCP_OPEN_RAM_HOST &#45; Open a client socket and 
....................                          connect it to a remote host who's name is stored as a 
....................                          null terminated string in a RAM array. Ex\: 
....................                          "www.microchip.com" or "192.168.0.123" (BYTE&#42; 
....................                          type) 
....................                        * TCP_OPEN_ROM_HOST &#45; Open a client socket and 
....................                          connect it to a remote host who's name is stored as a 
....................                          null terminated string in a literal string or ROM 
....................                          array. Ex\: "www.microchip.com" or "192.168.0.123" 
....................                          (ROM BYTE&#42; type) 
....................                        * TCP_OPEN_IP_ADDRESS &#45; Open a client socket and 
....................                          connect it to a remote IP address. Ex\: 0x7B01A8C0 
....................                          for 192.168.1.123 (DWORD type). Note that the byte 
....................                          ordering is big endian. 
....................                        * TCP_OPEN_NODE_INFO &#45; Open a client socket and 
....................                          connect it to a remote IP and MAC addresses pair 
....................                          stored in a NODE_INFO structure. dwRemoteHost must be 
....................                          a pointer to the NODE_INFO structure. This option is 
....................                          provided for backwards compatibility with 
....................                          applications built against prior stack versions that 
....................                          only implemented the TCPConnect() function. It can 
....................                          also be used to skip DNS and ARP resolution steps if 
....................                          connecting to a remote node which you've already 
....................                          connected to and have cached addresses for. 
....................     wPort -            TCP port to listen on or connect to\: 
....................                        * Client sockets &#45; the remote TCP port to which a 
....................                          connection should be made. The local port for client 
....................                          sockets will be automatically picked by the TCP 
....................                          module. 
....................                        * Server sockets &#45; the local TCP port on which to 
....................                          listen for connections. 
....................     vSocketPurpose -   Any of the TCP_PURPOSE_* constants defined in 
....................                        TCPIPConfig.h or the TCPIPConfig utility (see 
....................                        TCPSocketInitializer[] array). 
....................  
....................   Return Values: 
....................     INVALID_SOCKET -  No sockets of the specified type were available to be 
....................                       opened. 
....................     Otherwise -       A TCP_SOCKET handle. Save this handle and use it when 
....................                       calling all other TCP APIs. 
....................  
....................   Remarks: 
....................     This function replaces the old TCPConnect and TCPListen functions. 
....................      
....................     If TCP_OPEN_RAM_HOST or TCP_OPEN_ROM_HOST are used for the destination 
....................     type, the DNS client module must also be enabled (STACK_USE_DNS must be 
....................     defined in TCPIPConfig.h). 
....................  
....................   Example: 
....................     \ \  
....................     <code> 
....................     // Open a server socket 
....................     skt = TCPOpen(NULL, TCP_OPEN_SERVER, HTTP_PORT, TCP_PURPOSE_HTTP_SERVER); 
....................      
....................     // Open a client socket to www.microchip.com 
....................     // The double cast here prevents compiler warnings 
....................     skt = TCPOpen((DWORD)(PTR_BASE)"www.microchip.com", 
....................                     TCP_OPEN_ROM_HOST, 80, TCP_PURPOSE_DEFAULT); 
....................      
....................     // Reopen a client socket without repeating DNS or ARP 
....................     SOCKET_INFO cache = TCPGetSocketInfo(skt);  // Call with the old socket 
....................     skt = TCPOpen((DWORD)(PTR_BASE)&amp;cache.remote, TCP_OPEN_NODE_INFO, 
....................                     cache.remotePort.Val, TCP_PURPOSE_DEFAULT); 
....................     </code>                                                     
....................   *****************************************************************************/ 
.................... TCP_SOCKET TCPOpen(DWORD dwRemoteHost, BYTE vRemoteHostType, WORD wPort, BYTE vSocketPurpose) 
.................... { 
....................    TCP_SOCKET hTCP; 
....................  
....................    // Find an available socket that matches the specified socket type 
....................    for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++) 
*
02894:  MOVLB  2
02896:  CLRF   xEE
02898:  MOVF   xEE,F
0289A:  BTFSS  FD8.2
0289C:  BRA    2A66
....................    { 
....................       SyncTCBStub(hTCP); 
0289E:  MOVFF  2EE,321
028A2:  MOVLB  0
028A4:  CALL   0CA6
....................  
....................       // Sockets that are in use will be in a non-closed state 
....................       if(MyTCBStub.smState != TCP_CLOSED) 
028A8:  MOVLB  1
028AA:  MOVF   x2E,W
028AC:  SUBLW  0D
028AE:  BZ    28B2
....................          continue; 
028B0:  BRA    2A60
....................  
....................       SyncTCB(); 
028B2:  MOVLB  0
028B4:  CALL   1296
....................  
....................       // See if this socket matches the desired type 
....................       if(MyTCB.vSocketPurpose != vSocketPurpose) 
028B8:  MOVLB  2
028BA:  MOVF   xED,W
028BC:  MOVLB  0
028BE:  SUBWF  xDA,W
028C0:  BZ    28C8
....................          continue; 
028C2:  MOVLB  1
028C4:  BRA    2A60
028C6:  MOVLB  0
....................  
....................       // Start out assuming worst case Maximum Segment Size (changes when MSS  
....................       // option is received from remote node) 
....................       MyTCB.wRemoteMSS = 536; 
028C8:  MOVLW  02
028CA:  MOVWF  xD8
028CC:  MOVLW  18
028CE:  MOVWF  xD7
....................  
....................       // See if this is a server socket 
....................       if(vRemoteHostType == TCP_OPEN_SERVER) 
028D0:  MOVLB  2
028D2:  MOVF   xEA,F
028D4:  BNZ   28F2
....................       { 
....................          MyTCB.localPort.Val = wPort; 
028D6:  MOVFF  2EC,C5
028DA:  MOVFF  2EB,C4
....................          MyTCBStub.Flags.bServer = TRUE; 
028DE:  MOVLB  1
028E0:  BSF    x2F.3
....................          MyTCBStub.smState = TCP_LISTEN; 
028E2:  MOVLW  04
028E4:  MOVWF  x2E
....................          MyTCBStub.remoteHash.Val = wPort; 
028E6:  MOVFF  2EC,132
028EA:  MOVFF  2EB,131
....................          #if defined(STACK_USE_SSL_SERVER) 
....................          MyTCB.localSSLPort.Val = 0; 
....................          #endif 
....................       } 
028EE:  BRA    2A56
028F0:  MOVLB  2
....................       // Handle all the client mode socket types 
....................       else 
....................       { 
....................          #if defined(STACK_CLIENT_MODE) 
....................          { 
....................             // Each new socket that is opened by this node, gets the  
....................             // next sequential local port number. 
....................             if(NextPort < LOCAL_PORT_START_NUMBER || NextPort > LOCAL_PORT_END_NUMBER) 
028F2:  MOVLB  0
028F4:  MOVF   x97,W
028F6:  SUBLW  03
028F8:  BC    290A
028FA:  MOVF   x97,W
028FC:  SUBLW  12
028FE:  BC    2910
02900:  XORLW  FF
02902:  BNZ   290A
02904:  MOVF   x96,W
02906:  SUBLW  88
02908:  BC    2910
....................                NextPort = LOCAL_PORT_START_NUMBER; 
0290A:  MOVLW  04
0290C:  MOVWF  x97
0290E:  CLRF   x96
....................              
....................             // Set the non-zero TCB fields 
....................             MyTCB.localPort.Val = NextPort++; 
02910:  MOVFF  97,03
02914:  MOVF   x96,W
02916:  INCF   x96,F
02918:  BTFSC  FD8.2
0291A:  INCF   x97,F
0291C:  MOVWF  xC4
0291E:  MOVFF  03,C5
....................             MyTCB.remotePort.Val = wPort; 
02922:  MOVFF  2EC,C3
02926:  MOVFF  2EB,C2
....................     
....................             // Flag to start the DNS, ARP, SYN processes 
....................             MyTCBStub.eventTime = TickGet(); 
0292A:  CALL   1630
0292E:  MOVFF  03,129
02932:  MOVFF  02,128
02936:  MOVFF  01,127
0293A:  MOVFF  00,126
....................             MyTCBStub.Flags.bTimerEnabled = 1; 
0293E:  MOVLB  1
02940:  BSF    x2F.4
....................     
....................             switch(vRemoteHostType) 
02942:  MOVLB  2
02944:  MOVF   xEA,W
02946:  XORLW  03
02948:  MOVLB  0
0294A:  BZ    2952
0294C:  XORLW  07
0294E:  BZ    29D2
02950:  BRA    2A54
....................             { 
....................                #if defined(STACK_USE_DNS) 
....................                case TCP_OPEN_RAM_HOST: 
....................                case TCP_OPEN_ROM_HOST: 
....................                   MyTCB.remote.dwRemoteHost = dwRemoteHost; 
....................                   MyTCB.flags.bRemoteHostIsROM = (vRemoteHostType == TCP_OPEN_ROM_HOST); 
....................                   MyTCBStub.smState = TCP_GET_DNS_MODULE; 
....................                   break; 
....................                #endif 
....................        
....................                case TCP_OPEN_IP_ADDRESS: 
....................                   // dwRemoteHost is a literal IP address.  This  
....................                   // doesn't need DNS and can skip directly to the  
....................                   // Gateway ARPing step. 
....................                   MyTCBStub.remoteHash.Val = (((DWORD_VAL*)&dwRemoteHost)->w[1]+((DWORD_VAL*)&dwRemoteHost)->w[0] + wPort) ^ MyTCB.localPort.Val; 
02952:  MOVLW  02
02954:  MOVLB  2
02956:  MOVWF  xF0
02958:  MOVLW  E6
0295A:  MOVWF  xEF
0295C:  MOVLW  02
0295E:  ADDWF  xEF,W
02960:  MOVWF  FE9
02962:  MOVLW  00
02964:  ADDWFC xF0,W
02966:  MOVWF  FEA
02968:  MOVFF  FEC,2F2
0296C:  MOVF   FED,F
0296E:  MOVFF  FEF,2F1
02972:  MOVLW  02
02974:  MOVWF  xF4
02976:  MOVLW  E6
02978:  MOVWF  FE9
0297A:  MOVFF  2F4,FEA
0297E:  MOVFF  FEC,03
02982:  MOVF   FED,F
02984:  MOVF   FEF,W
02986:  ADDWF  xF1,F
02988:  MOVF   03,W
0298A:  ADDWFC xF2,F
0298C:  MOVF   xEB,W
0298E:  ADDWF  xF1,F
02990:  MOVF   xEC,W
02992:  ADDWFC xF2,F
02994:  MOVF   xF1,W
02996:  MOVLB  0
02998:  XORWF  xC4,W
0299A:  MOVLB  1
0299C:  MOVWF  x31
0299E:  MOVLB  2
029A0:  MOVF   xF2,W
029A2:  MOVLB  0
029A4:  XORWF  xC5,W
029A6:  MOVLB  1
029A8:  MOVWF  x32
....................                   MyTCB.remote.niRemoteMACIP.IPAddr.Val = dwRemoteHost; 
029AA:  MOVFF  2E9,CD
029AE:  MOVFF  2E8,CC
029B2:  MOVFF  2E7,CB
029B6:  MOVFF  2E6,CA
....................                   MyTCB.retryCount = 0; 
029BA:  MOVLB  0
029BC:  CLRF   xD9
....................                   MyTCB.retryInterval = (TICK_SECOND/4)/256; 
029BE:  CLRF   xB7
029C0:  CLRF   xB6
029C2:  CLRF   xB5
029C4:  MOVLW  26
029C6:  MOVWF  xB4
....................                   MyTCBStub.smState = TCP_GATEWAY_SEND_ARP; 
029C8:  MOVLW  02
029CA:  MOVLB  1
029CC:  MOVWF  x2E
....................                   break; 
029CE:  MOVLB  0
029D0:  BRA    2A54
....................        
....................                case TCP_OPEN_NODE_INFO: 
....................                   MyTCBStub.remoteHash.Val = (((NODE_INFO*)(PTR_BASE)dwRemoteHost)->IPAddr.w[1]+((NODE_INFO*)(PTR_BASE)dwRemoteHost)->IPAddr.w[0] + wPort) ^ MyTCB.localPort.Val; 
029D2:  MOVLW  02
029D4:  MOVLB  2
029D6:  ADDWF  xE6,W
029D8:  MOVWF  FE9
029DA:  MOVLW  00
029DC:  ADDWFC xE7,W
029DE:  MOVWF  FEA
029E0:  MOVFF  FEC,2F0
029E4:  MOVF   FED,F
029E6:  MOVFF  FEF,2EF
029EA:  MOVFF  2E6,FE9
029EE:  MOVFF  2E7,FEA
029F2:  MOVFF  FEC,03
029F6:  MOVF   FED,F
029F8:  MOVF   FEF,W
029FA:  ADDWF  xEF,F
029FC:  MOVF   03,W
029FE:  ADDWFC xF0,F
02A00:  MOVF   xEB,W
02A02:  ADDWF  xEF,F
02A04:  MOVF   xEC,W
02A06:  ADDWFC xF0,F
02A08:  MOVF   xEF,W
02A0A:  MOVLB  0
02A0C:  XORWF  xC4,W
02A0E:  MOVLB  1
02A10:  MOVWF  x31
02A12:  MOVLB  2
02A14:  MOVF   xF0,W
02A16:  MOVLB  0
02A18:  XORWF  xC5,W
02A1A:  MOVLB  1
02A1C:  MOVWF  x32
....................                   memcpy((void*)(BYTE*)&MyTCB.remote, (void*)(BYTE*)(PTR_BASE)dwRemoteHost, sizeof(NODE_INFO)); 
02A1E:  MOVLB  2
02A20:  CLRF   xF0
02A22:  MOVLW  CA
02A24:  MOVFF  2F0,FEA
02A28:  MOVWF  FE9
02A2A:  MOVFF  2E7,FE2
02A2E:  MOVFF  2E6,FE1
02A32:  MOVLW  0A
02A34:  MOVWF  01
02A36:  MOVFF  FE6,FEE
02A3A:  DECFSZ 01,F
02A3C:  BRA    2A36
....................                   MyTCBStub.smState = TCP_SYN_SENT; 
02A3E:  MOVLW  05
02A40:  MOVLB  1
02A42:  MOVWF  x2E
....................                   SendTCP(SYN, SENDTCP_RESET_TIMERS); 
02A44:  MOVLW  02
02A46:  MOVLB  3
02A48:  MOVWF  x36
02A4A:  MOVLW  01
02A4C:  MOVWF  x37
02A4E:  MOVLB  0
02A50:  CALL   2238
....................                   break; 
02A54:  MOVLB  1
....................             } 
....................          }       
....................          #else 
....................          { 
....................             return INVALID_SOCKET; 
....................          }    
....................          #endif 
....................       } 
....................        
....................       return hTCP;       
02A56:  MOVLB  2
02A58:  MOVFF  2EE,01
02A5C:  BRA    2A6A
02A5E:  MOVLB  1
02A60:  MOVLB  2
02A62:  INCF   xEE,F
02A64:  BRA    2898
....................    } 
....................  
....................    // If there is no socket available, return error. 
....................    return INVALID_SOCKET; 
02A66:  MOVLW  FE
02A68:  MOVWF  01
02A6A:  MOVLB  0
02A6C:  GOTO   2AA4 (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPWasReset(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Self-clearing semaphore inidicating socket reset. 
....................  
....................   Description: 
....................    This function is a self-clearing semaphore indicating whether or not 
....................    a socket has been disconnected since the previous call.  This function 
....................    works for all possible disconnections: a call to TCPDisconnect, a FIN  
....................    from the remote node, or an acknowledgement timeout caused by the loss 
....................    of a network link.  It also returns TRUE after the first call to TCPInit. 
....................    Applications should use this function to reset their state machines. 
....................     
....................    This function was added due to the possibility of an error when relying 
....................    on TCPIsConnected returing FALSE to check for a condition requiring a 
....................    state machine reset.  If a socket is closed (due to a FIN ACK) and then 
....................    immediately reopened (due to a the arrival of a new SYN) in the same 
....................    cycle of the stack, calls to TCPIsConnected by the application will  
....................    never return FALSE even though the socket has been disconnected.  This  
....................    can cause errors for protocols such as HTTP in which a client will  
....................    immediately open a new connection upon closing of a prior one.  Relying 
....................    on this function instead allows applications to trap those conditions  
....................    and properly reset their internal state for the new connection. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Return Values: 
....................      TRUE - The socket has been disconnected since the previous call. 
....................      FALSE - The socket has not been disconnected since the previous call. 
....................   ***************************************************************************/ 
.................... BOOL TCPWasReset(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return TRUE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    if(MyTCBStub.Flags.bSocketReset) 
....................    { 
....................       MyTCBStub.Flags.bSocketReset = 0; 
....................       return TRUE; 
....................    }    
....................     
....................    return FALSE; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPIsConnected(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines if a socket has an established connection. 
....................  
....................   Description: 
....................    This function determines if a socket has an established connection to  
....................    a remote node.  Call this function after calling TCPOpen to determine  
....................    when the connection is set up and ready for use.  This function was  
....................    historically used to check for disconnections, but TCPWasReset is now a 
....................    more appropriate solution.  
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Return Values: 
....................      TRUE - The socket has an established connection to a remote node. 
....................      FALSE - The socket is not currently connected. 
....................  
....................   Remarks: 
....................    A socket is said to be connected only if it is in the TCP_ESTABLISHED 
....................    state.  Sockets in the process of opening or closing will return FALSE. 
....................   ***************************************************************************/ 
.................... BOOL TCPIsConnected(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
05DC8:  MOVLB  2
05DCA:  MOVF   xEB,W
05DCC:  SUBLW  00
05DCE:  BC    5DD6
....................     { 
....................         return FALSE; 
05DD0:  MOVLW  00
05DD2:  MOVWF  01
05DD4:  BRA    5DF2
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
05DD6:  MOVFF  2EB,321
05DDA:  MOVLB  0
05DDC:  CALL   0CA6
....................    return (MyTCBStub.smState == TCP_ESTABLISHED); 
05DE0:  MOVLB  1
05DE2:  MOVF   x2E,W
05DE4:  SUBLW  07
05DE6:  BZ    5DEC
05DE8:  MOVLW  00
05DEA:  BRA    5DEE
05DEC:  MOVLW  01
05DEE:  MOVWF  01
05DF0:  MOVLB  2
05DF2:  MOVLB  0
05DF4:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPDisconnect(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Disconnects an open socket. 
....................  
....................   Description: 
....................    This function closes a connection to a remote node by sending a FIN (if  
....................    currently connected). 
....................     
....................    The function can be called a second time to force a socket closed by  
....................    sending a RST packet.  This is useful when the application knows that  
....................    the remote node will not send an ACK (if it has crashed or lost its link), 
....................    or when the application needs to reuse the socket immediately regardless 
....................    of whether or not the remote node would like to transmit more data before 
....................    closing. 
....................     
....................    For client mode sockets, upon return, the hTCP handle is relinquished to  
....................    the TCP/IP stack and must no longer be used by the application (except for  
....................    an immediate subsequent call to TCPDisconnect() to force a RST  
....................    transmission, if needed).   
....................     
....................    For server mode sockets, upon return, the hTCP handle is NOT relinquished  
....................    to the TCP/IP stack.  After closing, the socket returns to the listening  
....................    state allowing future connection requests to be serviced.  This leaves the  
....................    hTCP handle in a valid state and must be retained for future operations on  
....................    the socket.  If you want to close the server and relinquish the socket back  
....................    to the TCP/IP stack, call the TCPClose() API instead of TCPDisconnect(). 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    hTCP - Handle of the socket to disconnect. 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    If the socket is using SSL, a CLOSE_NOTIFY record will be transmitted 
....................    first to allow the SSL session to be resumed at a later time. 
....................   ***************************************************************************/ 
.................... void TCPDisconnect(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
02B72:  MOVLB  2
02B74:  MOVF   xF0,W
02B76:  SUBLW  00
02B78:  BC    2B7C
....................     { 
....................         return; 
02B7A:  BRA    2C6E
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
02B7C:  MOVFF  2F0,321
02B80:  MOVLB  0
02B82:  CALL   0CA6
....................  
....................    // Delete all data in the RX FIFO 
....................    // In this stack's API, the application TCP handle is  
....................    // immediately invalid after calling this function, so there  
....................    // is no longer any way to receive data from the TCP RX FIFO,  
....................    // even though the data is still there.  Leaving the data there  
....................    // could interfere with the remote node sending us a FIN if our 
....................    // RX window is zero 
....................    MyTCBStub.rxTail = MyTCBStub.rxHead; 
02B86:  MOVFF  123,125
02B8A:  MOVFF  122,124
....................  
....................    switch(MyTCBStub.smState) 
02B8E:  MOVLB  1
02B90:  MOVF   x2E,W
02B92:  XORLW  00
02B94:  MOVLB  0
02B96:  BZ    2BC2
02B98:  XORLW  02
02B9A:  BZ    2BC2
02B9C:  XORLW  01
02B9E:  BZ    2BC2
02BA0:  XORLW  06
02BA2:  BZ    2BC2
02BA4:  XORLW  03
02BA6:  BZ    2BC8
02BA8:  XORLW  01
02BAA:  BZ    2BC8
02BAC:  XORLW  0C
02BAE:  BZ    2C0C
02BB0:  XORLW  05
02BB2:  BZ    2C50
02BB4:  XORLW  06
02BB6:  BZ    2C5A
02BB8:  XORLW  01
02BBA:  BZ    2C5A
02BBC:  XORLW  05
02BBE:  BZ    2C5A
02BC0:  BRA    2C5A
....................    { 
....................       #if defined(STACK_CLIENT_MODE) && defined(STACK_USE_DNS) 
....................       case TCP_DNS_RESOLVE: 
....................          DNSEndUsage();   // Release the DNS module, since the user is aborting 
....................          CloseSocket(); 
....................          break; 
....................       #endif 
....................  
....................       case TCP_GET_DNS_MODULE: 
....................       case TCP_GATEWAY_SEND_ARP: 
....................       case TCP_GATEWAY_GET_ARP: 
....................       case TCP_SYN_SENT: 
....................          CloseSocket(); 
02BC2:  CALL   136A
....................          break; 
02BC6:  BRA    2C6C
....................  
....................       case TCP_SYN_RECEIVED: 
....................       case TCP_ESTABLISHED: 
....................          #if defined(STACK_USE_SSL) 
....................          // When disconnecting SSL sockets, send a close_notify so we can resume later 
....................          if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................          { 
....................             // Flush pending data and send close_notify 
....................             SSLTxRecord(hTCP, MyTCBStub.sslStubID, SSL_APPLICATION); 
....................             SSLTxMessage(hTCP, MyTCBStub.sslStubID, SSL_ALERT_CLOSE_NOTIFY); 
....................          } 
....................          #endif 
....................  
....................          // Send the FIN.  This is done in a loop to ensure that if we have  
....................          // more data wating in the TX FIFO than can be sent in a single  
....................          // packet (due to the remote Max Segment Size packet size limit),  
....................          // we will keep generating more packets until either all data gets  
....................          // transmitted or the remote node's receive window fills up. 
....................          do 
....................          { 
....................             SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS); 
02BC8:  MOVLW  11
02BCA:  MOVLB  3
02BCC:  MOVWF  x36
02BCE:  MOVLW  01
02BD0:  MOVWF  x37
02BD2:  MOVLB  0
02BD4:  CALL   2238
....................             if(MyTCB.remoteWindow == 0u) 
02BD8:  MOVF   xC6,F
02BDA:  BNZ   2BE2
02BDC:  MOVF   xC7,F
02BDE:  BNZ   2BE2
....................                break; 
02BE0:  BRA    2C02
....................          } while(MyTCBStub.txHead != MyTCB.txUnackedTail); 
02BE2:  MOVF   xC0,W
02BE4:  MOVLB  1
02BE6:  SUBWF  x1E,W
02BE8:  BTFSC  FD8.2
02BEA:  BRA    2BF0
02BEC:  MOVLB  0
02BEE:  BRA    2BC8
02BF0:  MOVLB  0
02BF2:  MOVF   xC1,W
02BF4:  MOVLB  1
02BF6:  SUBWF  x1F,W
02BF8:  BTFSC  FD8.2
02BFA:  BRA    2C00
02BFC:  MOVLB  0
02BFE:  BRA    2BC8
02C00:  MOVLB  0
....................           
....................          MyTCBStub.smState = TCP_FIN_WAIT_1; 
02C02:  MOVLW  08
02C04:  MOVLB  1
02C06:  MOVWF  x2E
....................          break; 
02C08:  MOVLB  0
02C0A:  BRA    2C6C
....................  
....................       case TCP_CLOSE_WAIT: 
....................          // Send the FIN.  This is done in a loop to ensure that if we have  
....................          // more data wating in the TX FIFO than can be sent in a single  
....................          // packet (due to the remote Max Segment Size packet size limit),  
....................          // we will keep generating more packets until either all data gets  
....................          // transmitted or the remote node's receive window fills up. 
....................          do 
....................          { 
....................             SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS); 
02C0C:  MOVLW  11
02C0E:  MOVLB  3
02C10:  MOVWF  x36
02C12:  MOVLW  01
02C14:  MOVWF  x37
02C16:  MOVLB  0
02C18:  CALL   2238
....................             if(MyTCB.remoteWindow == 0u) 
02C1C:  MOVF   xC6,F
02C1E:  BNZ   2C26
02C20:  MOVF   xC7,F
02C22:  BNZ   2C26
....................                break; 
02C24:  BRA    2C46
....................          } while(MyTCBStub.txHead != MyTCB.txUnackedTail); 
02C26:  MOVF   xC0,W
02C28:  MOVLB  1
02C2A:  SUBWF  x1E,W
02C2C:  BTFSC  FD8.2
02C2E:  BRA    2C34
02C30:  MOVLB  0
02C32:  BRA    2C0C
02C34:  MOVLB  0
02C36:  MOVF   xC1,W
02C38:  MOVLB  1
02C3A:  SUBWF  x1F,W
02C3C:  BTFSC  FD8.2
02C3E:  BRA    2C44
02C40:  MOVLB  0
02C42:  BRA    2C0C
02C44:  MOVLB  0
....................  
....................          MyTCBStub.smState = TCP_LAST_ACK; 
02C46:  MOVLW  0C
02C48:  MOVLB  1
02C4A:  MOVWF  x2E
....................          break; 
02C4C:  MOVLB  0
02C4E:  BRA    2C6C
....................           
....................       // These states are all already closed or don't need explicit disconnecting -- they will disconnect by themselves after a while 
....................       //case TCP_CLOSED: 
....................       //case TCP_LISTEN: 
....................       //case TCP_CLOSING: 
....................       //case TCP_TIME_WAIT: 
....................       //   return; 
....................  
....................       case TCP_CLOSED_BUT_RESERVED: 
....................          MyTCBStub.smState = TCP_CLOSED; 
02C50:  MOVLW  0D
02C52:  MOVLB  1
02C54:  MOVWF  x2E
....................          break; 
02C56:  MOVLB  0
02C58:  BRA    2C6C
....................  
....................       // These states will close themselves after some delay, however,  
....................       // this is handled so that the user can call TCPDisconnect()  
....................       // twice to immediately close a socket (using an RST) without  
....................       // having to get an ACK back from the remote node.  This is  
....................       // great for instance when the application determines that  
....................       // the remote node has been physically disconnected and  
....................       // already knows that no ACK will be returned.  Alternatively,  
....................       // if the application needs to immediately reuse the socket  
....................       // regardless of what the other node's state is in (half open). 
....................       case TCP_FIN_WAIT_1: 
....................       case TCP_FIN_WAIT_2: 
....................       case TCP_LAST_ACK: 
....................       default: 
....................          SendTCP(RST | ACK, 0); 
02C5A:  MOVLW  14
02C5C:  MOVLB  3
02C5E:  MOVWF  x36
02C60:  CLRF   x37
02C62:  MOVLB  0
02C64:  CALL   2238
....................          CloseSocket(); 
02C68:  CALL   136A
....................          break; 
02C6C:  MOVLB  2
....................    } 
02C6E:  MOVLB  0
02C70:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPClose(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Disconnects an open socket and destroys the socket handle, including server  
....................    mode socket handles. 
....................  
....................   Description: 
....................    Disconnects an open socket and destroys the socket handle, including server  
....................    mode socket handles.  This function performs identically to the  
....................    TCPDisconnect() function, except that both client and server mode socket  
....................    handles are relinquished to the TCP/IP stack upon return. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    hTCP - Handle to the socket to disconnect and close. 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... void TCPClose(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    MyTCBStub.Flags.bServer = FALSE; 
....................    TCPDisconnect(hTCP); 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    SOCKET_INFO* TCPGetRemoteInfo(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Obtains information about a currently open socket. 
....................  
....................   Description: 
....................    Returns the SOCKET_INFO structure associated with this socket.  This  
....................    contains the NODE_INFO structure with IP and MAC address (or gateway 
....................    MAC) and the remote port. 
....................  
....................   Precondition: 
....................    TCP is initialized and the socket is connected. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    The SOCKET_INFO structure associated with this socket.  This structure is  
....................    allocated statically by the function and is valid only until the next  
....................    time TCPGetRemoteInfo() is called. 
....................   ***************************************************************************/ 
.................... SOCKET_INFO* TCPGetRemoteInfo(TCP_SOCKET hTCP) 
.................... { 
....................    static SOCKET_INFO   RemoteInfo; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    SyncTCB(); 
....................    memcpy((void*)&RemoteInfo.remote, (void*)&MyTCB.remote, sizeof(NODE_INFO)); 
....................    RemoteInfo.remotePort.Val = MyTCB.remotePort.Val; 
....................  
....................    return &RemoteInfo; 
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Transmit Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPFlush(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Immediately transmits all pending TX data. 
....................  
....................   Description: 
....................    This function immediately transmits all pending TX data with a PSH  
....................    flag.  If this function is not called, data will automatically be sent 
....................    when either a) the TX buffer is half full or b) the  
....................    TCP_AUTO_TRANSMIT_TIMEOUT_VAL (default: 40ms) has elapsed. 
....................  
....................   Precondition: 
....................    TCP is initialized and the socket is connected. 
....................  
....................   Parameters: 
....................    hTCP - The socket whose data is to be transmitted. 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    SSL application data is automatically flushed, so this function has  
....................    no effect for SSL sockets. 
....................   ***************************************************************************/ 
.................... void TCPFlush(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
07736:  MOVLB  3
07738:  MOVF   x1F,W
0773A:  SUBLW  00
0773C:  BC    7740
....................     { 
....................         return; 
0773E:  BRA    7774
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
07740:  MOVFF  31F,321
07744:  MOVLB  0
07746:  CALL   0CA6
....................    SyncTCB(); 
0774A:  CALL   1296
....................  
....................    // NOTE: Pending SSL data will NOT be transferred here 
....................  
....................    if(MyTCBStub.txHead != MyTCB.txUnackedTail) 
0774E:  MOVF   xC0,W
07750:  MOVLB  1
07752:  SUBWF  x1E,W
07754:  BNZ   7760
07756:  MOVLB  0
07758:  MOVF   xC1,W
0775A:  MOVLB  1
0775C:  SUBWF  x1F,W
0775E:  BZ    7772
....................    { 
....................       // Send the TCP segment with all unacked bytes 
....................       SendTCP(ACK, SENDTCP_RESET_TIMERS); 
07760:  MOVLW  10
07762:  MOVLB  3
07764:  MOVWF  x36
07766:  MOVLW  01
07768:  MOVWF  x37
0776A:  MOVLB  0
0776C:  CALL   2238
07770:  MOVLB  1
07772:  MOVLB  3
....................    } 
07774:  MOVLB  0
07776:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPIsPutReady(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines how much free space is available in the TCP TX buffer. 
....................  
....................   Description: 
....................    Call this function to determine how many bytes can be written to the  
....................    TCP TX buffer.  If this function returns zero, the application must  
....................    return to the main stack loop before continuing in order to transmit 
....................    more data. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    The number of bytes available to be written in the TCP TX buffer. 
....................   ***************************************************************************/ 
.................... WORD TCPIsPutReady(TCP_SOCKET hTCP) 
.................... { 
....................    BYTE i; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
07680:  MOVLB  3
07682:  MOVF   x1F,W
07684:  SUBLW  00
07686:  BC    7690
....................     { 
....................         return 0; 
07688:  MOVLW  00
0768A:  MOVWF  01
0768C:  MOVWF  02
0768E:  BRA    772A
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
07690:  MOVFF  31F,321
07694:  MOVLB  0
07696:  CALL   0CA6
....................  
....................    i = MyTCBStub.smState; 
0769A:  MOVFF  12E,320
....................  
....................    // Unconnected sockets shouldn't be transmitting anything. 
....................    if(!( (i == (BYTE)TCP_ESTABLISHED) || (i == (BYTE)TCP_CLOSE_WAIT) )) 
0769E:  MOVLB  3
076A0:  MOVF   x20,W
076A2:  SUBLW  07
076A4:  BZ    76B4
076A6:  MOVF   x20,W
076A8:  SUBLW  0B
076AA:  BZ    76B4
....................       return 0; 
076AC:  MOVLW  00
076AE:  MOVWF  01
076B0:  MOVWF  02
076B2:  BRA    772A
....................  
....................    // Calculate the free space in this socket's TX FIFO 
....................    #if defined(STACK_USE_SSL) 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    {// Use sslTxHead as the head pointer when SSL is active 
....................       WORD rem; 
....................        
....................       // Find out raw free space 
....................       if(MyTCBStub.sslTxHead >= MyTCBStub.txTail) 
....................          rem = (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.sslTxHead - MyTCBStub.txTail); 
....................       else 
....................          rem = MyTCBStub.txTail - MyTCBStub.sslTxHead - 1; 
....................           
....................       // Reserve space for a new MAC and header 
....................       if(rem > 22u) 
....................          return rem - 22; 
....................       else 
....................          return 0; 
....................    } 
....................    #endif 
....................     
....................    if(MyTCBStub.txHead >= MyTCBStub.txTail) 
076B4:  MOVLB  1
076B6:  MOVF   x21,W
076B8:  SUBWF  x1F,W
076BA:  BNC   7706
076BC:  BNZ   76C4
076BE:  MOVF   x20,W
076C0:  SUBWF  x1E,W
076C2:  BNC   7706
....................       return (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.txHead - MyTCBStub.txTail); 
076C4:  MOVF   x18,W
076C6:  SUBWF  x1A,W
076C8:  MOVLB  3
076CA:  MOVWF  x21
076CC:  MOVLB  1
076CE:  MOVF   x19,W
076D0:  SUBWFB x1B,W
076D2:  MOVLB  3
076D4:  MOVWF  x22
076D6:  MOVLW  01
076D8:  SUBWF  x21,F
076DA:  MOVLW  00
076DC:  SUBWFB x22,F
076DE:  MOVLB  1
076E0:  MOVF   x20,W
076E2:  SUBWF  x1E,W
076E4:  MOVWF  00
076E6:  MOVF   x21,W
076E8:  SUBWFB x1F,W
076EA:  MOVWF  03
076EC:  MOVF   00,W
076EE:  MOVLB  3
076F0:  SUBWF  x21,W
076F2:  MOVWF  00
076F4:  MOVF   03,W
076F6:  SUBWFB x22,W
076F8:  MOVWF  03
076FA:  MOVFF  00,01
076FE:  MOVWF  02
07700:  BRA    772A
07702:  BRA    772A
07704:  MOVLB  1
....................    else 
....................       return MyTCBStub.txTail - MyTCBStub.txHead - 1; 
07706:  MOVF   x1E,W
07708:  SUBWF  x20,W
0770A:  MOVLB  3
0770C:  MOVWF  x21
0770E:  MOVLB  1
07710:  MOVF   x1F,W
07712:  SUBWFB x21,W
07714:  MOVLB  3
07716:  MOVWF  x22
07718:  MOVLW  01
0771A:  SUBWF  x21,W
0771C:  MOVWF  00
0771E:  MOVLW  00
07720:  SUBWFB x22,W
07722:  MOVWF  03
07724:  MOVFF  00,01
07728:  MOVWF  02
0772A:  MOVLB  0
0772C:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPPut(TCP_SOCKET hTCP, BYTE byte) 
....................  
....................   Description: 
....................    Writes a single byte to a TCP socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    byte - The byte to write. 
....................  
....................   Return Values: 
....................    TRUE - The byte was written to the transmit buffer. 
....................    FALSE - The transmit buffer was full, or the socket is not connected. 
....................   ***************************************************************************/ 
.................... BOOL TCPPut(TCP_SOCKET hTCP, BYTE byte) 
.................... { 
....................    WORD wFreeTXSpace; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
07778:  MOVLB  3
0777A:  MOVF   x1B,W
0777C:  SUBLW  00
0777E:  BC    7786
....................     { 
....................         return 0; 
07780:  MOVLW  00
07782:  MOVWF  01
07784:  BRA    7892
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
07786:  MOVFF  31B,321
0778A:  MOVLB  0
0778C:  CALL   0CA6
....................  
....................    wFreeTXSpace = TCPIsPutReady(hTCP); 
07790:  MOVFF  31B,31F
07794:  RCALL  7680
07796:  MOVFF  02,31E
0779A:  MOVFF  01,31D
....................    if(wFreeTXSpace == 0u) 
0779E:  MOVLB  3
077A0:  MOVF   x1D,F
077A2:  BNZ   77B0
077A4:  MOVF   x1E,F
077A6:  BNZ   77B0
....................       return FALSE; 
077A8:  MOVLW  00
077AA:  MOVWF  01
077AC:  BRA    7892
077AE:  BRA    77C2
....................    else if(wFreeTXSpace == 1u) // About to run out of space, lets transmit so the remote node might send an ACK back faster 
077B0:  DECFSZ x1D,W
077B2:  BRA    77C2
077B4:  MOVF   x1E,F
077B6:  BNZ   77C2
....................       TCPFlush(hTCP);    
077B8:  MOVFF  31B,31F
077BC:  MOVLB  0
077BE:  RCALL  7736
077C0:  MOVLB  3
....................  
....................    // Send all current bytes if we are crossing half full 
....................    // This is required to improve performance with the delayed  
....................    // acknowledgement algorithm 
....................    if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1))) 
077C2:  MOVLB  1
077C4:  BTFSC  x30.0
077C6:  BRA    780C
077C8:  MOVF   x18,W
077CA:  SUBWF  x1A,W
077CC:  MOVLB  3
077CE:  MOVWF  x1F
077D0:  MOVLB  1
077D2:  MOVF   x19,W
077D4:  SUBWFB x1B,W
077D6:  MOVLB  3
077D8:  MOVWF  x20
077DA:  BCF    FD8.0
077DC:  RRCF   x20,W
077DE:  MOVWF  03
077E0:  RRCF   x1F,W
077E2:  MOVWF  02
077E4:  MOVWF  01
077E6:  MOVF   x1E,W
077E8:  SUBWF  03,W
077EA:  BTFSC  FD8.0
077EC:  BRA    77F2
077EE:  MOVLB  1
077F0:  BRA    780C
077F2:  BNZ   7800
077F4:  MOVF   x1D,W
077F6:  SUBWF  01,W
077F8:  BTFSC  FD8.0
077FA:  BRA    7800
077FC:  MOVLB  1
077FE:  BRA    780C
....................    { 
....................       TCPFlush(hTCP);    
07800:  MOVFF  31B,31F
07804:  MOVLB  0
07806:  RCALL  7736
....................       MyTCBStub.Flags.bHalfFullFlush = TRUE; 
07808:  MOVLB  1
0780A:  BSF    x30.0
....................    } 
....................  
....................    #if defined(STACK_USE_SSL) 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    { 
....................       TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte)); 
....................       if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    else 
....................    { 
....................       TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte)); 
....................       if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    #else 
....................    TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte)); 
0780C:  MOVLW  03
0780E:  MOVLB  3
07810:  MOVWF  x20
07812:  MOVLW  1C
07814:  MOVWF  x1F
07816:  MOVFF  11F,368
0781A:  MOVFF  11E,367
0781E:  MOVFF  133,369
07822:  MOVFF  320,36B
07826:  MOVWF  x6A
07828:  MOVLW  01
0782A:  MOVWF  x6C
0782C:  CLRF   x6E
0782E:  MOVWF  x6D
07830:  MOVLB  0
07832:  CALL   11B0
....................    if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart) 
07836:  MOVLB  1
07838:  INCF   x1E,F
0783A:  BTFSC  FD8.2
0783C:  INCF   x1F,F
0783E:  MOVF   x1B,W
07840:  SUBWF  x1F,W
07842:  BNC   7854
07844:  BNZ   784C
07846:  MOVF   x1A,W
07848:  SUBWF  x1E,W
0784A:  BNC   7854
....................       MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
0784C:  MOVFF  119,11F
07850:  MOVFF  118,11E
....................    #endif 
....................     
....................  
....................    // Send the last byte as a separate packet (likely will make the remote node send back ACK faster) 
....................    if(wFreeTXSpace == 1u) 
07854:  MOVLB  3
07856:  DECFSZ x1D,W
07858:  BRA    7868
0785A:  MOVF   x1E,F
0785C:  BNZ   7868
....................    { 
....................       TCPFlush(hTCP); 
0785E:  MOVFF  31B,31F
07862:  MOVLB  0
07864:  RCALL  7736
....................    } 
07866:  BRA    788C
....................    // If not already enabled, start a timer so this data will  
....................    // eventually get sent even if the application doens't call 
....................    // TCPFlush() 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
07868:  MOVLB  1
0786A:  BTFSC  x2F.5
0786C:  BRA    788A
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
0786E:  BSF    x2F.5
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull; 
07870:  MOVLB  0
07872:  CALL   2B2A
07876:  MOVLW  06
07878:  MOVLB  3
0787A:  ADDWF  00,W
0787C:  MOVLB  1
0787E:  MOVWF  x2A
07880:  MOVLW  00
07882:  MOVLB  3
07884:  ADDWFC 01,W
07886:  MOVLB  1
07888:  MOVWF  x2B
0788A:  MOVLB  0
....................    } 
....................  
....................    return TRUE; 
0788C:  MOVLW  01
0788E:  MOVWF  01
07890:  MOVLB  3
07892:  MOVLB  0
07894:  GOTO   78A2 (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPPutArray(TCP_SOCKET hTCP, BYTE* data, WORD len) 
....................  
....................   Description: 
....................    Writes an array from RAM to a TCP socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    data - Pointer to the array to be written. 
....................    len  - Number of bytes to be written. 
....................  
....................   Returns: 
....................    The number of bytes written to the socket.  If less than len, the 
....................    buffer became full or the socket is not conected. 
....................   ***************************************************************************/ 
.................... WORD TCPPutArray(TCP_SOCKET hTCP, BYTE* data, WORD len) 
.................... { 
....................    WORD wActualLen; 
....................    WORD wFreeTXSpace; 
....................    WORD wRightLen = 0; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    wFreeTXSpace = TCPIsPutReady(hTCP); 
....................    if(wFreeTXSpace == 0u) 
....................    { 
....................       TCPFlush(hTCP); 
....................       return 0; 
....................    } 
....................  
....................    wActualLen = wFreeTXSpace; 
....................    if(wFreeTXSpace > len) 
....................       wActualLen = len; 
....................  
....................    // Send all current bytes if we are crossing half full 
....................    // This is required to improve performance with the delayed  
....................    // acknowledgement algorithm 
....................    if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1))) 
....................    { 
....................       TCPFlush(hTCP);    
....................       MyTCBStub.Flags.bHalfFullFlush = TRUE; 
....................    } 
....................     
....................    #if defined(STACK_USE_SSL) 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    { 
....................       // See if we need a two part put 
....................       if(MyTCBStub.sslTxHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................       { 
....................          wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead; 
....................          TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen); 
....................          data += wRightLen; 
....................          wActualLen -= wRightLen; 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................       } 
....................     
....................       TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen); 
....................       MyTCBStub.sslTxHead += wActualLen; 
....................    } 
....................    else 
....................    { 
....................       // See if we need a two part put 
....................       if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................       { 
....................          wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead; 
....................          TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen); 
....................          data += wRightLen; 
....................          wActualLen -= wRightLen; 
....................          MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................       } 
....................     
....................       TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen); 
....................       MyTCBStub.txHead += wActualLen; 
....................    } 
....................    #else 
....................    // See if we need a two part put 
....................    if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................    { 
....................       wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead; 
....................       TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen); 
....................       data += wRightLen; 
....................       wActualLen -= wRightLen; 
....................       MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................    } 
....................  
....................    TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen); 
....................    MyTCBStub.txHead += wActualLen; 
....................    #endif 
....................  
....................    // Send these bytes right now if we are out of TX buffer space 
....................    if(wFreeTXSpace <= len) 
....................    { 
....................       TCPFlush(hTCP); 
....................    } 
....................    // If not already enabled, start a timer so this data will  
....................    // eventually get sent even if the application doens't call 
....................    // TCPFlush() 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull; 
....................    } 
....................  
....................    return wActualLen + wRightLen; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPPutROMArray(TCP_SOCKET hTCP, ROM BYTE* data, WORD len) 
....................  
....................   Description: 
....................    Writes an array from ROM to a TCP socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    data - Pointer to the array to be written. 
....................    len  - Number of bytes to be written. 
....................  
....................   Returns: 
....................    The number of bytes written to the socket.  If less than len, the 
....................    buffer became full or the socket is not conected. 
....................  
....................   Remarks: 
....................    This function is aliased to TCPPutArray on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... WORD TCPPutROMArray(TCP_SOCKET hTCP, ROM BYTE* data, WORD len) 
.................... { 
....................    WORD wActualLen; 
....................    WORD wFreeTXSpace; 
....................    WORD wRightLen = 0; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    wFreeTXSpace = TCPIsPutReady(hTCP); 
....................    if(wFreeTXSpace == 0u) 
....................    { 
....................       TCPFlush(hTCP); 
....................       return 0; 
....................    } 
....................  
....................    // Send all current bytes if we are crossing half full 
....................    // This is required to improve performance with the delayed  
....................    // acknowledgement algorithm 
....................    if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1))) 
....................    { 
....................       TCPFlush(hTCP);    
....................       MyTCBStub.Flags.bHalfFullFlush = TRUE; 
....................    } 
....................     
....................    wActualLen = wFreeTXSpace; 
....................    if(wFreeTXSpace > len) 
....................       wActualLen = len; 
....................     
....................    #if defined(STACK_USE_SSL) 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    { 
....................       // See if we need a two part put 
....................       if(MyTCBStub.sslTxHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................       { 
....................          wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead; 
....................          TCPRAMCopyROM(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, data, wRightLen); 
....................          data += wRightLen; 
....................          wActualLen -= wRightLen; 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................       } 
....................     
....................       TCPRAMCopyROM(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, data, wActualLen); 
....................       MyTCBStub.sslTxHead += wActualLen; 
....................    } 
....................    else 
....................    { 
....................       // See if we need a two part put 
....................       if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................       { 
....................          wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead; 
....................          TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wRightLen); 
....................          data += wRightLen; 
....................          wActualLen -= wRightLen; 
....................          MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................       } 
....................     
....................       TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wActualLen); 
....................       MyTCBStub.txHead += wActualLen; 
....................    } 
....................    #else 
....................    // See if we need a two part put 
....................    if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................    { 
....................       wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead; 
....................       TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wRightLen); 
....................       data += wRightLen; 
....................       wActualLen -= wRightLen; 
....................       MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................    } 
....................  
....................    TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wActualLen); 
....................    MyTCBStub.txHead += wActualLen; 
....................    #endif 
....................  
....................    // Send these bytes right now if we are out of TX buffer space 
....................    if(wFreeTXSpace <= len) 
....................    { 
....................       TCPFlush(hTCP); 
....................    } 
....................    // If not already enabled, start a timer so this data will  
....................    // eventually get sent even if the application doens't call 
....................    // TCPFlush() 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull; 
....................    } 
....................  
....................    return wActualLen + wRightLen; 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE* TCPPutString(TCP_SOCKET hTCP, BYTE* data) 
....................  
....................   Description: 
....................    Writes a null-terminated string from RAM to a TCP socket.  The  
....................    null-terminator is not copied to the socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    data - Pointer to the string to be written. 
....................  
....................   Returns: 
....................    Pointer to the byte following the last byte written to the socket.  If 
....................    this pointer does not dereference to a NUL byte, the buffer became full 
....................    or the socket is not connected. 
....................  
....................   Remarks: 
....................    The return value of this function differs from that of TCPPutArray.  To 
....................    write long strings in a single state, initialize the *data pointer to the 
....................    first byte, then call this function repeatedly (breaking to the main  
....................    stack loop after each call) until the return value dereferences to a NUL 
....................    byte.  Save the return value as the new starting *data pointer otherwise. 
....................   ***************************************************************************/ 
.................... BYTE* TCPPutString(TCP_SOCKET hTCP, BYTE* data) 
.................... { 
....................    return data + TCPPutArray(hTCP, data, strlen((char*)data)); 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE* TCPPutROMString(TCP_SOCKET hTCP, ROM BYTE* data) 
....................  
....................   Description: 
....................    Writes a null-terminated string from ROM to a TCP socket.  The  
....................    null-terminator is not copied to the socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    data - Pointer to the string to be written. 
....................  
....................   Returns: 
....................    Pointer to the byte following the last byte written to the socket.  If 
....................    this pointer does not dereference to a NUL byte, the buffer became full 
....................    or the socket is not connected. 
....................  
....................   Remarks: 
....................    The return value of this function differs from that of TCPPutArray.  To 
....................    write long strings in a single state, initialize the *data pointer to the 
....................    first byte, then call this function repeatedly (breaking to the main  
....................    stack loop after each call) until the return value dereferences to a NUL 
....................    byte.  Save the return value as the new starting *data pointer otherwise. 
....................     
....................    This function is aliased to TCPPutString on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... ROM BYTE* TCPPutROMString(TCP_SOCKET hTCP, ROM BYTE* data) 
.................... { 
....................    return data + TCPPutROMArray(hTCP, data, strlenpgm((ROM char*)data)); 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPGetTxFIFOFull(TCP_SOCKET hTCP) 
....................  
....................   Description: 
....................    Determines how many bytes are pending in the TCP TX FIFO. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    Number of bytes pending to be flushed in the TCP TX FIFO. 
....................   ***************************************************************************/ 
.................... WORD TCPGetTxFIFOFull(TCP_SOCKET hTCP) 
.................... { 
....................    WORD wDataLen; 
....................    WORD wFIFOSize; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
083CA:  MOVLB  2
083CC:  MOVF   xEB,W
083CE:  SUBLW  00
083D0:  BC    83DA
....................     { 
....................         return 0; 
083D2:  MOVLW  00
083D4:  MOVWF  01
083D6:  MOVWF  02
083D8:  BRA    842A
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
083DA:  MOVFF  2EB,321
083DE:  MOVLB  0
083E0:  CALL   0CA6
....................  
....................    // Calculate total usable FIFO size 
....................    wFIFOSize = MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1; 
083E4:  MOVLB  1
083E6:  MOVF   x18,W
083E8:  SUBWF  x1A,W
083EA:  MOVLB  2
083EC:  MOVWF  xF0
083EE:  MOVLB  1
083F0:  MOVF   x19,W
083F2:  SUBWFB x1B,W
083F4:  MOVLB  2
083F6:  MOVWF  xF1
083F8:  MOVLW  01
083FA:  SUBWF  xF0,W
083FC:  MOVWF  xEE
083FE:  MOVLW  00
08400:  SUBWFB xF1,W
08402:  MOVWF  xEF
....................  
....................    // Find out how many data bytes are free in the TX FIFO 
....................    wDataLen = TCPIsPutReady(hTCP); 
08404:  MOVFF  2EB,31F
08408:  MOVLB  0
0840A:  CALL   7680
0840E:  MOVFF  02,2ED
08412:  MOVFF  01,2EC
....................  
....................    return wFIFOSize - wDataLen; 
08416:  MOVLB  2
08418:  MOVF   xEC,W
0841A:  SUBWF  xEE,W
0841C:  MOVWF  00
0841E:  MOVF   xED,W
08420:  SUBWFB xEF,W
08422:  MOVWF  03
08424:  MOVFF  00,01
08428:  MOVWF  02
0842A:  MOVLB  0
0842C:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Receive Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPDiscard(TCP_SOCKET hTCP) 
....................  
....................   Description: 
....................    Discards any pending data in the TCP RX FIFO. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket whose RX FIFO is to be cleared. 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... void TCPDiscard(TCP_SOCKET hTCP) 
.................... { 
....................    if(TCPIsGetReady(hTCP)) 
*
07650:  MOVFF  2EB,2F0
07654:  CALL   5DF6
07658:  MOVF   01,W
0765A:  IORWF  02,W
0765C:  BZ    767E
....................    { 
....................       SyncTCBStub(hTCP); 
0765E:  MOVFF  2EB,321
07662:  CALL   0CA6
....................     
....................       // Delete all data in the RX buffer 
....................       MyTCBStub.rxTail = MyTCBStub.rxHead; 
07666:  MOVFF  123,125
0766A:  MOVFF  122,124
....................     
....................       // Send a Window update message to the remote node 
....................       SendTCP(ACK, SENDTCP_RESET_TIMERS); 
0766E:  MOVLW  10
07670:  MOVLB  3
07672:  MOVWF  x36
07674:  MOVLW  01
07676:  MOVWF  x37
07678:  MOVLB  0
0767A:  CALL   2238
....................    } 
0767E:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void WORD TCPIsGetReady(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines how many bytes can be read from the TCP RX buffer. 
....................  
....................   Description: 
....................    Call this function to determine how many bytes can be read from the  
....................    TCP RX buffer.  If this function returns zero, the application must  
....................    return to the main stack loop before continuing in order to wait for 
....................    more data to arrive. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    The number of bytes available to be read from the TCP RX buffer. 
....................   ***************************************************************************/ 
.................... WORD TCPIsGetReady(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
05DF6:  MOVLB  2
05DF8:  MOVF   xF0,W
05DFA:  SUBLW  00
05DFC:  BC    5E06
....................     { 
....................         return 0; 
05DFE:  MOVLW  00
05E00:  MOVWF  01
05E02:  MOVWF  02
05E04:  BRA    5E72
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
05E06:  MOVFF  2F0,321
05E0A:  MOVLB  0
05E0C:  CALL   0CA6
....................        
....................    if(MyTCBStub.rxHead >= MyTCBStub.rxTail) 
05E10:  MOVLB  1
05E12:  MOVF   x25,W
05E14:  SUBWF  x23,W
05E16:  BNC   5E3A
05E18:  BNZ   5E20
05E1A:  MOVF   x24,W
05E1C:  SUBWF  x22,W
05E1E:  BNC   5E3A
....................       return MyTCBStub.rxHead - MyTCBStub.rxTail; 
05E20:  MOVF   x24,W
05E22:  SUBWF  x22,W
05E24:  MOVWF  00
05E26:  MOVF   x25,W
05E28:  SUBWFB x23,W
05E2A:  MOVWF  03
05E2C:  MOVFF  00,01
05E30:  MOVWF  02
05E32:  MOVLB  2
05E34:  BRA    5E72
05E36:  BRA    5E72
05E38:  MOVLB  1
....................    else 
....................       return (MyTCBStub.bufferEnd - MyTCBStub.rxTail + 1) + (MyTCBStub.rxHead - MyTCBStub.bufferRxStart); 
05E3A:  MOVF   x24,W
05E3C:  SUBWF  x1C,W
05E3E:  MOVLB  2
05E40:  MOVWF  xF1
05E42:  MOVLB  1
05E44:  MOVF   x25,W
05E46:  SUBWFB x1D,W
05E48:  MOVLB  2
05E4A:  MOVWF  xF2
05E4C:  MOVLW  01
05E4E:  ADDWF  xF1,F
05E50:  MOVLW  00
05E52:  ADDWFC xF2,F
05E54:  MOVLB  1
05E56:  MOVF   x1A,W
05E58:  SUBWF  x22,W
05E5A:  MOVWF  00
05E5C:  MOVF   x1B,W
05E5E:  SUBWFB x23,W
05E60:  MOVWF  03
05E62:  MOVF   00,W
05E64:  MOVLB  2
05E66:  ADDWF  xF1,W
05E68:  MOVWF  01
05E6A:  MOVF   xF2,W
05E6C:  ADDWFC 03,F
05E6E:  MOVFF  03,02
05E72:  MOVLB  0
05E74:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPGet(TCP_SOCKET hTCP, BYTE* byte) 
....................  
....................   Description: 
....................    Retrieves a single byte to a TCP socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket from which to read. 
....................    byte - Pointer to location in which the read byte should be stored. 
....................  
....................   Return Values: 
....................    TRUE - A byte was read from the buffer. 
....................    FALSE - The buffer was empty, or the socket is not connected. 
....................   ***************************************************************************/ 
.................... BOOL TCPGet(TCP_SOCKET hTCP, BYTE* byte) 
.................... { 
....................    WORD wGetReadyCount; 
....................  
....................    // See if there is any data which can be read 
....................    wGetReadyCount = TCPIsGetReady(hTCP); 
05E76:  MOVFF  2EB,2F0
05E7A:  RCALL  5DF6
05E7C:  MOVFF  02,2EF
05E80:  MOVFF  01,2EE
....................    if(wGetReadyCount == 0u) 
05E84:  MOVLB  2
05E86:  MOVF   xEE,F
05E88:  BNZ   5E94
05E8A:  MOVF   xEF,F
05E8C:  BNZ   5E94
....................       return FALSE; 
05E8E:  MOVLW  00
05E90:  MOVWF  01
05E92:  BRA    5F22
....................  
....................    SyncTCBStub(hTCP); 
05E94:  MOVFF  2EB,321
05E98:  MOVLB  0
05E9A:  CALL   0CA6
....................     
....................    if(byte) 
05E9E:  MOVLB  2
05EA0:  MOVF   xEC,W
05EA2:  IORWF  xED,W
05EA4:  BZ    5ECC
....................       TCPRAMCopy((PTR_BASE)byte, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, 1); 
05EA6:  MOVFF  2ED,368
05EAA:  MOVFF  2EC,367
05EAE:  MOVLW  01
05EB0:  MOVLB  3
05EB2:  MOVWF  x69
05EB4:  MOVFF  125,36B
05EB8:  MOVFF  124,36A
05EBC:  MOVFF  133,36C
05EC0:  CLRF   x6E
05EC2:  MOVWF  x6D
05EC4:  MOVLB  0
05EC6:  CALL   11B0
05ECA:  MOVLB  2
....................    if(++MyTCBStub.rxTail > MyTCBStub.bufferEnd) 
05ECC:  MOVLB  1
05ECE:  INCF   x24,F
05ED0:  BTFSC  FD8.2
05ED2:  INCF   x25,F
05ED4:  MOVF   x1D,W
05ED6:  SUBWF  x25,W
05ED8:  BNC   5EEA
05EDA:  BNZ   5EE2
05EDC:  MOVF   x24,W
05EDE:  SUBWF  x1C,W
05EE0:  BC    5EEA
....................       MyTCBStub.rxTail = MyTCBStub.bufferRxStart; 
05EE2:  MOVFF  11B,125
05EE6:  MOVFF  11A,124
....................  
....................    // Send a window update if we've run out of data 
....................    if(wGetReadyCount == 1u) 
05EEA:  MOVLB  2
05EEC:  DECFSZ xEE,W
05EEE:  BRA    5EFA
05EF0:  MOVF   xEF,F
05EF2:  BNZ   5EFA
....................    { 
....................       MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
05EF4:  MOVLB  1
05EF6:  BSF    x30.2
....................    } 
05EF8:  BRA    5F1C
....................    // If not already enabled, start a timer so a window  
....................    // update will get sent to the remote node at some point 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
05EFA:  MOVLB  1
05EFC:  BTFSC  x2F.5
05EFE:  BRA    5F1C
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
05F00:  BSF    x2F.5
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_WINDOW_UPDATE_TIMEOUT_VAL/256ull; 
05F02:  MOVLB  0
05F04:  CALL   2B2A
05F08:  MOVLW  1E
05F0A:  MOVLB  2
05F0C:  ADDWF  00,W
05F0E:  MOVLB  1
05F10:  MOVWF  x2A
05F12:  MOVLW  00
05F14:  MOVLB  2
05F16:  ADDWFC 01,W
05F18:  MOVLB  1
05F1A:  MOVWF  x2B
....................    } 
....................  
....................  
....................    return TRUE; 
05F1C:  MOVLW  01
05F1E:  MOVWF  01
05F20:  MOVLB  2
05F22:  MOVLB  0
05F24:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPGetArray(TCP_SOCKET hTCP, BYTE* buffer, WORD len) 
....................  
....................   Description: 
....................    Reads an array of data bytes from a TCP socket's receive FIFO.  The data  
....................    is removed from the FIFO in the process. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket from which data is to be read. 
....................    buffer - Pointer to the array to store data that was read. 
....................    len  - Number of bytes to be read. 
....................  
....................   Returns: 
....................    The number of bytes read from the socket.  If less than len, the 
....................    RX FIFO buffer became empty or the socket is not conected. 
....................   ***************************************************************************/ 
.................... WORD TCPGetArray(TCP_SOCKET hTCP, BYTE* buffer, WORD len) 
.................... { 
....................    WORD wGetReadyCount; 
....................    WORD RightLen = 0; 
....................  
....................    // See if there is any data which can be read 
....................    wGetReadyCount = TCPIsGetReady(hTCP); 
....................    if(wGetReadyCount == 0u) 
....................       return 0x0000u; 
....................  
....................    SyncTCBStub(hTCP); 
....................  
....................    // Make sure we don't try to read more data than is available 
....................    if(len > wGetReadyCount) 
....................       len = wGetReadyCount; 
....................  
....................    // See if we need a two part get 
....................    if(MyTCBStub.rxTail + len > MyTCBStub.bufferEnd) 
....................    { 
....................       RightLen = MyTCBStub.bufferEnd - MyTCBStub.rxTail + 1; 
....................       if(buffer) 
....................       { 
....................          TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, RightLen); 
....................          buffer += RightLen; 
....................       } 
....................       len -= RightLen; 
....................       MyTCBStub.rxTail = MyTCBStub.bufferRxStart; 
....................    } 
....................  
....................    if(buffer) 
....................       TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, len); 
....................    MyTCBStub.rxTail += len; 
....................    len += RightLen; 
....................  
....................    // Send a window update if we've run low on data 
....................    if(wGetReadyCount - len <= len) 
....................    { 
....................       MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
....................    } 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
....................    // If not already enabled, start a timer so a window  
....................    // update will get sent to the remote node at some point 
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_WINDOW_UPDATE_TIMEOUT_VAL/256ull; 
....................    } 
....................  
....................    return len; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPGetRxFIFOFree(TCP_SOCKET hTCP) 
....................  
....................   Description: 
....................    Determines how many bytes are free in the RX FIFO. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    The number of bytes free in the TCP RX FIFO.  If zero, no additional  
....................    data can be received until the application removes some data using one 
....................    of the TCPGet family functions. 
....................   ***************************************************************************/ 
.................... WORD TCPGetRxFIFOFree(TCP_SOCKET hTCP) 
.................... { 
....................    WORD wDataLen; 
....................    WORD wFIFOSize; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    // Calculate total usable FIFO size 
....................    wFIFOSize = MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart; 
....................  
....................    #if defined(STACK_USE_SSL) 
....................    { 
....................       PTR_BASE SSLtemp = MyTCBStub.rxHead; 
....................  
....................       // Move SSL pointer to determine full buffer size 
....................       if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................          MyTCBStub.rxHead = MyTCBStub.sslRxHead; 
....................  
....................       // Find out how many data bytes are actually in the RX FIFO 
....................       wDataLen = TCPIsGetReady(hTCP); 
....................        
....................       // Move SSL pointer back to proper location (if we changed it) 
....................       MyTCBStub.rxHead = SSLtemp; 
....................    } 
....................    #else 
....................    { 
....................       // Find out how many data bytes are actually in the RX FIFO 
....................       wDataLen = TCPIsGetReady(hTCP); 
....................    } 
....................    #endif 
....................     
....................    // Perform the calculation    
....................    return wFIFOSize - wDataLen; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPPeekArray(TCP_SOCKET hTCP, BYTE *vBuffer, WORD wLen, WORD wStart) 
....................  
....................   Summary: 
....................      Reads a specified number of data bytes from the TCP RX FIFO without  
....................      removing them from the buffer. 
....................  
....................   Description: 
....................    Reads a specified number of data bytes from the TCP RX FIFO without  
....................      removing them from the buffer.  No TCP control actions are taken as a  
....................      result of this function (ex: no window update is sent to the remote node). 
....................       
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to peak from (read without removing from stream). 
....................    vBuffer - Destination to write the peeked data bytes. 
....................    wLen - Length of bytes to peak from the RX FIFO and copy to vBuffer. 
....................    wStart - Zero-indexed starting position within the FIFO to start peeking  
....................       from. 
....................  
....................   Return Values: 
....................    Number of bytes actually peeked from the stream and copied to vBuffer.   
....................    This value can be less than wLen if wStart + wLen is greater than the  
....................    deepest possible character in the RX FIFO. 
....................  
....................   Remarks: 
....................      None 
....................   ***************************************************************************/ 
.................... WORD TCPPeekArray(TCP_SOCKET hTCP, BYTE *vBuffer, WORD wLen, WORD wStart) 
.................... { 
....................    PTR_BASE ptrRead; 
....................    WORD w; 
....................    WORD wBytesUntilWrap; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT || wLen == 0) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    // Find out how many bytes are in the RX FIFO and decrease read length  
....................    // if the start offset + read length is beyond the end of the FIFO 
....................    w = TCPIsGetReady(hTCP); 
....................    if(wStart + wLen > w) 
....................       wLen = w - wStart; 
....................  
....................    // Find the read start location 
....................    ptrRead = MyTCBStub.rxTail + wStart; 
....................    if(ptrRead > MyTCBStub.bufferEnd) 
....................       ptrRead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................  
....................    // Calculate how many bytes can be read in a single go 
....................    wBytesUntilWrap = MyTCBStub.bufferEnd - ptrRead + 1; 
....................    if(wLen <= wBytesUntilWrap) 
....................    { 
....................       // Read all at once 
....................       TCPRAMCopy((PTR_BASE)vBuffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, wLen); 
....................    } 
....................    else 
....................    { 
....................       // Read all bytes up to the wrap position and then read remaining bytes  
....................       // at the start of the buffer 
....................       TCPRAMCopy((PTR_BASE)vBuffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, wBytesUntilWrap); 
....................       TCPRAMCopy((PTR_BASE)vBuffer+wBytesUntilWrap, TCP_PIC_RAM, MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, wLen - wBytesUntilWrap); 
....................    } 
....................     
....................    return wLen; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE TCPPeek(TCP_SOCKET hTCP, WORD wStart) 
....................  
....................   Summary: 
....................      Peaks at one byte in the TCP RX FIFO without removing it from the buffer. 
....................  
....................   Description: 
....................    Peaks at one byte in the TCP RX FIFO without removing it from the buffer. 
....................       
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to peak from (read without removing from stream). 
....................    wStart - Zero-indexed starting position within the FIFO to peek from. 
....................  
....................   Return Values: 
....................    Byte peeked from the RX FIFO.  If there is no data in the buffer or an  
....................    illegal wStart starting offset is given, then an indeterminate value is  
....................    returned.  The caller must ensure that valid parameters are passed to avoid  
....................    (i.e ensure that TCPIsGetReady() returns a number that is less than wStart  
....................    before calling TCPPeek()). 
....................  
....................   Remarks: 
....................      Use the TCPPeekArray() function to read more than one byte.  It will  
....................      perform better than calling TCPPeek() in a loop. 
....................   ***************************************************************************/ 
.................... BYTE TCPPeek(TCP_SOCKET hTCP, WORD wStart) 
.................... { 
....................    BYTE i; 
....................     
....................    TCPPeekArray(hTCP, &i, 1, wStart); 
....................    return i; 
.................... } 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Search Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPFindArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen,  
....................                   WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
....................  
....................   Summary: 
....................      Searches for a string in the TCP RX buffer. 
....................  
....................   Description: 
....................    This function finds the first occurrance of an array of bytes in the 
....................    TCP RX buffer.  It can be used by an application to abstract searches  
....................    out of their own application code.  For increased efficiency, the  
....................    function is capable of limiting the scope of search to a specific 
....................    range of bytes.  It can also perform a case-insensitive search if 
....................    required. 
....................     
....................    For example, if the buffer contains "I love PIC MCUs!" and the search 
....................    array is "love" with a length of 4, a value of 2 will be returned. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to search within. 
....................    cFindArray - The array of bytes to find in the buffer. 
....................    wLen - Length of cFindArray. 
....................    wStart - Zero-indexed starting position within the buffer. 
....................    wSearchLen - Length from wStart to search in the buffer. 
....................    bTextCompare - TRUE for case-insensitive text search, FALSE for binary search 
....................  
....................   Return Values: 
....................    0xFFFF - Search array not found 
....................    Otherwise - Zero-indexed position of the first occurrance 
....................  
....................   Remarks: 
....................    Since this function usually must transfer data from external storage 
....................    to internal RAM for comparison, its performance degrades significantly 
....................    when the buffer is full and the array is not found.  For better  
....................    performance, try to search for characters that are expected to exist or 
....................    limit the scope of the search as much as possible.  The HTTP2 module,  
....................    for example, uses this function to parse headers.  However, it searches  
....................    for newlines, then the separating colon, then reads the header name to  
....................    RAM for final comparison.  This has proven to be significantly faster   
....................    than searching for full header name strings outright. 
....................   ***************************************************************************/ 
.................... WORD TCPFindArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
.................... { 
....................    PTR_BASE ptrRead; 
....................    WORD wDataLen; 
....................    WORD wBytesUntilWrap; 
....................    PTR_BASE ptrLocation; 
....................    WORD wLenStart; 
....................    BYTE *cFindArrayStart; 
....................    BYTE i, j, k; 
....................    BOOL isFinding; 
....................    BYTE buffer[32]; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT || wLen == 0) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    // Find out how many bytes are in the RX FIFO and return  
....................    // immediately if we won't possibly find a match 
....................    wDataLen = TCPIsGetReady(hTCP) - wStart; 
....................    if(wDataLen < wLen) 
....................       return 0xFFFFu; 
....................    if(wSearchLen && (wDataLen > wSearchLen)) 
....................       wDataLen = wSearchLen; 
....................  
....................    ptrLocation = MyTCBStub.rxTail + wStart; 
....................    if(ptrLocation > MyTCBStub.bufferEnd) 
....................       ptrLocation -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................    ptrRead = ptrLocation; 
....................    wBytesUntilWrap = MyTCBStub.bufferEnd - ptrLocation + 1; 
....................    ptrLocation = wStart; 
....................    wLenStart = wLen; 
....................    cFindArrayStart = cFindArray; 
....................    j = *cFindArray++; 
....................    isFinding = FALSE; 
....................    if(bTextCompare) 
....................    { 
....................       if(j >= 'a' && j <= 'z') 
....................          j += 'A'-'a'; 
....................    } 
....................  
....................    // Search for the array 
....................    while(1) 
....................    { 
....................       // Figure out how big of a chunk to read 
....................       k = sizeof(buffer); 
....................       if(k > wBytesUntilWrap) 
....................          k = wBytesUntilWrap; 
....................       if((WORD)k > wDataLen) 
....................          k = wDataLen; 
....................  
....................       // Read a chunk of data into the buffer 
....................       TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, (WORD)k); 
....................       ptrRead += k; 
....................       wBytesUntilWrap -= k; 
....................  
....................       if(wBytesUntilWrap == 0u) 
....................       { 
....................          ptrRead = MyTCBStub.bufferRxStart; 
....................          wBytesUntilWrap = 0xFFFFu; 
....................       } 
....................  
....................       // Convert everything to uppercase 
....................       if(bTextCompare) 
....................       { 
....................          for(i = 0; i < k; i++) 
....................          { 
....................             if(buffer[i] >= 'a' && buffer[i] <= 'z') 
....................                buffer[i] += 'A'-'a'; 
....................  
....................             if(j == buffer[i]) 
....................             { 
....................                if(--wLen == 0u) 
....................                   return ptrLocation-wLenStart + i + 1; 
....................                j = *cFindArray++; 
....................                isFinding = TRUE; 
....................                if(j >= 'a' && j <= 'z') 
....................                   j += 'A'-'a'; 
....................             } 
....................             else 
....................             { 
....................                wLen = wLenStart; 
....................                if(isFinding) 
....................                { 
....................                   cFindArray = cFindArrayStart; 
....................                   j = *cFindArray++; 
....................                   if(j >= 'a' && j <= 'z') 
....................                      j += 'A'-'a'; 
....................                   isFinding = FALSE; 
....................                } 
....................             } 
....................          } 
....................       } 
....................       else   // Compare as is 
....................       { 
....................          for(i = 0; i < k; i++) 
....................          { 
....................             if(j == buffer[i]) 
....................             { 
....................                if(--wLen == 0u) 
....................                   return ptrLocation-wLenStart + i + 1; 
....................                j = *cFindArray++; 
....................                isFinding = TRUE; 
....................             } 
....................             else 
....................             { 
....................                wLen = wLenStart; 
....................                if(isFinding) 
....................                { 
....................                   cFindArray = cFindArrayStart; 
....................                   j = *cFindArray++; 
....................                   isFinding = FALSE; 
....................                } 
....................             } 
....................          } 
....................       } 
....................  
....................       // Check to see if it is impossible to find a match 
....................       wDataLen -= k; 
....................       if(wDataLen < wLen) 
....................          return 0xFFFFu; 
....................  
....................       ptrLocation += k; 
....................    } 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPFindROMArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen,  
....................                   WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
....................  
....................   Summary: 
....................      Searches for a ROM string in the TCP RX buffer. 
....................  
....................   Description: 
....................    This function finds the first occurrance of an array of bytes in the 
....................    TCP RX buffer.  It can be used by an application to abstract searches  
....................    out of their own application code.  For increased efficiency, the  
....................    function is capable of limiting the scope of search to a specific 
....................    range of bytes.  It can also perform a case-insensitive search if 
....................    required. 
....................     
....................    For example, if the buffer contains "I love PIC MCUs!" and the search 
....................    array is "love" with a length of 4, a value of 2 will be returned. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to search within. 
....................    cFindArray - The array of bytes to find in the buffer. 
....................    wLen - Length of cFindArray. 
....................    wStart - Zero-indexed starting position within the buffer. 
....................    wSearchLen - Length from wStart to search in the buffer. 
....................    bTextCompare - TRUE for case-insensitive text search, FALSE for binary search 
....................  
....................   Return Values: 
....................    0xFFFF - Search array not found 
....................    Otherwise - Zero-indexed position of the first occurrance 
....................  
....................   Remarks: 
....................    Since this function usually must transfer data from external storage 
....................    to internal RAM for comparison, its performance degrades significantly 
....................    when the buffer is full and the array is not found.  For better  
....................    performance, try to search for characters that are expected to exist or 
....................    limit the scope of the search as much as possible.  The HTTP2 module,  
....................    for example, uses this function to parse headers.  However, it searches  
....................    for newlines, then the separating colon, then reads the header name to  
....................    RAM for final comparison.  This has proven to be significantly faster   
....................    than searching for full header name strings outright. 
....................     
....................    This function is aliased to TCPFindArrayEx on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... WORD TCPFindROMArrayEx(TCP_SOCKET hTCP, ROM BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
.................... { 
....................    PTR_BASE ptrRead; 
....................    WORD wDataLen; 
....................    WORD wBytesUntilWrap; 
....................    PTR_BASE ptrLocation; 
....................    WORD wLenStart; 
....................    ROM BYTE *cFindArrayStart; 
....................    BYTE i, j, k; 
....................    BOOL isFinding; 
....................    BYTE buffer[32]; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT || wLen == 0) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    // Find out how many bytes are in the RX FIFO and return  
....................    // immediately if we won't possibly find a match 
....................    wDataLen = TCPIsGetReady(hTCP) - wStart; 
....................    if(wDataLen < wLen) 
....................       return 0xFFFFu; 
....................    if(wSearchLen && (wDataLen > wSearchLen)) 
....................       wDataLen = wSearchLen; 
....................  
....................    ptrLocation = MyTCBStub.rxTail + wStart; 
....................    if(ptrLocation > MyTCBStub.bufferEnd) 
....................       ptrLocation -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................    ptrRead = ptrLocation; 
....................    wBytesUntilWrap = MyTCBStub.bufferEnd - ptrLocation + 1; 
....................    ptrLocation = wStart; 
....................    wLenStart = wLen; 
....................    cFindArrayStart = cFindArray; 
....................    j = *cFindArray++; 
....................    isFinding = FALSE; 
....................    if(bTextCompare) 
....................    { 
....................       if(j >= 'a' && j <= 'z') 
....................          j += 'A'-'a'; 
....................    } 
....................  
....................    // Search for the array 
....................    while(1) 
....................    { 
....................       // Figure out how big of a chunk to read 
....................       k = sizeof(buffer); 
....................       if(k > wBytesUntilWrap) 
....................          k = wBytesUntilWrap; 
....................       if((WORD)k > wDataLen) 
....................          k = wDataLen; 
....................  
....................       // Read a chunk of data into the buffer 
....................       TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, (WORD)k); 
....................       ptrRead += k; 
....................       wBytesUntilWrap -= k; 
....................  
....................       if(wBytesUntilWrap == 0u) 
....................       { 
....................          ptrRead = MyTCBStub.bufferRxStart; 
....................          wBytesUntilWrap = 0xFFFFu; 
....................       } 
....................  
....................       // Convert everything to uppercase 
....................       if(bTextCompare) 
....................       { 
....................          for(i = 0; i < k; i++) 
....................          { 
....................             if(buffer[i] >= 'a' && buffer[i] <= 'z') 
....................                buffer[i] += 'A'-'a'; 
....................  
....................             if(j == buffer[i]) 
....................             { 
....................                if(--wLen == 0u) 
....................                   return ptrLocation-wLenStart + i + 1; 
....................                j = *cFindArray++; 
....................                isFinding = TRUE; 
....................                if(j >= 'a' && j <= 'z') 
....................                   j += 'A'-'a'; 
....................             } 
....................             else 
....................             { 
....................                wLen = wLenStart; 
....................                if(isFinding) 
....................                { 
....................                   cFindArray = cFindArrayStart; 
....................                   j = *cFindArray++; 
....................                   if(j >= 'a' && j <= 'z') 
....................                      j += 'A'-'a'; 
....................                   isFinding = FALSE; 
....................                } 
....................             } 
....................          } 
....................       } 
....................       else   // Compare as is 
....................       { 
....................          for(i = 0; i < k; i++) 
....................          { 
....................             if(j == buffer[i]) 
....................             { 
....................                if(--wLen == 0u) 
....................                   return ptrLocation-wLenStart + i + 1; 
....................                j = *cFindArray++; 
....................                isFinding = TRUE; 
....................             } 
....................             else 
....................             { 
....................                wLen = wLenStart; 
....................                if(isFinding) 
....................                { 
....................                   cFindArray = cFindArrayStart; 
....................                   j = *cFindArray++; 
....................                   isFinding = FALSE; 
....................                } 
....................             } 
....................          } 
....................       } 
....................  
....................       // Check to see if it is impossible to find a match 
....................       wDataLen -= k; 
....................       if(wDataLen < wLen) 
....................          return 0xFFFFu; 
....................  
....................       ptrLocation += k; 
....................    } 
.................... } 
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPFindEx(TCP_SOCKET hTCP, BYTE cFind, 
....................                   WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
....................  
....................   Summary: 
....................      Searches for a byte in the TCP RX buffer. 
....................  
....................   Description: 
....................    This function finds the first occurrance of a byte in the TCP RX 
....................    buffer.  It can be used by an application to abstract searches  
....................    out of their own application code.  For increased efficiency, the  
....................    function is capable of limiting the scope of search to a specific 
....................    range of bytes.  It can also perform a case-insensitive search if 
....................    required. 
....................     
....................    For example, if the buffer contains "I love PIC MCUs!" and the cFind 
....................    byte is ' ', a value of 1 will be returned. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to search within. 
....................    cFind - The byte to find in the buffer. 
....................    wStart - Zero-indexed starting position within the buffer. 
....................    wSearchLen - Length from wStart to search in the buffer. 
....................    bTextCompare - TRUE for case-insensitive text search, FALSE for binary search 
....................  
....................   Return Values: 
....................    0xFFFF - Search array not found 
....................    Otherwise - Zero-indexed position of the first occurrance 
....................  
....................   Remarks: 
....................    Since this function usually must transfer data from external storage 
....................    to internal RAM for comparison, its performance degrades significantly 
....................    when the buffer is full and the array is not found.  For better  
....................    performance, try to search for characters that are expected to exist or 
....................    limit the scope of the search as much as possible.  The HTTP2 module,  
....................    for example, uses this function to parse headers.  However, it searches  
....................    for newlines, then the separating colon, then reads the header name to  
....................    RAM for final comparison.  This has proven to be significantly faster   
....................    than searching for full header name strings outright. 
....................   ***************************************************************************/ 
.................... WORD TCPFindEx(TCP_SOCKET hTCP, BYTE cFind, WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
.................... { 
....................    return TCPFindArrayEx(hTCP, &cFind, sizeof(cFind), wStart, wSearchLen, bTextCompare); 
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Data Processing Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPTick(void) 
....................  
....................   Summary: 
....................      Performs periodic TCP tasks. 
....................  
....................   Description: 
....................    This function performs any required periodic TCP tasks.  Each  
....................    socket's state machine is checked, and any elapsed timeout periods 
....................    are handled. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... void TCPTick(void) 
.................... { 
....................    TCP_SOCKET hTCP; 
....................    BOOL bRetransmit; 
....................    BOOL bCloseSocket; 
....................    BYTE vFlags; 
....................    WORD w; 
....................  
....................    // Periodically all "not closed" sockets must perform timed operations 
....................    for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++) 
*
02FFE:  MOVLB  2
03000:  CLRF   xEB
03002:  MOVF   xEB,F
03004:  BTFSS  FD8.2
03006:  GOTO   378A
....................    { 
....................       SyncTCBStub(hTCP); 
0300A:  MOVFF  2EB,321
0300E:  MOVLB  0
03010:  CALL   0CA6
....................        
....................       // Handle any SSL Processing and Message Transmission 
....................       #if defined(STACK_USE_SSL) 
....................       if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       { 
....................          // Handle any periodic tasks, such as RSA operations 
....................          SSLPeriodic(hTCP, MyTCBStub.sslStubID); 
....................           
....................          // If unsent data is waiting, transmit it as an application record 
....................          if(MyTCBStub.sslTxHead != MyTCBStub.txHead && TCPSSLGetPendingTxSize(hTCP) != 0u) 
....................             SSLTxRecord(hTCP, MyTCBStub.sslStubID, SSL_APPLICATION); 
....................           
....................          // If an SSL message is requested, send it now 
....................          if(MyTCBStub.sslReqMessage != SSL_NO_MESSAGE) 
....................             SSLTxMessage(hTCP, MyTCBStub.sslStubID, MyTCBStub.sslReqMessage); 
....................       } 
....................       #endif 
....................        
....................       vFlags = 0x00; 
03014:  MOVLB  2
03016:  CLRF   xED
....................       bRetransmit = FALSE; 
03018:  BCF    xEC.0
....................       bCloseSocket = FALSE; 
0301A:  BCF    xEC.1
....................  
....................       // Transmit ASAP data if the medium is available 
....................       if(MyTCBStub.Flags.bTXASAP || MyTCBStub.Flags.bTXASAPWithoutTimerReset) 
0301C:  MOVLB  1
0301E:  BTFSC  x30.1
03020:  BRA    3026
03022:  BTFSS  x30.2
03024:  BRA    3044
....................       { 
....................          if(MACIsTxReady()) 
03026:  MOVLB  0
03028:  CALL   1656
0302C:  MOVF   01,F
0302E:  BZ    3046
....................          { 
....................             vFlags = ACK; 
03030:  MOVLW  10
03032:  MOVLB  2
03034:  MOVWF  xED
....................             bRetransmit = MyTCBStub.Flags.bTXASAPWithoutTimerReset; 
03036:  BCF    xEC.0
03038:  MOVLB  1
0303A:  BTFSS  x30.2
0303C:  BRA    3044
0303E:  MOVLB  2
03040:  BSF    xEC.0
03042:  MOVLB  1
03044:  MOVLB  0
....................          } 
....................       } 
....................  
....................       // Perform any needed window updates and data transmissions 
....................       if(MyTCBStub.Flags.bTimer2Enabled) 
03046:  MOVLB  1
03048:  BTFSS  x2F.5
0304A:  BRA    307A
....................       { 
....................          // See if the timeout has occured, and we need to send a new window update and pending data 
....................          if((SHORT)(MyTCBStub.eventTime2 - (WORD)TickGetDiv256()) <= (SHORT)0) 
0304C:  MOVLB  0
0304E:  RCALL  2B2A
03050:  MOVF   00,W
03052:  MOVLB  1
03054:  SUBWF  x2A,W
03056:  MOVWF  00
03058:  MOVF   01,W
0305A:  SUBWFB x2B,W
0305C:  MOVWF  03
0305E:  MOVFF  00,2F0
03062:  MOVLB  2
03064:  MOVWF  xF1
03066:  BTFSC  FE8.7
03068:  BRA    3074
0306A:  MOVF   xF1,F
0306C:  BNZ   3078
0306E:  MOVF   xF0,W
03070:  SUBLW  00
03072:  BNC   3078
....................             vFlags = ACK; 
03074:  MOVLW  10
03076:  MOVWF  xED
03078:  MOVLB  1
....................       } 
....................  
....................       // Process Delayed ACKnowledgement timer 
....................       if(MyTCBStub.Flags.bDelayedACKTimerEnabled) 
0307A:  BTFSS  x2F.6
0307C:  BRA    30AC
....................       { 
....................          // See if the timeout has occured and delayed ACK needs to be sent 
....................          if((SHORT)(MyTCBStub.OverlappedTimers.delayedACKTime - (WORD)TickGetDiv256()) <= (SHORT)0) 
0307E:  MOVLB  0
03080:  RCALL  2B2A
03082:  MOVF   00,W
03084:  MOVLB  1
03086:  SUBWF  x2C,W
03088:  MOVWF  00
0308A:  MOVF   01,W
0308C:  SUBWFB x2D,W
0308E:  MOVWF  03
03090:  MOVFF  00,2F0
03094:  MOVLB  2
03096:  MOVWF  xF1
03098:  BTFSC  FE8.7
0309A:  BRA    30A6
0309C:  MOVF   xF1,F
0309E:  BNZ   30AA
030A0:  MOVF   xF0,W
030A2:  SUBLW  00
030A4:  BNC   30AA
....................             vFlags = ACK; 
030A6:  MOVLW  10
030A8:  MOVWF  xED
030AA:  MOVLB  1
....................       } 
....................        
....................       // Process TCP_CLOSE_WAIT timer 
....................       if(MyTCBStub.smState == TCP_CLOSE_WAIT) 
030AC:  MOVF   x2E,W
030AE:  SUBLW  0B
030B0:  BNZ   30E4
....................       { 
....................          // Automatically close the socket on our end if the application  
....................          // fails to call TCPDisconnect() is a reasonable amount of time. 
....................          if((SHORT)(MyTCBStub.OverlappedTimers.closeWaitTime - (WORD)TickGetDiv256()) <= (SHORT)0) 
030B2:  MOVLB  0
030B4:  RCALL  2B2A
030B6:  MOVF   00,W
030B8:  MOVLB  1
030BA:  SUBWF  x2C,W
030BC:  MOVWF  00
030BE:  MOVF   01,W
030C0:  SUBWFB x2D,W
030C2:  MOVWF  03
030C4:  MOVFF  00,2F0
030C8:  MOVLB  2
030CA:  MOVWF  xF1
030CC:  BTFSC  FE8.7
030CE:  BRA    30DA
030D0:  MOVF   xF1,F
030D2:  BNZ   30E6
030D4:  MOVF   xF0,W
030D6:  SUBLW  00
030D8:  BNC   30E6
....................          { 
....................             vFlags = FIN | ACK; 
030DA:  MOVLW  11
030DC:  MOVWF  xED
....................             MyTCBStub.smState = TCP_LAST_ACK; 
030DE:  MOVLW  0C
030E0:  MOVLB  1
030E2:  MOVWF  x2E
030E4:  MOVLB  2
....................          } 
....................       } 
....................  
....................       // Process listening server sockets that might have a SYN waiting in the SYNQueue[] 
....................       #if TCP_SYN_QUEUE_MAX_ENTRIES 
....................          if(MyTCBStub.smState == TCP_LISTEN) 
030E6:  MOVLB  1
030E8:  MOVF   x2E,W
030EA:  SUBLW  04
030EC:  BTFSS  FD8.2
030EE:  BRA    33A8
....................          { 
....................             for(w = 0; w < TCP_SYN_QUEUE_MAX_ENTRIES; w++) 
030F0:  MOVLB  2
030F2:  CLRF   xEF
030F4:  CLRF   xEE
030F6:  MOVF   xEF,F
030F8:  BTFSS  FD8.2
030FA:  BRA    33A6
030FC:  MOVF   xEE,W
030FE:  SUBLW  02
03100:  BTFSS  FD8.0
03102:  BRA    33A6
....................             { 
....................                // Abort search if there are no more valid records 
....................                if(SYNQueue[w].wDestPort == 0u) 
03104:  MOVFF  2EF,321
03108:  MOVFF  2EE,320
0310C:  MOVLB  3
0310E:  CLRF   x23
03110:  MOVLW  14
03112:  MOVWF  x22
03114:  MOVLB  0
03116:  RCALL  2B50
03118:  MOVFF  01,2F0
0311C:  MOVLW  10
0311E:  MOVLB  2
03120:  ADDWF  01,W
03122:  MOVWF  01
03124:  MOVLW  00
03126:  ADDWFC 02,W
03128:  MOVWF  03
0312A:  MOVF   01,W
0312C:  ADDLW  DC
0312E:  MOVWF  FE9
03130:  MOVLW  00
03132:  ADDWFC 03,W
03134:  MOVWF  FEA
03136:  MOVFF  FEC,2F1
0313A:  MOVF   FED,F
0313C:  MOVFF  FEF,2F0
03140:  MOVF   xF0,F
03142:  BNZ   314A
03144:  MOVF   xF1,F
03146:  BNZ   314A
....................                   break; 
03148:  BRA    33A6
....................                 
....................                // Stop searching if this SYN queue entry can be used by this socket 
....................                #if defined(STACK_USE_SSL_SERVER) 
....................                if(SYNQueue[w].wDestPort == MyTCBStub.remoteHash.Val || SYNQueue[w].wDestPort == MyTCBStub.sslTxHead) 
....................                #else 
....................                if(SYNQueue[w].wDestPort == MyTCBStub.remoteHash.Val) 
0314A:  MOVFF  2EF,321
0314E:  MOVFF  2EE,320
03152:  MOVLB  3
03154:  CLRF   x23
03156:  MOVLW  14
03158:  MOVWF  x22
0315A:  MOVLB  0
0315C:  RCALL  2B50
0315E:  MOVFF  01,2F0
03162:  MOVLW  10
03164:  MOVLB  2
03166:  ADDWF  01,W
03168:  MOVWF  01
0316A:  MOVLW  00
0316C:  ADDWFC 02,W
0316E:  MOVWF  03
03170:  MOVF   01,W
03172:  ADDLW  DC
03174:  MOVWF  FE9
03176:  MOVLW  00
03178:  ADDWFC 03,W
0317A:  MOVWF  FEA
0317C:  MOVFF  FEC,2F1
03180:  MOVF   FED,F
03182:  MOVFF  FEF,2F0
03186:  MOVLB  1
03188:  MOVF   x31,W
0318A:  MOVLB  2
0318C:  SUBWF  xF0,W
0318E:  BTFSS  FD8.2
03190:  BRA    339E
03192:  MOVLB  1
03194:  MOVF   x32,W
03196:  MOVLB  2
03198:  SUBWF  xF1,W
0319A:  BTFSS  FD8.2
0319C:  BRA    339E
....................                #endif 
....................                { 
....................                   // Set up our socket and generate a reponse SYN+ACK packet 
....................                   SyncTCB(); 
0319E:  MOVLB  0
031A0:  CALL   1296
....................                    
....................                   #if defined(STACK_USE_SSL_SERVER) 
....................                   // If this matches the SSL port, make sure that can be configured 
....................                   // before continuing.  If not, break and leave this in the queue 
....................                   if(SYNQueue[w].wDestPort == MyTCBStub.sslTxHead && !TCPStartSSLServer(hTCP)) 
....................                      break; 
....................                   #endif 
....................                    
....................                   memcpy((void*)&MyTCB.remote.niRemoteMACIP, (void*)&SYNQueue[w].niSourceAddress, sizeof(NODE_INFO)); 
031A4:  MOVLB  2
031A6:  CLRF   xF1
031A8:  MOVLW  CA
031AA:  MOVWF  xF0
031AC:  MOVFF  2EF,321
031B0:  MOVFF  2EE,320
031B4:  MOVLB  3
031B6:  CLRF   x23
031B8:  MOVLW  14
031BA:  MOVWF  x22
031BC:  MOVLB  0
031BE:  RCALL  2B50
031C0:  MOVFF  02,2F3
031C4:  MOVFF  01,2F2
031C8:  MOVLW  DC
031CA:  MOVLB  2
031CC:  ADDWF  01,W
031CE:  MOVWF  01
031D0:  MOVLW  00
031D2:  ADDWFC 02,W
031D4:  MOVWF  03
031D6:  MOVFF  01,2F4
031DA:  MOVWF  xF5
031DC:  MOVFF  2F1,FEA
031E0:  MOVFF  2F0,FE9
031E4:  MOVWF  FE2
031E6:  MOVFF  01,FE1
031EA:  MOVLW  0A
031EC:  MOVWF  01
031EE:  MOVFF  FE6,FEE
031F2:  DECFSZ 01,F
031F4:  BRA    31EE
....................                   MyTCB.remotePort.Val = SYNQueue[w].wSourcePort; 
031F6:  MOVFF  2EF,321
031FA:  MOVFF  2EE,320
031FE:  MOVLB  3
03200:  CLRF   x23
03202:  MOVLW  14
03204:  MOVWF  x22
03206:  MOVLB  0
03208:  RCALL  2B50
0320A:  MOVFF  01,2F0
0320E:  MOVLW  0A
03210:  MOVLB  2
03212:  ADDWF  01,W
03214:  MOVWF  01
03216:  MOVLW  00
03218:  ADDWFC 02,W
0321A:  MOVWF  03
0321C:  MOVF   01,W
0321E:  ADDLW  DC
03220:  MOVWF  FE9
03222:  MOVLW  00
03224:  ADDWFC 03,W
03226:  MOVWF  FEA
03228:  MOVFF  FEC,C3
0322C:  MOVF   FED,F
0322E:  MOVFF  FEF,C2
....................                   MyTCB.RemoteSEQ = SYNQueue[w].dwSourceSEQ + 1; 
03232:  MOVFF  2EF,321
03236:  MOVFF  2EE,320
0323A:  MOVLB  3
0323C:  CLRF   x23
0323E:  MOVLW  14
03240:  MOVWF  x22
03242:  MOVLB  0
03244:  RCALL  2B50
03246:  MOVFF  01,2F0
0324A:  MOVLW  0C
0324C:  MOVLB  2
0324E:  ADDWF  01,W
03250:  MOVWF  01
03252:  MOVLW  00
03254:  ADDWFC 02,W
03256:  MOVWF  03
03258:  MOVF   01,W
0325A:  ADDLW  DC
0325C:  MOVWF  FE9
0325E:  MOVLW  00
03260:  ADDWFC 03,W
03262:  MOVWF  FEA
03264:  MOVFF  FEF,2F0
03268:  MOVFF  FEC,2F1
0326C:  MOVFF  FEC,2F2
03270:  MOVFF  FEC,2F3
03274:  MOVLW  01
03276:  ADDWF  xF0,W
03278:  MOVLB  0
0327A:  MOVWF  xBC
0327C:  MOVLW  00
0327E:  MOVLB  2
03280:  ADDWFC xF1,W
03282:  MOVLB  0
03284:  MOVWF  xBD
03286:  MOVLW  00
03288:  MOVLB  2
0328A:  ADDWFC xF2,W
0328C:  MOVLB  0
0328E:  MOVWF  xBE
03290:  MOVLW  00
03292:  MOVLB  2
03294:  ADDWFC xF3,W
03296:  MOVLB  0
03298:  MOVWF  xBF
....................                   MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1] + MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val; 
0329A:  MOVF   xCA,W
0329C:  ADDWF  xCC,W
0329E:  MOVLB  2
032A0:  MOVWF  xF0
032A2:  MOVLB  0
032A4:  MOVF   xCB,W
032A6:  ADDWFC xCD,W
032A8:  MOVLB  2
032AA:  MOVWF  xF1
032AC:  MOVLB  0
032AE:  MOVF   xC2,W
032B0:  MOVLB  2
032B2:  ADDWF  xF0,F
032B4:  MOVLB  0
032B6:  MOVF   xC3,W
032B8:  MOVLB  2
032BA:  ADDWFC xF1,F
032BC:  MOVF   xF0,W
032BE:  MOVLB  0
032C0:  XORWF  xC4,W
032C2:  MOVLB  1
032C4:  MOVWF  x31
032C6:  MOVLB  2
032C8:  MOVF   xF1,W
032CA:  MOVLB  0
032CC:  XORWF  xC5,W
032CE:  MOVLB  1
032D0:  MOVWF  x32
....................                   vFlags = SYN | ACK; 
032D2:  MOVLW  12
032D4:  MOVLB  2
032D6:  MOVWF  xED
....................                   MyTCBStub.smState = TCP_SYN_RECEIVED; 
032D8:  MOVLW  06
032DA:  MOVLB  1
032DC:  MOVWF  x2E
....................                    
....................                   // Delete this SYN from the SYNQueue and compact the SYNQueue[] array 
....................                   TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE)); 
032DE:  MOVFF  2EF,321
032E2:  MOVFF  2EE,320
032E6:  MOVLB  3
032E8:  CLRF   x23
032EA:  MOVLW  14
032EC:  MOVWF  x22
032EE:  MOVLB  0
032F0:  RCALL  2B50
032F2:  MOVFF  02,03
032F6:  MOVF   01,W
032F8:  ADDLW  DC
032FA:  MOVWF  01
032FC:  MOVLW  00
032FE:  ADDWFC 03,F
03300:  MOVFF  01,2F0
03304:  MOVLB  2
03306:  MOVFF  03,2F1
0330A:  MOVLW  01
0330C:  ADDWF  xEE,W
0330E:  MOVWF  xF2
03310:  MOVLW  00
03312:  ADDWFC xEF,W
03314:  MOVWF  xF3
03316:  MOVFF  FE8,321
0331A:  MOVFF  2F2,320
0331E:  MOVLB  3
03320:  CLRF   x23
03322:  MOVLW  14
03324:  MOVWF  x22
03326:  MOVLB  0
03328:  RCALL  2B50
0332A:  MOVFF  02,03
0332E:  MOVF   01,W
03330:  ADDLW  DC
03332:  MOVWF  01
03334:  MOVLW  00
03336:  ADDWFC 03,F
03338:  MOVFF  01,2F2
0333C:  MOVLB  2
0333E:  MOVFF  03,2F3
03342:  MOVLW  02
03344:  BSF    FD8.0
03346:  SUBFWB xEE,W
03348:  MOVWF  xF4
0334A:  MOVLW  00
0334C:  SUBFWB xEF,W
0334E:  MOVWF  xF5
03350:  MOVFF  FE8,321
03354:  MOVFF  2F4,320
03358:  MOVLB  3
0335A:  CLRF   x23
0335C:  MOVLW  14
0335E:  MOVWF  x22
03360:  MOVLB  0
03362:  CALL   2B50
03366:  MOVFF  02,2F5
0336A:  MOVFF  01,2F4
0336E:  MOVFF  2F1,368
03372:  MOVFF  2F0,367
03376:  MOVLW  01
03378:  MOVLB  3
0337A:  MOVWF  x69
0337C:  MOVFF  2F3,36B
03380:  MOVFF  2F2,36A
03384:  MOVWF  x6C
03386:  MOVFF  02,36E
0338A:  MOVFF  01,36D
0338E:  MOVLB  0
03390:  CALL   11B0
....................                   SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort = 0u; 
03394:  MOVLB  1
03396:  CLRF   x15
03398:  CLRF   x14
....................     
....................                   break; 
0339A:  MOVLB  2
0339C:  BRA    33A6
....................                } 
0339E:  INCF   xEE,F
033A0:  BTFSC  FD8.2
033A2:  INCF   xEF,F
033A4:  BRA    30F6
033A6:  MOVLB  1
....................             } 
....................          } 
....................       #endif 
....................  
....................       if(vFlags) 
033A8:  MOVLB  2
033AA:  MOVF   xED,F
033AC:  BZ    33CA
....................          SendTCP(vFlags, bRetransmit ? 0 : SENDTCP_RESET_TIMERS); 
033AE:  BTFSS  xEC.0
033B0:  BRA    33B6
033B2:  MOVLW  00
033B4:  BRA    33B8
033B6:  MOVLW  01
033B8:  MOVWF  xF0
033BA:  MOVFF  2ED,336
033BE:  MOVFF  FE8,337
033C2:  MOVLB  0
033C4:  CALL   2238
033C8:  MOVLB  2
....................  
....................       // The TCP_CLOSED, TCP_LISTEN, and sometimes the TCP_ESTABLISHED  
....................       // state don't need any timeout events, so see if the timer is enabled 
....................       if(!MyTCBStub.Flags.bTimerEnabled) 
033CA:  MOVLB  1
033CC:  BTFSC  x2F.4
033CE:  BRA    34AE
....................       { 
....................          #if defined(TCP_KEEP_ALIVE_TIMEOUT) 
....................             // Only the established state has any use for keep-alives 
....................             if(MyTCBStub.smState == TCP_ESTABLISHED) 
033D0:  MOVF   x2E,W
033D2:  SUBLW  07
033D4:  BNZ   34A8
....................             { 
....................                // If timeout has not occured, do not do anything. 
....................                if((LONG)(TickGet() - MyTCBStub.eventTime) < (LONG)0) 
033D6:  MOVLB  0
033D8:  CALL   1630
033DC:  MOVFF  03,2F3
033E0:  MOVFF  02,2F2
033E4:  MOVFF  01,2F1
033E8:  MOVFF  00,2F0
033EC:  MOVLB  1
033EE:  MOVF   x26,W
033F0:  MOVLB  2
033F2:  SUBWF  00,W
033F4:  MOVWF  00
033F6:  MOVLB  1
033F8:  MOVF   x27,W
033FA:  MOVLB  2
033FC:  SUBWFB 01,W
033FE:  MOVWF  01
03400:  MOVLB  1
03402:  MOVF   x28,W
03404:  MOVLB  2
03406:  SUBWFB 02,W
03408:  MOVWF  02
0340A:  MOVLB  1
0340C:  MOVF   x29,W
0340E:  MOVLB  2
03410:  SUBWFB 03,W
03412:  MOVWF  03
03414:  MOVWF  xF3
03416:  MOVFF  02,2F2
0341A:  MOVFF  01,2F1
0341E:  MOVFF  00,2F0
03422:  BTFSS  FE8.7
03424:  BRA    3428
....................                   continue; 
03426:  BRA    3786
....................        
....................                // If timeout has occured and the connection appears to be dead (no  
....................                // responses from remote node at all), close the connection so the  
....................                // application doesn't sit around indefinitely with a useless socket  
....................                // that it thinks is still open 
....................                if(MyTCBStub.Flags.vUnackedKeepalives == TCP_MAX_UNACKED_KEEP_ALIVES) 
03428:  MOVLB  1
0342A:  MOVF   x2F,W
0342C:  ANDLW  07
0342E:  SUBLW  06
03430:  BNZ   3466
....................                { 
....................                   vFlags = MyTCBStub.Flags.bServer; 
03432:  MOVLB  2
03434:  CLRF   xED
03436:  MOVLB  1
03438:  BTFSS  x2F.3
0343A:  BRA    3442
0343C:  MOVLB  2
0343E:  INCF   xED,F
03440:  MOVLB  1
....................  
....................                   // Force an immediate FIN and RST transmission 
....................                   // Double calling TCPDisconnect() will also place us  
....................                   // back in the listening state immediately if a server socket. 
....................                   TCPDisconnect(hTCP); 
03442:  MOVFF  2EB,2F0
03446:  MOVLB  0
03448:  CALL   2B72
....................                   TCPDisconnect(hTCP); 
0344C:  MOVFF  2EB,2F0
03450:  CALL   2B72
....................                    
....................                   // Prevent client mode sockets from getting reused by other applications.   
....................                   // The application must call TCPDisconnect() with the handle to free this  
....................                   // socket (and the handle associated with it) 
....................                   if(!vFlags) 
03454:  MOVLB  2
03456:  MOVF   xED,F
03458:  BNZ   3462
....................                      MyTCBStub.smState = TCP_CLOSED_BUT_RESERVED; 
0345A:  MOVLW  0E
0345C:  MOVLB  1
0345E:  MOVWF  x2E
03460:  MOVLB  2
....................                    
....................                   continue; 
03462:  BRA    3786
03464:  MOVLB  1
....................                } 
....................                 
....................                // Otherwise, if a timeout occured, simply send a keep-alive packet 
....................                SyncTCB(); 
03466:  MOVLB  0
03468:  CALL   1296
....................                SendTCP(ACK, SENDTCP_KEEP_ALIVE); 
0346C:  MOVLW  10
0346E:  MOVLB  3
03470:  MOVWF  x36
03472:  MOVLW  02
03474:  MOVWF  x37
03476:  MOVLB  0
03478:  CALL   2238
....................                MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
0347C:  CALL   1630
03480:  MOVLW  E6
03482:  MOVLB  2
03484:  ADDWF  00,W
03486:  MOVLB  1
03488:  MOVWF  x26
0348A:  MOVLW  F5
0348C:  MOVLB  2
0348E:  ADDWFC 01,W
03490:  MOVLB  1
03492:  MOVWF  x27
03494:  MOVLW  05
03496:  MOVLB  2
03498:  ADDWFC 02,W
0349A:  MOVLB  1
0349C:  MOVWF  x28
0349E:  MOVLW  00
034A0:  MOVLB  2
034A2:  ADDWFC 03,W
034A4:  MOVLB  1
034A6:  MOVWF  x29
....................             } 
....................          #endif 
....................          continue; 
034A8:  MOVLB  2
034AA:  BRA    3786
034AC:  MOVLB  1
....................       } 
....................  
....................       // If timeout has not occured, do not do anything. 
....................       if((LONG)(TickGet() - MyTCBStub.eventTime) < (LONG)0) 
034AE:  MOVLB  0
034B0:  CALL   1630
034B4:  MOVFF  03,2F3
034B8:  MOVFF  02,2F2
034BC:  MOVFF  01,2F1
034C0:  MOVFF  00,2F0
034C4:  MOVLB  1
034C6:  MOVF   x26,W
034C8:  MOVLB  2
034CA:  SUBWF  00,W
034CC:  MOVWF  00
034CE:  MOVLB  1
034D0:  MOVF   x27,W
034D2:  MOVLB  2
034D4:  SUBWFB 01,W
034D6:  MOVWF  01
034D8:  MOVLB  1
034DA:  MOVF   x28,W
034DC:  MOVLB  2
034DE:  SUBWFB 02,W
034E0:  MOVWF  02
034E2:  MOVLB  1
034E4:  MOVF   x29,W
034E6:  MOVLB  2
034E8:  SUBWFB 03,W
034EA:  MOVWF  03
034EC:  MOVWF  xF3
034EE:  MOVFF  02,2F2
034F2:  MOVFF  01,2F1
034F6:  MOVFF  00,2F0
034FA:  BTFSS  FE8.7
034FC:  BRA    3500
....................          continue; 
034FE:  BRA    3786
....................  
....................       // Load up extended TCB information 
....................       SyncTCB(); 
03500:  MOVLB  0
03502:  CALL   1296
....................  
....................       // A timeout has occured.  Respond to this timeout condition 
....................       // depending on what state this socket is in. 
....................       switch(MyTCBStub.smState) 
03506:  MOVLB  1
03508:  MOVF   x2E,W
0350A:  XORLW  02
0350C:  MOVLB  0
0350E:  BZ    3544
03510:  XORLW  01
03512:  BZ    3564
03514:  XORLW  06
03516:  BZ    35E4
03518:  XORLW  03
0351A:  BTFSC  FD8.2
0351C:  BRA    360A
0351E:  XORLW  01
03520:  BTFSC  FD8.2
03522:  BRA    3638
03524:  XORLW  0C
03526:  BTFSC  FD8.2
03528:  BRA    3638
0352A:  XORLW  03
0352C:  BTFSC  FD8.2
0352E:  BRA    365A
03530:  XORLW  01
03532:  BTFSC  FD8.2
03534:  BRA    3678
03536:  XORLW  03
03538:  BTFSC  FD8.2
0353A:  BRA    3684
0353C:  XORLW  06
0353E:  BTFSC  FD8.2
03540:  BRA    36A2
03542:  BRA    36C2
....................       { 
....................          #if defined(STACK_CLIENT_MODE) 
....................          #if defined(STACK_USE_DNS) 
....................          case TCP_GET_DNS_MODULE: 
....................             if(DNSBeginUsage()) 
....................             { 
....................                MyTCBStub.smState = TCP_DNS_RESOLVE; 
....................                if(MyTCB.flags.bRemoteHostIsROM) 
....................                   DNSResolveROM((ROM BYTE*)(ROM_PTR_BASE)MyTCB.remote.dwRemoteHost, DNS_TYPE_A); 
....................                else 
....................                   DNSResolve((BYTE*)(PTR_BASE)MyTCB.remote.dwRemoteHost, DNS_TYPE_A); 
....................             } 
....................             break; 
....................              
....................          case TCP_DNS_RESOLVE: 
....................          { 
....................             IP_ADDR ipResolvedDNSIP; 
....................  
....................             // See if DNS resolution has finished.  Note that if the DNS  
....................             // fails, the &ipResolvedDNSIP will be written with 0x00000000.  
....................             // MyTCB.remote.dwRemoteHost is unioned with  
....................             // MyTCB.remote.niRemoteMACIP.IPAddr, so we can't directly write  
....................             // the DNS result into MyTCB.remote.niRemoteMACIP.IPAddr.  We  
....................             // must copy it over only if the DNS is resolution step was  
....................             // successful. 
....................             if(DNSIsResolved(&ipResolvedDNSIP)) 
....................             { 
....................                if(DNSEndUsage()) 
....................                { 
....................                   MyTCB.remote.niRemoteMACIP.IPAddr.Val = ipResolvedDNSIP.Val; 
....................                   MyTCBStub.smState = TCP_GATEWAY_SEND_ARP; 
....................                   MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1]+MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val; 
....................                   MyTCB.retryCount = 0; 
....................                   MyTCB.retryInterval = (TICK_SECOND/4)/256; 
....................                } 
....................                else 
....................                { 
....................                   MyTCBStub.eventTime = TickGet() + 10*TICK_SECOND; 
....................                   MyTCBStub.smState = TCP_GET_DNS_MODULE; 
....................                } 
....................             } 
....................             break; 
....................          } 
....................          #endif // #if defined(STACK_USE_DNS) 
....................              
....................          case TCP_GATEWAY_SEND_ARP: 
....................             // Obtain the MAC address associated with the server's IP address (either direct MAC address on same subnet, or the MAC address of the Gateway machine) 
....................             MyTCBStub.eventTime2 = (WORD)TickGetDiv256(); 
03544:  CALL   2B2A
03548:  MOVFF  01,12B
0354C:  MOVFF  00,12A
....................             ARPResolve(&MyTCB.remote.niRemoteMACIP.IPAddr); 
03550:  MOVLB  2
03552:  CLRF   xF1
03554:  MOVLW  CA
03556:  MOVWF  xF0
03558:  MOVLB  0
0355A:  BRA    2E4C
....................             MyTCBStub.smState = TCP_GATEWAY_GET_ARP; 
0355C:  MOVLW  03
0355E:  MOVLB  1
03560:  MOVWF  x2E
....................             break; 
03562:  BRA    36C4
....................  
....................          case TCP_GATEWAY_GET_ARP: 
....................             // Wait for the MAC address to finish being obtained 
....................             if(!ARPIsResolved(&MyTCB.remote.niRemoteMACIP.IPAddr, &MyTCB.remote.niRemoteMACIP.MACAddr)) 
03564:  MOVLB  2
03566:  CLRF   xF1
03568:  MOVLW  CA
0356A:  MOVWF  xF0
0356C:  CLRF   xF3
0356E:  MOVLW  CE
03570:  MOVWF  xF2
03572:  MOVLB  0
03574:  BRA    2F0A
03576:  MOVF   01,F
03578:  BNZ   35D4
....................             { 
....................                // Time out if too much time is spent in this state 
....................                // Note that this will continuously send out ARP  
....................                // requests for an infinite time if the Gateway  
....................                // never responds 
....................                if((WORD)TickGetDiv256() - MyTCBStub.eventTime2 > (WORD)MyTCB.retryInterval) 
0357A:  CALL   2B2A
0357E:  MOVFF  01,2F1
03582:  MOVFF  00,2F0
03586:  MOVLB  1
03588:  MOVF   x2A,W
0358A:  MOVLB  2
0358C:  SUBWF  xF0,F
0358E:  MOVLB  1
03590:  MOVF   x2B,W
03592:  MOVLB  2
03594:  SUBWFB xF1,F
03596:  MOVLB  0
03598:  MOVF   xB5,W
0359A:  MOVLB  2
0359C:  SUBWF  xF1,W
0359E:  BNC   35CE
035A0:  BNZ   35B2
035A2:  MOVF   xF0,W
035A4:  MOVLB  0
035A6:  SUBWF  xB4,W
035A8:  BTFSS  FD8.0
035AA:  BRA    35B0
035AC:  MOVLB  2
035AE:  BRA    35CE
035B0:  MOVLB  2
....................                { 
....................                   // Exponentially increase timeout until we reach 6 attempts then stay constant 
....................                   if(MyTCB.retryCount < 6u) 
035B2:  MOVLB  0
035B4:  MOVF   xD9,W
035B6:  SUBLW  05
035B8:  BNC   35C6
....................                   { 
....................                      MyTCB.retryCount++; 
035BA:  INCF   xD9,F
....................                      MyTCB.retryInterval <<= 1; 
035BC:  BCF    FD8.0
035BE:  RLCF   xB4,F
035C0:  RLCF   xB5,F
035C2:  RLCF   xB6,F
035C4:  RLCF   xB7,F
....................                   } 
....................  
....................                   // Retransmit ARP request 
....................                   MyTCBStub.smState = TCP_GATEWAY_SEND_ARP; 
035C6:  MOVLW  02
035C8:  MOVLB  1
035CA:  MOVWF  x2E
035CC:  MOVLB  2
....................                } 
....................                break; 
035CE:  MOVLB  1
035D0:  BRA    36C4
035D2:  MOVLB  0
....................             } 
....................              
....................             // Send out SYN connection request to remote node 
....................             // This automatically disables the Timer from  
....................             // continuously firing for this socket 
....................             vFlags = SYN; 
035D4:  MOVLW  02
035D6:  MOVLB  2
035D8:  MOVWF  xED
....................             bRetransmit = FALSE; 
035DA:  BCF    xEC.0
....................             MyTCBStub.smState = TCP_SYN_SENT; 
035DC:  MOVLW  05
035DE:  MOVLB  1
035E0:  MOVWF  x2E
....................             break; 
035E2:  BRA    36C4
....................          #endif // #if defined(STACK_CLIENT_MODE) 
....................           
....................          case TCP_SYN_SENT: 
....................             // Keep sending SYN until we hear from remote node. 
....................             // This may be for infinite time, in that case 
....................             // caller must detect it and do something. 
....................             vFlags = SYN; 
035E4:  MOVLW  02
035E6:  MOVLB  2
035E8:  MOVWF  xED
....................             bRetransmit = TRUE; 
035EA:  BSF    xEC.0
....................  
....................             // Exponentially increase timeout until we reach TCP_MAX_RETRIES attempts then stay constant 
....................             if(MyTCB.retryCount >= (TCP_MAX_RETRIES - 1)) 
035EC:  MOVLB  0
035EE:  MOVF   xD9,W
035F0:  SUBLW  03
035F2:  BC    3606
....................             { 
....................                MyTCB.retryCount = TCP_MAX_RETRIES - 1; 
035F4:  MOVLW  04
035F6:  MOVWF  xD9
....................                MyTCB.retryInterval = TCP_START_TIMEOUT_VAL<<(TCP_MAX_RETRIES-1); 
035F8:  CLRF   xB7
035FA:  MOVLW  09
035FC:  MOVWF  xB6
035FE:  MOVLW  89
03600:  MOVWF  xB5
03602:  MOVLW  70
03604:  MOVWF  xB4
....................             } 
....................             break; 
03606:  MOVLB  1
03608:  BRA    36C4
....................     
....................          case TCP_SYN_RECEIVED: 
....................             // We must receive ACK before timeout expires. 
....................             // If not, resend SYN+ACK. 
....................             // Abort, if maximum attempts counts are reached. 
....................             if(MyTCB.retryCount < TCP_MAX_SYN_RETRIES) 
0360A:  MOVF   xD9,W
0360C:  SUBLW  01
0360E:  BNC   361C
....................             { 
....................                vFlags = SYN | ACK; 
03610:  MOVLW  12
03612:  MOVLB  2
03614:  MOVWF  xED
....................                bRetransmit = TRUE; 
03616:  BSF    xEC.0
....................             } 
03618:  BRA    3634
0361A:  MOVLB  0
....................             else 
....................             { 
....................                if(MyTCBStub.Flags.bServer) 
0361C:  MOVLB  1
0361E:  BTFSS  x2F.3
03620:  BRA    362E
....................                { 
....................                   vFlags = RST | ACK; 
03622:  MOVLW  14
03624:  MOVLB  2
03626:  MOVWF  xED
....................                   bCloseSocket = TRUE; 
03628:  BSF    xEC.1
....................                } 
0362A:  BRA    3634
0362C:  MOVLB  1
....................                else 
....................                { 
....................                   vFlags = SYN; 
0362E:  MOVLW  02
03630:  MOVLB  2
03632:  MOVWF  xED
....................                } 
....................             } 
....................             break; 
03634:  MOVLB  1
03636:  BRA    36C4
....................     
....................          case TCP_ESTABLISHED: 
....................          case TCP_CLOSE_WAIT: 
....................             // Retransmit any unacknowledged data 
....................             if(MyTCB.retryCount < TCP_MAX_RETRIES) 
03638:  MOVF   xD9,W
0363A:  SUBLW  04
0363C:  BNC   364A
....................             { 
....................                vFlags = ACK; 
0363E:  MOVLW  10
03640:  MOVLB  2
03642:  MOVWF  xED
....................                bRetransmit = TRUE; 
03644:  BSF    xEC.0
....................             } 
03646:  BRA    3656
03648:  MOVLB  0
....................             else 
....................             { 
....................                // No response back for too long, close connection 
....................                // This could happen, for instance, if the communication  
....................                // medium was lost 
....................                MyTCBStub.smState = TCP_FIN_WAIT_1; 
0364A:  MOVLW  08
0364C:  MOVLB  1
0364E:  MOVWF  x2E
....................                vFlags = FIN | ACK; 
03650:  MOVLW  11
03652:  MOVLB  2
03654:  MOVWF  xED
....................             } 
....................             break; 
03656:  MOVLB  1
03658:  BRA    36C4
....................     
....................          case TCP_FIN_WAIT_1: 
....................             if(MyTCB.retryCount < TCP_MAX_RETRIES) 
0365A:  MOVF   xD9,W
0365C:  SUBLW  04
0365E:  BNC   366C
....................             { 
....................                // Send another FIN 
....................                vFlags = FIN | ACK; 
03660:  MOVLW  11
03662:  MOVLB  2
03664:  MOVWF  xED
....................                bRetransmit = TRUE; 
03666:  BSF    xEC.0
....................             } 
03668:  BRA    3674
0366A:  MOVLB  0
....................             else 
....................             { 
....................                // Close on our own, we can't seem to communicate  
....................                // with the remote node anymore 
....................                vFlags = RST | ACK; 
0366C:  MOVLW  14
0366E:  MOVLB  2
03670:  MOVWF  xED
....................                bCloseSocket = TRUE; 
03672:  BSF    xEC.1
....................             } 
....................             break; 
03674:  MOVLB  1
03676:  BRA    36C4
....................     
....................          case TCP_FIN_WAIT_2: 
....................             // Close on our own, we can't seem to communicate  
....................             // with the remote node anymore 
....................             vFlags = RST | ACK; 
03678:  MOVLW  14
0367A:  MOVLB  2
0367C:  MOVWF  xED
....................             bCloseSocket = TRUE; 
0367E:  BSF    xEC.1
....................             break; 
03680:  MOVLB  1
03682:  BRA    36C4
....................  
....................          case TCP_CLOSING: 
....................             if(MyTCB.retryCount < TCP_MAX_RETRIES) 
03684:  MOVF   xD9,W
03686:  SUBLW  04
03688:  BNC   3696
....................             { 
....................                // Send another ACK+FIN (the FIN is retransmitted  
....................                // automatically since it hasn't been acknowledged by  
....................                // the remote node yet) 
....................                vFlags = ACK; 
0368A:  MOVLW  10
0368C:  MOVLB  2
0368E:  MOVWF  xED
....................                bRetransmit = TRUE; 
03690:  BSF    xEC.0
....................             } 
03692:  BRA    369E
03694:  MOVLB  0
....................             else 
....................             { 
....................                // Close on our own, we can't seem to communicate  
....................                // with the remote node anymore 
....................                vFlags = RST | ACK; 
03696:  MOVLW  14
03698:  MOVLB  2
0369A:  MOVWF  xED
....................                bCloseSocket = TRUE; 
0369C:  BSF    xEC.1
....................             } 
....................             break; 
0369E:  MOVLB  1
036A0:  BRA    36C4
....................     
.................... //         case TCP_TIME_WAIT: 
.................... //            // Wait around for a while (2MSL) and then goto closed state 
.................... //            bCloseSocket = TRUE; 
.................... //            break; 
.................... //          
....................  
....................          case TCP_LAST_ACK: 
....................             // Send some more FINs or close anyway 
....................             if(MyTCB.retryCount < TCP_MAX_RETRIES) 
036A2:  MOVF   xD9,W
036A4:  SUBLW  04
036A6:  BNC   36B4
....................             { 
....................                vFlags = FIN | ACK; 
036A8:  MOVLW  11
036AA:  MOVLB  2
036AC:  MOVWF  xED
....................                bRetransmit = TRUE; 
036AE:  BSF    xEC.0
....................             } 
036B0:  BRA    36BC
036B2:  MOVLB  0
....................             else 
....................             { 
....................                vFlags = RST | ACK; 
036B4:  MOVLW  14
036B6:  MOVLB  2
036B8:  MOVWF  xED
....................                bCloseSocket = TRUE; 
036BA:  BSF    xEC.1
....................             } 
....................             break; 
036BC:  MOVLB  1
036BE:  BRA    36C4
036C0:  MOVLB  0
....................           
....................          default: 
....................             break; 
036C2:  MOVLB  1
....................       } 
....................  
....................       if(vFlags) 
036C4:  MOVLB  2
036C6:  MOVF   xED,F
036C8:  BZ    377A
....................       { 
....................          // Transmit all unacknowledged data over again 
....................          if(bRetransmit) 
036CA:  BTFSS  xEC.0
036CC:  BRA    3768
....................          { 
....................             // Set the appropriate retry time 
....................             MyTCB.retryCount++; 
036CE:  MOVLB  0
036D0:  INCF   xD9,F
....................             MyTCB.retryInterval <<= 1; 
036D2:  BCF    FD8.0
036D4:  RLCF   xB4,F
036D6:  RLCF   xB5,F
036D8:  RLCF   xB6,F
036DA:  RLCF   xB7,F
....................        
....................             // Calculate how many bytes we have to roll back and retransmit 
....................             w = MyTCB.txUnackedTail - MyTCBStub.txTail; 
036DC:  MOVLB  1
036DE:  MOVF   x20,W
036E0:  MOVLB  0
036E2:  SUBWF  xC0,W
036E4:  MOVLB  2
036E6:  MOVWF  xEE
036E8:  MOVLB  1
036EA:  MOVF   x21,W
036EC:  MOVLB  0
036EE:  SUBWFB xC1,W
036F0:  MOVLB  2
036F2:  MOVWF  xEF
....................             if(MyTCB.txUnackedTail < MyTCBStub.txTail) 
036F4:  MOVLB  0
036F6:  MOVF   xC1,W
036F8:  MOVLB  1
036FA:  SUBWF  x21,W
036FC:  BNC   3728
036FE:  BNZ   3710
03700:  MOVF   x20,W
03702:  MOVLB  0
03704:  SUBWF  xC0,W
03706:  BTFSS  FD8.0
03708:  BRA    370E
0370A:  MOVLB  1
0370C:  BRA    3728
0370E:  MOVLB  1
....................                w += MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
03710:  MOVF   x18,W
03712:  SUBWF  x1A,W
03714:  MOVWF  00
03716:  MOVF   x19,W
03718:  SUBWFB x1B,W
0371A:  MOVWF  03
0371C:  MOVF   00,W
0371E:  MOVLB  2
03720:  ADDWF  xEE,F
03722:  MOVF   03,W
03724:  ADDWFC xEF,F
03726:  MOVLB  1
....................              
....................             // Perform roll back of local SEQuence counter, remote window  
....................             // adjustment, and cause all unacknowledged data to be  
....................             // retransmitted by moving the unacked tail pointer. 
....................             MyTCB.MySEQ -= w; 
03728:  MOVLB  2
0372A:  MOVF   xEE,W
0372C:  MOVLB  0
0372E:  SUBWF  xB8,F
03730:  MOVLB  2
03732:  MOVF   xEF,W
03734:  MOVLB  0
03736:  SUBWFB xB9,F
03738:  MOVLW  00
0373A:  SUBWFB xBA,F
0373C:  SUBWFB xBB,F
....................             MyTCB.remoteWindow += w; 
0373E:  MOVLB  2
03740:  MOVF   xEE,W
03742:  MOVLB  0
03744:  ADDWF  xC6,F
03746:  MOVLB  2
03748:  MOVF   xEF,W
0374A:  MOVLB  0
0374C:  ADDWFC xC7,F
....................             MyTCB.txUnackedTail = MyTCBStub.txTail;       
0374E:  MOVFF  121,C1
03752:  MOVFF  120,C0
....................             SendTCP(vFlags, 0); 
03756:  MOVFF  2ED,336
0375A:  MOVLB  3
0375C:  CLRF   x37
0375E:  MOVLB  0
03760:  CALL   2238
....................          } 
03764:  BRA    3778
03766:  MOVLB  2
....................          else 
....................             SendTCP(vFlags, SENDTCP_RESET_TIMERS); 
03768:  MOVFF  2ED,336
0376C:  MOVLW  01
0376E:  MOVLB  3
03770:  MOVWF  x37
03772:  MOVLB  0
03774:  CALL   2238
03778:  MOVLB  2
....................  
....................       } 
....................        
....................       if(bCloseSocket) 
0377A:  BTFSS  xEC.1
0377C:  BRA    3786
....................          CloseSocket(); 
0377E:  MOVLB  0
03780:  CALL   136A
03784:  MOVLB  2
....................    } 
....................     
....................     
....................    #if TCP_SYN_QUEUE_MAX_ENTRIES 
03786:  INCF   xEB,F
03788:  BRA    3002
....................       // Process SYN Queue entry timeouts 
....................       for(w = 0; w < TCP_SYN_QUEUE_MAX_ENTRIES; w++) 
0378A:  CLRF   xEF
0378C:  CLRF   xEE
0378E:  MOVF   xEF,F
03790:  BTFSS  FD8.2
03792:  BRA    391A
03794:  MOVF   xEE,W
03796:  SUBLW  02
03798:  BTFSS  FD8.0
0379A:  BRA    391A
....................       { 
....................          // Abort search if there are no more valid records 
....................          if(SYNQueue[w].wDestPort == 0u) 
0379C:  MOVFF  2EF,321
037A0:  MOVFF  2EE,320
037A4:  MOVLB  3
037A6:  CLRF   x23
037A8:  MOVLW  14
037AA:  MOVWF  x22
037AC:  MOVLB  0
037AE:  CALL   2B50
037B2:  MOVFF  01,2F0
037B6:  MOVLW  10
037B8:  MOVLB  2
037BA:  ADDWF  01,W
037BC:  MOVWF  01
037BE:  MOVLW  00
037C0:  ADDWFC 02,W
037C2:  MOVWF  03
037C4:  MOVF   01,W
037C6:  ADDLW  DC
037C8:  MOVWF  FE9
037CA:  MOVLW  00
037CC:  ADDWFC 03,W
037CE:  MOVWF  FEA
037D0:  MOVFF  FEC,2F1
037D4:  MOVF   FED,F
037D6:  MOVFF  FEF,2F0
037DA:  MOVF   xF0,F
037DC:  BNZ   37E4
037DE:  MOVF   xF1,F
037E0:  BNZ   37E4
....................             break; 
037E2:  BRA    391A
....................           
....................          // See if this SYN has timed out 
....................          if((WORD)TickGetDiv256() - SYNQueue[w].wTimestamp > (WORD)(TCP_SYN_QUEUE_TIMEOUT/256ull)) 
037E4:  MOVLB  0
037E6:  CALL   2B2A
037EA:  MOVFF  01,2F1
037EE:  MOVFF  00,2F0
037F2:  MOVFF  2EF,321
037F6:  MOVFF  2EE,320
037FA:  MOVLB  3
037FC:  CLRF   x23
037FE:  MOVLW  14
03800:  MOVWF  x22
03802:  MOVLB  0
03804:  CALL   2B50
03808:  MOVFF  02,2F3
0380C:  MOVFF  01,2F2
03810:  MOVLW  12
03812:  MOVLB  2
03814:  ADDWF  01,W
03816:  MOVWF  01
03818:  MOVLW  00
0381A:  ADDWFC 02,W
0381C:  MOVWF  03
0381E:  MOVF   01,W
03820:  ADDLW  DC
03822:  MOVWF  FE9
03824:  MOVLW  00
03826:  ADDWFC 03,W
03828:  MOVWF  FEA
0382A:  MOVFF  FEC,03
0382E:  MOVF   FED,F
03830:  MOVF   FEF,W
03832:  SUBWF  xF0,F
03834:  MOVF   03,W
03836:  SUBWFB xF1,F
03838:  MOVF   xF1,W
0383A:  SUBLW  00
0383C:  BC    3912
0383E:  XORLW  FF
03840:  BNZ   3848
03842:  MOVF   xF0,W
03844:  SUBLW  C9
03846:  BC    3912
....................          { 
....................             // Delete this SYN from the SYNQueue and compact the SYNQueue[] array 
....................             TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE)); 
03848:  MOVFF  2EF,321
0384C:  MOVFF  2EE,320
03850:  MOVLB  3
03852:  CLRF   x23
03854:  MOVLW  14
03856:  MOVWF  x22
03858:  MOVLB  0
0385A:  CALL   2B50
0385E:  MOVFF  02,03
03862:  MOVF   01,W
03864:  ADDLW  DC
03866:  MOVWF  01
03868:  MOVLW  00
0386A:  ADDWFC 03,F
0386C:  MOVFF  01,2F0
03870:  MOVLB  2
03872:  MOVFF  03,2F1
03876:  MOVLW  01
03878:  ADDWF  xEE,W
0387A:  MOVWF  xF2
0387C:  MOVLW  00
0387E:  ADDWFC xEF,W
03880:  MOVWF  xF3
03882:  MOVFF  FE8,321
03886:  MOVFF  2F2,320
0388A:  MOVLB  3
0388C:  CLRF   x23
0388E:  MOVLW  14
03890:  MOVWF  x22
03892:  MOVLB  0
03894:  CALL   2B50
03898:  MOVFF  02,03
0389C:  MOVF   01,W
0389E:  ADDLW  DC
038A0:  MOVWF  01
038A2:  MOVLW  00
038A4:  ADDWFC 03,F
038A6:  MOVFF  01,2F2
038AA:  MOVLB  2
038AC:  MOVFF  03,2F3
038B0:  MOVLW  02
038B2:  BSF    FD8.0
038B4:  SUBFWB xEE,W
038B6:  MOVWF  xF4
038B8:  MOVLW  00
038BA:  SUBFWB xEF,W
038BC:  MOVWF  xF5
038BE:  MOVFF  FE8,321
038C2:  MOVFF  2F4,320
038C6:  MOVLB  3
038C8:  CLRF   x23
038CA:  MOVLW  14
038CC:  MOVWF  x22
038CE:  MOVLB  0
038D0:  CALL   2B50
038D4:  MOVFF  02,2F5
038D8:  MOVFF  01,2F4
038DC:  MOVFF  2F1,368
038E0:  MOVFF  2F0,367
038E4:  MOVLW  01
038E6:  MOVLB  3
038E8:  MOVWF  x69
038EA:  MOVFF  2F3,36B
038EE:  MOVFF  2F2,36A
038F2:  MOVWF  x6C
038F4:  MOVFF  02,36E
038F8:  MOVFF  01,36D
038FC:  MOVLB  0
038FE:  CALL   11B0
....................             SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort = 0u; 
03902:  MOVLB  1
03904:  CLRF   x15
03906:  CLRF   x14
....................     
....................             // Since we deleted an entry, we need to roll back one  
....................             // index so next loop will process the correct record 
....................             w--;    
03908:  MOVLB  2
0390A:  MOVF   xEE,W
0390C:  BTFSC  FD8.2
0390E:  DECF   xEF,F
03910:  DECF   xEE,F
....................          } 
03912:  INCF   xEE,F
03914:  BTFSC  FD8.2
03916:  INCF   xEF,F
03918:  BRA    378E
....................       } 
....................    #endif 
0391A:  MOVLB  0
0391C:  GOTO   5A24 (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPProcess(NODE_INFO* remote, IP_ADDR* localIP, WORD len) 
....................  
....................   Summary: 
....................      Handles incoming TCP segments. 
....................  
....................   Description: 
....................    This function handles incoming TCP segments.  When a segment arrives, it 
....................    is compared to open sockets using a hash of the remote port and IP.   
....................    On a match, the data is passed to HandleTCPSeg for further processing. 
....................  
....................   Precondition: 
....................    TCP is initialized and a TCP segment is ready in the MAC buffer. 
....................  
....................   Parameters: 
....................    remote - Remote NODE_INFO structure 
....................    localIP - This stack's IP address (for header checking) 
....................    len - Total length of the waiting TCP segment 
....................  
....................   Return Values: 
....................    TRUE - the segment was properly handled. 
....................    FALSE - otherwise 
....................   ***************************************************************************/ 
.................... BOOL TCPProcess(NODE_INFO* remote, IP_ADDR* localIP, WORD len) 
.................... { 
....................    TCP_HEADER      TCPHeader; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................    WORD_VAL        checksum1; 
....................    WORD_VAL        checksum2; 
....................    BYTE            optionsSize; 
....................  
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress      = remote->IPAddr; 
*
05898:  MOVLB  2
0589A:  MOVFF  2EB,FE9
0589E:  MOVFF  2EC,FEA
058A2:  MOVFF  FEF,00
058A6:  MOVFF  FEC,01
058AA:  MOVFF  FEC,02
058AE:  MOVFF  FEC,03
058B2:  MOVFF  00,305
058B6:  MOVFF  01,306
058BA:  MOVFF  02,307
058BE:  MOVFF  03,308
....................    pseudoHeader.DestAddress        = *localIP; 
058C2:  MOVFF  2ED,FE9
058C6:  MOVFF  2EE,FEA
058CA:  MOVFF  FEF,00
058CE:  MOVFF  FEC,01
058D2:  MOVFF  FEC,02
058D6:  MOVFF  FEC,03
058DA:  MOVFF  00,309
058DE:  MOVFF  01,30A
058E2:  MOVFF  02,30B
058E6:  MOVFF  03,30C
....................    pseudoHeader.Zero               = 0x0; 
058EA:  MOVLB  3
058EC:  CLRF   x0D
....................    pseudoHeader.Protocol           = IP_PROT_TCP; 
058EE:  MOVLW  06
058F0:  MOVWF  x0E
....................    pseudoHeader.Length             = len; 
058F2:  MOVFF  2F0,310
058F6:  MOVFF  2EF,30F
....................  
....................    SwapPseudoHeader(pseudoHeader); 
058FA:  MOVFF  310,380
058FE:  MOVFF  30F,37F
05902:  MOVLB  0
05904:  CALL   1796
05908:  MOVFF  02,310
0590C:  MOVFF  01,30F
....................  
....................    checksum1.Val = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
05910:  MOVLW  03
05912:  MOVLB  3
05914:  MOVWF  x17
05916:  MOVLW  05
05918:  MOVWF  x16
0591A:  MOVFF  317,37C
0591E:  MOVWF  x7B
05920:  CLRF   x7E
05922:  MOVLW  0C
05924:  MOVWF  x7D
05926:  MOVLB  0
05928:  CALL   1B4A
0592C:  MOVFF  01,311
05930:  MOVLB  3
05932:  COMF   x11,F
05934:  MOVFF  02,312
05938:  COMF   x12,F
....................  
....................    // Now calculate TCP packet checksum in NIC RAM - should match 
....................    // pesudo header checksum 
....................    checksum2.Val = CalcIPBufferChecksum(len); 
0593A:  MOVFF  2F0,361
0593E:  MOVFF  2EF,360
05942:  MOVLB  0
05944:  CALL   1EBC
05948:  MOVFF  02,314
0594C:  MOVFF  01,313
....................  
....................    // Compare checksums. 
....................    if(checksum1.Val != checksum2.Val) 
05950:  MOVLB  3
05952:  MOVF   x13,W
05954:  SUBWF  x11,W
05956:  BNZ   595E
05958:  MOVF   x14,W
0595A:  SUBWF  x12,W
0595C:  BZ    596C
....................    { 
....................       MACDiscardRx(); 
0595E:  MOVLB  0
05960:  CALL   3920
....................       return TRUE; 
05964:  MOVLW  01
05966:  MOVWF  01
05968:  BRA    5A1C
0596A:  MOVLB  3
....................    } 
....................  
.................... #if defined(DEBUG_GENERATE_RX_LOSS) 
....................    // Throw RX packets away randomly 
....................    if(LFSRRand() > DEBUG_GENERATE_RX_LOSS) 
....................    { 
....................       MACDiscardRx(); 
....................       return TRUE; 
....................    } 
.................... #endif 
....................  
....................    // Retrieve TCP header. 
....................    IPSetRxBuffer(0); 
0596C:  CLRF   x3B
0596E:  CLRF   x3A
05970:  MOVLB  0
05972:  CALL   3F0C
....................    MACGetArray((BYTE*)&TCPHeader, sizeof(TCPHeader)); 
05976:  MOVLW  02
05978:  MOVLB  3
0597A:  MOVWF  x17
0597C:  MOVLW  F1
0597E:  MOVWF  x16
05980:  MOVFF  317,383
05984:  MOVWF  x82
05986:  CLRF   x85
05988:  MOVLW  14
0598A:  MOVWF  x84
0598C:  MOVLB  0
0598E:  CALL   0E68
....................    SwapTCPHeader(&TCPHeader); 
05992:  MOVLW  02
05994:  MOVLB  3
05996:  MOVWF  x61
05998:  MOVLW  F1
0599A:  MOVWF  x60
0599C:  MOVLB  0
0599E:  CALL   192E
....................  
....................  
....................    // Skip over options to retrieve data bytes 
....................    optionsSize = (BYTE)((TCPHeader.DataOffset.Val << 2)- 
....................       sizeof(TCPHeader)); 
059A2:  MOVLB  2
059A4:  SWAPF  xFD,W
059A6:  ANDLW  0F
059A8:  MOVWF  00
059AA:  RLCF   00,F
059AC:  RLCF   00,F
059AE:  MOVLW  FC
059B0:  ANDWF  00,F
059B2:  MOVF   00,W
059B4:  ADDLW  EC
059B6:  MOVLB  3
059B8:  MOVWF  x15
....................    len = len - optionsSize - sizeof(TCPHeader); 
059BA:  MOVF   x15,W
059BC:  MOVLB  2
059BE:  SUBWF  xEF,W
059C0:  MOVLB  3
059C2:  MOVWF  x16
059C4:  MOVLW  00
059C6:  MOVLB  2
059C8:  SUBWFB xF0,W
059CA:  MOVLB  3
059CC:  MOVWF  x17
059CE:  MOVLW  14
059D0:  SUBWF  x16,W
059D2:  MOVLB  2
059D4:  MOVWF  xEF
059D6:  MOVLW  00
059D8:  MOVLB  3
059DA:  SUBWFB x17,W
059DC:  MOVLB  2
059DE:  MOVWF  xF0
....................  
....................    // Find matching socket. 
....................    if(FindMatchingTCPSocket(&TCPHeader, remote)) 
059E0:  MOVLW  02
059E2:  MOVLB  3
059E4:  MOVWF  x17
059E6:  MOVLW  F1
059E8:  MOVWF  x16
059EA:  MOVFF  2EC,319
059EE:  MOVFF  2EB,318
059F2:  MOVLB  0
059F4:  GOTO   3F26
059F8:  MOVF   01,F
059FA:  BZ    5A14
....................    { 
....................       #if defined(STACK_USE_SSL) 
....................       PTR_BASE prevRxHead; 
....................       // For SSL connections, show HandleTCPSeg() the full data buffer 
....................       prevRxHead = MyTCBStub.rxHead; 
....................       if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................          MyTCBStub.rxHead = MyTCBStub.sslRxHead; 
....................       #endif 
....................        
....................       HandleTCPSeg(&TCPHeader, len); 
059FC:  MOVLW  02
059FE:  MOVLB  3
05A00:  MOVWF  x17
05A02:  MOVLW  F1
05A04:  MOVWF  x16
05A06:  MOVFF  2F0,319
05A0A:  MOVFF  2EF,318
05A0E:  MOVLB  0
05A10:  GOTO   466A
....................        
....................       #if defined(STACK_USE_SSL) 
....................       if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       { 
....................          // Restore the buffer state 
....................          MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................          MyTCBStub.rxHead = prevRxHead; 
....................  
....................          // Process the new SSL data, using the currently loaded stub 
....................          TCPSSLHandleIncoming(hCurrentTCP); 
....................       } 
....................       #endif 
....................    } 
.................... //   else 
.................... //   { 
.................... //      // NOTE: RFC 793 specifies that if the socket is closed and a segment  
.................... //      // arrives, we should send back a RST if the RST bit in the incoming  
.................... //      // packet is not set.  Instead, we will just silently ignore such a  
.................... //      // packet since this is what firewalls do on purpose to enhance  
.................... //      // security. 
.................... //      //if(!TCPHeader.Flags.bits.flagRST) 
.................... //      //   SendTCP(RST, SENDTCP_RESET_TIMERS); 
.................... //   } 
....................  
....................    // Finished with this packet, discard it and free the Ethernet RAM for new packets 
....................    MACDiscardRx(); 
05A14:  CALL   3920
....................  
....................    return TRUE; 
05A18:  MOVLW  01
05A1A:  MOVWF  01
05A1C:  GOTO   5B54 (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void SendTCP(BYTE vTCPFlags, BYTE vSendFlags) 
....................  
....................   Summary: 
....................    Transmits a TPC segment. 
....................  
....................   Description: 
....................    This function assembles and transmits a TCP segment, including any  
....................    pending data.  It also supports retransmissions, keep-alives, and  
....................    other packet types. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    vTCPFlags - Additional TCP flags to include 
....................    vSendFlags - Any combinations of SENDTCP_* constants to modify the 
....................              transmit behavior or contents. 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... static void SendTCP(BYTE vTCPFlags, BYTE vSendFlags) 
.................... { 
....................    WORD_VAL        wVal; 
....................    TCP_HEADER      header; 
....................    TCP_OPTIONS     options; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................    WORD          len; 
....................     
....................    SyncTCB(); 
*
02238:  CALL   1296
....................  
....................    // FINs must be handled specially 
....................    if(vTCPFlags & FIN) 
0223C:  MOVLB  3
0223E:  BTFSS  x36.0
02240:  BRA    224A
....................    { 
....................       MyTCBStub.Flags.bTXFIN = 1; 
02242:  MOVLB  1
02244:  BSF    x30.3
....................       vTCPFlags &= ~FIN; 
02246:  MOVLB  3
02248:  BCF    x36.0
....................    } 
....................  
....................    // Status will now be synched, disable automatic future  
....................    // status transmissions 
....................    MyTCBStub.Flags.bTimer2Enabled = 0; 
0224A:  MOVLB  1
0224C:  BCF    x2F.5
....................    MyTCBStub.Flags.bDelayedACKTimerEnabled = 0; 
0224E:  BCF    x2F.6
....................    MyTCBStub.Flags.bOneSegmentReceived = 0; 
02250:  BCF    x2F.7
....................    MyTCBStub.Flags.bTXASAP = 0; 
02252:  BCF    x30.1
....................    MyTCBStub.Flags.bTXASAPWithoutTimerReset = 0; 
02254:  BCF    x30.2
....................    MyTCBStub.Flags.bHalfFullFlush = 0; 
02256:  BCF    x30.0
....................  
....................    //  Make sure that we can write to the MAC transmit area 
....................    while(!IPIsTxReady()); 
02258:  MOVLB  0
0225A:  CALL   1656
0225E:  MOVF   01,F
02260:  BZ    225A
....................  
....................    // Put all socket application data in the TX space 
....................    if(vTCPFlags & (SYN | RST)) 
02262:  MOVLB  3
02264:  MOVF   x36,W
02266:  ANDLW  06
02268:  BZ    2270
....................    { 
....................       // Don't put any data in SYN and RST messages 
....................       len = 0; 
0226A:  CLRF   x5F
0226C:  CLRF   x5E
....................    } 
0226E:  BRA    24D6
....................    else 
....................    { 
....................       // Begin copying any application data over to the TX space 
....................       if(MyTCBStub.txHead == MyTCB.txUnackedTail) 
02270:  MOVLB  0
02272:  MOVF   xC0,W
02274:  MOVLB  1
02276:  SUBWF  x1E,W
02278:  BNZ   228C
0227A:  MOVLB  0
0227C:  MOVF   xC1,W
0227E:  MOVLB  1
02280:  SUBWF  x1F,W
02282:  BNZ   228C
....................       { 
....................          // All caught up on data TX, no real data for this packet 
....................          len = 0; 
02284:  MOVLB  3
02286:  CLRF   x5F
02288:  CLRF   x5E
....................       } 
0228A:  BRA    24A6
....................       else if(MyTCBStub.txHead > MyTCB.txUnackedTail) 
0228C:  MOVLB  0
0228E:  MOVF   xC1,W
02290:  MOVLB  1
02292:  SUBWF  x1F,W
02294:  BNC   2346
02296:  BNZ   22A8
02298:  MOVF   x1E,W
0229A:  MOVLB  0
0229C:  SUBWF  xC0,W
0229E:  BTFSS  FD8.0
022A0:  BRA    22A6
022A2:  MOVLB  1
022A4:  BRA    2346
022A6:  MOVLB  1
....................       { 
....................          len = MyTCBStub.txHead - MyTCB.txUnackedTail; 
022A8:  MOVLB  0
022AA:  MOVF   xC0,W
022AC:  MOVLB  1
022AE:  SUBWF  x1E,W
022B0:  MOVLB  3
022B2:  MOVWF  x5E
022B4:  MOVLB  0
022B6:  MOVF   xC1,W
022B8:  MOVLB  1
022BA:  SUBWFB x1F,W
022BC:  MOVLB  3
022BE:  MOVWF  x5F
....................  
....................          if(len > MyTCB.remoteWindow) 
022C0:  MOVLB  0
022C2:  MOVF   xC7,W
022C4:  MOVLB  3
022C6:  SUBWF  x5F,W
022C8:  BNC   22E4
022CA:  BNZ   22DC
022CC:  MOVF   x5E,W
022CE:  MOVLB  0
022D0:  SUBWF  xC6,W
022D2:  BTFSS  FD8.0
022D4:  BRA    22DA
022D6:  MOVLB  3
022D8:  BRA    22E4
022DA:  MOVLB  3
....................             len = MyTCB.remoteWindow; 
022DC:  MOVFF  C7,35F
022E0:  MOVFF  C6,35E
....................  
....................          if(len > MyTCB.wRemoteMSS) 
022E4:  MOVLB  0
022E6:  MOVF   xD8,W
022E8:  MOVLB  3
022EA:  SUBWF  x5F,W
022EC:  BNC   230E
022EE:  BNZ   2300
022F0:  MOVF   x5E,W
022F2:  MOVLB  0
022F4:  SUBWF  xD7,W
022F6:  BTFSS  FD8.0
022F8:  BRA    22FE
022FA:  MOVLB  3
022FC:  BRA    230E
022FE:  MOVLB  3
....................          { 
....................             len = MyTCB.wRemoteMSS; 
02300:  MOVFF  D8,35F
02304:  MOVFF  D7,35E
....................             MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
02308:  MOVLB  1
0230A:  BSF    x30.2
0230C:  MOVLB  3
....................          } 
....................  
....................          // Copy application data into the raw TX buffer 
....................          TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER), TCP_ETH_RAM, MyTCB.txUnackedTail, MyTCBStub.vMemoryMedium, len); 
0230E:  MOVLW  12
02310:  MOVWF  x68
02312:  MOVLW  0D
02314:  MOVWF  x67
02316:  CLRF   x69
02318:  MOVFF  C1,36B
0231C:  MOVFF  C0,36A
02320:  MOVFF  133,36C
02324:  MOVFF  35F,36E
02328:  MOVFF  35E,36D
0232C:  MOVLB  0
0232E:  CALL   11B0
....................          MyTCB.txUnackedTail += len; 
02332:  MOVLB  3
02334:  MOVF   x5E,W
02336:  MOVLB  0
02338:  ADDWF  xC0,F
0233A:  MOVLB  3
0233C:  MOVF   x5F,W
0233E:  MOVLB  0
02340:  ADDWFC xC1,F
....................       } 
02342:  BRA    24A4
02344:  MOVLB  1
....................       else 
....................       { 
....................          pseudoHeader.Length = MyTCBStub.bufferRxStart - MyTCB.txUnackedTail; 
02346:  MOVLB  0
02348:  MOVF   xC0,W
0234A:  MOVLB  1
0234C:  SUBWF  x1A,W
0234E:  MOVLB  3
02350:  MOVWF  x5C
02352:  MOVLB  0
02354:  MOVF   xC1,W
02356:  MOVLB  1
02358:  SUBWFB x1B,W
0235A:  MOVLB  3
0235C:  MOVWF  x5D
....................          len = pseudoHeader.Length + MyTCBStub.txHead - MyTCBStub.bufferTxStart; 
0235E:  MOVLB  1
02360:  MOVF   x1E,W
02362:  MOVLB  3
02364:  ADDWF  x5C,W
02366:  MOVWF  x60
02368:  MOVLB  1
0236A:  MOVF   x1F,W
0236C:  MOVLB  3
0236E:  ADDWFC x5D,W
02370:  MOVWF  x61
02372:  MOVLB  1
02374:  MOVF   x18,W
02376:  MOVLB  3
02378:  SUBWF  x60,W
0237A:  MOVWF  x5E
0237C:  MOVLB  1
0237E:  MOVF   x19,W
02380:  MOVLB  3
02382:  SUBWFB x61,W
02384:  MOVWF  x5F
....................  
....................          if(len > MyTCB.remoteWindow) 
02386:  MOVLB  0
02388:  MOVF   xC7,W
0238A:  MOVLB  3
0238C:  SUBWF  x5F,W
0238E:  BNC   23AA
02390:  BNZ   23A2
02392:  MOVF   x5E,W
02394:  MOVLB  0
02396:  SUBWF  xC6,W
02398:  BTFSS  FD8.0
0239A:  BRA    23A0
0239C:  MOVLB  3
0239E:  BRA    23AA
023A0:  MOVLB  3
....................             len = MyTCB.remoteWindow; 
023A2:  MOVFF  C7,35F
023A6:  MOVFF  C6,35E
....................  
....................          if(len > MyTCB.wRemoteMSS) 
023AA:  MOVLB  0
023AC:  MOVF   xD8,W
023AE:  MOVLB  3
023B0:  SUBWF  x5F,W
023B2:  BNC   23D4
023B4:  BNZ   23C6
023B6:  MOVF   x5E,W
023B8:  MOVLB  0
023BA:  SUBWF  xD7,W
023BC:  BTFSS  FD8.0
023BE:  BRA    23C4
023C0:  MOVLB  3
023C2:  BRA    23D4
023C4:  MOVLB  3
....................          { 
....................             len = MyTCB.wRemoteMSS; 
023C6:  MOVFF  D8,35F
023CA:  MOVFF  D7,35E
....................             MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
023CE:  MOVLB  1
023D0:  BSF    x30.2
023D2:  MOVLB  3
....................          } 
....................  
....................          if(pseudoHeader.Length > len) 
023D4:  MOVF   x5F,W
023D6:  SUBWF  x5D,W
023D8:  BNC   23EA
023DA:  BNZ   23E2
023DC:  MOVF   x5C,W
023DE:  SUBWF  x5E,W
023E0:  BC    23EA
....................             pseudoHeader.Length = len; 
023E2:  MOVFF  35F,35D
023E6:  MOVFF  35E,35C
....................  
....................          // Copy application data into the raw TX buffer 
....................          TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER), TCP_ETH_RAM, MyTCB.txUnackedTail, MyTCBStub.vMemoryMedium, pseudoHeader.Length); 
023EA:  MOVLW  12
023EC:  MOVWF  x68
023EE:  MOVLW  0D
023F0:  MOVWF  x67
023F2:  CLRF   x69
023F4:  MOVFF  C1,36B
023F8:  MOVFF  C0,36A
023FC:  MOVFF  133,36C
02400:  MOVFF  35D,36E
02404:  MOVFF  35C,36D
02408:  MOVLB  0
0240A:  CALL   11B0
....................          pseudoHeader.Length = len - pseudoHeader.Length; 
0240E:  MOVLB  3
02410:  MOVF   x5C,W
02412:  SUBWF  x5E,W
02414:  MOVWF  x5C
02416:  MOVF   x5D,W
02418:  SUBWFB x5F,W
0241A:  MOVWF  x5D
....................     
....................          // Copy any left over chunks of application data over 
....................          if(pseudoHeader.Length) 
0241C:  MOVF   x5C,W
0241E:  IORWF  x5D,W
02420:  BZ    2468
....................          { 
....................             TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER)+(MyTCBStub.bufferRxStart-MyTCB.txUnackedTail), TCP_ETH_RAM, MyTCBStub.bufferTxStart, MyTCBStub.vMemoryMedium, pseudoHeader.Length); 
02422:  MOVLB  0
02424:  MOVF   xC0,W
02426:  MOVLB  1
02428:  SUBWF  x1A,W
0242A:  MOVWF  00
0242C:  MOVLB  0
0242E:  MOVF   xC1,W
02430:  MOVLB  1
02432:  SUBWFB x1B,W
02434:  MOVWF  03
02436:  MOVF   00,W
02438:  ADDLW  0D
0243A:  MOVLB  3
0243C:  MOVWF  x60
0243E:  MOVLW  12
02440:  ADDWFC 03,W
02442:  MOVWF  x61
02444:  MOVWF  x68
02446:  MOVFF  360,367
0244A:  CLRF   x69
0244C:  MOVFF  119,36B
02450:  MOVFF  118,36A
02454:  MOVFF  133,36C
02458:  MOVFF  35D,36E
0245C:  MOVFF  35C,36D
02460:  MOVLB  0
02462:  CALL   11B0
02466:  MOVLB  3
....................          } 
....................  
....................          MyTCB.txUnackedTail += len; 
02468:  MOVF   x5E,W
0246A:  MOVLB  0
0246C:  ADDWF  xC0,F
0246E:  MOVLB  3
02470:  MOVF   x5F,W
02472:  MOVLB  0
02474:  ADDWFC xC1,F
....................          if(MyTCB.txUnackedTail >= MyTCBStub.bufferRxStart) 
02476:  MOVLB  1
02478:  MOVF   x1B,W
0247A:  MOVLB  0
0247C:  SUBWF  xC1,W
0247E:  BNC   24A4
02480:  BNZ   248C
02482:  MOVLB  1
02484:  MOVF   x1A,W
02486:  MOVLB  0
02488:  SUBWF  xC0,W
0248A:  BNC   24A4
....................             MyTCB.txUnackedTail -= MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart; 
0248C:  MOVLB  1
0248E:  MOVF   x18,W
02490:  SUBWF  x1A,W
02492:  MOVWF  00
02494:  MOVF   x19,W
02496:  SUBWFB x1B,W
02498:  MOVWF  03
0249A:  MOVF   00,W
0249C:  MOVLB  0
0249E:  SUBWF  xC0,F
024A0:  MOVF   03,W
024A2:  SUBWFB xC1,F
024A4:  MOVLB  3
....................       } 
....................  
....................       // If we are to transmit a FIN, make sure we can put one in this packet 
....................       if(MyTCBStub.Flags.bTXFIN) 
024A6:  MOVLB  1
024A8:  BTFSS  x30.3
024AA:  BRA    24D8
....................       { 
....................          if((len != MyTCB.remoteWindow) && (len != MyTCB.wRemoteMSS)) 
024AC:  MOVLB  0
024AE:  MOVF   xC6,W
024B0:  MOVLB  3
024B2:  SUBWF  x5E,W
024B4:  BNZ   24C0
024B6:  MOVLB  0
024B8:  MOVF   xC7,W
024BA:  MOVLB  3
024BC:  SUBWF  x5F,W
024BE:  BZ    24D6
024C0:  MOVLB  0
024C2:  MOVF   xD7,W
024C4:  MOVLB  3
024C6:  SUBWF  x5E,W
024C8:  BNZ   24D4
024CA:  MOVLB  0
024CC:  MOVF   xD8,W
024CE:  MOVLB  3
024D0:  SUBWF  x5F,W
024D2:  BZ    24D6
....................             vTCPFlags |= FIN; 
024D4:  BSF    x36.0
024D6:  MOVLB  1
....................       } 
....................    } 
....................  
....................    // Ensure that all packets with data of some kind are  
....................    // retransmitted by TCPTick() until acknowledged 
....................    // Pure ACK packets with no data are not ACKed back in TCP 
....................    if(len || (vTCPFlags & (SYN | FIN))) 
024D8:  MOVLB  3
024DA:  MOVF   x5E,W
024DC:  IORWF  x5F,W
024DE:  BNZ   24E6
024E0:  MOVF   x36,W
024E2:  ANDLW  03
024E4:  BZ    254E
....................    { 
....................       // Transmitting data, update remote window variable to reflect smaller  
....................       // window. 
....................       MyTCB.remoteWindow -= len; 
024E6:  MOVF   x5E,W
024E8:  MOVLB  0
024EA:  SUBWF  xC6,F
024EC:  MOVLB  3
024EE:  MOVF   x5F,W
024F0:  MOVLB  0
024F2:  SUBWFB xC7,F
....................  
....................       // Push (PSH) all data for enhanced responsiveness on  
....................       // the remote end, especially with GUIs 
....................       if(len) 
024F4:  MOVLB  3
024F6:  MOVF   x5E,W
024F8:  IORWF  x5F,W
024FA:  BZ    24FE
....................          vTCPFlags |= PSH; 
024FC:  BSF    x36.3
....................  
....................       if(vSendFlags & SENDTCP_RESET_TIMERS) 
024FE:  BTFSS  x37.0
02500:  BRA    2514
....................       { 
....................          MyTCB.retryCount = 0; 
02502:  MOVLB  0
02504:  CLRF   xD9
....................          MyTCB.retryInterval = TCP_START_TIMEOUT_VAL; 
02506:  CLRF   xB7
02508:  CLRF   xB6
0250A:  MOVLW  98
0250C:  MOVWF  xB5
0250E:  MOVLW  97
02510:  MOVWF  xB4
02512:  MOVLB  3
....................       }    
....................  
....................       MyTCBStub.eventTime = TickGet() + MyTCB.retryInterval; 
02514:  MOVLB  0
02516:  CALL   1630
0251A:  MOVF   xB4,W
0251C:  MOVLB  3
0251E:  ADDWF  00,W
02520:  MOVLB  1
02522:  MOVWF  x26
02524:  MOVLB  0
02526:  MOVF   xB5,W
02528:  MOVLB  3
0252A:  ADDWFC 01,W
0252C:  MOVLB  1
0252E:  MOVWF  x27
02530:  MOVLB  0
02532:  MOVF   xB6,W
02534:  MOVLB  3
02536:  ADDWFC 02,W
02538:  MOVLB  1
0253A:  MOVWF  x28
0253C:  MOVLB  0
0253E:  MOVF   xB7,W
02540:  MOVLB  3
02542:  ADDWFC 03,W
02544:  MOVLB  1
02546:  MOVWF  x29
....................       MyTCBStub.Flags.bTimerEnabled = 1; 
02548:  BSF    x2F.4
....................    } 
0254A:  BRA    25D0
0254C:  MOVLB  3
....................    else if(vSendFlags & SENDTCP_KEEP_ALIVE) 
0254E:  BTFSS  x37.1
02550:  BRA    257C
....................    { 
....................       // Increment Keep Alive TX counter to handle disconnection if not response is returned 
....................       MyTCBStub.Flags.vUnackedKeepalives++; 
02552:  MOVLB  1
02554:  MOVF   x2F,W
02556:  ADDLW  01
02558:  ANDLW  07
0255A:  MOVWF  00
0255C:  MOVLW  F8
0255E:  ANDWF  x2F,W
02560:  IORWF  00,W
02562:  MOVWF  x2F
....................        
....................       // Generate a dummy byte 
....................       MyTCB.MySEQ -= 1; 
02564:  MOVLW  01
02566:  MOVLB  0
02568:  SUBWF  xB8,F
0256A:  MOVLW  00
0256C:  SUBWFB xB9,F
0256E:  SUBWFB xBA,F
02570:  SUBWFB xBB,F
....................       len = 1; 
02572:  MOVLB  3
02574:  CLRF   x5F
02576:  MOVLW  01
02578:  MOVWF  x5E
....................    } 
0257A:  BRA    25D2
....................    else if(MyTCBStub.Flags.bTimerEnabled)  
0257C:  MOVLB  1
0257E:  BTFSS  x2F.4
02580:  BRA    25D0
....................    { 
....................       // If we have data to transmit, but the remote RX window is zero,  
....................       // so we aren't transmitting any right now then make sure to not  
....................       // extend the retry counter or timer.  This will stall our TX  
....................       // with a periodic ACK sent to the remote node. 
....................       if(!(vSendFlags & SENDTCP_RESET_TIMERS)) 
02582:  MOVLB  3
02584:  BTFSC  x37.0
02586:  BRA    259C
....................       { 
....................          // Roll back retry counters since we can't send anything,  
....................          // but only if we incremented it in the first place 
....................          if(MyTCB.retryCount) 
02588:  MOVLB  0
0258A:  MOVF   xD9,F
0258C:  BZ    259A
....................          { 
....................             MyTCB.retryCount--; 
0258E:  DECF   xD9,F
....................             MyTCB.retryInterval >>= 1; 
02590:  BCF    FD8.0
02592:  RRCF   xB7,F
02594:  RRCF   xB6,F
02596:  RRCF   xB5,F
02598:  RRCF   xB4,F
0259A:  MOVLB  3
....................          } 
....................       } 
....................     
....................       MyTCBStub.eventTime = TickGet() + MyTCB.retryInterval; 
0259C:  MOVLB  0
0259E:  CALL   1630
025A2:  MOVF   xB4,W
025A4:  MOVLB  3
025A6:  ADDWF  00,W
025A8:  MOVLB  1
025AA:  MOVWF  x26
025AC:  MOVLB  0
025AE:  MOVF   xB5,W
025B0:  MOVLB  3
025B2:  ADDWFC 01,W
025B4:  MOVLB  1
025B6:  MOVWF  x27
025B8:  MOVLB  0
025BA:  MOVF   xB6,W
025BC:  MOVLB  3
025BE:  ADDWFC 02,W
025C0:  MOVLB  1
025C2:  MOVWF  x28
025C4:  MOVLB  0
025C6:  MOVF   xB7,W
025C8:  MOVLB  3
025CA:  ADDWFC 03,W
025CC:  MOVLB  1
025CE:  MOVWF  x29
025D0:  MOVLB  3
....................    } 
....................     
....................  
....................    header.SourcePort         = MyTCB.localPort.Val; 
025D2:  MOVFF  C5,33B
025D6:  MOVFF  C4,33A
....................    header.DestPort            = MyTCB.remotePort.Val; 
025DA:  MOVFF  C3,33D
025DE:  MOVFF  C2,33C
....................    header.SeqNumber         = MyTCB.MySEQ; 
025E2:  MOVFF  BB,341
025E6:  MOVFF  BA,340
025EA:  MOVFF  B9,33F
025EE:  MOVFF  B8,33E
....................    header.AckNumber         = MyTCB.RemoteSEQ; 
025F2:  MOVFF  BF,345
025F6:  MOVFF  BE,344
025FA:  MOVFF  BD,343
025FE:  MOVFF  BC,342
....................    header.Flags.bits.Reserved2   = 0; 
02602:  MOVLW  3F
02604:  ANDWF  x47,W
02606:  MOVWF  x47
....................    header.DataOffset.Reserved3   = 0; 
02608:  MOVLW  F0
0260A:  ANDWF  x46,W
0260C:  MOVWF  x46
....................    header.Flags.byte         = vTCPFlags; 
0260E:  MOVFF  336,347
....................    header.UrgentPointer        = 0; 
02612:  CLRF   x4D
02614:  CLRF   x4C
....................  
....................    // Update our send sequence number and ensure retransmissions  
....................    // of SYNs and FINs use the right sequence number 
....................    MyTCB.MySEQ += (DWORD)len; 
02616:  MOVFF  35F,01
0261A:  CLRF   02
0261C:  CLRF   03
0261E:  MOVF   x5E,W
02620:  MOVLB  0
02622:  ADDWF  xB8,F
02624:  MOVF   01,W
02626:  ADDWFC xB9,F
02628:  MOVF   02,W
0262A:  ADDWFC xBA,F
0262C:  MOVF   03,W
0262E:  ADDWFC xBB,F
....................    if(vTCPFlags & SYN) 
02630:  MOVLB  3
02632:  BTFSS  x36.1
02634:  BRA    2672
....................    { 
....................       // SEG.ACK needs to be zero for the first SYN packet for compatibility  
....................       // with certain paranoid TCP/IP stacks, even though the ACK flag isn't  
....................       // set (indicating that the AckNumber field is unused). 
....................       if(!(vTCPFlags & ACK)) 
02636:  BTFSC  x36.4
02638:  BRA    2642
....................          header.AckNumber = 0x00000000; 
0263A:  CLRF   x45
0263C:  CLRF   x44
0263E:  CLRF   x43
02640:  CLRF   x42
....................  
....................       if(MyTCB.flags.bSYNSent) 
02642:  MOVLB  0
02644:  BTFSS  xD6.1
02646:  BRA    265E
....................          header.SeqNumber--; 
02648:  MOVLW  FF
0264A:  MOVLB  3
0264C:  ADDWF  x3E,F
0264E:  BTFSS  FD8.0
02650:  ADDWF  x3F,F
02652:  BTFSS  FD8.0
02654:  ADDWF  x40,F
02656:  BTFSS  FD8.0
02658:  ADDWF  x41,F
0265A:  BRA    2672
0265C:  MOVLB  0
....................       else 
....................       { 
....................          MyTCB.MySEQ++; 
0265E:  MOVLW  01
02660:  ADDWF  xB8,F
02662:  BTFSC  FD8.0
02664:  INCF   xB9,F
02666:  BTFSC  FD8.2
02668:  INCF   xBA,F
0266A:  BTFSC  FD8.2
0266C:  INCF   xBB,F
....................          MyTCB.flags.bSYNSent = 1; 
0266E:  BSF    xD6.1
02670:  MOVLB  3
....................       } 
....................    } 
....................    if(vTCPFlags & FIN) 
02672:  BTFSS  x36.0
02674:  BRA    267C
....................    { 
....................         MyTCB.flags.bFINSent = 1;   // do not advance the seq no for FIN! 
02676:  MOVLB  0
02678:  BSF    xD6.0
0267A:  MOVLB  3
....................    } 
....................  
....................    // Calculate the amount of free space in the RX buffer area of this socket 
....................    if(MyTCBStub.rxHead >= MyTCBStub.rxTail) 
0267C:  MOVLB  1
0267E:  MOVF   x25,W
02680:  SUBWF  x23,W
02682:  BNC   26BE
02684:  BNZ   268C
02686:  MOVF   x24,W
02688:  SUBWF  x22,W
0268A:  BNC   26BE
....................       header.Window = (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart) - (MyTCBStub.rxHead - MyTCBStub.rxTail); 
0268C:  MOVF   x1A,W
0268E:  SUBWF  x1C,W
02690:  MOVLB  3
02692:  MOVWF  x60
02694:  MOVLB  1
02696:  MOVF   x1B,W
02698:  SUBWFB x1D,W
0269A:  MOVLB  3
0269C:  MOVWF  x61
0269E:  MOVLB  1
026A0:  MOVF   x24,W
026A2:  SUBWF  x22,W
026A4:  MOVWF  00
026A6:  MOVF   x25,W
026A8:  SUBWFB x23,W
026AA:  MOVWF  03
026AC:  MOVF   00,W
026AE:  MOVLB  3
026B0:  SUBWF  x60,W
026B2:  MOVWF  x48
026B4:  MOVF   03,W
026B6:  SUBWFB x61,W
026B8:  MOVWF  x49
026BA:  BRA    26DC
026BC:  MOVLB  1
....................    else 
....................       header.Window = MyTCBStub.rxTail - MyTCBStub.rxHead - 1; 
026BE:  MOVF   x22,W
026C0:  SUBWF  x24,W
026C2:  MOVLB  3
026C4:  MOVWF  x60
026C6:  MOVLB  1
026C8:  MOVF   x23,W
026CA:  SUBWFB x25,W
026CC:  MOVLB  3
026CE:  MOVWF  x61
026D0:  MOVLW  01
026D2:  SUBWF  x60,W
026D4:  MOVWF  x48
026D6:  MOVLW  00
026D8:  SUBWFB x61,W
026DA:  MOVWF  x49
....................  
....................    // Calculate the amount of free space in the MAC RX buffer area and adjust window if needed 
....................    wVal.Val = MACGetFreeRxSize(); 
026DC:  MOVLB  0
026DE:  GOTO   167E
026E2:  MOVFF  02,339
026E6:  MOVFF  01,338
....................    if(wVal.Val < 64) 
026EA:  MOVLB  3
026EC:  MOVF   x39,F
026EE:  BNZ   26FC
026F0:  MOVF   x38,W
026F2:  SUBLW  3F
026F4:  BNC   26FC
....................     { 
....................       wVal.Val = 0; 
026F6:  CLRF   x39
026F8:  CLRF   x38
....................     } 
026FA:  BRA    2704
....................     else 
....................     { 
....................       wVal.Val -= 64; 
026FC:  MOVLW  40
026FE:  SUBWF  x38,F
02700:  MOVLW  00
02702:  SUBWFB x39,F
....................     } 
....................    // Force the remote node to throttle back if we are running low on general RX buffer space 
....................    if(header.Window > wVal.Val) 
02704:  MOVF   x39,W
02706:  SUBWF  x49,W
02708:  BNC   271A
0270A:  BNZ   2712
0270C:  MOVF   x48,W
0270E:  SUBWF  x38,W
02710:  BC    271A
....................       header.Window = wVal.Val; 
02712:  MOVFF  339,349
02716:  MOVFF  338,348
....................  
....................    SwapTCPHeader(&header); 
0271A:  MOVLW  03
0271C:  MOVWF  x61
0271E:  MOVLW  3A
02720:  MOVWF  x60
02722:  MOVLB  0
02724:  CALL   192E
....................  
....................  
....................    len += sizeof(header); 
02728:  MOVLW  14
0272A:  MOVLB  3
0272C:  ADDWF  x5E,F
0272E:  MOVLW  00
02730:  ADDWFC x5F,F
....................    header.DataOffset.Val   = sizeof(header) >> 2; 
02732:  MOVLW  0F
02734:  ANDWF  x46,W
02736:  IORLW  50
02738:  MOVWF  x46
....................  
....................    // Insert the MSS (Maximum Segment Size) TCP option if this is SYN packet 
....................    if(vTCPFlags & SYN) 
0273A:  BTFSS  x36.1
0273C:  BRA    276C
....................    { 
....................       len += sizeof(options); 
0273E:  MOVLW  04
02740:  ADDWF  x5E,F
02742:  MOVLW  00
02744:  ADDWFC x5F,F
....................       options.Kind = TCP_OPTIONS_MAX_SEG_SIZE; 
02746:  MOVLW  02
02748:  MOVWF  x4E
....................       options.Length = 0x04; 
0274A:  MOVLW  04
0274C:  MOVWF  x4F
....................  
....................       // Load MSS and swap to big endian 
....................       options.MaxSegSize.Val = (((TCP_MAX_SEG_SIZE_RX)&0x00FF)<<8) | (((TCP_MAX_SEG_SIZE_RX)&0xFF00)>>8); 
0274E:  MOVLW  18
02750:  MOVWF  x51
02752:  MOVLW  02
02754:  MOVWF  x50
....................  
....................      #if defined(__PCD__)  //__PCD__ __PCH__ __CCS__ bug 
....................       unsigned int8 scr8; 
....................       scr8 = header.DataOffset.Val; 
....................       scr8 += sizeof(options) >> 2; 
....................       header.DataOffset.Val = scr8; 
....................      #else  //standard code 
....................       header.DataOffset.Val   += sizeof(options) >> 2; 
02756:  SWAPF  x46,W
02758:  ANDLW  0F
0275A:  ADDLW  01
0275C:  MOVWF  00
0275E:  SWAPF  00,W
02760:  ANDLW  F0
02762:  MOVWF  00
02764:  MOVLW  0F
02766:  ANDWF  x46,W
02768:  IORWF  00,W
0276A:  MOVWF  x46
....................      #endif 
....................    } 
....................  
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress   = AppConfig.MyIPAddr; 
0276C:  MOVFF  2C,355
02770:  MOVFF  2B,354
02774:  MOVFF  2A,353
02778:  MOVFF  29,352
....................    pseudoHeader.DestAddress    = MyTCB.remote.niRemoteMACIP.IPAddr; 
0277C:  MOVFF  CD,359
02780:  MOVFF  CC,358
02784:  MOVFF  CB,357
02788:  MOVFF  CA,356
....................    pseudoHeader.Zero           = 0x0; 
0278C:  CLRF   x5A
....................    pseudoHeader.Protocol       = IP_PROT_TCP; 
0278E:  MOVLW  06
02790:  MOVWF  x5B
....................    pseudoHeader.Length         = len; 
02792:  MOVFF  35F,35D
02796:  MOVFF  35E,35C
....................    SwapPseudoHeader(pseudoHeader); 
0279A:  MOVFF  35D,380
0279E:  MOVFF  35C,37F
027A2:  MOVLB  0
027A4:  CALL   1796
027A8:  MOVFF  02,35D
027AC:  MOVFF  01,35C
....................    header.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader, sizeof(pseudoHeader)); 
027B0:  MOVLW  03
027B2:  MOVLB  3
027B4:  MOVWF  x61
027B6:  MOVLW  52
027B8:  MOVWF  x60
027BA:  MOVFF  361,37C
027BE:  MOVWF  x7B
027C0:  CLRF   x7E
027C2:  MOVLW  0C
027C4:  MOVWF  x7D
027C6:  MOVLB  0
027C8:  CALL   1B4A
027CC:  MOVFF  01,34A
027D0:  MOVLB  3
027D2:  COMF   x4A,F
027D4:  MOVFF  02,34B
027D8:  COMF   x4B,F
....................  
....................    // Write IP header 
....................    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER)); 
027DA:  MOVLW  11
027DC:  MOVWF  x70
027DE:  MOVLW  E5
027E0:  MOVWF  x6F
027E2:  MOVLB  0
027E4:  CALL   0D46
....................    IPPutHeader(&MyTCB.remote.niRemoteMACIP, IP_PROT_TCP, len); 
027E8:  MOVLB  3
027EA:  CLRF   x61
027EC:  MOVLW  CA
027EE:  MOVWF  x60
027F0:  MOVLW  06
027F2:  MOVWF  x62
027F4:  MOVFF  35F,364
027F8:  MOVFF  35E,363
027FC:  MOVLB  0
027FE:  CALL   1DD2
....................    MACPutArray((BYTE*)&header, sizeof(header)); 
02802:  MOVLW  03
02804:  MOVLB  3
02806:  MOVWF  x61
02808:  MOVLW  3A
0280A:  MOVWF  x60
0280C:  MOVFF  361,385
02810:  MOVWF  x84
02812:  CLRF   x87
02814:  MOVLW  14
02816:  MOVWF  x86
02818:  MOVLB  0
0281A:  CALL   0DB6
....................    if(vTCPFlags & SYN) 
0281E:  MOVLB  3
02820:  BTFSS  x36.1
02822:  BRA    2840
....................       MACPutArray((BYTE*)&options, sizeof(options)); 
02824:  MOVLW  03
02826:  MOVWF  x61
02828:  MOVLW  4E
0282A:  MOVWF  x60
0282C:  MOVFF  361,385
02830:  MOVWF  x84
02832:  CLRF   x87
02834:  MOVLW  04
02836:  MOVWF  x86
02838:  MOVLB  0
0283A:  CALL   0DB6
0283E:  MOVLB  3
....................  
....................    // Update the TCP checksum 
....................    MACSetReadPtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER)); 
02840:  MOVLW  11
02842:  MOVWF  x70
02844:  MOVLW  F9
02846:  MOVWF  x6F
02848:  MOVLB  0
0284A:  CALL   0DFC
....................    wVal.Val = CalcIPBufferChecksum(len); 
0284E:  MOVFF  35F,361
02852:  MOVFF  35E,360
02856:  CALL   1EBC
0285A:  MOVFF  02,339
0285E:  MOVFF  01,338
.................... #if defined(DEBUG_GENERATE_TX_LOSS) 
....................    // Damage TCP checksums on TX packets randomly 
....................    if(LFSRRand() > DEBUG_GENERATE_TX_LOSS) 
....................    { 
....................       wVal.Val++; 
....................    } 
.................... #endif 
....................    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER) + 16); 
02862:  MOVLW  12
02864:  MOVLB  3
02866:  MOVWF  x70
02868:  MOVLW  09
0286A:  MOVWF  x6F
0286C:  MOVLB  0
0286E:  CALL   0D46
....................    MACPutArray((BYTE*)&wVal, sizeof(WORD)); 
02872:  MOVLW  03
02874:  MOVLB  3
02876:  MOVWF  x61
02878:  MOVLW  38
0287A:  MOVWF  x60
0287C:  MOVFF  361,385
02880:  MOVWF  x84
02882:  CLRF   x87
02884:  MOVLW  02
02886:  MOVWF  x86
02888:  MOVLB  0
0288A:  CALL   0DB6
....................  
....................    // Physically start the packet transmission over the network 
....................    MACFlush(); 
0288E:  CALL   2004
02892:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static BOOL FindMatchingTCPSocket(TCP_HEADER* h, NODE_INFO* remote) 
....................  
....................   Summary: 
....................    Finds a suitable socket for a TCP segment. 
....................  
....................   Description: 
....................    This function searches through the sockets and attempts to match one with 
....................    a given TCP header and NODE_INFO structure.  If a socket is found, its  
....................    index is saved in hCurrentTCP and the associated MyTCBStub and MyTCB are 
....................    loaded. Otherwise, INVALID_SOCKET is placed in hCurrentTCP. 
....................     
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    h - TCP header to be matched against 
....................    remote - The remote node who sent this header 
....................  
....................   Return Values: 
....................    TRUE - A match was found and is loaded in hCurrentTCP 
....................    FALSE - No suitable socket was found and hCurrentTCP is INVALID_SOCKET 
....................   ***************************************************************************/ 
.................... static BOOL FindMatchingTCPSocket(TCP_HEADER* h, NODE_INFO* remote) 
.................... { 
....................    TCP_SOCKET hTCP; 
....................    TCP_SOCKET partialMatch; 
....................    WORD hash; 
....................  
....................    // Prevent connections on invalid port 0 
....................    if(h->DestPort == 0u) 
*
03F26:  MOVLW  02
03F28:  MOVLB  3
03F2A:  ADDWF  x16,W
03F2C:  MOVWF  FE9
03F2E:  MOVLW  00
03F30:  ADDWFC x17,W
03F32:  MOVWF  FEA
03F34:  MOVFF  FEC,321
03F38:  MOVF   FED,F
03F3A:  MOVFF  FEF,320
03F3E:  MOVF   x20,F
03F40:  BNZ   3F4C
03F42:  MOVF   x21,F
03F44:  BNZ   3F4C
....................       return FALSE; 
03F46:  MOVLW  00
03F48:  MOVWF  01
03F4A:  BRA    4548
....................  
....................    partialMatch = INVALID_SOCKET; 
03F4C:  MOVLW  FE
03F4E:  MOVWF  x1B
....................    hash = (remote->IPAddr.w[1]+remote->IPAddr.w[0] + h->SourcePort) ^ h->DestPort; 
03F50:  MOVLW  02
03F52:  ADDWF  x18,W
03F54:  MOVWF  FE9
03F56:  MOVLW  00
03F58:  ADDWFC x19,W
03F5A:  MOVWF  FEA
03F5C:  MOVFF  FEC,321
03F60:  MOVF   FED,F
03F62:  MOVFF  FEF,320
03F66:  MOVFF  318,FE9
03F6A:  MOVFF  319,FEA
03F6E:  MOVFF  FEC,03
03F72:  MOVF   FED,F
03F74:  MOVF   FEF,W
03F76:  ADDWF  x20,F
03F78:  MOVF   03,W
03F7A:  ADDWFC x21,F
03F7C:  MOVFF  316,FE9
03F80:  MOVFF  317,FEA
03F84:  MOVFF  FEC,03
03F88:  MOVF   FED,F
03F8A:  MOVF   FEF,W
03F8C:  ADDWF  x20,F
03F8E:  MOVF   03,W
03F90:  ADDWFC x21,F
03F92:  MOVLW  02
03F94:  ADDWF  x16,W
03F96:  MOVWF  FE9
03F98:  MOVLW  00
03F9A:  ADDWFC x17,W
03F9C:  MOVWF  FEA
03F9E:  MOVFF  FEC,03
03FA2:  MOVF   FED,F
03FA4:  MOVF   FEF,W
03FA6:  XORWF  x20,W
03FA8:  MOVWF  x1C
03FAA:  MOVF   03,W
03FAC:  XORWF  x21,W
03FAE:  MOVWF  x1D
....................  
....................    // Loop through all sockets looking for a socket that is expecting this  
....................    // packet or can handle it. 
....................    for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++ ) 
03FB0:  CLRF   x1A
03FB2:  MOVF   x1A,F
03FB4:  BTFSS  FD8.2
03FB6:  BRA    40BA
....................    { 
....................       SyncTCBStub(hTCP); 
03FB8:  MOVFF  31A,321
03FBC:  MOVLB  0
03FBE:  CALL   0CA6
....................  
....................       if(MyTCBStub.smState == TCP_CLOSED) 
03FC2:  MOVLB  1
03FC4:  MOVF   x2E,W
03FC6:  SUBLW  0D
03FC8:  BNZ   3FCE
....................       { 
....................          continue; 
03FCA:  BRA    40B4
....................       } 
03FCC:  BRA    4014
....................       else if(MyTCBStub.smState == TCP_LISTEN) 
03FCE:  MOVF   x2E,W
03FD0:  SUBLW  04
03FD2:  BNZ   3FFE
....................       {// For listening ports, check if this is the correct port 
....................          if(MyTCBStub.remoteHash.Val == h->DestPort) 
03FD4:  MOVLW  02
03FD6:  MOVLB  3
03FD8:  ADDWF  x16,W
03FDA:  MOVWF  FE9
03FDC:  MOVLW  00
03FDE:  ADDWFC x17,W
03FE0:  MOVWF  FEA
03FE2:  MOVFF  FEC,03
03FE6:  MOVF   FED,F
03FE8:  MOVF   FEF,W
03FEA:  MOVLB  1
03FEC:  SUBWF  x31,W
03FEE:  BNZ   3FFA
03FF0:  MOVF   03,W
03FF2:  SUBWF  x32,W
03FF4:  BNZ   3FFA
....................             partialMatch = hTCP; 
03FF6:  MOVFF  31A,31B
....................           
....................          #if defined(STACK_USE_SSL_SERVER) 
....................          // Check the SSL port as well for SSL Servers 
....................          // 0 is defined as an invalid port number 
....................          if(MyTCBStub.sslTxHead == h->DestPort) 
....................             partialMatch = hTCP; 
....................          #endif 
....................           
....................          continue; 
03FFA:  BRA    40B4
....................       } 
03FFC:  BRA    4014
....................       else if(MyTCBStub.remoteHash.Val != hash) 
03FFE:  MOVLB  3
04000:  MOVF   x1C,W
04002:  MOVLB  1
04004:  SUBWF  x31,W
04006:  BNZ   4012
04008:  MOVLB  3
0400A:  MOVF   x1D,W
0400C:  MOVLB  1
0400E:  SUBWF  x32,W
04010:  BZ    4014
....................       {// Ignore if the hash doesn't match 
....................          continue; 
04012:  BRA    40B4
....................       } 
....................  
....................       SyncTCB(); 
04014:  MOVLB  0
04016:  CALL   1296
....................       if(   h->DestPort == MyTCB.localPort.Val && 
....................          h->SourcePort == MyTCB.remotePort.Val && 
....................          remote->IPAddr.Val == MyTCB.remote.niRemoteMACIP.IPAddr.Val) 
0401A:  MOVLW  02
0401C:  MOVLB  3
0401E:  ADDWF  x16,W
04020:  MOVWF  FE9
04022:  MOVLW  00
04024:  ADDWFC x17,W
04026:  MOVWF  FEA
04028:  MOVFF  FEC,321
0402C:  MOVF   FED,F
0402E:  MOVFF  FEF,320
04032:  MOVLB  0
04034:  MOVF   xC4,W
04036:  MOVLB  3
04038:  SUBWF  x20,W
0403A:  BNZ   40B2
0403C:  MOVLB  0
0403E:  MOVF   xC5,W
04040:  MOVLB  3
04042:  SUBWF  x21,W
04044:  BNZ   40B2
04046:  MOVFF  316,FE9
0404A:  MOVFF  317,FEA
0404E:  MOVFF  FEC,321
04052:  MOVF   FED,F
04054:  MOVFF  FEF,320
04058:  MOVLB  0
0405A:  MOVF   xC2,W
0405C:  MOVLB  3
0405E:  SUBWF  x20,W
04060:  BNZ   40B2
04062:  MOVLB  0
04064:  MOVF   xC3,W
04066:  MOVLB  3
04068:  SUBWF  x21,W
0406A:  BNZ   40B2
0406C:  MOVFF  318,FE9
04070:  MOVFF  319,FEA
04074:  MOVFF  FEF,320
04078:  MOVFF  FEC,321
0407C:  MOVFF  FEC,322
04080:  MOVFF  FEC,323
04084:  MOVLB  0
04086:  MOVF   xCA,W
04088:  MOVLB  3
0408A:  SUBWF  x20,W
0408C:  BNZ   40B2
0408E:  MOVLB  0
04090:  MOVF   xCB,W
04092:  MOVLB  3
04094:  SUBWF  x21,W
04096:  BNZ   40B2
04098:  MOVLB  0
0409A:  MOVF   xCC,W
0409C:  MOVLB  3
0409E:  SUBWF  x22,W
040A0:  BNZ   40B2
040A2:  MOVLB  0
040A4:  MOVF   xCD,W
040A6:  MOVLB  3
040A8:  SUBWF  x23,W
040AA:  BNZ   40B2
....................       { 
....................          return TRUE; 
040AC:  MOVLW  01
040AE:  MOVWF  01
040B0:  BRA    4548
040B2:  MOVLB  1
....................       } 
040B4:  MOVLB  3
040B6:  INCF   x1A,F
040B8:  BRA    3FB2
....................    } 
....................  
....................  
....................    // If there is a partial match, then a listening socket is currently  
....................    // available.  Set up the extended TCB with the info needed  
....................    // to establish a connection and return this socket to the  
....................    // caller. 
....................    if(partialMatch != INVALID_SOCKET) 
040BA:  MOVF   x1B,W
040BC:  SUBLW  FE
040BE:  BZ    4132
....................    { 
....................       SyncTCBStub(partialMatch); 
040C0:  MOVFF  31B,321
040C4:  MOVLB  0
040C6:  CALL   0CA6
....................       SyncTCB(); 
040CA:  CALL   1296
....................     
....................       // For SSL ports, begin the SSL Handshake 
....................       #if defined(STACK_USE_SSL_SERVER) 
....................       if(MyTCBStub.sslTxHead == h->DestPort) 
....................       { 
....................          // Try to start an SSL session.  If no stubs are available, 
....................          // we can't service this request right now, so ignore it. 
....................          if(!TCPStartSSLServer(partialMatch)) 
....................             partialMatch = INVALID_SOCKET; 
....................       } 
....................       #endif 
....................     
....................       // Make sure the above check didn't fail (this is unfortunately  
....................       // redundant for non-SSL sockets).  Otherwise, fall out to below 
....................       // and add to the SYN queue. 
....................       if(partialMatch != INVALID_SOCKET) 
040CE:  MOVLB  3
040D0:  MOVF   x1B,W
040D2:  SUBLW  FE
040D4:  BZ    4132
....................       { 
....................          MyTCBStub.remoteHash.Val = hash; 
040D6:  MOVFF  31D,132
040DA:  MOVFF  31C,131
....................        
....................          memcpy((void*)&MyTCB.remote, (void*)remote, sizeof(NODE_INFO)); 
040DE:  CLRF   x21
040E0:  MOVLW  CA
040E2:  MOVFF  321,FEA
040E6:  MOVWF  FE9
040E8:  MOVFF  319,FE2
040EC:  MOVFF  318,FE1
040F0:  MOVLW  0A
040F2:  MOVWF  01
040F4:  MOVFF  FE6,FEE
040F8:  DECFSZ 01,F
040FA:  BRA    40F4
....................          MyTCB.remotePort.Val = h->SourcePort; 
040FC:  MOVFF  316,FE9
04100:  MOVFF  317,FEA
04104:  MOVFF  FEC,C3
04108:  MOVF   FED,F
0410A:  MOVFF  FEF,C2
....................          MyTCB.localPort.Val = h->DestPort; 
0410E:  MOVLW  02
04110:  ADDWF  x16,W
04112:  MOVWF  FE9
04114:  MOVLW  00
04116:  ADDWFC x17,W
04118:  MOVWF  FEA
0411A:  MOVFF  FEC,C5
0411E:  MOVF   FED,F
04120:  MOVFF  FEF,C4
....................          MyTCB.txUnackedTail   = MyTCBStub.bufferTxStart; 
04124:  MOVFF  119,C1
04128:  MOVFF  118,C0
....................        
....................          // All done, and we have a match 
....................          return TRUE; 
0412C:  MOVLW  01
0412E:  MOVWF  01
04130:  BRA    4548
....................       } 
....................    } 
....................  
....................    // No available sockets are listening on this port.  (Or, for 
....................    // SSL requests, perhaps no SSL sessions were available.  However, 
....................    // there may be a server socket which is currently busy but  
....................    // could handle this packet, so we should check. 
....................    #if TCP_SYN_QUEUE_MAX_ENTRIES 
....................    { 
....................       WORD wQueueInsertPos; 
....................        
....................       // See if this is a SYN packet 
....................       if(!h->Flags.bits.flagSYN) 
04132:  MOVLW  0D
04134:  ADDWF  x16,W
04136:  MOVWF  FE9
04138:  MOVLW  00
0413A:  ADDWFC x17,W
0413C:  MOVWF  FEA
0413E:  BTFSC  FEF.1
04140:  BRA    4148
....................          return FALSE; 
04142:  MOVLW  00
04144:  MOVWF  01
04146:  BRA    4548
....................  
....................       // See if there is space in our SYN queue 
....................       if(SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort) 
04148:  MOVLB  1
0414A:  MOVF   x14,W
0414C:  IORWF  x15,W
0414E:  BZ    415A
....................          return FALSE; 
04150:  MOVLW  00
04152:  MOVWF  01
04154:  MOVLB  3
04156:  BRA    4548
04158:  MOVLB  1
....................        
....................       // See if we have this SYN already in our SYN queue. 
....................       // If not already in the queue, find out where we  
....................       // should insert this SYN to the queue 
....................       for(wQueueInsertPos = 0; wQueueInsertPos < TCP_SYN_QUEUE_MAX_ENTRIES; wQueueInsertPos++) 
0415A:  MOVLB  3
0415C:  CLRF   x1F
0415E:  CLRF   x1E
04160:  MOVF   x1F,F
04162:  BTFSS  FD8.2
04164:  BRA    4332
04166:  MOVF   x1E,W
04168:  SUBLW  02
0416A:  BTFSS  FD8.0
0416C:  BRA    4332
....................       { 
....................          // Exit loop if we found a free record 
....................          if(SYNQueue[wQueueInsertPos].wDestPort == 0u) 
0416E:  MOVFF  31F,321
04172:  MOVFF  31E,320
04176:  CLRF   x23
04178:  MOVLW  14
0417A:  MOVWF  x22
0417C:  MOVLB  0
0417E:  CALL   2B50
04182:  MOVFF  01,320
04186:  MOVLW  10
04188:  MOVLB  3
0418A:  ADDWF  01,W
0418C:  MOVWF  01
0418E:  MOVLW  00
04190:  ADDWFC 02,W
04192:  MOVWF  03
04194:  MOVF   01,W
04196:  ADDLW  DC
04198:  MOVWF  FE9
0419A:  MOVLW  00
0419C:  ADDWFC 03,W
0419E:  MOVWF  FEA
041A0:  MOVFF  FEC,321
041A4:  MOVF   FED,F
041A6:  MOVFF  FEF,320
041AA:  MOVF   x20,F
041AC:  BNZ   41B4
041AE:  MOVF   x21,F
041B0:  BNZ   41B4
....................             break; 
041B2:  BRA    4332
....................  
....................          // Check if this SYN packet is already in the SYN queue 
....................          if(SYNQueue[wQueueInsertPos].wDestPort != h->DestPort) 
041B4:  MOVFF  31F,321
041B8:  MOVFF  31E,320
041BC:  CLRF   x23
041BE:  MOVLW  14
041C0:  MOVWF  x22
041C2:  MOVLB  0
041C4:  CALL   2B50
041C8:  MOVFF  01,320
041CC:  MOVLW  10
041CE:  MOVLB  3
041D0:  ADDWF  01,W
041D2:  MOVWF  01
041D4:  MOVLW  00
041D6:  ADDWFC 02,W
041D8:  MOVWF  03
041DA:  MOVF   01,W
041DC:  ADDLW  DC
041DE:  MOVWF  FE9
041E0:  MOVLW  00
041E2:  ADDWFC 03,W
041E4:  MOVWF  FEA
041E6:  MOVFF  FEC,321
041EA:  MOVF   FED,F
041EC:  MOVFF  FEF,320
041F0:  MOVLW  02
041F2:  ADDWF  x16,W
041F4:  MOVWF  FE9
041F6:  MOVLW  00
041F8:  ADDWFC x17,W
041FA:  MOVWF  FEA
041FC:  MOVFF  FEC,03
04200:  MOVF   FED,F
04202:  MOVF   FEF,W
04204:  SUBWF  x20,W
04206:  BNZ   420E
04208:  MOVF   03,W
0420A:  SUBWF  x21,W
0420C:  BZ    4210
....................             continue; 
0420E:  BRA    432A
....................          if(SYNQueue[wQueueInsertPos].wSourcePort != h->SourcePort) 
04210:  MOVFF  31F,321
04214:  MOVFF  31E,320
04218:  CLRF   x23
0421A:  MOVLW  14
0421C:  MOVWF  x22
0421E:  MOVLB  0
04220:  CALL   2B50
04224:  MOVFF  01,320
04228:  MOVLW  0A
0422A:  MOVLB  3
0422C:  ADDWF  01,W
0422E:  MOVWF  01
04230:  MOVLW  00
04232:  ADDWFC 02,W
04234:  MOVWF  03
04236:  MOVF   01,W
04238:  ADDLW  DC
0423A:  MOVWF  FE9
0423C:  MOVLW  00
0423E:  ADDWFC 03,W
04240:  MOVWF  FEA
04242:  MOVFF  FEC,321
04246:  MOVF   FED,F
04248:  MOVFF  FEF,320
0424C:  MOVFF  316,FE9
04250:  MOVFF  317,FEA
04254:  MOVFF  FEC,03
04258:  MOVF   FED,F
0425A:  MOVF   FEF,W
0425C:  SUBWF  x20,W
0425E:  BNZ   4266
04260:  MOVF   03,W
04262:  SUBWF  x21,W
04264:  BZ    4268
....................             continue; 
04266:  BRA    432A
....................          if(SYNQueue[wQueueInsertPos].niSourceAddress.IPAddr.Val != remote->IPAddr.Val) 
04268:  MOVFF  31F,321
0426C:  MOVFF  31E,320
04270:  CLRF   x23
04272:  MOVLW  14
04274:  MOVWF  x22
04276:  MOVLB  0
04278:  CALL   2B50
0427C:  MOVFF  02,321
04280:  MOVFF  01,320
04284:  MOVLW  DC
04286:  MOVLB  3
04288:  ADDWF  01,W
0428A:  MOVWF  FE9
0428C:  MOVLW  00
0428E:  ADDWFC 02,W
04290:  MOVWF  FEA
04292:  MOVFF  FEF,322
04296:  MOVFF  FEC,323
0429A:  MOVFF  FEC,324
0429E:  MOVFF  FEC,325
042A2:  MOVFF  318,FE9
042A6:  MOVFF  319,FEA
042AA:  MOVFF  FEF,00
042AE:  MOVFF  FEC,01
042B2:  MOVFF  FEC,02
042B6:  MOVFF  FEC,03
042BA:  MOVF   00,W
042BC:  SUBWF  x22,W
042BE:  BNZ   42D2
042C0:  MOVF   01,W
042C2:  SUBWF  x23,W
042C4:  BNZ   42D2
042C6:  MOVF   02,W
042C8:  SUBWF  x24,W
042CA:  BNZ   42D2
042CC:  MOVF   03,W
042CE:  SUBWF  x25,W
042D0:  BZ    42D4
....................             continue; 
042D2:  BRA    432A
....................  
....................          // SYN matches SYN queue entry.  Update timestamp and do nothing. 
....................          SYNQueue[wQueueInsertPos].wTimestamp = TickGetDiv256(); 
042D4:  MOVFF  31F,321
042D8:  MOVFF  31E,320
042DC:  CLRF   x23
042DE:  MOVLW  14
042E0:  MOVWF  x22
042E2:  MOVLB  0
042E4:  CALL   2B50
042E8:  MOVFF  01,320
042EC:  MOVLW  12
042EE:  MOVLB  3
042F0:  ADDWF  01,W
042F2:  MOVWF  01
042F4:  MOVLW  00
042F6:  ADDWFC 02,W
042F8:  MOVWF  03
042FA:  MOVF   01,W
042FC:  ADDLW  DC
042FE:  MOVWF  01
04300:  MOVLW  00
04302:  ADDWFC 03,F
04304:  MOVFF  01,320
04308:  MOVFF  03,321
0430C:  MOVLB  0
0430E:  CALL   2B2A
04312:  MOVFF  321,FEA
04316:  MOVFF  320,FE9
0431A:  MOVFF  00,FEF
0431E:  MOVFF  01,FEC
....................          return FALSE; 
04322:  MOVLW  00
04324:  MOVWF  01
04326:  MOVLB  3
04328:  BRA    4548
0432A:  INCF   x1E,F
0432C:  BTFSC  FD8.2
0432E:  INCF   x1F,F
04330:  BRA    4160
....................       } 
....................        
....................       // Check to see if we have any server sockets which  
....................       // are currently connected, but could handle this SYN  
....................       // request at a later time if the client disconnects. 
....................       for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++) 
04332:  CLRF   x1A
04334:  MOVF   x1A,F
04336:  BTFSS  FD8.2
04338:  BRA    4544
....................       { 
....................          SyncTCBStub(hTCP); 
0433A:  MOVFF  31A,321
0433E:  MOVLB  0
04340:  CALL   0CA6
....................          if(!MyTCBStub.Flags.bServer) 
04344:  MOVLB  1
04346:  BTFSC  x2F.3
04348:  BRA    434C
....................             continue; 
0434A:  BRA    453E
....................  
....................          SyncTCB(); 
0434C:  MOVLB  0
0434E:  CALL   1296
....................          #if defined(STACK_USE_SSL_SERVER) 
....................          if((MyTCB.localPort.Val != h->DestPort) && (MyTCB.localSSLPort.Val != h->DestPort)) 
....................          #else 
....................          if(MyTCB.localPort.Val != h->DestPort) 
04352:  MOVLW  02
04354:  MOVLB  3
04356:  ADDWF  x16,W
04358:  MOVWF  FE9
0435A:  MOVLW  00
0435C:  ADDWFC x17,W
0435E:  MOVWF  FEA
04360:  MOVFF  FEC,03
04364:  MOVF   FED,F
04366:  MOVF   FEF,W
04368:  MOVLB  0
0436A:  SUBWF  xC4,W
0436C:  BNZ   4374
0436E:  MOVF   03,W
04370:  SUBWF  xC5,W
04372:  BZ    437A
....................          #endif 
....................             continue; 
04374:  MOVLB  1
04376:  BRA    453E
04378:  MOVLB  0
....................  
....................          // Generate the SYN queue entry 
....................          memcpy((void*)&SYNQueue[wQueueInsertPos].niSourceAddress, (void*)remote, sizeof(NODE_INFO)); 
0437A:  MOVFF  31F,321
0437E:  MOVFF  31E,320
04382:  MOVLB  3
04384:  CLRF   x23
04386:  MOVLW  14
04388:  MOVWF  x22
0438A:  MOVLB  0
0438C:  CALL   2B50
04390:  MOVFF  02,321
04394:  MOVFF  01,320
04398:  MOVLW  DC
0439A:  MOVLB  3
0439C:  ADDWF  01,W
0439E:  MOVWF  01
043A0:  MOVLW  00
043A2:  ADDWFC 02,W
043A4:  MOVWF  03
043A6:  MOVFF  01,322
043AA:  MOVWF  x23
043AC:  MOVWF  FEA
043AE:  MOVFF  01,FE9
043B2:  MOVFF  319,FE2
043B6:  MOVFF  318,FE1
043BA:  MOVLW  0A
043BC:  MOVWF  01
043BE:  MOVFF  FE6,FEE
043C2:  DECFSZ 01,F
043C4:  BRA    43BE
....................          SYNQueue[wQueueInsertPos].wSourcePort = h->SourcePort; 
043C6:  MOVFF  31F,321
043CA:  MOVFF  31E,320
043CE:  CLRF   x23
043D0:  MOVLW  14
043D2:  MOVWF  x22
043D4:  MOVLB  0
043D6:  CALL   2B50
043DA:  MOVFF  01,320
043DE:  MOVLW  0A
043E0:  MOVLB  3
043E2:  ADDWF  01,W
043E4:  MOVWF  01
043E6:  MOVLW  00
043E8:  ADDWFC 02,W
043EA:  MOVWF  03
043EC:  MOVF   01,W
043EE:  ADDLW  DC
043F0:  MOVWF  01
043F2:  MOVLW  00
043F4:  ADDWFC 03,F
043F6:  MOVFF  03,321
043FA:  MOVFF  316,FE9
043FE:  MOVFF  317,FEA
04402:  MOVFF  FEC,03
04406:  MOVF   FED,F
04408:  MOVFF  FEF,322
0440C:  MOVFF  321,FEA
04410:  MOVFF  01,FE9
04414:  MOVFF  03,FEC
04418:  MOVF   FED,F
0441A:  MOVFF  322,FEF
....................          SYNQueue[wQueueInsertPos].dwSourceSEQ = h->SeqNumber; 
0441E:  MOVFF  31F,321
04422:  MOVFF  31E,320
04426:  CLRF   x23
04428:  MOVLW  14
0442A:  MOVWF  x22
0442C:  MOVLB  0
0442E:  CALL   2B50
04432:  MOVFF  01,320
04436:  MOVLW  0C
04438:  MOVLB  3
0443A:  ADDWF  01,W
0443C:  MOVWF  01
0443E:  MOVLW  00
04440:  ADDWFC 02,W
04442:  MOVWF  03
04444:  MOVF   01,W
04446:  ADDLW  DC
04448:  MOVWF  01
0444A:  MOVLW  00
0444C:  ADDWFC 03,F
0444E:  MOVFF  01,320
04452:  MOVFF  03,321
04456:  MOVLW  04
04458:  ADDWF  x16,W
0445A:  MOVWF  FE9
0445C:  MOVLW  00
0445E:  ADDWFC x17,W
04460:  MOVWF  FEA
04462:  MOVFF  FEF,00
04466:  MOVFF  FEC,01
0446A:  MOVFF  FEC,02
0446E:  MOVFF  FEC,03
04472:  MOVFF  321,FEA
04476:  MOVFF  320,FE9
0447A:  MOVFF  00,FEF
0447E:  MOVFF  01,FEC
04482:  MOVFF  02,FEC
04486:  MOVFF  03,FEC
....................          SYNQueue[wQueueInsertPos].wDestPort = h->DestPort; 
0448A:  MOVFF  31F,321
0448E:  MOVFF  31E,320
04492:  CLRF   x23
04494:  MOVLW  14
04496:  MOVWF  x22
04498:  MOVLB  0
0449A:  CALL   2B50
0449E:  MOVFF  01,320
044A2:  MOVLW  10
044A4:  MOVLB  3
044A6:  ADDWF  01,W
044A8:  MOVWF  01
044AA:  MOVLW  00
044AC:  ADDWFC 02,W
044AE:  MOVWF  03
044B0:  MOVF   01,W
044B2:  ADDLW  DC
044B4:  MOVWF  01
044B6:  MOVLW  00
044B8:  ADDWFC 03,F
044BA:  MOVFF  03,321
044BE:  MOVLW  02
044C0:  ADDWF  x16,W
044C2:  MOVWF  FE9
044C4:  MOVLW  00
044C6:  ADDWFC x17,W
044C8:  MOVWF  FEA
044CA:  MOVFF  FEC,03
044CE:  MOVF   FED,F
044D0:  MOVFF  FEF,322
044D4:  MOVFF  321,FEA
044D8:  MOVFF  01,FE9
044DC:  MOVFF  03,FEC
044E0:  MOVF   FED,F
044E2:  MOVFF  322,FEF
....................          SYNQueue[wQueueInsertPos].wTimestamp = TickGetDiv256(); 
044E6:  MOVFF  31F,321
044EA:  MOVFF  31E,320
044EE:  CLRF   x23
044F0:  MOVLW  14
044F2:  MOVWF  x22
044F4:  MOVLB  0
044F6:  CALL   2B50
044FA:  MOVFF  01,320
044FE:  MOVLW  12
04500:  MOVLB  3
04502:  ADDWF  01,W
04504:  MOVWF  01
04506:  MOVLW  00
04508:  ADDWFC 02,W
0450A:  MOVWF  03
0450C:  MOVF   01,W
0450E:  ADDLW  DC
04510:  MOVWF  01
04512:  MOVLW  00
04514:  ADDWFC 03,F
04516:  MOVFF  01,320
0451A:  MOVFF  03,321
0451E:  MOVLB  0
04520:  CALL   2B2A
04524:  MOVFF  321,FEA
04528:  MOVFF  320,FE9
0452C:  MOVFF  00,FEF
04530:  MOVFF  01,FEC
....................  
....................          return FALSE; 
04534:  MOVLW  00
04536:  MOVWF  01
04538:  MOVLB  3
0453A:  BRA    4548
0453C:  MOVLB  1
0453E:  MOVLB  3
04540:  INCF   x1A,F
04542:  BRA    4334
....................       } 
....................    } 
....................    #endif 
....................        
....................    return FALSE; 
04544:  MOVLW  00
04546:  MOVWF  01
04548:  MOVLB  0
0454A:  GOTO   59F8 (RETURN)
....................  
.................... } 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void SwapTCPHeader(TCP_HEADER* header) 
....................  
....................   Summary: 
....................    Swaps endian-ness of a TCP header. 
....................  
....................   Description: 
....................    This function swaps the endian-ness of a given TCP header for comparison. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    header - The TCP header that is to be swapped 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... static void SwapTCPHeader(TCP_HEADER* header) 
.................... { 
....................    header->SourcePort      = swaps(header->SourcePort); 
*
0192E:  MOVLB  3
01930:  MOVFF  360,01
01934:  MOVFF  361,03
01938:  MOVFF  360,362
0193C:  MOVFF  361,363
01940:  MOVFF  360,FE9
01944:  MOVFF  361,FEA
01948:  MOVFF  FEC,365
0194C:  MOVF   FED,F
0194E:  MOVFF  FEF,364
01952:  MOVFF  365,380
01956:  MOVFF  364,37F
0195A:  MOVLB  0
0195C:  RCALL  1796
0195E:  MOVFF  363,FEA
01962:  MOVFF  362,FE9
01966:  MOVFF  02,FEC
0196A:  MOVF   FED,F
0196C:  MOVFF  01,FEF
....................    header->DestPort        = swaps(header->DestPort); 
01970:  MOVLW  02
01972:  MOVLB  3
01974:  ADDWF  x60,W
01976:  MOVWF  01
01978:  MOVLW  00
0197A:  ADDWFC x61,W
0197C:  MOVWF  03
0197E:  MOVFF  01,362
01982:  MOVWF  x63
01984:  MOVLW  02
01986:  ADDWF  x60,W
01988:  MOVWF  FE9
0198A:  MOVLW  00
0198C:  ADDWFC x61,W
0198E:  MOVWF  FEA
01990:  MOVFF  FEC,365
01994:  MOVF   FED,F
01996:  MOVFF  FEF,364
0199A:  MOVFF  365,380
0199E:  MOVFF  364,37F
019A2:  MOVLB  0
019A4:  RCALL  1796
019A6:  MOVFF  363,FEA
019AA:  MOVFF  362,FE9
019AE:  MOVFF  02,FEC
019B2:  MOVF   FED,F
019B4:  MOVFF  01,FEF
....................    header->SeqNumber       = swapl(header->SeqNumber); 
019B8:  MOVLW  04
019BA:  MOVLB  3
019BC:  ADDWF  x60,W
019BE:  MOVWF  01
019C0:  MOVLW  00
019C2:  ADDWFC x61,W
019C4:  MOVWF  03
019C6:  MOVFF  01,362
019CA:  MOVWF  x63
019CC:  MOVLW  04
019CE:  ADDWF  x60,W
019D0:  MOVWF  FE9
019D2:  MOVLW  00
019D4:  ADDWFC x61,W
019D6:  MOVWF  FEA
019D8:  MOVFF  FEF,364
019DC:  MOVFF  FEC,365
019E0:  MOVFF  FEC,366
019E4:  MOVFF  FEC,367
019E8:  MOVFF  367,36B
019EC:  MOVFF  366,36A
019F0:  MOVFF  365,369
019F4:  MOVFF  364,368
019F8:  MOVLB  0
019FA:  RCALL  17B8
019FC:  MOVFF  363,FEA
01A00:  MOVFF  362,FE9
01A04:  MOVFF  00,FEF
01A08:  MOVFF  01,FEC
01A0C:  MOVFF  02,FEC
01A10:  MOVFF  03,FEC
....................    header->AckNumber       = swapl(header->AckNumber); 
01A14:  MOVLW  08
01A16:  MOVLB  3
01A18:  ADDWF  x60,W
01A1A:  MOVWF  01
01A1C:  MOVLW  00
01A1E:  ADDWFC x61,W
01A20:  MOVWF  03
01A22:  MOVFF  01,362
01A26:  MOVWF  x63
01A28:  MOVLW  08
01A2A:  ADDWF  x60,W
01A2C:  MOVWF  FE9
01A2E:  MOVLW  00
01A30:  ADDWFC x61,W
01A32:  MOVWF  FEA
01A34:  MOVFF  FEF,364
01A38:  MOVFF  FEC,365
01A3C:  MOVFF  FEC,366
01A40:  MOVFF  FEC,367
01A44:  MOVFF  367,36B
01A48:  MOVFF  366,36A
01A4C:  MOVFF  365,369
01A50:  MOVFF  364,368
01A54:  MOVLB  0
01A56:  RCALL  17B8
01A58:  MOVFF  363,FEA
01A5C:  MOVFF  362,FE9
01A60:  MOVFF  00,FEF
01A64:  MOVFF  01,FEC
01A68:  MOVFF  02,FEC
01A6C:  MOVFF  03,FEC
....................    header->Window          = swaps(header->Window); 
01A70:  MOVLW  0E
01A72:  MOVLB  3
01A74:  ADDWF  x60,W
01A76:  MOVWF  01
01A78:  MOVLW  00
01A7A:  ADDWFC x61,W
01A7C:  MOVWF  03
01A7E:  MOVFF  01,362
01A82:  MOVWF  x63
01A84:  MOVLW  0E
01A86:  ADDWF  x60,W
01A88:  MOVWF  FE9
01A8A:  MOVLW  00
01A8C:  ADDWFC x61,W
01A8E:  MOVWF  FEA
01A90:  MOVFF  FEC,365
01A94:  MOVF   FED,F
01A96:  MOVFF  FEF,364
01A9A:  MOVFF  365,380
01A9E:  MOVFF  364,37F
01AA2:  MOVLB  0
01AA4:  RCALL  1796
01AA6:  MOVFF  363,FEA
01AAA:  MOVFF  362,FE9
01AAE:  MOVFF  02,FEC
01AB2:  MOVF   FED,F
01AB4:  MOVFF  01,FEF
....................    header->Checksum        = swaps(header->Checksum); 
01AB8:  MOVLW  10
01ABA:  MOVLB  3
01ABC:  ADDWF  x60,W
01ABE:  MOVWF  01
01AC0:  MOVLW  00
01AC2:  ADDWFC x61,W
01AC4:  MOVWF  03
01AC6:  MOVFF  01,362
01ACA:  MOVWF  x63
01ACC:  MOVLW  10
01ACE:  ADDWF  x60,W
01AD0:  MOVWF  FE9
01AD2:  MOVLW  00
01AD4:  ADDWFC x61,W
01AD6:  MOVWF  FEA
01AD8:  MOVFF  FEC,365
01ADC:  MOVF   FED,F
01ADE:  MOVFF  FEF,364
01AE2:  MOVFF  365,380
01AE6:  MOVFF  364,37F
01AEA:  MOVLB  0
01AEC:  RCALL  1796
01AEE:  MOVFF  363,FEA
01AF2:  MOVFF  362,FE9
01AF6:  MOVFF  02,FEC
01AFA:  MOVF   FED,F
01AFC:  MOVFF  01,FEF
....................    header->UrgentPointer   = swaps(header->UrgentPointer); 
01B00:  MOVLW  12
01B02:  MOVLB  3
01B04:  ADDWF  x60,W
01B06:  MOVWF  01
01B08:  MOVLW  00
01B0A:  ADDWFC x61,W
01B0C:  MOVWF  03
01B0E:  MOVFF  01,362
01B12:  MOVWF  x63
01B14:  MOVLW  12
01B16:  ADDWF  x60,W
01B18:  MOVWF  FE9
01B1A:  MOVLW  00
01B1C:  ADDWFC x61,W
01B1E:  MOVWF  FEA
01B20:  MOVFF  FEC,365
01B24:  MOVF   FED,F
01B26:  MOVFF  FEF,364
01B2A:  MOVFF  365,380
01B2E:  MOVFF  364,37F
01B32:  MOVLB  0
01B34:  RCALL  1796
01B36:  MOVFF  363,FEA
01B3A:  MOVFF  362,FE9
01B3E:  MOVFF  02,FEC
01B42:  MOVF   FED,F
01B44:  MOVFF  01,FEF
01B48:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void CloseSocket(void) 
....................  
....................   Summary: 
....................    Closes a TCP socket. 
....................  
....................   Description: 
....................    This function closes a TCP socket.  All socket state information is  
....................    reset, and any buffered bytes are discarded.  The socket is no longer 
....................    accessible by the application after this point. 
....................  
....................   Precondition: 
....................    The TCPStub corresponding to the socket to be closed is synced. 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... static void CloseSocket(void) 
.................... { 
....................    SyncTCB(); 
*
0136A:  RCALL  1296
....................  
....................    MyTCBStub.remoteHash.Val = MyTCB.localPort.Val; 
0136C:  MOVFF  C5,132
01370:  MOVFF  C4,131
....................    MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
01374:  MOVFF  119,11F
01378:  MOVFF  118,11E
....................    MyTCBStub.txTail = MyTCBStub.bufferTxStart; 
0137C:  MOVFF  119,121
01380:  MOVFF  118,120
....................    MyTCBStub.rxHead = MyTCBStub.bufferRxStart; 
01384:  MOVFF  11B,123
01388:  MOVFF  11A,122
....................    MyTCBStub.rxTail = MyTCBStub.bufferRxStart; 
0138C:  MOVFF  11B,125
01390:  MOVFF  11A,124
....................    MyTCBStub.smState = MyTCBStub.Flags.bServer ? TCP_LISTEN : TCP_CLOSED; 
01394:  MOVLB  1
01396:  BTFSS  x2F.3
01398:  BRA    139E
0139A:  MOVLW  04
0139C:  BRA    13A0
0139E:  MOVLW  0D
013A0:  MOVWF  x2E
....................    MyTCBStub.Flags.vUnackedKeepalives = 0; 
013A2:  MOVLW  F8
013A4:  ANDWF  x2F,W
013A6:  MOVWF  x2F
....................    MyTCBStub.Flags.bTimerEnabled = 0; 
013A8:  BCF    x2F.4
....................    MyTCBStub.Flags.bTimer2Enabled = 0; 
013AA:  BCF    x2F.5
....................    MyTCBStub.Flags.bDelayedACKTimerEnabled = 0; 
013AC:  BCF    x2F.6
....................    MyTCBStub.Flags.bOneSegmentReceived = 0; 
013AE:  BCF    x2F.7
....................    MyTCBStub.Flags.bHalfFullFlush = 0; 
013B0:  BCF    x30.0
....................    MyTCBStub.Flags.bTXASAP = 0; 
013B2:  BCF    x30.1
....................    MyTCBStub.Flags.bTXASAPWithoutTimerReset = 0; 
013B4:  BCF    x30.2
....................    MyTCBStub.Flags.bTXFIN = 0; 
013B6:  BCF    x30.3
....................    MyTCBStub.Flags.bSocketReset = 1; 
013B8:  BSF    x30.4
....................  
....................    #if defined(STACK_USE_SSL) 
....................    // If SSL is active, then we need to close it 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    { 
....................       SSLTerminate(MyTCBStub.sslStubID); 
....................       MyTCBStub.sslStubID = SSL_INVALID_ID; 
....................  
....................       // Swap the SSL port and local port back to proper values 
....................       MyTCBStub.remoteHash.Val = MyTCB.localSSLPort.Val; 
....................       MyTCB.localSSLPort.Val = MyTCB.localPort.Val; 
....................       MyTCB.localPort.Val = MyTCBStub.remoteHash.Val; 
....................    } 
....................  
....................    // Reset the SSL buffer pointers 
....................    MyTCBStub.sslRxHead = MyTCBStub.bufferRxStart; 
....................    MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    #endif 
....................     
....................    #if defined(STACK_USE_SSL_SERVER) 
....................    MyTCBStub.sslTxHead = MyTCB.localSSLPort.Val; 
....................    #endif 
....................  
....................    MyTCB.flags.bFINSent = 0; 
013BA:  MOVLB  0
013BC:  BCF    xD6.0
....................    MyTCB.flags.bSYNSent = 0; 
013BE:  BCF    xD6.1
....................    MyTCB.flags.bRXNoneACKed1 = 0; 
013C0:  BCF    xD6.3
....................    MyTCB.flags.bRXNoneACKed2 = 0; 
013C2:  BCF    xD6.4
....................    MyTCB.txUnackedTail = MyTCBStub.bufferTxStart; 
013C4:  MOVFF  119,C1
013C8:  MOVFF  118,C0
....................    ((DWORD_VAL*)(&MyTCB.MySEQ))->w[0] = LFSRRand(); 
013CC:  MOVLB  3
013CE:  CLRF   x37
013D0:  MOVLW  B8
013D2:  MOVWF  x36
013D4:  MOVWF  01
013D6:  MOVFF  337,03
013DA:  MOVWF  x38
013DC:  MOVFF  337,339
013E0:  MOVLB  0
013E2:  CALL   0618
013E6:  MOVFF  339,FEA
013EA:  MOVFF  338,FE9
013EE:  MOVFF  02,FEC
013F2:  MOVF   FED,F
013F4:  MOVFF  01,FEF
....................    ((DWORD_VAL*)(&MyTCB.MySEQ))->w[1] = LFSRRand(); 
013F8:  MOVLB  3
013FA:  CLRF   x37
013FC:  MOVLW  B8
013FE:  MOVWF  x36
01400:  MOVLW  02
01402:  ADDWF  x36,W
01404:  MOVWF  01
01406:  MOVLW  00
01408:  ADDWFC x37,W
0140A:  MOVWF  03
0140C:  MOVFF  01,338
01410:  MOVWF  x39
01412:  MOVLB  0
01414:  CALL   0618
01418:  MOVFF  339,FEA
0141C:  MOVFF  338,FE9
01420:  MOVFF  02,FEC
01424:  MOVF   FED,F
01426:  MOVFF  01,FEF
....................    MyTCB.sHoleSize = -1; 
0142A:  SETF   xD5
0142C:  SETF   xD4
....................    MyTCB.remoteWindow = 1; 
0142E:  CLRF   xC7
01430:  MOVLW  01
01432:  MOVWF  xC6
01434:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static WORD GetMaxSegSizeOption(void) 
....................  
....................   Summary: 
....................    Obtains the Maximum Segment Size (MSS) TCP Option out of the TCP header  
....................    for the current socket. 
....................  
....................   Description: 
....................    Parses the current TCP packet header and extracts the Maximum Segment Size  
....................    option.   
....................  
....................   Precondition: 
....................    Must be called while a TCP packet is present and being processed via  
....................    HandleTCPSeg() and only if the the TCP SYN flag is set. 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................    Maximum segment size option value.  If illegal or not present, a failsafe  
....................    value of 536 is returned.  If the option is larger than the  
....................    TCP_MAX_SEG_SIZE_TX upper limit, then TCP_MAX_SEG_SIZE_TX is returned. 
....................  
....................   Remarks: 
....................    The internal MAC Read Pointer is moved but not restored. 
....................   ***************************************************************************/ 
.................... static WORD GetMaxSegSizeOption(void) 
.................... { 
....................    BYTE vOptionsBytes; 
....................    BYTE vOption; 
....................    WORD wMSS; 
....................  
....................    // Find out how many options bytes are in this packet. 
....................    IPSetRxBuffer(2+2+4+4);   // Seek to data offset field, skipping Source port (2), Destination port (2), Sequence number (4), and Acknowledgement number (4) 
*
0454E:  MOVLB  3
04550:  CLRF   x3B
04552:  MOVLW  0C
04554:  MOVWF  x3A
04556:  MOVLB  0
04558:  RCALL  3F0C
....................    vOptionsBytes = MACGet(); 
0455A:  CALL   0EDE
0455E:  MOVFF  01,336
....................    vOptionsBytes = ((vOptionsBytes&0xF0)>>2) - sizeof(TCP_HEADER); 
04562:  MOVLB  3
04564:  MOVF   x36,W
04566:  ANDLW  F0
04568:  MOVWF  00
0456A:  RRCF   00,F
0456C:  RRCF   00,F
0456E:  MOVLW  3F
04570:  ANDWF  00,F
04572:  MOVF   00,W
04574:  ADDLW  EC
04576:  MOVWF  x36
....................  
....................    // Return minimum Maximum Segment Size value of 536 bytes if none are  
....................    // present 
....................    if(vOptionsBytes == 0u) 
04578:  MOVF   x36,F
0457A:  BNZ   4586
....................       return 536; 
0457C:  MOVLW  18
0457E:  MOVWF  01
04580:  MOVLW  02
04582:  MOVWF  02
04584:  BRA    4666
....................        
....................    // Seek to beginning of options 
....................    MACGetArray(NULL, 7); 
04586:  CLRF   x83
04588:  CLRF   x82
0458A:  CLRF   x85
0458C:  MOVLW  07
0458E:  MOVWF  x84
04590:  MOVLB  0
04592:  CALL   0E68
....................  
....................    // Search for the Maximum Segment Size option    
....................    while(vOptionsBytes--) 
04596:  MOVLB  3
04598:  MOVF   x36,W
0459A:  DECF   x36,F
0459C:  XORLW  00
0459E:  BTFSC  FD8.2
045A0:  BRA    465E
....................    { 
....................       vOption = MACGet(); 
045A2:  MOVLB  0
045A4:  CALL   0EDE
045A8:  MOVFF  01,337
....................        
....................       if(vOption == 0u)   // End of Options list 
045AC:  MOVLB  3
045AE:  MOVF   x37,F
045B0:  BNZ   45B4
....................          break; 
045B2:  BRA    465E
....................        
....................       if(vOption == 1u)   // NOP option 
045B4:  DECFSZ x37,W
045B6:  BRA    45BA
....................          continue; 
045B8:  BRA    4598
....................           
....................       if(vOption == 2u)   // Maximum Segment Size option 
045BA:  MOVF   x37,W
045BC:  SUBLW  02
045BE:  BNZ   462A
....................       { 
....................          if(vOptionsBytes < 3u) 
045C0:  MOVF   x36,W
045C2:  SUBLW  02
045C4:  BNC   45C8
....................             break; 
045C6:  BRA    465E
....................  
....................          wMSS = 0; 
045C8:  CLRF   x39
045CA:  CLRF   x38
....................              
....................          // Get option length 
....................          vOption = MACGet(); 
045CC:  MOVLB  0
045CE:  CALL   0EDE
045D2:  MOVFF  01,337
....................          if(vOption == 4u) 
045D6:  MOVLB  3
045D8:  MOVF   x37,W
045DA:  SUBLW  04
045DC:  BNZ   45F2
....................          {// Retrieve MSS and swap value to little endian 
....................             ((BYTE*)&wMSS)[1] = MACGet(); 
045DE:  MOVLB  0
045E0:  CALL   0EDE
045E4:  MOVFF  01,339
....................             ((BYTE*)&wMSS)[0] = MACGet(); 
045E8:  CALL   0EDE
045EC:  MOVFF  01,338
045F0:  MOVLB  3
....................          } 
....................           
....................          if(wMSS < 536u) 
045F2:  MOVF   x39,W
045F4:  SUBLW  02
045F6:  BNC   4602
045F8:  BNZ   4600
045FA:  MOVF   x38,W
045FC:  SUBLW  17
045FE:  BNC   4602
....................             break; 
04600:  BRA    465E
....................          if(wMSS > TCP_MAX_SEG_SIZE_TX) 
04602:  MOVF   x39,W
04604:  SUBLW  04
04606:  BC    461E
04608:  XORLW  FF
0460A:  BNZ   4612
0460C:  MOVF   x38,W
0460E:  SUBLW  B4
04610:  BC    461E
....................             return TCP_MAX_SEG_SIZE_TX; 
04612:  MOVLW  B4
04614:  MOVWF  01
04616:  MOVLW  05
04618:  MOVWF  02
0461A:  BRA    4666
0461C:  BRA    4628
....................          else  
....................             return wMSS; 
0461E:  MOVFF  338,01
04622:  MOVFF  339,02
04626:  BRA    4666
....................       } 
04628:  BRA    465C
....................       else 
....................       { // Assume this is a multi byte option and throw it way 
....................          if(vOptionsBytes < 2u) 
0462A:  MOVF   x36,W
0462C:  SUBLW  01
0462E:  BNC   4632
....................             break; 
04630:  BRA    465E
....................          vOption = MACGet(); 
04632:  MOVLB  0
04634:  CALL   0EDE
04638:  MOVFF  01,337
....................          if(vOptionsBytes < vOption) 
0463C:  MOVLB  3
0463E:  MOVF   x37,W
04640:  SUBWF  x36,W
04642:  BC    4646
....................             break; 
04644:  BRA    465E
....................          MACGetArray(NULL, vOption); 
04646:  CLRF   x83
04648:  CLRF   x82
0464A:  CLRF   x85
0464C:  MOVFF  337,384
04650:  MOVLB  0
04652:  CALL   0E68
....................          vOptionsBytes -= vOption; 
04656:  MOVLB  3
04658:  MOVF   x37,W
0465A:  SUBWF  x36,F
....................       } 
0465C:  BRA    4598
....................        
....................    } 
....................     
....................    // Did not find MSS option, return worst case default 
....................    return 536; 
0465E:  MOVLW  18
04660:  MOVWF  01
04662:  MOVLW  02
04664:  MOVWF  02
04666:  MOVLB  0
04668:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void HandleTCPSeg(TCP_HEADER* h, WORD len) 
....................  
....................   Summary: 
....................    Processes an incoming TCP segment. 
....................  
....................   Description: 
....................    Once an incoming segment has been matched to a socket, this function 
....................    performs the necessary processing with the data.  Depending on the  
....................    segment and the state, this may include copying data to the TCP buffer, 
....................    re-assembling out-of order packets, continuing an initialization or  
....................    closing handshake, or closing the socket altogether. 
....................  
....................   Precondition: 
....................    TCP is initialized and the current TCP stub is already synced. 
....................  
....................   Parameters: 
....................    h - The TCP header for this packet 
....................    len - The total buffer length of this segment 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... static void HandleTCPSeg(TCP_HEADER* h, WORD len) 
.................... { 
....................    DWORD dwTemp; 
....................    PTR_BASE wTemp; 
....................    LONG lMissingBytes; 
....................    WORD wMissingBytes; 
....................    WORD wFreeSpace; 
....................    BYTE localHeaderFlags; 
....................    DWORD localAckNumber; 
....................    DWORD localSeqNumber; 
....................    WORD wSegmentLength; 
....................    BOOL bSegmentAcceptable; 
....................    WORD wNewWindow; 
....................  
....................  
....................    // Cache a few variables in local RAM.   
....................    // PIC18s take a fair amount of code and execution time to  
....................    // dereference pointers frequently. 
....................    localHeaderFlags = h->Flags.byte; 
0466A:  MOVLW  0D
0466C:  MOVLB  3
0466E:  ADDWF  x16,W
04670:  MOVWF  FE9
04672:  MOVLW  00
04674:  ADDWFC x17,W
04676:  MOVWF  FEA
04678:  MOVFF  FEF,328
....................    localAckNumber = h->AckNumber; 
0467C:  MOVLW  08
0467E:  ADDWF  x16,W
04680:  MOVWF  FE9
04682:  MOVLW  00
04684:  ADDWFC x17,W
04686:  MOVWF  FEA
04688:  MOVFF  FEF,329
0468C:  MOVFF  FEC,32A
04690:  MOVFF  FEC,32B
04694:  MOVFF  FEC,32C
....................    localSeqNumber = h->SeqNumber; 
04698:  MOVLW  04
0469A:  ADDWF  x16,W
0469C:  MOVWF  FE9
0469E:  MOVLW  00
046A0:  ADDWFC x17,W
046A2:  MOVWF  FEA
046A4:  MOVFF  FEF,32D
046A8:  MOVFF  FEC,32E
046AC:  MOVFF  FEC,32F
046B0:  MOVFF  FEC,330
....................  
....................    // We received a packet, reset the keep alive timer and count 
....................    #if defined(TCP_KEEP_ALIVE_TIMEOUT) 
....................       MyTCBStub.Flags.vUnackedKeepalives = 0; 
046B4:  MOVLW  F8
046B6:  MOVLB  1
046B8:  ANDWF  x2F,W
046BA:  MOVWF  x2F
....................       if(!MyTCBStub.Flags.bTimerEnabled) 
046BC:  BTFSC  x2F.4
046BE:  BRA    46EE
....................          MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
046C0:  MOVLB  0
046C2:  CALL   1630
046C6:  MOVLW  E6
046C8:  MOVLB  3
046CA:  ADDWF  00,W
046CC:  MOVLB  1
046CE:  MOVWF  x26
046D0:  MOVLW  F5
046D2:  MOVLB  3
046D4:  ADDWFC 01,W
046D6:  MOVLB  1
046D8:  MOVWF  x27
046DA:  MOVLW  05
046DC:  MOVLB  3
046DE:  ADDWFC 02,W
046E0:  MOVLB  1
046E2:  MOVWF  x28
046E4:  MOVLW  00
046E6:  MOVLB  3
046E8:  ADDWFC 03,W
046EA:  MOVLB  1
046EC:  MOVWF  x29
....................    #endif 
....................  
....................    // Handle TCP_LISTEN and TCP_SYN_SENT states 
....................    // Both of these states will return, so code following this  
....................    // state machine need not check explicitly for these two  
....................    // states. 
....................    switch(MyTCBStub.smState) 
046EE:  MOVF   x2E,W
046F0:  XORLW  04
046F2:  MOVLB  0
046F4:  BZ    46FC
046F6:  XORLW  01
046F8:  BZ    4794
046FA:  BRA    48CA
....................    { 
....................       case TCP_LISTEN: 
....................          // First: check RST flag 
....................          if(localHeaderFlags & RST) 
046FC:  MOVLB  3
046FE:  BTFSS  x28.2
04700:  BRA    470E
....................          { 
....................             CloseSocket();   // Unbind remote IP address/port info 
04702:  MOVLB  0
04704:  CALL   136A
....................             return; 
04708:  GOTO   5890
0470C:  MOVLB  3
....................          } 
....................  
....................          // Second: check ACK flag, which would be invalid 
....................          if(localHeaderFlags & ACK) 
0470E:  BTFSS  x28.4
04710:  BRA    4738
....................          { 
....................             // Use a believable sequence number and reset the remote node 
....................             MyTCB.MySEQ = localAckNumber; 
04712:  MOVFF  32C,BB
04716:  MOVFF  32B,BA
0471A:  MOVFF  32A,B9
0471E:  MOVFF  329,B8
....................             SendTCP(RST, 0); 
04722:  MOVLW  04
04724:  MOVWF  x36
04726:  CLRF   x37
04728:  MOVLB  0
0472A:  CALL   2238
....................             CloseSocket();   // Unbind remote IP address/port info 
0472E:  CALL   136A
....................             return; 
04732:  GOTO   5890
04736:  MOVLB  3
....................          } 
....................  
....................          // Third: check for SYN flag, which is what we're looking for 
....................          if(localHeaderFlags & SYN) 
04738:  BTFSS  x28.1
0473A:  BRA    4786
....................          { 
....................             // We now have a sequence number for the remote node 
....................             MyTCB.RemoteSEQ = localSeqNumber + 1; 
0473C:  MOVLW  01
0473E:  ADDWF  x2D,W
04740:  MOVLB  0
04742:  MOVWF  xBC
04744:  MOVLW  00
04746:  MOVLB  3
04748:  ADDWFC x2E,W
0474A:  MOVLB  0
0474C:  MOVWF  xBD
0474E:  MOVLW  00
04750:  MOVLB  3
04752:  ADDWFC x2F,W
04754:  MOVLB  0
04756:  MOVWF  xBE
04758:  MOVLW  00
0475A:  MOVLB  3
0475C:  ADDWFC x30,W
0475E:  MOVLB  0
04760:  MOVWF  xBF
....................  
....................             // Get MSS option 
....................             MyTCB.wRemoteMSS = GetMaxSegSizeOption(); 
04762:  RCALL  454E
04764:  MOVFF  02,D8
04768:  MOVFF  01,D7
....................  
....................             // Set Initial Send Sequence (ISS) number 
....................             // Nothing to do on this step... ISS already set in CloseSocket() 
....................              
....................             // Respond with SYN + ACK 
....................             SendTCP(SYN | ACK, SENDTCP_RESET_TIMERS); 
0476C:  MOVLW  12
0476E:  MOVLB  3
04770:  MOVWF  x36
04772:  MOVLW  01
04774:  MOVWF  x37
04776:  MOVLB  0
04778:  CALL   2238
....................             MyTCBStub.smState = TCP_SYN_RECEIVED; 
0477C:  MOVLW  06
0477E:  MOVLB  1
04780:  MOVWF  x2E
....................          } 
04782:  BRA    478E
04784:  MOVLB  3
....................          else 
....................          { 
....................             CloseSocket();   // Unbind remote IP address/port info 
04786:  MOVLB  0
04788:  CALL   136A
0478C:  MOVLB  1
....................          } 
....................  
....................          // Fourth: check for other text and control 
....................          // Nothing to do since we don't support this 
....................          return; 
0478E:  MOVLB  0
04790:  GOTO   5890
....................  
....................       case TCP_SYN_SENT: 
....................          // Second: check the RST bit 
....................          // This is out of order because this stack has no API for  
....................          // notifying the application that the connection seems to  
....................          // be failing.  Instead, the application must time out and  
....................          // the stack will just keep trying in the mean time. 
....................          if(localHeaderFlags & RST) 
04794:  MOVLB  3
04796:  BTFSS  x28.2
04798:  BRA    47A2
....................             return; 
0479A:  MOVLB  0
0479C:  GOTO   5890
047A0:  MOVLB  3
....................  
....................          // First: check ACK bit 
....................          if(localHeaderFlags & ACK) 
047A2:  BTFSS  x28.4
047A4:  BRA    4812
....................          { 
....................             if(localAckNumber != MyTCB.MySEQ) 
047A6:  MOVLB  0
047A8:  MOVF   xB8,W
047AA:  MOVLB  3
047AC:  SUBWF  x29,W
047AE:  BNZ   47CE
047B0:  MOVLB  0
047B2:  MOVF   xB9,W
047B4:  MOVLB  3
047B6:  SUBWF  x2A,W
047B8:  BNZ   47CE
047BA:  MOVLB  0
047BC:  MOVF   xBA,W
047BE:  MOVLB  3
047C0:  SUBWF  x2B,W
047C2:  BNZ   47CE
047C4:  MOVLB  0
047C6:  MOVF   xBB,W
047C8:  MOVLB  3
047CA:  SUBWF  x2C,W
047CC:  BZ    4812
....................             { 
....................                // Send a RST packet with SEQ = SEG.ACK, but retain our SEQ  
....................                // number for arivial of any other SYN+ACK packets 
....................                localSeqNumber = MyTCB.MySEQ;   // Save our original SEQ number 
047CE:  MOVFF  BB,330
047D2:  MOVFF  BA,32F
047D6:  MOVFF  B9,32E
047DA:  MOVFF  B8,32D
....................                MyTCB.MySEQ = localAckNumber;   // Set SEQ = SEG.ACK 
047DE:  MOVFF  32C,BB
047E2:  MOVFF  32B,BA
047E6:  MOVFF  32A,B9
047EA:  MOVFF  329,B8
....................                SendTCP(RST, SENDTCP_RESET_TIMERS);      // Send the RST 
047EE:  MOVLW  04
047F0:  MOVWF  x36
047F2:  MOVLW  01
047F4:  MOVWF  x37
047F6:  MOVLB  0
047F8:  CALL   2238
....................                MyTCB.MySEQ = localSeqNumber;   // Restore original SEQ number 
047FC:  MOVFF  330,BB
04800:  MOVFF  32F,BA
04804:  MOVFF  32E,B9
04808:  MOVFF  32D,B8
....................                return; 
0480C:  GOTO   5890
04810:  MOVLB  3
....................             } 
....................          } 
....................  
....................          // Third: check the security and precedence 
....................          // No such feature in this stack.  We want to accept all connections. 
....................  
....................          // Fourth: check the SYN bit 
....................          if(localHeaderFlags & SYN) 
04812:  BTFSS  x28.1
04814:  BRA    48C4
....................          { 
....................             // We now have an initial sequence number and window size 
....................             MyTCB.RemoteSEQ = localSeqNumber + 1; 
04816:  MOVLW  01
04818:  ADDWF  x2D,W
0481A:  MOVLB  0
0481C:  MOVWF  xBC
0481E:  MOVLW  00
04820:  MOVLB  3
04822:  ADDWFC x2E,W
04824:  MOVLB  0
04826:  MOVWF  xBD
04828:  MOVLW  00
0482A:  MOVLB  3
0482C:  ADDWFC x2F,W
0482E:  MOVLB  0
04830:  MOVWF  xBE
04832:  MOVLW  00
04834:  MOVLB  3
04836:  ADDWFC x30,W
04838:  MOVLB  0
0483A:  MOVWF  xBF
....................             MyTCB.remoteWindow = h->Window; 
0483C:  MOVLW  0E
0483E:  MOVLB  3
04840:  ADDWF  x16,W
04842:  MOVWF  FE9
04844:  MOVLW  00
04846:  ADDWFC x17,W
04848:  MOVWF  FEA
0484A:  MOVFF  FEC,C7
0484E:  MOVF   FED,F
04850:  MOVFF  FEF,C6
....................  
....................             // Get MSS option 
....................             MyTCB.wRemoteMSS = GetMaxSegSizeOption(); 
04854:  MOVLB  0
04856:  RCALL  454E
04858:  MOVFF  02,D8
0485C:  MOVFF  01,D7
....................  
....................             if(localHeaderFlags & ACK) 
04860:  MOVLB  3
04862:  BTFSS  x28.4
04864:  BRA    48AE
....................             { 
....................                SendTCP(ACK, SENDTCP_RESET_TIMERS); 
04866:  MOVLW  10
04868:  MOVWF  x36
0486A:  MOVLW  01
0486C:  MOVWF  x37
0486E:  MOVLB  0
04870:  CALL   2238
....................                MyTCBStub.smState = TCP_ESTABLISHED; 
04874:  MOVLW  07
04876:  MOVLB  1
04878:  MOVWF  x2E
....................                // Set up keep-alive timer 
....................                #if defined(TCP_KEEP_ALIVE_TIMEOUT) 
....................                   MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
0487A:  MOVLB  0
0487C:  CALL   1630
04880:  MOVLW  E6
04882:  MOVLB  3
04884:  ADDWF  00,W
04886:  MOVLB  1
04888:  MOVWF  x26
0488A:  MOVLW  F5
0488C:  MOVLB  3
0488E:  ADDWFC 01,W
04890:  MOVLB  1
04892:  MOVWF  x27
04894:  MOVLW  05
04896:  MOVLB  3
04898:  ADDWFC 02,W
0489A:  MOVLB  1
0489C:  MOVWF  x28
0489E:  MOVLW  00
048A0:  MOVLB  3
048A2:  ADDWFC 03,W
048A4:  MOVLB  1
048A6:  MOVWF  x29
....................                #endif 
....................                MyTCBStub.Flags.bTimerEnabled = 0; 
048A8:  BCF    x2F.4
....................             } 
048AA:  BRA    48C2
048AC:  MOVLB  3
....................             else 
....................             { 
....................                SendTCP(SYN | ACK, SENDTCP_RESET_TIMERS); 
048AE:  MOVLW  12
048B0:  MOVWF  x36
048B2:  MOVLW  01
048B4:  MOVWF  x37
048B6:  MOVLB  0
048B8:  CALL   2238
....................                MyTCBStub.smState = TCP_SYN_RECEIVED; 
048BC:  MOVLW  06
048BE:  MOVLB  1
048C0:  MOVWF  x2E
048C2:  MOVLB  3
....................             } 
....................          } 
....................  
....................          // Fifth: drop the segment if neither SYN or RST is set 
....................          return; 
048C4:  MOVLB  0
048C6:  GOTO   5890
....................  
....................       default: 
....................          break; 
....................    } 
....................  
....................    // 
....................    // First: check the sequence number 
....................    // 
....................    wSegmentLength = len; 
048CA:  MOVFF  319,332
048CE:  MOVFF  318,331
....................    if(localHeaderFlags & FIN) 
048D2:  MOVLB  3
048D4:  BTFSS  x28.0
048D6:  BRA    48DE
....................       wSegmentLength++; 
048D8:  INCF   x31,F
048DA:  BTFSC  FD8.2
048DC:  INCF   x32,F
....................    if(localHeaderFlags & SYN) 
048DE:  BTFSS  x28.1
048E0:  BRA    48E8
....................       wSegmentLength++; 
048E2:  INCF   x31,F
048E4:  BTFSC  FD8.2
048E6:  INCF   x32,F
....................  
....................    // Calculate the RX FIFO space 
....................    if(MyTCBStub.rxHead >= MyTCBStub.rxTail) 
048E8:  MOVLB  1
048EA:  MOVF   x25,W
048EC:  SUBWF  x23,W
048EE:  BNC   492A
048F0:  BNZ   48F8
048F2:  MOVF   x24,W
048F4:  SUBWF  x22,W
048F6:  BNC   492A
....................       wFreeSpace = (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart) - (MyTCBStub.rxHead - MyTCBStub.rxTail); 
048F8:  MOVF   x1A,W
048FA:  SUBWF  x1C,W
048FC:  MOVLB  3
048FE:  MOVWF  x36
04900:  MOVLB  1
04902:  MOVF   x1B,W
04904:  SUBWFB x1D,W
04906:  MOVLB  3
04908:  MOVWF  x37
0490A:  MOVLB  1
0490C:  MOVF   x24,W
0490E:  SUBWF  x22,W
04910:  MOVWF  00
04912:  MOVF   x25,W
04914:  SUBWFB x23,W
04916:  MOVWF  03
04918:  MOVF   00,W
0491A:  MOVLB  3
0491C:  SUBWF  x36,W
0491E:  MOVWF  x26
04920:  MOVF   03,W
04922:  SUBWFB x37,W
04924:  MOVWF  x27
04926:  BRA    4948
04928:  MOVLB  1
....................    else 
....................       wFreeSpace = MyTCBStub.rxTail - MyTCBStub.rxHead - 1; 
0492A:  MOVF   x22,W
0492C:  SUBWF  x24,W
0492E:  MOVLB  3
04930:  MOVWF  x36
04932:  MOVLB  1
04934:  MOVF   x23,W
04936:  SUBWFB x25,W
04938:  MOVLB  3
0493A:  MOVWF  x37
0493C:  MOVLW  01
0493E:  SUBWF  x36,W
04940:  MOVWF  x26
04942:  MOVLW  00
04944:  SUBWFB x37,W
04946:  MOVWF  x27
....................  
....................    // Calculate the number of bytes ahead of our head pointer this segment skips 
....................    lMissingBytes = localSeqNumber - MyTCB.RemoteSEQ; 
04948:  MOVLB  0
0494A:  MOVF   xBC,W
0494C:  MOVLB  3
0494E:  SUBWF  x2D,W
04950:  MOVWF  00
04952:  MOVLB  0
04954:  MOVF   xBD,W
04956:  MOVLB  3
04958:  SUBWFB x2E,W
0495A:  MOVWF  01
0495C:  MOVLB  0
0495E:  MOVF   xBE,W
04960:  MOVLB  3
04962:  SUBWFB x2F,W
04964:  MOVWF  02
04966:  MOVLB  0
04968:  MOVF   xBF,W
0496A:  MOVLB  3
0496C:  SUBWFB x30,W
0496E:  MOVWF  x23
04970:  MOVFF  02,322
04974:  MOVFF  01,321
04978:  MOVFF  00,320
....................    wMissingBytes = (WORD)lMissingBytes; 
0497C:  MOVFF  321,325
04980:  MOVFF  320,324
....................     
....................    // Run TCP acceptability tests to verify that this packet has a valid sequence number 
....................    bSegmentAcceptable = FALSE; 
04984:  BCF    x33.0
....................    if(wSegmentLength) 
04986:  MOVF   x31,W
04988:  IORWF  x32,W
0498A:  BTFSC  FD8.2
0498C:  BRA    4A90
....................    { 
....................       // Check to see if we have free space, and if so, if any of the data falls within the freespace 
....................       if(wFreeSpace) 
0498E:  MOVF   x26,W
04990:  IORWF  x27,W
04992:  BTFSC  FD8.2
04994:  BRA    4A8E
....................       { 
....................          // RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND 
....................          if((lMissingBytes >= (LONG)0) && (wFreeSpace > (DWORD)lMissingBytes)) 
04996:  BTFSC  x23.7
04998:  BRA    49B4
0499A:  MOVF   x23,F
0499C:  BNZ   49B4
0499E:  MOVF   x22,F
049A0:  BNZ   49B4
049A2:  MOVF   x21,W
049A4:  SUBWF  x27,W
049A6:  BNC   49B4
049A8:  BNZ   49B0
049AA:  MOVF   x26,W
049AC:  SUBWF  x20,W
049AE:  BC    49B4
....................             bSegmentAcceptable = TRUE; 
049B0:  BSF    x33.0
049B2:  BRA    4A3A
....................          else 
....................          { 
....................             // RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND 
....................             if((lMissingBytes + (LONG)wSegmentLength > (LONG)0) && (lMissingBytes <= (LONG)(SHORT)(wFreeSpace - wSegmentLength))) 
049B4:  MOVFF  331,00
049B8:  MOVFF  332,01
049BC:  CLRF   02
049BE:  CLRF   03
049C0:  MOVF   x31,W
049C2:  ADDWF  x20,W
049C4:  MOVWF  x36
049C6:  MOVF   x32,W
049C8:  ADDWFC x21,W
049CA:  MOVWF  x37
049CC:  MOVF   02,W
049CE:  ADDWFC x22,W
049D0:  MOVWF  x38
049D2:  MOVF   03,W
049D4:  ADDWFC x23,W
049D6:  MOVWF  x39
049D8:  BTFSC  FE8.7
049DA:  BRA    4A3A
049DC:  MOVF   x39,F
049DE:  BNZ   49EE
049E0:  MOVF   x38,F
049E2:  BNZ   49EE
049E4:  MOVF   x37,F
049E6:  BNZ   49EE
049E8:  MOVF   x36,W
049EA:  SUBLW  00
049EC:  BC    4A3A
049EE:  MOVF   x31,W
049F0:  SUBWF  x26,W
049F2:  MOVWF  00
049F4:  MOVF   x32,W
049F6:  SUBWFB x27,W
049F8:  MOVWF  03
049FA:  MOVF   00,W
049FC:  MOVFF  03,01
04A00:  CLRF   02
04A02:  CLRF   03
04A04:  BTFSS  01.7
04A06:  BRA    4A0C
04A08:  DECF   02,F
04A0A:  DECF   03,F
04A0C:  BTFSS  x23.7
04A0E:  BRA    4A16
04A10:  BTFSS  03.7
04A12:  BRA    4A38
04A14:  BRA    4A1A
04A16:  BTFSC  03.7
04A18:  BRA    4A3A
04A1A:  MOVF   x23,W
04A1C:  SUBWF  03,W
04A1E:  BNC   4A3A
04A20:  BNZ   4A38
04A22:  MOVF   x22,W
04A24:  SUBWF  02,W
04A26:  BNC   4A3A
04A28:  BNZ   4A38
04A2A:  MOVF   x21,W
04A2C:  SUBWF  01,W
04A2E:  BNC   4A3A
04A30:  BNZ   4A38
04A32:  MOVF   x20,W
04A34:  SUBWF  00,W
04A36:  BNC   4A3A
....................                bSegmentAcceptable = TRUE; 
04A38:  BSF    x33.0
....................          } 
....................           
....................          if((lMissingBytes < (LONG)wFreeSpace) && ((SHORT)wMissingBytes + (SHORT)wSegmentLength > (SHORT)0)) 
04A3A:  MOVFF  326,00
04A3E:  MOVFF  327,01
04A42:  CLRF   02
04A44:  CLRF   03
04A46:  BTFSS  x23.7
04A48:  BRA    4A50
04A4A:  BTFSS  03.7
04A4C:  BRA    4A72
04A4E:  BRA    4A54
04A50:  BTFSC  03.7
04A52:  BRA    4A8E
04A54:  MOVF   x23,W
04A56:  SUBWF  03,W
04A58:  BNC   4A8E
04A5A:  BNZ   4A72
04A5C:  MOVF   x22,W
04A5E:  SUBWF  02,W
04A60:  BNC   4A8E
04A62:  BNZ   4A72
04A64:  MOVF   x21,W
04A66:  SUBWF  01,W
04A68:  BNC   4A8E
04A6A:  BNZ   4A72
04A6C:  MOVF   00,W
04A6E:  SUBWF  x20,W
04A70:  BC    4A8E
04A72:  MOVF   x31,W
04A74:  ADDWF  x24,W
04A76:  MOVWF  x36
04A78:  MOVF   x32,W
04A7A:  ADDWFC x25,W
04A7C:  MOVWF  x37
04A7E:  BTFSC  FE8.7
04A80:  BRA    4A8E
04A82:  MOVF   x37,F
04A84:  BNZ   4A8C
04A86:  MOVF   x36,W
04A88:  SUBLW  00
04A8A:  BC    4A8E
....................             bSegmentAcceptable = TRUE; 
04A8C:  BSF    x33.0
....................       } 
....................       // Segments with data are not acceptable if we have no free space 
....................    } 
04A8E:  BRA    4AC0
....................    else 
....................    { 
....................       // Zero length packets are acceptable if they fall within our free space window 
....................       // SEG.SEQ = RCV.NXT 
....................       if(lMissingBytes == 0) 
04A90:  MOVF   x20,F
04A92:  BNZ   4AA4
04A94:  MOVF   x21,F
04A96:  BNZ   4AA4
04A98:  MOVF   x22,F
04A9A:  BNZ   4AA4
04A9C:  MOVF   x23,F
04A9E:  BNZ   4AA4
....................       { 
....................          bSegmentAcceptable = TRUE; 
04AA0:  BSF    x33.0
....................       } 
04AA2:  BRA    4AC0
....................       else 
....................       { 
....................          // RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND 
....................          if((lMissingBytes >= (LONG)0) && (wFreeSpace > (DWORD)lMissingBytes)) 
04AA4:  BTFSC  x23.7
04AA6:  BRA    4AC0
04AA8:  MOVF   x23,F
04AAA:  BNZ   4AC0
04AAC:  MOVF   x22,F
04AAE:  BNZ   4AC0
04AB0:  MOVF   x21,W
04AB2:  SUBWF  x27,W
04AB4:  BNC   4AC0
04AB6:  BNZ   4ABE
04AB8:  MOVF   x26,W
04ABA:  SUBWF  x20,W
04ABC:  BC    4AC0
....................             bSegmentAcceptable = TRUE; 
04ABE:  BSF    x33.0
....................       } 
....................    } 
....................     
....................    if(!bSegmentAcceptable) 
04AC0:  BTFSC  x33.0
04AC2:  BRA    4AE0
....................    { 
....................       // Unacceptable segment, drop it and respond appropriately 
....................       if(!(localHeaderFlags & RST))  
04AC4:  BTFSC  x28.2
04AC6:  BRA    4AD8
....................          SendTCP(ACK, SENDTCP_RESET_TIMERS); 
04AC8:  MOVLW  10
04ACA:  MOVWF  x36
04ACC:  MOVLW  01
04ACE:  MOVWF  x37
04AD0:  MOVLB  0
04AD2:  CALL   2238
04AD6:  MOVLB  3
....................       return; 
04AD8:  MOVLB  0
04ADA:  GOTO   5890
04ADE:  MOVLB  3
....................    } 
....................  
....................  
....................    // 
....................    // Second: check the RST bit 
....................    // 
....................    // 
....................    // Fourth: check the SYN bit 
....................    // 
....................    // Note, that since the third step is not implemented, we can  
....................    // combine this second and fourth step into a single operation. 
....................    if(localHeaderFlags & (RST | SYN)) 
04AE0:  MOVF   x28,W
04AE2:  ANDLW  06
04AE4:  BZ    4AF2
....................    { 
....................       CloseSocket(); 
04AE6:  MOVLB  0
04AE8:  CALL   136A
....................       return; 
04AEC:  GOTO   5890
04AF0:  MOVLB  3
....................    } 
....................  
....................    // 
....................    // Third: check the security and precedence 
....................    // 
....................    // Feature not supported.  Let's process this segment. 
....................  
....................    // 
....................    // Fifth: check the ACK bit 
....................    // 
....................    if(!(localHeaderFlags & ACK)) 
04AF2:  BTFSC  x28.4
04AF4:  BRA    4AFE
....................       return; 
04AF6:  MOVLB  0
04AF8:  GOTO   5890
04AFC:  MOVLB  3
....................  
....................    switch(MyTCBStub.smState) 
04AFE:  MOVLB  1
04B00:  MOVF   x2E,W
04B02:  XORLW  06
04B04:  MOVLB  0
04B06:  BZ    4B24
04B08:  XORLW  01
04B0A:  BZ    4B96
04B0C:  XORLW  0F
04B0E:  BZ    4B96
04B10:  XORLW  01
04B12:  BZ    4B96
04B14:  XORLW  02
04B16:  BZ    4B96
04B18:  XORLW  01
04B1A:  BZ    4B96
04B1C:  XORLW  06
04B1E:  BTFSC  FD8.2
04B20:  BRA    5146
04B22:  BRA    5192
....................    { 
....................       case TCP_SYN_RECEIVED: 
....................          if(localAckNumber != MyTCB.MySEQ) 
04B24:  MOVF   xB8,W
04B26:  MOVLB  3
04B28:  SUBWF  x29,W
04B2A:  BNZ   4B4A
04B2C:  MOVLB  0
04B2E:  MOVF   xB9,W
04B30:  MOVLB  3
04B32:  SUBWF  x2A,W
04B34:  BNZ   4B4A
04B36:  MOVLB  0
04B38:  MOVF   xBA,W
04B3A:  MOVLB  3
04B3C:  SUBWF  x2B,W
04B3E:  BNZ   4B4A
04B40:  MOVLB  0
04B42:  MOVF   xBB,W
04B44:  MOVLB  3
04B46:  SUBWF  x2C,W
04B48:  BZ    4B8E
....................          { 
....................             // Send a RST packet with SEQ = SEG.ACK, but retain our SEQ  
....................             // number for arivial of any other correct packets 
....................             localSeqNumber = MyTCB.MySEQ;   // Save our original SEQ number 
04B4A:  MOVFF  BB,330
04B4E:  MOVFF  BA,32F
04B52:  MOVFF  B9,32E
04B56:  MOVFF  B8,32D
....................             MyTCB.MySEQ = localAckNumber;   // Set SEQ = SEG.ACK 
04B5A:  MOVFF  32C,BB
04B5E:  MOVFF  32B,BA
04B62:  MOVFF  32A,B9
04B66:  MOVFF  329,B8
....................             SendTCP(RST, SENDTCP_RESET_TIMERS);      // Send the RST 
04B6A:  MOVLW  04
04B6C:  MOVWF  x36
04B6E:  MOVLW  01
04B70:  MOVWF  x37
04B72:  MOVLB  0
04B74:  CALL   2238
....................             MyTCB.MySEQ = localSeqNumber;   // Restore original SEQ number 
04B78:  MOVFF  330,BB
04B7C:  MOVFF  32F,BA
04B80:  MOVFF  32E,B9
04B84:  MOVFF  32D,B8
....................             return; 
04B88:  GOTO   5890
04B8C:  MOVLB  3
....................          } 
....................          MyTCBStub.smState = TCP_ESTABLISHED; 
04B8E:  MOVLW  07
04B90:  MOVLB  1
04B92:  MOVWF  x2E
04B94:  MOVLB  0
....................          // No break 
....................  
....................       case TCP_ESTABLISHED: 
....................       case TCP_FIN_WAIT_1: 
....................       case TCP_FIN_WAIT_2: 
....................       case TCP_CLOSE_WAIT: 
....................       case TCP_CLOSING: 
....................          // Calculate what the highest possible SEQ number in our TX FIFO is 
....................          wTemp = MyTCBStub.txHead - MyTCB.txUnackedTail; 
04B96:  MOVF   xC0,W
04B98:  MOVLB  1
04B9A:  SUBWF  x1E,W
04B9C:  MOVLB  3
04B9E:  MOVWF  x1E
04BA0:  MOVLB  0
04BA2:  MOVF   xC1,W
04BA4:  MOVLB  1
04BA6:  SUBWFB x1F,W
04BA8:  MOVLB  3
04BAA:  MOVWF  x1F
....................          if((SHORT)wTemp < (SHORT)0) 
04BAC:  BTFSS  x1F.7
04BAE:  BRA    4BC8
....................             wTemp += MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
04BB0:  MOVLB  1
04BB2:  MOVF   x18,W
04BB4:  SUBWF  x1A,W
04BB6:  MOVWF  00
04BB8:  MOVF   x19,W
04BBA:  SUBWFB x1B,W
04BBC:  MOVWF  03
04BBE:  MOVF   00,W
04BC0:  MOVLB  3
04BC2:  ADDWF  x1E,F
04BC4:  MOVF   03,W
04BC6:  ADDWFC x1F,F
....................          dwTemp = MyTCB.MySEQ + (DWORD)wTemp; 
04BC8:  CLRF   02
04BCA:  CLRF   03
04BCC:  MOVF   x1E,W
04BCE:  MOVLB  0
04BD0:  ADDWF  xB8,W
04BD2:  MOVLB  3
04BD4:  MOVWF  x1A
04BD6:  MOVF   x1F,W
04BD8:  MOVLB  0
04BDA:  ADDWFC xB9,W
04BDC:  MOVLB  3
04BDE:  MOVWF  x1B
04BE0:  MOVF   02,W
04BE2:  MOVLB  0
04BE4:  ADDWFC xBA,W
04BE6:  MOVLB  3
04BE8:  MOVWF  x1C
04BEA:  MOVF   03,W
04BEC:  MOVLB  0
04BEE:  ADDWFC xBB,W
04BF0:  MOVLB  3
04BF2:  MOVWF  x1D
....................  
....................          // Drop the packet if it ACKs something we haven't sent 
....................             dwTemp = (LONG)localAckNumber - (LONG)dwTemp; 
04BF4:  MOVF   x1A,W
04BF6:  SUBWF  x29,W
04BF8:  MOVWF  00
04BFA:  MOVF   x1B,W
04BFC:  SUBWFB x2A,W
04BFE:  MOVWF  01
04C00:  MOVF   x1C,W
04C02:  SUBWFB x2B,W
04C04:  MOVWF  02
04C06:  MOVF   x1D,W
04C08:  SUBWFB x2C,W
04C0A:  MOVWF  x1D
04C0C:  MOVFF  02,31C
04C10:  MOVFF  01,31B
04C14:  MOVFF  00,31A
....................             if((LONG)dwTemp > 0) 
04C18:  BTFSC  x1D.7
04C1A:  BRA    4C80
04C1C:  MOVF   x1D,F
04C1E:  BNZ   4C2E
04C20:  MOVF   x1C,F
04C22:  BNZ   4C2E
04C24:  MOVF   x1B,F
04C26:  BNZ   4C2E
04C28:  MOVF   x1A,W
04C2A:  SUBLW  00
04C2C:  BC    4C80
....................             {   // acknowledged more than we've sent?? 
....................                 if(!MyTCB.flags.bFINSent || dwTemp != 1) 
04C2E:  MOVLB  0
04C30:  BTFSS  xD6.0
04C32:  BRA    4C5A
04C34:  MOVLB  3
04C36:  DECFSZ x1A,W
04C38:  BRA    4C3C
04C3A:  BRA    4C40
04C3C:  MOVLB  0
04C3E:  BRA    4C5A
04C40:  MOVF   x1B,F
04C42:  BTFSC  FD8.2
04C44:  BRA    4C4A
04C46:  MOVLB  0
04C48:  BRA    4C5A
04C4A:  MOVF   x1C,F
04C4C:  BTFSC  FD8.2
04C4E:  BRA    4C54
04C50:  MOVLB  0
04C52:  BRA    4C5A
04C54:  MOVF   x1D,F
04C56:  BZ    4C70
04C58:  MOVLB  0
....................                 { 
....................                     SendTCP(ACK, 0); 
04C5A:  MOVLW  10
04C5C:  MOVLB  3
04C5E:  MOVWF  x36
04C60:  CLRF   x37
04C62:  MOVLB  0
04C64:  CALL   2238
....................                     return; 
04C68:  GOTO   5890
....................                 } 
04C6C:  BRA    4C82
04C6E:  MOVLB  3
....................                 else 
....................                 { 
....................                     localAckNumber--;   // since we don't count the FIN anyway 
04C70:  MOVLW  FF
04C72:  ADDWF  x29,F
04C74:  BTFSS  FD8.0
04C76:  ADDWF  x2A,F
04C78:  BTFSS  FD8.0
04C7A:  ADDWF  x2B,F
04C7C:  BTFSS  FD8.0
04C7E:  ADDWF  x2C,F
04C80:  MOVLB  0
....................                 } 
....................             } 
....................  
....................          // Throw away all ACKnowledged TX data: 
....................          // Calculate what the last acknowledged sequence number was (ignoring any FINs we sent) 
....................          dwTemp = MyTCB.MySEQ - (LONG)(SHORT)(MyTCB.txUnackedTail - MyTCBStub.txTail); 
04C82:  MOVLB  1
04C84:  MOVF   x20,W
04C86:  MOVLB  0
04C88:  SUBWF  xC0,W
04C8A:  MOVWF  00
04C8C:  MOVLB  1
04C8E:  MOVF   x21,W
04C90:  MOVLB  0
04C92:  SUBWFB xC1,W
04C94:  MOVWF  03
04C96:  MOVF   00,W
04C98:  MOVFF  03,01
04C9C:  CLRF   02
04C9E:  CLRF   03
04CA0:  BTFSS  01.7
04CA2:  BRA    4CA8
04CA4:  DECF   02,F
04CA6:  DECF   03,F
04CA8:  MOVF   00,W
04CAA:  SUBWF  xB8,W
04CAC:  MOVWF  00
04CAE:  MOVF   01,W
04CB0:  SUBWFB xB9,W
04CB2:  MOVWF  01
04CB4:  MOVF   02,W
04CB6:  SUBWFB xBA,W
04CB8:  MOVWF  02
04CBA:  MOVF   03,W
04CBC:  SUBWFB xBB,W
04CBE:  MOVFF  FE8,31D
04CC2:  MOVFF  02,31C
04CC6:  MOVFF  01,31B
04CCA:  MOVFF  00,31A
....................          if(MyTCB.txUnackedTail < MyTCBStub.txTail) 
04CCE:  MOVF   xC1,W
04CD0:  MOVLB  1
04CD2:  SUBWF  x21,W
04CD4:  BNC   4D06
04CD6:  BNZ   4CE8
04CD8:  MOVF   x20,W
04CDA:  MOVLB  0
04CDC:  SUBWF  xC0,W
04CDE:  BTFSS  FD8.0
04CE0:  BRA    4CE6
04CE2:  MOVLB  1
04CE4:  BRA    4D06
04CE6:  MOVLB  1
....................             dwTemp -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
04CE8:  MOVF   x18,W
04CEA:  SUBWF  x1A,W
04CEC:  MOVWF  00
04CEE:  MOVF   x19,W
04CF0:  SUBWFB x1B,W
04CF2:  MOVWF  03
04CF4:  MOVF   00,W
04CF6:  MOVLB  3
04CF8:  SUBWF  x1A,F
04CFA:  MOVF   03,W
04CFC:  SUBWFB x1B,F
04CFE:  MOVLW  00
04D00:  SUBWFB x1C,F
04D02:  SUBWFB x1D,F
04D04:  MOVLB  1
....................     
....................          // Calcluate how many bytes were ACKed with this packet 
....................          dwTemp = localAckNumber - dwTemp; 
04D06:  MOVLB  3
04D08:  MOVF   x1A,W
04D0A:  SUBWF  x29,W
04D0C:  MOVWF  x1A
04D0E:  MOVF   x1B,W
04D10:  SUBWFB x2A,W
04D12:  MOVWF  x1B
04D14:  MOVF   x1C,W
04D16:  SUBWFB x2B,W
04D18:  MOVWF  x1C
04D1A:  MOVF   x1D,W
04D1C:  SUBWFB x2C,W
04D1E:  MOVWF  x1D
....................          if(((LONG)(dwTemp) > (LONG)0) && (dwTemp <= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart)) 
04D20:  BTFSC  x1D.7
04D22:  BRA    4EAA
04D24:  MOVF   x1D,F
04D26:  BNZ   4D38
04D28:  MOVF   x1C,F
04D2A:  BNZ   4D38
04D2C:  MOVF   x1B,F
04D2E:  BNZ   4D38
04D30:  MOVF   x1A,W
04D32:  SUBLW  00
04D34:  BTFSC  FD8.0
04D36:  BRA    4EAA
04D38:  MOVLB  1
04D3A:  MOVF   x18,W
04D3C:  SUBWF  x1A,W
04D3E:  MOVWF  00
04D40:  MOVF   x19,W
04D42:  SUBWFB x1B,W
04D44:  MOVWF  03
04D46:  MOVFF  00,01
04D4A:  MOVLB  3
04D4C:  MOVF   x1D,F
04D4E:  BTFSS  FD8.2
04D50:  BRA    4EAA
04D52:  MOVF   x1C,F
04D54:  BTFSS  FD8.2
04D56:  BRA    4EAA
04D58:  MOVF   x1B,W
04D5A:  SUBWF  03,W
04D5C:  BTFSS  FD8.0
04D5E:  BRA    4EAA
04D60:  BNZ   4D6A
04D62:  MOVF   x1A,W
04D64:  SUBWF  01,W
04D66:  BTFSS  FD8.0
04D68:  BRA    4EAA
....................          { 
....................             MyTCB.flags.bRXNoneACKed1 = 0; 
04D6A:  MOVLB  0
04D6C:  BCF    xD6.3
....................             MyTCB.flags.bRXNoneACKed2 = 0; 
04D6E:  BCF    xD6.4
....................             MyTCBStub.Flags.bHalfFullFlush = FALSE; 
04D70:  MOVLB  1
04D72:  BCF    x30.0
....................     
....................             // Bytes ACKed, free up the TX FIFO space 
....................             wTemp = MyTCBStub.txTail; 
04D74:  MOVFF  121,31F
04D78:  MOVFF  120,31E
....................             MyTCBStub.txTail += dwTemp; 
04D7C:  MOVLB  3
04D7E:  MOVF   x1A,W
04D80:  MOVLB  1
04D82:  ADDWF  x20,F
04D84:  MOVLB  3
04D86:  MOVF   x1B,W
04D88:  MOVLB  1
04D8A:  ADDWFC x21,F
....................             if(MyTCB.txUnackedTail >= wTemp) 
04D8C:  MOVLB  3
04D8E:  MOVF   x1F,W
04D90:  MOVLB  0
04D92:  SUBWF  xC1,W
04D94:  BNC   4DEE
04D96:  BNZ   4DA2
04D98:  MOVLB  3
04D9A:  MOVF   x1E,W
04D9C:  MOVLB  0
04D9E:  SUBWF  xC0,W
04DA0:  BNC   4DEE
....................             { 
....................                if(MyTCB.txUnackedTail < MyTCBStub.txTail) 
04DA2:  MOVF   xC1,W
04DA4:  MOVLB  1
04DA6:  SUBWF  x21,W
04DA8:  BNC   4DEA
04DAA:  BNZ   4DBC
04DAC:  MOVF   x20,W
04DAE:  MOVLB  0
04DB0:  SUBWF  xC0,W
04DB2:  BTFSS  FD8.0
04DB4:  BRA    4DBA
04DB6:  MOVLB  1
04DB8:  BRA    4DEA
04DBA:  MOVLB  1
....................                { 
....................                   MyTCB.MySEQ += MyTCBStub.txTail - MyTCB.txUnackedTail; 
04DBC:  MOVLB  0
04DBE:  MOVF   xC0,W
04DC0:  MOVLB  1
04DC2:  SUBWF  x20,W
04DC4:  MOVWF  00
04DC6:  MOVLB  0
04DC8:  MOVF   xC1,W
04DCA:  MOVLB  1
04DCC:  SUBWFB x21,W
04DCE:  MOVWF  03
04DD0:  MOVF   00,W
04DD2:  MOVLB  0
04DD4:  ADDWF  xB8,F
04DD6:  MOVF   03,W
04DD8:  ADDWFC xB9,F
04DDA:  MOVLW  00
04DDC:  ADDWFC xBA,F
04DDE:  ADDWFC xBB,F
....................                   MyTCB.txUnackedTail = MyTCBStub.txTail; 
04DE0:  MOVFF  121,C1
04DE4:  MOVFF  120,C0
04DE8:  MOVLB  1
....................                } 
....................             } 
04DEA:  BRA    4E58
04DEC:  MOVLB  0
....................             else 
....................             { 
....................                wTemp = MyTCB.txUnackedTail + (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart); 
04DEE:  MOVLB  1
04DF0:  MOVF   x18,W
04DF2:  SUBWF  x1A,W
04DF4:  MOVWF  00
04DF6:  MOVF   x19,W
04DF8:  SUBWFB x1B,W
04DFA:  MOVWF  03
04DFC:  MOVF   00,W
04DFE:  MOVLB  0
04E00:  ADDWF  xC0,W
04E02:  MOVLB  3
04E04:  MOVWF  x1E
04E06:  MOVF   03,W
04E08:  MOVLB  0
04E0A:  ADDWFC xC1,W
04E0C:  MOVLB  3
04E0E:  MOVWF  x1F
....................                if(wTemp < MyTCBStub.txTail) 
04E10:  MOVF   x1F,W
04E12:  MOVLB  1
04E14:  SUBWF  x21,W
04E16:  BNC   4E58
04E18:  BNZ   4E2A
04E1A:  MOVF   x20,W
04E1C:  MOVLB  3
04E1E:  SUBWF  x1E,W
04E20:  BTFSS  FD8.0
04E22:  BRA    4E28
04E24:  MOVLB  1
04E26:  BRA    4E58
04E28:  MOVLB  1
....................                { 
....................                   MyTCB.MySEQ += MyTCBStub.txTail - wTemp; 
04E2A:  MOVLB  3
04E2C:  MOVF   x1E,W
04E2E:  MOVLB  1
04E30:  SUBWF  x20,W
04E32:  MOVWF  00
04E34:  MOVLB  3
04E36:  MOVF   x1F,W
04E38:  MOVLB  1
04E3A:  SUBWFB x21,W
04E3C:  MOVWF  03
04E3E:  MOVF   00,W
04E40:  MOVLB  0
04E42:  ADDWF  xB8,F
04E44:  MOVF   03,W
04E46:  ADDWFC xB9,F
04E48:  MOVLW  00
04E4A:  ADDWFC xBA,F
04E4C:  ADDWFC xBB,F
....................                   MyTCB.txUnackedTail = MyTCBStub.txTail; 
04E4E:  MOVFF  121,C1
04E52:  MOVFF  120,C0
04E56:  MOVLB  1
....................                } 
....................             } 
....................             if(MyTCBStub.txTail >= MyTCBStub.bufferRxStart) 
04E58:  MOVF   x1B,W
04E5A:  SUBWF  x21,W
04E5C:  BNC   4E7A
04E5E:  BNZ   4E66
04E60:  MOVF   x1A,W
04E62:  SUBWF  x20,W
04E64:  BNC   4E7A
....................                MyTCBStub.txTail -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
04E66:  MOVF   x18,W
04E68:  SUBWF  x1A,W
04E6A:  MOVWF  00
04E6C:  MOVF   x19,W
04E6E:  SUBWFB x1B,W
04E70:  MOVWF  03
04E72:  MOVF   00,W
04E74:  SUBWF  x20,F
04E76:  MOVF   03,W
04E78:  SUBWFB x21,F
....................             if(MyTCB.txUnackedTail >= MyTCBStub.bufferRxStart) 
04E7A:  MOVF   x1B,W
04E7C:  MOVLB  0
04E7E:  SUBWF  xC1,W
04E80:  BNC   4EA6
04E82:  BNZ   4E8E
04E84:  MOVLB  1
04E86:  MOVF   x1A,W
04E88:  MOVLB  0
04E8A:  SUBWF  xC0,W
04E8C:  BNC   4EA6
....................                MyTCB.txUnackedTail -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
04E8E:  MOVLB  1
04E90:  MOVF   x18,W
04E92:  SUBWF  x1A,W
04E94:  MOVWF  00
04E96:  MOVF   x19,W
04E98:  SUBWFB x1B,W
04E9A:  MOVWF  03
04E9C:  MOVF   00,W
04E9E:  MOVLB  0
04EA0:  SUBWF  xC0,F
04EA2:  MOVF   03,W
04EA4:  SUBWFB xC1,F
....................          } 
04EA6:  BRA    4F84
04EA8:  MOVLB  3
....................          else 
....................          { 
....................             // See if we have outstanding TX data that is waiting for an ACK 
....................             if(MyTCBStub.txTail != MyTCB.txUnackedTail) 
04EAA:  MOVLB  0
04EAC:  MOVF   xC0,W
04EAE:  MOVLB  1
04EB0:  SUBWF  x20,W
04EB2:  BNZ   4EBE
04EB4:  MOVLB  0
04EB6:  MOVF   xC1,W
04EB8:  MOVLB  1
04EBA:  SUBWF  x21,W
04EBC:  BZ    4F86
....................             { 
....................                if(MyTCB.flags.bRXNoneACKed1) 
04EBE:  MOVLB  0
04EC0:  BTFSS  xD6.3
04EC2:  BRA    4F82
....................                { 
....................                   if(MyTCB.flags.bRXNoneACKed2) 
04EC4:  BTFSS  xD6.4
04EC6:  BRA    4F80
....................                   { 
....................                      // Set up to perform a fast retransmission 
....................                      // Roll back unacknowledged TX tail pointer to cause retransmit to occur 
....................                      MyTCB.MySEQ -= (LONG)(SHORT)(MyTCB.txUnackedTail - MyTCBStub.txTail); 
04EC8:  MOVLB  1
04ECA:  MOVF   x20,W
04ECC:  MOVLB  0
04ECE:  SUBWF  xC0,W
04ED0:  MOVWF  00
04ED2:  MOVLB  1
04ED4:  MOVF   x21,W
04ED6:  MOVLB  0
04ED8:  SUBWFB xC1,W
04EDA:  MOVWF  03
04EDC:  MOVF   00,W
04EDE:  MOVFF  03,01
04EE2:  CLRF   02
04EE4:  CLRF   03
04EE6:  BTFSS  01.7
04EE8:  BRA    4EEE
04EEA:  DECF   02,F
04EEC:  DECF   03,F
04EEE:  MOVF   00,W
04EF0:  SUBWF  xB8,W
04EF2:  MOVWF  00
04EF4:  MOVF   01,W
04EF6:  SUBWFB xB9,W
04EF8:  MOVWF  01
04EFA:  MOVF   02,W
04EFC:  SUBWFB xBA,W
04EFE:  MOVWF  02
04F00:  MOVF   03,W
04F02:  SUBWFB xBB,W
04F04:  MOVWF  xBB
04F06:  MOVFF  02,BA
04F0A:  MOVFF  01,B9
04F0E:  MOVFF  00,B8
....................                      if(MyTCB.txUnackedTail < MyTCBStub.txTail) 
04F12:  MOVF   xC1,W
04F14:  MOVLB  1
04F16:  SUBWF  x21,W
04F18:  BNC   4F74
04F1A:  BNZ   4F2C
04F1C:  MOVF   x20,W
04F1E:  MOVLB  0
04F20:  SUBWF  xC0,W
04F22:  BTFSS  FD8.0
04F24:  BRA    4F2A
04F26:  MOVLB  1
04F28:  BRA    4F74
04F2A:  MOVLB  1
....................                         MyTCB.MySEQ -= (LONG)(SHORT)(MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart); 
04F2C:  MOVF   x18,W
04F2E:  SUBWF  x1A,W
04F30:  MOVWF  00
04F32:  MOVF   x19,W
04F34:  SUBWFB x1B,W
04F36:  MOVWF  03
04F38:  MOVF   00,W
04F3A:  MOVFF  03,01
04F3E:  CLRF   02
04F40:  CLRF   03
04F42:  BTFSS  01.7
04F44:  BRA    4F4A
04F46:  DECF   02,F
04F48:  DECF   03,F
04F4A:  MOVF   00,W
04F4C:  MOVLB  0
04F4E:  SUBWF  xB8,W
04F50:  MOVWF  00
04F52:  MOVF   01,W
04F54:  SUBWFB xB9,W
04F56:  MOVWF  01
04F58:  MOVF   02,W
04F5A:  SUBWFB xBA,W
04F5C:  MOVWF  02
04F5E:  MOVF   03,W
04F60:  SUBWFB xBB,W
04F62:  MOVWF  03
04F64:  MOVWF  xBB
04F66:  MOVFF  02,BA
04F6A:  MOVFF  01,B9
04F6E:  MOVFF  00,B8
04F72:  MOVLB  1
....................                      MyTCB.txUnackedTail = MyTCBStub.txTail; 
04F74:  MOVFF  121,C1
04F78:  MOVFF  120,C0
....................                      MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
04F7C:  BSF    x30.2
04F7E:  MOVLB  0
....................                   } 
....................                   MyTCB.flags.bRXNoneACKed2 = 1; 
04F80:  BSF    xD6.4
....................                } 
....................                MyTCB.flags.bRXNoneACKed1 = 1; 
04F82:  BSF    xD6.3
04F84:  MOVLB  1
....................             } 
....................          } 
....................  
....................          // No need to keep our retransmit timer going if we have nothing that needs ACKing anymore 
....................          if(MyTCBStub.txTail == MyTCBStub.txHead) 
04F86:  MOVF   x1E,W
04F88:  SUBWF  x20,W
04F8A:  BNZ   4FFA
04F8C:  MOVF   x1F,W
04F8E:  SUBWF  x21,W
04F90:  BNZ   4FFA
....................          { 
....................             // Make sure there isn't a "FIN byte in our TX FIFO" 
....................             if(MyTCBStub.Flags.bTXFIN == 0u) 
04F92:  BTFSC  x30.3
04F94:  BRA    4FC8
....................             { 
....................                // Convert retransmission timer to keep-alive timer 
....................                #if defined(TCP_KEEP_ALIVE_TIMEOUT) 
....................                   MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
04F96:  MOVLB  0
04F98:  CALL   1630
04F9C:  MOVLW  E6
04F9E:  MOVLB  3
04FA0:  ADDWF  00,W
04FA2:  MOVLB  1
04FA4:  MOVWF  x26
04FA6:  MOVLW  F5
04FA8:  MOVLB  3
04FAA:  ADDWFC 01,W
04FAC:  MOVLB  1
04FAE:  MOVWF  x27
04FB0:  MOVLW  05
04FB2:  MOVLB  3
04FB4:  ADDWFC 02,W
04FB6:  MOVLB  1
04FB8:  MOVWF  x28
04FBA:  MOVLW  00
04FBC:  MOVLB  3
04FBE:  ADDWFC 03,W
04FC0:  MOVLB  1
04FC2:  MOVWF  x29
....................                #endif 
....................                MyTCBStub.Flags.bTimerEnabled = 0; 
04FC4:  BCF    x2F.4
....................             } 
04FC6:  BRA    4FFA
....................             else 
....................             { 
....................                // "Throw away" FIN byte from our TX FIFO if it has been ACKed 
....................                if((MyTCB.MySEQ == localAckNumber) && MyTCB.flags.bFINSent) 
04FC8:  MOVLB  3
04FCA:  MOVF   x29,W
04FCC:  MOVLB  0
04FCE:  SUBWF  xB8,W
04FD0:  BNZ   4FFC
04FD2:  MOVLB  3
04FD4:  MOVF   x2A,W
04FD6:  MOVLB  0
04FD8:  SUBWF  xB9,W
04FDA:  BNZ   4FFC
04FDC:  MOVLB  3
04FDE:  MOVF   x2B,W
04FE0:  MOVLB  0
04FE2:  SUBWF  xBA,W
04FE4:  BNZ   4FFC
04FE6:  MOVLB  3
04FE8:  MOVF   x2C,W
04FEA:  MOVLB  0
04FEC:  SUBWF  xBB,W
04FEE:  BNZ   4FFC
04FF0:  BTFSS  xD6.0
04FF2:  BRA    4FFC
....................                { 
....................                   MyTCBStub.Flags.bTimerEnabled = 0; 
04FF4:  MOVLB  1
04FF6:  BCF    x2F.4
....................                   MyTCBStub.Flags.bTXFIN = 0; 
04FF8:  BCF    x30.3
04FFA:  MOVLB  0
....................                } 
....................             } 
....................          } 
....................  
....................          // The window size advirtised in this packet is adjusted to account  
....................          // for any bytes that we have transmitted but haven't been ACKed yet  
....................          // by this segment. 
....................          wNewWindow = h->Window - ((WORD)(MyTCB.MySEQ - localAckNumber)); 
04FFC:  MOVLW  0E
04FFE:  MOVLB  3
05000:  ADDWF  x16,W
05002:  MOVWF  FE9
05004:  MOVLW  00
05006:  ADDWFC x17,W
05008:  MOVWF  FEA
0500A:  MOVFF  FEC,337
0500E:  MOVF   FED,F
05010:  MOVFF  FEF,336
05014:  MOVF   x29,W
05016:  MOVLB  0
05018:  SUBWF  xB8,W
0501A:  MOVWF  00
0501C:  MOVLB  3
0501E:  MOVF   x2A,W
05020:  MOVLB  0
05022:  SUBWFB xB9,W
05024:  MOVWF  01
05026:  MOVLB  3
05028:  MOVF   x2B,W
0502A:  MOVLB  0
0502C:  SUBWFB xBA,W
0502E:  MOVLB  3
05030:  MOVF   x2C,W
05032:  MOVLB  0
05034:  SUBWFB xBB,W
05036:  MOVF   00,W
05038:  MOVLB  3
0503A:  SUBWF  x36,W
0503C:  MOVWF  x34
0503E:  MOVF   01,W
05040:  SUBWFB x37,W
05042:  MOVWF  x35
....................  
....................          // Update the local stored copy of the RemoteWindow. 
....................          // If previously we had a zero window, and now we don't, then  
....................          // immediately send whatever was pending. 
....................          if((MyTCB.remoteWindow == 0u) && wNewWindow) 
05044:  MOVLB  0
05046:  MOVF   xC6,F
05048:  BNZ   5062
0504A:  MOVF   xC7,F
0504C:  BNZ   5062
0504E:  MOVLB  3
05050:  MOVF   x34,W
05052:  IORWF  x35,W
05054:  BTFSS  FD8.2
05056:  BRA    505C
05058:  MOVLB  0
0505A:  BRA    5062
....................             MyTCBStub.Flags.bTXASAP = 1; 
0505C:  MOVLB  1
0505E:  BSF    x30.1
05060:  MOVLB  0
....................          MyTCB.remoteWindow = wNewWindow; 
05062:  MOVFF  335,C7
05066:  MOVFF  334,C6
....................  
....................          // A couple of states must do all of the TCP_ESTABLISHED stuff, but also a little more 
....................          if(MyTCBStub.smState == TCP_FIN_WAIT_1) 
0506A:  MOVLB  1
0506C:  MOVF   x2E,W
0506E:  SUBLW  08
05070:  BNZ   50D6
....................          { 
....................             // Check to see if our FIN has been ACKnowledged 
....................             if((MyTCB.MySEQ == localAckNumber) && MyTCB.flags.bFINSent) 
05072:  MOVLB  3
05074:  MOVF   x29,W
05076:  MOVLB  0
05078:  SUBWF  xB8,W
0507A:  BNZ   50D2
0507C:  MOVLB  3
0507E:  MOVF   x2A,W
05080:  MOVLB  0
05082:  SUBWF  xB9,W
05084:  BNZ   50D2
05086:  MOVLB  3
05088:  MOVF   x2B,W
0508A:  MOVLB  0
0508C:  SUBWF  xBA,W
0508E:  BNZ   50D2
05090:  MOVLB  3
05092:  MOVF   x2C,W
05094:  MOVLB  0
05096:  SUBWF  xBB,W
05098:  BNZ   50D2
0509A:  BTFSS  xD6.0
0509C:  BRA    50D2
....................             { 
....................                // Reset our timer for forced closure if the remote node  
....................                // doesn't send us a FIN in a timely manner. 
....................                MyTCBStub.eventTime = TickGet() + TCP_FIN_WAIT_2_TIMEOUT; 
0509E:  CALL   1630
050A2:  MOVLW  F3
050A4:  MOVLB  3
050A6:  ADDWF  00,W
050A8:  MOVLB  1
050AA:  MOVWF  x26
050AC:  MOVLW  FA
050AE:  MOVLB  3
050B0:  ADDWFC 01,W
050B2:  MOVLB  1
050B4:  MOVWF  x27
050B6:  MOVLW  02
050B8:  MOVLB  3
050BA:  ADDWFC 02,W
050BC:  MOVLB  1
050BE:  MOVWF  x28
050C0:  MOVLW  00
050C2:  MOVLB  3
050C4:  ADDWFC 03,W
050C6:  MOVLB  1
050C8:  MOVWF  x29
....................                MyTCBStub.Flags.bTimerEnabled = 1; 
050CA:  BSF    x2F.4
....................                MyTCBStub.smState = TCP_FIN_WAIT_2; 
050CC:  MOVLW  09
050CE:  MOVWF  x2E
050D0:  MOVLB  0
....................             } 
....................          } 
050D2:  BRA    5142
050D4:  MOVLB  1
....................          else if(MyTCBStub.smState == TCP_FIN_WAIT_2) 
050D6:  MOVF   x2E,W
050D8:  SUBLW  09
050DA:  BNZ   510C
....................          { 
....................             // RFC noncompliance: 
....................             // The remote node should not keep sending us data  
....................             // indefinitely after we send a FIN to it.   
....................             // However, some bad stacks may still keep sending  
....................             // us data indefinitely after ACKing our FIN.  To  
....................             // prevent this from locking up our socket, let's  
....................             // send a RST right now and close forcefully on  
....................             // our side. 
....................             if(!(localHeaderFlags & FIN)) 
050DC:  MOVLB  3
050DE:  BTFSC  x28.0
050E0:  BRA    5108
....................             { 
....................                MyTCB.MySEQ = localAckNumber;   // Set SEQ = SEG.ACK 
050E2:  MOVFF  32C,BB
050E6:  MOVFF  32B,BA
050EA:  MOVFF  32A,B9
050EE:  MOVFF  329,B8
....................                SendTCP(RST | ACK, 0); 
050F2:  MOVLW  14
050F4:  MOVWF  x36
050F6:  CLRF   x37
050F8:  MOVLB  0
050FA:  CALL   2238
....................                CloseSocket(); 
050FE:  CALL   136A
....................                return; 
05102:  GOTO   5890
05106:  MOVLB  3
....................             } 
....................          } 
05108:  BRA    5144
0510A:  MOVLB  1
....................          else if(MyTCBStub.smState == TCP_CLOSING) 
0510C:  MOVF   x2E,W
0510E:  SUBLW  0A
05110:  BNZ   5142
....................          { 
....................             // Check to see if our FIN has been ACKnowledged 
....................             if(MyTCB.MySEQ == localAckNumber) 
05112:  MOVLB  3
05114:  MOVF   x29,W
05116:  MOVLB  0
05118:  SUBWF  xB8,W
0511A:  BNZ   513E
0511C:  MOVLB  3
0511E:  MOVF   x2A,W
05120:  MOVLB  0
05122:  SUBWF  xB9,W
05124:  BNZ   513E
05126:  MOVLB  3
05128:  MOVF   x2B,W
0512A:  MOVLB  0
0512C:  SUBWF  xBA,W
0512E:  BNZ   513E
05130:  MOVLB  3
05132:  MOVF   x2C,W
05134:  MOVLB  0
05136:  SUBWF  xBB,W
05138:  BNZ   513E
....................             { 
....................                // RFC not recommended: We should be going to  
....................                // the TCP_TIME_WAIT state right here and  
....................                // starting a 2MSL timer, but since we have so  
....................                // few precious sockets, we can't afford to  
....................                // leave a socket waiting around doing nothing  
....................                // for a long time.  If the remote node does  
....................                // not recieve this ACK, it'll have to figure  
....................                // out on it's own that the connection is now  
....................                // closed. 
....................                CloseSocket(); 
0513A:  CALL   136A
....................             } 
....................  
....................             return; 
0513E:  GOTO   5890
05142:  MOVLB  3
....................          } 
....................  
....................          break; 
05144:  BRA    5194
....................  
....................       case TCP_LAST_ACK: 
....................          // Check to see if our FIN has been ACKnowledged 
....................          if(MyTCB.MySEQ + 1 == localAckNumber) 
05146:  MOVLW  01
05148:  ADDWF  xB8,W
0514A:  MOVLB  3
0514C:  MOVWF  x36
0514E:  MOVLW  00
05150:  MOVLB  0
05152:  ADDWFC xB9,W
05154:  MOVLB  3
05156:  MOVWF  x37
05158:  MOVLW  00
0515A:  MOVLB  0
0515C:  ADDWFC xBA,W
0515E:  MOVLB  3
05160:  MOVWF  x38
05162:  MOVLW  00
05164:  MOVLB  0
05166:  ADDWFC xBB,W
05168:  MOVLB  3
0516A:  MOVWF  x39
0516C:  MOVF   x29,W
0516E:  SUBWF  x36,W
05170:  BNZ   518C
05172:  MOVF   x2A,W
05174:  SUBWF  x37,W
05176:  BNZ   518C
05178:  MOVF   x2B,W
0517A:  SUBWF  x38,W
0517C:  BNZ   518C
0517E:  MOVF   x2C,W
05180:  SUBWF  x39,W
05182:  BNZ   518C
....................             CloseSocket(); 
05184:  MOVLB  0
05186:  CALL   136A
0518A:  MOVLB  3
....................          return; 
0518C:  MOVLB  0
0518E:  GOTO   5890
....................  
.................... //      case TCP_TIME_WAIT: 
.................... //         // Nothing is supposed to arrive here.  If it does, reset the quiet timer. 
.................... //         SendTCP(ACK, SENDTCP_RESET_TIMERS); 
.................... //         return; 
....................  
....................       default: 
....................          break; 
05192:  MOVLB  3
....................    } 
....................  
....................    // 
....................    // Sixth: Check the URG bit 
....................    // 
....................    // Urgent packets are not supported in this stack, so we 
....................    // will throw them away instead 
....................    if(localHeaderFlags & URG) 
05194:  BTFSS  x28.5
05196:  BRA    519E
....................       return; 
05198:  MOVLB  0
0519A:  BRA    5890
0519C:  MOVLB  3
....................  
....................    // 
....................    // Seventh: Process the segment text 
....................    // 
....................    // Throw data away if in a state that doesn't accept data 
....................    if(MyTCBStub.smState == TCP_CLOSE_WAIT) 
0519E:  MOVLB  1
051A0:  MOVF   x2E,W
051A2:  SUBLW  0B
051A4:  BNZ   51AC
....................       return; 
051A6:  MOVLB  0
051A8:  BRA    5890
051AA:  MOVLB  1
....................    if(MyTCBStub.smState == TCP_CLOSING) 
051AC:  MOVF   x2E,W
051AE:  SUBLW  0A
051B0:  BNZ   51B8
....................       return; 
051B2:  MOVLB  0
051B4:  BRA    5890
051B6:  MOVLB  1
....................    if(MyTCBStub.smState == TCP_LAST_ACK) 
051B8:  MOVF   x2E,W
051BA:  SUBLW  0C
051BC:  BNZ   51C4
....................       return; 
051BE:  MOVLB  0
051C0:  BRA    5890
051C2:  MOVLB  1
.................... //   if(MyTCBStub.smState == TCP_TIME_WAIT) 
.................... //      return; 
....................  
....................    // Copy any valid segment data into our RX FIFO, if any 
....................    if(len) 
051C4:  MOVLB  3
051C6:  MOVF   x18,W
051C8:  IORWF  x19,W
051CA:  BTFSC  FD8.2
051CC:  BRA    56FC
....................    { 
....................       // See if there are bytes we must skip 
....................       if((SHORT)wMissingBytes <= 0) 
051CE:  BTFSC  x25.7
051D0:  BRA    51E0
051D2:  MOVF   x25,F
051D4:  BTFSS  FD8.2
051D6:  BRA    53F0
051D8:  MOVF   x24,W
051DA:  SUBLW  00
051DC:  BTFSS  FD8.0
051DE:  BRA    53F0
....................       { 
....................          // Position packet read pointer to start of useful data area. 
....................          IPSetRxBuffer((h->DataOffset.Val << 2) - wMissingBytes); 
051E0:  MOVLW  0C
051E2:  ADDWF  x16,W
051E4:  MOVWF  FE9
051E6:  MOVLW  00
051E8:  ADDWFC x17,W
051EA:  MOVWF  FEA
051EC:  MOVFF  FEF,00
051F0:  SWAPF  00,W
051F2:  ANDLW  0F
051F4:  MOVWF  00
051F6:  RLCF   00,F
051F8:  RLCF   00,F
051FA:  MOVLW  FC
051FC:  ANDWF  00,F
051FE:  MOVF   00,W
05200:  BSF    FD8.0
05202:  SUBFWB x24,W
05204:  MOVWF  x36
05206:  MOVLW  00
05208:  SUBFWB x25,W
0520A:  MOVWF  x37
0520C:  MOVWF  x3B
0520E:  MOVFF  336,33A
05212:  MOVLB  0
05214:  CALL   3F0C
....................          len += wMissingBytes;       
05218:  MOVLB  3
0521A:  MOVF   x24,W
0521C:  ADDWF  x18,F
0521E:  MOVF   x25,W
05220:  ADDWFC x19,F
....................     
....................          // Truncate packets that would overflow our TCP RX FIFO 
....................          // and request a retransmit by sending a duplicate ACK 
....................          if(len > wFreeSpace) 
05222:  MOVF   x27,W
05224:  SUBWF  x19,W
05226:  BNC   5238
05228:  BNZ   5230
0522A:  MOVF   x18,W
0522C:  SUBWF  x26,W
0522E:  BC    5238
....................             len = wFreeSpace; 
05230:  MOVFF  327,319
05234:  MOVFF  326,318
....................     
....................          MyTCB.RemoteSEQ += (DWORD)len; 
05238:  MOVFF  319,01
0523C:  CLRF   02
0523E:  CLRF   03
05240:  MOVF   x18,W
05242:  MOVLB  0
05244:  ADDWF  xBC,F
05246:  MOVF   01,W
05248:  ADDWFC xBD,F
0524A:  MOVF   02,W
0524C:  ADDWFC xBE,F
0524E:  MOVF   03,W
05250:  ADDWFC xBF,F
....................        
....................          // Copy the application data from the packet into the socket RX FIFO 
....................          // See if we need a two part copy (spans bufferEnd->bufferRxStart) 
....................          if(MyTCBStub.rxHead + len > MyTCBStub.bufferEnd) 
05252:  MOVLB  3
05254:  MOVF   x18,W
05256:  MOVLB  1
05258:  ADDWF  x22,W
0525A:  MOVLB  3
0525C:  MOVWF  x36
0525E:  MOVF   x19,W
05260:  MOVLB  1
05262:  ADDWFC x23,W
05264:  MOVLB  3
05266:  MOVWF  x37
05268:  MOVLB  1
0526A:  MOVF   x1D,W
0526C:  MOVLB  3
0526E:  SUBWF  x37,W
05270:  BNC   5310
05272:  BNZ   5284
05274:  MOVF   x36,W
05276:  MOVLB  1
05278:  SUBWF  x1C,W
0527A:  BTFSS  FD8.0
0527C:  BRA    5282
0527E:  MOVLB  3
05280:  BRA    5310
05282:  MOVLB  3
....................          { 
....................             wTemp = MyTCBStub.bufferEnd - MyTCBStub.rxHead + 1; 
05284:  MOVLB  1
05286:  MOVF   x22,W
05288:  SUBWF  x1C,W
0528A:  MOVLB  3
0528C:  MOVWF  x36
0528E:  MOVLB  1
05290:  MOVF   x23,W
05292:  SUBWFB x1D,W
05294:  MOVLB  3
05296:  MOVWF  x37
05298:  MOVLW  01
0529A:  ADDWF  x36,W
0529C:  MOVWF  x1E
0529E:  MOVLW  00
052A0:  ADDWFC x37,W
052A2:  MOVWF  x1F
....................             TCPRAMCopy(MyTCBStub.rxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, wTemp); 
052A4:  MOVFF  123,368
052A8:  MOVFF  122,367
052AC:  MOVFF  133,369
052B0:  SETF   x6B
052B2:  SETF   x6A
052B4:  CLRF   x6C
052B6:  MOVFF  31F,36E
052BA:  MOVFF  31E,36D
052BE:  MOVLB  0
052C0:  CALL   11B0
....................             TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len - wTemp); 
052C4:  MOVLB  3
052C6:  MOVF   x1E,W
052C8:  SUBWF  x18,W
052CA:  MOVWF  x36
052CC:  MOVF   x1F,W
052CE:  SUBWFB x19,W
052D0:  MOVWF  x37
052D2:  MOVFF  11B,368
052D6:  MOVFF  11A,367
052DA:  MOVFF  133,369
052DE:  SETF   x6B
052E0:  SETF   x6A
052E2:  CLRF   x6C
052E4:  MOVWF  x6E
052E6:  MOVFF  336,36D
052EA:  MOVLB  0
052EC:  CALL   11B0
....................             MyTCBStub.rxHead = MyTCBStub.bufferRxStart + (len - wTemp); 
052F0:  MOVLB  3
052F2:  MOVF   x1E,W
052F4:  SUBWF  x18,W
052F6:  MOVWF  00
052F8:  MOVF   x1F,W
052FA:  SUBWFB x19,W
052FC:  MOVWF  03
052FE:  MOVF   00,W
05300:  MOVLB  1
05302:  ADDWF  x1A,W
05304:  MOVWF  x22
05306:  MOVF   03,W
05308:  ADDWFC x1B,W
0530A:  MOVWF  x23
....................          } 
0530C:  BRA    5340
0530E:  MOVLB  3
....................          else 
....................          { 
....................             TCPRAMCopy(MyTCBStub.rxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len); 
05310:  MOVFF  123,368
05314:  MOVFF  122,367
05318:  MOVFF  133,369
0531C:  SETF   x6B
0531E:  SETF   x6A
05320:  CLRF   x6C
05322:  MOVFF  319,36E
05326:  MOVFF  318,36D
0532A:  MOVLB  0
0532C:  CALL   11B0
....................             MyTCBStub.rxHead += len; 
05330:  MOVLB  3
05332:  MOVF   x18,W
05334:  MOVLB  1
05336:  ADDWF  x22,F
05338:  MOVLB  3
0533A:  MOVF   x19,W
0533C:  MOVLB  1
0533E:  ADDWFC x23,F
....................          } 
....................        
....................          // See if we have a hole and other data waiting already in the RX FIFO 
....................          if(MyTCB.sHoleSize != -1) 
05340:  MOVLB  0
05342:  INCFSZ xD4,W
05344:  BRA    534C
05346:  INCFSZ xD5,W
05348:  BRA    534C
0534A:  BRA    53EC
....................          { 
....................             MyTCB.sHoleSize -= len; 
0534C:  MOVLB  3
0534E:  MOVF   x18,W
05350:  MOVLB  0
05352:  SUBWF  xD4,F
05354:  MOVLB  3
05356:  MOVF   x19,W
05358:  MOVLB  0
0535A:  SUBWFB xD5,F
....................             wTemp = MyTCB.wFutureDataSize + MyTCB.sHoleSize; 
0535C:  MOVF   xD4,W
0535E:  ADDWF  xC8,W
05360:  MOVWF  01
05362:  MOVF   xD5,W
05364:  ADDWFC xC9,W
05366:  MOVFF  01,31E
0536A:  MOVLB  3
0536C:  MOVWF  x1F
....................        
....................             // See if we just closed up a hole, and if so, advance head pointer 
....................             if((SHORT)wTemp < (SHORT)0) 
0536E:  BTFSS  x1F.7
05370:  BRA    537A
....................             { 
....................                MyTCB.sHoleSize = -1; 
05372:  MOVLB  0
05374:  SETF   xD5
05376:  SETF   xD4
....................             } 
05378:  BRA    53EC
....................             else if(MyTCB.sHoleSize <= 0) 
0537A:  MOVLB  0
0537C:  BTFSC  xD5.7
0537E:  BRA    538A
05380:  MOVF   xD5,F
05382:  BNZ   53EC
05384:  MOVF   xD4,W
05386:  SUBLW  00
05388:  BNC   53EC
....................             { 
....................                MyTCB.RemoteSEQ += wTemp; 
0538A:  MOVLB  3
0538C:  MOVF   x1E,W
0538E:  MOVLB  0
05390:  ADDWF  xBC,F
05392:  MOVLB  3
05394:  MOVF   x1F,W
05396:  MOVLB  0
05398:  ADDWFC xBD,F
0539A:  MOVLW  00
0539C:  ADDWFC xBE,F
0539E:  ADDWFC xBF,F
....................                MyTCBStub.rxHead += wTemp; 
053A0:  MOVLB  3
053A2:  MOVF   x1E,W
053A4:  MOVLB  1
053A6:  ADDWF  x22,F
053A8:  MOVLB  3
053AA:  MOVF   x1F,W
053AC:  MOVLB  1
053AE:  ADDWFC x23,F
....................                if(MyTCBStub.rxHead > MyTCBStub.bufferEnd) 
053B0:  MOVF   x1D,W
053B2:  SUBWF  x23,W
053B4:  BNC   53E6
053B6:  BNZ   53BE
053B8:  MOVF   x22,W
053BA:  SUBWF  x1C,W
053BC:  BC    53E6
....................                   MyTCBStub.rxHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;                      
053BE:  MOVF   x1A,W
053C0:  SUBWF  x1C,W
053C2:  MOVLB  3
053C4:  MOVWF  x36
053C6:  MOVLB  1
053C8:  MOVF   x1B,W
053CA:  SUBWFB x1D,W
053CC:  MOVLB  3
053CE:  MOVWF  x37
053D0:  MOVLW  01
053D2:  ADDWF  x36,W
053D4:  MOVWF  01
053D6:  MOVLW  00
053D8:  ADDWFC x37,W
053DA:  MOVWF  03
053DC:  MOVF   01,W
053DE:  MOVLB  1
053E0:  SUBWF  x22,F
053E2:  MOVF   03,W
053E4:  SUBWFB x23,F
....................                MyTCB.sHoleSize = -1; 
053E6:  MOVLB  0
053E8:  SETF   xD5
053EA:  SETF   xD4
....................             } 
....................          } 
....................       } // This packet is out of order or we lost a packet, see if we can generate a hole to accomodate it 
053EC:  BRA    56FA
053EE:  MOVLB  3
....................       else if((SHORT)wMissingBytes > 0) 
053F0:  BTFSC  x25.7
053F2:  BRA    56FC
053F4:  MOVF   x25,F
053F6:  BNZ   5400
053F8:  MOVF   x24,W
053FA:  SUBLW  00
053FC:  BTFSC  FD8.0
053FE:  BRA    56FC
....................       { 
....................          // Truncate packets that would overflow our TCP RX FIFO 
....................          if(len + wMissingBytes > wFreeSpace) 
05400:  MOVF   x24,W
05402:  ADDWF  x18,W
05404:  MOVWF  x36
05406:  MOVF   x25,W
05408:  ADDWFC x19,W
0540A:  MOVWF  x37
0540C:  MOVF   x27,W
0540E:  SUBWF  x37,W
05410:  BNC   5426
05412:  BNZ   541A
05414:  MOVF   x36,W
05416:  SUBWF  x26,W
05418:  BC    5426
....................             len = wFreeSpace - wMissingBytes; 
0541A:  MOVF   x24,W
0541C:  SUBWF  x26,W
0541E:  MOVWF  x18
05420:  MOVF   x25,W
05422:  SUBWFB x27,W
05424:  MOVWF  x19
....................        
....................          // Position packet read pointer to start of useful data area. 
....................          IPSetRxBuffer(h->DataOffset.Val << 2); 
05426:  MOVLW  0C
05428:  ADDWF  x16,W
0542A:  MOVWF  FE9
0542C:  MOVLW  00
0542E:  ADDWFC x17,W
05430:  MOVWF  FEA
05432:  MOVFF  FEF,00
05436:  SWAPF  00,W
05438:  ANDLW  0F
0543A:  MOVWF  00
0543C:  RLCF   00,W
0543E:  MOVWF  x36
05440:  RLCF   x36,F
05442:  MOVLW  FC
05444:  ANDWF  x36,F
05446:  CLRF   x3B
05448:  MOVFF  336,33A
0544C:  MOVLB  0
0544E:  CALL   3F0C
....................     
....................          // See if we need a two part copy (spans bufferEnd->bufferRxStart) 
....................          if(MyTCBStub.rxHead + wMissingBytes + len > MyTCBStub.bufferEnd) 
05452:  MOVLB  3
05454:  MOVF   x24,W
05456:  MOVLB  1
05458:  ADDWF  x22,W
0545A:  MOVLB  3
0545C:  MOVWF  x36
0545E:  MOVF   x25,W
05460:  MOVLB  1
05462:  ADDWFC x23,W
05464:  MOVLB  3
05466:  MOVWF  x37
05468:  MOVF   x18,W
0546A:  ADDWF  x36,F
0546C:  MOVF   x19,W
0546E:  ADDWFC x37,F
05470:  MOVLB  1
05472:  MOVF   x1D,W
05474:  MOVLB  3
05476:  SUBWF  x37,W
05478:  BTFSS  FD8.0
0547A:  BRA    557C
0547C:  BNZ   548E
0547E:  MOVF   x36,W
05480:  MOVLB  1
05482:  SUBWF  x1C,W
05484:  BTFSS  FD8.0
05486:  BRA    548C
05488:  MOVLB  3
0548A:  BRA    557C
0548C:  MOVLB  3
....................          { 
....................             // Calculate number of data bytes to copy before wraparound 
....................             wTemp = MyTCBStub.bufferEnd - MyTCBStub.rxHead + 1 - wMissingBytes; 
0548E:  MOVLB  1
05490:  MOVF   x22,W
05492:  SUBWF  x1C,W
05494:  MOVLB  3
05496:  MOVWF  x36
05498:  MOVLB  1
0549A:  MOVF   x23,W
0549C:  SUBWFB x1D,W
0549E:  MOVLB  3
054A0:  MOVWF  x37
054A2:  MOVLW  01
054A4:  ADDWF  x36,F
054A6:  MOVLW  00
054A8:  ADDWFC x37,F
054AA:  MOVF   x24,W
054AC:  SUBWF  x36,W
054AE:  MOVWF  x1E
054B0:  MOVF   x25,W
054B2:  SUBWFB x37,W
054B4:  MOVWF  x1F
....................             if((SHORT)wTemp >= 0) 
054B6:  BTFSC  x1F.7
054B8:  BRA    551C
....................             { 
....................                TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, wTemp); 
054BA:  MOVF   x24,W
054BC:  MOVLB  1
054BE:  ADDWF  x22,W
054C0:  MOVLB  3
054C2:  MOVWF  x36
054C4:  MOVF   x25,W
054C6:  MOVLB  1
054C8:  ADDWFC x23,W
054CA:  MOVLB  3
054CC:  MOVWF  x37
054CE:  MOVWF  x68
054D0:  MOVFF  336,367
054D4:  MOVFF  133,369
054D8:  SETF   x6B
054DA:  SETF   x6A
054DC:  CLRF   x6C
054DE:  MOVFF  31F,36E
054E2:  MOVFF  31E,36D
054E6:  MOVLB  0
054E8:  CALL   11B0
....................                TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len - wTemp); 
054EC:  MOVLB  3
054EE:  MOVF   x1E,W
054F0:  SUBWF  x18,W
054F2:  MOVWF  x36
054F4:  MOVF   x1F,W
054F6:  SUBWFB x19,W
054F8:  MOVWF  x37
054FA:  MOVFF  11B,368
054FE:  MOVFF  11A,367
05502:  MOVFF  133,369
05506:  SETF   x6B
05508:  SETF   x6A
0550A:  CLRF   x6C
0550C:  MOVWF  x6E
0550E:  MOVFF  336,36D
05512:  MOVLB  0
05514:  CALL   11B0
....................             } 
05518:  BRA    5578
0551A:  MOVLB  3
....................             else 
....................             { 
....................                TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes - (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1), MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len); 
0551C:  MOVF   x24,W
0551E:  MOVLB  1
05520:  ADDWF  x22,W
05522:  MOVLB  3
05524:  MOVWF  x36
05526:  MOVF   x25,W
05528:  MOVLB  1
0552A:  ADDWFC x23,W
0552C:  MOVLB  3
0552E:  MOVWF  x37
05530:  MOVLB  1
05532:  MOVF   x1A,W
05534:  SUBWF  x1C,W
05536:  MOVLB  3
05538:  MOVWF  x38
0553A:  MOVLB  1
0553C:  MOVF   x1B,W
0553E:  SUBWFB x1D,W
05540:  MOVLB  3
05542:  MOVWF  x39
05544:  MOVLW  01
05546:  ADDWF  x38,W
05548:  MOVWF  01
0554A:  MOVLW  00
0554C:  ADDWFC x39,W
0554E:  MOVWF  03
05550:  MOVF   01,W
05552:  SUBWF  x36,F
05554:  MOVF   03,W
05556:  SUBWFB x37,F
05558:  MOVFF  337,368
0555C:  MOVFF  336,367
05560:  MOVFF  133,369
05564:  SETF   x6B
05566:  SETF   x6A
05568:  CLRF   x6C
0556A:  MOVFF  319,36E
0556E:  MOVFF  318,36D
05572:  MOVLB  0
05574:  CALL   11B0
....................             } 
....................          } 
05578:  BRA    55AE
0557A:  MOVLB  3
....................          else 
....................          { 
....................             TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len); 
0557C:  MOVF   x24,W
0557E:  MOVLB  1
05580:  ADDWF  x22,W
05582:  MOVLB  3
05584:  MOVWF  x36
05586:  MOVF   x25,W
05588:  MOVLB  1
0558A:  ADDWFC x23,W
0558C:  MOVLB  3
0558E:  MOVWF  x37
05590:  MOVWF  x68
05592:  MOVFF  336,367
05596:  MOVFF  133,369
0559A:  SETF   x6B
0559C:  SETF   x6A
0559E:  CLRF   x6C
055A0:  MOVFF  319,36E
055A4:  MOVFF  318,36D
055A8:  MOVLB  0
055AA:  CALL   11B0
....................          } 
....................        
....................          // Record the hole is here 
....................          if(MyTCB.sHoleSize == -1) 
055AE:  INCFSZ xD4,W
055B0:  BRA    55C8
055B2:  INCFSZ xD5,W
055B4:  BRA    55C8
....................          { 
....................             MyTCB.sHoleSize = wMissingBytes; 
055B6:  MOVFF  325,D5
055BA:  MOVFF  324,D4
....................             MyTCB.wFutureDataSize = len; 
055BE:  MOVFF  319,C9
055C2:  MOVFF  318,C8
....................          } 
055C6:  BRA    56FA
....................          else 
....................          { 
....................             // We already have a hole, see if we can shrink the hole  
....................             // or extend the future data size 
....................             if(wMissingBytes < (WORD)MyTCB.sHoleSize) 
055C8:  MOVLB  3
055CA:  MOVF   x25,W
055CC:  MOVLB  0
055CE:  SUBWF  xD5,W
055D0:  BNC   5674
055D2:  BNZ   55E4
055D4:  MOVF   xD4,W
055D6:  MOVLB  3
055D8:  SUBWF  x24,W
055DA:  BTFSS  FD8.0
055DC:  BRA    55E2
055DE:  MOVLB  0
055E0:  BRA    5674
055E2:  MOVLB  0
....................             { 
....................                if((wMissingBytes + len > (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize) || (wMissingBytes + len < (WORD)MyTCB.sHoleSize)) 
055E4:  MOVLB  3
055E6:  MOVF   x18,W
055E8:  ADDWF  x24,W
055EA:  MOVWF  x36
055EC:  MOVF   x19,W
055EE:  ADDWFC x25,W
055F0:  MOVWF  x37
055F2:  MOVLB  0
055F4:  MOVF   xC8,W
055F6:  ADDWF  xD4,W
055F8:  MOVWF  01
055FA:  MOVF   xC9,W
055FC:  ADDWFC xD5,W
055FE:  MOVWF  03
05600:  MOVF   03,W
05602:  MOVLB  3
05604:  SUBWF  x37,W
05606:  BNC   5610
05608:  BNZ   5638
0560A:  MOVF   x36,W
0560C:  SUBWF  01,W
0560E:  BNC   5638
05610:  MOVF   x18,W
05612:  ADDWF  x24,W
05614:  MOVWF  x36
05616:  MOVF   x19,W
05618:  ADDWFC x25,W
0561A:  MOVWF  x37
0561C:  MOVLB  0
0561E:  SUBWF  xD5,W
05620:  BNC   5644
05622:  BTFSC  FD8.2
05624:  BRA    562A
05626:  MOVLB  3
05628:  BRA    5638
0562A:  MOVF   xD4,W
0562C:  MOVLB  3
0562E:  SUBWF  x36,W
05630:  BTFSS  FD8.0
05632:  BRA    5638
05634:  MOVLB  0
05636:  BRA    5644
....................                   MyTCB.wFutureDataSize = len; 
05638:  MOVFF  319,C9
0563C:  MOVFF  318,C8
05640:  BRA    566A
05642:  MOVLB  0
....................                else 
....................                   MyTCB.wFutureDataSize = (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize - wMissingBytes; 
05644:  MOVF   xC8,W
05646:  ADDWF  xD4,W
05648:  MOVLB  3
0564A:  MOVWF  x36
0564C:  MOVLB  0
0564E:  MOVF   xC9,W
05650:  ADDWFC xD5,W
05652:  MOVLB  3
05654:  MOVWF  x37
05656:  MOVF   x24,W
05658:  SUBWF  x36,W
0565A:  MOVLB  0
0565C:  MOVWF  xC8
0565E:  MOVLB  3
05660:  MOVF   x25,W
05662:  SUBWFB x37,W
05664:  MOVLB  0
05666:  MOVWF  xC9
05668:  MOVLB  3
....................                MyTCB.sHoleSize = wMissingBytes; 
0566A:  MOVFF  325,D5
0566E:  MOVFF  324,D4
....................             } 
05672:  BRA    56FC
....................             else if(wMissingBytes + len > (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize) 
05674:  MOVLB  3
05676:  MOVF   x18,W
05678:  ADDWF  x24,W
0567A:  MOVWF  x36
0567C:  MOVF   x19,W
0567E:  ADDWFC x25,W
05680:  MOVWF  x37
05682:  MOVLB  0
05684:  MOVF   xC8,W
05686:  ADDWF  xD4,W
05688:  MOVWF  01
0568A:  MOVF   xC9,W
0568C:  ADDWFC xD5,W
0568E:  MOVWF  03
05690:  MOVF   03,W
05692:  MOVLB  3
05694:  SUBWF  x37,W
05696:  BNC   56FC
05698:  BNZ   56A0
0569A:  MOVF   x36,W
0569C:  SUBWF  01,W
0569E:  BC    56FC
....................             { 
....................                // Make sure that there isn't a second hole between  
....................                // our future data and this TCP segment's future data 
....................                if(wMissingBytes <= (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize) 
056A0:  MOVLB  0
056A2:  MOVF   xC8,W
056A4:  ADDWF  xD4,W
056A6:  MOVWF  01
056A8:  MOVF   xC9,W
056AA:  ADDWFC xD5,W
056AC:  MOVWF  03
056AE:  MOVF   01,W
056B0:  MOVLB  3
056B2:  MOVF   x25,W
056B4:  SUBWF  03,W
056B6:  BNC   56FC
056B8:  BNZ   56C0
056BA:  MOVF   x24,W
056BC:  SUBWF  01,W
056BE:  BNC   56FC
....................                   MyTCB.wFutureDataSize += wMissingBytes + len - (WORD)MyTCB.sHoleSize - MyTCB.wFutureDataSize; 
056C0:  MOVF   x18,W
056C2:  ADDWF  x24,W
056C4:  MOVWF  x36
056C6:  MOVF   x19,W
056C8:  ADDWFC x25,W
056CA:  MOVWF  x37
056CC:  MOVLB  0
056CE:  MOVF   xD4,W
056D0:  MOVLB  3
056D2:  SUBWF  x36,F
056D4:  MOVLB  0
056D6:  MOVF   xD5,W
056D8:  MOVLB  3
056DA:  SUBWFB x37,F
056DC:  MOVLB  0
056DE:  MOVF   xC8,W
056E0:  MOVLB  3
056E2:  SUBWF  x36,W
056E4:  MOVWF  00
056E6:  MOVLB  0
056E8:  MOVF   xC9,W
056EA:  MOVLB  3
056EC:  SUBWFB x37,W
056EE:  MOVWF  03
056F0:  MOVF   00,W
056F2:  MOVLB  0
056F4:  ADDWF  xC8,F
056F6:  MOVF   03,W
056F8:  ADDWFC xC9,F
056FA:  MOVLB  3
....................             } 
....................              
....................          } 
....................       } 
....................    } 
....................  
....................    // Send back an ACK of the data (+SYN | FIN) we just received,  
....................    // if any.  To minimize bandwidth waste, we are implementing  
....................    // the delayed acknowledgement algorithm here, only sending  
....................    // back an immediate ACK if this is the second segment received.   
....................    // Otherwise, a 200ms timer will cause the ACK to be transmitted. 
....................    if(wSegmentLength) 
056FC:  MOVF   x31,W
056FE:  IORWF  x32,W
05700:  BZ    5754
....................    { 
....................       // For non-established sockets, let's delete all data in  
....................       // the RX buffer immediately after receiving it.  This is  
....................       // not really how TCP was intended to operate since a  
....................       // socket cannot receive any response after it sends a FIN, 
....................       // but our TCP application API doesn't readily accomodate 
....................       // receiving data after calling TCPDisconnect(), which  
....................       // invalidates the application TCP handle.  By deleting all  
....................       // data, we'll ensure that the RX window is nonzero and  
....................       // the remote node will be able to send us a FIN response,  
....................       // which needs an RX window of at least 1. 
....................       if(MyTCBStub.smState != TCP_ESTABLISHED) 
05702:  MOVLB  1
05704:  MOVF   x2E,W
05706:  SUBLW  07
05708:  BZ    5712
....................          MyTCBStub.rxTail = MyTCBStub.rxHead; 
0570A:  MOVFF  123,125
0570E:  MOVFF  122,124
....................  
....................       if(MyTCBStub.Flags.bOneSegmentReceived) 
05712:  BTFSS  x2F.7
05714:  BRA    572E
....................       { 
....................          SendTCP(ACK, SENDTCP_RESET_TIMERS); 
05716:  MOVLW  10
05718:  MOVLB  3
0571A:  MOVWF  x36
0571C:  MOVLW  01
0571E:  MOVWF  x37
05720:  MOVLB  0
05722:  CALL   2238
....................          SyncTCB(); 
05726:  CALL   1296
....................          // bOneSegmentReceived is cleared in SendTCP(), so no need here 
....................       } 
0572A:  BRA    5752
0572C:  MOVLB  1
....................       else 
....................       { 
....................          MyTCBStub.Flags.bOneSegmentReceived = TRUE;    
0572E:  BSF    x2F.7
....................        
....................          // Do not send an ACK immediately back.  Instead, we will  
....................          // perform delayed acknowledgements.  To do this, we will  
....................          // just start a timer 
....................          if(!MyTCBStub.Flags.bDelayedACKTimerEnabled) 
05730:  BTFSC  x2F.6
05732:  BRA    5750
....................          { 
....................             MyTCBStub.Flags.bDelayedACKTimerEnabled = 1; 
05734:  BSF    x2F.6
....................             MyTCBStub.OverlappedTimers.delayedACKTime = (WORD)TickGetDiv256() + (WORD)((TCP_DELAYED_ACK_TIMEOUT)>>8); 
05736:  MOVLB  0
05738:  CALL   2B2A
0573C:  MOVLW  0F
0573E:  MOVLB  3
05740:  ADDWF  00,W
05742:  MOVLB  1
05744:  MOVWF  x2C
05746:  MOVLW  00
05748:  MOVLB  3
0574A:  ADDWFC 01,W
0574C:  MOVLB  1
0574E:  MOVWF  x2D
05750:  MOVLB  0
05752:  MOVLB  3
....................          } 
....................       } 
....................    } 
....................  
....................    // 
....................    // Eighth: check the FIN bit 
....................    // 
....................    if(localHeaderFlags & FIN) 
05754:  BTFSS  x28.0
05756:  BRA    5892
....................    { 
....................       // Note: Since we don't have a good means of storing "FIN bytes"  
....................       // in our TCP RX FIFO, we must ensure that FINs are processed  
....................       // in-order. 
....................       if(MyTCB.RemoteSEQ + 1 == localSeqNumber + (DWORD)wSegmentLength) 
05758:  MOVLW  01
0575A:  MOVLB  0
0575C:  ADDWF  xBC,W
0575E:  MOVLB  3
05760:  MOVWF  x36
05762:  MOVLW  00
05764:  MOVLB  0
05766:  ADDWFC xBD,W
05768:  MOVLB  3
0576A:  MOVWF  x37
0576C:  MOVLW  00
0576E:  MOVLB  0
05770:  ADDWFC xBE,W
05772:  MOVLB  3
05774:  MOVWF  x38
05776:  MOVLW  00
05778:  MOVLB  0
0577A:  ADDWFC xBF,W
0577C:  MOVLB  3
0577E:  MOVWF  x39
05780:  MOVFF  331,00
05784:  MOVFF  332,01
05788:  CLRF   02
0578A:  CLRF   03
0578C:  MOVF   x2D,W
0578E:  ADDWF  00,F
05790:  MOVF   x2E,W
05792:  ADDWFC 01,F
05794:  MOVF   x2F,W
05796:  ADDWFC 02,F
05798:  MOVF   x30,W
0579A:  ADDWFC 03,F
0579C:  MOVF   00,W
0579E:  SUBWF  x36,W
057A0:  BTFSS  FD8.2
057A2:  BRA    5892
057A4:  MOVF   01,W
057A6:  SUBWF  x37,W
057A8:  BTFSS  FD8.2
057AA:  BRA    5892
057AC:  MOVF   02,W
057AE:  SUBWF  x38,W
057B0:  BTFSS  FD8.2
057B2:  BRA    5892
057B4:  MOVF   03,W
057B6:  SUBWF  x39,W
057B8:  BTFSS  FD8.2
057BA:  BRA    5892
....................       { 
....................          // FINs are treated as one byte of data for ACK sequencing 
....................          MyTCB.RemoteSEQ++; 
057BC:  MOVLW  01
057BE:  MOVLB  0
057C0:  ADDWF  xBC,F
057C2:  BTFSC  FD8.0
057C4:  INCF   xBD,F
057C6:  BTFSC  FD8.2
057C8:  INCF   xBE,F
057CA:  BTFSC  FD8.2
057CC:  INCF   xBF,F
....................           
....................          switch(MyTCBStub.smState) 
057CE:  MOVLB  1
057D0:  MOVF   x2E,W
057D2:  XORLW  06
057D4:  MOVLB  0
057D6:  BZ    57E6
057D8:  XORLW  01
057DA:  BZ    57FE
057DC:  XORLW  0F
057DE:  BZ    5820
057E0:  XORLW  01
057E2:  BZ    586A
057E4:  BRA    587E
....................          { 
....................             case TCP_SYN_RECEIVED: 
....................                // RFC in exact: Our API has no need for the user  
....................                // to explicitly close a socket that never really  
....................                // got opened fully in the first place, so just  
....................                // transmit a FIN automatically and jump to  
....................                // TCP_LAST_ACK 
....................                MyTCBStub.smState = TCP_LAST_ACK; 
057E6:  MOVLW  0C
057E8:  MOVLB  1
057EA:  MOVWF  x2E
....................                SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS); 
057EC:  MOVLW  11
057EE:  MOVLB  3
057F0:  MOVWF  x36
057F2:  MOVLW  01
057F4:  MOVWF  x37
057F6:  MOVLB  0
057F8:  CALL   2238
....................                return; 
057FC:  BRA    5890
....................  
....................             case TCP_ESTABLISHED: 
....................                // Go to TCP_CLOSE_WAIT state 
....................                MyTCBStub.smState = TCP_CLOSE_WAIT; 
057FE:  MOVLW  0B
05800:  MOVLB  1
05802:  MOVWF  x2E
....................                 
....................                // For legacy applications that don't call  
....................                // TCPDisconnect() as needed and expect the TCP/IP  
....................                // Stack to automatically close sockets when the  
....................                // remote node sends a FIN, let's start a timer so  
....................                // that we will eventually close the socket automatically 
....................                MyTCBStub.OverlappedTimers.closeWaitTime = (WORD)TickGetDiv256() + (WORD)((TCP_CLOSE_WAIT_TIMEOUT)>>8); 
05804:  MOVLB  0
05806:  CALL   2B2A
0580A:  MOVLW  1E
0580C:  MOVLB  3
0580E:  ADDWF  00,W
05810:  MOVLB  1
05812:  MOVWF  x2C
05814:  MOVLW  00
05816:  MOVLB  3
05818:  ADDWFC 01,W
0581A:  MOVLB  1
0581C:  MOVWF  x2D
....................                break; 
0581E:  BRA    5880
....................     
....................             case TCP_FIN_WAIT_1: 
....................                if(MyTCB.MySEQ == localAckNumber) 
05820:  MOVLB  3
05822:  MOVF   x29,W
05824:  MOVLB  0
05826:  SUBWF  xB8,W
05828:  BNZ   585E
0582A:  MOVLB  3
0582C:  MOVF   x2A,W
0582E:  MOVLB  0
05830:  SUBWF  xB9,W
05832:  BNZ   585E
05834:  MOVLB  3
05836:  MOVF   x2B,W
05838:  MOVLB  0
0583A:  SUBWF  xBA,W
0583C:  BNZ   585E
0583E:  MOVLB  3
05840:  MOVF   x2C,W
05842:  MOVLB  0
05844:  SUBWF  xBB,W
05846:  BNZ   585E
....................                { 
....................                   // RFC not recommended: We should be going to  
....................                   // the TCP_TIME_WAIT state right here and  
....................                   // starting a 2MSL timer, but since we have so  
....................                   // few precious sockets, we can't afford to  
....................                   // leave a socket waiting around doing nothing  
....................                   // for a long time.  If the remote node does  
....................                   // not recieve this ACK, it'll have to figure  
....................                   // out on it's own that the connection is now  
....................                   // closed. 
....................                   SendTCP(ACK, 0); 
05848:  MOVLW  10
0584A:  MOVLB  3
0584C:  MOVWF  x36
0584E:  CLRF   x37
05850:  MOVLB  0
05852:  CALL   2238
....................                   CloseSocket(); 
05856:  CALL   136A
....................                   return; 
0585A:  BRA    5890
....................                } 
0585C:  BRA    5866
....................                else 
....................                { 
....................                   MyTCBStub.smState = TCP_CLOSING; 
0585E:  MOVLW  0A
05860:  MOVLB  1
05862:  MOVWF  x2E
05864:  MOVLB  0
....................                } 
....................                break; 
05866:  MOVLB  1
05868:  BRA    5880
....................     
....................             case TCP_FIN_WAIT_2: 
....................                // RFC not recommended: We should be going to  
....................                // the TCP_TIME_WAIT state right here and  
....................                // starting a 2MSL timer, but since we have so  
....................                // few precious sockets, we can't afford to  
....................                // leave a socket waiting around doing nothing  
....................                // for a long time.  If the remote node does  
....................                // not recieve this ACK, it'll have to figure  
....................                // out on it's own that the connection is now  
....................                // closed. 
....................                SendTCP(ACK, 0); 
0586A:  MOVLW  10
0586C:  MOVLB  3
0586E:  MOVWF  x36
05870:  CLRF   x37
05872:  MOVLB  0
05874:  CALL   2238
....................                CloseSocket(); 
05878:  CALL   136A
....................                return; 
0587C:  BRA    5890
....................  
....................             default: 
....................                break; 
0587E:  MOVLB  1
....................          } 
....................  
....................          // Acknowledge receipt of FIN 
....................          SendTCP(ACK, SENDTCP_RESET_TIMERS); 
05880:  MOVLW  10
05882:  MOVLB  3
05884:  MOVWF  x36
05886:  MOVLW  01
05888:  MOVWF  x37
0588A:  MOVLB  0
0588C:  CALL   2238
05890:  MOVLB  3
....................       } 
....................    } 
05892:  MOVLB  0
05894:  GOTO   5A14 (RETURN)
.................... } 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Buffer Management Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPAdjustFIFOSize(TCP_SOCKET hTCP, WORD wMinRXSize,  
....................                      WORD wMinTXSize, BYTE vFlags) 
....................  
....................   Summary: 
....................    Adjusts the relative sizes of the RX and TX buffers. 
....................  
....................   Description: 
....................    This function can be used to adjust the relative sizes of the RX and 
....................    TX FIFO depending on the immediate needs of an application.  Since a  
....................    larger FIFO can allow more data to be sent in a given packet, adjusting  
....................    the relative sizes on the fly can allow for optimal transmission speed  
....................    for one-sided application protocols.  For example, HTTP typically  
....................    begins by receiving large amounts of data from the client, then switches 
....................    to serving large amounts of data back.  Adjusting the FIFO at these  
....................    points can increase performance substantially.  Once the FIFO is 
....................    adjusted, a window update is sent. 
....................     
....................    If neither or both of TCP_ADJUST_GIVE_REST_TO_TX and  
....................    TCP_ADJUST_GIVE_REST_TO_RX are set, the function distributes the 
....................    remaining space equally. 
....................     
....................    Received data can be preserved as long as the buffer is expanding and  
....................    has not wrapped. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP      - The socket to be adjusted 
....................    wMinRXSize   - Minimum number of byte for the RX FIFO 
....................    wMinTXSize    - Minimum number of bytes for the RX FIFO 
....................    vFlags      - Any combination of TCP_ADJUST_GIVE_REST_TO_RX,  
....................               TCP_ADJUST_GIVE_REST_TO_TX, TCP_ADJUST_PRESERVE_RX. 
....................               TCP_ADJUST_PRESERVE_TX is not currently supported. 
....................  
....................   Return Values: 
....................    TRUE - The FIFOs were adjusted successfully 
....................    FALSE - Minimum RX, Minimum TX, or flags couldn't be accommodated and 
....................          therefore the socket was left unchanged. 
....................  
....................   Side Effects: 
....................    Any unacknowledged or untransmitted data in the TX FIFO is always 
....................    deleted. 
....................  
....................   Remarks: 
....................    At least one byte must always be allocated to the RX buffer so that 
....................    a FIN can be received.  The function automatically corrects for this. 
....................   ***************************************************************************/ 
.................... BOOL TCPAdjustFIFOSize(TCP_SOCKET hTCP, WORD wMinRXSize, WORD wMinTXSize, BYTE vFlags) 
.................... { 
....................    PTR_BASE ptrTemp, ptrHead; 
....................    WORD wTXAllocation; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    // Load up info on this socket 
....................    SyncTCBStub(hTCP); 
....................  
....................    // RX has to be at least 1 byte to receive SYN and FIN bytes  
....................    // from the remote node, even if they aren't stored in the RX FIFO 
....................    if(wMinRXSize == 0u) 
....................       wMinRXSize = 1; 
....................        
....................    // SSL connections need to be able to send or receive at least  
....................    // a full Alert record, MAC, and FIN 
....................    #if defined(STACK_USE_SSL) 
....................    if(TCPIsSSL(hTCP) && wMinRXSize < 25u) 
....................       wMinRXSize = 25; 
....................    if(TCPIsSSL(hTCP) && wMinTXSize < 25u) 
....................       wMinTXSize = 25; 
....................    #endif 
....................     
....................    // Make sure space is available for minimums 
....................    ptrTemp = MyTCBStub.bufferEnd - MyTCBStub.bufferTxStart - 1; 
....................    if(wMinRXSize + wMinTXSize > ptrTemp) 
....................       return FALSE; 
....................  
....................    SyncTCB(); 
....................  
....................    // Set both allocation flags if none set 
....................    if(!(vFlags & (TCP_ADJUST_GIVE_REST_TO_TX | TCP_ADJUST_GIVE_REST_TO_RX))) 
....................       vFlags |= TCP_ADJUST_GIVE_REST_TO_TX | TCP_ADJUST_GIVE_REST_TO_RX; 
....................        
....................  
....................    // Allocate minimums 
....................    wTXAllocation = wMinTXSize; 
....................    ptrTemp -= wMinRXSize + wMinTXSize; 
....................  
....................    // Allocate extra 
....................    if(vFlags & TCP_ADJUST_GIVE_REST_TO_TX) 
....................    { 
....................       if(vFlags & TCP_ADJUST_GIVE_REST_TO_RX) 
....................       { 
....................          // Do a 50%/50% split with any odd byte always going to the RX FIFO 
....................          wTXAllocation += ptrTemp>>1; 
....................       } 
....................       else 
....................       { 
....................          wTXAllocation += ptrTemp; 
....................       } 
....................    } 
....................  
....................    // Calculate new bufferRxStart pointer 
....................    ptrTemp = MyTCBStub.bufferTxStart + wTXAllocation + 1; 
....................  
....................    // Find the head pointer to use 
....................    ptrHead = MyTCBStub.rxHead; 
....................    #if defined(STACK_USE_SSL) 
....................    if(TCPIsSSL(hTCP)) 
....................       ptrHead = MyTCBStub.sslRxHead; 
....................    #endif 
....................     
....................    // If there's out-of-order data pending, adjust the head pointer to compensate 
....................    if(MyTCB.sHoleSize != -1) 
....................    { 
....................       ptrHead += MyTCB.sHoleSize + MyTCB.wFutureDataSize; 
....................       if(ptrHead > MyTCBStub.bufferEnd) 
....................          ptrHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................    } 
....................  
....................    // Determine if resizing will lose any RX data 
....................    if(MyTCBStub.rxTail < ptrHead) 
....................    { 
....................       if(ptrTemp > MyTCBStub.rxTail) 
....................       { 
....................          if(vFlags & TCP_ADJUST_PRESERVE_RX) 
....................             return FALSE; 
....................          else 
....................          { 
....................             MyTCBStub.rxTail = ptrTemp; 
....................             MyTCBStub.rxHead = ptrTemp; 
....................  
....................             #if defined(STACK_USE_SSL) 
....................             MyTCBStub.sslRxHead = ptrTemp; 
....................             #endif 
....................          } 
....................       } 
....................    } 
....................    else if(MyTCBStub.rxTail > ptrHead) 
....................    { 
....................       if(ptrTemp > MyTCBStub.bufferRxStart) 
....................       { 
....................          if(vFlags & TCP_ADJUST_PRESERVE_RX) 
....................             return FALSE; 
....................          else 
....................          { 
....................             MyTCBStub.rxTail = ptrTemp; 
....................             MyTCBStub.rxHead = ptrTemp; 
....................              
....................             #if defined(STACK_USE_SSL) 
....................             MyTCBStub.sslRxHead = ptrTemp; 
....................             #endif 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       // No data to preserve, but we may need to move  
....................       // the pointers to stay in the RX space 
....................       MyTCBStub.rxTail = ptrTemp; 
....................       MyTCBStub.rxHead = ptrTemp; 
....................        
....................       #if defined(STACK_USE_SSL) 
....................       MyTCBStub.sslRxHead = ptrTemp; 
....................       #endif 
....................    } 
....................     
....................    // If we need to preserve data that wrapped in the ring, we must copy 
....................    if(ptrHead < MyTCBStub.rxTail && (vFlags & TCP_ADJUST_PRESERVE_RX)) 
....................    { 
....................       TCPRAMCopy(ptrTemp, MyTCBStub.vMemoryMedium,  
....................          MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, 
....................          ptrHead - MyTCBStub.bufferRxStart); 
....................  
....................       // Move the pointers if they were in front of the tail 
....................       #if defined(STACK_USE_SSL) 
....................       if(TCPIsSSL(hTCP) && MyTCBStub.sslRxHead < MyTCBStub.rxTail) 
....................          MyTCBStub.sslRxHead -= MyTCBStub.bufferRxStart - ptrTemp; 
....................       #endif 
....................       if(MyTCBStub.rxHead < MyTCBStub.rxTail) 
....................          MyTCBStub.rxHead -= MyTCBStub.bufferRxStart - ptrTemp; 
....................    } 
....................     
....................    // Move the RX buffer pointer - it's the one that divides the two 
....................    MyTCBStub.bufferRxStart = ptrTemp; 
....................  
....................    // Empty the TX buffer 
....................    MyTCB.txUnackedTail = MyTCBStub.bufferTxStart; 
....................    MyTCBStub.txTail = MyTCBStub.bufferTxStart; 
....................    MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................     
....................    #if defined(STACK_USE_SSL) 
....................    if(TCPIsSSL(hTCP)) 
....................       MyTCBStub.sslTxHead = MyTCBStub.txHead + 5; 
....................    #endif 
....................     
....................    // Send a window update to notify remote node of change 
....................    if(MyTCBStub.smState == TCP_ESTABLISHED) 
....................       SendTCP(ACK, SENDTCP_RESET_TIMERS); 
....................  
....................    return TRUE; 
....................  
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void TCPRAMCopy(PTR_BASE ptrDest, BYTE vDestType, PTR_BASE ptrSource,  
....................                      BYTE vSourceType, WORD wLength) 
....................  
....................   Summary: 
....................    Copies data to/from various memory mediums. 
....................  
....................   Description: 
....................    This function copies data between memory mediums (PIC RAM, SPI 
....................    RAM, and Ethernet buffer RAM). 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    ptrDest      - Address to write to 
....................    vDestType   - Destination meidum (TCP_PIC_RAM, TCP_ETH_RAM, TCP_SPI_RAM) 
....................    ptrSource   - Address to copy from 
....................    vSourceType - Source medium (TCP_PIC_RAM, TCP_ETH_RAM, or TCP_SPI_RAM) 
....................    wLength      - Number of bytes to copy 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    Copying to a destination region that overlaps with the source address  
....................    is supported only if the destination start address is at a lower memory  
....................    address (closer to 0x0000) than the source pointer.  However, if they do  
....................    overlap there must be at least 4 bytes of non-overlap to ensure correct  
....................    results due to hardware DMA requirements. 
....................   ***************************************************************************/ 
.................... static void TCPRAMCopy(PTR_BASE ptrDest, BYTE vDestType, PTR_BASE ptrSource, BYTE vSourceType, WORD wLength) 
.................... { 
....................    #if defined(SPIRAM_CS_TRIS) 
....................    BYTE vBuffer[16]; 
....................    WORD w; 
....................    #endif 
....................        
....................    switch(vSourceType) 
*
011B0:  MOVLB  3
011B2:  MOVF   x6C,W
011B4:  XORLW  01
011B6:  MOVLB  0
011B8:  BZ    11C0
011BA:  XORLW  01
011BC:  BZ    1232
011BE:  BRA    1294
....................    { 
....................       case TCP_PIC_RAM: 
....................          switch(vDestType) 
011C0:  MOVLB  3
011C2:  MOVF   x69,W
011C4:  XORLW  01
011C6:  MOVLB  0
011C8:  BZ    11D0
011CA:  XORLW  01
011CC:  BZ    1202
011CE:  BRA    1230
....................          { 
....................             case TCP_PIC_RAM: 
....................                memcpy((void*)(BYTE*)ptrDest, (void*)(BYTE*)ptrSource, wLength); 
011D0:  MOVFF  368,FEA
011D4:  MOVFF  367,FE9
011D8:  MOVFF  36B,FE2
011DC:  MOVFF  36A,FE1
011E0:  MOVFF  36E,02
011E4:  MOVFF  36D,01
011E8:  MOVF   01,F
011EA:  BZ    11F0
011EC:  INCF   02,F
011EE:  BRA    11F4
011F0:  MOVF   02,F
011F2:  BZ    1200
011F4:  MOVFF  FE6,FEE
011F8:  DECFSZ 01,F
011FA:  BRA    11F4
011FC:  DECFSZ 02,F
011FE:  BRA    11F4
....................                break; 
01200:  BRA    1230
....................     
....................             case TCP_ETH_RAM: 
....................                if(ptrDest!=(PTR_BASE)-1) 
01202:  MOVLB  3
01204:  INCFSZ x67,W
01206:  BRA    120E
01208:  INCFSZ x68,W
0120A:  BRA    120E
0120C:  BRA    121C
....................                   MACSetWritePtr(ptrDest); 
0120E:  MOVFF  368,370
01212:  MOVFF  367,36F
01216:  MOVLB  0
01218:  RCALL  0D46
0121A:  MOVLB  3
....................                MACPutArray((BYTE*)ptrSource, wLength); 
0121C:  MOVFF  36B,385
01220:  MOVFF  36A,384
01224:  MOVFF  36E,387
01228:  MOVFF  36D,386
0122C:  MOVLB  0
0122E:  RCALL  0DB6
....................                break; 
....................     
....................             #if defined(SPIRAM_CS_TRIS) 
....................             case TCP_SPI_RAM: 
....................                SPIRAMPutArray(ptrDest, (BYTE*)ptrSource, wLength); 
....................                break; 
....................             #endif 
....................          } 
....................          break; 
01230:  BRA    1294
....................     
....................       case TCP_ETH_RAM: 
....................          switch(vDestType) 
01232:  MOVLB  3
01234:  MOVF   x69,W
01236:  XORLW  01
01238:  MOVLB  0
0123A:  BZ    1242
0123C:  XORLW  01
0123E:  BZ    1272
01240:  BRA    1292
....................          { 
....................             case TCP_PIC_RAM: 
....................                if(ptrSource!=(PTR_BASE)-1) 
01242:  MOVLB  3
01244:  INCFSZ x6A,W
01246:  BRA    124E
01248:  INCFSZ x6B,W
0124A:  BRA    124E
0124C:  BRA    125C
....................                   MACSetReadPtr(ptrSource); 
0124E:  MOVFF  36B,370
01252:  MOVFF  36A,36F
01256:  MOVLB  0
01258:  RCALL  0DFC
0125A:  MOVLB  3
....................                MACGetArray((BYTE*)ptrDest, wLength); 
0125C:  MOVFF  368,383
01260:  MOVFF  367,382
01264:  MOVFF  36E,385
01268:  MOVFF  36D,384
0126C:  MOVLB  0
0126E:  RCALL  0E68
....................                break; 
01270:  BRA    1292
....................     
....................             case TCP_ETH_RAM: 
....................                MACMemCopyAsync(ptrDest, ptrSource, wLength); 
01272:  MOVFF  368,370
01276:  MOVFF  367,36F
0127A:  MOVFF  36B,372
0127E:  MOVFF  36A,371
01282:  MOVFF  36E,374
01286:  MOVFF  36D,373
0128A:  RCALL  0F08
....................                while(!MACIsMemCopyDone()); 
0128C:  RCALL  1188
0128E:  MOVF   01,F
01290:  BZ    128C
....................                break; 
....................     
....................             #if defined(SPIRAM_CS_TRIS) 
....................             case TCP_SPI_RAM: 
....................                if(ptrSource!=(PTR_BASE)-1) 
....................                   MACSetReadPtr(ptrSource); 
....................                w = sizeof(vBuffer); 
....................                while(wLength) 
....................                { 
....................                   if(w > wLength) 
....................                      w = wLength; 
....................                    
....................                   // Read and write a chunk    
....................                   MACGetArray(vBuffer, w); 
....................                   SPIRAMPutArray(ptrDest, vBuffer, w); 
....................                   ptrDest += w; 
....................                   wLength -= w; 
....................                } 
....................                break; 
....................             #endif 
....................          } 
....................          break; 
01292:  BRA    1294
....................     
....................       #if defined(SPIRAM_CS_TRIS) 
....................       case TCP_SPI_RAM: 
....................          switch(vDestType) 
....................          { 
....................             case TCP_PIC_RAM: 
....................                SPIRAMGetArray(ptrSource, (BYTE*)ptrDest, wLength); 
....................                break; 
....................     
....................             case TCP_ETH_RAM: 
....................                if(ptrDest!=(PTR_BASE)-1) 
....................                   MACSetWritePtr(ptrDest); 
....................                w = sizeof(vBuffer); 
....................                while(wLength) 
....................                { 
....................                   if(w > wLength) 
....................                      w = wLength; 
....................                    
....................                   // Read and write a chunk    
....................                   SPIRAMGetArray(ptrSource, vBuffer, w); 
....................                   ptrSource += w; 
....................                   MACPutArray(vBuffer, w); 
....................                   wLength -= w; 
....................                } 
....................                break; 
....................     
....................             case TCP_SPI_RAM: 
....................                // Copy all of the data over in chunks 
....................                w = sizeof(vBuffer); 
....................                while(wLength) 
....................                { 
....................                   if(w > wLength) 
....................                      w = wLength; 
....................                       
....................                   SPIRAMGetArray(ptrSource, vBuffer, w); 
....................                   SPIRAMPutArray(ptrDest, vBuffer, w); 
....................                   ptrSource += w; 
....................                   ptrDest += w; 
....................                   wLength -= w; 
....................                } 
....................                break; 
....................          } 
....................          break; 
....................       #endif          
....................    } 
01294:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void TCPRAMCopyROM(PTR_BASE wDest, BYTE wDestType, ROM BYTE* wSource,  
....................                         WORD wLength) 
....................  
....................   Summary: 
....................    Copies data to/from various memory mediums. 
....................  
....................   Description: 
....................    This function copies data between memory mediums (PIC RAM, SPI 
....................    RAM, and Ethernet buffer RAM).  This function is to be used when  
....................    copying from ROM. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    wDest      - Address to write to 
....................    wDestType   - Destination meidum (TCP_PIC_RAM, TCP_ETH_RAM, TCP_SPI_RAM) 
....................    wSource      - Address to copy from 
....................    wLength      - Number of bytes to copy 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    Copying to a destination region that overlaps with the source address  
....................    is supported only if the destination start address is at a lower memory  
....................    address (closer to 0x0000) than the source pointer. 
....................     
....................    This function is aliased to TCPRAMCopy on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... static void TCPRAMCopyROM(PTR_BASE wDest, BYTE wDestType, ROM BYTE* wSource, WORD wLength) 
.................... { 
....................    BYTE vBuffer[16]; 
....................    WORD w; 
....................     
....................    switch(wDestType) 
....................    { 
....................       case TCP_PIC_RAM: 
....................          memcpypgm2ram((void*)(BYTE*)wDest, (ROM void*)wSource, wLength); 
....................          break; 
....................     
....................       case TCP_ETH_RAM: 
....................          if(wDest!=(PTR_BASE)-1) 
....................             MACSetWritePtr(wDest); 
....................          w = sizeof(vBuffer); 
....................          while(wLength) 
....................          { 
....................             if(w > wLength) 
....................                w = wLength; 
....................              
....................             // Read and write a chunk    
....................             memcpypgm2ram(vBuffer, (ROM void*)wSource, w); 
....................             MACPutArray(vBuffer, w); 
....................             wSource += w; 
....................             wLength -= w; 
....................          } 
....................          break; 
....................     
....................       #if defined(SPIRAM_CS_TRIS) 
....................       case TCP_SPI_RAM: 
....................          w = sizeof(vBuffer); 
....................          while(wLength) 
....................          { 
....................             if(w > wLength) 
....................                w = wLength; 
....................              
....................             // Read and write a chunk    
....................             memcpypgm2ram(vBuffer, (ROM void*)wSource, w); 
....................             SPIRAMPutArray(wDest, vBuffer, w); 
....................             wDest += w; 
....................             wSource += w; 
....................             wLength -= w; 
....................          } 
....................          break; 
....................       #endif 
....................    } 
.................... } 
.................... #endif 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    SSL Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPStartSSLClient(TCP_SOCKET hTCP, BYTE* host) 
....................  
....................   Summary: 
....................    Begins an SSL client session. 
....................  
....................   Description: 
....................    This function escalates the current connection to an SSL secured  
....................    connection by initiating an SSL client handshake. 
....................  
....................   Precondition: 
....................    TCP is initialized and hTCP is already connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to secure 
....................    host      - Expected host name on certificate (currently ignored) 
....................  
....................   Return Values: 
....................    TRUE       - an SSL connection was initiated 
....................    FALSE       - Insufficient SSL resources (stubs) were available 
....................  
....................   Remarks: 
....................    The host parameter is currently ignored and is not validated. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL_CLIENT) 
.................... BOOL TCPStartSSLClient(TCP_SOCKET hTCP, BYTE* host) 
.................... { 
....................    BYTE i; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    // Make sure SSL is not established already 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       return FALSE; 
....................     
....................    // Try to start the session 
....................    MyTCBStub.sslStubID = SSLStartSession(hTCP, NULL, 0); 
....................     
....................    // Make sure a session stub was obtained 
....................    if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................       return FALSE; 
....................  
....................    // Mark connection as handshaking and return 
....................    MyTCBStub.sslReqMessage = SSL_CLIENT_HELLO; 
....................    MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................    MyTCBStub.sslTxHead = MyTCBStub.txHead; 
....................    MyTCBStub.Flags.bSSLHandshaking = 1; 
....................    for(i = 0; i < 5u; i++) 
....................    {// Skip first 5 bytes in TX for the record header 
....................       if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    return TRUE; 
.................... } 
.................... #endif // SSL Client 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPStartSSLClientEx(TCP_SOCKET hTCP, BYTE* host, BYTE * buffer, BYTE suppDataType) 
....................  
....................   Summary: 
....................    Begins an SSL client session. 
....................  
....................   Description: 
....................    This function escalates the current connection to an SSL secured  
....................    connection by initiating an SSL client handshake. 
....................  
....................   Precondition: 
....................    TCP is initialized and hTCP is already connected. 
....................  
....................   Parameters: 
....................    hTCP         - TCP connection to secure 
....................    host         - Expected host name on certificate (currently ignored) 
....................    buffer         - Buffer for supplementary data return 
....................    suppDataType    - Type of supplementary data to copy 
....................  
....................   Return Values: 
....................    TRUE       - an SSL connection was initiated 
....................    FALSE       - Insufficient SSL resources (stubs) were available 
....................  
....................   Remarks: 
....................    The host parameter is currently ignored and is not validated. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL_CLIENT) 
.................... BOOL TCPStartSSLClientEx(TCP_SOCKET hTCP, BYTE* host, void * buffer, BYTE suppDataType) 
.................... { 
....................    BYTE i; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    // Make sure SSL is not established already 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       return FALSE; 
....................     
....................    // Try to start the session 
....................    MyTCBStub.sslStubID = SSLStartSession(hTCP, buffer, suppDataType); 
....................     
....................    // Make sure a session stub was obtained 
....................    if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................       return FALSE; 
....................  
....................    // Mark connection as handshaking and return 
....................    MyTCBStub.sslReqMessage = SSL_CLIENT_HELLO; 
....................    MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................    MyTCBStub.sslTxHead = MyTCBStub.txHead; 
....................    MyTCBStub.Flags.bSSLHandshaking = 1; 
....................    for(i = 0; i < 5u; i++) 
....................    {// Skip first 5 bytes in TX for the record header 
....................       if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    return TRUE; 
.................... } 
.................... #endif // SSL Client 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPStartSSLServer(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Begins an SSL server session. 
....................  
....................   Description: 
....................    This function sets up an SSL server session when a new connection is 
....................    established on an SSL port. 
....................  
....................   Precondition: 
....................    TCP is initialized and hTCP is already connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to secure 
....................  
....................   Return Values: 
....................    TRUE      - an SSL connection was initiated 
....................    FALSE      - Insufficient SSL resources (stubs) were available 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL_SERVER) 
.................... BOOL TCPStartSSLServer(TCP_SOCKET hTCP) 
.................... { 
....................    BYTE i; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    SyncTCB(); 
....................     
....................    // Make sure SSL is not established already 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       return TRUE; 
....................     
....................    // Try to start the session 
....................    MyTCBStub.sslStubID = SSLStartSession(hTCP, NULL, 0); 
....................     
....................    // Make sure a session stub was obtained 
....................    if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................       return FALSE; 
....................  
....................    // Swap the localPort and localSSLPort 
....................    MyTCBStub.remoteHash.Val = MyTCB.localPort.Val; 
....................    MyTCB.localPort.Val = MyTCB.localSSLPort.Val; 
....................    MyTCB.localSSLPort.Val = MyTCBStub.remoteHash.Val;    
....................  
....................    // Mark connection as handshaking and return 
....................    MyTCBStub.sslReqMessage = SSL_NO_MESSAGE; 
....................    MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................    MyTCBStub.sslTxHead = MyTCBStub.txHead; 
....................    MyTCBStub.Flags.bSSLHandshaking = 1; 
....................    for(i = 0; i < 5u; i++) 
....................    {// Skip first 5 bytes in TX for the record header 
....................       if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    return TRUE; 
.................... } 
.................... #endif // SSL Client 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPAddSSLListener(TCP_SOCKET hTCP, WORD port) 
....................  
....................   Summary: 
....................    Listens for SSL connection on a specific port. 
....................  
....................   Description: 
....................    This function adds an additional listening port to a TCP connection.   
....................    Connections made on this alternate port will be secured via SSL. 
....................  
....................   Precondition: 
....................    TCP is initialized and hTCP is listening. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to secure 
....................    port      - SSL port to listen on 
....................  
....................   Return Values: 
....................    TRUE      - SSL port was added. 
....................    FALSE      - The socket was not a listening socket. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL_SERVER) 
.................... BOOL TCPAddSSLListener(TCP_SOCKET hTCP, WORD port) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    if(MyTCBStub.smState != TCP_LISTEN) 
....................       return FALSE; 
....................     
....................    SyncTCB(); 
....................     
....................    MyTCB.localSSLPort.Val = port; 
....................    MyTCBStub.sslTxHead = port; 
....................  
....................    return TRUE; 
.................... } 
.................... #endif // SSL Server 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPRequestSSLMessage(TCP_SOCKET hTCP, BYTE msg) 
....................  
....................   Summary: 
....................    Requests an SSL message to be transmitted. 
....................  
....................   Description: 
....................    This function is called to request that a specific SSL message be 
....................    transmitted.  This message should only be called by the SSL module. 
....................     
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to use 
....................    msg         - One of the SSL_MESSAGE types to transmit. 
....................  
....................   Return Values: 
....................    TRUE      - The message was requested. 
....................    FALSE      - Another message is already pending transmission. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... BOOL TCPRequestSSLMessage(TCP_SOCKET hTCP, BYTE msg) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    if(msg == SSL_NO_MESSAGE || MyTCBStub.sslReqMessage == SSL_NO_MESSAGE) 
....................    { 
....................       MyTCBStub.sslReqMessage = msg; 
....................       return TRUE; 
....................    } 
....................     
....................    return FALSE; 
.................... } 
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPSSLIsHandshaking(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines if an SSL session is still handshaking. 
....................  
....................   Description: 
....................    Call this function after calling TCPStartSSLClient until FALSE is 
....................    returned.  Then your application may continue with its normal data 
....................    transfer (which is now secured). 
....................     
....................   Precondition: 
....................    TCP is initialized and hTCP is connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to check 
....................  
....................   Return Values: 
....................    TRUE      - SSL handshake is still progressing 
....................    FALSE      - SSL handshake has completed 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... BOOL TCPSSLIsHandshaking(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    return MyTCBStub.Flags.bSSLHandshaking;    
.................... } 
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPIsSSL(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines if a TCP connection is secured with SSL. 
....................  
....................   Description: 
....................    Call this function to determine whether or not a TCP connection is  
....................    secured with SSL. 
....................     
....................   Precondition: 
....................    TCP is initialized and hTCP is connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to check 
....................  
....................   Return Values: 
....................    TRUE      - Connection is secured via SSL 
....................    FALSE      - Connection is not secured 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... BOOL TCPIsSSL(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................       return FALSE; 
....................     
....................    return TRUE; 
.................... } 
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLHandshakeComplete(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Clears the SSL handshake flag. 
....................  
....................   Description: 
....................    This function clears the flag indicating that an SSL handshake is 
....................    complete. 
....................     
....................   Precondition: 
....................    TCP is initialized and hTCP is connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to set 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLHandshakeComplete(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    MyTCBStub.Flags.bSSLHandshaking = 0; 
.................... } 
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLDecryptMAC(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, WORD len) 
....................  
....................   Summary: 
....................    Decrypts and MACs data arriving via SSL. 
....................  
....................   Description: 
....................    This function decrypts data in the TCP buffer and calculates the MAC over 
....................    the data.  All data is left in the exact same location in the TCP buffer. 
....................    It is called to help process incoming SSL records. 
....................     
....................   Precondition: 
....................    TCP is initialized, hTCP is connected, and ctx's Sbox is loaded. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to decrypt in 
....................    ctx         - ARCFOUR encryption context to use 
....................    len       - Number of bytes to crypt 
....................    inPlace      - TRUE to write back in place, FALSE to write at end of 
....................                currently visible data. 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLDecryptMAC(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, WORD len) 
.................... { 
....................    PTR_BASE wSrc, wDest, wBlockLen, wTemp; 
....................    BYTE buffer[32]; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    // Set up the pointers 
....................    SyncTCBStub(hTCP); 
....................    wSrc = MyTCBStub.rxTail; 
....................    wDest = wSrc; 
....................     
....................    // Handle 32 bytes at a time 
....................    while(len) 
....................    { 
....................       // Determine how many bytes we can read 
....................       wBlockLen = sizeof(buffer); 
....................       if(wBlockLen > len) // Don't do more than we should 
....................          wBlockLen = len; 
....................        
....................       // Read those bytes to a buffer 
....................       if(wSrc + wBlockLen > MyTCBStub.bufferEnd) 
....................       {// Two part read 
....................          wTemp = MyTCBStub.bufferEnd - wSrc + 1; 
....................          TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, wSrc, MyTCBStub.vMemoryMedium, wTemp); 
....................          TCPRAMCopy((PTR_BASE)buffer+wTemp, TCP_PIC_RAM, MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, wBlockLen - wTemp); 
....................          wSrc = MyTCBStub.bufferRxStart + wBlockLen - wTemp; 
....................       } 
....................       else 
....................       { 
....................          TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, wSrc, MyTCBStub.vMemoryMedium, wBlockLen); 
....................          wSrc += wBlockLen; 
....................       } 
....................        
....................       // Decrypt and hash 
....................       ARCFOURCrypt(ctx, buffer, wBlockLen); 
....................       SSLMACAdd(buffer, wBlockLen); 
....................        
....................       // Write decrypted bytes back 
....................       if(wDest + wBlockLen > MyTCBStub.bufferEnd) 
....................       {// Two part write 
....................          wTemp = MyTCBStub.bufferEnd - wDest + 1; 
....................          TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, wTemp); 
....................          TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer+wTemp, TCP_PIC_RAM, wBlockLen - wTemp); 
....................          wDest = MyTCBStub.bufferRxStart + wBlockLen - wTemp; 
....................       } 
....................       else 
....................       { 
....................          TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, wBlockLen); 
....................          wDest += wBlockLen; 
....................       } 
....................        
....................       // Update the length remaining 
....................       len -= wBlockLen; 
....................    } 
.................... }    
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLInPlaceMACEncrypt(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx,  
....................                            BYTE* MACSecret, WORD len) 
....................  
....................   Summary: 
....................    Encrypts and MACs data in place in the TCP TX buffer. 
....................  
....................   Description: 
....................    This function encrypts data in the TCP buffer while calcuating a MAC.   
....................    When encryption is finished, the MAC is appended to the buffer and  
....................    the record will be ready to transmit. 
....................     
....................   Precondition: 
....................    TCP is initialized, hTCP is connected, and ctx's Sbox is loaded. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to encrypt in 
....................    ctx         - ARCFOUR encryption context to use 
....................    MACSecret   - MAC encryption secret to use 
....................    len       - Number of bytes to crypt 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLInPlaceMACEncrypt(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, BYTE* MACSecret, WORD len) 
.................... { 
....................    PTR_BASE pos; 
....................    WORD blockLen; 
....................    BYTE buffer[32]; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    // Set up the pointers 
....................    SyncTCBStub(hTCP); 
....................    pos = MyTCBStub.txHead; 
....................    for(blockLen = 0; blockLen < 5u; blockLen++) 
....................    {// Skips first 5 bytes for the header 
....................       if(++pos >= MyTCBStub.bufferRxStart) 
....................          pos = MyTCBStub.bufferTxStart; 
....................    } 
....................     
....................    // Handle 32 bytes at a time 
....................    while(len) 
....................    { 
....................       // Determine how many bytes we can read 
....................       blockLen = sizeof(buffer); 
....................       if(blockLen > len) // Don't do more than we should 
....................          blockLen = len; 
....................       if(blockLen > MyTCBStub.bufferRxStart - pos) // Don't pass the end 
....................          blockLen = MyTCBStub.bufferRxStart - pos; 
....................        
....................       // Read those bytes to a buffer 
....................       TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, pos, MyTCBStub.vMemoryMedium, blockLen); 
....................        
....................       // Hash and encrypt 
....................       SSLMACAdd(buffer, blockLen); 
....................       ARCFOURCrypt(ctx, buffer, blockLen); 
....................        
....................       // Put them back 
....................       TCPRAMCopy(pos, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, blockLen); 
....................        
....................       // Update the pointers 
....................       pos += blockLen; 
....................       len -= blockLen; 
....................       if(pos >= MyTCBStub.bufferRxStart) 
....................          pos = MyTCBStub.bufferTxStart; 
....................    } 
....................     
....................    // Calculate and add the MAC 
....................    SSLMACCalc(MACSecret, buffer); 
....................    ARCFOURCrypt(ctx, buffer, 16); 
....................  
....................    // Write the MAC to the TX FIFO 
....................    // Can't use TCPPutArray here because TCPIsPutReady() saves 16 bytes for the MAC 
....................    // TCPPut* functions use this to prevent writing too much data.  Therefore, the 
....................    // functionality is duplicated here. 
....................     
....................    len = 16; 
....................    blockLen = 0; 
....................    // See if we need a two part put 
....................    if(MyTCBStub.sslTxHead + len >= MyTCBStub.bufferRxStart) 
....................    { 
....................       blockLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead; 
....................       TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, blockLen); 
....................       len -= blockLen; 
....................       MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................     
....................    TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&buffer[blockLen], TCP_PIC_RAM, len); 
....................    MyTCBStub.sslTxHead += len; 
....................  
.................... }    
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLPutRecordHeader(TCP_SOCKET hTCP, BYTE* hdr, BOOL recDone) 
....................  
....................   Summary: 
....................    Writes an SSL record header and sends an SSL record. 
....................  
....................   Description: 
....................    This function writes an SSL record header to the pending TCP SSL data,  
....................    then indicates that the data is ready to be sent by moving the txHead 
....................    pointer. 
....................     
....................    If the record is complete, set recDone to TRUE.  The sslTxHead  
....................    pointer will be moved forward 5 bytes to leave space for a future  
....................    record header.  If the record is only partially sent, use FALSE and 
....................    to leave the pointer where it is so that more data can be added 
....................    to the record.  Partial records can only be used for the  
....................    SERVER_CERTIFICATE handshake message. 
....................     
....................   Precondition: 
....................    TCP is initialized, and hTCP is connected with an active SSL session. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to write the header and transmit with 
....................    hdr         - Record header (5 bytes) to send or NULL to just  
....................               move the pointerctx 
....................    recDone      - TRUE if the record is done, FALSE otherwise 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLPutRecordHeader(TCP_SOCKET hTCP, BYTE* hdr, BOOL recDone) 
.................... { 
....................    BYTE i; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    // Set up the pointers 
....................    SyncTCBStub(hTCP); 
....................     
....................    // Write the header if needed 
....................    if(hdr) 
....................    {// This is a new record, so insert the header 
....................       for(i = 0; i < 5u; i++) 
....................       { 
....................          TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)hdr+i, TCP_PIC_RAM, sizeof(BYTE)); 
....................          if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart) 
....................             MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................       } 
....................    } 
....................     
....................    // Move the txHead pointer to indicate what data is ready 
....................    // Also, flush just the header, then all the data.  This shotguns two  
....................    // packets down the line, therefore causing immediate ACKs by the  
....................    // remote node.  Reconnect handshakes are as much as 60% faster now. 
....................    TCPFlush(hTCP); 
....................    MyTCBStub.txHead = MyTCBStub.sslTxHead; 
....................    TCPFlush(hTCP); 
....................     
....................    // If this record is done, move the sslTxHead forward 
....................    // to accomodate the next record header 
....................    if(recDone) 
....................    { 
....................       for(i = 0; i < 5u; i++) 
....................       {// Skip first 5 bytes in TX for the record header 
....................          if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................             MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................       } 
....................    } 
.................... }    
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPSSLGetPendingTxSize(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines how many bytes are pending for a future SSL record. 
....................  
....................   Description: 
....................    This function determines how many bytes are pending for a future SSL 
....................    record. 
....................     
....................   Precondition: 
....................    TCP is initialized, and hTCP is connected with an active SSL connection. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to check 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... WORD TCPSSLGetPendingTxSize(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    // Non-SSL connections have no pending SSL data 
....................    //if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................    //   return 0; 
....................           
....................    // Determine how many bytes are waiting to be written in this record 
....................    if(MyTCBStub.sslTxHead > MyTCBStub.txHead) 
....................       return MyTCBStub.sslTxHead - MyTCBStub.txHead - 5; 
....................    else 
....................       return (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.txHead - MyTCBStub.sslTxHead - 1) - 5; 
.................... } 
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLHandleIncoming(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Hands newly arrive TCP data to the SSL module for processing. 
....................  
....................   Description: 
....................    This function processes incoming TCP data as an SSL record and  
....................    performs any necessary repositioning and decrypting. 
....................     
....................   Precondition: 
....................    TCP is initialized, and hTCP is connected with an active SSL session. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to handle incoming data on 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLHandleIncoming(TCP_SOCKET hTCP) 
.................... { 
....................    PTR_BASE prevRxTail, nextRxHead, startRxTail, wSrc, wDest; 
....................    WORD wToMove, wLen, wSSLBytesThatPoofed, wDecryptedBytes; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    // Sync the stub 
....................    SyncTCBStub(hTCP); 
....................  
....................    // If new data is waiting 
....................    if(MyTCBStub.sslRxHead != MyTCBStub.rxHead) 
....................    { 
....................       // Reconfigure pointers for SSL use 
....................       prevRxTail = MyTCBStub.rxTail; 
....................       nextRxHead = MyTCBStub.rxHead; 
....................       MyTCBStub.rxTail = MyTCBStub.rxHead; 
....................       MyTCBStub.rxHead = MyTCBStub.sslRxHead; 
....................        
....................       do 
....................       { 
....................          startRxTail = MyTCBStub.rxTail; 
....................  
....................          // Handle incoming data.  This function performs deframing of the  
....................          // SSL records, decryption, and MAC verification. 
....................          wSSLBytesThatPoofed = TCPIsGetReady(hTCP); 
....................          wDecryptedBytes = SSLRxRecord(hTCP, MyTCBStub.sslStubID); 
....................          wSSLBytesThatPoofed -= TCPIsGetReady(hTCP); 
....................  
....................          // Now need to move data to fill the SSL header/MAC/padding hole,  
....................          // if there is one 
....................          if(wSSLBytesThatPoofed) 
....................          {    
....................             // Sync the TCP so we can see if there is a TCP hole 
....................             SyncTCB(); 
....................  
....................             // Calculate how big the SSL hole is 
....................             if(MyTCB.sHoleSize == -1) 
....................             {// Just need to move pending SSL data 
....................                wToMove = TCPIsGetReady(hTCP); 
....................             } 
....................             else 
....................             {// A TCP hole exists, so move all data 
....................                wToMove = TCPIsGetReady(hTCP) + MyTCB.sHoleSize + MyTCB.wFutureDataSize; 
....................             } 
....................              
....................             // Start with the destination as the startRxTail and source as current rxTail 
....................             wDest = startRxTail; 
....................             wSrc = MyTCBStub.rxTail; 
....................              
....................             // If data exists between the end of the buffer and  
....................             // the destination, then move it forward 
....................             if(wSrc > wDest) 
....................             { 
....................                wLen = MyTCBStub.bufferEnd - wSrc + 1; 
....................                if(wLen > wToMove) 
....................                   wLen = wToMove; 
....................                TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium,  
....................                         wSrc, MyTCBStub.vMemoryMedium, wLen); 
....................                wDest += wLen; 
....................                wSrc = MyTCBStub.bufferRxStart; 
....................                wToMove -= wLen; 
....................             } 
....................              
....................             // If data remains to be moved, fill in to end of buffer 
....................             if(wToMove) 
....................             { 
....................                wLen = MyTCBStub.bufferEnd - wDest + 1; 
....................                if(wLen > wToMove) 
....................                   wLen = wToMove; 
....................                TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium,  
....................                         wSrc, MyTCBStub.vMemoryMedium, wLen); 
....................                wDest = MyTCBStub.bufferRxStart; 
....................                wSrc += wLen; 
....................                wToMove -= wLen; 
....................             } 
....................              
....................             // If data still remains, copy from from front + len to front 
....................             if(wToMove) 
....................             { 
....................                TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, 
....................                         wSrc, MyTCBStub.vMemoryMedium, wToMove); 
....................             } 
....................  
....................             // Since bytes poofed, we need to move the head pointers  
....................             // backwards by an equal amount. 
....................             MyTCBStub.rxHead -= wSSLBytesThatPoofed; 
....................             if(MyTCBStub.rxHead < MyTCBStub.bufferRxStart) 
....................                MyTCBStub.rxHead += MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................             MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................          } 
....................              
....................          // Move tail pointer forward by the number of decrypted bytes ready  
....................          // for the application (but not poofed bytes) 
....................          MyTCBStub.rxTail = startRxTail + wDecryptedBytes; 
....................          if(MyTCBStub.rxTail > MyTCBStub.bufferEnd) 
....................             MyTCBStub.rxTail -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................          nextRxHead += wDecryptedBytes; 
....................           
....................          // Loop until SSLRxRecord() runs out of data and stops doing  
....................          // anything 
....................       } while(wSSLBytesThatPoofed || (startRxTail != MyTCBStub.rxTail)); 
....................  
....................       // Restore TCP buffer pointers to point to the decrypted application data  
....................       // only 
....................       if(nextRxHead > MyTCBStub.bufferEnd) 
....................          nextRxHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................       MyTCBStub.rxTail = prevRxTail; 
....................       MyTCBStub.rxHead = nextRxHead; 
....................    } 
.................... }    
.................... #endif 
....................  
....................  
.................... #endif //#if defined(STACK_USE_TCP) 
....................  
....................     
....................    void TCPTouch(TCP_SOCKET s) 
....................    { 
....................       SyncTCBStub(s); 
....................       if(MyTCBStub.smState == TCP_ESTABLISHED) 
....................       { 
....................          MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
....................          SyncTCB(); 
....................       } 
....................    } 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
....................    #include "_DNS.c" //ccs had to rename this driver to not conflict an s7600 driver in the default include path - a bug in the compiler 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS) 
....................    #include "MPFS.c" 
.................... #endif 
....................  
.................... #if (defined(STACK_USE_HTTP2) || defined(STACK_USE_HTTP2_SERVER)) && !defined(__HTTP2_C) 
....................     #include "HTTP2.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_HTTP) || defined(STACK_USE_HTTP_SERVER) 
....................     #include "HTTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP1_SERVER) 
....................    #include "ccs_HTTP.c" 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///                              HTTP.C 
.................... /// 
.................... /// Simple webserver for the Microchip TCP/IP stack. 
.................... /// NOTE: THIS IS A DIFFERENT HTTP.C THAN WHAT MICROCHIP PROVIDES 
.................... /// 
.................... /// **** CONFIGURATION **** 
.................... /// 
.................... /// STACK_USE_HTTP - Define this to be true before you include stacktsk.c 
.................... ///        in your application.  Defining this to be true will cause 
.................... ///        the stack to include the HTTP portion and execute the init 
.................... ///        and process any HTTP tasks. 
.................... /// 
.................... /// HTTP_PORT - The TCP/IP port the HTTP server will listen to for HTTP 
.................... ///        connections. 
.................... /// 
.................... /// HTTP_NUM_SOCKETS - Number of sockets the stack will open for the 
.................... ///        HTTP server.  You probably will be fine with just 1.  The 
.................... ///        more sockets you use the more RAM is used to hold buffers 
.................... ///        and state configuration. 
.................... /// 
.................... /// HTTP_GET_PARAM_MAX_SIZE - This defines the maximum size of several 
.................... ///        buffers.  This limits the size of your GET or POST requests 
.................... ///        and all CGI POST data: 
.................... ///            If using GET, then max amount of cgi data is this value 
.................... ///            minus everything else on the initial GET command (which 
.................... ///            also includes the filename).  I believe the max specified 
.................... ///            by W3C is 255. 
.................... ///            If using POST, then this is the maximum size for one 
.................... ///            key=value pair (including the '=' sign). 
.................... ///        These values do not inlude any escape characters. 
.................... /// 
.................... /// HTTP_USE_CHUNKS - Set to TRUE to make the HTTP server 1.1 compliant 
.................... ///      and will use Transfer-Encoding: chunked.  Default is FALSE. 
.................... /// 
.................... /// HTTP_USE_DOUBLE_ESCAPE - If your HTTP pages need more escape 
.................... ///      chars, set this to TRUE.  When set to TRUE your HTTP pages have 
.................... ///      two escape characters after the %.  An example of each: 
.................... ///         If FALSE: %A 
.................... ///         If TRUE: %0A 
.................... /// 
.................... /// HTTP_USE_CONTENT_TYPE - Set to TRUE if your http_get_page() has a third 
.................... ///      parameter which is the content-type of the requested page. 
.................... /// 
.................... /// **** HOW IT WORKS **** 
.................... /// 
.................... /// The TCP/IP stack will open sockets to the desired ports.  It will 
.................... /// then listen for GET or POST requests.  When it gets a GET or POST 
.................... /// request it passes the page request to the callback function 
.................... /// http_get_page() which then returns 0 if the page doesn't exist, or 
.................... /// a pointer to the constant memory area that holds the page in program 
.................... /// memory.  If it was a POST request it waits until the HTTP header is 
.................... /// done and then saves the POST data into a buffer, and passes the 
.................... /// buffer to the callback function http_exec_cgi().  http_exec_cgi() will 
.................... /// parse the CGI post data and act upon it.  When done, the HTTP 
.................... /// server then responds by sending the page.  If the page is to have 
.................... /// variable data, it can be represented by an escape code - %0 or %1 
.................... /// for example.  When the HTTP stack sees such an escape code it calls 
.................... /// the callback function http_format_char() to format the escape code 
.................... /// into the needed variable data (such as ADC readings).  After the 
.................... /// HTTP stack is done sending the request it will close the port. 
.................... /// If the page didn't exist in program memory it will send a 404 File 
.................... /// not found error.  If there was a problem/timeout parsing the request 
.................... /// the HTTP stack will send a 500 Internal Server Error response. 
.................... /// 
.................... /// **** CALL BACK FUNCTIONS **** 
.................... /// 
.................... /// Your main application must provide the following callback functions to 
.................... /// fill application dependent needs: 
.................... /// 
.................... /// http_get_page(char *file); 
.................... ///    If HTTP_USE_CONTENT_TYPE is FALSE, this is the proper prototype.  Else, 
.................... ///    if HTTP_USE_CONTENT_TYPE is TRUE then see the next paragraph. 
.................... ///    A call-back function provided by your application that finds the 
.................... ///    required file.  If the file exists, returns address to page in 
.................... ///    program memory.  If it doesn't exist, returns 0. 
.................... /// 
.................... /// http_get_page(char *file_str, unsigned int32 *retAddress, char *retStr); 
.................... ///    If HTTP_USE_CONTENT_TYPE is TRUE, this is the proper prototype.  Else, 
.................... ///    if HTTP_USE_CONTENT_TYPE is FALSE then see the previous paragraph. 
.................... ///    A call-back function provided by your application that finds the 
.................... ///    required file.  If the file exists, saves value to retAddress.  If 
.................... ///    the file doesn't exist, will save 0 to retAddress.  retStr is the 
.................... ///    content-type (text/html, text/xml, etc). 
.................... /// 
.................... /// http_exec_cgi(unsigned int32 file, char *key, char *val); 
.................... ///    A call-back function provided by your application that processes incoming 
.................... ///    CGI commands.  key and val are the incoming key=val CGI pairs.  file is 
.................... ///    the file address as returned by http_get_page(). 
.................... /// 
.................... /// int http_format_char(unsigned int32 file, char id, char *str, unsigned int8 max_ret); 
.................... ///    Given an escaped character in the program memory HTTP file, convert to 
.................... ///    variable data.  id is the escaped character, *str is where to save the 
.................... ///    result.  max_ret is the maximum amount of bytes you can save to *str. 
.................... ///    Returns the number of bytes written to *str.  file is 
.................... ///    the file address as returned by http_get_page(). 
.................... /// 
.................... /// **** LIMITATIONS **** 
.................... /// 
.................... /// When creating web pages with forms, keep your form names (keys) simple 
.................... /// because the HTTP stack does not format the escape characters.  For example, 
.................... /// when sending "Pass+Word" the HTTP client will parse it out as "Pass%2bWord". 
.................... /// The HTTP stack will correctly parse out the escape chars when retrieving 
.................... /// the value, but not the key.  Therefore keep your keys simple. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// * Author         Date           Comment 
.................... /// *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
.................... /// 
.................... /// * Darren Rook    Oct 05 2006    Bug fix involving POST 
.................... /// 
.................... /// * Darren Rook    Summer 2006    Large parts of this rewritten to fix 
.................... ///                                 many bugs.  The biggest bug is that 
.................... ///                                 it can send pages and receive CGI that 
.................... ///                                 is larger than 1 TCP packet.  Also 
.................... ///                                 added the HTTP_USE_CHUNKS, 
.................... ///                                 HTTP_USE_DOUBLE_ESCAPE and 
.................... ///                                 HTTP_USE_CONTENT_TYPE paremeters. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __CCS_HTTP1_C__ 
.................... #define __CCS_HTTP1_C__ 
....................  
.................... //#define debug_http   printf 
.................... #define debug_http(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u) 
....................  
.................... rom char http_404_error[]="<HTML><BODY><H1>404 Error</H1><HR><P>File Not found.</BODY></HTML>"; 
.................... rom char http_500_error[]="<HTML><BODY><H1>500 Error</H1><HR><P>Internal Server Error</BODY></HTML>"; 
....................  
.................... //key=val pair string, & delimited 
.................... void http_parse_cgi_str(unsigned int32 file, char *cgistr); 
....................  
.................... unsigned int8 http_socket[HTTP_NUM_SOCKETS]={INVALID_SOCKET}; 
....................  
.................... enum { 
....................    HTTP_DISABLED = 0xFF, 
....................    HTTP_IGNORE, 
....................    HTTP_LISTEN_WAIT, 
....................    HTTP_CONNECTED, 
....................    HTTP_GET_HEADERS, 
....................    HTTP_GET_POST, 
....................    HTTP_GET_POST_CONTINUE, 
....................    HTTP_SEND_RESPONSE, 
....................    HTTP_SEND_RESPONSE_CONTINUE, 
....................    HTTP_CLOSE, 
....................    HTTP_CLOSE_WAITING, 
....................    HTTP_CLOSED 
.................... } http_state[HTTP_NUM_SOCKETS]={HTTP_IGNORE}; 
....................  
.................... //strips out any escape characters that the HTTP client may have inserted. 
.................... // (+ is replaced with space) 
.................... // (%xx is replaced with character representation of xx) 
.................... char * http_escape_chars(char *str) 
.................... { 
....................    char *ostr; 
....................    char new[3]; 
....................    char c; 
....................    char val; 
....................  
....................    new[2]=0; 
*
06732:  MOVLB  3
06734:  CLRF   x04
....................  
....................    ostr = str; 
06736:  MOVFF  2FF,301
0673A:  MOVFF  2FE,300
....................  
....................    while((c=*str) != 0) 
0673E:  MOVFF  2FF,03
06742:  MOVFF  2FE,FE9
06746:  MOVFF  2FF,FEA
0674A:  MOVFF  FEF,305
0674E:  MOVLB  3
06750:  MOVF   x05,F
06752:  BZ    682A
....................    { 
....................       if (c=='+') 
06754:  MOVF   x05,W
06756:  SUBLW  2B
06758:  BNZ   6776
....................          *str++=' '; 
0675A:  MOVLB  2
0675C:  MOVFF  2FF,03
06760:  MOVF   xFE,W
06762:  INCF   xFE,F
06764:  BTFSC  FD8.2
06766:  INCF   xFF,F
06768:  MOVWF  FE9
0676A:  MOVFF  03,FEA
0676E:  MOVLW  20
06770:  MOVWF  FEF
06772:  BRA    6826
06774:  MOVLB  3
....................       else if (c=='%') 
06776:  MOVF   x05,W
06778:  SUBLW  25
0677A:  BNZ   681E
....................       { 
....................          memcpy(new, str + 1, 2); 
0677C:  MOVLW  01
0677E:  MOVLB  2
06780:  ADDWF  xFE,W
06782:  MOVLB  3
06784:  MOVWF  x07
06786:  MOVLW  00
06788:  MOVLB  2
0678A:  ADDWFC xFF,W
0678C:  MOVLB  3
0678E:  MOVWF  x08
06790:  MOVLW  03
06792:  MOVWF  FEA
06794:  MOVLW  02
06796:  MOVWF  FE9
06798:  MOVFF  308,FE2
0679C:  MOVFF  307,FE1
067A0:  MOVWF  01
067A2:  MOVFF  FE6,FEE
067A6:  DECFSZ 01,F
067A8:  BRA    67A2
....................          val = strtoul(new, 0, 16); 
067AA:  MOVLW  03
067AC:  MOVWF  x0A
067AE:  MOVLW  02
067B0:  MOVWF  x09
067B2:  CLRF   x0C
067B4:  CLRF   x0B
067B6:  CLRF   x0E
067B8:  MOVLW  10
067BA:  MOVWF  x0D
067BC:  MOVLB  0
067BE:  BRA    620C
067C0:  MOVFF  00,306
....................          *str++ = val; 
067C4:  MOVLB  2
067C6:  MOVFF  2FF,03
067CA:  MOVF   xFE,W
067CC:  INCF   xFE,F
067CE:  BTFSC  FD8.2
067D0:  INCF   xFF,F
067D2:  MOVWF  FE9
067D4:  MOVFF  03,FEA
067D8:  MOVFF  306,FEF
....................          memmove(str, str + 2, strlen(str) - 1); 
067DC:  MOVLW  02
067DE:  ADDWF  xFE,W
067E0:  MOVLB  3
067E2:  MOVWF  x07
067E4:  MOVLW  00
067E6:  MOVLB  2
067E8:  ADDWFC xFF,W
067EA:  MOVLB  3
067EC:  MOVWF  x08
067EE:  MOVFF  2FF,31C
067F2:  MOVFF  2FE,31B
067F6:  MOVLB  0
067F8:  RCALL  660E
067FA:  MOVLW  01
067FC:  SUBWF  01,W
067FE:  MOVLB  3
06800:  MOVWF  x09
06802:  MOVFF  2FF,30D
06806:  MOVFF  2FE,30C
0680A:  MOVFF  308,30F
0680E:  MOVFF  307,30E
06812:  CLRF   x11
06814:  MOVWF  x10
06816:  MOVLB  0
06818:  BRA    6648
....................       } 
0681A:  BRA    6826
0681C:  MOVLB  3
....................       else 
....................          str++; 
0681E:  MOVLB  2
06820:  INCF   xFE,F
06822:  BTFSC  FD8.2
06824:  INCF   xFF,F
06826:  MOVLB  3
06828:  BRA    673E
....................    } 
....................  
....................    return(ostr); 
0682A:  MOVFF  300,01
0682E:  MOVFF  301,02
06832:  MOVLB  0
06834:  RETURN 0
.................... } 
....................  
.................... void http_parse_cgi_string(unsigned int32 file, char *ptr) 
.................... { 
....................    char *pKey, *pValue, c; 
....................  
....................    pKey=ptr; 
*
07258:  MOVFF  2F8,2FA
0725C:  MOVFF  2F7,2F9
....................    pValue=0; 
07260:  MOVLB  2
07262:  CLRF   xFC
07264:  CLRF   xFB
....................  
....................    while(TRUE) 
....................    { 
....................       c = *ptr; 
07266:  MOVFF  2F7,FE9
0726A:  MOVFF  2F8,FEA
0726E:  MOVFF  FEF,2FD
....................       if ((c=='&') || (c==0)) 
07272:  MOVF   xFD,W
07274:  SUBLW  26
07276:  BZ    727C
07278:  MOVF   xFD,F
0727A:  BNZ   72DC
....................       { 
....................          *ptr=0; 
0727C:  MOVFF  2F7,FE9
07280:  MOVFF  2F8,FEA
07284:  CLRF   FEF
....................          http_escape_chars(pKey); 
07286:  MOVFF  2FA,2FF
0728A:  MOVFF  2F9,2FE
0728E:  MOVLB  0
07290:  CALL   6732
....................          http_escape_chars(pValue); 
07294:  MOVFF  2FC,2FF
07298:  MOVFF  2FB,2FE
0729C:  CALL   6732
....................          http_exec_cgi(file, pKey, pValue); 
072A0:  MOVFF  2F6,301
072A4:  MOVFF  2F5,300
072A8:  MOVFF  2F4,2FF
072AC:  MOVFF  2F3,2FE
072B0:  MOVFF  2FA,303
072B4:  MOVFF  2F9,302
072B8:  MOVFF  2FC,305
072BC:  MOVFF  2FB,304
072C0:  BRA    710A
....................          pKey=ptr+1; 
072C2:  MOVLW  01
072C4:  MOVLB  2
072C6:  ADDWF  xF7,W
072C8:  MOVWF  xF9
072CA:  MOVLW  00
072CC:  ADDWFC xF8,W
072CE:  MOVWF  xFA
....................          pValue=0; 
072D0:  CLRF   xFC
072D2:  CLRF   xFB
....................          if (c==0) 
072D4:  MOVF   xFD,F
072D6:  BNZ   72DA
....................             break; 
072D8:  BRA    7300
....................       } 
072DA:  BRA    72F8
....................       else if (c=='=') 
072DC:  MOVF   xFD,W
072DE:  SUBLW  3D
072E0:  BNZ   72F8
....................       { 
....................          *ptr=0; 
072E2:  MOVFF  2F7,FE9
072E6:  MOVFF  2F8,FEA
072EA:  CLRF   FEF
....................          pValue=ptr+1; 
072EC:  MOVLW  01
072EE:  ADDWF  xF7,W
072F0:  MOVWF  xFB
072F2:  MOVLW  00
072F4:  ADDWFC xF8,W
072F6:  MOVWF  xFC
....................       } 
....................       ptr++; 
072F8:  INCF   xF7,F
072FA:  BTFSC  FD8.2
072FC:  INCF   xF8,F
072FE:  BRA    7266
....................    } 
07300:  MOVLB  0
07302:  RETURN 0
.................... } 
....................  
.................... unsigned int8 _httpPutcSocket; 
....................  
.................... #define tcp_http_tx_left()  TCPIsPutReady(_httpPutcSocket) 
....................  
.................... void set_tcp_http_putc(unsigned int8 newSocket) 
.................... { 
....................    _httpPutcSocket=newSocket; 
*
0772E:  MOVFF  2FC,144
07732:  GOTO   809E (RETURN)
.................... } 
....................  
.................... int tcp_http_putc(char c) 
.................... { 
....................    return(TCPPut(_httpPutcSocket,c)); 
*
07898:  MOVFF  144,31B
0789C:  MOVFF  31A,31C
078A0:  BRA    7778
078A2:  CLRF   03
078A4:  MOVFF  03,02
078A8:  RETURN 0
.................... } 
....................  
.................... unsigned int32 lastHTTPPutConstPos[HTTP_NUM_SOCKETS]; 
.................... char * lastHTTPPutVarPos[HTTP_NUM_SOCKETS]; 
....................  
.................... #if HTTP_USE_CHUNKS 
.................... void TCPPutFileChunkStart(unsigned int16 count) 
.................... { 
....................    printf(tcp_http_putc, "%04LX\r\n", count); 
.................... } 
....................  
.................... void TCPPutFileChunkStop(void) 
.................... { 
....................    tcp_http_putc('\r'); 
....................    tcp_http_putc('\n'); 
.................... } 
.................... #else 
....................  #define TCPPutFileChunkStart(x) 
....................  #define TCPPutFileChunkStop() 
.................... #endif 
....................  
.................... typedef enum 
.................... { 
....................    TCP_PUT_CONST_EC_FINISH = 0, 
....................    TCP_PUT_CONST_EC_CONTINUE, 
....................    TCP_PUT_CONST_EC_ESCAPE 
.................... } TCP_PUT_CONST_EC; 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // TCPPutFileVarChunk(ptr) 
.................... // 
.................... // send a chunked response from ram 
.................... // 
.................... // ptr - data to send (well be sent as an http/1.1 chunk).  It will be updated 
.................... //          with the continue position before exit. 
.................... // 
.................... // Returns a status code: 
.................... //    TCP_PUT_CONST_EC_FINISH - The whole chunk was completed 
.................... //    TCP_PUT_CONST_EC_CONTINUE - The chunk needs to be continued 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //TCP_PUT_CONST_EC TCPPutFileVarChunk(char **retPtr) 
.................... //because of a compiler error i had to make this double pointer an int16, when 
.................... //it should be a char. 
.................... TCP_PUT_CONST_EC TCPPutFileVarChunk(unsigned int16 **retPtr) 
.................... { 
....................    unsigned int16 txLeft, n; 
....................    char *ptr, ec; 
....................  
....................    ptr=*retPtr; 
*
079EE:  MOVLB  2
079F0:  MOVFF  2FE,FE9
079F4:  MOVFF  2FF,FEA
079F8:  MOVFF  FEC,03
079FC:  MOVF   FED,F
079FE:  MOVFF  FEF,304
07A02:  MOVLB  3
07A04:  MOVFF  03,305
....................  
....................    n=strlen(ptr); 
07A08:  MOVFF  305,31C
07A0C:  MOVFF  304,31B
07A10:  MOVLB  0
07A12:  CALL   660E
07A16:  MOVLB  3
07A18:  CLRF   x03
07A1A:  MOVFF  01,302
....................  
....................    if (!n) 
07A1E:  MOVF   x02,W
07A20:  IORWF  x03,W
07A22:  BNZ   7A2A
....................       return(TCP_PUT_CONST_EC_FINISH); 
07A24:  MOVLW  00
07A26:  MOVWF  01
07A28:  BRA    7AB2
....................  
....................    txLeft = tcp_http_tx_left(); 
07A2A:  MOVFF  144,31F
07A2E:  MOVLB  0
07A30:  RCALL  7680
07A32:  MOVFF  02,301
07A36:  MOVFF  01,300
....................  
....................   #if HTTP_USE_CHUNKS 
....................    if (txLeft > 8) 
....................       txLeft -= 8;   //save space for 2x CRLF and 4 chars 
....................    else 
....................       return(TCP_PUT_CONST_EC_CONTINUE); 
....................   #else 
....................    if (!txLeft) 
07A3A:  MOVLB  3
07A3C:  MOVF   x00,W
07A3E:  IORWF  x01,W
07A40:  BNZ   7A48
....................       return(TCP_PUT_CONST_EC_CONTINUE); 
07A42:  MOVLW  01
07A44:  MOVWF  01
07A46:  BRA    7AB2
....................   #endif 
....................  
....................    if (n > txLeft) 
07A48:  MOVF   x01,W
07A4A:  SUBWF  x03,W
07A4C:  BNC   7A5C
07A4E:  BNZ   7A56
07A50:  MOVF   x02,W
07A52:  SUBWF  x00,W
07A54:  BC    7A5C
....................    { 
....................       ec = TCP_PUT_CONST_EC_CONTINUE; 
07A56:  MOVLW  01
07A58:  MOVWF  x06
....................    } 
07A5A:  BRA    7A66
....................    else 
....................    { 
....................       txLeft = n; 
07A5C:  MOVFF  303,301
07A60:  MOVFF  302,300
....................       ec = TCP_PUT_CONST_EC_FINISH; 
07A64:  CLRF   x06
....................    } 
....................  
....................    TCPPutFileChunkStart(txLeft); 
....................  
....................    while (txLeft--) 
07A66:  MOVFF  301,03
07A6A:  MOVF   x00,W
07A6C:  BTFSC  FD8.2
07A6E:  DECF   x01,F
07A70:  DECF   x00,F
07A72:  IORWF  03,W
07A74:  BZ    7A98
....................    { 
....................       tcp_http_putc(*ptr++); 
07A76:  MOVFF  305,03
07A7A:  MOVF   x04,W
07A7C:  INCF   x04,F
07A7E:  BTFSC  FD8.2
07A80:  INCF   x05,F
07A82:  MOVWF  FE9
07A84:  MOVFF  03,FEA
07A88:  MOVFF  FEF,307
07A8C:  MOVFF  307,31A
07A90:  MOVLB  0
07A92:  RCALL  7898
07A94:  MOVLB  3
07A96:  BRA    7A66
....................    } 
....................  
....................    TCPPutFileChunkStop(); 
....................  
....................    *retPtr=ptr; 
07A98:  MOVLB  2
07A9A:  MOVFF  2FE,FE9
07A9E:  MOVFF  2FF,FEA
07AA2:  MOVFF  305,FEC
07AA6:  MOVF   FED,F
07AA8:  MOVFF  304,FEF
....................  
....................    return(ec); 
07AAC:  MOVLB  3
07AAE:  MOVFF  306,01
07AB2:  MOVLB  0
07AB4:  RETURN 0
.................... } 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // TCPPutFileParseConst(addy, n, doSend) 
.................... // 
.................... // Reads file from Const memory.  Stops when it reaches an escape sequence, 
.................... // n chars or an end of file 
.................... // 
.................... // addy - data to read (well be sent as an http/1.1 chunk).  This address 
.................... //        will be updated for the next call. 
.................... // 
.................... // n - max number of chars to read from file.  will save the total number 
.................... //    of chars passed to this pointer. 
.................... // 
.................... // doSend - if TRUE, then send data to TCP socket 
.................... // 
.................... // returns the last char read 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... char TCPPutFileParseConst(unsigned int32 *retAddy, unsigned int16 *n, unsigned int8 doSend) 
*
07AD4:  MOVLB  3
07AD6:  CLRF   x12
07AD8:  CLRF   x11
07ADA:  BSF    x19.0
.................... { 
....................    char stopC, checkC; 
....................    unsigned int16 fileSize = 0, max; 
....................    unsigned int32 addy; 
....................    int1 premature = TRUE; 
....................  
....................    max = *n; 
07ADC:  MOVFF  30C,FE9
07AE0:  MOVFF  30D,FEA
07AE4:  MOVFF  FEC,314
07AE8:  MOVF   FED,F
07AEA:  MOVFF  FEF,313
....................    addy = *retAddy; 
07AEE:  MOVFF  30A,FE9
07AF2:  MOVFF  30B,FEA
07AF6:  MOVFF  FEF,315
07AFA:  MOVFF  FEC,316
07AFE:  MOVFF  FEC,317
07B02:  MOVFF  FEC,318
....................  
....................    while (TRUE) 
....................    { 
....................       read_program_memory(addy++, &stopC, 1); 
07B06:  MOVFF  318,03
07B0A:  MOVFF  317,02
07B0E:  MOVFF  316,01
07B12:  MOVFF  315,00
07B16:  MOVLW  01
07B18:  ADDWF  x15,F
07B1A:  BTFSC  FD8.0
07B1C:  INCF   x16,F
07B1E:  BTFSC  FD8.2
07B20:  INCF   x17,F
07B22:  BTFSC  FD8.2
07B24:  INCF   x18,F
07B26:  MOVFF  03,31D
07B2A:  MOVFF  02,31C
07B2E:  MOVFF  01,31B
07B32:  MOVFF  00,31A
07B36:  MOVFF  02,FF8
07B3A:  MOVFF  01,FF7
07B3E:  MOVFF  00,FF6
07B42:  MOVLW  03
07B44:  MOVWF  FEA
07B46:  MOVLW  0F
07B48:  MOVWF  FE9
07B4A:  CLRF   x1F
07B4C:  MOVLW  01
07B4E:  MOVWF  x1E
07B50:  MOVLB  0
07B52:  RCALL  7AB6
....................       if (stopC == '%') 
07B54:  MOVLB  3
07B56:  MOVF   x0F,W
07B58:  SUBLW  25
07B5A:  BNZ   7BDE
....................       { 
....................          read_program_memory(addy++, &checkC, 1); 
07B5C:  MOVFF  318,03
07B60:  MOVFF  317,02
07B64:  MOVFF  316,01
07B68:  MOVFF  315,00
07B6C:  MOVLW  01
07B6E:  ADDWF  x15,F
07B70:  BTFSC  FD8.0
07B72:  INCF   x16,F
07B74:  BTFSC  FD8.2
07B76:  INCF   x17,F
07B78:  BTFSC  FD8.2
07B7A:  INCF   x18,F
07B7C:  MOVFF  03,31D
07B80:  MOVFF  02,31C
07B84:  MOVFF  01,31B
07B88:  MOVFF  00,31A
07B8C:  MOVFF  02,FF8
07B90:  MOVFF  01,FF7
07B94:  MOVFF  00,FF6
07B98:  MOVLW  03
07B9A:  MOVWF  FEA
07B9C:  MOVLW  10
07B9E:  MOVWF  FE9
07BA0:  CLRF   x1F
07BA2:  MOVLW  01
07BA4:  MOVWF  x1E
07BA6:  MOVLB  0
07BA8:  RCALL  7AB6
....................          if (checkC == '%') 
07BAA:  MOVLB  3
07BAC:  MOVF   x10,W
07BAE:  SUBLW  25
07BB0:  BNZ   7BDA
....................          { 
....................             if (fileSize < max) 
07BB2:  MOVF   x12,W
07BB4:  SUBWF  x14,W
07BB6:  BNC   7BD6
07BB8:  BNZ   7BC0
07BBA:  MOVF   x13,W
07BBC:  SUBWF  x11,W
07BBE:  BC    7BD6
....................             { 
....................                if (doSend) 
07BC0:  MOVF   x0E,F
07BC2:  BZ    7BCE
....................                   tcp_http_putc('%'); 
07BC4:  MOVLW  25
07BC6:  MOVWF  x1A
07BC8:  MOVLB  0
07BCA:  RCALL  7898
07BCC:  MOVLB  3
....................                fileSize++; 
07BCE:  INCF   x11,F
07BD0:  BTFSC  FD8.2
07BD2:  INCF   x12,F
....................             } 
07BD4:  BRA    7BD8
....................             else 
....................                break; 
07BD6:  BRA    7C10
....................          } 
07BD8:  BRA    7BDC
....................          else 
....................             break;   //ESCAPE 
07BDA:  BRA    7C10
....................       } 
07BDC:  BRA    7C0E
....................       else if (stopC) 
07BDE:  MOVF   x0F,F
07BE0:  BZ    7C0A
....................       { 
....................          if (fileSize < max) 
07BE2:  MOVF   x12,W
07BE4:  SUBWF  x14,W
07BE6:  BNC   7C06
07BE8:  BNZ   7BF0
07BEA:  MOVF   x13,W
07BEC:  SUBWF  x11,W
07BEE:  BC    7C06
....................          { 
....................             if (doSend) 
07BF0:  MOVF   x0E,F
07BF2:  BZ    7BFE
....................                tcp_http_putc(stopC); 
07BF4:  MOVFF  30F,31A
07BF8:  MOVLB  0
07BFA:  RCALL  7898
07BFC:  MOVLB  3
....................             fileSize++; 
07BFE:  INCF   x11,F
07C00:  BTFSC  FD8.2
07C02:  INCF   x12,F
....................          } 
07C04:  BRA    7C08
....................          else 
....................             break; 
07C06:  BRA    7C10
....................       } 
07C08:  BRA    7C0E
....................       else 
....................       { 
....................          premature = FALSE; 
07C0A:  BCF    x19.0
....................          break;   //EOF (stopC == 0) 
07C0C:  BRA    7C10
....................       } 
07C0E:  BRA    7B06
....................    } 
....................  
....................    if (premature) 
07C10:  BTFSS  x19.0
07C12:  BRA    7C24
....................       addy--; 
07C14:  MOVLW  FF
07C16:  ADDWF  x15,F
07C18:  BTFSS  FD8.0
07C1A:  ADDWF  x16,F
07C1C:  BTFSS  FD8.0
07C1E:  ADDWF  x17,F
07C20:  BTFSS  FD8.0
07C22:  ADDWF  x18,F
....................  
....................    *n = fileSize; 
07C24:  MOVFF  30C,FE9
07C28:  MOVFF  30D,FEA
07C2C:  MOVFF  312,FEC
07C30:  MOVF   FED,F
07C32:  MOVFF  311,FEF
....................    *retAddy = addy; 
07C36:  MOVFF  30A,FE9
07C3A:  MOVFF  30B,FEA
07C3E:  MOVFF  315,FEF
07C42:  MOVFF  316,FEC
07C46:  MOVFF  317,FEC
07C4A:  MOVFF  318,FEC
....................  
....................    return(stopC); 
07C4E:  MOVFF  30F,01
07C52:  MOVLB  0
07C54:  RETURN 0
.................... } 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // TCPPutFileConstChunk(*addy) 
.................... // 
.................... // send a chunked response from constant memory 
.................... // 
.................... // addy - data to send (well be sent as an http/1.1 chunk).  This address 
.................... //        will be updated for the next call. 
.................... // 
.................... // returns a response: 
.................... //    TCP_PUT_CONST_EC_CONTINUE: we ran out of space to put more data, continue 
.................... //                            from this position on next call. 
.................... //    TCP_PUT_CONST_EC_ESCAPE:   an escape character 
.................... //    TCP_PUT_CONST_EC_FINISH:   we finished reading the chunk, end of file. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... TCP_PUT_CONST_EC TCPPutFileConstChunk(unsigned int32 *retAddy) 
07C56:  MOVLB  3
07C58:  CLRF   x06
07C5A:  CLRF   x05
.................... { 
....................    char stopC; 
....................    unsigned int32 addy; 
....................    unsigned int16 fileSize = 0, txLeft; 
....................    TCP_PUT_CONST_EC ec; 
....................  
....................    txLeft = tcp_http_tx_left(); 
07C5C:  MOVFF  144,31F
07C60:  MOVLB  0
07C62:  RCALL  7680
07C64:  MOVFF  02,308
07C68:  MOVFF  01,307
....................  
....................  #if HTTP_USE_CHUNKS 
....................    if (txLeft > 8) 
....................       txLeft -= 8;   //save space for 2x CRLF and 4 chars 
....................    else 
....................       return(TCP_PUT_CONST_EC_CONTINUE); 
....................  #else 
....................    if (!txLeft) 
07C6C:  MOVLB  3
07C6E:  MOVF   x07,W
07C70:  IORWF  x08,W
07C72:  BNZ   7C7A
....................       return(TCP_PUT_CONST_EC_CONTINUE); 
07C74:  MOVLW  01
07C76:  MOVWF  01
07C78:  BRA    7D1A
....................  #endif 
....................  
....................    addy = *retAddy; 
07C7A:  MOVLB  2
07C7C:  MOVFF  2FE,FE9
07C80:  MOVFF  2FF,FEA
07C84:  MOVFF  FEF,301
07C88:  MOVFF  FEC,302
07C8C:  MOVFF  FEC,303
07C90:  MOVFF  FEC,304
....................  
....................    fileSize = 0xFFFF; 
07C94:  MOVLB  3
07C96:  SETF   x06
07C98:  SETF   x05
....................    stopC = TCPPutFileParseConst(&addy, &fileSize, FALSE); 
07C9A:  MOVLW  03
07C9C:  MOVWF  x0B
07C9E:  MOVLW  01
07CA0:  MOVWF  x0A
07CA2:  MOVLW  03
07CA4:  MOVWF  x0D
07CA6:  MOVLW  05
07CA8:  MOVWF  x0C
07CAA:  CLRF   x0E
07CAC:  MOVLB  0
07CAE:  RCALL  7AD4
07CB0:  MOVFF  01,300
....................  
....................    if (!fileSize && (stopC!='%')) 
07CB4:  MOVLB  3
07CB6:  MOVF   x05,W
07CB8:  IORWF  x06,W
07CBA:  BNZ   7CC8
07CBC:  MOVF   x00,W
07CBE:  SUBLW  25
07CC0:  BZ    7CC8
....................       return(TCP_PUT_CONST_EC_FINISH); 
07CC2:  MOVLW  00
07CC4:  MOVWF  01
07CC6:  BRA    7D1A
....................  
....................    //TODO: optimize 
....................    if (fileSize > txLeft) 
07CC8:  MOVF   x08,W
07CCA:  SUBWF  x06,W
07CCC:  BNC   7CE4
07CCE:  BNZ   7CD6
07CD0:  MOVF   x05,W
07CD2:  SUBWF  x07,W
07CD4:  BC    7CE4
....................    { 
....................       fileSize = txLeft; 
07CD6:  MOVFF  308,306
07CDA:  MOVFF  307,305
.................... //      if (stopC == '%') 
.................... //         ec = TCP_PUT_CONST_EC_ESCAPE; 
.................... //      else 
....................          ec = TCP_PUT_CONST_EC_CONTINUE; 
07CDE:  MOVLW  01
07CE0:  MOVWF  x09
....................    } 
07CE2:  BRA    7CFC
....................    else 
....................    { 
....................       if (stopC == '%') 
07CE4:  MOVF   x00,W
07CE6:  SUBLW  25
07CE8:  BNZ   7CF0
....................          ec = TCP_PUT_CONST_EC_ESCAPE; 
07CEA:  MOVLW  02
07CEC:  MOVWF  x09
07CEE:  BRA    7CFC
....................       else if (stopC) 
07CF0:  MOVF   x00,F
07CF2:  BZ    7CFA
....................          ec = TCP_PUT_CONST_EC_CONTINUE; 
07CF4:  MOVLW  01
07CF6:  MOVWF  x09
07CF8:  BRA    7CFC
....................       else 
....................          ec = TCP_PUT_CONST_EC_FINISH; 
07CFA:  CLRF   x09
....................    } 
....................  
....................    TCPPutFileChunkStart(fileSize); 
....................  
....................    TCPPutFileParseConst(retAddy, &fileSize, TRUE); 
07CFC:  MOVFF  2FF,30B
07D00:  MOVFF  2FE,30A
07D04:  MOVLW  03
07D06:  MOVWF  x0D
07D08:  MOVLW  05
07D0A:  MOVWF  x0C
07D0C:  MOVLW  01
07D0E:  MOVWF  x0E
07D10:  MOVLB  0
07D12:  RCALL  7AD4
....................  
....................    TCPPutFileChunkStop(); 
....................  
....................    return(ec); 
07D14:  MOVLB  3
07D16:  MOVFF  309,01
07D1A:  MOVLB  0
07D1C:  GOTO   827A (RETURN)
.................... } 
....................  
.................... int TCPPutFileConstGetEscape(unsigned int32 addy) 
.................... { 
.................... #if HTTP_USE_DOUBLE_ESCAPE 
....................    char str[3]; 
....................    int ret; 
....................  
....................    read_program_memory(addy, &str[0], 2); 
....................    str[2] = 0; 
....................    ret = strtol(str, 0, 16); 
.................... #else 
....................    char ret; 
....................    read_program_memory(addy, &ret, 1); 
07D20:  MOVFF  302,FF8
07D24:  MOVFF  301,FF7
07D28:  MOVFF  300,FF6
07D2C:  MOVLW  03
07D2E:  MOVWF  FEA
07D30:  MOVLW  04
07D32:  MOVWF  FE9
07D34:  MOVLB  3
07D36:  CLRF   x1F
07D38:  MOVLW  01
07D3A:  MOVWF  x1E
07D3C:  MOVLB  0
07D3E:  RCALL  7AB6
.................... #endif 
....................  
....................    return(ret); 
07D40:  CLRF   03
07D42:  MOVLB  3
07D44:  MOVF   x04,W
07D46:  MOVWF  00
07D48:  BTFSC  FE8.7
07D4A:  DECF   03,F
07D4C:  MOVWF  01
07D4E:  MOVFF  03,02
07D52:  MOVLB  0
07D54:  GOTO   82BE (RETURN)
.................... } 
....................  
.................... int1 tcp_http_put_file(unsigned int8 which, unsigned int16 errorCode, unsigned int32 file, char *contentType) 
.................... { 
....................    static char str[40]; 
....................    unsigned int8 socket; 
....................    char ec; 
....................    int escaped; 
....................  
....................    static enum 
....................    { 
....................       HTTP_PUT_FILE_INIT = 0, 
....................       HTTP_PUT_FILE_CONTINUE, 
....................       HTTP_PUT_FILE_CHUNK_END, 
....................       HTTP_PUT_FILE_DONE 
....................    } status; 
....................  
....................    socket=http_socket[which]; 
*
08080:  CLRF   03
08082:  MOVLB  2
08084:  MOVF   xEF,W
08086:  ADDLW  41
08088:  MOVWF  FE9
0808A:  MOVLW  01
0808C:  ADDWFC 03,W
0808E:  MOVWF  FEA
08090:  MOVFF  FEF,2F8
....................  
....................    set_tcp_http_putc(socket); 
08094:  MOVFF  2F8,2FC
08098:  MOVLB  0
0809A:  GOTO   772E
....................  
....................    if (lastHTTPPutConstPos[which] == 0) 
0809E:  MOVLB  2
080A0:  MOVF   xEF,W
080A2:  MULLW  04
080A4:  MOVF   FF3,W
080A6:  CLRF   03
080A8:  ADDLW  45
080AA:  MOVWF  FE9
080AC:  MOVLW  01
080AE:  ADDWFC 03,W
080B0:  MOVWF  FEA
080B2:  MOVFF  FEF,2FC
080B6:  MOVFF  FEC,2FD
080BA:  MOVFF  FEC,2FE
080BE:  MOVFF  FEC,2FF
080C2:  MOVF   xFC,F
080C4:  BTFSS  FD8.2
080C6:  BRA    81FE
080C8:  MOVF   xFD,F
080CA:  BTFSS  FD8.2
080CC:  BRA    81FE
080CE:  MOVF   xFE,F
080D0:  BTFSS  FD8.2
080D2:  BRA    81FE
080D4:  MOVF   xFF,F
080D6:  BTFSS  FD8.2
080D8:  BRA    81FE
....................    { 
....................       lastHTTPPutVarPos[which] = 0; 
080DA:  BCF    FD8.0
080DC:  RLCF   xEF,W
080DE:  CLRF   03
080E0:  ADDLW  49
080E2:  MOVWF  FE9
080E4:  MOVLW  01
080E6:  ADDWFC 03,W
080E8:  MOVWF  FEA
080EA:  CLRF   FEC
080EC:  MOVF   FED,F
080EE:  CLRF   FEF
....................       lastHTTPPutConstPos[which] = file; 
080F0:  MOVF   xEF,W
080F2:  MULLW  04
080F4:  MOVF   FF3,W
080F6:  CLRF   03
080F8:  ADDLW  45
080FA:  MOVWF  FE9
080FC:  MOVLW  01
080FE:  ADDWFC 03,W
08100:  MOVWF  FEA
08102:  MOVFF  2F2,FEF
08106:  MOVFF  2F3,FEC
0810A:  MOVFF  2F4,FEC
0810E:  MOVFF  2F5,FEC
....................       status = HTTP_PUT_FILE_CONTINUE; 
08112:  MOVLW  01
08114:  MOVLB  1
08116:  MOVWF  x73
....................  
....................     #if HTTP_USE_CHUNKS 
....................       printf(tcp_http_putc,"HTTP/1.1 %LU ", errorCode); 
....................     #else 
....................       printf(tcp_http_putc,"HTTP/1.0 %LU ", errorCode); 
08118:  MOVLW  B6
0811A:  MOVWF  FF6
0811C:  MOVLW  00
0811E:  MOVWF  FF7
08120:  MOVLW  09
08122:  MOVLB  2
08124:  MOVWF  xFC
08126:  MOVLB  0
08128:  GOTO   78AA
0812C:  MOVLW  10
0812E:  MOVWF  FE9
08130:  MOVFF  2F1,2FD
08134:  MOVFF  2F0,2FC
08138:  GOTO   78D4
0813C:  MOVLW  20
0813E:  MOVLB  3
08140:  MOVWF  x1A
08142:  MOVLB  0
08144:  CALL   7898
....................     #endif 
....................  
....................       switch(errorCode) 
08148:  MOVLB  2
0814A:  MOVF   xF0,W
0814C:  MOVWF  00
0814E:  MOVF   xF1,W
08150:  MOVWF  03
08152:  MOVF   03,W
08154:  BNZ   8160
08156:  MOVLW  C8
08158:  SUBWF  00,W
0815A:  MOVLB  0
0815C:  BZ    8182
0815E:  MOVLB  2
08160:  MOVLW  01
08162:  SUBWF  03,W
08164:  BNZ   8170
08166:  MOVLW  94
08168:  SUBWF  00,W
0816A:  MOVLB  0
0816C:  BZ    819C
0816E:  MOVLB  2
08170:  MOVLW  01
08172:  SUBWF  03,W
08174:  BNZ   8180
08176:  MOVLW  F4
08178:  SUBWF  00,W
0817A:  MOVLB  0
0817C:  BZ    81A8
0817E:  MOVLB  2
08180:  BRA    81B8
....................       { 
....................          case 200: 
....................             printf(tcp_http_putc,"OK"); 
08182:  MOVLW  4F
08184:  MOVLB  3
08186:  MOVWF  x1A
08188:  MOVLB  0
0818A:  CALL   7898
0818E:  MOVLW  4B
08190:  MOVLB  3
08192:  MOVWF  x1A
08194:  MOVLB  0
08196:  CALL   7898
....................             break; 
0819A:  BRA    81BA
....................          case 404: 
....................             printf(tcp_http_putc,"Not found"); 
0819C:  MOVLW  C4
0819E:  MOVWF  FF6
081A0:  MOVLW  00
081A2:  MOVWF  FF7
081A4:  RCALL  79A8
....................             break; 
081A6:  BRA    81BA
....................          case 500: 
....................             printf(tcp_http_putc,"Server Error"); 
081A8:  MOVLW  CE
081AA:  MOVWF  FF6
081AC:  MOVLW  00
081AE:  MOVWF  FF7
081B0:  CALL   79A8
....................             break; 
081B4:  BRA    81BA
081B6:  MOVLB  2
....................          default: 
....................             break; 
081B8:  MOVLB  0
....................       } 
....................  
....................       printf(tcp_http_putc, "\r\nContent-Type: "); 
081BA:  MOVLW  DC
081BC:  MOVWF  FF6
081BE:  MOVLW  00
081C0:  MOVWF  FF7
081C2:  CALL   79A8
....................       if (contentType) 
081C6:  MOVLB  2
081C8:  MOVF   xF6,W
081CA:  IORWF  xF7,W
081CC:  BZ    81E2
....................          printf(tcp_http_putc, "%s", contentType); 
081CE:  MOVFF  2F7,FEA
081D2:  MOVFF  2F6,FE9
081D6:  MOVLB  0
081D8:  GOTO   79C8
081DC:  MOVLB  0
081DE:  BRA    81F0
081E0:  MOVLB  2
....................       else 
....................          printf(tcp_http_putc,"text/html"); 
081E2:  MOVLW  EE
081E4:  MOVWF  FF6
081E6:  MOVLW  00
081E8:  MOVWF  FF7
081EA:  MOVLB  0
081EC:  CALL   79A8
....................  
....................     #if HTTP_USE_CHUNKS 
....................       printf(tcp_http_putc, "\r\nConnection: close"); 
....................       printf(tcp_http_putc, "\r\nTransfer-Encoding: chunked"); 
....................     #endif 
....................  
....................       printf(tcp_http_putc, "\r\n\r\n"); 
081F0:  MOVLW  F8
081F2:  MOVWF  FF6
081F4:  MOVLW  00
081F6:  MOVWF  FF7
081F8:  CALL   79A8
081FC:  MOVLB  2
....................    } 
....................  
....................    if (lastHTTPPutVarPos[which]) 
081FE:  BCF    FD8.0
08200:  RLCF   xEF,W
08202:  CLRF   03
08204:  ADDLW  49
08206:  MOVWF  FE9
08208:  MOVLW  01
0820A:  ADDWFC 03,W
0820C:  MOVWF  FEA
0820E:  MOVF   FEF,F
08210:  BZ    824E
....................    { 
....................       TCPPutFileVarChunk(&lastHTTPPutVarPos[which]); 
08212:  BCF    FD8.0
08214:  RLCF   xEF,W
08216:  CLRF   03
08218:  ADDLW  49
0821A:  MOVWF  01
0821C:  MOVLW  01
0821E:  ADDWFC 03,F
08220:  MOVFF  01,2FC
08224:  MOVFF  03,2FD
08228:  MOVFF  03,2FF
0822C:  MOVFF  01,2FE
08230:  MOVLB  0
08232:  CALL   79EE
....................       lastHTTPPutVarPos[which] = 0; 
08236:  BCF    FD8.0
08238:  MOVLB  2
0823A:  RLCF   xEF,W
0823C:  CLRF   03
0823E:  ADDLW  49
08240:  MOVWF  FE9
08242:  MOVLW  01
08244:  ADDWFC 03,W
08246:  MOVWF  FEA
08248:  CLRF   FEC
0824A:  MOVF   FED,F
0824C:  CLRF   FEF
....................    } 
....................  
....................    if (status == HTTP_PUT_FILE_CONTINUE) 
0824E:  MOVLB  1
08250:  DECFSZ x73,W
08252:  BRA    83A2
....................    { 
....................       do { 
....................          ec = TCPPutFileConstChunk(&lastHTTPPutConstPos[which]); 
08254:  MOVLB  2
08256:  MOVF   xEF,W
08258:  MULLW  04
0825A:  MOVF   FF3,W
0825C:  CLRF   03
0825E:  ADDLW  45
08260:  MOVWF  01
08262:  MOVLW  01
08264:  ADDWFC 03,F
08266:  MOVFF  01,2FC
0826A:  MOVFF  03,2FD
0826E:  MOVFF  03,2FF
08272:  MOVFF  01,2FE
08276:  MOVLB  0
08278:  BRA    7C56
0827A:  MOVFF  01,2F9
....................  
....................          if (ec == TCP_PUT_CONST_EC_ESCAPE) 
0827E:  MOVLB  2
08280:  MOVF   xF9,W
08282:  SUBLW  02
08284:  BTFSS  FD8.2
08286:  BRA    8390
....................          { 
....................             escaped = TCPPutFileConstGetEscape(lastHTTPPutConstPos[which]); 
08288:  MOVF   xEF,W
0828A:  MULLW  04
0828C:  MOVF   FF3,W
0828E:  CLRF   03
08290:  ADDLW  45
08292:  MOVWF  FE9
08294:  MOVLW  01
08296:  ADDWFC 03,W
08298:  MOVWF  FEA
0829A:  MOVFF  FEF,2FC
0829E:  MOVFF  FEC,2FD
082A2:  MOVFF  FEC,2FE
082A6:  MOVFF  FEC,2FF
082AA:  MOVFF  2FF,303
082AE:  MOVFF  2FE,302
082B2:  MOVFF  2FD,301
082B6:  MOVFF  2FC,300
082BA:  MOVLB  0
082BC:  BRA    7D20
082BE:  MOVFF  02,2FB
082C2:  MOVFF  01,2FA
....................            #if HTTP_USE_DOUBLE_ESCAPE 
....................             lastHTTPPutConstPos[which] += 2; 
....................            #else 
....................             lastHTTPPutConstPos[which] += 1; 
082C6:  MOVLB  2
082C8:  MOVF   xEF,W
082CA:  MULLW  04
082CC:  MOVF   FF3,W
082CE:  CLRF   03
082D0:  ADDLW  45
082D2:  MOVWF  FE9
082D4:  MOVLW  01
082D6:  ADDWFC 03,W
082D8:  MOVWF  FEA
082DA:  MOVLW  01
082DC:  ADDWF  FEF,W
082DE:  MOVWF  00
082E0:  MOVLW  00
082E2:  ADDWFC FEC,W
082E4:  MOVWF  01
082E6:  MOVLW  00
082E8:  ADDWFC FEC,W
082EA:  MOVWF  02
082EC:  MOVLW  00
082EE:  ADDWFC FEC,W
082F0:  MOVF   FED,F
082F2:  MOVF   FED,F
082F4:  MOVF   FED,F
082F6:  MOVFF  00,FEF
082FA:  MOVFF  01,FEC
082FE:  MOVFF  02,FEC
08302:  MOVWF  FEC
....................            #endif 
....................             http_format_char(file, escaped, &str[0], sizeof(str)-1); 
08304:  MOVFF  2F5,2FF
08308:  MOVFF  2F4,2FE
0830C:  MOVFF  2F3,2FD
08310:  MOVFF  2F2,2FC
08314:  MOVFF  2FA,300
08318:  MOVLW  01
0831A:  MOVLB  3
0831C:  MOVWF  x02
0831E:  MOVLW  4B
08320:  MOVWF  x01
08322:  MOVLW  27
08324:  MOVWF  x03
08326:  MOVLB  0
08328:  BRA    7F5C
....................             lastHTTPPutVarPos[which] = &str[0]; 
0832A:  BCF    FD8.0
0832C:  MOVLB  2
0832E:  RLCF   xEF,W
08330:  CLRF   03
08332:  ADDLW  49
08334:  MOVWF  FE9
08336:  MOVLW  01
08338:  ADDWFC 03,W
0833A:  MOVWF  FEA
0833C:  MOVLW  01
0833E:  MOVWF  FEC
08340:  MOVF   FED,F
08342:  MOVLW  4B
08344:  MOVWF  FEF
....................             ec = TCPPutFileVarChunk(&lastHTTPPutVarPos[which]); 
08346:  BCF    FD8.0
08348:  RLCF   xEF,W
0834A:  CLRF   03
0834C:  ADDLW  49
0834E:  MOVWF  01
08350:  MOVLW  01
08352:  ADDWFC 03,F
08354:  MOVFF  01,2FC
08358:  MOVFF  03,2FD
0835C:  MOVFF  03,2FF
08360:  MOVFF  01,2FE
08364:  MOVLB  0
08366:  CALL   79EE
0836A:  MOVFF  01,2F9
....................             if (ec == TCP_PUT_CONST_EC_FINISH) 
0836E:  MOVLB  2
08370:  MOVF   xF9,F
08372:  BNZ   838C
....................                lastHTTPPutVarPos[which] = 0; 
08374:  BCF    FD8.0
08376:  RLCF   xEF,W
08378:  CLRF   03
0837A:  ADDLW  49
0837C:  MOVWF  FE9
0837E:  MOVLW  01
08380:  ADDWFC 03,W
08382:  MOVWF  FEA
08384:  CLRF   FEC
08386:  MOVF   FED,F
08388:  CLRF   FEF
0838A:  BRA    838E
....................             else 
....................                break; 
0838C:  BRA    83A0
....................          } 
0838E:  BRA    839E
....................          else 
....................          { 
....................             if (ec == TCP_PUT_CONST_EC_FINISH) 
08390:  MOVF   xF9,F
08392:  BNZ   839C
....................                status = HTTP_PUT_FILE_CHUNK_END; 
08394:  MOVLW  02
08396:  MOVLB  1
08398:  MOVWF  x73
0839A:  MOVLB  2
....................             break; 
0839C:  BRA    83A0
....................          } 
....................       } while (TRUE); 
0839E:  BRA    8256
083A0:  MOVLB  1
....................    } 
....................  
....................    if (status == HTTP_PUT_FILE_CHUNK_END) 
083A2:  MOVF   x73,W
083A4:  SUBLW  02
083A6:  BNZ   83AC
....................    { 
....................      #if HTTP_USE_CHUNKS 
....................       if (tcp_http_tx_left() > 8) 
....................       { 
....................          TCPPutFileChunkStart(0); 
....................          TCPPutFileChunkStop(); 
....................          status = HTTP_PUT_FILE_DONE; 
....................       } 
....................      #else 
....................       status = HTTP_PUT_FILE_DONE; 
083A8:  MOVLW  03
083AA:  MOVWF  x73
....................      #endif 
....................    } 
....................  
....................  
....................    TCPFlush(socket); 
083AC:  MOVFF  2F8,31F
083B0:  MOVLB  0
083B2:  CALL   7736
....................  
....................    return(status == HTTP_PUT_FILE_DONE); 
083B6:  MOVLB  1
083B8:  MOVF   x73,W
083BA:  SUBLW  03
083BC:  BZ    83C2
083BE:  MOVLW  00
083C0:  BRA    83C4
083C2:  MOVLW  01
083C4:  MOVWF  01
083C6:  MOVLB  0
083C8:  RETURN 0
.................... } 
....................  
.................... //initializes the HTTP state machine.  called automatically by the TCP/IP stack 
.................... void HTTPInit(void) { 
....................    unsigned int8 i; 
....................    debug_http("\r\nHTTP OPENING"); 
....................    if (HTTP_PORT != 0) 
....................    { 
....................       for (i=0;i<HTTP_NUM_SOCKETS;i++) 
*
02A70:  MOVLB  2
02A72:  CLRF   xE3
02A74:  MOVF   xE3,F
02A76:  BNZ   2AE2
....................       { 
....................          http_socket[i] = TCPOpen(0, TCP_OPEN_SERVER, HTTP_PORT, TCP_PURPOSE_HTTP_SERVER); 
02A78:  CLRF   03
02A7A:  MOVF   xE3,W
02A7C:  ADDLW  41
02A7E:  MOVWF  01
02A80:  MOVLW  01
02A82:  ADDWFC 03,F
02A84:  MOVFF  01,2E4
02A88:  MOVFF  03,2E5
02A8C:  CLRF   xE9
02A8E:  CLRF   xE8
02A90:  CLRF   xE7
02A92:  CLRF   xE6
02A94:  CLRF   xEA
02A96:  CLRF   xEC
02A98:  MOVLW  50
02A9A:  MOVWF  xEB
02A9C:  MOVLW  08
02A9E:  MOVWF  xED
02AA0:  MOVLB  0
02AA2:  BRA    2894
02AA4:  MOVFF  2E5,FEA
02AA8:  MOVFF  2E4,FE9
02AAC:  MOVFF  01,FEF
....................          debug_http("\r\nHTTP SOCKET=%X", http_socket[i]); 
....................          if (http_socket[i]!=INVALID_SOCKET) 
02AB0:  CLRF   03
02AB2:  MOVLB  2
02AB4:  MOVF   xE3,W
02AB6:  ADDLW  41
02AB8:  MOVWF  FE9
02ABA:  MOVLW  01
02ABC:  ADDWFC 03,W
02ABE:  MOVWF  FEA
02AC0:  MOVF   FEF,W
02AC2:  SUBLW  FE
02AC4:  BZ    2ADE
....................          { 
....................             http_state[i]=HTTP_LISTEN_WAIT; 
02AC6:  BCF    FD8.0
02AC8:  RLCF   xE3,W
02ACA:  CLRF   03
02ACC:  ADDLW  42
02ACE:  MOVWF  FE9
02AD0:  MOVLW  01
02AD2:  ADDWFC 03,W
02AD4:  MOVWF  FEA
02AD6:  MOVLW  01
02AD8:  MOVWF  FEC
02ADA:  MOVF   FED,F
02ADC:  MOVWF  FEF
....................          } 
02ADE:  INCF   xE3,F
02AE0:  BRA    2A74
....................       } 
....................    } 
....................    else 
....................    { 
....................       debug_http("\r\nHTTP DISABLED"); 
....................       for (i=0;i<HTTP_NUM_SOCKETS;i++) 
....................       { 
....................             http_state[i]=HTTP_DISABLED; 
....................       } 
....................    } 
02AE2:  MOVLB  0
02AE4:  GOTO   2B26 (RETURN)
.................... } 
....................  
.................... void HTTPServer(void) { 
....................    static char tokens_header[]=" "; 
....................    static char tokens_get[]="?"; 
....................    static char http_get_str[]="GET"; 
....................    static char http_post_str[]="POST"; 
....................    static char http_len_str[]="Content-Length:"; 
....................    //static char http_keepalive_str[]="keep-alive"; 
....................    //static char http_connection_str[]="Connection"; 
....................  
....................    static char buffer[HTTP_NUM_SOCKETS][HTTP_GET_PARAM_MAX_SIZE]; 
....................  
....................    static unsigned int8 i[HTTP_NUM_SOCKETS]; 
....................    static enum {HTTP_REQ_GET=1, HTTP_REQ_POST=2, HTTP_REQ_UNKOWN=0} http_cmd[HTTP_NUM_SOCKETS]={0}; 
....................    static unsigned int32 http_page_req[HTTP_NUM_SOCKETS]; 
....................    static unsigned int16 http_post_len[HTTP_NUM_SOCKETS]={0}; 
....................    static TICK http_timer[HTTP_NUM_SOCKETS]; 
....................  #if HTTP_USE_CONTENT_TYPE 
....................    static char contentType[HTTP_NUM_SOCKETS][12]; 
....................  #endif 
....................  
....................    int1 doneSend, postContinue; 
....................  
....................    char c, *pKey, *pValue; 
....................    unsigned int8 hs, currSocket; 
....................  
....................    for (hs=0; hs<HTTP_NUM_SOCKETS; hs++) 
*
0842E:  MOVLB  2
08430:  CLRF   xE9
08432:  MOVF   xE9,F
08434:  BTFSS  FD8.2
08436:  GOTO   9084
....................    { 
....................       if (http_state[hs]==HTTP_DISABLED) 
0843A:  BCF    FD8.0
0843C:  RLCF   xE9,W
0843E:  CLRF   03
08440:  ADDLW  42
08442:  MOVWF  FE9
08444:  MOVLW  01
08446:  ADDWFC 03,W
08448:  MOVWF  FEA
0844A:  MOVFF  FEC,2EC
0844E:  MOVF   FED,F
08450:  MOVFF  FEF,2EB
08454:  INCFSZ xEB,W
08456:  BRA    8460
08458:  MOVF   xEC,F
0845A:  BNZ   8460
....................          return; 
0845C:  GOTO   9084
....................  
....................       currSocket=http_socket[hs]; 
08460:  CLRF   03
08462:  MOVF   xE9,W
08464:  ADDLW  41
08466:  MOVWF  FE9
08468:  MOVLW  01
0846A:  ADDWFC 03,W
0846C:  MOVWF  FEA
0846E:  MOVFF  FEF,2EA
....................  
....................       if (!TCPIsConnected(currSocket)) 
08472:  MOVFF  2EA,2EB
08476:  MOVLB  0
08478:  CALL   5DC8
0847C:  MOVF   01,F
0847E:  BNZ   849C
....................          http_state[hs]=HTTP_LISTEN_WAIT; 
08480:  BCF    FD8.0
08482:  MOVLB  2
08484:  RLCF   xE9,W
08486:  CLRF   03
08488:  ADDLW  42
0848A:  MOVWF  FE9
0848C:  MOVLW  01
0848E:  ADDWFC 03,W
08490:  MOVWF  FEA
08492:  MOVLW  01
08494:  MOVWF  FEC
08496:  MOVF   FED,F
08498:  MOVWF  FEF
0849A:  MOVLB  0
....................  
....................       switch(http_state[hs]) 
0849C:  BCF    FD8.0
0849E:  MOVLB  2
084A0:  RLCF   xE9,W
084A2:  CLRF   03
084A4:  ADDLW  42
084A6:  MOVWF  FE9
084A8:  MOVLW  01
084AA:  ADDWFC 03,W
084AC:  MOVWF  FEA
084AE:  MOVF   FEF,W
084B0:  MOVWF  00
084B2:  INCF   FE9,F
084B4:  MOVF   FEF,W
084B6:  DECF   FE9,F
084B8:  MOVWF  03
084BA:  MOVLW  01
084BC:  SUBWF  03,W
084BE:  BNZ   84CA
084C0:  MOVLW  01
084C2:  SUBWF  00,W
084C4:  MOVLB  0
084C6:  BZ    8578
084C8:  MOVLB  2
084CA:  MOVLW  01
084CC:  SUBWF  03,W
084CE:  BNZ   84DA
084D0:  MOVLW  02
084D2:  SUBWF  00,W
084D4:  MOVLB  0
084D6:  BZ    8588
084D8:  MOVLB  2
084DA:  MOVLW  01
084DC:  SUBWF  03,W
084DE:  BNZ   84EC
084E0:  MOVLW  03
084E2:  SUBWF  00,W
084E4:  MOVLB  0
084E6:  BTFSC  FD8.2
084E8:  BRA    8640
084EA:  MOVLB  2
084EC:  MOVLW  01
084EE:  SUBWF  03,W
084F0:  BNZ   84FE
084F2:  MOVLW  04
084F4:  SUBWF  00,W
084F6:  MOVLB  0
084F8:  BTFSC  FD8.2
084FA:  BRA    8A50
084FC:  MOVLB  2
084FE:  MOVLW  01
08500:  SUBWF  03,W
08502:  BNZ   8510
08504:  MOVLW  05
08506:  SUBWF  00,W
08508:  MOVLB  0
0850A:  BTFSC  FD8.2
0850C:  BRA    8AB6
0850E:  MOVLB  2
08510:  MOVLW  01
08512:  SUBWF  03,W
08514:  BNZ   8524
08516:  MOVLW  06
08518:  SUBWF  00,W
0851A:  MOVLB  0
0851C:  BTFSC  FD8.2
0851E:  GOTO   8D20
08522:  MOVLB  2
08524:  MOVLW  01
08526:  SUBWF  03,W
08528:  BNZ   8538
0852A:  MOVLW  07
0852C:  SUBWF  00,W
0852E:  MOVLB  0
08530:  BTFSC  FD8.2
08532:  GOTO   8D62
08536:  MOVLB  2
08538:  MOVLW  01
0853A:  SUBWF  03,W
0853C:  BNZ   854C
0853E:  MOVLW  08
08540:  SUBWF  00,W
08542:  MOVLB  0
08544:  BTFSC  FD8.2
08546:  GOTO   8F4C
0854A:  MOVLB  2
0854C:  MOVLW  01
0854E:  SUBWF  03,W
08550:  BNZ   8560
08552:  MOVLW  09
08554:  SUBWF  00,W
08556:  MOVLB  0
08558:  BTFSC  FD8.2
0855A:  GOTO   8F9E
0855E:  MOVLB  2
08560:  MOVLW  01
08562:  SUBWF  03,W
08564:  BNZ   8574
08566:  MOVLW  0A
08568:  SUBWF  00,W
0856A:  MOVLB  0
0856C:  BTFSC  FD8.2
0856E:  GOTO   9078
08572:  MOVLB  2
08574:  GOTO   907A
....................       { 
....................          case HTTP_LISTEN_WAIT: 
....................             if (!TCPIsConnected(currSocket)) 
08578:  MOVFF  2EA,2EB
0857C:  CALL   5DC8
08580:  MOVF   01,F
08582:  BNZ   8588
....................                break; 
08584:  GOTO   907C
....................             debug_http("HTTP %U CONNECTED\r\n", hs); 
....................  
....................          //wait until we get '\r\n\r\n', which marks the end of the HTTP request header 
....................          case HTTP_CONNECTED: 
....................             debug_http("HTTP %U LISTENING\r\n", hs); 
....................             buffer[hs][0]=0; 
08588:  MOVLB  2
0858A:  MOVF   xE9,W
0858C:  MULLW  FE
0858E:  MOVF   FF3,W
08590:  CLRF   xEC
08592:  MOVWF  xEB
08594:  MOVLW  91
08596:  ADDWF  xEB,W
08598:  MOVWF  FE9
0859A:  MOVLW  01
0859C:  ADDWFC xEC,W
0859E:  MOVWF  FEA
085A0:  CLRF   FEF
....................             i[hs]=0; 
085A2:  CLRF   03
085A4:  MOVF   xE9,W
085A6:  ADDLW  8F
085A8:  MOVWF  FE9
085AA:  MOVLW  02
085AC:  ADDWFC 03,W
085AE:  MOVWF  FEA
085B0:  CLRF   FEF
....................             http_state[hs]=HTTP_GET_HEADERS; 
085B2:  BCF    FD8.0
085B4:  RLCF   xE9,W
085B6:  CLRF   03
085B8:  ADDLW  42
085BA:  MOVWF  FE9
085BC:  MOVLW  01
085BE:  ADDWFC 03,W
085C0:  MOVWF  FEA
085C2:  MOVLW  01
085C4:  MOVWF  FEC
085C6:  MOVF   FED,F
085C8:  MOVLW  03
085CA:  MOVWF  FEF
....................             http_timer[hs]=TickGet(); 
085CC:  MOVF   xE9,W
085CE:  MULLW  04
085D0:  MOVF   FF3,W
085D2:  CLRF   03
085D4:  ADDLW  97
085D6:  MOVWF  01
085D8:  MOVLW  02
085DA:  ADDWFC 03,F
085DC:  MOVFF  01,2EB
085E0:  MOVFF  03,2EC
085E4:  MOVLB  0
085E6:  CALL   1630
085EA:  MOVFF  2EC,FEA
085EE:  MOVFF  2EB,FE9
085F2:  MOVFF  00,FEF
085F6:  MOVFF  01,FEC
085FA:  MOVFF  02,FEC
085FE:  MOVFF  03,FEC
....................             http_page_req[hs]=0; 
08602:  MOVLB  2
08604:  MOVF   xE9,W
08606:  MULLW  04
08608:  MOVF   FF3,W
0860A:  CLRF   03
0860C:  ADDLW  91
0860E:  MOVWF  FE9
08610:  MOVLW  02
08612:  ADDWFC 03,W
08614:  MOVWF  FEA
08616:  MOVF   FEE,F
08618:  MOVF   FEE,F
0861A:  CLRF   FEC
0861C:  MOVF   FED,F
0861E:  CLRF   FEF
08620:  MOVF   FED,F
08622:  CLRF   FEF
08624:  MOVF   FED,F
08626:  CLRF   FEF
....................             http_post_len[hs]=0; 
08628:  BCF    FD8.0
0862A:  RLCF   xE9,W
0862C:  CLRF   03
0862E:  ADDLW  95
08630:  MOVWF  FE9
08632:  MOVLW  02
08634:  ADDWFC 03,W
08636:  MOVWF  FEA
08638:  CLRF   FEC
0863A:  MOVF   FED,F
0863C:  CLRF   FEF
0863E:  MOVLB  0
....................             //http_got_headers[hs]=FALSE; 
....................             //http_isKeepAlive[hs]=FALSE; 
....................  
....................          case HTTP_GET_HEADERS: 
....................             postContinue=FALSE; 
08640:  MOVLB  2
08642:  BCF    xE3.1
....................             while (TCPIsGetReady(currSocket) && TCPGet(currSocket, &c)) 
08644:  MOVFF  2EA,2F0
08648:  MOVLB  0
0864A:  CALL   5DF6
0864E:  MOVF   01,W
08650:  IORWF  02,W
08652:  BTFSC  FD8.2
08654:  BRA    89AC
08656:  MOVFF  2EA,2EB
0865A:  MOVLW  02
0865C:  MOVLB  2
0865E:  MOVWF  xED
08660:  MOVLW  E4
08662:  MOVWF  xEC
08664:  MOVLB  0
08666:  CALL   5E76
0866A:  MOVF   01,F
0866C:  BTFSC  FD8.2
0866E:  BRA    89AC
....................             { 
....................                //http_got_headers[hs]=TRUE; 
....................                if ( (c >= 0x20) && (i[hs] < HTTP_GET_PARAM_MAX_SIZE - 2) ) 
08670:  MOVLB  2
08672:  BTFSC  xE4.7
08674:  BRA    86C6
08676:  MOVF   xE4,W
08678:  SUBLW  1F
0867A:  BC    86C6
0867C:  CLRF   03
0867E:  MOVF   xE9,W
08680:  ADDLW  8F
08682:  MOVWF  FE9
08684:  MOVLW  02
08686:  ADDWFC 03,W
08688:  MOVWF  FEA
0868A:  MOVF   FEF,W
0868C:  SUBLW  FB
0868E:  BNC   86C6
....................                { 
....................                   buffer[hs][i[hs]++]=c; 
08690:  MOVF   xE9,W
08692:  MULLW  FE
08694:  MOVF   FF3,W
08696:  CLRF   xEC
08698:  MOVWF  xEB
0869A:  CLRF   03
0869C:  MOVF   xE9,W
0869E:  ADDLW  8F
086A0:  MOVWF  FE9
086A2:  MOVLW  02
086A4:  ADDWFC 03,W
086A6:  MOVWF  FEA
086A8:  MOVF   FEF,W
086AA:  INCF   FEF,F
086AC:  CLRF   03
086AE:  ADDWF  xEB,W
086B0:  MOVWF  01
086B2:  MOVF   xEC,W
086B4:  ADDWFC 03,F
086B6:  MOVF   01,W
086B8:  ADDLW  91
086BA:  MOVWF  FE9
086BC:  MOVLW  01
086BE:  ADDWFC 03,W
086C0:  MOVWF  FEA
086C2:  MOVFF  2E4,FEF
....................                } 
....................                if (c=='\n') 
086C6:  MOVF   xE4,W
086C8:  SUBLW  0A
086CA:  BTFSS  FD8.2
086CC:  BRA    89A8
....................                { 
....................                   buffer[hs][i[hs]]=0; 
086CE:  MOVF   xE9,W
086D0:  MULLW  FE
086D2:  MOVF   FF3,W
086D4:  CLRF   xEC
086D6:  MOVWF  xEB
086D8:  CLRF   03
086DA:  MOVF   xE9,W
086DC:  ADDLW  8F
086DE:  MOVWF  FE9
086E0:  MOVLW  02
086E2:  ADDWFC 03,W
086E4:  MOVWF  FEA
086E6:  CLRF   03
086E8:  MOVF   FEF,W
086EA:  ADDWF  xEB,W
086EC:  MOVWF  01
086EE:  MOVF   xEC,W
086F0:  ADDWFC 03,F
086F2:  MOVF   01,W
086F4:  ADDLW  91
086F6:  MOVWF  FE9
086F8:  MOVLW  01
086FA:  ADDWFC 03,W
086FC:  MOVWF  FEA
086FE:  CLRF   FEF
....................                   if ( 
....................                        ( ( pKey = strtok(&buffer[hs][0], tokens_header) ) !=0 ) && 
....................                        ( ( pValue = strtok(0, tokens_header) ) !=0 ) 
08700:  MOVF   xE9,W
08702:  MULLW  FE
08704:  MOVF   FF3,W
08706:  CLRF   xEC
08708:  MOVWF  xEB
0870A:  MOVLW  91
0870C:  ADDWF  xEB,W
0870E:  MOVWF  01
08710:  MOVLW  01
08712:  ADDWFC xEC,W
08714:  MOVWF  03
08716:  MOVFF  01,2ED
0871A:  MOVWF  xEE
0871C:  MOVWF  xF0
0871E:  MOVFF  01,2EF
08722:  MOVLW  01
08724:  MOVWF  xF2
08726:  MOVLW  74
08728:  MOVWF  xF1
0872A:  MOVLB  0
0872C:  CALL   6030
08730:  MOVFF  02,2E6
08734:  MOVFF  01,2E5
08738:  MOVLB  2
0873A:  MOVF   xE5,F
0873C:  BNZ   8744
0873E:  MOVF   xE6,F
08740:  BTFSC  FD8.2
08742:  BRA    8928
08744:  CLRF   xF0
08746:  CLRF   xEF
08748:  MOVLW  01
0874A:  MOVWF  xF2
0874C:  MOVLW  74
0874E:  MOVWF  xF1
08750:  MOVLB  0
08752:  CALL   6030
08756:  MOVFF  02,2E8
0875A:  MOVFF  01,2E7
0875E:  MOVLB  2
08760:  MOVF   xE7,F
08762:  BNZ   876A
08764:  MOVF   xE8,F
08766:  BTFSC  FD8.2
08768:  BRA    8928
....................                      ) 
....................                   { 
....................                      debug_http("HTTP %U PAIR %s = %s\r\n", hs, pKey, pValue); 
....................                      if ( (strcmp(pKey, http_get_str)==0) || (strcmp(pKey, http_post_str)==0) ) 
0876A:  MOVFF  2E6,2EC
0876E:  MOVFF  2E5,2EB
08772:  MOVLW  01
08774:  MOVWF  xEE
08776:  MOVLW  78
08778:  MOVWF  xED
0877A:  MOVLB  0
0877C:  CALL   60E0
08780:  MOVF   01,F
08782:  BZ    87A2
08784:  MOVFF  2E6,2EC
08788:  MOVFF  2E5,2EB
0878C:  MOVLW  01
0878E:  MOVLB  2
08790:  MOVWF  xEE
08792:  MOVLW  7C
08794:  MOVWF  xED
08796:  MOVLB  0
08798:  CALL   60E0
0879C:  MOVF   01,F
0879E:  BTFSS  FD8.2
087A0:  BRA    88BE
....................                      { 
....................                         pValue=strtok(pValue, tokens_get);  //chop the file after a ? 
087A2:  MOVFF  2E8,2F0
087A6:  MOVFF  2E7,2EF
087AA:  MOVLW  01
087AC:  MOVLB  2
087AE:  MOVWF  xF2
087B0:  MOVLW  76
087B2:  MOVWF  xF1
087B4:  MOVLB  0
087B6:  CALL   6030
087BA:  MOVFF  02,2E8
087BE:  MOVFF  01,2E7
....................                         http_escape_chars(pValue); 
087C2:  MOVFF  2E8,2FF
087C6:  MOVFF  2E7,2FE
087CA:  CALL   6732
....................                        #if HTTP_USE_CONTENT_TYPE 
....................                         http_get_page(pValue, &http_page_req[hs], &contentType[hs][0]); 
....................                        #else 
....................                         http_page_req[hs] = http_get_page(pValue); 
087CE:  MOVLB  2
087D0:  MOVF   xE9,W
087D2:  MULLW  04
087D4:  MOVF   FF3,W
087D6:  CLRF   03
087D8:  ADDLW  91
087DA:  MOVWF  01
087DC:  MOVLW  02
087DE:  ADDWFC 03,F
087E0:  MOVFF  01,2EB
087E4:  MOVFF  03,2EC
087E8:  MOVFF  2E8,2EE
087EC:  MOVFF  2E7,2ED
087F0:  MOVLB  0
087F2:  GOTO   6A00
087F6:  MOVFF  2EC,FEA
087FA:  MOVFF  2EB,FE9
087FE:  MOVFF  00,FEF
08802:  MOVFF  01,FEC
08806:  MOVFF  02,FEC
0880A:  MOVFF  03,FEC
....................                        #endif 
....................                         debug_http("HTTP %U FILE %s = %lx\r\n", hs, pValue, http_page_req[hs]); 
....................                         pValue=strtok(0, tokens_get); 
0880E:  MOVLB  2
08810:  CLRF   xF0
08812:  CLRF   xEF
08814:  MOVLW  01
08816:  MOVWF  xF2
08818:  MOVLW  76
0881A:  MOVWF  xF1
0881C:  MOVLB  0
0881E:  CALL   6030
08822:  MOVFF  02,2E8
08826:  MOVFF  01,2E7
....................                         if (pValue) 
0882A:  MOVLB  2
0882C:  MOVF   xE7,W
0882E:  IORWF  xE8,W
08830:  BZ    8874
....................                            http_parse_cgi_string(http_page_req[hs], pValue); 
08832:  MOVF   xE9,W
08834:  MULLW  04
08836:  MOVF   FF3,W
08838:  CLRF   03
0883A:  ADDLW  91
0883C:  MOVWF  FE9
0883E:  MOVLW  02
08840:  ADDWFC 03,W
08842:  MOVWF  FEA
08844:  MOVFF  FEF,2EB
08848:  MOVFF  FEC,2EC
0884C:  MOVFF  FEC,2ED
08850:  MOVFF  FEC,2EE
08854:  MOVFF  2EE,2F6
08858:  MOVFF  2ED,2F5
0885C:  MOVFF  2EC,2F4
08860:  MOVFF  2EB,2F3
08864:  MOVFF  2E8,2F8
08868:  MOVFF  2E7,2F7
0886C:  MOVLB  0
0886E:  CALL   7258
08872:  MOVLB  2
....................  
....................                         if (strcmp(pKey, http_get_str)==0) 
08874:  MOVFF  2E6,2EC
08878:  MOVFF  2E5,2EB
0887C:  MOVLW  01
0887E:  MOVWF  xEE
08880:  MOVLW  78
08882:  MOVWF  xED
08884:  MOVLB  0
08886:  CALL   60E0
0888A:  MOVF   01,F
0888C:  BNZ   88A6
....................                            http_cmd[hs]=HTTP_REQ_GET; 
0888E:  CLRF   03
08890:  MOVLB  2
08892:  MOVF   xE9,W
08894:  ADDLW  90
08896:  MOVWF  FE9
08898:  MOVLW  02
0889A:  ADDWFC 03,W
0889C:  MOVWF  FEA
0889E:  MOVLW  01
088A0:  MOVWF  FEF
088A2:  BRA    88BA
088A4:  MOVLB  0
....................                         else 
....................                            http_cmd[hs]=HTTP_REQ_POST; 
088A6:  CLRF   03
088A8:  MOVLB  2
088AA:  MOVF   xE9,W
088AC:  ADDLW  90
088AE:  MOVWF  FE9
088B0:  MOVLW  02
088B2:  ADDWFC 03,W
088B4:  MOVWF  FEA
088B6:  MOVLW  02
088B8:  MOVWF  FEF
....................                      } 
088BA:  BRA    8926
088BC:  MOVLB  0
....................                      else if (http_cmd[hs] != HTTP_REQ_UNKOWN)   //we processed a GET or POST 
088BE:  CLRF   03
088C0:  MOVLB  2
088C2:  MOVF   xE9,W
088C4:  ADDLW  90
088C6:  MOVWF  FE9
088C8:  MOVLW  02
088CA:  ADDWFC 03,W
088CC:  MOVWF  FEA
088CE:  MOVF   FEF,F
088D0:  BZ    8926
....................                      { 
....................                         //if you want to parse HTTP headers, do it here. 
....................                         //pKey and pVal hold the individual headers. 
....................  
....................                         //this driver only parses the Content-Length header. 
....................                         if (strcmp(pKey, http_len_str)==0) 
088D2:  MOVFF  2E6,2EC
088D6:  MOVFF  2E5,2EB
088DA:  MOVLW  01
088DC:  MOVWF  xEE
088DE:  MOVLW  81
088E0:  MOVWF  xED
088E2:  MOVLB  0
088E4:  CALL   60E0
088E8:  MOVF   01,F
088EA:  BNZ   8924
....................                         { 
....................                            http_post_len[hs]=atol(pValue); 
088EC:  BCF    FD8.0
088EE:  MOVLB  2
088F0:  RLCF   xE9,W
088F2:  CLRF   03
088F4:  ADDLW  95
088F6:  MOVWF  01
088F8:  MOVLW  02
088FA:  ADDWFC 03,F
088FC:  MOVFF  01,2EB
08900:  MOVFF  03,2EC
08904:  MOVFF  2E8,2EE
08908:  MOVFF  2E7,2ED
0890C:  MOVLB  0
0890E:  GOTO   7304
08912:  MOVFF  2EC,FEA
08916:  MOVFF  2EB,FE9
0891A:  MOVFF  01,FEC
0891E:  MOVF   FED,F
08920:  MOVFF  00,FEF
08924:  MOVLB  2
....................                         } 
....................                      } 
....................                   } 
08926:  BRA    8998
....................                   else if (i[hs] == 0) 
08928:  CLRF   03
0892A:  MOVF   xE9,W
0892C:  ADDLW  8F
0892E:  MOVWF  FE9
08930:  MOVLW  02
08932:  ADDWFC 03,W
08934:  MOVWF  FEA
08936:  MOVF   FEF,F
08938:  BNZ   8998
....................                   { 
....................                      //got a double \r\n 
....................                      debug_http("HTTP %U GET HEADER DONE\r\n", hs); 
....................                      if (http_cmd[hs] == HTTP_REQ_POST) 
0893A:  CLRF   03
0893C:  MOVF   xE9,W
0893E:  ADDLW  90
08940:  MOVWF  FE9
08942:  MOVLW  02
08944:  ADDWFC 03,W
08946:  MOVWF  FEA
08948:  MOVF   FEF,W
0894A:  SUBLW  02
0894C:  BNZ   896C
....................                      { 
....................                         http_state[hs]=HTTP_GET_POST; 
0894E:  BCF    FD8.0
08950:  RLCF   xE9,W
08952:  CLRF   03
08954:  ADDLW  42
08956:  MOVWF  FE9
08958:  MOVLW  01
0895A:  ADDWFC 03,W
0895C:  MOVWF  FEA
0895E:  MOVLW  01
08960:  MOVWF  FEC
08962:  MOVF   FED,F
08964:  MOVLW  04
08966:  MOVWF  FEF
....................                         postContinue=TRUE; 
08968:  BSF    xE3.1
....................                      } 
0896A:  BRA    8992
....................                      else 
....................                      { 
....................                         http_state[hs]=HTTP_SEND_RESPONSE; 
0896C:  BCF    FD8.0
0896E:  RLCF   xE9,W
08970:  CLRF   03
08972:  ADDLW  42
08974:  MOVWF  FE9
08976:  MOVLW  01
08978:  ADDWFC 03,W
0897A:  MOVWF  FEA
0897C:  MOVLW  01
0897E:  MOVWF  FEC
08980:  MOVF   FED,F
08982:  MOVLW  06
08984:  MOVWF  FEF
....................                         TCPDiscard(currSocket); 
08986:  MOVFF  2EA,2EB
0898A:  MOVLB  0
0898C:  CALL   7650
08990:  MOVLB  2
....................                      } 
....................                      break;   //break out of read from ethernet loop 
08992:  MOVLB  0
08994:  BRA    89AC
08996:  MOVLB  2
....................                   } 
....................                   i[hs]=0; 
08998:  CLRF   03
0899A:  MOVF   xE9,W
0899C:  ADDLW  8F
0899E:  MOVWF  FE9
089A0:  MOVLW  02
089A2:  ADDWFC 03,W
089A4:  MOVWF  FEA
089A6:  CLRF   FEF
....................                } 
089A8:  BRA    8644
089AA:  MOVLB  0
....................             } 
....................             if (TickGetDiff(TickGet(),http_timer[hs]) > TICKS_PER_SECOND*20) 
089AC:  CALL   1630
089B0:  MOVFF  03,2EE
089B4:  MOVFF  02,2ED
089B8:  MOVFF  01,2EC
089BC:  MOVFF  00,2EB
089C0:  MOVLB  2
089C2:  MOVF   xE9,W
089C4:  MULLW  04
089C6:  MOVF   FF3,W
089C8:  CLRF   03
089CA:  ADDLW  97
089CC:  MOVWF  FE9
089CE:  MOVLW  02
089D0:  ADDWFC 03,W
089D2:  MOVWF  FEA
089D4:  MOVFF  FEF,00
089D8:  MOVFF  FEC,01
089DC:  MOVFF  FEC,02
089E0:  MOVFF  FEC,03
089E4:  MOVF   00,W
089E6:  SUBWF  xEB,F
089E8:  MOVF   01,W
089EA:  SUBWFB xEC,F
089EC:  MOVF   02,W
089EE:  SUBWFB xED,F
089F0:  MOVF   03,W
089F2:  SUBWFB xEE,F
089F4:  BNZ   8A10
089F6:  MOVF   xED,W
089F8:  SUBLW  0A
089FA:  BC    8A44
089FC:  XORLW  FF
089FE:  BNZ   8A10
08A00:  MOVF   xEC,W
08A02:  SUBLW  EA
08A04:  BC    8A44
08A06:  XORLW  FF
08A08:  BNZ   8A10
08A0A:  MOVF   xEB,W
08A0C:  SUBLW  CC
08A0E:  BC    8A44
....................             { 
....................                //if (http_got_headers[hs]) 
....................                //{ 
....................                   debug_http("HTTP %U GET HEADER TIMEOUT\r\n", hs); 
....................                   http_page_req[hs]=0xFFFFFFFF; 
08A10:  MOVF   xE9,W
08A12:  MULLW  04
08A14:  MOVF   FF3,W
08A16:  CLRF   03
08A18:  ADDLW  91
08A1A:  MOVWF  FE9
08A1C:  MOVLW  02
08A1E:  ADDWFC 03,W
08A20:  MOVWF  FEA
08A22:  SETF   FEF
08A24:  SETF   FEC
08A26:  SETF   FEC
08A28:  SETF   FEC
....................                   http_state[hs]=HTTP_SEND_RESPONSE; 
08A2A:  BCF    FD8.0
08A2C:  RLCF   xE9,W
08A2E:  CLRF   03
08A30:  ADDLW  42
08A32:  MOVWF  FE9
08A34:  MOVLW  01
08A36:  ADDWFC 03,W
08A38:  MOVWF  FEA
08A3A:  MOVLW  01
08A3C:  MOVWF  FEC
08A3E:  MOVF   FED,F
08A40:  MOVLW  06
08A42:  MOVWF  FEF
....................                //} 
....................                //else 
....................                //{ 
....................                //   http_state[hs]=HTTP_CLOSE; 
....................                //} 
....................             } 
....................             if (!postContinue) 
08A44:  BTFSC  xE3.1
08A46:  BRA    8A4E
....................                break; 
08A48:  MOVLB  0
08A4A:  BRA    907C
08A4C:  MOVLB  2
08A4E:  MOVLB  0
....................  
....................          case HTTP_GET_POST: 
....................             debug_http("HTTP %U GET POST %LU\r\n", hs, http_post_len[hs]); 
....................             http_state[hs]=HTTP_GET_POST_CONTINUE; 
08A50:  BCF    FD8.0
08A52:  MOVLB  2
08A54:  RLCF   xE9,W
08A56:  CLRF   03
08A58:  ADDLW  42
08A5A:  MOVWF  FE9
08A5C:  MOVLW  01
08A5E:  ADDWFC 03,W
08A60:  MOVWF  FEA
08A62:  MOVLW  01
08A64:  MOVWF  FEC
08A66:  MOVF   FED,F
08A68:  MOVLW  05
08A6A:  MOVWF  FEF
....................             http_timer[hs]=TickGet(); 
08A6C:  MOVF   xE9,W
08A6E:  MULLW  04
08A70:  MOVF   FF3,W
08A72:  CLRF   03
08A74:  ADDLW  97
08A76:  MOVWF  01
08A78:  MOVLW  02
08A7A:  ADDWFC 03,F
08A7C:  MOVFF  01,2EB
08A80:  MOVFF  03,2EC
08A84:  MOVLB  0
08A86:  CALL   1630
08A8A:  MOVFF  2EC,FEA
08A8E:  MOVFF  2EB,FE9
08A92:  MOVFF  00,FEF
08A96:  MOVFF  01,FEC
08A9A:  MOVFF  02,FEC
08A9E:  MOVFF  03,FEC
....................             i[hs]=0; 
08AA2:  CLRF   03
08AA4:  MOVLB  2
08AA6:  MOVF   xE9,W
08AA8:  ADDLW  8F
08AAA:  MOVWF  FE9
08AAC:  MOVLW  02
08AAE:  ADDWFC 03,W
08AB0:  MOVWF  FEA
08AB2:  CLRF   FEF
08AB4:  MOVLB  0
....................  
....................          case HTTP_GET_POST_CONTINUE: 
....................             while ( 
....................                      TCPIsGetReady(currSocket) && 
....................                      TCPGet(currSocket, &c) && 
....................                      (http_post_len[hs] != 0) 
....................                   ) 
08AB6:  MOVFF  2EA,2F0
08ABA:  CALL   5DF6
08ABE:  MOVF   01,W
08AC0:  IORWF  02,W
08AC2:  BTFSC  FD8.2
08AC4:  BRA    8C84
08AC6:  MOVFF  2EA,2EB
08ACA:  MOVLW  02
08ACC:  MOVLB  2
08ACE:  MOVWF  xED
08AD0:  MOVLW  E4
08AD2:  MOVWF  xEC
08AD4:  MOVLB  0
08AD6:  CALL   5E76
08ADA:  MOVF   01,F
08ADC:  BTFSC  FD8.2
08ADE:  BRA    8C84
08AE0:  BCF    FD8.0
08AE2:  MOVLB  2
08AE4:  RLCF   xE9,W
08AE6:  CLRF   03
08AE8:  ADDLW  95
08AEA:  MOVWF  FE9
08AEC:  MOVLW  02
08AEE:  ADDWFC 03,W
08AF0:  MOVWF  FEA
08AF2:  MOVFF  FEC,2EC
08AF6:  MOVF   FED,F
08AF8:  MOVFF  FEF,2EB
08AFC:  MOVF   xEB,F
08AFE:  BNZ   8B0A
08B00:  MOVF   xEC,F
08B02:  BTFSS  FD8.2
08B04:  BRA    8B0A
08B06:  MOVLB  0
08B08:  BRA    8C84
....................             { 
....................                http_post_len[hs] -= 1; 
08B0A:  BCF    FD8.0
08B0C:  RLCF   xE9,W
08B0E:  CLRF   03
08B10:  ADDLW  95
08B12:  MOVWF  FE9
08B14:  MOVLW  02
08B16:  ADDWFC 03,W
08B18:  MOVWF  FEA
08B1A:  MOVLW  01
08B1C:  SUBWF  FEF,W
08B1E:  MOVWF  00
08B20:  MOVLW  00
08B22:  SUBWFB FEC,W
08B24:  MOVWF  03
08B26:  MOVF   00,W
08B28:  MOVF   FED,F
08B2A:  MOVWF  FEF
08B2C:  MOVFF  03,FEC
....................  
....................                if (c!='&') 
08B30:  MOVF   xE4,W
08B32:  SUBLW  26
08B34:  BZ    8B6C
....................                { 
....................                   buffer[hs][i[hs]++]=c; 
08B36:  MOVF   xE9,W
08B38:  MULLW  FE
08B3A:  MOVF   FF3,W
08B3C:  CLRF   xEC
08B3E:  MOVWF  xEB
08B40:  CLRF   03
08B42:  MOVF   xE9,W
08B44:  ADDLW  8F
08B46:  MOVWF  FE9
08B48:  MOVLW  02
08B4A:  ADDWFC 03,W
08B4C:  MOVWF  FEA
08B4E:  MOVF   FEF,W
08B50:  INCF   FEF,F
08B52:  CLRF   03
08B54:  ADDWF  xEB,W
08B56:  MOVWF  01
08B58:  MOVF   xEC,W
08B5A:  ADDWFC 03,F
08B5C:  MOVF   01,W
08B5E:  ADDLW  91
08B60:  MOVWF  FE9
08B62:  MOVLW  01
08B64:  ADDWFC 03,W
08B66:  MOVWF  FEA
08B68:  MOVFF  2E4,FEF
....................                } 
....................  
....................                if ( (c=='&') || (http_post_len[hs] == 0) ) 
08B6C:  MOVF   xE4,W
08B6E:  SUBLW  26
08B70:  BZ    8B96
08B72:  BCF    FD8.0
08B74:  RLCF   xE9,W
08B76:  CLRF   03
08B78:  ADDLW  95
08B7A:  MOVWF  FE9
08B7C:  MOVLW  02
08B7E:  ADDWFC 03,W
08B80:  MOVWF  FEA
08B82:  MOVFF  FEC,2EC
08B86:  MOVF   FED,F
08B88:  MOVFF  FEF,2EB
08B8C:  MOVF   xEB,F
08B8E:  BTFSS  FD8.2
08B90:  BRA    8C80
08B92:  MOVF   xEC,F
08B94:  BNZ   8C80
....................                { 
....................                   buffer[hs][i[hs]]=0; 
08B96:  MOVF   xE9,W
08B98:  MULLW  FE
08B9A:  MOVF   FF3,W
08B9C:  CLRF   xEC
08B9E:  MOVWF  xEB
08BA0:  CLRF   03
08BA2:  MOVF   xE9,W
08BA4:  ADDLW  8F
08BA6:  MOVWF  FE9
08BA8:  MOVLW  02
08BAA:  ADDWFC 03,W
08BAC:  MOVWF  FEA
08BAE:  CLRF   03
08BB0:  MOVF   FEF,W
08BB2:  ADDWF  xEB,W
08BB4:  MOVWF  01
08BB6:  MOVF   xEC,W
08BB8:  ADDWFC 03,F
08BBA:  MOVF   01,W
08BBC:  ADDLW  91
08BBE:  MOVWF  FE9
08BC0:  MOVLW  01
08BC2:  ADDWFC 03,W
08BC4:  MOVWF  FEA
08BC6:  CLRF   FEF
....................  
....................                   debug_http("%lu - %s\r\n", http_post_len[hs], &buffer[hs][0]); 
....................  
....................                   http_parse_cgi_string(http_page_req[hs], &buffer[hs][0]); 
08BC8:  MOVF   xE9,W
08BCA:  MULLW  04
08BCC:  MOVF   FF3,W
08BCE:  CLRF   03
08BD0:  ADDLW  91
08BD2:  MOVWF  FE9
08BD4:  MOVLW  02
08BD6:  ADDWFC 03,W
08BD8:  MOVWF  FEA
08BDA:  MOVFF  FEF,2EB
08BDE:  MOVFF  FEC,2EC
08BE2:  MOVFF  FEC,2ED
08BE6:  MOVFF  FEC,2EE
08BEA:  MOVF   xE9,W
08BEC:  MULLW  FE
08BEE:  MOVF   FF3,W
08BF0:  CLRF   xF0
08BF2:  MOVWF  xEF
08BF4:  MOVLW  91
08BF6:  ADDWF  xEF,W
08BF8:  MOVWF  01
08BFA:  MOVLW  01
08BFC:  ADDWFC xF0,W
08BFE:  MOVWF  03
08C00:  MOVFF  01,2F1
08C04:  MOVWF  xF2
08C06:  MOVFF  2EE,2F6
08C0A:  MOVFF  2ED,2F5
08C0E:  MOVFF  2EC,2F4
08C12:  MOVFF  2EB,2F3
08C16:  MOVWF  xF8
08C18:  MOVFF  01,2F7
08C1C:  MOVLB  0
08C1E:  CALL   7258
....................                   if (http_post_len[hs] == 0) 
08C22:  BCF    FD8.0
08C24:  MOVLB  2
08C26:  RLCF   xE9,W
08C28:  CLRF   03
08C2A:  ADDLW  95
08C2C:  MOVWF  FE9
08C2E:  MOVLW  02
08C30:  ADDWFC 03,W
08C32:  MOVWF  FEA
08C34:  MOVFF  FEC,2EC
08C38:  MOVF   FED,F
08C3A:  MOVFF  FEF,2EB
08C3E:  MOVF   xEB,F
08C40:  BNZ   8C70
08C42:  MOVF   xEC,F
08C44:  BNZ   8C70
....................                   { 
....................                      http_state[hs]=HTTP_SEND_RESPONSE; 
08C46:  BCF    FD8.0
08C48:  RLCF   xE9,W
08C4A:  CLRF   03
08C4C:  ADDLW  42
08C4E:  MOVWF  FE9
08C50:  MOVLW  01
08C52:  ADDWFC 03,W
08C54:  MOVWF  FEA
08C56:  MOVLW  01
08C58:  MOVWF  FEC
08C5A:  MOVF   FED,F
08C5C:  MOVLW  06
08C5E:  MOVWF  FEF
....................                      TCPDiscard(currSocket); 
08C60:  MOVFF  2EA,2EB
08C64:  MOVLB  0
08C66:  CALL   7650
....................                      break; 
08C6A:  BRA    8C84
....................                   } 
08C6C:  BRA    8C82
08C6E:  MOVLB  2
....................                   else 
....................                      i[hs]=0; 
08C70:  CLRF   03
08C72:  MOVF   xE9,W
08C74:  ADDLW  8F
08C76:  MOVWF  FE9
08C78:  MOVLW  02
08C7A:  ADDWFC 03,W
08C7C:  MOVWF  FEA
08C7E:  CLRF   FEF
08C80:  MOVLB  0
....................                } 
08C82:  BRA    8AB6
....................             } 
....................             if (TickGetDiff(TickGet(),http_timer[hs]) > TICKS_PER_SECOND*20) 
08C84:  CALL   1630
08C88:  MOVFF  03,2EE
08C8C:  MOVFF  02,2ED
08C90:  MOVFF  01,2EC
08C94:  MOVFF  00,2EB
08C98:  MOVLB  2
08C9A:  MOVF   xE9,W
08C9C:  MULLW  04
08C9E:  MOVF   FF3,W
08CA0:  CLRF   03
08CA2:  ADDLW  97
08CA4:  MOVWF  FE9
08CA6:  MOVLW  02
08CA8:  ADDWFC 03,W
08CAA:  MOVWF  FEA
08CAC:  MOVFF  FEF,00
08CB0:  MOVFF  FEC,01
08CB4:  MOVFF  FEC,02
08CB8:  MOVFF  FEC,03
08CBC:  MOVF   00,W
08CBE:  SUBWF  xEB,F
08CC0:  MOVF   01,W
08CC2:  SUBWFB xEC,F
08CC4:  MOVF   02,W
08CC6:  SUBWFB xED,F
08CC8:  MOVF   03,W
08CCA:  SUBWFB xEE,F
08CCC:  BNZ   8CE8
08CCE:  MOVF   xED,W
08CD0:  SUBLW  0A
08CD2:  BC    8D1C
08CD4:  XORLW  FF
08CD6:  BNZ   8CE8
08CD8:  MOVF   xEC,W
08CDA:  SUBLW  EA
08CDC:  BC    8D1C
08CDE:  XORLW  FF
08CE0:  BNZ   8CE8
08CE2:  MOVF   xEB,W
08CE4:  SUBLW  CC
08CE6:  BC    8D1C
....................             { 
....................                debug_http("HTTP %U GET POST TIMEOUT\r\n", hs); 
....................                http_page_req[hs]=0xFFFFFFFF; 
08CE8:  MOVF   xE9,W
08CEA:  MULLW  04
08CEC:  MOVF   FF3,W
08CEE:  CLRF   03
08CF0:  ADDLW  91
08CF2:  MOVWF  FE9
08CF4:  MOVLW  02
08CF6:  ADDWFC 03,W
08CF8:  MOVWF  FEA
08CFA:  SETF   FEF
08CFC:  SETF   FEC
08CFE:  SETF   FEC
08D00:  SETF   FEC
....................                http_state[hs]=HTTP_SEND_RESPONSE; 
08D02:  BCF    FD8.0
08D04:  RLCF   xE9,W
08D06:  CLRF   03
08D08:  ADDLW  42
08D0A:  MOVWF  FE9
08D0C:  MOVLW  01
08D0E:  ADDWFC 03,W
08D10:  MOVWF  FEA
08D12:  MOVLW  01
08D14:  MOVWF  FEC
08D16:  MOVF   FED,F
08D18:  MOVLW  06
08D1A:  MOVWF  FEF
....................             } 
....................             break; 
08D1C:  MOVLB  0
08D1E:  BRA    907C
....................  
....................          case HTTP_SEND_RESPONSE: 
....................             debug_http("HTTP %U SEND RESPONSE\r\n", hs); 
....................             lastHTTPPutConstPos[hs]=0; 
08D20:  MOVLB  2
08D22:  MOVF   xE9,W
08D24:  MULLW  04
08D26:  MOVF   FF3,W
08D28:  CLRF   03
08D2A:  ADDLW  45
08D2C:  MOVWF  FE9
08D2E:  MOVLW  01
08D30:  ADDWFC 03,W
08D32:  MOVWF  FEA
08D34:  MOVF   FEE,F
08D36:  MOVF   FEE,F
08D38:  CLRF   FEC
08D3A:  MOVF   FED,F
08D3C:  CLRF   FEF
08D3E:  MOVF   FED,F
08D40:  CLRF   FEF
08D42:  MOVF   FED,F
08D44:  CLRF   FEF
....................             http_state[hs]=HTTP_SEND_RESPONSE_CONTINUE; 
08D46:  BCF    FD8.0
08D48:  RLCF   xE9,W
08D4A:  CLRF   03
08D4C:  ADDLW  42
08D4E:  MOVWF  FE9
08D50:  MOVLW  01
08D52:  ADDWFC 03,W
08D54:  MOVWF  FEA
08D56:  MOVLW  01
08D58:  MOVWF  FEC
08D5A:  MOVF   FED,F
08D5C:  MOVLW  07
08D5E:  MOVWF  FEF
08D60:  MOVLB  0
....................  
....................          case HTTP_SEND_RESPONSE_CONTINUE: 
....................             TCPDiscard(currSocket); 
08D62:  MOVFF  2EA,2EB
08D66:  CALL   7650
....................             if (TCPIsPutReady(currSocket)) 
08D6A:  MOVFF  2EA,31F
08D6E:  CALL   7680
08D72:  MOVF   01,W
08D74:  IORWF  02,W
08D76:  BTFSC  FD8.2
08D78:  BRA    8ECA
....................             { 
....................                http_timer[hs]=TickGet(); 
08D7A:  MOVLB  2
08D7C:  MOVF   xE9,W
08D7E:  MULLW  04
08D80:  MOVF   FF3,W
08D82:  CLRF   03
08D84:  ADDLW  97
08D86:  MOVWF  01
08D88:  MOVLW  02
08D8A:  ADDWFC 03,F
08D8C:  MOVFF  01,2EB
08D90:  MOVFF  03,2EC
08D94:  MOVLB  0
08D96:  CALL   1630
08D9A:  MOVFF  2EC,FEA
08D9E:  MOVFF  2EB,FE9
08DA2:  MOVFF  00,FEF
08DA6:  MOVFF  01,FEC
08DAA:  MOVFF  02,FEC
08DAE:  MOVFF  03,FEC
....................                debug_http("\r\nPUTTING HTTP SEG\r\n"); 
....................                if (http_page_req[hs]==0xFFFFFFFF) 
08DB2:  MOVLB  2
08DB4:  MOVF   xE9,W
08DB6:  MULLW  04
08DB8:  MOVF   FF3,W
08DBA:  CLRF   03
08DBC:  ADDLW  91
08DBE:  MOVWF  FE9
08DC0:  MOVLW  02
08DC2:  ADDWFC 03,W
08DC4:  MOVWF  FEA
08DC6:  MOVFF  FEF,2EB
08DCA:  MOVFF  FEC,2EC
08DCE:  MOVFF  FEC,2ED
08DD2:  MOVFF  FEC,2EE
08DD6:  INCFSZ xEB,W
08DD8:  BRA    8E10
08DDA:  INCFSZ xEC,W
08DDC:  BRA    8E10
08DDE:  INCFSZ xED,W
08DE0:  BRA    8E10
08DE2:  INCFSZ xEE,W
08DE4:  BRA    8E10
....................                   doneSend=tcp_http_put_file(hs, 500, &http_500_error[0], 0); 
08DE6:  MOVFF  2E9,2EF
08DEA:  MOVLW  01
08DEC:  MOVWF  xF1
08DEE:  MOVLW  F4
08DF0:  MOVWF  xF0
08DF2:  CLRF   xF5
08DF4:  CLRF   xF4
08DF6:  SETF   xF3
08DF8:  MOVLW  72
08DFA:  MOVWF  xF2
08DFC:  CLRF   xF7
08DFE:  CLRF   xF6
08E00:  MOVLB  0
08E02:  CALL   8080
08E06:  MOVLB  2
08E08:  BCF    xE3.0
08E0A:  BTFSC  01.0
08E0C:  BSF    xE3.0
08E0E:  BRA    8EAA
....................                else if (http_page_req[hs]) 
....................                 #if HTTP_USE_CONTENT_TYPE 
08E10:  MOVF   xE9,W
08E12:  MULLW  04
08E14:  MOVF   FF3,W
08E16:  CLRF   03
08E18:  ADDLW  91
08E1A:  MOVWF  FE9
08E1C:  MOVLW  02
08E1E:  ADDWFC 03,W
08E20:  MOVWF  FEA
08E22:  MOVF   FEF,F
08E24:  BNZ   8E32
08E26:  MOVF   FEC,F
08E28:  BNZ   8E32
08E2A:  MOVF   FEC,F
08E2C:  BNZ   8E32
08E2E:  MOVF   FEC,F
08E30:  BZ    8E82
....................                   doneSend=tcp_http_put_file(hs, 200, http_page_req[hs], &contentType[hs][0]); 
....................                 #else 
....................                   doneSend=tcp_http_put_file(hs, 200, http_page_req[hs], 0); 
08E32:  MOVF   xE9,W
08E34:  MULLW  04
08E36:  MOVF   FF3,W
08E38:  CLRF   03
08E3A:  ADDLW  91
08E3C:  MOVWF  FE9
08E3E:  MOVLW  02
08E40:  ADDWFC 03,W
08E42:  MOVWF  FEA
08E44:  MOVFF  FEF,2EB
08E48:  MOVFF  FEC,2EC
08E4C:  MOVFF  FEC,2ED
08E50:  MOVFF  FEC,2EE
08E54:  MOVFF  2E9,2EF
08E58:  CLRF   xF1
08E5A:  MOVLW  C8
08E5C:  MOVWF  xF0
08E5E:  MOVFF  2EE,2F5
08E62:  MOVFF  2ED,2F4
08E66:  MOVFF  2EC,2F3
08E6A:  MOVFF  2EB,2F2
08E6E:  CLRF   xF7
08E70:  CLRF   xF6
08E72:  MOVLB  0
08E74:  CALL   8080
08E78:  MOVLB  2
08E7A:  BCF    xE3.0
08E7C:  BTFSC  01.0
08E7E:  BSF    xE3.0
....................                 #endif 
08E80:  BRA    8EAA
....................                else 
....................                   doneSend=tcp_http_put_file(hs, 404, &http_404_error[0], 0); 
08E82:  MOVFF  2E9,2EF
08E86:  MOVLW  01
08E88:  MOVWF  xF1
08E8A:  MOVLW  94
08E8C:  MOVWF  xF0
08E8E:  CLRF   xF5
08E90:  CLRF   xF4
08E92:  SETF   xF3
08E94:  MOVLW  BC
08E96:  MOVWF  xF2
08E98:  CLRF   xF7
08E9A:  CLRF   xF6
08E9C:  MOVLB  0
08E9E:  CALL   8080
08EA2:  MOVLB  2
08EA4:  BCF    xE3.0
08EA6:  BTFSC  01.0
08EA8:  BSF    xE3.0
....................  
....................                if (doneSend) 
08EAA:  BTFSS  xE3.0
08EAC:  BRA    8EC8
....................                { 
....................                   //if (http_isKeepAlive[hs]) 
....................                   //   http_state[hs]=HTTP_CONNECTED; 
....................                   //else 
....................                   //   http_state[hs]=HTTP_CLOSE; 
....................                   http_state[hs] = HTTP_CLOSE; 
08EAE:  BCF    FD8.0
08EB0:  RLCF   xE9,W
08EB2:  CLRF   03
08EB4:  ADDLW  42
08EB6:  MOVWF  FE9
08EB8:  MOVLW  01
08EBA:  ADDWFC 03,W
08EBC:  MOVWF  FEA
08EBE:  MOVLW  01
08EC0:  MOVWF  FEC
08EC2:  MOVF   FED,F
08EC4:  MOVLW  08
08EC6:  MOVWF  FEF
08EC8:  MOVLB  0
....................                   debug_http("HTTP %U RESPONSE SENT\r\n", hs); 
....................                } 
....................             } 
....................             if ((TickGet() - http_timer[hs]) >= (TICK)15*TICKS_PER_SECOND) 
08ECA:  CALL   1630
08ECE:  MOVFF  03,2EE
08ED2:  MOVFF  02,2ED
08ED6:  MOVFF  01,2EC
08EDA:  MOVFF  00,2EB
08EDE:  MOVLB  2
08EE0:  MOVF   xE9,W
08EE2:  MULLW  04
08EE4:  MOVF   FF3,W
08EE6:  CLRF   03
08EE8:  ADDLW  97
08EEA:  MOVWF  FE9
08EEC:  MOVLW  02
08EEE:  ADDWFC 03,W
08EF0:  MOVWF  FEA
08EF2:  MOVFF  FEF,00
08EF6:  MOVFF  FEC,01
08EFA:  MOVFF  FEC,02
08EFE:  MOVFF  FEC,03
08F02:  MOVF   00,W
08F04:  SUBWF  xEB,F
08F06:  MOVF   01,W
08F08:  SUBWFB xEC,F
08F0A:  MOVF   02,W
08F0C:  SUBWFB xED,F
08F0E:  MOVF   03,W
08F10:  SUBWFB xEE,F
08F12:  BNZ   8F2E
08F14:  MOVF   xED,W
08F16:  SUBLW  07
08F18:  BC    8F48
08F1A:  XORLW  FF
08F1C:  BNZ   8F2E
08F1E:  MOVF   xEC,W
08F20:  SUBLW  EF
08F22:  BC    8F48
08F24:  XORLW  FF
08F26:  BNZ   8F2E
08F28:  MOVF   xEB,W
08F2A:  SUBLW  D8
08F2C:  BC    8F48
....................             { 
....................                http_state[hs] = HTTP_CLOSE; 
08F2E:  BCF    FD8.0
08F30:  RLCF   xE9,W
08F32:  CLRF   03
08F34:  ADDLW  42
08F36:  MOVWF  FE9
08F38:  MOVLW  01
08F3A:  ADDWFC 03,W
08F3C:  MOVWF  FEA
08F3E:  MOVLW  01
08F40:  MOVWF  FEC
08F42:  MOVF   FED,F
08F44:  MOVLW  08
08F46:  MOVWF  FEF
....................             } 
....................             /*else 
....................             { 
....................                debug_http("\r\nNR => RW=%LX B=%X IS=%U\r\n", 
....................                      TCB[currSocket].RemoteWindow, 
....................                      TCB[currSocket].TxBuffer, 
....................                      TCB[currSocket].Flags.bIsPutReady 
....................                   ); 
....................                delay_ms(100); 
....................             }*/ 
....................             break; 
08F48:  MOVLB  0
08F4A:  BRA    907C
....................  
....................          case HTTP_CLOSE: 
....................             //since we set connection: close in the header, the client 
....................             //should automatically close.  but after so many seconds we 
....................             //shall kill the connection 
....................             http_state[hs]=HTTP_CLOSE_WAITING; 
08F4C:  BCF    FD8.0
08F4E:  MOVLB  2
08F50:  RLCF   xE9,W
08F52:  CLRF   03
08F54:  ADDLW  42
08F56:  MOVWF  FE9
08F58:  MOVLW  01
08F5A:  ADDWFC 03,W
08F5C:  MOVWF  FEA
08F5E:  MOVLW  01
08F60:  MOVWF  FEC
08F62:  MOVF   FED,F
08F64:  MOVLW  09
08F66:  MOVWF  FEF
....................             http_timer[hs]=TickGet(); 
08F68:  MOVF   xE9,W
08F6A:  MULLW  04
08F6C:  MOVF   FF3,W
08F6E:  CLRF   03
08F70:  ADDLW  97
08F72:  MOVWF  01
08F74:  MOVLW  02
08F76:  ADDWFC 03,F
08F78:  MOVFF  01,2EB
08F7C:  MOVFF  03,2EC
08F80:  MOVLB  0
08F82:  CALL   1630
08F86:  MOVFF  2EC,FEA
08F8A:  MOVFF  2EB,FE9
08F8E:  MOVFF  00,FEF
08F92:  MOVFF  01,FEC
08F96:  MOVFF  02,FEC
08F9A:  MOVFF  03,FEC
....................  
....................          case HTTP_CLOSE_WAITING: 
....................             TCPDiscard(currSocket); 
08F9E:  MOVFF  2EA,2EB
08FA2:  CALL   7650
....................             if ( 
....................                   (TCPGetTxFIFOFull(currSocket) == 0) || 
....................                   (TickGetDiff(TickGet(),http_timer[hs]) > (TICKS_PER_SECOND*8)) 
08FA6:  MOVFF  2EA,2EB
08FAA:  CALL   83CA
08FAE:  MOVFF  02,2EC
08FB2:  MOVFF  01,2EB
08FB6:  MOVLB  2
08FB8:  MOVF   xEB,F
08FBA:  BNZ   8FC0
08FBC:  MOVF   xEC,F
08FBE:  BZ    9026
08FC0:  MOVLB  0
08FC2:  CALL   1630
08FC6:  MOVFF  03,2EE
08FCA:  MOVFF  02,2ED
08FCE:  MOVFF  01,2EC
08FD2:  MOVFF  00,2EB
08FD6:  MOVLB  2
08FD8:  MOVF   xE9,W
08FDA:  MULLW  04
08FDC:  MOVF   FF3,W
08FDE:  CLRF   03
08FE0:  ADDLW  97
08FE2:  MOVWF  FE9
08FE4:  MOVLW  02
08FE6:  ADDWFC 03,W
08FE8:  MOVWF  FEA
08FEA:  MOVFF  FEF,00
08FEE:  MOVFF  FEC,01
08FF2:  MOVFF  FEC,02
08FF6:  MOVFF  FEC,03
08FFA:  MOVF   00,W
08FFC:  SUBWF  xEB,F
08FFE:  MOVF   01,W
09000:  SUBWFB xEC,F
09002:  MOVF   02,W
09004:  SUBWFB xED,F
09006:  MOVF   03,W
09008:  SUBWFB xEE,F
0900A:  BNZ   9026
0900C:  MOVF   xED,W
0900E:  SUBLW  03
09010:  BC    9074
09012:  XORLW  FF
09014:  BNZ   9026
09016:  MOVF   xEC,W
09018:  SUBLW  C3
0901A:  BC    9074
0901C:  XORLW  FF
0901E:  BNZ   9026
09020:  MOVF   xEB,W
09022:  SUBLW  B8
09024:  BC    9074
....................                ) 
....................             { 
....................                debug_http("HTTP %U FORCE CLOSED\r\n", hs); 
....................                if (TCPGetTxFIFOFull(currSocket) != 0) 
09026:  MOVFF  2EA,2EB
0902A:  MOVLB  0
0902C:  CALL   83CA
09030:  MOVFF  02,2EC
09034:  MOVFF  01,2EB
09038:  MOVLB  2
0903A:  MOVF   xEB,F
0903C:  BNZ   9042
0903E:  MOVF   xEC,F
09040:  BZ    904E
....................                { 
....................                   //socket is messed up.  just kill it by calling TCPDisconnect() twice. 
....................                   TCPDisconnect(currSocket); 
09042:  MOVFF  2EA,2F0
09046:  MOVLB  0
09048:  CALL   2B72
0904C:  MOVLB  2
....................                } 
....................                TCPDisconnect(currSocket); 
0904E:  MOVFF  2EA,2F0
09052:  MOVLB  0
09054:  CALL   2B72
....................                http_state[hs]=HTTP_CLOSED; 
09058:  BCF    FD8.0
0905A:  MOVLB  2
0905C:  RLCF   xE9,W
0905E:  CLRF   03
09060:  ADDLW  42
09062:  MOVWF  FE9
09064:  MOVLW  01
09066:  ADDWFC 03,W
09068:  MOVWF  FEA
0906A:  MOVLW  01
0906C:  MOVWF  FEC
0906E:  MOVF   FED,F
09070:  MOVLW  0A
09072:  MOVWF  FEF
....................             } 
....................             break; 
09074:  MOVLB  0
09076:  BRA    907C
09078:  MOVLB  2
....................  
....................          case HTTP_CLOSED: //do nothing until socket actually closes 
....................          default: 
....................             break; 
0907A:  MOVLB  0
....................       } 
0907C:  MOVLB  2
0907E:  INCF   xE9,F
09080:  GOTO   8432
....................    } 
09084:  MOVLB  0
09086:  GOTO   908E (RETURN)
.................... } 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    #include "ccs_HTTP2.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP) && !defined(__SMTP_C) 
....................    #include "smtp.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SMTP) 
....................    #include "ccs_SMTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
....................    #include "SNTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    #include "ccs_SNTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TWITTER) 
....................    #include "ccs_twitter.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
....................    #include "TFTPc.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_TFTP_SERVER) 
....................    #include "ccs_TFTPs.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) && !defined(__ANNOUNCE_C) 
....................    #include "Announce.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
....................    #include "MPFS2.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_GRATUITOUS_ARP) 
....................    #include "ccs_gratarp.c" 
.................... #endif 
....................  
.................... #if defined(__18CXX) 
....................    #include "p18cxxx.c" 
.................... // CCS PCH C Compiler to Microchip C18 Compiler compatability layer. 
....................  
.................... #ifndef __P18CXXXX_C__ 
.................... #define __P18CXXXX_C__ 
....................  
.................... #include "p18cxxx.h" 
.................... // CCS PCH C Compiler to Microchip C18 Compiler compatability layer. 
....................  
.................... #ifndef __P18CXXXX_H__ 
.................... #define __P18CXXXX_H__ 
....................  
.................... #ifndef __18CXX 
.................... #define __18CXX 
.................... #endif 
....................  
.................... //#zero_local_ram 
.................... #zero_ram 
....................  
....................  
.................... #device PASS_STRINGS=IN_RAM 
.................... #device CONST=READ_ONLY 
....................  
.................... #case 
.................... #type signed 
.................... #type short=16 int=16 long=32 
....................  
.................... #define _asm #asm 
.................... #define _endasm #endasm 
....................  
.................... /* usualy 
.................... #define GetSystemClock()      getenv("CLOCK") 
.................... #define GetInstructionClock()   (GetSystemClock()/4) 
.................... #define GetPeripheralClock()   (unsigned int32)GetInstructionClock() 
.................... */ 
....................  
.................... #if getenv("DEVICE") == "PIC18F97J60" 
....................  #define __18F97J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F96J65" 
....................  #define __18F96J65) 
.................... #elif getenv("DEVICE") == "PIC18F96J60" 
....................  #define __18F96J60 
.................... #elif getenv("DEVICE") == "PIC18F87J60" 
....................  #define __18F87J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J60" 
....................  #define __18F86J60 
.................... #elif getenv("DEVICE") == "PIC18F67J60" 
....................  #define __18F67J60 
....................  #include "PIC18F67J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F66J65" 
....................  #define __18F66J65 
.................... #elif getenv("DEVICE") == "PIC18F66J60" 
....................  #define __18F66J60 
.................... #elif getenv("DEVICE") == "PIC18F67K22" 
....................  #define __18F67K22 
....................  #include "PIC18F67K22_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F4620" 
....................  #define __18F4620 
....................  #include "PIC18F4620_registers.h" 
.................... #else 
....................    #error Do this for your chip 
.................... #endif 
....................  
.................... #if defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) 
....................    #reserve 0xE80:0xEFF 
....................    #reserve 0xF00:0xFFF 
.................... #endif 
....................  
.................... #if defined(TRUE) 
....................    #undef TRUE 
.................... #endif 
....................  
.................... #if defined(FALSE) 
....................    #undef FALSE 
.................... #endif 
....................  
.................... #if defined(BYTE) 
....................    #undef BYTE 
.................... #endif 
....................  
....................       #define Reset()            reset_cpu() 
....................         #define far 
....................         #define ClrWdt()         restart_wdt() 
....................       #define Nop()            delay_cycles(1)       
....................  
.................... #define __CCS__ 
....................  
.................... //signed int8 memcmppgm2ram(void * s1, rom char *s2, unsigned int8 n); 
.................... signed int8 strcmppgm2ram(char *s1, __ADDRESS__ s2); 
.................... char *strchrpgm(__ADDRESS__ s, unsigned int8 c); 
.................... char *strstrrampgm(char *s1, __ADDRESS__ s2); 
.................... unsigned int8 strlenpgm(__ADDRESS__ s); 
.................... void memcpypgm2ram(unsigned int8 *d, __ADDRESS__ s, unsigned int16 n); 
.................... //char* strupr(char *s);   now in string.h 
.................... void strcpypgm2ram(char *d, __ADDRESS__ s); 
.................... #endif 
....................  
.................... /* STRING.H already has this exact function 
.................... signed int8 memcmppgm2ram(void * s1, rom char *s2, unsigned int8 n) 
.................... { 
....................   #if 1 
....................    char *su1; 
....................    rom char *su2; 
....................     
....................    for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
....................    { 
....................       if(*su1!=*su2) 
....................          return ((*su1<*su2)?-1:+1); 
....................    } 
....................    return 0; 
....................   #else 
....................    #error///warning memcmppgm2ram disabled 
....................   #endif 
.................... }*/ 
....................  
.................... #if 0 //this is in string.h and helpers.c 
.................... char* strupr(char *s) 
.................... { 
....................    char *p; 
....................     
....................    p=s; 
....................     
....................    while(*p) 
....................    { 
....................       *p = toupper(*p++); 
....................    } 
....................    return(s); 
.................... } 
.................... #endif 
....................  
.................... void memcpypgm2ram(unsigned int8 *d, __ADDRESS__ s, unsigned int16 n) 
.................... { 
....................    //printf("ROM_0x%LX-to-0x%LX ", d, s); 
....................   #if (getenv("PROGRAM_MEMORY") > 0x10000) 
....................    #warning temporary ccs bug fix 
....................    s |= 0x10000; 
....................   #endif 
....................    read_program_memory(s, d, n); 
.................... } 
....................  
.................... void strcpypgm2ram(char *d, __ADDRESS__ s) 
.................... { 
....................    char c; 
....................    do 
....................    { 
....................       memcpypgm2ram(&c, s++, 1); 
....................       *d++ = c; 
....................    } while(c); 
.................... } 
....................  
.................... #if 0 
.................... signed int8 strcmppgm2ram(char *s1, rom char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... char *strchrpgm(rom char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
....................  
.................... char *strstrrampgm(char *s1, rom char *s2) 
.................... { 
....................    char *s; 
....................    rom char *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... unsigned int8 strlenpgm(rom char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
.................... #endif   //if 0 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... int1 DHCPBoundOrDisabled(void) 
.................... { 
....................   #if defined(STACK_USE_DHCP_CLIENT) 
....................    return(!DHCPIsEnabled(0) || DHCPIsBound(0)); 
....................   #else 
....................    return(TRUE); 
....................   #endif 
.................... } 
....................  
.................... int1 IsLinked(void) 
.................... { 
....................   #if STACK_USE_WIFI && defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    if (AppConfig.networkType == WF_ADHOC) 
....................    { 
....................       return(MACIsLinked() && g_WifiAdhocIsConn); 
....................    } 
....................   #endif 
....................     
....................    return(MACIsLinked() && DHCPBoundOrDisabled()); 
.................... } 
....................  
.................... #if defined(STACK_USE_MPFS) 
.................... MPFS _MpfsEofLoc; 
....................  
.................... unsigned int16 MPFSGetBytes(unsigned int8 *pDest, unsigned int16 n) 
.................... { 
....................    unsigned int16 ret = 0; 
....................    unsigned int16 i; 
....................    unsigned int8 *p; 
....................    int1 escaped = FALSE; 
....................     
....................    p = pDest; 
....................     
....................    debug_mpfs2(debug_putc, "\r\nMPFSGetBytes() START %LX ", _currentHandle); 
....................     
....................    while(n) 
....................    { 
....................       HTTP_INTERRUPT_TASKS(); 
....................        
....................       debug_mpfs2(debug_putc, "n=%LX ", n); 
....................        
....................       _MpfsEofLoc = _currentHandle; 
....................      #if defined(MPFS_USE_SPI_FLASH) 
....................       SPIFlashReadArray(_currentHandle, pDest, n); 
....................      #else 
....................       memcpypgm2ram(pDest, _currentHandle, n); //__ccs__ change because MPFS isn't rom pointer 
....................      #endif 
....................  
....................       _currentHandle += n; 
....................  
....................       //debug_array("START", pDest, n); 
....................  
....................       i = n; 
....................       n = 0; 
....................        
....................       while(i--) 
....................       { 
....................          _MpfsEofLoc++; 
....................          if (escaped || (*pDest == MPFS_DLE)) 
....................          { 
....................             if (!escaped) 
....................             { 
....................                n++; 
....................             } 
....................              
....................             if (escaped || i) 
....................             { 
....................                if (!escaped) 
....................                { 
....................                   debug_mpfs2(debug_putc, "! "); 
....................                   memmove(pDest, pDest+1, i); 
....................                   _MpfsEofLoc++; 
....................                   i--; 
....................                } 
....................                ret++; 
....................                escaped = FALSE; 
....................             } 
....................             else 
....................             { 
....................                escaped = TRUE; 
....................                pDest--; //counter pDest++ below, since we need to start saving new bytes here 
....................             } 
....................          } 
....................          else if(*pDest == MPFS_ETX) 
....................          { 
....................             _MpfsEofLoc--; 
....................             debug_mpfs2(debug_putc, "EOF %LX ", _MpfsEofLoc); 
....................             _currentHandle = MPFS_INVALID; 
....................             n = 0; 
....................             break; 
....................          } 
....................          else 
....................          { 
....................             ret++; 
....................          } 
....................          pDest++; 
....................       } 
....................    } 
....................    //debug_array("STOP", p, ret);    
....................  
....................    return(ret); 
.................... } 
.................... #ENDIF 
....................  
.................... #if STACK_USE_WIFI 
....................  
.................... //extern int1 g_WifiTempDisFlag; 
.................... //extern TICK g_WifiTempDisTick; 
.................... //extern int1 g_wifiConnected; 
.................... extern int1 g_WifiConnectFail; 
....................  
.................... // see StackTsk2.h for documentation 
.................... #if 0 
.................... int1 MyWFisConnected(void) 
.................... { 
....................    int1 ret = FALSE; 
....................  
....................   #if defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    if (AppConfig.networkType == WF_ADHOC) 
....................    { 
....................       if ( 
....................             g_WifiAdhocIsConn && 
....................             ((TickGet() - g_WifiAdhocTickConn) > WIFI_ADHOC_CONNECTION_TIMER) 
....................          ) 
....................       { 
....................          g_WifiAdhocIsConn = FALSE; 
....................       } 
....................       return(g_WifiAdhocIsConn); 
....................    } 
....................   #endif 
....................  
....................    if (g_wifiConnected) 
....................    { 
....................       ret = TRUE; 
....................    } 
....................    else if (!g_WifiConnectFail) 
....................    { 
....................       if (g_WifiTempDisFlag) 
....................       { 
....................          if ((TickGet() - g_WifiTempDisTick) < ((TICK)5*TICKS_PER_SECOND)) 
....................          { 
....................             ret = TRUE; 
....................          } 
....................          else 
....................          { 
....................             g_WifiTempDisFlag = FALSE; 
....................          } 
....................       } 
....................    } 
....................  
....................    return(ret); 
.................... } 
.................... #endif 
....................  
.................... unsigned int8 g_connectionProfileID = 0xFF;  //used to communicate with the connection profile on the WiFi module 
....................  
.................... unsigned int8 WIFI_channelList[16]; 
.................... unsigned int8 WIFI_numChannelsInList; 
.................... unsigned int8 WIFI_region; 
....................  
.................... // this option will force the connection profile to be closed and reopened 
.................... // if we do not get a connection within this time.  might fix an errata that 
.................... // says WPA/WPA2 will lockup instead of sending an event. 
.................... #define WIFI_FORCE_RECONNECT_TICK   (TICK)(TICKS_PER_SECOND * 120)  //might be too short for WPA/WPA2 phrase 
....................  
.................... #ifndef wifi_debug 
.................... #define wifi_debug(a,b,c,d,e,f,g,h,i) 
.................... #endif 
....................  
.................... // this was based off of WF_Connect() in Microchip's demo application. 
.................... void WIFIConnectTask(void) 
.................... { 
....................    #if !defined(APP_GENERIC_SCRATCH) 
....................       char WIFIConnectTask_Scratch[6]; 
....................    #else 
....................       #define WIFIConnectTask_Scratch  APP_GENERIC_SCRATCH 
....................    #endif 
....................     
....................   #if defined(WIFI_FORCE_RECONNECT_TICK) 
....................    static TICK fTick; 
....................   #endif 
....................  
....................   #if defined(LED_CONNECTION_ON) || defined(LED_ACTIVITY_ON) 
....................    static TICK l; 
....................    // if you have both LED_CONNECTION_ON and LED_ACTIVITY_ON (2 WIFI LEDs),  
....................    //    then one LED is used for flickering on traffic and another is used to  
....................    //    show connection state. 
....................    // if you only have LED_CONNECTION_ON (only 1 WIFI LED), then WIFI  
....................    //    connection status and wifi traffic flickering is shared on the same 
....................    //    LED. 
....................    // this routine below handles the traffic led flickering.  the LED was 
....................    //    turned off in the TCP/IP stack, this routine turns it back on every 
....................    //    200ms. 
....................    if ((TickGet() - l) >= TICKS_PER_SECOND/5) 
....................    { 
....................       l = TickGet(); 
....................        
....................      #if defined(LED_ACTIVITY_ON) 
....................       LED_ACTIVITY_OFF(); 
....................      #else 
....................       if (IsLinked()) 
....................       { 
....................          LED_CONNECTION_ON(); 
....................       } 
....................       else 
....................       { 
....................          LED_CONNECTION_OFF(); 
....................       } 
....................      #endif 
....................    } 
....................   #endif 
....................  
....................   #if defined(LED_CONNECTION_ON) && defined(LED_ACTIVITY_ON) 
....................    // handle the connection status LED if you have 2 WIFI LEDs. 
....................    if (IsLinked()) 
....................    { 
....................       LED_CONNECTION_ON(); 
....................    } 
....................    else 
....................    { 
....................       LED_CONNECTION_OFF(); 
....................    } 
....................   #endif 
....................  
....................   #if STACK_USE_WIFI && defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    if (AppConfig.networkType == WF_ADHOC) 
....................    { 
....................       if ( 
....................             g_WifiAdhocIsConn && 
....................             ((TickGet() - g_WifiAdhocTickConn) > WIFI_ADHOC_CONNECTION_TIMER) 
....................          ) 
....................       { 
....................          g_WifiAdhocIsConn = FALSE; 
....................       } 
....................    } 
....................   #endif 
....................  
....................   #if defined(WIFI_FORCE_RECONNECT_TICK) 
....................    if ( 
....................          (AppConfig.networkType != WF_ADHOC) && 
....................          (g_connectionProfileID != 0xFF) 
....................       ) 
....................    { 
....................       if (IsLinked()) 
....................       { 
....................          fTick = TickGet(); 
....................       } 
....................       else if ((TickGet() - fTick) > WIFI_FORCE_RECONNECT_TICK) 
....................       { 
....................         #if defined(STACK_IS_CCS_EXAMPLE) 
....................          fprintf(STREAM_UI, "\r\nLong WIFI connection timeout, reseting module"); 
....................         #endif 
....................          delay_ms(200); 
....................          MACInit(); 
....................          delay_ms(200); 
....................          g_connectionProfileID = 0xFF; 
....................         #if defined(WIFI_EXTRA_LINK_STATUS) 
....................          g_LastWifiEvent = 20; 
....................         #endif 
....................       } 
....................    } 
....................   #endif 
....................  
....................    if (g_connectionProfileID == 0xFF) 
....................    { 
....................       g_WifiConnectFail = FALSE; 
....................        
....................       WF_CPCreate(&g_connectionProfileID); 
....................        
....................       if (g_connectionProfileID != 0xFF) 
....................       { 
....................         #if defined(WIFI_GET_VERSION_INFO) 
....................          WF_GetDeviceInfo(&WIFI_GET_VERSION_INFO); 
....................         #endif 
....................  
....................          g_WifiConnectFail = TRUE; 
....................  
....................          WF_CPSetSsid(g_connectionProfileID,  
....................                     AppConfig.MySSID,  
....................                     AppConfig.SsidLength); 
....................           
....................          memset(WIFIConnectTask_Scratch, 0xFF, 6); 
....................          WF_CPSetBssid(g_connectionProfileID, WIFIConnectTask_Scratch); 
....................  
....................          WF_CPSetNetworkType(g_connectionProfileID, AppConfig.networkType); 
....................           
....................          if(AppConfig.networkType == WF_ADHOC) 
....................          { 
....................             WF_CPSetAdHocBehavior(g_connectionProfileID, AppConfig.adhocBehavior); 
....................          } 
....................  
....................          WF_CASetScanType(MY_DEFAULT_SCAN_TYPE);   // was WF_ACTIVE_SCAN 
....................  
....................          WF_CASetChannelList(WIFI_channelList, WIFI_numChannelsInList); //was AppConfig.channelList, AppConfig.numChannelsInList 
....................  
....................          WF_SetRegionalDomain(WIFI_region);  //was AppConfig.region 
....................           
....................          WF_CASetListRetryCount(MY_DEFAULT_LIST_RETRY_COUNT);  // was WF_RETRY_FOREVER 
....................           
....................          WF_CASetEventNotificationAction(MY_DEFAULT_EVENT_NOTIFICATION_LIST); // was WF_NOTIFY_ALL_EVENTS 
....................           
....................          WF_CASetBeaconTimeout(MY_DEFAULT_BEACON_TIMEOUT); 
....................  
....................          WF_CASetBeaconTimeoutAction(WF_ATTEMPT_TO_RECONNECT); 
....................           
....................          WF_CASetDeauthAction(WF_ATTEMPT_TO_RECONNECT); 
....................  
....................        #if defined(DERIVE_KEY_FROM_PASSPHRASE_IN_HOST) 
....................            if (AppConfig.SecurityMode == WF_SECURITY_WPA_WITH_PASS_PHRASE 
....................                || AppConfig.SecurityMode == WF_SECURITY_WPA2_WITH_PASS_PHRASE 
....................                || AppConfig.SecurityMode == WF_SECURITY_WPA_AUTO_WITH_PASS_PHRASE) { 
....................                WF_ConvPassphrase2Key(AppConfig.SecurityKeyLength, AppConfig.SecurityKey, 
....................                    AppConfig.SsidLength, AppConfig.MySSID); 
....................                AppConfig.SecurityMode--; 
....................                AppConfig.SecurityKeyLength = 32; 
....................            } 
....................        #if defined (MRF24WG) 
....................            else if (AppConfig.SecurityMode == WF_SECURITY_WPS_PUSH_BUTTON 
....................                        || AppConfig.SecurityMode == WF_SECURITY_WPS_PIN) { 
....................                WF_YieldPassphrase2Host();     
....................            } 
....................        #endif    /* defined (MRF24WG) */ 
....................        #endif    /* defined(DERIVE_KEY_FROM_PASSPHRASE_IN_HOST) */ 
....................  
....................          WF_CPSetSecurity(g_connectionProfileID, 
....................                         AppConfig.SecurityMode, 
....................                         0, //AppConfig.WepKeyIndex, //AppConfig.WepKeyIndex,   /* only used if WEP enabled */ 
....................                         AppConfig.SecurityKey, 
....................                         AppConfig.SecurityKeyLength);       
....................   
....................       #if (MY_DEFAULT_WIFI_SECURITY_WEP_KEYTYPE!=WF_SECURITY_WEP_SHAREDKEY) 
....................         #if !defined(MRF24WG) 
....................          if (gRFModuleVer1209orLater) 
....................         #endif 
....................          { 
....................             // If WEP security is used, set WEP Key Type.  The default WEP Key Type is Shared Key. 
....................             if ((AppConfig.SecurityMode == WF_SECURITY_WEP_40) || (AppConfig.SecurityMode == WF_SECURITY_WEP_104)) 
....................             { 
....................                 WF_CPSetWepKeyType(g_connectionProfileID, MY_DEFAULT_WIFI_SECURITY_WEP_KEYTYPE); 
....................             } 
....................          } 
....................         #endif 
....................  
....................        #ifndef WF_FORCE_NO_PS_POLL 
....................        #if MY_DEFAULT_PS_POLL == WF_ENABLED 
....................            WF_PsPollEnable(TRUE); 
....................        #if !defined(MRF24WG)  
....................            if (gRFModuleVer1209orLater) 
....................                WFEnableDeferredPowerSave(); 
....................        #endif    // !defined(MRF24WG) 
....................        #else     // MY_DEFAULT_PS_POLL != WF_ENABLED 
....................            WF_PsPollDisable(); 
....................        #endif    // MY_DEFAULT_PS_POLL == WF_ENABLED 
....................     
....................        #ifdef WF_AGGRESSIVE_PS 
....................        #if !defined(MRF24WG) 
....................            if (gRFModuleVer1209orLater) 
....................                WFEnableAggressivePowerSave(); 
....................        #endif 
....................        #endif 
....................        #endif 
....................       } 
....................    } 
....................  
....................    if(g_WifiConnectFail) 
....................    { 
....................       wifi_debug(debug_putc, "Start WiFi Connect PROF=%u\r\n", g_connectionProfileID); 
....................       
....................      #if defined(STACK_IS_CCS_EXAMPLE) 
....................       fprintf(STREAM_UI, "\r\nStart WiFi Connect"); 
....................      #endif 
....................       
....................      #if defined(WIFI_FORCE_RECONNECT_TICK) 
....................       fTick = TickGet(); 
....................      #endif 
....................  
....................      #if defined(WF_FORCE_NO_PS_POLL) 
....................       WF_CCS_PsPollDisable(); 
....................      #endif 
....................     
....................       WF_CMConnect(g_connectionProfileID); 
....................    } 
....................     
....................    g_WifiConnectFail = 0; 
.................... } 
....................  
.................... void LinkTraffic(int1 isTx) 
.................... { 
....................   #if defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    if (!isTx && (AppConfig.networkType == WF_ADHOC)) 
....................    { 
....................       g_WifiAdhocIsConn = TRUE; 
....................       g_WifiAdhocTickConn = TickGet(); 
....................    } 
....................   #endif 
....................  
....................    // these LEDs are desribed in WIFIConnectTask() 
....................   #if defined(LED_ACTIVITY_ON) 
....................    LED_ACTIVITY_ON(); 
....................   #elif defined(LED_CONNECTION_ON) 
....................    LED_CONNECTION_OFF(); 
....................   #endif 
.................... } 
....................  
....................  
.................... #if defined(WF_FORCE_NO_PS_POLL) 
.................... #if defined(WF_USE_POWER_SAVE_FUNCTIONS) 
....................    #error dont use both at the same time 
.................... #endif 
.................... typedef struct pwrModeRequestStruct 
.................... { 
....................     UINT8 mode; 
....................     UINT8 wake; 
....................     UINT8 rcvDtims; 
....................     UINT8 reserved;            /* pad byte */ 
.................... } tWFPwrModeReq; 
....................  
.................... static void SendPowerModeMsg(tWFPwrModeReq *p_powerMode) 
.................... { 
....................     UINT8 hdr[2]; 
....................      
....................     hdr[0] = WF_MGMT_REQUEST_TYPE; 
....................     hdr[1] = WF_SET_POWER_MODE_SUBTYPE; 
....................  
....................     SendMgmtMsg(hdr, 
....................                 sizeof(hdr), 
....................                (UINT8 *)p_powerMode, 
....................                sizeof(tWFPwrModeReq)); 
....................  
....................     /* wait for mgmt response, free buffer after it comes in (no data to read) */ 
....................    WaitForMgmtResponse(WF_SET_POWER_MODE_SUBTYPE, FREE_MGMT_BUFFER); 
....................      
.................... }  
....................  
.................... void WF_CCS_PsPollDisable(void) 
.................... { 
....................    tWFPwrModeReq   pwrModeReq; 
....................      
....................     pwrModeReq.mode     = 1;  //PS_POLL_DISABLED; 
....................     pwrModeReq.wake     = 1; 
....................     pwrModeReq.rcvDtims = 1; 
....................     SendPowerModeMsg(&pwrModeReq); 
....................  
....................     //SetPowerSaveState(WF_PS_OFF); //not really needed, sets a global for their statemachine 
....................  
....................     WFConfigureLowPowerMode(WF_LOW_POWER_MODE_OFF);  
.................... } 
.................... #endif   //WF_FORCE_NO_PS_POLL 
....................  
.................... #endif //STACK_USE_WIFI 
....................  
.................... #if defined(__DO_DEBUG_MPFS2) 
.................... void debug_array(char *str, char *p, unsigned int16 n) 
.................... { 
....................    char c; 
....................    debug_mpfs2(debug_putc, "\r\n%s %LX ", str, n); 
....................    while(n--) 
....................    { 
....................       c = *p++; 
....................       if ((c >= ' ') && (c <= '}')) 
....................       { 
....................          debug_mpfs2(debug_putc, "%c", c); 
....................       } 
....................       else 
....................       { 
....................          debug_mpfs2(debug_putc, "+%X", c); 
....................       } 
....................    } 
....................    debug_mpfs2(debug_putc, " "); 
.................... } 
.................... #else 
.................... #define debug_array(str, p, n) 
.................... #endif 
....................  
.................... // if you call TickGet() from an ISR, this may be a lock-up condition. 
.................... // this is a morph of GetTickCopy() and TickUpdate() that works from an ISR. 
.................... // only works on PIC18. 
.................... #if defined(__PCH__) 
.................... TICK TickGetSafe(void) 
.................... { 
....................    BYTE myTickReading[6]; 
....................    do 
....................    { 
....................       if(INTCONbits.TMR0IF) 
....................       { 
....................          dwInternalTicks++; 
....................          INTCONbits.TMR0IF = 0; 
....................       } 
....................       myTickReading[0] = TMR0L; 
....................       myTickReading[1] = TMR0H; 
....................       *((DWORD*)&myTickReading[2]) = dwInternalTicks; 
....................    } while(INTCONbits.TMR0IF); 
....................     
....................    return *((DWORD*)&myTickReading[0]); 
.................... } 
.................... #endif 
....................  
.................... // this used to be called GenerateRandomBYTE() in an older CCS port of Helpers.c 
.................... BYTE GenerateRandomByteFromTimers(void) 
.................... { 
....................    BYTE rand; 
....................     
....................   #if getenv("TIMER0") && !defined(__PCD__) 
....................    rand+=get_timer0(); 
....................   #endif 
....................    
....................   #if getenv("TIMER1") 
....................    rand+=get_timer1(); 
....................   #endif 
....................    
....................   #if getenv("TIMER2") 
....................    rand+=get_timer2(); 
....................   #endif 
....................    
....................   #if getenv("TIMER3") 
....................    rand+=get_timer3(); 
....................   #endif 
....................    
....................   #if getenv("TIMER4") 
....................    rand+=get_timer4(); 
....................   #endif 
....................    
....................   #if getenv("TIMER5") 
....................    rand+=get_timer5(); 
....................   #endif 
....................    
....................    return(rand); 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................    Assigns the MAC address of the unit. 
....................    This is removed when using WIFI, so it will use the MAC address of the 
....................    WIFI module.  You can still override the MAC address of the WIFI module 
....................    if you remove the conditional compilation option. 
.................... */ 
.................... void MACAddrInit(void) 
.................... { 
....................   #if !STACK_USE_WIFI 
....................    MY_MAC_BYTE1=0; 
*
0026C:  CLRF   56
....................    MY_MAC_BYTE2=2; 
0026E:  MOVLW  02
00270:  MOVWF  57
....................    MY_MAC_BYTE3=3; 
00272:  MOVLW  03
00274:  MOVWF  58
....................    MY_MAC_BYTE4=4; 
00276:  MOVLW  04
00278:  MOVWF  59
....................    MY_MAC_BYTE5=5; 
0027A:  MOVLW  05
0027C:  MOVWF  5A
....................    MY_MAC_BYTE6=7; 
0027E:  MOVLW  07
00280:  MOVWF  5B
....................   #endif 
00282:  GOTO   02C8 (RETURN)
.................... } 
....................  
.................... void IPAddrInit(void)  
.................... { 
....................    //IP address of this unit 
....................    MY_IP_BYTE1=192; 
00286:  MOVLW  C0
00288:  MOVWF  29
....................    MY_IP_BYTE2=168; 
0028A:  MOVLW  A8
0028C:  MOVWF  2A
....................    MY_IP_BYTE3=100; 
0028E:  MOVLW  64
00290:  MOVWF  2B
....................    MY_IP_BYTE4=7; 
00292:  MOVLW  07
00294:  MOVWF  2C
....................  
....................    //network gateway 
....................    MY_GATE_BYTE1=192; 
00296:  MOVLW  C0
00298:  MOVWF  31
....................    MY_GATE_BYTE2=168; 
0029A:  MOVLW  A8
0029C:  MOVWF  32
....................    MY_GATE_BYTE3=100; 
0029E:  MOVLW  64
002A0:  MOVWF  33
....................    MY_GATE_BYTE4=1; 
002A2:  MOVLW  01
002A4:  MOVWF  34
....................  
....................    //subnet mask 
....................    MY_MASK_BYTE1=255; 
002A6:  SETF   2D
....................    MY_MASK_BYTE2=255; 
002A8:  SETF   2E
....................    MY_MASK_BYTE3=255; 
002AA:  SETF   2F
....................    MY_MASK_BYTE4=0; 
002AC:  CLRF   30
....................    
....................   #if defined(STACK_USE_DNS) 
002AE:  GOTO   02CA (RETURN)
....................    AppConfig.PrimaryDNSServer.v[0] = 192; 
....................    AppConfig.PrimaryDNSServer.v[1] = 168; 
....................    AppConfig.PrimaryDNSServer.v[2] = 100; 
....................    AppConfig.PrimaryDNSServer.v[3] = 1; 
....................   #endif 
.................... } 
....................  
.................... char ExampleIPDatagram[] = { 
....................    0x45, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
....................    0x64, 0x11, 0x2A, 0x9D, 0x0A, 0x0B, 0x0C, 0x0D, 
....................    0x0A, 0x0B, 0x0C, 0x0E 
.................... }; 
....................  
.................... char ExampleUDPPacket[] = { 
....................    0x04, 0x00, 0x04, 0x01, 0x00, 0x0C, 0x00, 0x00, 
....................    0x01, 0x02, 0x03, 0x04 
.................... }; 
....................  
.................... void MACToString(char *str, MAC_ADDR *mac) 
.................... { 
....................    sprintf(str, "%X:%X:%X:%X:%X:%X", mac->v[0], mac->v[1], mac->v[2], mac->v[3], mac->v[4], mac->v[5]); 
.................... } 
....................  
.................... void IPToString(char *str, IP_ADDR *ip) 
.................... { 
....................    sprintf(str, "%u.%u.%u.%u", ip->v[0], ip->v[1], ip->v[2], ip->v[3]); 
*
07046:  MOVLB  3
07048:  MOVFF  31A,FE9
0704C:  MOVFF  31B,FEA
07050:  MOVFF  FEF,31C
07054:  MOVLW  01
07056:  ADDWF  x1A,W
07058:  MOVWF  FE9
0705A:  MOVLW  00
0705C:  ADDWFC x1B,W
0705E:  MOVWF  FEA
07060:  MOVFF  FEF,31D
07064:  MOVLW  02
07066:  ADDWF  x1A,W
07068:  MOVWF  FE9
0706A:  MOVLW  00
0706C:  ADDWFC x1B,W
0706E:  MOVWF  FEA
07070:  MOVFF  FEF,31E
07074:  MOVLW  03
07076:  ADDWF  x1A,W
07078:  MOVWF  FE9
0707A:  MOVLW  00
0707C:  ADDWFC x1B,W
0707E:  MOVWF  FEA
07080:  MOVFF  FEF,31F
07084:  MOVFF  319,2BC
07088:  MOVFF  318,2BB
0708C:  MOVFF  31C,320
07090:  MOVLW  1B
07092:  MOVWF  x21
07094:  MOVLB  0
07096:  RCALL  6FC6
07098:  MOVLW  2E
0709A:  MOVLB  3
0709C:  MOVWF  x24
0709E:  MOVLB  0
070A0:  RCALL  6FA4
070A2:  MOVFF  31D,320
070A6:  MOVLW  1B
070A8:  MOVLB  3
070AA:  MOVWF  x21
070AC:  MOVLB  0
070AE:  RCALL  6FC6
070B0:  MOVLW  2E
070B2:  MOVLB  3
070B4:  MOVWF  x24
070B6:  MOVLB  0
070B8:  RCALL  6FA4
070BA:  MOVFF  31E,320
070BE:  MOVLW  1B
070C0:  MOVLB  3
070C2:  MOVWF  x21
070C4:  MOVLB  0
070C6:  RCALL  6FC6
070C8:  MOVLW  2E
070CA:  MOVLB  3
070CC:  MOVWF  x24
070CE:  MOVLB  0
070D0:  RCALL  6FA4
070D2:  MOVFF  31F,320
070D6:  MOVLW  1B
070D8:  MOVLB  3
070DA:  MOVWF  x21
070DC:  MOVLB  0
070DE:  RCALL  6FC6
070E0:  GOTO   721C (RETURN)
.................... } 
....................  
.................... /****************************************************************************** 
....................  * If using the newest stack, options for WiFi should be set in WF_Config.h 
....................  *****************************************************************************/ 
.................... #if STACK_USE_WIFI 
....................  
.................... #include "tcpip/StackTsk2.c" 
....................  
.................... #if !STACK_USE_CCS_INI 
.................... // initialize WIFI settings using harcoded values 
.................... void WIFI_Init(void) 
.................... { 
....................    unsigned int8 chans[] = MY_DEFAULT_CHANNEL_LIST; 
....................     
....................    g_connectionProfileID = 0xFF; 
....................     
....................    WIFI_numChannelsInList = sizeof(chans); 
....................    memcpy(WIFI_channelList, chans, WIFI_numChannelsInList); 
....................    WIFI_region = MY_DEFAULT_REGION; 
....................  
....................    // If MAC address is all zero's, then set it to the default MAC address. 
....................    // If the MAC address is the default MAC address, the stack will then use 
....................    // MAC internal to the WIFI module. 
....................    MAC_ADDR blankMac; 
....................    memset(&blankMac, 0x00, sizeof(MAC_ADDR)); 
....................    if (memcmp(&AppConfig.MyMACAddr, &blankMac, sizeof(MAC_ADDR)) == 0) 
....................    { 
....................       memcpy(&AppConfig.MyMACAddr, &MchpDefaultMacAddress, sizeof(MAC_ADDR)); 
....................    } 
....................     
....................    // Load the default SSID Name 
....................    strcpy(AppConfig.MySSID, MY_DEFAULT_SSID_NAME); 
....................    AppConfig.SsidLength = strlen(AppConfig.MySSID); 
....................  
....................    AppConfig.SecurityMode = MY_DEFAULT_WIFI_SECURITY_MODE; 
....................    AppConfig.WepKeyIndex  = MY_DEFAULT_WEP_KEY_INDEX; 
....................    
....................   #if (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_OPEN) 
....................       memset(AppConfig.SecurityKey, 0x00, sizeof(AppConfig.SecurityKey)); 
....................  
....................   #elif MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WEP_40 
....................       strcpy(AppConfig.SecurityKey, MY_DEFAULT_WEP_KEYS_40); 
....................  
....................   #elif MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WEP_104 
....................     strcpy(AppConfig.SecurityKey, MY_DEFAULT_WEP_KEYS_104); 
....................      
....................   #elif (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA_WITH_KEY)       || \ 
....................         (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA2_WITH_KEY)      || \ 
....................         (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA_AUTO_WITH_KEY) 
....................     strcpy(AppConfig.SecurityKey, MY_DEFAULT_PSK); 
....................  
....................   #elif (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA_WITH_PASS_PHRASE)     || \ 
....................         (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA2_WITH_PASS_PHRASE)    || \ 
....................         (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA_AUTO_WITH_PASS_PHRASE) 
....................       strcpy(AppConfig.SecurityKey, MY_DEFAULT_PSK_PHRASE); 
....................  
....................   #else  
....................       #error No security defined 
....................   #endif 
....................      
....................     AppConfig.networkType = MY_DEFAULT_NETWORK_TYPE; 
....................     AppConfig.adhocBehavior = MY_DEFAULT_ADHOC_BEHAVIOR; 
....................      
....................     AppConfig.SecurityKeyLength = strlen(AppConfig.SecurityKey); 
.................... } 
.................... #else  
.................... #define WIFI_Init()  g_connectionProfileID = 0xFF  //taken care of by CCS_INI 
.................... #endif   //!STACK_USE_CCS_INI 
.................... #endif   //!WIFI 
....................  
.................... void Init(void) 
.................... { 
....................    init_user_io(); 
*
002C4:  BRA    021E
....................   
....................    MACAddrInit(); //used by CCS TCP/IP examples 
002C6:  BRA    026C
....................     
....................    IPAddrInit();  //used by CCS TCP/IP examples 
002C8:  BRA    0286
....................     
....................    TickInit(); 
002CA:  BRA    02B2
....................     
....................     
....................   #if STACK_USE_WIFI 
....................    delay_ms(50); //let the tick get a value for seeding rand 
....................    srand(TickGet() * get_timer0()); //seed random value for channel 
....................    WIFI_Init(); 
....................   #endif 
....................     
....................   #if defined(__PCH__) 
....................    enable_interrupts(GLOBAL); //used by TICK and WIFI 
002CC:  MOVLW  C0
002CE:  IORWF  FF2,F
....................   #else 
....................    enable_interrupts(INTR_GLOBAL); 
....................   #endif 
....................  
....................   #if STACK_USE_CCS_INI 
002D0:  GOTO   91CE (RETURN)
....................    EEInit(); 
....................  
....................    //printf("\r\n\nMAGIC RD = %X\r\n\n", EERead8(EE_MAGIC)); 
....................  
....................    if (EERead8(EE_MAGIC) != DEF_MAGIC) 
....................    { 
....................       printf(UserPutc, "\r\n\nResetting EEPROM...\r\n\n"); 
....................       EEPROMToDefaults(); 
....................    } 
....................  
....................    EELoadSettings();    
....................    
....................    UIInit(); 
....................   #endif 
.................... } 
....................  
.................... #if STACK_USE_CCS_INI 
....................    #include "ee.c" 
....................    #include "ccsui.c" 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... #int_addrerr FAST 
.................... void IsrAdrerr(void) 
.................... { 
....................    int16 w[16]; 
....................    int16 h,l; 
....................    int32 val; 
....................   #asm 
....................    POP.S 
....................    POP h; 
....................    POP l; 
....................   #endasm 
....................     
....................    w[0] = WREG0; 
....................    w[1] = WREG1; 
....................    w[2] = WREG2; 
....................    w[3] = WREG3; 
....................    w[4] = WREG4; 
....................    w[5] = WREG5; 
....................    w[6] = WREG6; 
....................    w[7] = WREG7; 
....................    w[8] = WREG8; 
....................    w[9] = WREG9; 
....................    w[10] = WREG10; 
....................    w[11] = WREG11; 
....................    w[12] = WREG12; 
....................    w[13] = WREG13; 
....................    w[14] = WREG14; 
....................    w[15] = WREG15; 
....................     
....................     
....................    h &= 0x00FF; 
....................     
....................    val = make32(h, l); 
....................    val -= 2; 
....................     
....................    // this address might be off by 2 bytes 
....................     
....................    printf("\r\n\nADDRESS FAULT 0x%LX ", val); 
....................    for (l=0;l<16;l++) 
....................    { 
....................       printf("W%U:%LX ", l, w[l]); 
....................    } 
....................    printf("\r\n"); 
....................  
....................    while(TRUE); 
.................... } 
.................... #int_stackerr 
.................... void IsrStackerr(void) 
.................... { 
....................    printf("\r\n\n*** STACKERR ***\r\n\n"); 
....................    for(;;) {} 
.................... } 
.................... #endif 
....................  
....................  
.................... // one HTTP purpose TCP sockets. 
.................... TCPSocketInitializer_t TCPSocketInitializer[TCP_CONFIGURATION] = 
.................... { 
....................     {TCP_PURPOSE_HTTP_SERVER, TCP_ETH_RAM, 1500, 500} 
.................... }; 
....................  
.................... #if defined(__PCD__) 
.................... /* 
....................    This example is not compatible with PCD compiler.  It was meant to run 
....................    on PIC18 with read_program_memory().  See ex_st_webserver2.c for a  
....................    webserver example that works with PCD. 
.................... */ 
....................    #error This example not compatible with PCD compiler.  See above comments. 
.................... #endif 
....................  
.................... //here is this examples / page 
.................... rom char  HTML_INDEX_PAGE[]=" 
.................... <HTML><BODY BGCOLOR=#FFFFFF TEXT=#000000> 
.................... <IMG SRC=\"http://www.ccsinfo.com/images/CCSlogotiny.gif\"><P> 
.................... <H1>RIKOTECH Embedded project</H1> 
.................... <FORM METHOD=GET> 
.................... <P>LCD: <INPUT TYPE=\"text\" NAME=\"lcd\" size=20 maxlength=16> 
.................... <BR>LED1:<INPUT type=\"radio\" name=\"led1\" value=1>ON &nbsp; &nbsp; &nbsp; 
.................... <INPUT type=\"radio\" name=\"led1\" value=0>OFF 
.................... <BR>LED2:<INPUT type=\"radio\" name=\"led2\" value=1>ON &nbsp; &nbsp; &nbsp; 
.................... <INPUT type=\"radio\" name=\"led2\" value=0>OFF 
.................... <BR><INPUT TYPE=\"submit\"></FORM> 
.................... <P><A HREF=\"/analog\">Analog Readings</A> 
.................... </BODY></HTML> 
.................... "; 
....................  
.................... rom char  HTML_ANALOG_PAGE[]=" 
.................... <HTML><BODY BGCOLOR=#FFFFFF TEXT=#000000> 
.................... <IMG SRC=\"http://www.ccsinfo.com/images/CCSlogotiny.gif\"> 
.................... <H1>ADC READINGS</H1> 
.................... <P>%0 
.................... <BR>%1 
.................... <P><A HREF=\"/\">Change LCD/LEDs</A> 
.................... </BODY></HTML> 
.................... "; 
....................  
.................... rom char FAVICON[]=""; //saves time when web browser requests this file 
....................  
.................... //this is a callback function to the HTTP stack.  see http.c 
.................... //this demo provides to web "pages", an index (/) and an about page (/about) 
.................... unsigned int32 http_get_page(char *file_str) { 
*
06A00:  MOVLB  2
06A02:  CLRF   xF2
06A04:  CLRF   xF1
06A06:  CLRF   xF0
06A08:  CLRF   xEF
....................    unsigned int32 file_loc=0; 
....................    static char index[]="/"; 
....................    static char about[]="/analog"; 
....................    static char favicon[]="/favicon.ico"; 
....................  
....................    printf("\r\nRequest %s ",file_str); 
06A0A:  MOVLW  FE
06A0C:  MOVWF  FF6
06A0E:  MOVLW  00
06A10:  MOVWF  FF7
06A12:  MOVLW  0A
06A14:  MOVLB  3
06A16:  MOVWF  x18
06A18:  MOVLB  0
06A1A:  RCALL  6836
06A1C:  MOVFF  2EE,FEA
06A20:  MOVFF  2ED,FE9
06A24:  RCALL  6860
06A26:  MOVLW  20
06A28:  BTFSS  F9E.4
06A2A:  BRA    6A28
06A2C:  MOVWF  FAD
....................  
....................    if (stricmp(file_str,index)==0) 
06A2E:  MOVFF  2EE,319
06A32:  MOVFF  2ED,318
06A36:  MOVLW  02
06A38:  MOVLB  3
06A3A:  MOVWF  x1B
06A3C:  MOVLW  BD
06A3E:  MOVWF  x1A
06A40:  MOVLB  0
06A42:  RCALL  6886
06A44:  MOVF   01,F
06A46:  BNZ   6A58
....................       file_loc = &HTML_INDEX_PAGE[0]; 
06A48:  MOVLB  2
06A4A:  CLRF   xF2
06A4C:  CLRF   xF1
06A4E:  MOVLW  FD
06A50:  MOVWF  xF0
06A52:  MOVLW  48
06A54:  MOVWF  xEF
06A56:  BRA    6AAA
....................  
....................    else if (stricmp(file_str,about)==0) 
06A58:  MOVFF  2EE,319
06A5C:  MOVFF  2ED,318
06A60:  MOVLW  02
06A62:  MOVLB  3
06A64:  MOVWF  x1B
06A66:  MOVLW  BF
06A68:  MOVWF  x1A
06A6A:  MOVLB  0
06A6C:  RCALL  6886
06A6E:  MOVF   01,F
06A70:  BNZ   6A82
....................       file_loc = &HTML_ANALOG_PAGE[0]; 
06A72:  MOVLB  2
06A74:  CLRF   xF2
06A76:  CLRF   xF1
06A78:  MOVLW  FC
06A7A:  MOVWF  xF0
06A7C:  MOVLW  84
06A7E:  MOVWF  xEF
06A80:  BRA    6AAA
....................        
....................    else if (stricmp(file_str,favicon)==0) 
06A82:  MOVFF  2EE,319
06A86:  MOVFF  2ED,318
06A8A:  MOVLW  02
06A8C:  MOVLB  3
06A8E:  MOVWF  x1B
06A90:  MOVLW  C7
06A92:  MOVWF  x1A
06A94:  MOVLB  0
06A96:  RCALL  6886
06A98:  MOVF   01,F
06A9A:  BNZ   6AAC
....................       file_loc = &FAVICON[0]; 
06A9C:  MOVLB  2
06A9E:  CLRF   xF2
06AA0:  CLRF   xF1
06AA2:  MOVLW  FC
06AA4:  MOVWF  xF0
06AA6:  MOVLW  82
06AA8:  MOVWF  xEF
06AAA:  MOVLB  0
....................  
....................    if (file_loc) 
06AAC:  MOVLB  2
06AAE:  MOVF   xEF,F
06AB0:  BNZ   6ABE
06AB2:  MOVF   xF0,F
06AB4:  BNZ   6ABE
06AB6:  MOVF   xF1,F
06AB8:  BNZ   6ABE
06ABA:  MOVF   xF2,F
06ABC:  BZ    6AF4
....................       printf("(FILE=%0xLX)",file_loc); 
06ABE:  MOVLW  0C
06AC0:  MOVWF  FF6
06AC2:  MOVLW  01
06AC4:  MOVWF  FF7
06AC6:  MOVLW  06
06AC8:  MOVLB  3
06ACA:  MOVWF  x18
06ACC:  MOVLB  0
06ACE:  RCALL  6836
06AD0:  MOVFF  2EF,2F3
06AD4:  MOVLW  57
06AD6:  MOVLB  2
06AD8:  MOVWF  xF4
06ADA:  MOVLB  0
06ADC:  BRA    69B8
06ADE:  MOVLW  15
06AE0:  MOVWF  FF6
06AE2:  MOVLW  01
06AE4:  MOVWF  FF7
06AE6:  MOVLW  03
06AE8:  MOVLB  3
06AEA:  MOVWF  x18
06AEC:  MOVLB  0
06AEE:  RCALL  6836
06AF0:  BRA    6B02
06AF2:  MOVLB  2
....................    else 
....................       printf("(File Not Found)"); 
06AF4:  MOVLW  1A
06AF6:  MOVWF  FF6
06AF8:  MOVLW  01
06AFA:  MOVWF  FF7
06AFC:  MOVLB  0
06AFE:  CALL   02D4
....................  
....................    return(file_loc); 
06B02:  MOVFF  2EF,00
06B06:  MOVFF  2F0,01
06B0A:  MOVFF  2F1,02
06B0E:  MOVFF  2F2,03
06B12:  GOTO   87F6 (RETURN)
.................... } 
....................  
.................... //this is a callback function to the HTTP stack. see http.c 
.................... // this demo provides handling for two formatting chars, %0 and %1. 
.................... //  %0 is ADC for channel 0, %1 is ADC for channel 1. 
.................... unsigned int8 http_format_char(unsigned int32 file, char id, char *str, unsigned int8 max_ret) { 
*
07F5C:  MOVLB  3
07F5E:  CLRF   x18
....................    char new_str[20]; 
....................    unsigned int8 len=0; 
....................    unsigned int16 i; 
....................  
....................    *str=0; 
07F60:  MOVFF  301,FE9
07F64:  MOVFF  302,FEA
07F68:  CLRF   FEF
....................  
....................    switch(id) { 
07F6A:  MOVF   x00,W
07F6C:  XORLW  30
07F6E:  MOVLB  0
07F70:  BZ    7F78
07F72:  XORLW  01
07F74:  BZ    803C
07F76:  BRA    8042
....................       case '0': 
....................         #if STACK_USE_CCS_PICNET 
....................          set_adc_channel(0); 
....................          delay_us(100); 
....................         #endif 
....................          i=(long)read_adc()*100/255; 
07F78:  BSF    FC2.1
07F7A:  BTFSC  FC2.1
07F7C:  BRA    7F7A
07F7E:  MOVF   FC4,W
07F80:  MOVLB  3
07F82:  CLRF   x1E
07F84:  CLRF   x1D
07F86:  CLRF   x1C
07F88:  MOVWF  x1B
07F8A:  MOVFF  31E,345
07F8E:  MOVFF  31D,344
07F92:  MOVFF  31C,343
07F96:  MOVWF  x42
07F98:  CLRF   x49
07F9A:  CLRF   x48
07F9C:  CLRF   x47
07F9E:  MOVLW  64
07FA0:  MOVWF  x46
07FA2:  MOVLB  0
07FA4:  CALL   61B0
07FA8:  MOVFF  03,31E
07FAC:  MOVFF  02,31D
07FB0:  MOVFF  01,31C
07FB4:  MOVFF  00,31B
07FB8:  BCF    FD8.1
07FBA:  MOVFF  03,322
07FBE:  MOVFF  02,321
07FC2:  MOVFF  01,320
07FC6:  MOVFF  00,31F
07FCA:  MOVLB  3
07FCC:  CLRF   x26
07FCE:  CLRF   x25
07FD0:  CLRF   x24
07FD2:  SETF   x23
07FD4:  MOVLB  0
07FD6:  BRA    7D58
07FD8:  MOVFF  01,31A
07FDC:  MOVFF  00,319
....................          sprintf(new_str,"<B>%s = </B>%lu",STANDARD_ADC_STRING,i); 
07FE0:  MOVLW  03
07FE2:  MOVLB  2
07FE4:  MOVWF  xBC
07FE6:  MOVLW  04
07FE8:  MOVWF  xBB
07FEA:  MOVLW  2C
07FEC:  MOVWF  FF6
07FEE:  MOVLW  01
07FF0:  MOVWF  FF7
07FF2:  MOVLW  03
07FF4:  MOVLB  3
07FF6:  MOVWF  x1B
07FF8:  MOVLB  0
07FFA:  RCALL  7E44
07FFC:  MOVLW  3C
07FFE:  MOVWF  FF6
08000:  MOVLW  01
08002:  MOVWF  FF7
08004:  BRA    7E6E
08006:  MOVLW  31
08008:  MOVWF  FF6
0800A:  MOVLW  01
0800C:  MOVWF  FF7
0800E:  MOVLW  07
08010:  MOVLB  3
08012:  MOVWF  x1B
08014:  MOVLB  0
08016:  RCALL  7E44
08018:  MOVLW  10
0801A:  MOVWF  FE9
0801C:  MOVFF  31A,31C
08020:  MOVFF  319,31B
08024:  BRA    7E92
....................          len=strlen(new_str); 
08026:  MOVLW  03
08028:  MOVLB  3
0802A:  MOVWF  x1C
0802C:  MOVLW  04
0802E:  MOVWF  x1B
08030:  MOVLB  0
08032:  CALL   660E
08036:  MOVFF  01,318
....................          break; 
0803A:  BRA    8042
....................  
....................       case '1': 
....................         #if STACK_USE_CCS_PICNET 
....................          set_adc_channel(1); 
....................          delay_us(100); 
....................          i=read_adc(); 
....................          sprintf(new_str,"<B>AN1 = </B>0x%X",i); 
....................          len=strlen(new_str); 
....................         #else 
....................          len=0; 
0803C:  MOVLB  3
0803E:  CLRF   x18
....................         #endif 
....................          break; 
08040:  MOVLB  0
....................  
....................    } 
....................  
....................    if (len) { 
08042:  MOVLB  3
08044:  MOVF   x18,F
08046:  BZ    8076
....................       if (len>max_ret) {len=max_ret;} 
08048:  MOVF   x18,W
0804A:  SUBWF  x03,W
0804C:  BTFSS  FD8.0
0804E:  MOVFF  303,318
....................       memcpy(str,new_str,len+1); 
08052:  MOVLW  01
08054:  ADDWF  x18,W
08056:  MOVWF  x1B
08058:  MOVFF  302,FEA
0805C:  MOVFF  301,FE9
08060:  MOVLW  03
08062:  MOVWF  FE2
08064:  MOVLW  04
08066:  MOVWF  FE1
08068:  MOVF   x1B,W
0806A:  MOVWF  01
0806C:  BZ    8076
0806E:  MOVFF  FE6,FEE
08072:  DECFSZ 01,F
08074:  BRA    806E
....................    } 
....................  
....................    return(len); 
08076:  MOVFF  318,01
0807A:  MOVLB  0
0807C:  GOTO   832A (RETURN)
.................... } 
....................  
.................... //this is a callback function to the HTTP stack. see http.c 
.................... //in this example it verifies that "pwd" is "master", if it is 
.................... //then it sets led1 and led2 ("led1" and "led2") based on their value 
.................... //and changes the lcd screen ("lcd"). 
.................... void http_exec_cgi(unsigned int32 file, char *key, char *val) { 
....................    static char led1_key[]="led1"; 
....................    static char led2_key[]="led2"; 
....................    static char lcd_key[]="lcd"; 
....................    unsigned int8 v; 
....................    char scr[17]; 
....................  
....................    printf("\r\nCGI FILE=%LD KEY=%S VAL=%S", file, key, val); 
*
0710A:  MOVLW  40
0710C:  MOVWF  FF6
0710E:  MOVLW  01
07110:  MOVWF  FF7
07112:  MOVLW  0B
07114:  MOVLB  3
07116:  MOVWF  x18
07118:  MOVLB  0
0711A:  CALL   6836
0711E:  MOVLW  41
07120:  MOVWF  FE9
07122:  MOVFF  301,31B
07126:  MOVFF  300,31A
0712A:  MOVFF  2FF,319
0712E:  MOVFF  2FE,318
07132:  BRA    6BAA
07134:  MOVLW  4E
07136:  MOVWF  FF6
07138:  MOVLW  01
0713A:  MOVWF  FF7
0713C:  MOVLW  05
0713E:  MOVLB  3
07140:  MOVWF  x18
07142:  MOVLB  0
07144:  CALL   6836
07148:  MOVFF  303,FEA
0714C:  MOVFF  302,FE9
07150:  CALL   6860
07154:  MOVLW  55
07156:  MOVWF  FF6
07158:  MOVLW  01
0715A:  MOVWF  FF7
0715C:  MOVLW  05
0715E:  MOVLB  3
07160:  MOVWF  x18
07162:  MOVLB  0
07164:  CALL   6836
07168:  MOVFF  305,FEA
0716C:  MOVFF  304,FE9
07170:  CALL   6860
....................  
....................    if (stricmp(key,led1_key)==0) { 
07174:  MOVFF  303,319
07178:  MOVFF  302,318
0717C:  MOVLW  02
0717E:  MOVLB  3
07180:  MOVWF  x1B
07182:  MOVLW  D4
07184:  MOVWF  x1A
07186:  MOVLB  0
07188:  CALL   6886
0718C:  MOVF   01,F
0718E:  BNZ   71B0
....................       v=atoi(val); 
07190:  MOVFF  305,319
07194:  MOVFF  304,318
07198:  RCALL  6D10
0719A:  MOVFF  01,306
....................       if (v) {LED_ON(USER_LED1);} 
0719E:  MOVLB  3
071A0:  MOVF   x06,F
071A2:  BZ    71AA
071A4:  BCF    F92.5
071A6:  BCF    F89.5
071A8:  BRA    71AE
....................       else {LED_OFF(USER_LED1);} 
071AA:  BCF    F92.5
071AC:  BSF    F89.5
071AE:  MOVLB  0
....................    } 
....................  
....................    if (stricmp(key,led2_key)==0) { 
071B0:  MOVFF  303,319
071B4:  MOVFF  302,318
071B8:  MOVLW  02
071BA:  MOVLB  3
071BC:  MOVWF  x1B
071BE:  MOVLW  D9
071C0:  MOVWF  x1A
071C2:  MOVLB  0
071C4:  CALL   6886
071C8:  MOVF   01,F
071CA:  BNZ   71EC
....................       v=atoi(val); 
071CC:  MOVFF  305,319
071D0:  MOVFF  304,318
071D4:  RCALL  6D10
071D6:  MOVFF  01,306
....................       if (v) {LED_ON(USER_LED2);} 
071DA:  MOVLB  3
071DC:  MOVF   x06,F
071DE:  BZ    71E6
071E0:  BCF    F93.4
071E2:  BCF    F8A.4
071E4:  BRA    71EA
....................       else {LED_OFF(USER_LED2);} 
071E6:  BCF    F93.4
071E8:  BSF    F8A.4
071EA:  MOVLB  0
....................    } 
....................  
....................    if (stricmp(key,lcd_key)==0)  
071EC:  MOVFF  303,319
071F0:  MOVFF  302,318
071F4:  MOVLW  02
071F6:  MOVLB  3
071F8:  MOVWF  x1B
071FA:  MOVLW  DE
071FC:  MOVWF  x1A
071FE:  MOVLB  0
07200:  CALL   6886
07204:  MOVF   01,F
07206:  BNZ   7254
....................    { 
....................       IPToString(scr, &MY_IP); 
07208:  MOVLW  03
0720A:  MOVLB  3
0720C:  MOVWF  x19
0720E:  MOVLW  07
07210:  MOVWF  x18
07212:  CLRF   x1B
07214:  MOVLW  29
07216:  MOVWF  x1A
07218:  MOVLB  0
0721A:  BRA    7046
....................       printf(lcd_putc,"\f%s\n\r%s",val, scr); 
0721C:  MOVLW  0C
0721E:  MOVLB  3
07220:  MOVWF  x1A
07222:  MOVLB  0
07224:  CALL   0548
07228:  MOVFF  305,FEA
0722C:  MOVFF  304,FE9
07230:  RCALL  70E4
07232:  MOVLW  0A
07234:  MOVLB  3
07236:  MOVWF  x1A
07238:  MOVLB  0
0723A:  CALL   0548
0723E:  MOVLW  0D
07240:  MOVLB  3
07242:  MOVWF  x1A
07244:  MOVLB  0
07246:  CALL   0548
0724A:  MOVLW  03
0724C:  MOVWF  FEA
0724E:  MOVLW  07
07250:  MOVWF  FE9
07252:  RCALL  70E4
....................    } 
07254:  GOTO   72C2 (RETURN)
.................... } 
....................  
....................  
.................... void LCDTask(void)  
.................... { 
....................    static enum {LCD_INIT=0, LCD_NO_MAC, LCD_NO_DHCP, LCD_IDLE} state=0; 
....................  
....................    switch(state)  
*
05D0C:  MOVLB  2
05D0E:  MOVF   xE2,W
05D10:  XORLW  00
05D12:  MOVLB  0
05D14:  BZ    5D20
05D16:  XORLW  01
05D18:  BZ    5D3A
05D1A:  XORLW  02
05D1C:  BZ    5DB8
05D1E:  BRA    5DC4
....................    { 
....................       case LCD_INIT: 
....................          printf(lcd_putc, "\fWebserver\n\rNo MAC Link"); 
05D20:  MOVLW  5E
05D22:  MOVWF  FF6
05D24:  MOVLW  01
05D26:  MOVWF  FF7
05D28:  CALL   05F8
....................          state = LCD_NO_MAC; 
05D2C:  MOVLW  01
05D2E:  MOVLB  2
05D30:  MOVWF  xE2
....................          LED_OFF(USER_LED1); 
05D32:  BCF    F92.5
05D34:  BSF    F89.5
....................          break; 
05D36:  MOVLB  0
05D38:  BRA    5DC4
....................           
....................       case LCD_NO_MAC: 
....................          if (MACIsLinked()) 
05D3A:  RCALL  5C16
05D3C:  MOVF   01,F
05D3E:  BZ    5DB6
....................          { 
....................            #if defined(STACK_USE_DHCP_CLIENT) 
....................             if (!DHCPIsEnabled(0)) 
....................            #else 
....................             if (1) 
....................            #endif 
....................             { 
....................                printf(lcd_putc, "\fDHCP Disabled\n\r%u.%u.%u.%u",  
....................                      MY_IP_BYTE1, MY_IP_BYTE2, MY_IP_BYTE3, MY_IP_BYTE4 
....................                   ); 
05D40:  MOVLW  76
05D42:  MOVWF  FF6
05D44:  MOVLW  01
05D46:  MOVWF  FF7
05D48:  MOVLW  10
05D4A:  MOVLB  2
05D4C:  MOVWF  xE3
05D4E:  MOVLB  0
05D50:  BRA    5C32
05D52:  MOVFF  29,2E3
05D56:  MOVLW  1B
05D58:  MOVLB  2
05D5A:  MOVWF  xE4
05D5C:  MOVLB  0
05D5E:  RCALL  5C8A
05D60:  MOVLW  2E
05D62:  MOVLB  3
05D64:  MOVWF  x1A
05D66:  MOVLB  0
05D68:  CALL   0548
05D6C:  MOVFF  2A,2E3
05D70:  MOVLW  1B
05D72:  MOVLB  2
05D74:  MOVWF  xE4
05D76:  MOVLB  0
05D78:  RCALL  5C8A
05D7A:  MOVLW  2E
05D7C:  MOVLB  3
05D7E:  MOVWF  x1A
05D80:  MOVLB  0
05D82:  CALL   0548
05D86:  MOVFF  2B,2E3
05D8A:  MOVLW  1B
05D8C:  MOVLB  2
05D8E:  MOVWF  xE4
05D90:  MOVLB  0
05D92:  RCALL  5C8A
05D94:  MOVLW  2E
05D96:  MOVLB  3
05D98:  MOVWF  x1A
05D9A:  MOVLB  0
05D9C:  CALL   0548
05DA0:  MOVFF  2C,2E3
05DA4:  MOVLW  1B
05DA6:  MOVLB  2
05DA8:  MOVWF  xE4
05DAA:  MOVLB  0
05DAC:  RCALL  5C8A
....................                state = LCD_IDLE; 
05DAE:  MOVLW  03
05DB0:  MOVLB  2
05DB2:  MOVWF  xE2
05DB4:  MOVLB  0
....................             } 
....................             else 
....................             { 
....................                printf(lcd_putc, "\fWebserver\n\rDHCP Not Bound"); 
....................                state = LCD_NO_DHCP; 
....................             } 
....................          } 
....................          break; 
05DB6:  BRA    5DC4
....................      
....................     #if defined(STACK_USE_DHCP_CLIENT) 
....................      case LCD_NO_DHCP: 
....................          if (!MACIsLinked()) 
....................          { 
....................             state = LCD_INIT; 
....................             break; 
....................          } 
....................          if (DHCPIsBound(0)) 
....................          { 
....................             state = LCD_IDLE; 
....................             printf(lcd_putc, "\fDHCP Bound\n\r%u.%u.%u.%u", MY_IP_BYTE1, MY_IP_BYTE2, 
....................                MY_IP_BYTE3, MY_IP_BYTE4); 
....................             LED_ON(USER_LED1); 
....................          } 
....................          break; 
....................     #endif 
....................  
....................       case LCD_IDLE: 
....................          if ( 
....................                !MACIsLinked() 
....................               #if defined(STACK_USE_DHCP_CLIENT) 
05DB8:  RCALL  5C16
05DBA:  MOVF   01,F
05DBC:  BNZ   5DC4
....................                || (DHCPIsEnabled(0) && !DHCPIsBound(0)) 
....................               #endif 
....................             ) 
....................          { 
....................             state = LCD_INIT; 
05DBE:  MOVLB  2
05DC0:  CLRF   xE2
05DC2:  MOVLB  0
....................          } 
....................          break; 
....................    } 
05DC4:  GOTO   9204 (RETURN)
.................... } 
....................  
.................... void main(void)  
*
09092:  CLRF   FF8
09094:  BCF    FD0.7
09096:  BSF    07.7
09098:  MOVLW  7E
0909A:  MOVWF  00
0909C:  MOVLW  10
0909E:  MOVWF  01
090A0:  MOVLW  02
090A2:  MOVWF  FE9
090A4:  MOVLW  00
090A6:  MOVWF  FEA
090A8:  CLRF   FEE
090AA:  DECFSZ 00,F
090AC:  BRA    90A8
090AE:  DECFSZ 01,F
090B0:  BRA    90A8
090B2:  CLRF   16
090B4:  BSF    FB8.3
090B6:  MOVLW  11
090B8:  MOVWF  FAF
090BA:  MOVLW  04
090BC:  MOVWF  FB0
090BE:  MOVLW  A6
090C0:  MOVWF  FAC
090C2:  MOVLW  90
090C4:  MOVWF  FAB
090C6:  BCF    67.0
090C8:  MOVLW  41
090CA:  MOVWF  6B
090CC:  MOVLW  FE
090CE:  MOVWF  6A
090D0:  MOVLW  9F
090D2:  MOVWF  69
090D4:  MOVLW  9E
090D6:  MOVWF  68
090D8:  CLRF   73
090DA:  CLRF   72
090DC:  CLRF   71
090DE:  CLRF   70
090E0:  CLRF   x80
090E2:  CLRF   7F
090E4:  BCF    67.2
090E6:  MOVLW  FE
090E8:  MOVWF  xDB
090EA:  MOVLB  1
090EC:  MOVWF  x34
090EE:  MOVLB  2
090F0:  CLRF   xBC
090F2:  CLRF   xBB
090F4:  CLRF   xE2
090F6:  MOVF   FC1,W
090F8:  ANDLW  C0
090FA:  IORLW  0F
090FC:  MOVWF  FC1
090FE:  MOVLW  07
09100:  MOVWF  FB4
09102:  BRA    918A
09104:  DATA 25,02
09106:  DATA BD,2F
09108:  DATA 00,2F
0910A:  DATA 61,6E
0910C:  DATA 61,6C
0910E:  DATA 6F,67
09110:  DATA 00,2F
09112:  DATA 66,61
09114:  DATA 76,69
09116:  DATA 63,6F
09118:  DATA 6E,2E
0911A:  DATA 69,63
0911C:  DATA 6F,00
0911E:  DATA 6C,65
09120:  DATA 64,31
09122:  DATA 00,6C
09124:  DATA 65,64
09126:  DATA 32,00
09128:  DATA 6C,63
0912A:  DATA 64,00
0912C:  DATA 03,01
0912E:  DATA 41,FE
09130:  DATA 00,01
09132:  DATA 1D,01
09134:  DATA 74,20
09136:  DATA 00,3F
09138:  DATA 00,47
0913A:  DATA 45,54
0913C:  DATA 00,50
0913E:  DATA 4F,53
09140:  DATA 54,00
09142:  DATA 43,6F
09144:  DATA 6E,74
09146:  DATA 65,6E
09148:  DATA 74,2D
0914A:  DATA 4C,65
0914C:  DATA 6E,67
0914E:  DATA 74,68
09150:  DATA 3A,00
09152:  DATA 01,02
09154:  DATA 90,00
09156:  DATA 02,02
09158:  DATA 95,00
0915A:  DATA 00,04
0915C:  DATA 02,9B
0915E:  DATA 45,00
09160:  DATA 00,20
09162:  DATA 04,C0
09164:  DATA 00,18
09166:  DATA 80,64
09168:  DATA 11,2A
0916A:  DATA 9D,0A
0916C:  DATA 0B,0C
0916E:  DATA 0D,0A
09170:  DATA 0B,0C
09172:  DATA 0E,04
09174:  DATA 00,04
09176:  DATA 01,00
09178:  DATA 0C,00
0917A:  DATA 00,01
0917C:  DATA 02,03
0917E:  DATA 04,06
09180:  DATA 00,23
09182:  DATA 08,00
09184:  DATA DC,05
09186:  DATA F4,01
09188:  DATA 00,00
0918A:  MOVLW  00
0918C:  MOVWF  FF8
0918E:  MOVLW  91
09190:  MOVWF  FF7
09192:  MOVLW  04
09194:  MOVWF  FF6
09196:  TBLRD*+
09198:  MOVF   FF5,W
0919A:  MOVWF  00
0919C:  XORLW  00
0919E:  BZ    91C6
091A0:  TBLRD*+
091A2:  MOVF   FF5,W
091A4:  MOVWF  01
091A6:  BTFSC  FE8.7
091A8:  BRA    91B4
091AA:  ANDLW  0F
091AC:  MOVWF  FEA
091AE:  TBLRD*+
091B0:  MOVFF  FF5,FE9
091B4:  BTFSC  01.6
091B6:  TBLRD*+
091B8:  BTFSS  01.6
091BA:  TBLRD*+
091BC:  MOVFF  FF5,FEE
091C0:  DCFSNZ 00,F
091C2:  BRA    9196
091C4:  BRA    91B8
091C6:  CLRF   FF8
.................... { 
....................    Init(); 
091C8:  MOVLB  0
091CA:  GOTO   02C4
....................     
....................    printf("\r\n\nCCS TCP/IP TUTORIAL, EXAMPLE 15 (HTTP SERVER)\r\n"); 
091CE:  MOVLW  AE
091D0:  MOVWF  FF6
091D2:  MOVLW  01
091D4:  MOVWF  FF7
091D6:  CALL   02D4
....................     
....................    lcd_init(); 
091DA:  GOTO   046A
....................     
....................    printf(lcd_putc,"\fCCS CGI Example\n\rInit Stack..."); 
091DE:  MOVLW  E2
091E0:  MOVWF  FF6
091E2:  MOVLW  01
091E4:  MOVWF  FF7
091E6:  CALL   05F8
....................  
....................    StackInit(); 
091EA:  GOTO   2AE8
....................     
....................    printf("\r\n\nCCS CGI Example\r\nWaiting"); 
091EE:  MOVLW  02
091F0:  MOVWF  FF6
091F2:  MOVLW  02
091F4:  MOVWF  FF7
091F6:  CALL   02D4
....................     
....................    while(TRUE)  
....................    { 
....................       restart_wdt(); 
091FA:  CLRWDT
....................       StackTask(); 
091FC:  GOTO   5A20
....................  
....................       LCDTask(); 
09200:  GOTO   5D0C
....................       StackApplications(); //HTTP is processed here 
09204:  BRA    908A
09206:  BRA    91FA
....................    } 
.................... } 
09208:  SLEEP 

Configuration Fuses:
   Word  1: C600   H4 FCMEN IESO
   Word  2: 1E1E   PUT BROWNOUT BORV21 NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB

ROM data:
00FC82: 00 

00FC84: 20 0A 3C 48 54 4D 4C 3E 3C 42 4F 44 59 20 42 47 
00FC94: 43 4F 4C 4F 52 3D 23 46 46 46 46 46 46 20 54 45 
00FCA4: 58 54 3D 23 30 30 30 30 30 30 3E 20 0A 3C 49 4D 
00FCB4: 47 20 53 52 43 3D 22 68 74 74 70 3A 2F 2F 77 77 
00FCC4: 77 2E 63 63 73 69 6E 66 6F 2E 63 6F 6D 2F 69 6D 
00FCD4: 61 67 65 73 2F 43 43 53 6C 6F 67 6F 74 69 6E 79 
00FCE4: 2E 67 69 66 22 3E 20 0A 3C 48 31 3E 41 44 43 20 
00FCF4: 52 45 41 44 49 4E 47 53 3C 2F 48 31 3E 20 0A 3C 
00FD04: 50 3E 25 30 20 0A 3C 42 52 3E 25 31 20 0A 3C 50 
00FD14: 3E 3C 41 20 48 52 45 46 3D 22 2F 22 3E 43 68 61 
00FD24: 6E 67 65 20 4C 43 44 2F 4C 45 44 73 3C 2F 41 3E 
00FD34: 20 0A 3C 2F 42 4F 44 59 3E 3C 2F 48 54 4D 4C 3E 
00FD44: 20 0A 00 

00FD48: 20 0A 3C 48 54 4D 4C 3E 3C 42 4F 44 59 20 42 47 
00FD58: 43 4F 4C 4F 52 3D 23 46 46 46 46 46 46 20 54 45 
00FD68: 58 54 3D 23 30 30 30 30 30 30 3E 20 0A 3C 49 4D 
00FD78: 47 20 53 52 43 3D 22 68 74 74 70 3A 2F 2F 77 77 
00FD88: 77 2E 63 63 73 69 6E 66 6F 2E 63 6F 6D 2F 69 6D 
00FD98: 61 67 65 73 2F 43 43 53 6C 6F 67 6F 74 69 6E 79 
00FDA8: 2E 67 69 66 22 3E 3C 50 3E 20 0A 3C 48 31 3E 52 
00FDB8: 49 4B 4F 54 45 43 48 20 45 6D 62 65 64 64 65 64 
00FDC8: 20 70 72 6F 6A 65 63 74 3C 2F 48 31 3E 20 0A 3C 
00FDD8: 46 4F 52 4D 20 4D 45 54 48 4F 44 3D 47 45 54 3E 
00FDE8: 20 0A 3C 50 3E 4C 43 44 3A 20 3C 49 4E 50 55 54 
00FDF8: 20 54 59 50 45 3D 22 74 65 78 74 22 20 4E 41 4D 
00FE08: 45 3D 22 6C 63 64 22 20 73 69 7A 65 3D 32 30 20 
00FE18: 6D 61 78 6C 65 6E 67 74 68 3D 31 36 3E 20 0A 3C 
00FE28: 42 52 3E 4C 45 44 31 3A 3C 49 4E 50 55 54 20 74 
00FE38: 79 70 65 3D 22 72 61 64 69 6F 22 20 6E 61 6D 65 
00FE48: 3D 22 6C 65 64 31 22 20 76 61 6C 75 65 3D 31 3E 
00FE58: 4F 4E 20 26 6E 62 73 70 3B 20 26 6E 62 73 70 3B 
00FE68: 20 26 6E 62 73 70 3B 20 0A 3C 49 4E 50 55 54 20 
00FE78: 74 79 70 65 3D 22 72 61 64 69 6F 22 20 6E 61 6D 
00FE88: 65 3D 22 6C 65 64 31 22 20 76 61 6C 75 65 3D 30 
00FE98: 3E 4F 46 46 20 0A 3C 42 52 3E 4C 45 44 32 3A 3C 
00FEA8: 49 4E 50 55 54 20 74 79 70 65 3D 22 72 61 64 69 
00FEB8: 6F 22 20 6E 61 6D 65 3D 22 6C 65 64 32 22 20 76 
00FEC8: 61 6C 75 65 3D 31 3E 4F 4E 20 26 6E 62 73 70 3B 
00FED8: 20 26 6E 62 73 70 3B 20 26 6E 62 73 70 3B 20 0A 
00FEE8: 3C 49 4E 50 55 54 20 74 79 70 65 3D 22 72 61 64 
00FEF8: 69 6F 22 20 6E 61 6D 65 3D 22 6C 65 64 32 22 20 
00FF08: 76 61 6C 75 65 3D 30 3E 4F 46 46 20 0A 3C 42 52 
00FF18: 3E 3C 49 4E 50 55 54 20 54 59 50 45 3D 22 73 75 
00FF28: 62 6D 69 74 22 3E 3C 2F 46 4F 52 4D 3E 20 0A 3C 
00FF38: 50 3E 3C 41 20 48 52 45 46 3D 22 2F 61 6E 61 6C 
00FF48: 6F 67 22 3E 41 6E 61 6C 6F 67 20 52 65 61 64 69 
00FF58: 6E 67 73 3C 2F 41 3E 20 0A 3C 2F 42 4F 44 59 3E 
00FF68: 3C 2F 48 54 4D 4C 3E 20 0A 00 

00FF72: 3C 48 54 4D 4C 3E 3C 42 4F 44 59 3E 3C 48 31 3E 
00FF82: 35 30 30 20 45 72 72 6F 72 3C 2F 48 31 3E 3C 48 
00FF92: 52 3E 3C 50 3E 49 6E 74 65 72 6E 61 6C 20 53 65 
00FFA2: 72 76 65 72 20 45 72 72 6F 72 3C 2F 42 4F 44 59 
00FFB2: 3E 3C 2F 48 54 4D 4C 3E 00 

00FFBC: 3C 48 54 4D 4C 3E 3C 42 4F 44 59 3E 3C 48 31 3E 
00FFCC: 34 30 34 20 45 72 72 6F 72 3C 2F 48 31 3E 3C 48 
00FFDC: 52 3E 3C 50 3E 46 69 6C 65 20 4E 6F 74 20 66 6F 
00FFEC: 75 6E 64 2E 3C 2F 42 4F 44 59 3E 3C 2F 48 54 4D 
00FFFC: 4C 3E 00 
