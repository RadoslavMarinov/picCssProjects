CCS PCH C Compiler, Version 5.015, 5967               20-май-14 20:40

               Filename:   D:\Projects\PIC18F4620_ENC28J60\CCS\ex14ws\ex14.lst

               ROM used:   26202 bytes (40%)
                           Largest free fragment is 39330
               RAM used:   364 (9%) at main() level
                           711 (18%) worst case
               Stack used: 12 locations (10 in main + 2 for interrupts)
               Stack size: 31

*
00000:  GOTO   6548
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  00,0E
0003C:  MOVFF  01,0F
00040:  MOVFF  02,10
00044:  MOVFF  03,11
00048:  BTFSS  FF2.5
0004A:  GOTO   0054
0004E:  BTFSC  FF2.2
00050:  GOTO   00B0
00054:  MOVFF  0E,00
00058:  MOVFF  0F,01
0005C:  MOVFF  10,02
00060:  MOVFF  11,03
00064:  MOVFF  0C,FE9
00068:  MOVFF  07,FEA
0006C:  BSF    07.7
0006E:  MOVFF  08,FE1
00072:  MOVFF  09,FE2
00076:  MOVFF  0A,FD9
0007A:  MOVFF  0B,FDA
0007E:  MOVFF  12,FF3
00082:  MOVFF  13,FF4
00086:  MOVFF  14,FFA
0008A:  MOVF   04,W
0008C:  MOVFF  06,FE0
00090:  MOVFF  05,FD8
00094:  RETFIE 0
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // ex14.c - Example 14 from the Embedded Internet/Embedded Ethernet tutorial 
.................... // 
.................... // A very simple webserver.  Webserver is written in this example (see 
.................... // HTTPTask()), does not use a CCS or Microchip written HTTP library. 
.................... // 
.................... // NOTE: Change the code in IPAddrInit() to your desired IP address, which 
.................... //       is based on your network. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // force enabling of LCD library.  if hardware doesn't have LCD hardware, 
.................... // then it will use RS232/Serial for lcd_putc(). 
.................... #define STACK_USE_PICDEM_LCD     1 
....................  
.................... #define STACK_USE_ICMP_SERVER 
.................... #define STACK_USE_TCP 
....................  
.................... // configure TCP stack for the correct number of sockets and RAM needed. 
.................... #define TCP_CONFIGURATION  1   //tell TCPIPConfig.h to not include default TCPSocketInitializer[] array. 
.................... // See ex13b.c for comments. 
.................... #define TCP_ETH_RAM_SIZE   1280 
....................  
.................... #include "ccstcpip.h" 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // ccstcpip.h - Common code shared among all Embedded Internet/Embedded 
.................... // Ethernet tutorial book examples. 
.................... // 
.................... // If you are using a CCS Embedded Ethernet Board (labeled PICENS, which 
.................... // has an MCP ENC28J60) then define STACK_USE_CCS_PICENS to TRUE. 
.................... // 
.................... // If you are using a CCS Embedded Internet Board (labeled PICNET, which 
.................... // has a Realtek RTL8019AS and a 56K Modem) then define STACK_USE_CCS_PICNET 
.................... // to TRUE. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // 10/25/06 
.................... //  - Added STACK_USE_CCS_PICEEC 
.................... //  - ExamplePacket[] UDP header length fixed 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #define STACK_USE_CCS_EWLWIFIB      0 //18f67k22 + mrf24wb0m 
.................... #define STACK_USE_CCS_EWLWIFIG      0 //18f67k22 + mrf24wg0m 
.................... #define STACK_USE_CCS_PICEEC        0 //18f67j60 
.................... #define STACK_USE_CCS_PICENS        1 //18f4620 + enc28j60 
.................... #define STACK_USE_PIC24FJGA110_ENC28     0 //explorer 16, PIC24FJ256GA110, ENC28J60.  unfortunately with this combinatin you cannot use ENC28J60 and 25LC256 at same time 
.................... #define STACK_USE_PIC24FJGA010_ENC28     0 //explorer 16, PIC24FJ128GA010, ENC28J60. 
.................... #define STACK_USE_CCS_EWL5V_REV5    0 //ezWebLynx 5V (REV5), 18f67k22 + enc28j60 
.................... #define STACK_USE_CCS_EWL3V         0 //ezWebLynx 3V, 18f67j60 
.................... //#define STACK_USE_CCS_PICNET        0 //18f6722 + realtek 
....................  
.................... #define STACK_IS_CCS_EXAMPLE 
....................  
.................... /* not working right now 
.................... #define STACK_USE_CCS_PICNET        0 //18f6722 + realtek 
.................... #define STACK_USE_CCS_EWL5V         0 //ezWebLynx 5V 
.................... #define STACK_USE_CCS_EWL5V_REV2    0 //ezWebLynx 5V (REV2) 
.................... */ 
....................  
.................... #if STACK_USE_CCS_EWLWIFIB || STACK_USE_CCS_EWLWIFIG 
....................    #define WF_DEBUG  
....................    #define STACK_USE_WIFI 1 
....................    #if STACK_USE_CCS_EWLWIFIG 
....................       #define MRF24WG 
....................    #endif 
.................... #else 
....................    #define STACK_USE_WIFI 0 
.................... #endif 
....................  
.................... #define LCD_EXTENDED_NEWLINE  //configuration for lcd.c driver/library 
....................   
.................... #if STACK_USE_CCS_EWLWIFIB || STACK_USE_CCS_EWLWIFIG 
....................    #include <18F67K22.h> 
....................    #device HIGH_INTS = TRUE 
....................    #include "tcpip\p18cxxx.h" 
....................     
....................    #reserve 0xF16:0xFFF   //SFR 
....................    #use delay(clock=64M, XTAL=16M) 
....................     
....................    //took out fuses 12/13/11 
....................    //#fuses HSH 
....................    //#fuses PLLEN 
....................    //#fuses MCLR 
....................     
....................    #use rs232(baud=9600, uart1, stream=STREAM_UI, errors) 
....................  
....................    #define wf_debug_printf printf 
....................    void wf_debug_putc(char c) {putc(c);} 
....................  
....................    void lcd_putc(char c) 
....................    { 
....................      #if STACK_USE_PICDEM_LCD 
....................        if (c == '\f') 
....................          printf("\r\n\n"); 
....................        else 
....................          putc(c); 
....................      #endif 
....................    } 
....................    #define lcd_init() 
....................    #ifndef STACK_USE_PICDEM_LCD 
....................       #define STACK_USE_PICDEM_LCD 0   // no hardware LCD support 
....................    #endif 
....................      
....................    #define LED_ON       output_high 
....................    #define LED_OFF      output_low 
....................    #define USER_LED1    PIN_G3                 //input1 
....................    #define USER_LED2    PIN_G4                 //input2 
....................    #define USER_LED3    PIN_F3                 //input3 
....................    #define STANDARD_ADC_STRING  "AN9" 
....................    #define STANDARD_ADC_CHANNEL 9              //input4 
....................    #define BUTTON1_PRESSED() (input(PIN_F5))   //input5 
....................    #define BUTTON2_PRESSED() (input(PIN_A5))   //input6 
....................  
....................    // more gpio / hardware definitions hiding in HardwareProfile.h 
....................  
....................    // macros used by CCS's WIFIConnectTask() 
....................    #define LED_WIFI  PIN_E0 
....................    #define LED_CONNECTION_ON()   output_drive(LED_WIFI);   output_high(LED_WIFI) 
....................    #define LED_CONNECTION_OFF()   output_drive(LED_WIFI);   output_low(LED_WIFI) 
....................     
....................    void init_user_io(void) 
....................    { 
....................       setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_2); 
....................       setup_adc_ports(sAN9); 
....................       set_adc_channel(STANDARD_ADC_CHANNEL); 
....................        
....................       output_drive(USER_LED1); 
....................       output_drive(USER_LED2); 
....................       output_float(PIN_G4); 
....................       output_float(PIN_G3); 
....................       LED_OFF(USER_LED1); 
....................       LED_OFF(USER_LED2); 
....................       LED_CONNECTION_OFF(); 
....................    } 
....................           
....................    #define __AT45DB_D__ 
....................    #define FLASH_SELECT PIN_D2 
....................    #define FLASH_CLOCK  PIN_D6 
....................    #define FLASH_DI     PIN_D4 
....................    #define FLASH_DO     PIN_D5 
....................    #define FLASH_BUFFER_SIZE    264 
....................    #define FLASH_BUFFER_COUNT   4096 
....................    #include "at45db.c"  
....................        
....................    #define __SPIFLASH_H    //prevent spiflash.h from being loaded/used 
....................    #define SPIFlashReadArray(dwAddress, pData, wLen)  ext_flash_read(dwAddress, pData, wLen) 
....................    #define SPIFlashInit()                             init_ext_flash() 
....................    #define SPIFlashBeginWrite(addy)                   ext_flash_startWrite(addy) 
....................    #define SPIFlashWrite(d)                           ext_flash_continuousWrite(d) 
....................    #define SPIFlashStopWrite()                        ext_flash_flushWrites() 
....................    #define SPIFlashWriteBytes(dwAddress, pData, wLen) ext_flash_writeBytes(dwAddress, pData, wLen) 
....................     
....................    // if you want TCP/IP settings saved to internal EEPROM, then comment 
....................    // out the next few lines: 
....................    #define EEInit SPIFlashInit 
....................    #define EEReadBytes(dst, src, len)  SPIFlashReadArray(src, dst, len) 
....................    #define EEWriteBytes(dst, src, len) SPIFlashWriteBytes(dst, src, len) 
....................     
.................... #elif STACK_USE_PIC24FJGA010_ENC28 
....................    #include <24FJ128GA010.h> 
....................    //#device ICD=TRUE 
....................    #device ADC=8 
....................    #include "tcpip\p24fxxxx.h"   //C30 to CCS compatability layer 
....................    #use delay(clock=32MHz) 
....................    #fuses PR_PLL, XT                 //cw2 
....................    #fuses NOWDT, NOJTAG             //cw1 
....................     
....................    //pin_f13 = rts 
....................    //pin_f12 = cts 
....................    #use rs232(baud=9600, uart2, stream=STREAM_UI, errors) 
....................     
....................    #define BUTTON1_PRESSED()  (!input(PIN_D6))  //marked S3 on PCB 
....................    #define USER_LED1    PIN_A0   //marked D3 on PCB 
....................    #define USER_LED2    PIN_A1   //marked D4 on PCB 
....................    #define USER_LED3    PIN_A2   //marked D5 on PCB 
....................    #define LED_ON       output_high 
....................    #define LED_OFF      output_low 
....................    #define STANDARD_ADC_STRING  "AN5" 
....................    #define STANDARD_ADC_CHANNEL 5   //rb5/an5 
....................         
....................    #define LCD_ENABLE_PIN  PIN_D4 
....................    #define LCD_RS_PIN      PIN_B15 
....................    #define LCD_RW_PIN      PIN_D5 
....................    #define LCD_DATA4       PIN_E4 
....................    #define LCD_DATA5       PIN_E5 
....................    #define LCD_DATA6       PIN_E6 
....................    #define LCD_DATA7       PIN_E7 
....................     
....................    #ifndef STACK_USE_PICDEM_LCD 
....................       #define STACK_USE_PICDEM_LCD 1 
....................    #endif 
....................    #if STACK_USE_PICDEM_LCD 
....................       #include "lcd.c"    
....................    #endif 
....................    
....................    #define ENC_CS_IO       LATDbits.LATD14 
....................    #define ENC_CS_TRIS     TRISDbits.TRISD14 
....................    #define ENC_RST_IO      LATDbits.LATD15 
....................    #define ENC_RST_TRIS    TRISDbits.TRISD15 
....................    #define ENC_SPI_IF         IFS0bits.SPI1IF 
....................    #define ENC_SPICON1        SPI1CON1 
....................    #define ENC_SPICON2        SPI1CON2 
....................    #define ENC_SPISTAT        SPI1STAT 
....................    #define ENC_SSPBUF         SPI1BUF 
....................    #define ENC_SPICON1bits    SPI1CON1bits 
....................    #define ENC_SPICON2bits    SPI1CON2bits 
....................    #define ENC_SPISTATbits    SPI1STATbits 
....................    //!INT pin is RE9/INT2 
....................  
....................    void init_user_io(void)  
....................    { 
....................       setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_2); 
....................       setup_adc_ports(sAN5); 
....................       set_adc_channel(STANDARD_ADC_CHANNEL); 
....................        
....................       output_drive(USER_LED1); 
....................       output_drive(USER_LED2); 
....................       output_drive(USER_LED3); 
....................       LED_OFF(USER_LED1); 
....................       LED_OFF(USER_LED2); 
....................       LED_OFF(USER_LED3); 
....................    } 
....................    // 25LC256 
.................... //#define debug_ee  printf 
.................... //void debug_ee_putc(char c) {putc(c);} 
....................    #define EEPROM_SELECT PIN_D12 
....................    #define EEPROM_CLK    PIN_G6 
....................    #define EEPROM_DI     PIN_G7 
....................    #define EEPROM_DO     PIN_G8 
....................    #include "25lc256.c" 
....................     
....................    #define __SPIFLASH_H    //prevent spiflash.h from being loaded/used 
....................    #define SPIFlashReadArray(dwAddress, pData, wLen)  read_ext_eeprom_bytes(pData, dwAddress, wLen) 
....................    #define SPIFlashInit()                             init_ext_eeprom() 
....................    EEPROM_ADDRESS g_SpiFlashCurrWrite; 
....................    #define SPIFlashBeginWrite(addy)                   g_SpiFlashCurrWrite=addy 
....................    #define SPIFlashWrite(d)                           write_ext_eeprom(g_SpiFlashCurrWrite++, d) 
....................    #define SPIFlashStopWrite() 
....................    #define SPIFlashWriteBytes(dwAddress, pData, wLen) write_ext_eeprom_bytes(dwAddress, pData, wLen) 
....................     
....................    // if you want TCP/IP settings saved to internal EEPROM, then comment 
....................    // out the next few lines: 
....................    #define EEInit SPIFlashInit 
....................    #define EEReadBytes(dst, src, len)  SPIFlashReadArray(src, dst, len) 
....................    #define EEWriteBytes(dst, src, len) SPIFlashWriteBytes(dst, src, len); SPIFlashStopWrite() 
....................     
....................     
.................... #elif STACK_USE_PIC24FJGA110_ENC28 
....................    #include <24FJ256GA110.h> 
....................    //#device ICD=TRUE 
....................    #device ADC=8 
....................    #include "tcpip\p24fxxxx.h" 
....................    #use delay(clock=32MHz) 
....................    #fuses PR_PLL, XT                 //cw2 
....................    #fuses NOWDT, NOJTAG, ICSP2      //cw1 
....................     
....................    #pin_select U2TX=PIN_F5 
....................    #pin_select U2RX=PIN_F4 
....................    //pin_f13 = rts 
....................    //pin_f12 = cts 
....................    #use rs232(baud=9600, uart2, stream=STREAM_UI, errors) 
....................     
....................    #define BUTTON1_PRESSED()  (!input(PIN_D6))  //marked S3 on PCB 
....................    #define USER_LED1    PIN_A0   //marked D3 on PCB 
....................    #define USER_LED2    PIN_A1   //marked D4 on PCB 
....................    #define USER_LED3    PIN_A2   //marked D5 on PCB 
....................    #define LED_ON       output_high 
....................    #define LED_OFF      output_low 
....................    #define STANDARD_ADC_STRING  "AN5" 
....................    #define STANDARD_ADC_CHANNEL 5   //rb5/an5 
....................         
....................    #define LCD_ENABLE_PIN  PIN_D4 
....................    #define LCD_RS_PIN      PIN_B15 
....................    #define LCD_RW_PIN      PIN_D5 
....................    #define LCD_DATA4       PIN_E4 
....................    #define LCD_DATA5       PIN_E5 
....................    #define LCD_DATA6       PIN_E6 
....................    #define LCD_DATA7       PIN_E7 
....................     
....................    #ifndef STACK_USE_PICDEM_LCD 
....................       #define STACK_USE_PICDEM_LCD 1 
....................    #endif 
....................    #if STACK_USE_PICDEM_LCD 
....................       #include "lcd.c"    
....................    #endif 
....................    
....................    // When using 24FJ256GA110, due to an errata with SPI1 we must use SPI2. 
....................    // so when inserting the ENC28J60 PICTail into the Explorer 16, insert 
....................    // it into the second slot.  The definitions below are for the second 
....................    // slot. 
....................    //ENC28J60 INT is mapped to RA15, but not used by software 
....................    #pin_select SDO2=PIN_G8 
....................    #pin_select SDI2=PIN_G7 
....................    #pin_select SCK2OUT=PIN_G6 
....................    #define ENC_CS_IO       LATFbits.LATF12    
....................    #define ENC_CS_TRIS     TRISFbits.TRISF12 
....................    #define ENC_RST_IO      LATFbits.LATF13 
....................    #define ENC_RST_TRIS    TRISFbits.TRISF13 
....................    #define ENC_SPI_IF         IFS2bits.SPI2IF 
....................    #define ENC_SPICON1        SPI2CON1 
....................    #define ENC_SPICON2        SPI2CON2 
....................    #define ENC_SPISTAT        SPI2STAT 
....................    #define ENC_SSPBUF         SPI2BUF 
....................    #define ENC_SPICON1bits    SPI2CON1bits 
....................    #define ENC_SPICON2bits    SPI2CON2bits 
....................    #define ENC_SPISTATbits    SPI2STATbits 
....................  
....................    void init_user_io(void)  
....................    { 
....................       setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_2); 
....................       setup_adc_ports(sAN5); 
....................       set_adc_channel(STANDARD_ADC_CHANNEL); 
....................        
....................       output_drive(USER_LED1); 
....................       output_drive(USER_LED2); 
....................       output_drive(USER_LED3); 
....................       LED_OFF(USER_LED1); 
....................       LED_OFF(USER_LED2); 
....................       LED_OFF(USER_LED3); 
....................    } 
....................  
.................... #elif STACK_USE_CCS_PICEEC 
....................    #include <18F67J60.h> 
....................    #include "tcpip\p18cxxx.h" 
....................    #reserve 0xE80:0xEFF   //SFR 
....................    #reserve 0xF00:0xFFF   //SFR 
....................    #use delay(clock=41666667) 
....................    #fuses NOWDT, NODEBUG, H4_SW, NOIESO, NOFCMEN, PRIMARY, ETHLED 
....................     
....................    #use rs232(baud=9600, uart1, stream=STREAM_UI, errors) 
....................        
....................    //#include "tcpip/elcd.c" //removed, use standard lcd.c that has #define'able pins 
....................    #define BUTTON1_PRESSED()  (!input(PIN_A4)) 
....................    #define USER_LED1    PIN_B3 
....................    #define USER_LED2    PIN_B4 
....................    #define USER_LED3    PIN_B5 
....................    #define LED_ON       output_low 
....................    #define LED_OFF      output_high 
....................    #define STANDARD_ADC_STRING  "AN2" 
....................    #define STANDARD_ADC_CHANNEL 2 
....................  
....................    #define LCD_ENABLE_PIN  PIN_F3 
....................    #define LCD_RS_PIN      PIN_F1 
....................    #define LCD_RW_PIN      PIN_F2 
....................    #define LCD_DATA4       PIN_F4 
....................    #define LCD_DATA5       PIN_F5 
....................    #define LCD_DATA6       PIN_F6 
....................    #define LCD_DATA7       PIN_F7 
....................     
....................    #ifndef STACK_USE_PICDEM_LCD 
....................       #define STACK_USE_PICDEM_LCD 1 
....................    #endif 
....................    #if STACK_USE_PICDEM_LCD 
....................       #include "lcd.c" 
....................    #endif 
....................     
....................    void init_user_io(void)  
....................    { 
....................       setup_oscillator(OSC_PLL_5_DIV_3 | OSC_NORMAL); 
....................       restart_wdt(); 
....................       delay_ms(144); 
....................       restart_wdt(); 
....................        
....................       setup_adc(ADC_CLOCK_INTERNAL); 
....................       setup_adc_ports(AN0_TO_AN2); 
....................       set_adc_channel(STANDARD_ADC_CHANNEL); 
....................        
....................       setup_comparator(NC_NC_NC_NC); 
....................        
....................       output_drive(PIN_A1);   //ethernet led 
....................       output_drive(PIN_A0);   //ethernet led 
....................        
....................       output_drive(USER_LED1); 
....................       output_drive(USER_LED2); 
....................       output_drive(USER_LED3); 
....................       LED_OFF(USER_LED1); 
....................       LED_OFF(USER_LED2); 
....................       LED_OFF(USER_LED3); 
....................    } 
....................     
....................    #define EEPROM_SELECT   PIN_C1  //o 
....................    #define EEPROM_DI       PIN_C5  //o 
....................    #define EEPROM_DO       PIN_C4  //i 
....................    #define EEPROM_CLK      PIN_C3  //o 
....................    #define EEPROM_USE_SPI  1 
....................    #include "AT25256.C" 
....................  
....................    #define __SPIFLASH_H    //prevent spiflash.h from being loaded/used 
....................    #define SPIFlashReadArray(dwAddress, pData, wLen)  read_ext_eeprom_buf(dwAddress, pData, wLen) 
....................    #define SPIFlashInit()                             init_ext_eeprom() 
....................    EEPROM_ADDRESS g_SpiFlashCurrWrite; 
....................    #define SPIFlashBeginWrite(addy)                   g_SpiFlashCurrWrite=addy 
....................    #define SPIFlashWrite(d)                           write_ext_eeprom(g_SpiFlashCurrWrite++, d) 
....................    #define SPIFlashStopWrite() 
....................    #define SPIFlashWriteBytes(dwAddress, pData, wLen) write_ext_eeprom_buf(dwAddress, pData, wLen) 
....................     
....................    // if you want TCP/IP settings saved to internal EEPROM, then comment 
....................    // out the next few lines: 
....................    #define EEInit SPIFlashInit 
....................    #define EEReadBytes(dst, src, len)  SPIFlashReadArray(src, dst, len) 
....................    #define EEWriteBytes(dst, src, len) SPIFlashWriteBytes(dst, src, len); SPIFlashStopWrite() 
....................  
.................... #elif STACK_USE_CCS_PICENS 
....................    #include <18F4620.h> 
.................... //////////// Standard Header file for the PIC18F4620 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4620 
*
000B6:  DATA 0C,57
000B8:  DATA 65,62
000BA:  DATA 73,65
000BC:  DATA 72,76
000BE:  DATA 65,72
000C0:  DATA 0A,0D
000C2:  DATA 4E,6F
000C4:  DATA 20,4D
000C6:  DATA 41,43
000C8:  DATA 20,4C
000CA:  DATA 69,6E
000CC:  DATA 6B,00
000CE:  DATA 0C,57
000D0:  DATA 65,62
000D2:  DATA 73,65
000D4:  DATA 72,76
000D6:  DATA 65,72
000D8:  DATA 0A,0D
000DA:  DATA 44,48
000DC:  DATA 43,50
000DE:  DATA 20,4E
000E0:  DATA 6F,74
000E2:  DATA 20,42
000E4:  DATA 6F,75
000E6:  DATA 6E,64
000E8:  DATA 00,00
000EA:  DATA 0C,57
000EC:  DATA 65,62
000EE:  DATA 73,65
000F0:  DATA 72,76
000F2:  DATA 65,72
000F4:  DATA 20,49
000F6:  DATA 64,6C
000F8:  DATA 65,0A
000FA:  DATA 0D,25
000FC:  DATA 75,2E
000FE:  DATA 25,75
00100:  DATA 2E,25
00102:  DATA 75,2E
00104:  DATA 25,75
00106:  DATA 00,00
00108:  DATA 0C,43
0010A:  DATA 6F,6E
0010C:  DATA 6E,65
0010E:  DATA 63,74
00110:  DATA 65,64
00112:  DATA 20,74
00114:  DATA 6F,0A
00116:  DATA 0D,25
00118:  DATA 75,2E
0011A:  DATA 25,75
0011C:  DATA 2E,25
0011E:  DATA 75,2E
00120:  DATA 25,75
00122:  DATA 00,00
00124:  DATA 0D,0A
00126:  DATA 48,54
00128:  DATA 54,50
0012A:  DATA 3A,20
0012C:  DATA 4C,69
0012E:  DATA 73,74
00130:  DATA 65,6E
00132:  DATA 69,6E
00134:  DATA 67,00
00136:  DATA 0D,0A
00138:  DATA 48,54
0013A:  DATA 54,50
0013C:  DATA 3A,20
0013E:  DATA 43,6F
00140:  DATA 6E,6E
00142:  DATA 65,63
00144:  DATA 74,65
00146:  DATA 64,00
00148:  DATA 0D,0A
0014A:  DATA 48,54
0014C:  DATA 54,50
0014E:  DATA 3A,20
00150:  DATA 47,6F
00152:  DATA 74,20
00154:  DATA 50,61
00156:  DATA 67,65
00158:  DATA 20,52
0015A:  DATA 65,71
0015C:  DATA 75,65
0015E:  DATA 73,74
00160:  DATA 00,00
00162:  DATA 0D,0A
00164:  DATA 48,54
00166:  DATA 54,50
00168:  DATA 3A,20
0016A:  DATA 50,75
0016C:  DATA 74,74
0016E:  DATA 69,6E
00170:  DATA 67,20
00172:  DATA 50,61
00174:  DATA 67,65
00176:  DATA 20,52
00178:  DATA 65,73
0017A:  DATA 70,6F
0017C:  DATA 6E,73
0017E:  DATA 65,00
00180:  DATA 3C,48
00182:  DATA 54,4D
00184:  DATA 4C,3E
00186:  DATA 3C,48
00188:  DATA 45,41
0018A:  DATA 44,3E
0018C:  DATA 3C,54
0018E:  DATA 49,54
00190:  DATA 4C,45
00192:  DATA 3E,50
00194:  DATA 49,43
00196:  DATA 4E,45
00198:  DATA 54,3C
0019A:  DATA 2F,54
0019C:  DATA 49,54
0019E:  DATA 4C,45
001A0:  DATA 3E,3C
001A2:  DATA 2F,48
001A4:  DATA 45,41
001A6:  DATA 44,3E
001A8:  DATA 3C,42
001AA:  DATA 4F,44
001AC:  DATA 59,3E
001AE:  DATA 3C,48
001B0:  DATA 31,3E
001B2:  DATA 48,45
001B4:  DATA 4C,4C
001B6:  DATA 4F,3C
001B8:  DATA 2F,48
001BA:  DATA 31,3E
001BC:  DATA 00,00
001BE:  DATA 3C,50
001C0:  DATA 3E,25
001C2:  DATA 73,20
001C4:  DATA 3D,20
001C6:  DATA 30,78
001C8:  DATA 25,58
001CA:  DATA 00,00
001CC:  DATA 41,4E
001CE:  DATA 30,00
001D0:  DATA 3C,2F
001D2:  DATA 42,4F
001D4:  DATA 44,59
001D6:  DATA 3E,3C
001D8:  DATA 2F,48
001DA:  DATA 54,4D
001DC:  DATA 4C,3E
001DE:  DATA 00,00
001E0:  DATA 48,54
001E2:  DATA 54,50
001E4:  DATA 2F,31
001E6:  DATA 2E,31
001E8:  DATA 20,32
001EA:  DATA 30,30
001EC:  DATA 20,4F
001EE:  DATA 4B,0D
001F0:  DATA 0A,00
001F2:  DATA 43,6F
001F4:  DATA 6E,74
001F6:  DATA 65,6E
001F8:  DATA 74,2D
001FA:  DATA 54,79
001FC:  DATA 70,65
001FE:  DATA 3A,20
00200:  DATA 74,65
00202:  DATA 78,74
00204:  DATA 2F,68
00206:  DATA 74,6D
00208:  DATA 6C,0D
0020A:  DATA 0A,00
0020C:  DATA 43,6F
0020E:  DATA 6E,74
00210:  DATA 65,6E
00212:  DATA 74,2D
00214:  DATA 4C,65
00216:  DATA 6E,67
00218:  DATA 74,68
0021A:  DATA 3A,20
0021C:  DATA 25,75
0021E:  DATA 0D,0A
00220:  DATA 00,00
00222:  DATA 0D,0A
00224:  DATA 48,54
00226:  DATA 54,50
00228:  DATA 3A,20
0022A:  DATA 46,6C
0022C:  DATA 75,73
0022E:  DATA 68,69
00230:  DATA 6E,67
00232:  DATA 2E,2E
00234:  DATA 2E,00
00236:  DATA 0D,0A
00238:  DATA 48,54
0023A:  DATA 54,50
0023C:  DATA 3A,20
0023E:  DATA 46,6C
00240:  DATA 75,73
00242:  DATA 68,65
00244:  DATA 64,21
00246:  DATA 00,00
00248:  DATA 0D,0A
0024A:  DATA 48,54
0024C:  DATA 54,50
0024E:  DATA 3A,20
00250:  DATA 46,6F
00252:  DATA 72,63
00254:  DATA 65,20
00256:  DATA 44,69
00258:  DATA 73,63
0025A:  DATA 6F,6E
0025C:  DATA 6E,65
0025E:  DATA 63,74
00260:  DATA 00,00
00262:  DATA 0D,0A
00264:  DATA 0A,43
00266:  DATA 43,53
00268:  DATA 20,54
0026A:  DATA 43,50
0026C:  DATA 2F,49
0026E:  DATA 50,20
00270:  DATA 54,55
00272:  DATA 54,4F
00274:  DATA 52,49
00276:  DATA 41,4C
00278:  DATA 2C,20
0027A:  DATA 45,58
0027C:  DATA 41,4D
0027E:  DATA 50,4C
00280:  DATA 45,20
00282:  DATA 31,34
00284:  DATA 20,28
00286:  DATA 48,54
00288:  DATA 54,50
0028A:  DATA 20,53
0028C:  DATA 45,52
0028E:  DATA 56,45
00290:  DATA 52,29
00292:  DATA 0D,0A
00294:  DATA 00,00
00296:  DATA 0C,49
00298:  DATA 6E,69
0029A:  DATA 74,20
0029C:  DATA 53,74
0029E:  DATA 61,63
002A0:  DATA 6B,2E
002A2:  DATA 2E,2E
002A4:  DATA 00,00
*
0035C:  TBLRD*+
0035E:  MOVF   FF5,F
00360:  BZ    037C
00362:  MOVFF  FF6,268
00366:  MOVFF  FF7,269
0036A:  MOVF   FF5,W
0036C:  BTFSS  F9E.4
0036E:  BRA    036C
00370:  MOVWF  FAD
00372:  MOVFF  268,FF6
00376:  MOVFF  269,FF7
0037A:  BRA    035C
0037C:  RETURN 0
*
00678:  TBLRD*+
0067A:  MOVF   FF5,F
0067C:  BZ    0696
0067E:  MOVFF  FF6,16C
00682:  MOVFF  FF7,16D
00686:  MOVFF  FF5,16F
0068A:  RCALL  05C8
0068C:  MOVFF  16C,FF6
00690:  MOVFF  16D,FF7
00694:  BRA    0678
00696:  RETURN 0
*
00CFE:  TSTFSZ 01
00D00:  BRA    0D08
00D02:  TSTFSZ 02
00D04:  BRA    0D0A
00D06:  BRA    0D16
00D08:  INCF   02,F
00D0A:  MOVFF  00,FEE
00D0E:  DECFSZ 01,F
00D10:  BRA    0D0A
00D12:  DECFSZ 02,F
00D14:  BRA    0D0A
00D16:  GOTO   14F4 (RETURN)
*
01764:  TBLRD*+
01766:  MOVFF  FF6,16D
0176A:  MOVFF  FF7,16E
0176E:  MOVFF  FF5,16F
01772:  CALL   05C8
01776:  MOVFF  16D,FF6
0177A:  MOVFF  16E,FF7
0177E:  MOVLB  1
01780:  DECFSZ x6C,F
01782:  BRA    1786
01784:  BRA    178A
01786:  MOVLB  0
01788:  BRA    1764
0178A:  MOVLB  0
0178C:  RETURN 0
0178E:  MOVLB  2
01790:  MOVF   x6C,W
01792:  CLRF   01
01794:  SUBWF  x6B,W
01796:  BC    179E
01798:  MOVFF  26B,00
0179C:  BRA    17B6
0179E:  CLRF   00
017A0:  MOVLW  08
017A2:  MOVWF  x6D
017A4:  RLCF   x6B,F
017A6:  RLCF   00,F
017A8:  MOVF   x6C,W
017AA:  SUBWF  00,W
017AC:  BTFSC  FD8.0
017AE:  MOVWF  00
017B0:  RLCF   01,F
017B2:  DECFSZ x6D,F
017B4:  BRA    17A4
017B6:  MOVLB  0
017B8:  RETURN 0
017BA:  MOVF   01,W
017BC:  MOVFF  16C,26B
017C0:  MOVLW  64
017C2:  MOVLB  2
017C4:  MOVWF  x6C
017C6:  MOVLB  0
017C8:  RCALL  178E
017CA:  MOVFF  00,16C
017CE:  MOVF   01,W
017D0:  MOVLW  30
017D2:  BNZ   17E4
017D4:  MOVLB  1
017D6:  BTFSS  x6D.1
017D8:  BRA    17F8
017DA:  BTFSC  x6D.3
017DC:  BRA    17F8
017DE:  BTFSC  x6D.4
017E0:  MOVLW  20
017E2:  BRA    17EC
017E4:  MOVLB  1
017E6:  BCF    x6D.3
017E8:  BCF    x6D.4
017EA:  BSF    x6D.0
017EC:  ADDWF  01,F
017EE:  MOVFF  01,16F
017F2:  MOVLB  0
017F4:  CALL   05C8
017F8:  MOVFF  16C,26B
017FC:  MOVLW  0A
017FE:  MOVLB  2
01800:  MOVWF  x6C
01802:  MOVLB  0
01804:  RCALL  178E
01806:  MOVFF  00,16C
0180A:  MOVF   01,W
0180C:  MOVLW  30
0180E:  BNZ   1820
01810:  MOVLB  1
01812:  BTFSC  x6D.3
01814:  BRA    182C
01816:  BTFSS  x6D.0
01818:  BRA    182C
0181A:  BTFSC  x6D.4
0181C:  MOVLW  20
0181E:  MOVLB  0
01820:  ADDWF  01,F
01822:  MOVFF  01,16F
01826:  CALL   05C8
0182A:  MOVLB  1
0182C:  MOVLW  30
0182E:  ADDWF  x6C,F
01830:  MOVFF  16C,16F
01834:  MOVLB  0
01836:  CALL   05C8
0183A:  RETURN 0
*
019EC:  MOVFF  FF2,0D
019F0:  BCF    FF2.7
019F2:  ADDWF  FE8,W
019F4:  CLRF   FF7
019F6:  RLCF   FF7,F
019F8:  ADDLW  11
019FA:  MOVWF  FF6
019FC:  MOVLW  1A
019FE:  ADDWFC FF7,F
01A00:  TBLRD*-
01A02:  MOVF   FF5,W
01A04:  MOVWF  FFA
01A06:  TBLRD*
01A08:  MOVF   FF5,W
01A0A:  BTFSC  0D.7
01A0C:  BSF    FF2.7
01A0E:  MOVWF  FF9
01A10:  DATA 7C,18
01A12:  DATA 94,18
01A14:  DATA E4,19
01A16:  DATA A6,18
01A18:  DATA 1C,19
01A1A:  DATA C2,19
*
01AA0:  MOVLB  1
01AA2:  MOVF   xA9,W
01AA4:  MULWF  xAB
01AA6:  MOVFF  FF3,01
01AAA:  MOVFF  FF4,00
01AAE:  MULWF  xAC
01AB0:  MOVF   FF3,W
01AB2:  ADDWF  00,F
01AB4:  MOVF   xAA,W
01AB6:  MULWF  xAB
01AB8:  MOVF   FF3,W
01ABA:  ADDWFC 00,W
01ABC:  MOVWF  02
01ABE:  MOVLB  0
01AC0:  RETURN 0
*
05EBE:  MOVFF  162,FEA
05EC2:  MOVFF  161,FE9
05EC6:  MOVLB  2
05EC8:  MOVFF  26D,FEF
05ECC:  INCF   FE9,F
05ECE:  BTFSC  FD8.2
05ED0:  INCF   FEA,F
05ED2:  CLRF   FEF
05ED4:  MOVLB  1
05ED6:  INCF   x61,F
05ED8:  BTFSC  FD8.2
05EDA:  INCF   x62,F
05EDC:  MOVLB  0
05EDE:  RETURN 0
05EE0:  TBLRD*+
05EE2:  MOVF   FF5,F
05EE4:  BZ    5EFE
05EE6:  MOVFF  FF6,26A
05EEA:  MOVFF  FF7,26B
05EEE:  MOVFF  FF5,26D
05EF2:  RCALL  5EBE
05EF4:  MOVFF  26A,FF6
05EF8:  MOVFF  26B,FF7
05EFC:  BRA    5EE0
05EFE:  RETURN 0
*
05F3A:  TBLRD*+
05F3C:  MOVFF  FF6,26B
05F40:  MOVFF  FF7,26C
05F44:  MOVFF  FF5,26D
05F48:  RCALL  5EBE
05F4A:  MOVFF  26B,FF6
05F4E:  MOVFF  26C,FF7
05F52:  MOVLB  2
05F54:  DECFSZ x6A,F
05F56:  BRA    5F5A
05F58:  BRA    5F5E
05F5A:  MOVLB  0
05F5C:  BRA    5F3A
05F5E:  MOVLB  0
05F60:  RETURN 0
05F62:  MOVLB  2
05F64:  BTFSC  x6B.7
05F66:  BRA    5F8A
05F68:  MOVLW  0F
05F6A:  MOVWF  00
05F6C:  SWAPF  x6A,W
05F6E:  ANDWF  00,F
05F70:  MOVLW  0A
05F72:  SUBWF  00,W
05F74:  BC    5F7C
05F76:  MOVLW  30
05F78:  ADDWF  00,F
05F7A:  BRA    5F80
05F7C:  MOVF   x6B,W
05F7E:  ADDWF  00,F
05F80:  MOVFF  00,26D
05F84:  MOVLB  0
05F86:  RCALL  5EBE
05F88:  MOVLB  2
05F8A:  MOVLW  0F
05F8C:  ANDWF  x6A,F
05F8E:  MOVLW  0A
05F90:  SUBWF  x6A,W
05F92:  BC    5F98
05F94:  MOVLW  30
05F96:  BRA    5F9C
05F98:  BCF    x6B.7
05F9A:  MOVF   x6B,W
05F9C:  ADDWF  x6A,F
05F9E:  MOVFF  26A,26D
05FA2:  MOVLB  0
05FA4:  RCALL  5EBE
05FA6:  GOTO   6412 (RETURN)
*
06118:  TBLRD*+
0611A:  MOVF   FF5,F
0611C:  BZ    6136
0611E:  MOVFF  FF6,268
06122:  MOVFF  FF7,269
06126:  MOVFF  FF5,26C
0612A:  RCALL  610C
0612C:  MOVFF  268,FF6
06130:  MOVFF  269,FF7
06134:  BRA    6118
06136:  RETURN 0
06138:  TBLRD*+
0613A:  MOVFF  FF6,26A
0613E:  MOVFF  FF7,26B
06142:  MOVFF  FF5,26C
06146:  RCALL  610C
06148:  MOVFF  26A,FF6
0614C:  MOVFF  26B,FF7
06150:  MOVLB  2
06152:  DECFSZ x69,F
06154:  BRA    6158
06156:  BRA    615C
06158:  MOVLB  0
0615A:  BRA    6138
0615C:  MOVLB  0
0615E:  GOTO   647C (RETURN)
06162:  MOVF   01,W
06164:  MOVFF  269,26B
06168:  MOVLW  64
0616A:  MOVLB  2
0616C:  MOVWF  x6C
0616E:  MOVLB  0
06170:  CALL   178E
06174:  MOVFF  00,269
06178:  MOVF   01,W
0617A:  MOVLW  30
0617C:  BNZ   618E
0617E:  MOVLB  2
06180:  BTFSS  x6A.1
06182:  BRA    61A2
06184:  BTFSC  x6A.3
06186:  BRA    61A2
06188:  BTFSC  x6A.4
0618A:  MOVLW  20
0618C:  BRA    6196
0618E:  MOVLB  2
06190:  BCF    x6A.3
06192:  BCF    x6A.4
06194:  BSF    x6A.0
06196:  ADDWF  01,F
06198:  MOVFF  01,26C
0619C:  MOVLB  0
0619E:  RCALL  610C
061A0:  MOVLB  2
061A2:  MOVFF  269,26B
061A6:  MOVLW  0A
061A8:  MOVWF  x6C
061AA:  MOVLB  0
061AC:  CALL   178E
061B0:  MOVFF  00,269
061B4:  MOVF   01,W
061B6:  MOVLW  30
061B8:  BNZ   61CA
061BA:  MOVLB  2
061BC:  BTFSC  x6A.3
061BE:  BRA    61D4
061C0:  BTFSS  x6A.0
061C2:  BRA    61D4
061C4:  BTFSC  x6A.4
061C6:  MOVLW  20
061C8:  MOVLB  0
061CA:  ADDWF  01,F
061CC:  MOVFF  01,26C
061D0:  RCALL  610C
061D2:  MOVLB  2
061D4:  MOVLW  30
061D6:  ADDWF  x69,F
061D8:  MOVFF  269,26C
061DC:  MOVLB  0
061DE:  RCALL  610C
061E0:  GOTO   648A (RETURN)
061E4:  MOVF   FEF,F
061E6:  BZ    6206
061E8:  MOVFF  FEA,269
061EC:  MOVFF  FE9,268
061F0:  MOVFF  FEF,26C
061F4:  RCALL  610C
061F6:  MOVFF  269,FEA
061FA:  MOVFF  268,FE9
061FE:  INCF   FE9,F
06200:  BTFSC  FD8.2
06202:  INCF   FEA,F
06204:  BRA    61E4
06206:  GOTO   64BC (RETURN)
*
0651A:  MOVFF  FF2,0D
0651E:  BCF    FF2.7
06520:  ADDWF  FE8,W
06522:  CLRF   FF7
06524:  RLCF   FF7,F
06526:  ADDLW  3F
06528:  MOVWF  FF6
0652A:  MOVLW  65
0652C:  ADDWFC FF7,F
0652E:  TBLRD*-
06530:  MOVF   FF5,W
06532:  MOVWF  FFA
06534:  TBLRD*
06536:  MOVF   FF5,W
06538:  BTFSC  0D.7
0653A:  BSF    FF2.7
0653C:  MOVWF  FF9
0653E:  DATA 98,62
06540:  DATA EC,62
06542:  DATA 24,63
06544:  DATA 78,63
06546:  DATA E6,64
....................  
.................... #list 
....................  
....................    #include "tcpip\p18cxxx.h" 
.................... // CCS PCH C Compiler to Microchip C18 Compiler compatability layer. 
....................  
.................... #ifndef __P18CXXXX_H__ 
.................... #define __P18CXXXX_H__ 
....................  
.................... #ifndef __18CXX 
.................... #define __18CXX 
.................... #endif 
....................  
.................... //#zero_local_ram 
.................... #zero_ram 
....................  
....................  
.................... #device PASS_STRINGS=IN_RAM 
.................... #device CONST=READ_ONLY 
....................  
.................... #case 
.................... #type signed 
.................... #type short=16 int=16 long=32 
....................  
.................... #define _asm #asm 
.................... #define _endasm #endasm 
....................  
.................... /* usualy 
.................... #define GetSystemClock()      getenv("CLOCK") 
.................... #define GetInstructionClock()   (GetSystemClock()/4) 
.................... #define GetPeripheralClock()   (unsigned int32)GetInstructionClock() 
.................... */ 
....................  
.................... #if getenv("DEVICE") == "PIC18F97J60" 
....................  #define __18F97J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F96J65" 
....................  #define __18F96J65) 
.................... #elif getenv("DEVICE") == "PIC18F96J60" 
....................  #define __18F96J60 
.................... #elif getenv("DEVICE") == "PIC18F87J60" 
....................  #define __18F87J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J60" 
....................  #define __18F86J60 
.................... #elif getenv("DEVICE") == "PIC18F67J60" 
....................  #define __18F67J60 
....................  #include "PIC18F67J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F66J65" 
....................  #define __18F66J65 
.................... #elif getenv("DEVICE") == "PIC18F66J60" 
....................  #define __18F66J60 
.................... #elif getenv("DEVICE") == "PIC18F67K22" 
....................  #define __18F67K22 
....................  #include "PIC18F67K22_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F4620" 
....................  #define __18F4620 
....................  #include "PIC18F4620_registers.h" 
.................... #byte TOSU = 0xFFF 
....................  
.................... #byte TOSH = 0xFFE 
....................  
.................... #byte TOSL = 0xFFD 
....................  
.................... struct STKPTRBITS { 
....................    unsigned int STKPTR0:1; 
....................    unsigned int STKPTR1:1; 
....................    unsigned int STKPTR2:1; 
....................    unsigned int STKPTR3:1; 
....................    unsigned int STKPTR4:1; 
....................    unsigned int :1; 
....................    unsigned int STKUNF:1; 
....................    unsigned int STKFUL:1; 
.................... } STKPTRbits; 
.................... #byte STKPTRbits = 0xFFC 
.................... #byte STKPTR = 0xFFC 
....................  
.................... #byte PCLATU = 0xFFB 
....................  
.................... #byte PCLATH = 0xFFA 
....................  
.................... #byte PCL = 0xFF9 
....................  
.................... struct TBLPTRUBITS { 
....................    unsigned int TBLPTRU0:1; 
....................    unsigned int TBLPTRU1:1; 
....................    unsigned int TBLPTRU2:1; 
....................    unsigned int TBLPTRU3:1; 
....................    unsigned int TBLPTRU4:1; 
....................    unsigned int ACSS:1; 
.................... } TBLPTRUbits; 
.................... #byte TBLPTRUbits = 0xFF8 
.................... #byte TBLPTRU = 0xFF8 
....................  
.................... #byte TBLPTRH = 0xFF7 
....................  
.................... #byte TBLPTRL = 0xFF6 
....................  
.................... #byte TABLAT = 0xFF5 
....................  
.................... #byte PRODH = 0xFF4 
....................  
.................... #byte PRODL = 0xFF3 
....................  
.................... struct INTCONBITS { 
....................    unsigned int RBIF:1; 
....................    unsigned int INT0IF:1; 
....................    unsigned int TMR0IF:1; 
....................    unsigned int RBIE:1; 
....................    unsigned int INT0IE:1; 
....................    unsigned int TMR0IE:1; 
....................    unsigned int PEIE_GIEL:1; 
....................    unsigned int GIE_GIEH:1; 
.................... } INTCONbits; 
.................... #byte INTCONbits = 0xFF2 
.................... #byte INTCON = 0xFF2 
....................  
.................... struct INTCON2BITS { 
....................    unsigned int RBIP:1; 
....................    unsigned int :1; 
....................    unsigned int TMR0IP:1; 
....................    unsigned int :1; 
....................    unsigned int INTEDG4:1; 
....................    unsigned int INTEDG5:1; 
....................    unsigned int INTEDG6:1; 
....................    unsigned int RBPU:1; 
.................... } INTCON2bits; 
.................... #byte INTCON2bits = 0xFF1 
.................... #byte INTCON2 = 0xFF1 
....................  
.................... struct INTCON3BITS { 
....................    unsigned int INT1IF:1; 
....................    unsigned int INT2IF:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IE:1; 
....................    unsigned int INT2IE:1; 
....................    unsigned int :1; 
....................    unsigned int INT1IP:1; 
....................    unsigned int INT2IP:1; 
.................... } INTCON3bits; 
.................... #byte INTCON3bits = 0xFF0 
.................... #byte INTCON3 = 0xFF0 
....................  
.................... #byte INDF0 = 0xFEF 
....................  
.................... #byte POSTINC0 = 0xFEE 
....................  
.................... #byte POSTDEC0 = 0xFED 
....................  
.................... #byte PREINC0 = 0xFEC 
....................  
.................... #byte PLUSW0 = 0xFEB 
....................  
.................... #byte FSR0H = 0xFEA 
....................  
.................... #byte FSR0L = 0xFE9 
....................  
.................... #byte WREG = 0xFE8 
....................  
.................... #byte INDF1 = 0xFE7 
....................  
.................... #byte POSTINC1 = 0xFE6 
....................  
.................... #byte POSTDEC1 = 0xFE5 
....................  
.................... #byte PREINC1 = 0xFE4 
....................  
.................... #byte PLUSW1 = 0xFE3 
....................  
.................... #byte FSR1H = 0xFE2 
....................  
.................... #byte FSR1L = 0xFE1 
....................  
.................... #byte BSR = 0xFE0 
....................  
.................... #byte INDF2 = 0xFDF 
....................  
.................... #byte POSTINC2 = 0xFDE 
....................  
.................... #byte POSTDEC2 = 0xFDD 
....................  
.................... #byte PREINC2 = 0xFDC 
....................  
.................... #byte PLUSW2 = 0xFDB 
....................  
.................... #byte FSR2H = 0xFDA 
....................  
.................... #byte FSR2L = 0xFD9 
....................  
.................... struct STATUSBITS { 
....................    unsigned int C:1; 
....................    unsigned int DC:1; 
....................    unsigned int Z:1; 
....................    unsigned int OV:1; 
....................    unsigned int N:1; 
.................... } STATUSbits; 
.................... #byte STATUSbits = 0xFD8 
.................... #byte STATUS = 0xFD8 
....................  
.................... #byte TMR0H = 0xFD7 
....................  
.................... #byte TMR0L = 0xFD6 
....................  
.................... struct T0CONBITS { 
....................    unsigned int T0PS0:1; 
....................    unsigned int T0PS1:1; 
....................    unsigned int T0PS2:1; 
....................    unsigned int PSA:1; 
....................    unsigned int T0SE:1; 
....................    unsigned int T0CS:1; 
....................    unsigned int T08BIT:1; 
....................    unsigned int TMR0ON:1; 
.................... } T0CONbits; 
.................... #byte T0CONbits = 0xFD5 
.................... #byte T0CON = 0xFD5 
....................  
.................... struct OSCCONBITS { 
....................    unsigned int SCS0:1; 
....................    unsigned int SCS1:1; 
....................    unsigned int IOFS:1; 
....................    unsigned int OSTS:1; 
....................    unsigned int IRCF4:1; 
....................    unsigned int IRCF5:1; 
....................    unsigned int IRCF6:1; 
....................    unsigned int IDLEN:1; 
.................... } OSCCONbits; 
.................... #byte OSCCONbits = 0xFD3 
.................... #byte OSCCON = 0xFD3 
....................  
.................... struct HLVDCONBITS { 
....................    unsigned int HLVDL0:1; 
....................    unsigned int HLVDL1:1; 
....................    unsigned int HLVDL2:1; 
....................    unsigned int HLVDL3:1; 
....................    unsigned int HLVDEN:1; 
....................    unsigned int IVRST:1; 
....................    unsigned int :1; 
....................    unsigned int VDIRMAG:1; 
.................... } HLVDCONbits; 
.................... #byte HLVDCONbits = 0xFD2 
.................... #byte HLVDCON = 0xFD2 
....................  
.................... struct WDTCONBITS { 
....................    unsigned int SWDTEN:1; 
.................... } WDTCONbits; 
.................... #byte WDTCONbits = 0xFD1 
.................... #byte WDTCON = 0xFD1 
....................  
.................... struct RCONBITS { 
....................    unsigned int BOR:1; 
....................    unsigned int POR:1; 
....................    unsigned int PD:1; 
....................    unsigned int TO:1; 
....................    unsigned int RI:1; 
....................    unsigned int :1; 
....................    unsigned int SBOREN:1; 
....................    unsigned int IPEN:1; 
.................... } RCONbits; 
.................... #byte RCONbits = 0xFD0 
.................... #byte RCON = 0xFD0 
....................  
.................... #byte TMR1H = 0xFCF 
....................  
.................... #byte TMR1L = 0xFCE 
....................  
.................... struct T1CONBITS { 
....................    unsigned int TMR1ON:1; 
....................    unsigned int TMR1CS:1; 
....................    unsigned int T1SYNC:1; 
....................    unsigned int T1OSCEN:1; 
....................    unsigned int T1CKPS4:1; 
....................    unsigned int T1CKPS5:1; 
....................    unsigned int T1RUN:1; 
....................    unsigned int RD16:1; 
.................... } T1CONbits; 
.................... #byte T1CONbits = 0xFCD 
.................... #byte T1CON = 0xFCD 
....................  
.................... #byte TMR2 = 0xFCC 
....................  
.................... #byte PR2 = 0xFCB 
....................  
.................... struct T2CONBITS { 
....................    unsigned int T2CKPS0:1; 
....................    unsigned int T2CKPS1:1; 
....................    unsigned int TMR2ON:1; 
....................    unsigned int TOUTPS:4; 
.................... } T2CONbits; 
.................... #byte T2CONbits = 0xFCA 
.................... #byte T2CON = 0xFCA 
....................  
.................... #byte SSPBUF = 0xFC9 
....................  
.................... #byte SSPADD = 0xFC8 
....................  
.................... struct SSPSTATBITS { 
....................    unsigned int BF:1; 
....................    unsigned int UA:1; 
....................    unsigned int R:1; 
....................    unsigned int S:1; 
....................    unsigned int P:1; 
....................    unsigned int D:1; 
....................    unsigned int CKE:1; 
....................    unsigned int SMP:1; 
.................... } SSPSTATbits; 
.................... #byte SSPSTATbits = 0xFC7 
.................... #byte SSPSTAT = 0xFC7 
....................  
.................... struct SSPCON1BITS { 
....................    unsigned int SSPM0:1; 
....................    unsigned int SSPM1:1; 
....................    unsigned int SSPM2:1; 
....................    unsigned int SSPM3:1; 
....................    unsigned int CKP:1; 
....................    unsigned int SSPEN:1; 
....................    unsigned int SSPOV:1; 
....................    unsigned int WCOL:1; 
.................... } SSPCON1bits; 
.................... #byte SSPCON1bits = 0xFC6 
.................... #byte SSPCON1 = 0xFC6 
....................  
.................... struct SSPCON2BITS { 
....................    unsigned int SEN:1; 
....................    unsigned int RSEN:1; 
....................    unsigned int PEN:1; 
....................    unsigned int RCEN:1; 
....................    unsigned int ACKEN:1; 
....................    unsigned int ACKDT:1; 
....................    unsigned int ACKSTAT:1; 
....................    unsigned int GCEN:1; 
.................... } SSPCON2bits; 
.................... #byte SSPCON2bits = 0xFC5 
.................... #byte SSPCON2 = 0xFC5 
....................  
.................... #byte ADRESH = 0xFC4 
....................  
.................... #byte ADRESL = 0xFC3 
....................  
.................... struct ADCON0BITS { 
....................    unsigned int ADON:1; 
....................    unsigned int GO:1; 
....................    unsigned int CHS:4; 
.................... } ADCON0bits; 
.................... #byte ADCON0bits = 0xFC2 
.................... #byte ADCON0 = 0xFC2 
....................  
.................... struct ADCON1BITS { 
....................    unsigned int PCFG0:1; 
....................    unsigned int PCFG1:1; 
....................    unsigned int PCFG2:1; 
....................    unsigned int PCFG3:1; 
....................    unsigned int VCFG4:1; 
....................    unsigned int VCFG1:1; 
.................... } ADCON1bits; 
.................... #byte ADCON1bits = 0xFC1 
.................... #byte ADCON1 = 0xFC1 
....................  
.................... struct ADCON2BITS { 
....................    unsigned int ADCS0:1; 
....................    unsigned int ADCS1:1; 
....................    unsigned int ADCS2:1; 
....................    unsigned int ACQT3:1; 
....................    unsigned int ACQT4:1; 
....................    unsigned int ACQT2:1; 
....................    unsigned int :1; 
....................    unsigned int ADFM:1; 
.................... } ADCON2bits; 
.................... #byte ADCON2bits = 0xFC0 
.................... #byte ADCON2 = 0xFC0 
....................  
.................... #byte CCPR1H = 0xFBF 
....................  
.................... #byte CCPR1L = 0xFBE 
....................  
.................... struct CCP1CONBITS { 
....................    unsigned int CCP1M0:1; 
....................    unsigned int CCP1M1:1; 
....................    unsigned int CCP1M2:1; 
....................    unsigned int CCP1M3:1; 
....................    unsigned int DC1B4:1; 
....................    unsigned int DC1B5:1; 
....................    unsigned int P1M6:1; 
....................    unsigned int P1M1:1; 
.................... } CCP1CONbits; 
.................... #byte CCP1CONbits = 0xFBD 
.................... #byte CCP1CON = 0xFBD 
....................  
.................... #byte CCPR2H = 0xFBC 
....................  
.................... #byte CCPR2L = 0xFBB 
....................  
.................... struct CCP2CONBITS { 
....................    unsigned int CCP2M0:1; 
....................    unsigned int CCP2M1:1; 
....................    unsigned int CCP2M2:1; 
....................    unsigned int CCP2M3:1; 
....................    unsigned int DC2B4:1; 
....................    unsigned int DC2B1:1; 
.................... } CCP2CONbits; 
.................... #byte CCP2CONbits = 0xFBA 
.................... #byte CCP2CON = 0xFBA 
....................  
.................... struct BAUDCONBITS { 
....................    unsigned int ABDEN:1; 
....................    unsigned int WUE:1; 
....................    unsigned int :1; 
....................    unsigned int BRG1:1; 
....................    unsigned int TXCKP:1; 
....................    unsigned int RXDTP:1; 
....................    unsigned int RCIDL:1; 
....................    unsigned int ABDOVF:1; 
.................... } BAUDCONbits; 
.................... #byte BAUDCONbits = 0xFB8 
.................... #byte BAUDCON = 0xFB8 
....................  
.................... struct PWM1CONBITS { 
....................    unsigned int PDC0:1; 
....................    unsigned int PDC1:1; 
....................    unsigned int PDC2:1; 
....................    unsigned int PDC3:1; 
....................    unsigned int PDC4:1; 
....................    unsigned int PDC5:1; 
....................    unsigned int PDC6:1; 
....................    unsigned int PRSEN:1; 
.................... } PWM1CONbits; 
.................... #byte PWM1CONbits = 0xFB7 
.................... #byte PWM1CON = 0xFB7 
....................  
.................... struct ECCP1ASBITS { 
....................    unsigned int PSSBD0:1; 
....................    unsigned int PSSBD1:1; 
....................    unsigned int PSSAC2:1; 
....................    unsigned int PSSAC3:1; 
....................    unsigned int ECCPAS4:1; 
....................    unsigned int ECCPAS5:1; 
....................    unsigned int ECCPAS6:1; 
....................    unsigned int ECCPASE:1; 
.................... } ECCP1ASbits; 
.................... #byte ECCP1ASbits = 0xFB6 
.................... #byte ECCP1AS = 0xFB6 
....................  
.................... struct CVRCONBITS { 
....................    unsigned int CVR0:1; 
....................    unsigned int CVR1:1; 
....................    unsigned int CVR2:1; 
....................    unsigned int CVR3:1; 
....................    unsigned int CVRSS:1; 
....................    unsigned int CVRR:1; 
....................    unsigned int CVROE:1; 
....................    unsigned int CVREN:1; 
.................... } CVRCONbits; 
.................... #byte CVRCONbits = 0xFB5 
.................... #byte CVRCON = 0xFB5 
....................  
.................... struct CMCONBITS { 
....................    unsigned int CM0:1; 
....................    unsigned int CM1:1; 
....................    unsigned int CM2:1; 
....................    unsigned int CIS:1; 
....................    unsigned int C1INV:1; 
....................    unsigned int C2INV:1; 
....................    unsigned int C1OUT:1; 
....................    unsigned int C2OUT:1; 
.................... } CMCONbits; 
.................... #byte CMCONbits = 0xFB4 
.................... #byte CMCON = 0xFB4 
....................  
.................... #byte TMR3H = 0xFB3 
....................  
.................... #byte TMR3L = 0xFB2 
....................  
.................... struct T3CONBITS { 
....................    unsigned int TMR3ON:1; 
....................    unsigned int TMR3CS:1; 
....................    unsigned int T3SYNC:1; 
....................    unsigned int T3CCP3:1; 
....................    unsigned int T3CKPS4:1; 
....................    unsigned int T3CKPS5:1; 
....................    unsigned int T3CCP6:1; 
....................    unsigned int RD16:1; 
.................... } T3CONbits; 
.................... #byte T3CONbits = 0xFB1 
.................... #byte T3CON = 0xFB1 
....................  
.................... #byte SPBRGH = 0xFB0 
....................  
.................... #byte SPBRG = 0xFAF 
....................  
.................... #byte RCREG = 0xFAE 
....................  
.................... #byte TXREG = 0xFAD 
....................  
.................... struct TXSTABITS { 
....................    unsigned int TX9D:1; 
....................    unsigned int TRMT:1; 
....................    unsigned int BRGH:1; 
....................    unsigned int SENDB:1; 
....................    unsigned int SYNC:1; 
....................    unsigned int TXEN:1; 
....................    unsigned int TX:1; 
....................    unsigned int CSRC:1; 
.................... } TXSTAbits; 
.................... #byte TXSTAbits = 0xFAC 
.................... #byte TXSTA = 0xFAC 
....................  
.................... struct RCSTABITS { 
....................    unsigned int RX9D:1; 
....................    unsigned int OERR:1; 
....................    unsigned int FERR:1; 
....................    unsigned int ADDEN:1; 
....................    unsigned int CREN:1; 
....................    unsigned int SREN:1; 
....................    unsigned int RX:1; 
....................    unsigned int SPEN:1; 
.................... } RCSTAbits; 
.................... #byte RCSTAbits = 0xFAB 
.................... #byte RCSTA = 0xFAB 
....................  
.................... #byte EEADRH = 0xFAA 
....................  
.................... #byte EEADR = 0xFA9 
....................  
.................... #byte EEDATA = 0xFA8 
....................  
.................... #byte EECON2 = 0xFA7 
....................  
.................... struct EECON1BITS { 
....................    unsigned int RD:1; 
....................    unsigned int WR:1; 
....................    unsigned int WREN:1; 
....................    unsigned int WRERR:1; 
....................    unsigned int FREE:1; 
....................    unsigned int :1; 
....................    unsigned int CFGS:1; 
....................    unsigned int EEPGD:1; 
.................... } EECON1bits; 
.................... #byte EECON1bits = 0xFA6 
.................... #byte EECON1 = 0xFA6 
....................  
.................... struct IPR2BITS { 
....................    unsigned int CCP2IP:1; 
....................    unsigned int TMR3IP:1; 
....................    unsigned int HLVDIP:1; 
....................    unsigned int BCLIP:1; 
....................    unsigned int EEIP:1; 
....................    unsigned int :1; 
....................    unsigned int CMIP:1; 
....................    unsigned int OSCFIP:1; 
.................... } IPR2bits; 
.................... #byte IPR2bits = 0xFA2 
.................... #byte IPR2 = 0xFA2 
....................  
.................... struct PIR2BITS { 
....................    unsigned int CCP2IF:1; 
....................    unsigned int TMR3IF:1; 
....................    unsigned int HLVDIF:1; 
....................    unsigned int BCLIF:1; 
....................    unsigned int EEIF:1; 
....................    unsigned int :1; 
....................    unsigned int CMIF:1; 
....................    unsigned int OSCFIF:1; 
.................... } PIR2bits; 
.................... #byte PIR2bits = 0xFA1 
.................... #byte PIR2 = 0xFA1 
....................  
.................... struct PIE2BITS { 
....................    unsigned int CCP2IE:1; 
....................    unsigned int TMR3IE:1; 
....................    unsigned int HLVDIE:1; 
....................    unsigned int BCLIE:1; 
....................    unsigned int EEIE:1; 
....................    unsigned int :1; 
....................    unsigned int CMIE:1; 
....................    unsigned int OSCFIE:1; 
.................... } PIE2bits; 
.................... #byte PIE2bits = 0xFA0 
.................... #byte PIE2 = 0xFA0 
....................  
.................... struct IPR1BITS { 
....................    unsigned int TMR1IP:1; 
....................    unsigned int TMR2IP:1; 
....................    unsigned int CCP1IP:1; 
....................    unsigned int SSPIP:1; 
....................    unsigned int TXIP:1; 
....................    unsigned int RCIP:1; 
....................    unsigned int ADIP:1; 
....................    unsigned int PSPIP:1; 
.................... } IPR1bits; 
.................... #byte IPR1bits = 0xF9F 
.................... #byte IPR1 = 0xF9F 
....................  
.................... struct PIR1BITS { 
....................    unsigned int TMR1IF:1; 
....................    unsigned int TMR2IF:1; 
....................    unsigned int CCP1IF:1; 
....................    unsigned int SSPIF:1; 
....................    unsigned int TXIF:1; 
....................    unsigned int RCIF:1; 
....................    unsigned int ADIF:1; 
....................    unsigned int PSPIF:1; 
.................... } PIR1bits; 
.................... #byte PIR1bits = 0xF9E 
.................... #byte PIR1 = 0xF9E 
....................  
.................... struct PIE1BITS { 
....................    unsigned int TMR1IE:1; 
....................    unsigned int TMR2IE:1; 
....................    unsigned int CCP1IE:1; 
....................    unsigned int SSPIE:1; 
....................    unsigned int TXIE:1; 
....................    unsigned int RCIE:1; 
....................    unsigned int ADIE:1; 
....................    unsigned int PSPIE:1; 
.................... } PIE1bits; 
.................... #byte PIE1bits = 0xF9D 
.................... #byte PIE1 = 0xF9D 
....................  
.................... struct OSCTUNEBITS { 
....................    unsigned int TUN0:1; 
....................    unsigned int TUN1:1; 
....................    unsigned int TUN2:1; 
....................    unsigned int TUN3:1; 
....................    unsigned int TUN4:1; 
....................    unsigned int :1; 
....................    unsigned int PLLEN:1; 
....................    unsigned int INTSRC:1; 
.................... } OSCTUNEbits; 
.................... #byte OSCTUNEbits = 0xF9B 
.................... #byte OSCTUNE = 0xF9B 
....................  
.................... struct TRISEBITS { 
....................    unsigned int TRISE0:1; 
....................    unsigned int TRISE1:1; 
....................    unsigned int TRISE2:1; 
....................    unsigned int :1; 
....................    unsigned int PSPMODE:1; 
....................    unsigned int IBOV:1; 
....................    unsigned int OBF:1; 
....................    unsigned int IBF:1; 
.................... } TRISEbits; 
.................... #byte TRISEbits = 0xF96 
.................... #byte TRISE = 0xF96 
....................  
.................... struct TRISDBITS { 
....................    unsigned int TRISD0:1; 
....................    unsigned int TRISD1:1; 
....................    unsigned int TRISD2:1; 
....................    unsigned int TRISD3:1; 
....................    unsigned int TRISD4:1; 
....................    unsigned int TRISD5:1; 
....................    unsigned int TRISD6:1; 
....................    unsigned int TRISD7:1; 
.................... } TRISDbits; 
.................... #byte TRISDbits = 0xF95 
.................... #byte TRISD = 0xF95 
....................  
.................... struct TRISCBITS { 
....................    unsigned int TRISC0:1; 
....................    unsigned int TRISC1:1; 
....................    unsigned int TRISC2:1; 
....................    unsigned int TRISC3:1; 
....................    unsigned int TRISC4:1; 
....................    unsigned int TRISC5:1; 
....................    unsigned int TRISC6:1; 
....................    unsigned int TRISC7:1; 
.................... } TRISCbits; 
.................... #byte TRISCbits = 0xF94 
.................... #byte TRISC = 0xF94 
....................  
.................... struct TRISBBITS { 
....................    unsigned int TRISB0:1; 
....................    unsigned int TRISB1:1; 
....................    unsigned int TRISB2:1; 
....................    unsigned int TRISB3:1; 
....................    unsigned int TRISB4:1; 
....................    unsigned int TRISB5:1; 
....................    unsigned int TRISB6:1; 
....................    unsigned int TRISB7:1; 
.................... } TRISBbits; 
.................... #byte TRISBbits = 0xF93 
.................... #byte TRISB = 0xF93 
....................  
.................... struct TRISABITS { 
....................    unsigned int TRISA0:1; 
....................    unsigned int TRISA1:1; 
....................    unsigned int TRISA2:1; 
....................    unsigned int TRISA3:1; 
....................    unsigned int TRISA4:1; 
....................    unsigned int TRISA5:1; 
....................    unsigned int TRISA6:1; 
....................    unsigned int TRISA7:1; 
.................... } TRISAbits; 
.................... #byte TRISAbits = 0xF92 
.................... #byte TRISA = 0xF92 
....................  
.................... struct LATEBITS { 
....................    unsigned int LATE0:1; 
....................    unsigned int LATE1:1; 
....................    unsigned int LATE2:1; 
....................    unsigned int LATE3:1; 
....................    unsigned int LATE4:1; 
....................    unsigned int LATE5:1; 
....................    unsigned int LATE6:1; 
....................    unsigned int LATE7:1; 
.................... } LATEbits; 
.................... #byte LATEbits = 0xF8D 
.................... #byte LATE = 0xF8D 
....................  
.................... struct LATDBITS { 
....................    unsigned int LATD0:1; 
....................    unsigned int LATD1:1; 
....................    unsigned int LATD2:1; 
....................    unsigned int LATD3:1; 
....................    unsigned int LATD4:1; 
....................    unsigned int LATD5:1; 
....................    unsigned int LATD6:1; 
....................    unsigned int LATD7:1; 
.................... } LATDbits; 
.................... #byte LATDbits = 0xF8C 
.................... #byte LATD = 0xF8C 
....................  
.................... struct LATCBITS { 
....................    unsigned int LATC0:1; 
....................    unsigned int LATC1:1; 
....................    unsigned int LATC2:1; 
....................    unsigned int LATC3:1; 
....................    unsigned int LATC4:1; 
....................    unsigned int LATC5:1; 
....................    unsigned int LATC6:1; 
....................    unsigned int LATC7:1; 
.................... } LATCbits; 
.................... #byte LATCbits = 0xF8B 
.................... #byte LATC = 0xF8B 
....................  
.................... struct LATBBITS { 
....................    unsigned int LATB0:1; 
....................    unsigned int LATB1:1; 
....................    unsigned int LATB2:1; 
....................    unsigned int LATB3:1; 
....................    unsigned int LATB4:1; 
....................    unsigned int LATB5:1; 
....................    unsigned int LATB6:1; 
....................    unsigned int LATB7:1; 
.................... } LATBbits; 
.................... #byte LATBbits = 0xF8A 
.................... #byte LATB = 0xF8A 
....................  
.................... struct LATABITS { 
....................    unsigned int LATA0:1; 
....................    unsigned int LATA1:1; 
....................    unsigned int LATA2:1; 
....................    unsigned int LATA3:1; 
....................    unsigned int LATA4:1; 
....................    unsigned int LATA5:1; 
....................    unsigned int LATA6:1; 
....................    unsigned int LATA7:1; 
.................... } LATAbits; 
.................... #byte LATAbits = 0xF89 
.................... #byte LATA = 0xF89 
....................  
.................... struct PORTEBITS { 
....................    unsigned int RE0:1; 
....................    unsigned int RE1:1; 
....................    unsigned int RE2:1; 
....................    unsigned int RE3:1; 
....................    unsigned int RE4:1; 
....................    unsigned int RE5:1; 
....................    unsigned int RE6:1; 
....................    unsigned int RE7:1; 
.................... } PORTEbits; 
.................... #byte PORTEbits = 0xF84 
.................... #byte PORTE = 0xF84 
....................  
.................... struct PORTDBITS { 
....................    unsigned int RD0:1; 
....................    unsigned int RD1:1; 
....................    unsigned int RD2:1; 
....................    unsigned int RD3:1; 
....................    unsigned int RD4:1; 
....................    unsigned int RD5:1; 
....................    unsigned int RD6:1; 
....................    unsigned int RD7:1; 
.................... } PORTDbits; 
.................... #byte PORTDbits = 0xF83 
.................... #byte PORTD = 0xF83 
....................  
.................... struct PORTCBITS { 
....................    unsigned int RC0:1; 
....................    unsigned int RC1:1; 
....................    unsigned int RC2:1; 
....................    unsigned int RC3:1; 
....................    unsigned int RC4:1; 
....................    unsigned int RC5:1; 
....................    unsigned int RC6:1; 
....................    unsigned int RC7:1; 
.................... } PORTCbits; 
.................... #byte PORTCbits = 0xF82 
.................... #byte PORTC = 0xF82 
....................  
.................... struct PORTBBITS { 
....................    unsigned int RB0:1; 
....................    unsigned int RB1:1; 
....................    unsigned int RB2:1; 
....................    unsigned int RB3:1; 
....................    unsigned int RB4:1; 
....................    unsigned int RB5:1; 
....................    unsigned int RB6:1; 
....................    unsigned int RB7:1; 
.................... } PORTBbits; 
.................... #byte PORTBbits = 0xF81 
.................... #byte PORTB = 0xF81 
....................  
.................... struct PORTABITS { 
....................    unsigned int RA0:1; 
....................    unsigned int RA1:1; 
....................    unsigned int RA2:1; 
....................    unsigned int RA3:1; 
....................    unsigned int RA4:1; 
....................    unsigned int RA5:1; 
....................    unsigned int RA6:1; 
....................    unsigned int RA7:1; 
.................... } PORTAbits; 
.................... #byte PORTAbits = 0xF80 
.................... #byte PORTA = 0xF80 
....................  
....................  
.................... #else 
....................    #error Do this for your chip 
.................... #endif 
....................  
.................... #if defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) 
....................    #reserve 0xE80:0xEFF 
....................    #reserve 0xF00:0xFFF 
.................... #endif 
....................  
.................... #if defined(TRUE) 
....................    #undef TRUE 
.................... #endif 
....................  
.................... #if defined(FALSE) 
....................    #undef FALSE 
.................... #endif 
....................  
.................... #if defined(BYTE) 
....................    #undef BYTE 
.................... #endif 
....................  
....................       #define Reset()            reset_cpu() 
....................         #define far 
....................         #define ClrWdt()         restart_wdt() 
....................       #define Nop()            delay_cycles(1)       
....................  
.................... #define __CCS__ 
....................  
.................... //signed int8 memcmppgm2ram(void * s1, rom char *s2, unsigned int8 n); 
.................... signed int8 strcmppgm2ram(char *s1, __ADDRESS__ s2); 
.................... char *strchrpgm(__ADDRESS__ s, unsigned int8 c); 
.................... char *strstrrampgm(char *s1, __ADDRESS__ s2); 
.................... unsigned int8 strlenpgm(__ADDRESS__ s); 
.................... void memcpypgm2ram(unsigned int8 *d, __ADDRESS__ s, unsigned int16 n); 
.................... //char* strupr(char *s);   now in string.h 
.................... void strcpypgm2ram(char *d, __ADDRESS__ s); 
.................... #endif 
....................  
....................    #use delay(clock=40000000) 
*
0037E:  MOVLW  01
00380:  MOVWF  FEA
00382:  MOVLW  71
00384:  MOVWF  FE9
00386:  MOVF   FEF,W
00388:  BZ    03A6
0038A:  MOVLW  0C
0038C:  MOVWF  01
0038E:  CLRF   00
00390:  DECFSZ 00,F
00392:  BRA    0390
00394:  DECFSZ 01,F
00396:  BRA    038E
00398:  MOVLW  F7
0039A:  MOVWF  00
0039C:  DECFSZ 00,F
0039E:  BRA    039C
003A0:  BRA    03A2
003A2:  DECFSZ FEF,F
003A4:  BRA    038A
003A6:  RETURN 0
....................    #fuses H4, NOWDT, NOLVP, NODEBUG  
....................     
....................    #use rs232(baud=9600, uart1, stream=STREAM_UI, errors) 
....................        
....................    #define BUTTON1_PRESSED()  (!input(PIN_A4)) 
....................    #define USER_LED1    PIN_A5 
....................    #define USER_LED2    PIN_B4 
....................    #define USER_LED3    PIN_B5 
....................    #define LED_ON       output_low 
....................    #define LED_OFF      output_high 
....................    #define STANDARD_ADC_STRING  "AN0" 
....................    #define STANDARD_ADC_CHANNEL 0 
....................     
....................    #define LCD_ENABLE_PIN  PIN_E2 
....................    #define LCD_RS_PIN      PIN_E0 
....................    #define LCD_RW_PIN      PIN_E1 
....................    #define LCD_DATA4       PIN_D4 
....................    #define LCD_DATA5       PIN_D5 
....................    #define LCD_DATA6       PIN_D6 
....................    #define LCD_DATA7       PIN_D7 
....................     
....................    #ifndef STACK_USE_PICDEM_LCD 
....................       #define STACK_USE_PICDEM_LCD 1 
....................    #endif 
....................    #if STACK_USE_PICDEM_LCD 
....................       #include "lcd.c" 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
00448:  BSF    F95.4
....................    output_float(LCD_DATA5); 
0044A:  BSF    F95.5
....................    output_float(LCD_DATA6); 
0044C:  BSF    F95.6
....................    output_float(LCD_DATA7); 
0044E:  BSF    F95.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
00450:  BSF    F8D.1
00452:  BCF    F96.1
....................    delay_cycles(1); 
00454:  NOP   
....................    lcd_output_enable(1); 
00456:  BSF    F8D.2
00458:  BCF    F96.2
....................    delay_cycles(1); 
0045A:  NOP   
....................    high = lcd_read_nibble(); 
0045C:  RCALL  03F2
0045E:  MOVFF  01,178
....................        
....................    lcd_output_enable(0); 
00462:  BCF    F8D.2
00464:  BCF    F96.2
....................    delay_cycles(1); 
00466:  NOP   
....................    lcd_output_enable(1); 
00468:  BSF    F8D.2
0046A:  BCF    F96.2
....................    delay_us(1); 
0046C:  MOVLW  02
0046E:  MOVWF  00
00470:  DECFSZ 00,F
00472:  BRA    0470
00474:  BRA    0476
00476:  NOP   
....................    low = lcd_read_nibble(); 
00478:  RCALL  03F2
0047A:  MOVFF  01,177
....................        
....................    lcd_output_enable(0); 
0047E:  BCF    F8D.2
00480:  BCF    F96.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
00482:  BCF    F95.4
....................    output_drive(LCD_DATA5); 
00484:  BCF    F95.5
....................    output_drive(LCD_DATA6); 
00486:  BCF    F95.6
....................    output_drive(LCD_DATA7); 
00488:  BCF    F95.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0048A:  MOVLB  1
0048C:  SWAPF  x78,W
0048E:  MOVWF  00
00490:  MOVLW  F0
00492:  ANDWF  00,F
00494:  MOVF   00,W
00496:  IORWF  x77,W
00498:  MOVWF  01
0049A:  MOVLB  0
0049C:  GOTO   04AC (RETURN)
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
003F2:  MOVLB  1
003F4:  CLRF   x79
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
003F6:  BSF    F95.4
003F8:  MOVLW  00
003FA:  BTFSC  F83.4
003FC:  MOVLW  01
003FE:  IORWF  x79,F
....................    n |= input(LCD_DATA5) << 1; 
00400:  BSF    F95.5
00402:  MOVLW  00
00404:  BTFSC  F83.5
00406:  MOVLW  01
00408:  MOVWF  00
0040A:  BCF    FD8.0
0040C:  RLCF   00,F
0040E:  MOVF   00,W
00410:  IORWF  x79,F
....................    n |= input(LCD_DATA6) << 2; 
00412:  BSF    F95.6
00414:  MOVLW  00
00416:  BTFSC  F83.6
00418:  MOVLW  01
0041A:  MOVWF  00
0041C:  RLCF   00,F
0041E:  RLCF   00,F
00420:  MOVLW  FC
00422:  ANDWF  00,F
00424:  MOVF   00,W
00426:  IORWF  x79,F
....................    n |= input(LCD_DATA7) << 3; 
00428:  BSF    F95.7
0042A:  MOVLW  00
0042C:  BTFSC  F83.7
0042E:  MOVLW  01
00430:  MOVWF  00
00432:  RLCF   00,F
00434:  RLCF   00,F
00436:  RLCF   00,F
00438:  MOVLW  F8
0043A:  ANDWF  00,F
0043C:  MOVF   00,W
0043E:  IORWF  x79,F
....................     
....................    return(n); 
00440:  MOVFF  179,01
....................   #else 
00444:  MOVLB  0
00446:  RETURN 0
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
003A8:  MOVLB  1
003AA:  BTFSC  x78.0
003AC:  BRA    03B2
003AE:  BCF    F8C.4
003B0:  BRA    03B4
003B2:  BSF    F8C.4
003B4:  BCF    F95.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
003B6:  BTFSC  x78.1
003B8:  BRA    03BE
003BA:  BCF    F8C.5
003BC:  BRA    03C0
003BE:  BSF    F8C.5
003C0:  BCF    F95.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
003C2:  BTFSC  x78.2
003C4:  BRA    03CA
003C6:  BCF    F8C.6
003C8:  BRA    03CC
003CA:  BSF    F8C.6
003CC:  BCF    F95.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
003CE:  BTFSC  x78.3
003D0:  BRA    03D6
003D2:  BCF    F8C.7
003D4:  BRA    03D8
003D6:  BSF    F8C.7
003D8:  BCF    F95.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
003DA:  NOP   
....................    lcd_output_enable(1); 
003DC:  BSF    F8D.2
003DE:  BCF    F96.2
....................    delay_us(2); 
003E0:  MOVLW  06
003E2:  MOVWF  00
003E4:  DECFSZ 00,F
003E6:  BRA    03E4
003E8:  NOP   
....................    lcd_output_enable(0); 
003EA:  BCF    F8D.2
003EC:  BCF    F96.2
003EE:  MOVLB  0
003F0:  RETURN 0
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
004A0:  BCF    F96.2
....................    lcd_rs_tris(); 
004A2:  BCF    F96.0
....................    lcd_rw_tris(); 
004A4:  BCF    F96.1
....................   #endif 
....................  
....................    lcd_output_rs(0); 
004A6:  BCF    F8D.0
004A8:  BCF    F96.0
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
004AA:  BRA    0448
004AC:  MOVFF  01,177
004B0:  MOVLB  1
004B2:  BTFSS  01.7
004B4:  BRA    04BA
004B6:  MOVLB  0
004B8:  BRA    04AA
....................    lcd_output_rs(address); 
004BA:  MOVF   x75,F
004BC:  BNZ   04C2
004BE:  BCF    F8D.0
004C0:  BRA    04C4
004C2:  BSF    F8D.0
004C4:  BCF    F96.0
....................    delay_cycles(1); 
004C6:  NOP   
....................    lcd_output_rw(0); 
004C8:  BCF    F8D.1
004CA:  BCF    F96.1
....................    delay_cycles(1); 
004CC:  NOP   
....................    lcd_output_enable(0); 
004CE:  BCF    F8D.2
004D0:  BCF    F96.2
....................    lcd_send_nibble(n >> 4); 
004D2:  SWAPF  x76,W
004D4:  MOVWF  x77
004D6:  MOVLW  0F
004D8:  ANDWF  x77,F
004DA:  MOVFF  177,178
004DE:  MOVLB  0
004E0:  RCALL  03A8
....................    lcd_send_nibble(n & 0xf); 
004E2:  MOVLB  1
004E4:  MOVF   x76,W
004E6:  ANDLW  0F
004E8:  MOVWF  x77
004EA:  MOVWF  x78
004EC:  MOVLB  0
004EE:  RCALL  03A8
004F0:  RETURN 0
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
004F2:  MOVLW  28
004F4:  MOVLB  1
004F6:  MOVWF  x6D
004F8:  MOVLW  0C
004FA:  MOVWF  x6E
004FC:  MOVLW  01
004FE:  MOVWF  x6F
00500:  MOVLW  06
00502:  MOVWF  x70
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
00504:  BCF    F8D.2
00506:  BCF    F96.2
....................    lcd_output_rs(0); 
00508:  BCF    F8D.0
0050A:  BCF    F96.0
....................    lcd_output_rw(0); 
0050C:  BCF    F8D.1
0050E:  BCF    F96.1
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
00510:  BCF    F95.4
....................    output_drive(LCD_DATA5); 
00512:  BCF    F95.5
....................    output_drive(LCD_DATA6); 
00514:  BCF    F95.6
....................    output_drive(LCD_DATA7); 
00516:  BCF    F95.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
00518:  BCF    F96.2
....................    lcd_rs_tris(); 
0051A:  BCF    F96.0
....................    lcd_rw_tris(); 
0051C:  BCF    F96.1
....................  #endif 
....................      
....................    delay_ms(15); 
0051E:  MOVLW  0F
00520:  MOVWF  x71
00522:  MOVLB  0
00524:  RCALL  037E
....................    for(i=1;i<=3;++i) 
00526:  MOVLW  01
00528:  MOVLB  1
0052A:  MOVWF  x6C
0052C:  MOVF   x6C,W
0052E:  SUBLW  03
00530:  BNC   054A
....................    { 
....................        lcd_send_nibble(3); 
00532:  MOVLW  03
00534:  MOVWF  x78
00536:  MOVLB  0
00538:  RCALL  03A8
....................        delay_ms(5); 
0053A:  MOVLW  05
0053C:  MOVLB  1
0053E:  MOVWF  x71
00540:  MOVLB  0
00542:  RCALL  037E
00544:  MOVLB  1
00546:  INCF   x6C,F
00548:  BRA    052C
....................    } 
....................     
....................    lcd_send_nibble(2); 
0054A:  MOVLW  02
0054C:  MOVWF  x78
0054E:  MOVLB  0
00550:  RCALL  03A8
....................    delay_ms(5); 
00552:  MOVLW  05
00554:  MOVLB  1
00556:  MOVWF  x71
00558:  MOVLB  0
0055A:  RCALL  037E
....................    for(i=0;i<=3;++i) 
0055C:  MOVLB  1
0055E:  CLRF   x6C
00560:  MOVF   x6C,W
00562:  SUBLW  03
00564:  BNC   0588
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
00566:  CLRF   03
00568:  MOVF   x6C,W
0056A:  ADDLW  6D
0056C:  MOVWF  FE9
0056E:  MOVLW  01
00570:  ADDWFC 03,W
00572:  MOVWF  FEA
00574:  MOVFF  FEF,171
00578:  CLRF   x75
0057A:  MOVFF  171,176
0057E:  MOVLB  0
00580:  RCALL  04A0
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
00582:  MOVLB  1
00584:  INCF   x6C,F
00586:  BRA    0560
....................    g_LcdX = 0; 
00588:  CLRF   17
....................    g_LcdY = 0; 
0058A:  CLRF   18
....................   #endif 
0058C:  MOVLB  0
0058E:  GOTO   663E (RETURN)
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
00592:  MOVLB  1
00594:  DECFSZ x72,W
00596:  BRA    059A
00598:  BRA    05A0
....................       address=LCD_LINE_TWO; 
0059A:  MOVLW  40
0059C:  MOVWF  x73
0059E:  BRA    05A2
....................    else 
....................       address=0; 
005A0:  CLRF   x73
....................       
....................    address+=x-1; 
005A2:  MOVLW  01
005A4:  SUBWF  x71,W
005A6:  ADDWF  x73,F
....................    lcd_send_byte(0,0x80|address); 
005A8:  MOVF   x73,W
005AA:  IORLW  80
005AC:  MOVWF  x74
005AE:  CLRF   x75
005B0:  MOVWF  x76
005B2:  MOVLB  0
005B4:  RCALL  04A0
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
....................    g_LcdX = x - 1; 
005B6:  MOVLW  01
005B8:  MOVLB  1
005BA:  SUBWF  x71,W
005BC:  MOVWF  17
....................    g_LcdY = y - 1; 
005BE:  MOVLW  01
005C0:  SUBWF  x72,W
005C2:  MOVWF  18
....................   #endif 
005C4:  MOVLB  0
005C6:  RETURN 0
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
005C8:  MOVLB  1
005CA:  MOVF   x6F,W
005CC:  XORLW  07
005CE:  MOVLB  0
005D0:  BZ    05E4
005D2:  XORLW  0B
005D4:  BZ    05F2
005D6:  XORLW  01
005D8:  BZ    060E
005DA:  XORLW  07
005DC:  BZ    0624
005DE:  XORLW  02
005E0:  BZ    0652
005E2:  BRA    0660
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
005E4:  MOVLW  01
005E6:  MOVLB  1
005E8:  MOVWF  x71
005EA:  MOVWF  x72
005EC:  MOVLB  0
005EE:  RCALL  0592
005F0:  BRA    0676
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
005F2:  MOVLB  1
005F4:  CLRF   x75
005F6:  MOVLW  01
005F8:  MOVWF  x76
005FA:  MOVLB  0
005FC:  RCALL  04A0
....................                      delay_ms(2); 
005FE:  MOVLW  02
00600:  MOVLB  1
00602:  MOVWF  x71
00604:  MOVLB  0
00606:  RCALL  037E
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
00608:  CLRF   17
....................                      g_LcdY = 0; 
0060A:  CLRF   18
....................                     #endif 
....................                      break; 
0060C:  BRA    0676
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
0060E:  MOVLW  01
00610:  ADDWF  18,W
00612:  MOVLB  1
00614:  MOVWF  x70
00616:  MOVLW  01
00618:  MOVWF  x71
0061A:  MOVFF  170,172
0061E:  MOVLB  0
00620:  RCALL  0592
00622:  BRA    0676
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
00624:  MOVF   17,W
00626:  INCF   17,F
00628:  SUBLW  13
0062A:  BNC   063C
....................          { 
....................             lcd_send_byte(1, ' '); 
0062C:  MOVLW  01
0062E:  MOVLB  1
00630:  MOVWF  x75
00632:  MOVLW  20
00634:  MOVWF  x76
00636:  MOVLB  0
00638:  RCALL  04A0
0063A:  BRA    0624
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
0063C:  MOVLW  02
0063E:  ADDWF  18,W
00640:  MOVLB  1
00642:  MOVWF  x70
00644:  MOVLW  01
00646:  MOVWF  x71
00648:  MOVFF  170,172
0064C:  MOVLB  0
0064E:  RCALL  0592
....................          break; 
00650:  BRA    0676
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
00652:  MOVLB  1
00654:  CLRF   x75
00656:  MOVLW  10
00658:  MOVWF  x76
0065A:  MOVLB  0
0065C:  RCALL  04A0
0065E:  BRA    0676
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
00660:  MOVF   17,W
00662:  SUBLW  13
00664:  BNC   0676
....................          { 
....................             lcd_send_byte(1, c); 
00666:  MOVLW  01
00668:  MOVLB  1
0066A:  MOVWF  x75
0066C:  MOVFF  16F,176
00670:  MOVLB  0
00672:  RCALL  04A0
....................             g_LcdX++; 
00674:  INCF   17,F
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
....................      #endif 
....................    } 
00676:  RETURN 0
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................    #endif 
....................     
....................    #define ENC_CS_IO       LATDbits.LATD1 
....................    #define ENC_CS_TRIS     TRISDbits.TRISD1 
....................    #define ENC_SCK_TRIS    TRISCbits.TRISC3 
....................    #define ENC_SDO_TRIS    TRISCbits.TRISC5 
....................    #define ENC_SDI_TRIS    TRISCbits.TRISC4 
....................    #define ENC_SPI_IF         PIR1bits.SSPIF 
....................    #define ENC_SPICON1        SSPCON1bits 
....................    #define ENC_SPISTATbits    SSPSTATbits 
....................    #define ENC_SSPBUF         SSPBUF 
....................     
....................    void init_user_io(void)  
....................    { 
....................       setup_adc(ADC_CLOCK_INTERNAL); 
*
002A6:  MOVF   FC0,W
002A8:  ANDLW  C0
002AA:  IORLW  07
002AC:  MOVWF  FC0
002AE:  BCF    FC0.7
002B0:  BSF    FC2.0
....................       setup_adc_ports(AN0); 
002B2:  MOVF   FC1,W
002B4:  ANDLW  C0
002B6:  IORLW  0E
002B8:  MOVWF  FC1
....................       set_adc_channel(STANDARD_ADC_CHANNEL); 
002BA:  MOVLW  00
002BC:  MOVWF  01
002BE:  MOVF   FC2,W
002C0:  ANDLW  C3
002C2:  IORWF  01,W
002C4:  MOVWF  FC2
....................        
....................       setup_comparator(NC_NC_NC_NC); 
002C6:  MOVLW  07
002C8:  MOVWF  FB4
002CA:  MOVF   F92,W
002CC:  MOVWF  F92
002CE:  MOVLW  20
002D0:  MOVWF  00
002D2:  DECFSZ 00,F
002D4:  BRA    02D2
002D6:  BRA    02D8
002D8:  NOP   
002DA:  MOVF   FB4,W
002DC:  BCF    FA1.6
....................        
....................       output_drive(USER_LED1); 
002DE:  BCF    F92.5
....................       output_drive(USER_LED2); 
002E0:  BCF    F93.4
....................       output_drive(USER_LED3); 
002E2:  BCF    F93.5
....................       LED_OFF(USER_LED1); 
002E4:  BCF    F92.5
002E6:  BSF    F89.5
....................       LED_OFF(USER_LED2); 
002E8:  BCF    F93.4
002EA:  BSF    F8A.4
....................       LED_OFF(USER_LED3); 
002EC:  BCF    F93.5
002EE:  BSF    F8A.5
002F0:  GOTO   034E (RETURN)
....................    } 
....................     
....................    #define EEPROM_SELECT     PIN_B3 
....................    #define EEPROM_DI         PIN_C5 
....................    #define EEPROM_DO         PIN_C4 
....................    #define EEPROM_CLK        PIN_C3 
....................    #define EEPROM_USE_SPI    1 
....................    #include "AT25256.C" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for an ATMEL25128 or ATMEL25256                         //// 
.................... ////    ATMEL25128 has 16,384 (or 13bits of addressing) locations      //// 
.................... ////    ATMEL25256 has 32,768 words of 8 bits                          //// 
.................... ////                                                                   //// 
.................... ////   Uses software (bit banging on the port pins)                    //// 
.................... ////                                                                   //// 
.................... ////                     Pin Layout                                    //// 
.................... ////   ATMEL EEPROM pin     to      Microchip MCU Pin                  //// 
.................... ////   ----------------             -----------------                  //// 
.................... ////   1 (CS)                       PortB 0                            //// 
.................... ////   2 (SO)                       PortC 4                            //// 
.................... ////   3 (WP)                       +5V                                //// 
.................... ////   4 (GND)                      GND                                //// 
.................... ////   5 (SI)                       PortC 5                            //// 
.................... ////   6 (SCK)                      PortC 3                            //// 
.................... ////   7 (HOLD)                     +5V                                //// 
.................... ////   8 (VCC)                      +5V                                //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the unsigned int8 d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the unsigned int8 d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   b = ext_eerpom_ready();  Returns TRUE if the eeprom is ready    //// 
.................... ////                            to receive opcodes                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef EEPROM_SELECT 
.................... #define EEPROM_SELECT PIN_B0 
.................... #define EEPROM_DI     PIN_C5 
.................... #define EEPROM_DO     PIN_C4 
.................... #define EEPROM_CLK    PIN_C3 
.................... #endif 
....................  
.................... #ifndef EEPROM_ADDRESS 
.................... #define EEPROM_ADDRESS long 
.................... #endif 
....................  
.................... #byte SSPSTAT=0x94 
.................... #byte SSPCON=0x14 
....................  
.................... void init_ext_eeprom() { 
....................    int1 i; 
....................  
....................    output_low(EEPROM_DI); 
....................    output_low(EEPROM_CLK); 
....................    output_high(EEPROM_SELECT);   //at25256 is cs active LOW 
....................    i=input(EEPROM_DO); 
.................... } 
....................  
.................... BOOLEAN ext_eeprom_ready() { 
....................    unsigned int8 cmd[1],i,data; 
....................  
....................    cmd[0] = 0x05;         //rdsr opcode 
....................  
....................    output_low(EEPROM_SELECT); 
....................  
....................    for(i=1;i<=8;++i) { 
....................       output_bit(EEPROM_DI, shift_left(cmd,1,0)); 
....................       output_high(EEPROM_CLK);      //data latches 
....................       output_low(EEPROM_CLK);      //back to idle 
....................    } 
....................  
....................    for(i=1;i<=8;++i) { 
....................         output_high(EEPROM_CLK);      //data latches 
....................         shift_left(&data,1,input(EEPROM_DO)); 
....................         output_low(EEPROM_CLK);              //back to idle 
....................    } 
....................    output_high(EEPROM_SELECT); 
....................    return (!(bit_test(data, 0))); 
.................... } 
....................  
....................  
.................... void write_ext_eeprom(EEPROM_ADDRESS address, unsigned int8 data) { 
....................  
....................    unsigned int8 cmd[4]; 
....................    unsigned int8 i; 
....................    cmd[2]=((address>>8)&(0xFF));   //address msb (16bit addressing) 
....................    cmd[1]=address-cmd[2];      //address lsb 
....................  
....................    do {} while (!(ext_eeprom_ready())); //wait until the eeprom is out of the previous write state, if applicable 
....................  
....................    cmd[0]=0x06; 
....................    output_low(EEPROM_SELECT); //cs is active low 
....................    for(i=1;i<=8;++i) { 
....................       output_bit(EEPROM_DI, shift_left(cmd,1,0)); 
....................       output_high(EEPROM_CLK);      //data latches 
....................       output_low(EEPROM_CLK);      //back to idle 
....................    } 
....................    output_high(EEPROM_SELECT); 
....................  
....................    cmd[0]=data; 
....................    cmd[3]=0x02;      //write opcode 
....................    output_low(EEPROM_SELECT); 
....................    for(i=1;i<=32;++i) { 
....................       output_bit(EEPROM_DI, shift_left(cmd,4,0)); 
....................       output_high(EEPROM_CLK);      //data latches 
....................       output_low(EEPROM_CLK);      //back to idle 
....................    } 
....................  
....................    output_high(EEPROM_SELECT); 
.................... } 
....................  
....................  
.................... unsigned int8 read_ext_eeprom(EEPROM_ADDRESS address) { 
....................    unsigned int8 i,data; 
....................    unsigned int8 cmd[3]; 
....................    cmd[2]=0x03;            //read opcode 
....................    cmd[1]=((address>>8)&(0xFF)); 
....................    cmd[0]=address-cmd[1]; 
....................  
....................    do {} while (!(ext_eeprom_ready())); //wait until the eeprom is out of the previous write state, if applicable 
....................    output_low(EEPROM_SELECT); 
....................    for(i=1;i<=24;++i) { 
....................       output_bit(EEPROM_DI, shift_left(cmd,3,0)); 
....................       output_high(EEPROM_CLK);      //data latches 
....................       output_low(EEPROM_CLK);      //back to idle 
....................    } 
....................  
....................    for(i=1;i<=8;++i) { 
....................         output_high(EEPROM_CLK);      //data latches 
....................         shift_left(&data,1,input(EEPROM_DO)); 
....................         output_low(EEPROM_CLK);              //back to idle 
....................    } 
....................  
....................    output_high(EEPROM_SELECT); 
....................  
....................    return(data); 
.................... } 
....................  
....................     
....................    #define __SPIFLASH_H    //prevent spiflash.h from being loaded/used 
....................    #define SPIFlashReadArray(dwAddress, pData, wLen)  read_ext_eeprom_buf(dwAddress, pData, wLen) 
....................    #define SPIFlashInit()                             init_ext_eeprom() 
....................    EEPROM_ADDRESS g_SpiFlashCurrWrite; 
....................    #define SPIFlashBeginWrite(addy)                   g_SpiFlashCurrWrite=addy 
....................    #define SPIFlashWrite(d)                           write_ext_eeprom(g_SpiFlashCurrWrite++, d) 
....................    #define SPIFlashStopWrite() 
....................    #define SPIFlashWriteBytes(dwAddress, pData, wLen) write_ext_eeprom_buf(dwAddress, pData, wLen) 
....................     
....................    // if you want TCP/IP settings saved to internal EEPROM, then comment 
....................    // out the next few lines: 
....................    #define EEInit SPIFlashInit 
....................    #define EEReadBytes(dst, src, len)  SPIFlashReadArray(src, dst, len) 
....................    #define EEWriteBytes(dst, src, len) SPIFlashWriteBytes(dst, src, len); SPIFlashStopWrite() 
....................  
.................... #elif STACK_USE_CCS_EWL3V 
....................    #include <18F67J60.h> 
....................    #include "tcpip\p18cxxx.h" 
....................    #reserve 0xE80:0xEFF   //SFR 
....................    #reserve 0xF00:0xFFF   //SFR 
....................    #use delay(clock=41666667) 
....................    #fuses NOWDT, NODEBUG, H4_SW, NOIESO, NOFCMEN, PRIMARY, ETHLED 
....................   
....................    #use rs232(baud=9600, uart1, stream=STREAM_UI, errors)  
....................  
....................    void lcd_putc(char c) 
....................    { 
....................      #if STACK_USE_PICDEM_LCD 
....................        if (c == '\f') 
....................          printf("\r\n\n"); 
....................        else 
....................          putc(c); 
....................      #endif 
....................    } 
....................    #define lcd_init() 
....................    #ifndef STACK_USE_PICDEM_LCD 
....................       #define STACK_USE_PICDEM_LCD 0   // no hardware LCD support 
....................    #endif 
....................     
....................    #define LED_ON       output_high 
....................    #define LED_OFF      output_low 
....................    #define USER_LED1    PIN_F1                 //input1 
....................    #define USER_LED2    PIN_F2                 //input2 
....................    #define USER_LED3    PIN_F3                 //input3 
....................    #define STANDARD_ADC_STRING  "AN9" 
....................    #define STANDARD_ADC_CHANNEL 9              //input4 
....................    #define BUTTON1_PRESSED() (input(PIN_F5))   //input5 
....................    #define BUTTON2_PRESSED() (input(PIN_F6))   //input6 
....................  
....................    void init_user_io(void) 
....................    { 
....................       setup_oscillator(OSC_PLL_5_DIV_3 | OSC_NORMAL); 
....................       restart_wdt(); 
....................       delay_ms(144); 
....................       restart_wdt(); 
....................     
....................       setup_adc(ADC_CLOCK_INTERNAL); 
....................       setup_adc_ports(AN0_TO_AN9); 
....................       set_adc_channel(STANDARD_ADC_CHANNEL); 
....................        
....................       setup_comparator(NC_NC_NC_NC); 
....................  
....................       output_drive(USER_LED1); 
....................       output_drive(USER_LED2); 
....................       output_drive(USER_LED3); 
....................       LED_OFF(USER_LED1); 
....................       LED_OFF(USER_LED2); 
....................       LED_OFF(USER_LED3); 
....................    } 
....................      
....................    #define __AT45DB_B__ 
....................    #define FLASH_SELECT PIN_C2 
....................    #define FLASH_CLOCK  PIN_C3 
....................    #define FLASH_DI     PIN_C5 
....................    #define FLASH_DO     PIN_C4 
....................    #define FLASH_BUFFER_SIZE    264     //bytes per page 
....................    #define FLASH_BUFFER_COUNT   4096   //page count 
....................    #include "at45db.c"  
....................        
....................    #define __SPIFLASH_H    //prevent spiflash.h from being loaded/used 
....................    #define SPIFlashReadArray(dwAddress, pData, wLen)  ext_flash_read(dwAddress, pData, wLen) 
....................    #define SPIFlashInit()                             init_ext_flash() 
....................    #define SPIFlashBeginWrite(addy)                   ext_flash_startWrite(addy) 
....................    #define SPIFlashWrite(d)                           ext_flash_continuousWrite(d) 
....................    #define SPIFlashStopWrite()                        ext_flash_flushWrites() 
....................    #define SPIFlashWriteBytes(dwAddress, pData, wLen) ext_flash_writeBytes(dwAddress, pData, wLen) 
....................     
....................    // if you want TCP/IP settings saved to internal EEPROM, then comment 
....................    // out the next few lines: 
....................    #define EEInit SPIFlashInit 
....................    #define EEReadBytes(dst, src, len)  SPIFlashReadArray(src, dst, len) 
....................    #define EEWriteBytes(dst, src, len) SPIFlashWriteBytes(dst, src, len)  
....................     
.................... #elif STACK_USE_CCS_EWL5V_REV5 
....................    #include <18F67K22.h> 
....................    #include "tcpip\p18cxxx.h" 
....................    #reserve 0xF16:0xFFF   //SFR 
....................    #use delay(clock=64M, XTAL=16M) 
....................     
....................    #use rs232(baud=9600, uart1, stream=STREAM_UI, errors) 
....................  
....................    void lcd_putc(char c) 
....................    { 
....................      #if STACK_USE_PICDEM_LCD 
....................        if (c == '\f') 
....................          printf("\r\n\n"); 
....................        else 
....................          putc(c); 
....................      #endif 
....................    } 
....................    #define lcd_init() 
....................    #ifndef STACK_USE_PICDEM_LCD 
....................       #define STACK_USE_PICDEM_LCD 0   // no hardware LCD support 
....................    #endif 
....................      
....................    #define LED_ON       output_high 
....................    #define LED_OFF      output_low 
....................    #define USER_LED1    PIN_G3                 //input1 
....................    #define USER_LED2    PIN_G4                 //input2 
....................    #define USER_LED3    PIN_A2                 //input3 
....................    #define STANDARD_ADC_STRING  "AN3" 
....................    #define STANDARD_ADC_CHANNEL 3              //input4 
....................    #define BUTTON1_PRESSED() (input(PIN_A5))   //input5 
....................    #define BUTTON2_PRESSED() (input(PIN_B5))   //input6 
....................  
....................    #define ENC_CS_IO       LATFbits.LATF2    
....................    #define ENC_CS_TRIS     TRISFbits.TRISF2 
....................    #define ENC_SCK_TRIS    TRISCbits.TRISC3 
....................    #define ENC_SDO_TRIS    TRISCbits.TRISC5 
....................    #define ENC_SDI_TRIS    TRISCbits.TRISC4 
....................    #define ENC_RST_IO      LATDbits.LATD0 
....................    #define ENC_RST_TRIS    TRISDbits.TRISD0 
....................    #define ENC_SPI_IF         PIR1bits.SSP1IF 
....................    #define ENC_SPICON1        SSP1CON1bits   //SPI1CON1 
....................    #define ENC_SPICON2        SPI1CON2 
....................    #define ENC_SPISTAT        SPI1STAT 
....................    #define ENC_SSPBUF         SSP1BUF        //SPI1BUF 
....................    #define ENC_SPICON1bits    SPI1CON1bits 
....................    #define ENC_SPICON2bits    SPI1CON2bits 
....................    #define ENC_SPISTATbits    SSP1STATbits   //SPI1STATbits   
....................  
....................    void init_user_io(void) 
....................    { 
....................       setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_2); 
....................       setup_adc_ports(sAN3); 
....................       set_adc_channel(STANDARD_ADC_CHANNEL); 
....................       output_drive(USER_LED1); 
....................       output_drive(USER_LED2); 
....................       output_drive(USER_LED3); 
....................       LED_OFF(USER_LED1); 
....................       LED_OFF(USER_LED2); 
....................       LED_OFF(USER_LED3); 
....................    } 
....................     
....................    #define __AT45DB_D__ 
....................    #define FLASH_SELECT PIN_F1 
....................    #define FLASH_CLOCK  PIN_D6 
....................    #define FLASH_DO     PIN_D5   //MISO 
....................    #define FLASH_DI     PIN_D4   //MOSI 
....................    #define FLASH_BUFFER_SIZE    264 
....................    #define FLASH_BUFFER_COUNT   4096 
....................    #include "at45db.c" 
....................        
....................    #define __SPIFLASH_H    //prevent spiflash.h from being loaded/used 
....................    #define SPIFlashReadArray(dwAddress, pData, wLen)  ext_flash_read(dwAddress, pData, wLen) 
....................    #define SPIFlashInit()                             init_ext_flash() 
....................    #define SPIFlashBeginWrite(addy)                   ext_flash_startWrite(addy) 
....................    #define SPIFlashWrite(d)                           ext_flash_continuousWrite(d) 
....................    #define SPIFlashStopWrite()                        ext_flash_flushWrites() 
....................    #define SPIFlashWriteBytes(dwAddress, pData, wLen) ext_flash_writeBytes(dwAddress, pData, wLen) 
....................     
....................    // if you want TCP/IP settings saved to internal EEPROM, then comment 
....................    // out the next few lines: 
....................    #define EEInit SPIFlashInit 
....................    #define EEReadBytes(dst, src, len)  SPIFlashReadArray(src, dst, len) 
....................    #define EEWriteBytes(dst, src, len) SPIFlashWriteBytes(dst, src, len) 
....................  
.................... /* currently working on this - not functional */ 
.................... #elif STACK_USE_CCS_PICNET 
....................    #include <18F6722.h> 
....................    #include "tcpip\p18cxxx.h" 
....................    // SFR? 
....................    #use delay (clock=40000000) 
....................    #fuses H4, NOLVP, NOWDT, NODEBUG 
....................     
....................    #use rs232(baud=9600, uart1, stream=STREAM_UI, errors) 
....................  
....................    #define STACK_USE_PICDEM_LCD TRUE 
....................    #define BUTTON1_PRESSED()  (!input(PIN_B0)) 
....................    #define BUTTON2_PRESSED()  (!input(PIN_B1)) 
....................    #define USER_LED1    PIN_B2 
....................    #define USER_LED2    PIN_B4 
....................    #define LED_ON       output_low 
....................    #define LED_OFF      output_high 
....................    #define STANDARD_ADC_STRING  "AN0" 
....................    #define STANDARD_ADC_CHANNEL 0 
....................    #define SECONDARY_ADC_STRING "AN1" 
....................    #define SECONDARY_ADC_CHANNEL 1 
....................     
....................    #define LCD_ENABLE_PIN  PIN_D0 
....................    #define LCD_RS_PIN      PIN_D1 
....................    #define LCD_RW_PIN      PIN_D2 
....................    #define LCD_DATA4       PIN_D4 
....................    #define LCD_DATA5       PIN_D5 
....................    #define LCD_DATA6       PIN_D6 
....................    #define LCD_DATA7       PIN_D7 
....................     
....................    #ifndef STACK_USE_PICDEM_LCD 
....................       #define STACK_USE_PICDEM_LCD 1 
....................    #endif 
....................    #if STACK_USE_PICDEM_LCD 
....................       #include "lcd.c" 
....................    #endif 
....................     
....................    void init_user_io(void) { 
....................       setup_adc(ADC_CLOCK_INTERNAL ); 
....................       setup_adc_ports(ANALOG_AN0_TO_AN1); 
....................       set_adc_channel(STANDARD_ADC_CHANNEL); 
....................       //*0xF92=*0xF92 | 3;            //a0 and a1 input (for ADC) 
....................       //*0xF93=(*0xF93 & 0xEB) | 3;   //B0 and B1 input, B2 and B4 output 
....................       output_drive(USER_LED1); 
....................       output_drive(USER_LED2); 
....................       LED_OFF(USER_LED1); 
....................       LED_OFF(USER_LED2); 
....................    } 
....................  
.................... #else 
....................  #error You need to define your custom hardware 
.................... #endif 
....................  
.................... #ifndef LED_ACTIVITY_BLINK 
.................... #define LED_ACTIVITY_BLINK() 
.................... #endif 
....................  
.................... #if !STACK_USE_PICDEM_LCD 
....................    #define lcd_putc(c) 
....................    #define lcd_init() 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_WIFI 
....................    #define STACK_USE_CCS_GRATUITOUS_ARP 
....................     
....................    #define WIFI_CCS_RESET_ON_MODULE_HANG 
....................     
....................    #define WF_USE_TX_POWER_CONTROL_FUNCTIONS 
....................  
....................    #define WF_FORCE_NO_PS_POLL 
....................      
....................    //#define FORCE_ADHOC_ACTIVATED !input(PIN_G4)     //a certain button press can force ad hoc mode regardless of EE setting 
....................     
....................    #define STACK_USE_DNS_SERVER   //strongly recommended if using ad-hoc mode 
....................    #define STACK_USE_DHCP_SERVER  //strongly recommended if using ad-hoc mode 
.................... #endif 
....................  
.................... #ifndef STACK_USE_CCS_INI 
....................  #define STACK_USE_CCS_INI 0 
....................  #define UITask() 
.................... #endif 
....................  
.................... #if STACK_USE_CCS_INI 
....................    #define STACK_USE_DHCP_CLIENT 
.................... #endif 
....................  
.................... // clock definitions required by Microchip's TCP/IP Stack. 
.................... #if defined(__PCH__) //pic18 
....................    #define GetSystemClock()      getenv("CLOCK") 
....................    #define GetInstructionClock()   (GetSystemClock()/4) 
....................    #define GetPeripheralClock()   (unsigned int32)GetInstructionClock() 
.................... #else //pic24,dspic30,dspic33f 
....................    #define GetSystemClock()       getenv("CLOCK") 
....................    #define GetInstructionClock()  (GetSystemClock()/2) 
....................    #define GetPeripheralClock()   (GetSystemClock()/2) 
.................... #endif 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define MIN(a,b)  ((a > b) ? b : a) 
....................  
.................... #include "tcpip/StackTsk2.h" 
.................... // 'glue' file for using Microchip's TCP/IP stack inside CCS C Compiler without 
.................... // a linker.   
.................... // Also includes some macros/defines for porting older V3 stack to this current 
.................... // stack. 
.................... // Also provides extra routines written by CCS to improve the stack. 
....................  
.................... #ifndef __CCS_STACKTSK2_H__ 
.................... #define __CCS_STACKTSK2_H__ 
....................  
.................... #if !defined(debug_mpfs2) 
....................  #define debug_mpfs2(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) 
.................... #else 
....................  #define __DO_DEBUG_MPFS2 
.................... #endif 
....................  
.................... #if defined(__PCH__) && !defined(__18CXX) 
....................  #define __18CXX 
.................... #endif 
....................  
.................... #define SIZEOF_MAC_HEADER 14 
....................  
.................... // override delay.c/delay.h with CCS compatible code 
.................... #define __DELAY_H 
.................... #define Delay10us(x) delay_us((uint16_t)10*(uint16_t)x) 
.................... #define DelayMs(x)   delay_ms(x) 
....................  
.................... #define __WF_DEBUG_STRINGS_H  //don't include this file 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
05F00:  MOVFF  269,26B
05F04:  MOVFF  268,26A
05F08:  MOVFF  26B,03
05F0C:  MOVLB  2
05F0E:  MOVFF  26A,FE9
05F12:  MOVFF  26B,FEA
05F16:  MOVF   FEF,F
05F18:  BZ    5F26
05F1A:  INCF   x6A,F
05F1C:  BTFSC  FD8.2
05F1E:  INCF   x6B,F
05F20:  MOVLB  0
05F22:  BRA    5F08
05F24:  MOVLB  2
....................    return(sc - s); 
05F26:  MOVF   x68,W
05F28:  SUBWF  x6A,W
05F2A:  MOVWF  00
05F2C:  MOVF   x69,W
05F2E:  SUBWFB x6B,W
05F30:  MOVWF  03
05F32:  MOVFF  00,01
05F36:  MOVLB  0
05F38:  RETURN 0
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... #ifdef BYTE 
.................... #undef BYTE 
.................... #endif 
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
.................... #include "Compiler.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Compiler and hardware specific definitions 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Compiler.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, PIC24E, dsPIC30F, dsPIC33F,  
....................  *               dsPIC33E, PIC32 
....................  * Compiler:        Microchip C32 v1.00 or higher 
....................  *               Microchip C30 v3.01 or higher 
....................  *               Microchip C18 v3.13 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights  
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and  
....................  * distribute:  
....................  * (i)  the Software when embedded on a Microchip microcontroller or  
....................  *      digital signal controller product ("Device") which is  
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c and  
....................  *      ENC28J60.h ported to a non-Microchip device used in  
....................  *      conjunction with a Microchip ethernet controller for the  
....................  *      sole purpose of interfacing with the ethernet controller.  
....................  * 
....................  * You should refer to the license agreement accompanying this  
....................  * Software for additional information regarding your rights and  
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT  
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT  
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A  
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL  
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR  
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF  
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS  
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER  
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT  
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * 10/03/2006   Original, copied from old Compiler.h 
....................  * 11/07/2007   Reorganized and simplified 
....................  * 03/31/2010   Removed dependency on WORD and DWORD typedefs 
....................  * 04/14/2010   Added defines to uniquely identify each compiler 
....................  ********************************************************************/ 
.................... #ifndef __COMPILER_H 
.................... #define __COMPILER_H 
....................  
.................... // Include proper device header file 
.................... #if defined(__18CXX) && !defined(HI_TECH_C)    
....................    // PIC18 processor with Microchip C18 compiler 
....................     #define COMPILER_MPLAB_C18 
....................     #include <p18cxxx.h> 
.................... // CCS PCH C Compiler to Microchip C18 Compiler compatability layer. 
....................  
.................... #ifndef __P18CXXXX_H__ 
.................... #define __P18CXXXX_H__ 
....................  
.................... #ifndef __18CXX 
.................... #define __18CXX 
.................... #endif 
....................  
.................... //#zero_local_ram 
.................... #zero_ram 
....................  
....................  
.................... #device PASS_STRINGS=IN_RAM 
.................... #device CONST=READ_ONLY 
....................  
.................... #case 
.................... #type signed 
.................... #type short=16 int=16 long=32 
....................  
.................... #define _asm #asm 
.................... #define _endasm #endasm 
....................  
.................... /* usualy 
.................... #define GetSystemClock()      getenv("CLOCK") 
.................... #define GetInstructionClock()   (GetSystemClock()/4) 
.................... #define GetPeripheralClock()   (unsigned int32)GetInstructionClock() 
.................... */ 
....................  
.................... #if getenv("DEVICE") == "PIC18F97J60" 
....................  #define __18F97J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F96J65" 
....................  #define __18F96J65) 
.................... #elif getenv("DEVICE") == "PIC18F96J60" 
....................  #define __18F96J60 
.................... #elif getenv("DEVICE") == "PIC18F87J60" 
....................  #define __18F87J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J60" 
....................  #define __18F86J60 
.................... #elif getenv("DEVICE") == "PIC18F67J60" 
....................  #define __18F67J60 
....................  #include "PIC18F67J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F66J65" 
....................  #define __18F66J65 
.................... #elif getenv("DEVICE") == "PIC18F66J60" 
....................  #define __18F66J60 
.................... #elif getenv("DEVICE") == "PIC18F67K22" 
....................  #define __18F67K22 
....................  #include "PIC18F67K22_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F4620" 
....................  #define __18F4620 
....................  #include "PIC18F4620_registers.h" 
.................... #else 
....................    #error Do this for your chip 
.................... #endif 
....................  
.................... #if defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) 
....................    #reserve 0xE80:0xEFF 
....................    #reserve 0xF00:0xFFF 
.................... #endif 
....................  
.................... #if defined(TRUE) 
....................    #undef TRUE 
.................... #endif 
....................  
.................... #if defined(FALSE) 
....................    #undef FALSE 
.................... #endif 
....................  
.................... #if defined(BYTE) 
....................    #undef BYTE 
.................... #endif 
....................  
....................       #define Reset()            reset_cpu() 
....................         #define far 
....................         #define ClrWdt()         restart_wdt() 
....................       #define Nop()            delay_cycles(1)       
....................  
.................... #define __CCS__ 
....................  
.................... //signed int8 memcmppgm2ram(void * s1, rom char *s2, unsigned int8 n); 
.................... signed int8 strcmppgm2ram(char *s1, __ADDRESS__ s2); 
.................... char *strchrpgm(__ADDRESS__ s, unsigned int8 c); 
.................... char *strstrrampgm(char *s1, __ADDRESS__ s2); 
.................... unsigned int8 strlenpgm(__ADDRESS__ s); 
.................... void memcpypgm2ram(unsigned int8 *d, __ADDRESS__ s, unsigned int16 n); 
.................... //char* strupr(char *s);   now in string.h 
.................... void strcpypgm2ram(char *d, __ADDRESS__ s); 
.................... #endif 
....................  
.................... #elif defined(__PICC18__) && defined(HI_TECH_C)    
....................    // PIC18 processor with (Microchip) HI-TECH PICC-18 compiler 
....................    #if !defined(__18CXX) 
....................       #define __18CXX 
....................    #endif 
....................     #define COMPILER_HITECH_PICC18 
....................    #include <htc.h> 
.................... #elif (defined(__PIC24F__) || defined(__PIC24FK__)) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Fxxxx.h> 
.................... #elif defined(__PIC24H__) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24H processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Hxxxx.h> 
.................... #elif defined(__PIC24E__) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24E processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Exxxx.h> 
.................... #elif defined(__dsPIC33F__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC33F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p33Fxxxx.h> 
.................... #elif defined(__dsPIC33E__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC33E processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p33Exxxx.h> 
.................... #elif defined(__dsPIC30F__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC30F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p30fxxxx.h> 
.................... #elif defined(__C30__)      // Microchip C30 compiler, but targeting "generic-16bit" processor. 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p30sim.h> 
....................    // Define some useful inline assembly functions which are normally in the  
....................    // processor header files, but absent from the generic p30sim.h file. 
....................    #if !defined(Nop) 
....................       #define Nop()    __builtin_nop() 
....................       #define ClrWdt() {__asm__ volatile ("clrwdt");} 
....................       #define Sleep()  {__asm__ volatile ("pwrsav #0");} 
....................       #define Idle()   {__asm__ volatile ("pwrsav #1");} 
....................    #endif 
.................... #elif defined(__PIC32MX__)   // Microchip C32 compiler 
....................    #if !defined(__C32__) 
....................       #define __C32__ 
....................    #endif 
....................     #define COMPILER_MPLAB_C32 
....................    #include <p32xxxx.h> 
....................    #include <plib.h> 
.................... #else 
....................    #error Unknown processor or compiler.  See Compiler.h 
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... // Base RAM and ROM pointer types for given architecture 
.................... #if defined(__PCH__) || defined(__PCD__) 
....................    #define PTR_BASE      unsigned int16 
....................    #define ROM_PTR_BASE   unsigned int32 
.................... #elif defined(__PIC32MX__) 
....................    #define PTR_BASE      unsigned long 
....................    #define ROM_PTR_BASE   unsigned long 
.................... #elif defined(__C30__) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned short 
.................... #elif defined(COMPILER_MPLAB_C18) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned short long 
.................... #elif defined(COMPILER_HITECH_PICC18) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned long 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all except Microchip MPLAB C Compiler for PIC18 MCUs (C18) 
.................... #if !defined(COMPILER_MPLAB_C18) 
....................    #define memcmppgm2ram(a,b,c)   memcmp(a,b,c) 
....................    #define strcmppgm2ram(a,b)      strcmp(a,b) 
....................   #if defined(__PCD__) 
....................    #warning temporary 4.121 fix 
....................    #define memcpypgm2ram(a,b,c)   memcpy(a,b|0x8000,c) 
....................   #else 
....................    #define memcpypgm2ram(a,b,c)   memcpy(a,b,c) 
....................   #endif 
....................    #define strcpypgm2ram(a,b)      strcpy(a,b) 
....................    #define strncpypgm2ram(a,b,c)   strncpy(a,b,c) 
....................    #define strstrrampgm(a,b)      strstr(a,b) 
....................    #define   strlenpgm(a)         strlen(a) 
....................    #define strchrpgm(a,b)         strchr(a,b) 
....................    #define strcatpgm2ram(a,b)      strcat(a,b) 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all 8-bit products 
.................... // (PIC18) 
.................... #if defined(__18CXX) 
....................    #define   __attribute__(a) 
....................  
....................     #define FAR                         far 
....................  
....................    // Microchip C18 specific defines 
....................    #if defined(COMPILER_MPLAB_C18) 
....................        #define ROM                    rom 
....................    #endif 
....................     
....................    // HI TECH PICC-18 specific defines 
....................    #if defined(COMPILER_HITECH_PICC18) 
....................        #define ROM                    const 
....................       #define rom 
....................        #define Nop()                  asm("NOP"); 
....................       #define ClrWdt()            asm("CLRWDT"); 
....................        #define Reset()               asm("RESET"); 
....................    #endif 
....................      
.................... // Definitions that apply to all 16-bit and 32-bit products 
.................... // (PIC24F, PIC24H, dsPIC30F, dsPIC33F, and PIC32) 
.................... #else 
....................    #define   ROM                  const 
....................  
....................    // 16-bit specific defines (PIC24F, PIC24H, dsPIC30F, dsPIC33F) 
....................    #if defined(__C30__) && !defined(__PCD__) 
....................       #define Reset()            asm("reset") 
....................         #define FAR                 __attribute__((far)) 
....................    #endif 
....................  
....................    // 32-bit specific defines (PIC32) 
....................    #if defined(__PIC32MX__) 
....................       #define persistent 
....................       #define far 
....................         #define FAR 
....................       #define Reset()            SoftReset() 
....................       #define ClrWdt()         (WDTCONSET = _WDTCON_WDTCLR_MASK) 
....................  
....................       // MPLAB C Compiler for PIC32 MCUs version 1.04 and below don't have a  
....................       // Nop() function. However, version 1.05 has Nop() declared as _nop(). 
....................       #if !defined(Nop) && (__C32_VERSION__ <= 104) 
....................          #define Nop()            asm("nop") 
....................       #endif 
....................    #endif 
.................... #endif 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "HardwareProfile.h" 
.................... // hardwareprofile.h 
....................  
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #if STACK_USE_CCS_EWLWIFIB || STACK_USE_CCS_EWLWIFIG 
....................  
....................    #bit WF_CS_TRIS1   =     0xF96.1 //E1 
....................    #define WF_CS_TRIS WF_CS_TRIS1 
....................    #bit WF_CS_IO     =  0xF8D.1    //LatE1 
....................    #bit WF_SDI_TRIS  =  0xF94.4    // (TRISCbits.TRISC4) 
....................    #bit WF_SCK_TRIS  =  0xF94.3    // (TRISCbits.TRISC3) 
....................    #bit WF_SDO_TRIS  =  0xF94.5    // (TRISCbits.TRISC5) 
....................    #bit WF_RESET_TRIS=  0xF93.1    //(TRISBbits.TRISB1) 
....................    #bit WF_RESET_IO  =  0xF8A.1     //(LATBbits.LATB1)   
....................    #bit WF_INT_TRIS  =  0xF93.0     // (TRISBbits.TRISB0)  // INT1 
....................    #bit WF_INT_IO    =  0xF81.0   //(PORTBbits.RB0)  
....................    #bit WF_HIBERNATE_TRIS= 0xF93.2  //(TRISBbits.TRISB2)  
....................    #bit   WF_HIBERNATE_IO=  0xF81.2    //(PORTBbits.RB2) 
....................     
....................    #bit WF_INT_EDGE  =  0xFF1.6      //(INTCON2bits.INTEDG0) 
....................    #bit WF_INT_IE    =  0xFF2.4   //(INTCONbits.INT0IE) 
....................    #bit WF_INT_IF    =  0xFF2.1   //(INTCONbits.INT0IF) 
....................    #define WF_SSPBUF  (SSP1BUF) 
....................    #define WF_SPISTAT  (SSP1STATbits) 
....................    #define WF_SPISTATbits SSP1STATbits     //(SSP1STATbits) 
....................    #define WF_SPICON1  (SSP1CON1bits) 
....................    #define WF_SPICON1bits WF_SPICON1    // (SSP1CON1bits) 
....................    #define WF_SPICON2  (SSP1CON2bits) 
....................    #bit WF_SPI_IE    =   0xF9D.3  //(PIE1bits.SSPIE) 
....................    #bit WF_SPI_IP    =   0xF9F.3  //(IPR1bits.SSPIP) 
....................    #bit WF_SPI_IF    =   0xF9E.3  //(PIR1bits.SSPIF) 
....................     
.................... #else 
....................  
.................... //#error define necessary hardware for TCPIP stack 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
.................... /* 
....................    TCPIPConfig.h used by all of CCS's TCP/IP examples. 
....................     
....................    Usually you use a Microchip tool to generate one of these files for 
....................    your projects.  But since we are using this .h for many projects, 
....................    some stuff is conditionally compiled out or commented out, and then 
....................    defined in the application code instead. 
.................... */ 
.................... /********************************************************************* 
....................  * 
....................  *   Microchip TCP/IP Stack Demo Application Configuration Header 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIPConfig.h 
....................  * Dependencies:    Microchip TCP/IP Stack 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.10 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.34 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder      10/04/2006   Original 
....................  * Ken Hesky            07/01/2008  Added ZG2100-specific features 
....................  * SG                   03/25/2009  Added ZGLinkMgrII specific features 
....................  ********************************************************************/ 
.................... #ifndef __TCPIPCONFIG_H 
.................... #define __TCPIPCONFIG_H 
....................  
.................... #include "GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... #ifdef BYTE 
.................... #undef BYTE 
.................... #endif 
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
.................... #include "Compiler.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Compiler and hardware specific definitions 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Compiler.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, PIC24E, dsPIC30F, dsPIC33F,  
....................  *               dsPIC33E, PIC32 
....................  * Compiler:        Microchip C32 v1.00 or higher 
....................  *               Microchip C30 v3.01 or higher 
....................  *               Microchip C18 v3.13 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights  
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and  
....................  * distribute:  
....................  * (i)  the Software when embedded on a Microchip microcontroller or  
....................  *      digital signal controller product ("Device") which is  
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c and  
....................  *      ENC28J60.h ported to a non-Microchip device used in  
....................  *      conjunction with a Microchip ethernet controller for the  
....................  *      sole purpose of interfacing with the ethernet controller.  
....................  * 
....................  * You should refer to the license agreement accompanying this  
....................  * Software for additional information regarding your rights and  
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT  
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT  
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A  
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL  
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR  
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF  
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS  
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER  
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT  
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * 10/03/2006   Original, copied from old Compiler.h 
....................  * 11/07/2007   Reorganized and simplified 
....................  * 03/31/2010   Removed dependency on WORD and DWORD typedefs 
....................  * 04/14/2010   Added defines to uniquely identify each compiler 
....................  ********************************************************************/ 
.................... #ifndef __COMPILER_H 
.................... #define __COMPILER_H 
....................  
.................... // Include proper device header file 
.................... #if defined(__18CXX) && !defined(HI_TECH_C)    
....................    // PIC18 processor with Microchip C18 compiler 
....................     #define COMPILER_MPLAB_C18 
....................     #include <p18cxxx.h> 
.................... #elif defined(__PICC18__) && defined(HI_TECH_C)    
....................    // PIC18 processor with (Microchip) HI-TECH PICC-18 compiler 
....................    #if !defined(__18CXX) 
....................       #define __18CXX 
....................    #endif 
....................     #define COMPILER_HITECH_PICC18 
....................    #include <htc.h> 
.................... #elif (defined(__PIC24F__) || defined(__PIC24FK__)) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Fxxxx.h> 
.................... #elif defined(__PIC24H__) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24H processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Hxxxx.h> 
.................... #elif defined(__PIC24E__) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24E processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Exxxx.h> 
.................... #elif defined(__dsPIC33F__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC33F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p33Fxxxx.h> 
.................... #elif defined(__dsPIC33E__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC33E processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p33Exxxx.h> 
.................... #elif defined(__dsPIC30F__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC30F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p30fxxxx.h> 
.................... #elif defined(__C30__)      // Microchip C30 compiler, but targeting "generic-16bit" processor. 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p30sim.h> 
....................    // Define some useful inline assembly functions which are normally in the  
....................    // processor header files, but absent from the generic p30sim.h file. 
....................    #if !defined(Nop) 
....................       #define Nop()    __builtin_nop() 
....................       #define ClrWdt() {__asm__ volatile ("clrwdt");} 
....................       #define Sleep()  {__asm__ volatile ("pwrsav #0");} 
....................       #define Idle()   {__asm__ volatile ("pwrsav #1");} 
....................    #endif 
.................... #elif defined(__PIC32MX__)   // Microchip C32 compiler 
....................    #if !defined(__C32__) 
....................       #define __C32__ 
....................    #endif 
....................     #define COMPILER_MPLAB_C32 
....................    #include <p32xxxx.h> 
....................    #include <plib.h> 
.................... #else 
....................    #error Unknown processor or compiler.  See Compiler.h 
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... #include <stdlib.h> 
.................... #include <string.h> 
....................  
....................  
.................... // Base RAM and ROM pointer types for given architecture 
.................... #if defined(__PCH__) || defined(__PCD__) 
....................    #define PTR_BASE      unsigned int16 
....................    #define ROM_PTR_BASE   unsigned int32 
.................... #elif defined(__PIC32MX__) 
....................    #define PTR_BASE      unsigned long 
....................    #define ROM_PTR_BASE   unsigned long 
.................... #elif defined(__C30__) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned short 
.................... #elif defined(COMPILER_MPLAB_C18) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned short long 
.................... #elif defined(COMPILER_HITECH_PICC18) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned long 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all except Microchip MPLAB C Compiler for PIC18 MCUs (C18) 
.................... #if !defined(COMPILER_MPLAB_C18) 
....................    #define memcmppgm2ram(a,b,c)   memcmp(a,b,c) 
....................    #define strcmppgm2ram(a,b)      strcmp(a,b) 
....................   #if defined(__PCD__) 
....................    #warning temporary 4.121 fix 
....................    #define memcpypgm2ram(a,b,c)   memcpy(a,b|0x8000,c) 
....................   #else 
....................    #define memcpypgm2ram(a,b,c)   memcpy(a,b,c) 
....................   #endif 
....................    #define strcpypgm2ram(a,b)      strcpy(a,b) 
....................    #define strncpypgm2ram(a,b,c)   strncpy(a,b,c) 
....................    #define strstrrampgm(a,b)      strstr(a,b) 
....................    #define   strlenpgm(a)         strlen(a) 
....................    #define strchrpgm(a,b)         strchr(a,b) 
....................    #define strcatpgm2ram(a,b)      strcat(a,b) 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all 8-bit products 
.................... // (PIC18) 
.................... #if defined(__18CXX) 
....................    #define   __attribute__(a) 
....................  
....................     #define FAR                         far 
....................  
....................    // Microchip C18 specific defines 
....................    #if defined(COMPILER_MPLAB_C18) 
....................        #define ROM                    rom 
....................    #endif 
....................     
....................    // HI TECH PICC-18 specific defines 
....................    #if defined(COMPILER_HITECH_PICC18) 
....................        #define ROM                    const 
....................       #define rom 
....................        #define Nop()                  asm("NOP"); 
....................       #define ClrWdt()            asm("CLRWDT"); 
....................        #define Reset()               asm("RESET"); 
....................    #endif 
....................      
.................... // Definitions that apply to all 16-bit and 32-bit products 
.................... // (PIC24F, PIC24H, dsPIC30F, dsPIC33F, and PIC32) 
.................... #else 
....................    #define   ROM                  const 
....................  
....................    // 16-bit specific defines (PIC24F, PIC24H, dsPIC30F, dsPIC33F) 
....................    #if defined(__C30__) && !defined(__PCD__) 
....................       #define Reset()            asm("reset") 
....................         #define FAR                 __attribute__((far)) 
....................    #endif 
....................  
....................    // 32-bit specific defines (PIC32) 
....................    #if defined(__PIC32MX__) 
....................       #define persistent 
....................       #define far 
....................         #define FAR 
....................       #define Reset()            SoftReset() 
....................       #define ClrWdt()         (WDTCONSET = _WDTCON_WDTCLR_MASK) 
....................  
....................       // MPLAB C Compiler for PIC32 MCUs version 1.04 and below don't have a  
....................       // Nop() function. However, version 1.05 has Nop() declared as _nop(). 
....................       #if !defined(Nop) && (__C32_VERSION__ <= 104) 
....................          #define Nop()            asm("nop") 
....................       #endif 
....................    #endif 
.................... #endif 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... // ======================================================================= 
.................... //   Application Options 
.................... // ======================================================================= 
....................  
.................... /* Application Level Module Selection 
....................  *   Uncomment or comment the following lines to enable or 
....................  *   disabled the following high-level application modules. 
....................  */ 
.................... //#define STACK_USE_UART               // Application demo using UART for IP address display and stack configuration 
.................... //#define STACK_USE_UART2TCP_BRIDGE      // UART to TCP Bridge application example 
.................... //#define STACK_USE_IP_GLEANING 
.................... //#define STACK_USE_ICMP_SERVER         // Ping query and response capability 
.................... //#define STACK_USE_ICMP_CLIENT         // Ping transmission capability 
.................... //#define STACK_USE_HTTP_SERVER         // Old HTTP server 
.................... //#define STACK_USE_HTTP2_SERVER         // New HTTP server with POST, Cookies, Authentication, etc. 
.................... //#define STACK_USE_SSL_SERVER         // SSL server socket support (Requires SW300052) 
.................... //#define STACK_USE_SSL_CLIENT         // SSL client socket support (Requires SW300052) 
.................... //#define STACK_USE_AUTO_IP               // Dynamic link-layer IP address automatic configuration protocol 
.................... //#define STACK_USE_DHCP_CLIENT         // Dynamic Host Configuration Protocol client for obtaining IP address and other parameters 
.................... //#define STACK_USE_DHCP_SERVER         // Single host DHCP server 
.................... //#define STACK_USE_FTP_SERVER         // File Transfer Protocol (old) 
.................... //#define STACK_USE_SMTP_CLIENT         // Simple Mail Transfer Protocol for sending email 
.................... //#define STACK_USE_SNMP_SERVER         // Simple Network Management Protocol v2C Community Agent 
.................... //#define STACK_USE_SNMPV3_SERVER         // Simple Network Management Protocol v3 Agent 
.................... //#define STACK_USE_TFTP_CLIENT         // Trivial File Transfer Protocol client 
.................... //#define STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE   // HTTP Client example in GenericTCPClient.c 
.................... //#define STACK_USE_GENERIC_TCP_SERVER_EXAMPLE   // ToUpper server example in GenericTCPServer.c 
.................... //#define STACK_USE_TELNET_SERVER         // Telnet server 
.................... //#define STACK_USE_ANNOUNCE            // Microchip Embedded Ethernet Device Discoverer server/client 
.................... //#define STACK_USE_DNS               // Domain Name Service Client for resolving hostname strings to IP addresses 
.................... //#define STACK_USE_DNS_SERVER         // Domain Name Service Server for redirection to the local device 
.................... //#define STACK_USE_NBNS               // NetBIOS Name Service Server for repsonding to NBNS hostname broadcast queries 
.................... //#define STACK_USE_REBOOT_SERVER         // Module for resetting this PIC remotely.  Primarily useful for a Bootloader. 
.................... //#define STACK_USE_SNTP_CLIENT         // Simple Network Time Protocol for obtaining current date/time from Internet 
.................... //#define STACK_USE_UDP_PERFORMANCE_TEST   // Module for testing UDP TX performance characteristics.  NOTE: Enabling this will cause a huge amount of UDP broadcast packets to flood your network on the discard port.  Use care when enabling this on production networks, especially with VPNs (could tunnel broadcast traffic across a limited bandwidth connection). 
.................... //#define STACK_USE_TCP_PERFORMANCE_TEST   // Module for testing TCP TX performance characteristics 
.................... //#define STACK_USE_DYNAMICDNS_CLIENT      // Dynamic DNS client updater module 
.................... //#define STACK_USE_BERKELEY_API         // Berekely Sockets APIs are available 
.................... //#define STACK_USE_ZEROCONF_LINK_LOCAL   // Zeroconf IPv4 Link-Local Addressing 
.................... //#define STACK_USE_ZEROCONF_MDNS_SD      // Zeroconf mDNS and mDNS service discovery 
....................  
....................  
.................... // ======================================================================= 
.................... //   Data Storage Options 
.................... // ======================================================================= 
....................  
.................... /* MPFS Configuration 
....................  *   MPFS is automatically included when required for other 
....................  *   applications.  If your custom application requires it 
....................  *   otherwise, uncomment the appropriate selection. 
....................  */ 
.................... //#define STACK_USE_MPFS 
.................... //#define STACK_USE_MPFS2 
....................  
.................... /* MPFS Storage Location 
....................  *   If html pages are stored in internal program memory, 
....................  *   comment both MPFS_USE_EEPROM and MPFS_USE_SPI_FLASH, then 
....................  *   include an MPFS image (.c or .s file) in the project. 
....................  *   If html pages are stored in external memory, uncomment the 
....................  *   appropriate definition. 
....................  * 
....................  *   Supported serial flash parts include the SST25VFxxxB series. 
....................  */ 
.................... //#define MPFS_USE_EEPROM 
.................... //#define MPFS_USE_SPI_FLASH 
....................  
.................... /* EEPROM Addressing Selection 
....................  *   If using the 1Mbit EEPROM, uncomment this line 
....................  */ 
.................... //#define USE_EEPROM_25LC1024 
....................  
.................... /* EEPROM Reserved Area 
....................  *   Number of EEPROM bytes to be reserved before MPFS storage starts. 
....................  *   These bytes host application configurations such as IP Address, 
....................  *   MAC Address, and any other required variables. 
....................  * 
....................  *   For MPFS Classic, this setting must match the Reserved setting 
....................  *    on the Advanced Settings page of the MPFS2 Utility. 
....................  */ 
.................... //#define MPFS_RESERVE_BLOCK            #error do this 
....................  
.................... /* MPFS File Handles 
....................  *   Maximum number of simultaneously open MPFS2 files. 
....................  *   For MPFS Classic, this has no effect. 
....................  */ 
.................... //#define MAX_MPFS_HANDLES            (7ul) 
....................  
....................  
.................... // ======================================================================= 
.................... //   Network Addressing Options 
.................... // ======================================================================= 
....................  
.................... /* Default Network Configuration 
....................  *   These settings are only used if data is not found in EEPROM. 
....................  *   To clear EEPROM, hold BUTTON0, reset the board, and continue 
....................  *   holding until the LEDs flash.  Release, and reset again. 
....................  */ 
.................... #define MY_DEFAULT_HOST_NAME            "CCS_EXAMPLES" 
....................  
.................... /*#define MY_DEFAULT_MAC_BYTE1            (0x00)   // Use the default of 00-04-A3-00-00-00 
.................... #define MY_DEFAULT_MAC_BYTE2            (0x04)   // if using an ENCX24J600, MRF24WB0M, or 
.................... #define MY_DEFAULT_MAC_BYTE3            (0xA3)   // PIC32MX6XX/7XX internal Ethernet  
.................... #define MY_DEFAULT_MAC_BYTE4            (0x00)   // controller and wish to use the  
.................... #define MY_DEFAULT_MAC_BYTE5            (0x00)   // internal factory programmed MAC 
.................... #define MY_DEFAULT_MAC_BYTE6            (0x00)   // address instead. */ 
....................  
.................... #define MY_DEFAULT_MAC_BYTE1            (0x00)   // Use the default of 00-04-A3-00-00-00 
.................... #define MY_DEFAULT_MAC_BYTE2            (0x20)   // if using an ENCX24J600, MRF24WB0M, or 
.................... #define MY_DEFAULT_MAC_BYTE3            (0x30)   // PIC32MX6XX/7XX internal Ethernet  
.................... #define MY_DEFAULT_MAC_BYTE4            (0x40)   // controller and wish to use the  
.................... #define MY_DEFAULT_MAC_BYTE5            (0x50)   // internal factory programmed MAC 
.................... #define MY_DEFAULT_MAC_BYTE6            (0x60)   // address instead. 
....................  
.................... #define MY_DEFAULT_IP_ADDR_BYTE1        (192ul) 
.................... #define MY_DEFAULT_IP_ADDR_BYTE2        (168ul) 
.................... #define MY_DEFAULT_IP_ADDR_BYTE3        (100ul) 
.................... #define MY_DEFAULT_IP_ADDR_BYTE4        (120ul) 
....................  
.................... #define MY_DEFAULT_MASK_BYTE1           (255ul) 
.................... #define MY_DEFAULT_MASK_BYTE2           (255ul) 
.................... #define MY_DEFAULT_MASK_BYTE3           (255ul) 
.................... #define MY_DEFAULT_MASK_BYTE4           (0ul) 
....................  
.................... #define MY_DEFAULT_GATE_BYTE1           (192ul) 
.................... #define MY_DEFAULT_GATE_BYTE2           (168ul) 
.................... #define MY_DEFAULT_GATE_BYTE3           (100ul) 
.................... #define MY_DEFAULT_GATE_BYTE4           (1ul) 
....................  
.................... #define MY_DEFAULT_PRIMARY_DNS_BYTE1   (192ul) 
.................... #define MY_DEFAULT_PRIMARY_DNS_BYTE2   (168ul) 
.................... #define MY_DEFAULT_PRIMARY_DNS_BYTE3   (100ul) 
.................... #define MY_DEFAULT_PRIMARY_DNS_BYTE4   (1ul) 
....................  
.................... #define MY_DEFAULT_SECONDARY_DNS_BYTE1   (0ul) 
.................... #define MY_DEFAULT_SECONDARY_DNS_BYTE2   (0ul) 
.................... #define MY_DEFAULT_SECONDARY_DNS_BYTE3   (0ul) 
.................... #define MY_DEFAULT_SECONDARY_DNS_BYTE4   (0ul) 
....................  
.................... // ======================================================================= 
.................... //   PIC32MX7XX/6XX MAC Layer Options 
.................... //   If not using a PIC32MX7XX/6XX device, ignore this section. 
.................... // ======================================================================= 
.................... /*#define   ETH_CFG_LINK         0      // set to 1 if you need to config the link to specific following parameters 
....................                               // otherwise the default connection will be attempted 
....................                               // depending on the selected PHY 
....................    #define   ETH_CFG_AUTO      1      // use auto negotiation 
....................    #define   ETH_CFG_10         1      // use/advertise 10 Mbps capability 
....................    #define   ETH_CFG_100         1      // use/advertise 100 Mbps capability 
....................    #define   ETH_CFG_HDUPLEX      1      // use/advertise half duplex capability 
....................    #define   ETH_CFG_FDUPLEX      1      // use/advertise full duplex capability 
....................    #define   ETH_CFG_AUTO_MDIX   1      // use/advertise auto MDIX capability 
....................    #define   ETH_CFG_SWAP_MDIX   1      // use swapped MDIX. else normal MDIX 
....................  
.................... #define EMAC_TX_DESCRIPTORS      2      // number of the TX descriptors to be created 
.................... #define EMAC_RX_DESCRIPTORS      8      // number of the RX descriptors and RX buffers to be created 
....................  
.................... #define   EMAC_RX_BUFF_SIZE      1536   // size of a RX buffer. should be multiple of 16 
....................                               // this is the size of all receive buffers processed by the ETHC 
....................                               // The size should be enough to accomodate any network received packet 
....................                               // If the packets are larger, they will have to take multiple RX buffers 
....................                               // The current implementation does not handle this situation right now and the packet is discarded. 
.................... */ 
....................  
.................... // ======================================================================= 
.................... //   Transport Layer Options 
.................... // ======================================================================= 
....................  
.................... /* Transport Layer Configuration 
....................  *   The following low level modules are automatically enabled 
....................  *   based on module selections above.  If your custom module 
....................  *   requires them otherwise, enable them here. 
....................  */ 
.................... //#define STACK_USE_TCP 
.................... //#define STACK_USE_UDP 
....................  
.................... /* Client Mode Configuration 
....................  *   Uncomment following line if this stack will be used in CLIENT 
....................  *   mode.  In CLIENT mode, some functions specific to client operation 
....................  *   are enabled. 
....................  */ 
.................... #define STACK_CLIENT_MODE 
....................  
.................... /* TCP Socket Memory Allocation 
....................  *   TCP needs memory to buffer incoming and outgoing data.  The 
....................  *   amount and medium of storage can be allocated on a per-socket 
....................  *   basis using the example below as a guide. 
....................  */ 
....................    // Allocate how much total RAM (in bytes) you want to allocate 
....................    // for use by your TCP TCBs, RX FIFOs, and TX FIFOs. 
....................   #ifndef TCP_ETH_RAM_SIZE 
....................    #define TCP_ETH_RAM_SIZE                 (8192ul) 
....................   #endif 
....................    #define TCP_PIC_RAM_SIZE                 (0ul) 
....................    #define TCP_SPI_RAM_SIZE                 (0ul) 
....................    #define TCP_SPI_RAM_BASE_ADDRESS         (0x00) 
....................  
....................    // Define names of socket types 
....................    #define TCP_SOCKET_TYPES 
....................       #define TCP_PURPOSE_GENERIC_TCP_CLIENT 0 
....................       #define TCP_PURPOSE_GENERIC_TCP_SERVER 1 
....................       #define TCP_PURPOSE_TELNET 2 
....................       #define TCP_PURPOSE_FTP_COMMAND 3 
....................       #define TCP_PURPOSE_FTP_DATA 4 
....................       #define TCP_PURPOSE_TCP_PERFORMANCE_TX 5 
....................       #define TCP_PURPOSE_TCP_PERFORMANCE_RX 6 
....................       #define TCP_PURPOSE_UART_2_TCP_BRIDGE 7 
....................       #define TCP_PURPOSE_HTTP_SERVER 8 
....................       #define TCP_PURPOSE_DEFAULT 9 
....................       #define TCP_PURPOSE_BERKELEY_SERVER 10 
....................       #define TCP_PURPOSE_BERKELEY_CLIENT 11 
....................    #define END_OF_TCP_SOCKET_TYPES 
....................  
....................    //changed the check here because it was set up for linking, not static compiling 
....................       typedef struct 
....................       { 
....................          BYTE vSocketPurpose; 
....................          BYTE vMemoryMedium; 
....................          WORD wTXBufferSize; 
....................          WORD wRXBufferSize;       
....................       } TCPSocketInitializer_t; 
....................      #if defined(STACK_USE_TCP) && defined(TCP_CONFIGURATION) 
....................       //ccs bug, wouldn't let me extern empty brace 
....................       extern TCPSocketInitializer_t TCPSocketInitializer[TCP_CONFIGURATION]; 
....................      #endif 
....................    #if defined(STACK_USE_TCP) && !defined(TCP_CONFIGURATION) 
....................       // Define what types of sockets are needed, how many of 
....................       // each to include, where their TCB, TX FIFO, and RX FIFO 
....................       // should be stored, and how big the RX and TX FIFOs should 
....................       // be.  Making this initializer bigger or smaller defines 
....................       // how many total TCP sockets are available. 
....................       // 
....................       // Each socket requires up to 56 bytes of PIC RAM and 
....................       // 48+(TX FIFO size)+(RX FIFO size) bytes of TCP_*_RAM each. 
....................       // 
....................       // Note: The RX FIFO must be at least 1 byte in order to 
....................       // receive SYN and FIN messages required by TCP.  The TX 
....................       // FIFO can be zero if desired. 
....................       #define TCP_CONFIGURATION  1 
....................       //REMOVED ROM prefix -Tim 
....................       TCPSocketInitializer_t TCPSocketInitializer[TCP_CONFIGURATION] = 
....................       { 
....................           {TCP_PURPOSE_DEFAULT, TCP_ETH_RAM, 250, 250} 
....................       }; 
....................       #define END_OF_TCP_CONFIGURATION 
....................    #endif  
....................  
.................... #ifndef MAX_HTTP_CONNECTIONS 
....................    #define  MAX_HTTP_CONNECTIONS 1 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
....................    #define MAX_UDP_SOCKETS 7 
.................... #endif    
....................     
.................... /* UDP Socket Configuration 
....................  *   Define the maximum number of available UDP Sockets, and whether 
....................  *   or not to include a checksum on packets being transmitted. 
....................  */ 
.................... //#define MAX_UDP_SOCKETS           
.................... //#define UDP_USE_TX_CHECKSUM      // This slows UDP TX performance by nearly 50%, except when using the ENCX24J600 or PIC32MX6XX/7XX, which have a super fast DMA and incurs virtually no speed pentalty. 
....................  
....................  
.................... /* Berkeley API Sockets Configuration 
....................  *   Note that each Berkeley socket internally uses one TCP or UDP socket 
....................  *   defined by MAX_UDP_SOCKETS and the TCPSocketInitializer[] array. 
....................  *   Therefore, this number MUST be less than or equal to MAX_UDP_SOCKETS + the 
....................  *   number of TCP sockets defined by the TCPSocketInitializer[] array 
....................  *   (i.e. sizeof(TCPSocketInitializer)/sizeof(TCPSocketInitializer[0])). 
....................  *   This define has no effect if STACK_USE_BERKELEY_API is not defined and 
....................  *   Berkeley Sockets are disabled.  Set this value as low as your application 
....................  *   requires to avoid waisting RAM. 
....................  */ 
.................... //#define BSD_SOCKET_COUNT (5u) 
....................  
....................  
.................... // ======================================================================= 
.................... //   Application-Specific Options 
.................... // ======================================================================= 
....................  
.................... // -- HTTP2 Server options ----------------------------------------------- 
....................  
....................    // Maximum numbers of simultaneous HTTP connections allowed. 
....................    // Each connection consumes 2 bytes of RAM and a TCP socket 
....................    //#define MAX_HTTP_CONNECTIONS   (2u) 
....................  
....................    // Optional setting to use PIC RAM instead of Ethernet/Wi-Fi RAM for 
....................    // storing HTTP Connection Context variables (HTTP_CONN structure for each  
....................    // HTTP connection).  Undefining this macro results in the Ethernet/Wi-Fi  
....................    // RAM being used (minimum PIC RAM usage, lower performance).  Defining  
....................    // this macro results in PIC RAM getting used (higher performance, but uses  
....................    // PIC RAM).  This option should not be enabled on PIC18 devices.  The  
....................    // performance increase of having this option defined is only apparent when  
....................    // the HTTP server is servicing multiple connections simultaneously. 
....................    //#define HTTP_SAVE_CONTEXT_IN_PIC_RAM 
....................  
....................    // Indicate what file to serve when no specific one is requested 
....................    //#define HTTP_DEFAULT_FILE      "index.htm" 
....................    //#define HTTPS_DEFAULT_FILE      "index.htm" 
....................    //#define HTTP_DEFAULT_LEN      (10u)      // For buffer overrun protection. 
....................                                     // Set to longest length of above two strings. 
....................  
....................    // Configure MPFS over HTTP updating 
....................    // Comment this line to disable updating via HTTP 
....................    //#define HTTP_MPFS_UPLOAD      "mpfsupload" 
....................    //#define HTTP_MPFS_UPLOAD_REQUIRES_AUTH   // Require password for MPFS uploads 
....................       // Certain firewall and router combinations cause the MPFS2 Utility to fail 
....................       // when uploading.  If this happens, comment out this definition. 
....................  
....................    // Define which HTTP modules to use 
....................    // If not using a specific module, comment it to save resources 
....................    //#define HTTP_USE_POST               // Enable POST support 
....................    //#define HTTP_USE_COOKIES            // Enable cookie support 
....................    //#define HTTP_USE_AUTHENTICATION         // Enable basic authentication support 
....................  
....................    //#define HTTP_NO_AUTH_WITHOUT_SSL      // Uncomment to require SSL before requesting a password 
....................  
....................     // Define the listening port for the HTTP server 
....................      //#define HTTP_PORT               (80u) 
....................     
....................     // Define the listening port for the HTTPS server (if STACK_USE_SSL_SERVER is enabled) 
....................    //#define HTTPS_PORT            (443u) 
....................     
....................     // Define the maximum data length for reading cookie and GET/POST arguments (bytes) 
....................    //#define HTTP_MAX_DATA_LEN      (%HTTP_MAX_DATA_LEN%) 
....................     
....................     // Define the minimum number of bytes free in the TX FIFO before executing callbacks 
....................    //#define HTTP_MIN_CALLBACK_FREE   (16u) 
.................... // -- SSL Options -------------------------------------------------------- 
....................  
....................    //#define MAX_SSL_CONNECTIONS      (2ul)   // Maximum connections via SSL 
....................    //#define MAX_SSL_SESSIONS      (2ul)   // Max # of cached SSL sessions 
....................    //#define MAX_SSL_BUFFERS         (4ul)   // Max # of SSL buffers (2 per socket) 
....................    //#define MAX_SSL_HASHES         (5ul)   // Max # of SSL hashes  (2 per, plus 1 to avoid deadlock) 
....................  
....................    // Bits in SSL RSA key.  This parameter is used for SSL sever 
....................    // connections only.  The only valid value is 512 bits (768 and 1024 
....................    // bits do not work at this time).  Note, however, that SSL client 
....................    // operations do currently work up to 1024 bit RSA key length. 
....................    #define SSL_RSA_KEY_SIZE      (512ul) 
....................  
....................  
.................... // -- Telnet Options ----------------------------------------------------- 
....................  
....................    // Number of simultaneously allowed Telnet sessions.  Note that you 
....................    // must have an equal number of TCP_PURPOSE_TELNET type TCP sockets 
....................    // declared in the TCPSocketInitializer[] array above for multiple 
....................    // connections to work.  If fewer sockets are available than this 
....................    // definition, then the the lesser of the two quantities will be the 
....................    // actual limit. 
....................    //#define MAX_TELNET_CONNECTIONS   (1u) 
....................  
....................    // Default local listening port for the Telnet server.  Port 23 is the 
....................    // protocol default. 
....................    //#define TELNET_PORT            23 
....................  
....................    // Default local listening port for the Telnet server when SSL secured. 
....................    // Port 992 is the telnets protocol default. 
....................    //#define TELNETS_PORT         992 
....................  
....................    // Force all connecting clients to be SSL secured and connected via 
....................    // TELNETS_PORT.  Connections on port TELNET_PORT will be ignored.  If 
....................    // STACK_USE_SSL_SERVER is undefined, this entire setting is ignored 
....................    // (server will accept unsecured connections on TELNET_PORT and won't even 
....................    // listen on TELNETS_PORT). 
....................    //#define TELNET_REJECT_UNSECURED 
....................  
....................    // Default username and password required to login to the Telnet server. 
....................    //#define TELNET_USERNAME         "admin" 
....................    //#define TELNET_PASSWORD         "microchip" 
....................  
....................  
.................... // -- SNMP Options ------------------------------------------------------- 
....................  
....................    // Comment following line if SNMP TRAP support is needed 
....................    //#define SNMP_TRAP_DISABLED 
....................  
....................    //#define SNMP_STACK_USE_V2_TRAP 
....................    #if defined(STACK_USE_SNMPV3_SERVER) 
....................       #define SNMP_V1_V2_TRAP_WITH_SNMPV3 
....................    #endif 
....................  
....................    // This is the maximum length for community string. 
....................    // Application must ensure that this length is observed. 
....................    // SNMP module adds one byte extra after SNMP_COMMUNITY_MAX_LEN 
....................    // for adding '\0' NULL character. 
....................    //#define SNMP_COMMUNITY_MAX_LEN     (8u) 
....................    //#define SNMP_MAX_COMMUNITY_SUPPORT   (3u) 
....................    //#define NOTIFY_COMMUNITY_LEN      (SNMP_COMMUNITY_MAX_LEN) 
....................  
....................    // Default SNMPv2C community names.  These can be overridden at run time if 
....................    // alternate strings are present in external EEPROM or Flash (actual 
....................    // strings are stored in AppConfig.readCommunity[] and 
....................    // AppConfig.writeCommunity[] arrays).  These strings are case sensitive. 
....................    // An empty string means disabled (not matchable). 
....................    // For application security, these default community names should not be 
....................    // used, but should all be disabled to force the end user to select unique 
....................    // community names.  These defaults are provided only to make it easier to 
....................    // start development.  Specifying more strings than 
....................    // SNMP_MAX_COMMUNITY_SUPPORT will result in the later strings being 
....................    // ignored (but still wasting program memory).  Specifying fewer strings is 
....................    // legal, as long as at least one is present.  A string larger than 
....................    // SNMP_COMMUNITY_MAX_LEN bytes will be ignored. 
....................    //#define SNMP_READ_COMMUNITIES      {"public", "read", ""} 
....................    //#define END_OF_SNMP_READ_COMMUNITIES 
....................    //#define SNMP_WRITE_COMMUNITIES        {"private", "write", "public"} 
....................    //#define END_OF_SNMP_WRITE_COMMUNITIES 
.................... #endif 
....................  
....................  
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definitions 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    Compiler.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,  
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,  
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook/CCS      WIFI networkType added to AppConfig, hopefully 
....................  *                         this doesn't conflict with EZ_CONFIG_STORE.  
....................  *                      WIFI adhocBehavior added to AppConfig. 
....................  ********************************************************************/ 
.................... #ifndef __STACK_TSK_H 
.................... #define __STACK_TSK_H 
....................  
.................... #if defined (WF_CS_TRIS) 
....................     #include "WF_Config.h"      
.................... #endif 
....................  
.................... // Check for potential configuration errors in "TCPIPConfig.h" 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 ) 
.................... #error Invalid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... // Check for potential configuration errors in "TCPIPConfig.h" 
.................... #if (MAX_HTTP_CONNECTIONS <= 0 || MAX_HTTP_CONNECTIONS > 255 ) 
.................... #error Invalid MAX_HTTP_CONNECTIONS value specified. 
.................... #endif 
....................  
.................... // Structure to contain a MAC address 
.................... typedef struct __attribute__((__packed__)) 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... // Definition to represent an IP address 
.................... #define IP_ADDR      DWORD_VAL 
....................  
.................... // Address structure for a node 
.................... typedef struct __attribute__((__packed__)) 
.................... { 
....................     IP_ADDR     IPAddr; 
....................     MAC_ADDR    MACAddr; 
.................... } NODE_INFO; 
....................  
.................... // Application-dependent structure used to contain address information 
.................... typedef struct __attribute__((__packed__)) appConfigStruct  
.................... { 
....................    IP_ADDR      MyIPAddr;               // IP address 
....................    IP_ADDR      MyMask;                 // Subnet mask 
....................    IP_ADDR      MyGateway;              // Default Gateway 
....................    IP_ADDR      PrimaryDNSServer;       // Primary DNS Server 
....................    IP_ADDR      SecondaryDNSServer;     // Secondary DNS Server 
....................    IP_ADDR      DefaultIPAddr;          // Default IP address 
....................    IP_ADDR      DefaultMask;            // Default subnet mask 
....................    BYTE      NetBIOSName[16];        // NetBIOS name 
....................    struct 
....................    { 
....................       unsigned char : 6; 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    } Flags;                            // Flag structure 
....................    MAC_ADDR   MyMACAddr;              // Application MAC address 
....................  
.................... #if defined(WF_CS_TRIS) 
....................    BYTE      MySSID[32];             // Wireless SSID (if using MRF24W) 
....................    BYTE        SsidLength;             // number of bytes in SSID 
....................    BYTE        SecurityMode;           // WF_SECURITY_OPEN or one of the other security modes 
....................    BYTE        SecurityKey[64];        // WiFi Security key, or passphrase.    
....................    BYTE        SecurityKeyLength;      // number of bytes in security key (can be 0) 
....................    BYTE        WepKeyIndex;            // WEP key index (only valid for WEP) 
....................    BYTE        networkType; 
....................    BYTE        adhocBehavior; 
....................     #if defined(EZ_CONFIG_STORE) // WLAN configuration data stored to NVM 
....................     BYTE        dataValid; 
....................     //BYTE        networkType; 
....................     BYTE        saveSecurityInfo;       // Save 32-byte PSK 
....................     #endif 
.................... #endif 
....................     
.................... #if defined(STACK_USE_SNMP_SERVER) || defined(STACK_USE_SNMPV3_SERVER) 
....................    // SNMPv2C Read community names 
....................    // SNMP_COMMUNITY_MAX_LEN (8) + 1 null termination byte 
....................    BYTE readCommunity[SNMP_MAX_COMMUNITY_SUPPORT][SNMP_COMMUNITY_MAX_LEN+1];  
....................  
....................    // SNMPv2C Write community names 
....................    // SNMP_COMMUNITY_MAX_LEN (8) + 1 null termination byte 
....................    BYTE writeCommunity[SNMP_MAX_COMMUNITY_SUPPORT][SNMP_COMMUNITY_MAX_LEN+1]; 
....................  
....................    UINT32 SnmpEngineBootRcrd; 
.................... #endif 
....................  
.................... } APP_CONFIG; 
....................  
.................... #ifndef THIS_IS_STACK_APPLICATION 
....................     extern APP_CONFIG AppConfig; 
.................... #endif 
....................  
....................  
.................... void StackInit(void); 
.................... void StackTask(void); 
.................... void StackApplications(void); 
.................... #endif 
....................  
.................... #include "TCPIP Stack/Helpers.h" 
.................... /********************************************************************* 
....................  Header file for Helpers.c 
....................   
....................  FileName:      Helpers.h 
....................  Dependencies:  See INCLUDES section 
....................  Processor:     PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:      Microchip C18, C30, C32 
....................  Company:       Microchip Technology, Inc. 
....................  
....................  Software License Agreement 
....................  
....................  Copyright (C) 2002-2011 Microchip Technology Inc.  All rights 
....................  reserved. 
....................  
....................  Microchip licenses to you the right to use, modify, copy, and 
....................  distribute: 
....................  (i)  the Software when embedded on a Microchip microcontroller or 
....................       digital signal controller product ("Device") which is 
....................       integrated into Licensee's product; or 
....................  (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
.................... 		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
.................... 		used in conjunction with a Microchip ethernet controller for 
.................... 		the sole purpose of interfacing with the ethernet controller. 
....................  
....................  You should refer to the license agreement accompanying this 
....................  Software for additional information regarding your rights and 
....................  obligations. 
....................  
....................  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  
....................  ******************************************************************** 
....................  File Description: 
....................   
....................  Change History: 
....................   
....................   Rev         Description 
....................   ----------  ------------------------------------------------------- 
....................   1.0 - 5.31  Initial release 
....................   5.36        Updated compile time check for ultoa(); 
....................  ********************************************************************/ 
.................... #ifndef __HELPERS_H 
.................... #define __HELPERS_H 
....................  
....................  
.................... #if !defined(__18CXX) || defined(HI_TECH_C) 
.................... 	char *strupr(char* s); 
.................... #endif 
....................  
.................... // Implement consistent ultoa() function 
.................... #if (defined(__PIC32MX__) && (__C32_VERSION__ < 112)) || (defined (__C30__) && (__C30_VERSION__ < 325)) || defined(__C30_LEGACY_LIBC__) || defined(__C32_LEGACY_LIBC__) 
.................... 	// C32 < 1.12 and C30 < v3.25 need this 2 parameter stack implemented function 
.................... 	void ultoa(DWORD Value, BYTE* Buffer); 
.................... #elif defined(__18CXX) && !defined(HI_TECH_C) 
.................... 	// C18 already has a 2 parameter ultoa() function 
.................... 	#include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #else 
.................... 	// HI-TECH PICC-18 PRO 9.63, C30 v3.25+, and C32 v1.12+ already have a ultoa() stdlib  
.................... 	// library function, but it requires 3 parameters.  The TCP/IP Stack  
.................... 	// assumes the C18 style 2 parameter ultoa() function, so we shall  
.................... 	// create a macro to automatically convert the code. 
.................... 	#include <stdlib.h> 
.................... 	#define ultoa(val,buf)	ultoa((char*)(buf),(val),10) 
.................... #endif 
....................  
.................... #if defined(DEBUG) 
.................... 	#define DebugPrint(a)	{putrsUART(a);} 
.................... #else 
.................... 	#define DebugPrint(a) 
.................... #endif 
....................  
.................... DWORD	LFSRSeedRand(DWORD dwSeed); 
.................... WORD	LFSRRand(void); 
.................... DWORD	GenerateRandomDWORD(void); 
.................... void 	uitoa(WORD Value, BYTE* Buffer); 
.................... void 	UnencodeURL(BYTE* URL); 
.................... WORD 	Base64Decode(BYTE* cSourceData, WORD wSourceLen, BYTE* cDestData, WORD wDestLen); 
.................... WORD	Base64Encode(BYTE* cSourceData, WORD wSourceLen, BYTE* cDestData, WORD wDestLen); 
.................... BOOL	StringToIPAddress(BYTE* str, IP_ADDR* IPAddress); 
.................... BYTE 	ReadStringUART(BYTE* Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
.................... signed char stricmppgm2ram(BYTE* a, ROM BYTE* b); 
.................... char * 	strnchr(const char *searchString, size_t count, char c); 
.................... size_t  strncpy_m(char* destStr, size_t destSize, int nStrings, ...); 
....................  
.................... #if defined(__18CXX) 
.................... 	BOOL	ROMStringToIPAddress(ROM BYTE* str, IP_ADDR* IPAddress); 
.................... #else 
.................... 	// Non-ROM variant for C30 and C32 
.................... 	#define ROMStringToIPAddress(a,b)	StringToIPAddress((BYTE*)a,b) 
.................... #endif 
....................  
....................  
.................... WORD    swaps(WORD v); 
....................  
.................... #if defined(__C32__) 
.................... DWORD   __attribute__((nomips16)) swapl(DWORD v); 
.................... #else 
.................... DWORD   swapl(DWORD v); 
.................... #endif 
....................  
.................... WORD    CalcIPChecksum(BYTE* buffer, WORD len); 
....................  
....................  
.................... #if defined(__18CXX) 
.................... 	DWORD leftRotateDWORD(DWORD val, BYTE bits); 
.................... #else 
.................... 	// Rotations are more efficient in C30 and C32 
.................... 	#define leftRotateDWORD(x, n) (((x) << (n)) | ((x) >> (32-(n)))) 
.................... #endif 
....................  
.................... void FormatNetBIOSName(BYTE Name[16]); 
....................  
....................  
.................... // Protocols understood by the ExtractURLFields() function.  IMPORTANT: If you  
.................... // need to reorder these (change their constant values), you must also reorder  
.................... // the constant arrays in ExtractURLFields(). 
.................... typedef enum 
.................... { 
.................... 	PROTOCOL_HTTP = 0u, 
.................... 	PROTOCOL_HTTPS, 
.................... 	PROTOCOL_MMS, 
.................... 	PROTOCOL_RTSP 
.................... } PROTOCOLS; 
....................  
.................... BYTE ExtractURLFields(BYTE *vURL, PROTOCOLS *protocol, BYTE *vUsername, WORD *wUsernameLen, BYTE *vPassword, WORD *wPasswordLen, BYTE *vHostname, WORD *wHostnameLen, WORD *wPort, BYTE *vFilePath, WORD *wFilePathLen); 
.................... SHORT Replace(BYTE *vExpression, ROM BYTE *vFind, ROM BYTE *vReplacement, WORD wMaxLen, BOOL bSearchCaseInsensitive); 
....................  
.................... #endif 
....................  
.................... #include "TCPIP Stack/Delay.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  General Delay rouines 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Delay.h 
....................  * Dependencies:    Compiler.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/9/02  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     6/10/02 Fixed C18 ms and us routines 
....................  * Howard Schlunder		4/04/06	Changed for C30 
....................  ********************************************************************/ 
.................... #ifndef __DELAY_H 
.................... #define __DELAY_H 
....................  
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
.................... #if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 	#include <delays.h> 
.................... #endif 
....................  
.................... #if !defined(GetInstructionClock) 
.................... 	#error GetInstructionClock() must be defined. 
.................... #endif 
....................  
.................... #if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 	#define Delay10us(us)		Delay10TCYx(((GetInstructionClock()/1000000)*(us))) 
.................... 	#define DelayMs(ms)												\ 
.................... 	do																\ 
.................... 	{																\ 
.................... 		unsigned int _iTemp = (ms); 								\ 
.................... 		while(_iTemp--)												\ 
.................... 			Delay1KTCYx((GetInstructionClock()+999999)/1000000);	\ 
.................... 	} while(0) 
....................  
.................... #elif defined(__C30__) || defined(__C32__) 
.................... 	void Delay10us(DWORD dwCount); 
.................... 	void DelayMs(WORD ms); 
....................  
.................... #else 
.................... 	#define Delay10us(x)			\ 
.................... 	do 								\ 
.................... 	{								\ 
.................... 		unsigned long _dcnt;		\ 
.................... 		_dcnt=x*((unsigned long)(0.00001/(1.0/GetInstructionClock())/6));	\ 
.................... 		while(_dcnt--);				\ 
.................... 	} while(0) 
.................... 	void DelayMs(WORD ms); 
.................... #endif 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "TCPIP Stack/Tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  ********************************************************************/ 
.................... #ifndef __TICK_H 
.................... #define __TICK_H 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... // All TICKS are stored as 32-bit unsigned integers. 
.................... // This is deprecated since it conflicts with other TICK definitions used in  
.................... // other Microchip software libraries and therefore poses a merge and maintence  
.................... // problem.  Instead of using the TICK data type, just use the base DWORD data  
.................... // type instead. 
.................... typedef __attribute__((__deprecated__)) DWORD TICK; 
....................  
.................... // This value is used by TCP and other modules to implement timeout actions. 
.................... // For this definition, the Timer must be initialized to use a 1:256 prescalar  
.................... // in Tick.c.  If using a 32kHz watch crystal as the time base, modify the  
.................... // Tick.c file to use no prescalar. 
.................... #define TICKS_PER_SECOND		((GetPeripheralClock()+128ull)/256ull)	// Internal core clock drives timer with 1:256 prescaler 
.................... //#define TICKS_PER_SECOND		(32768ul)								// 32kHz crystal drives timer with no scalar 
....................  
.................... // Represents one second in Ticks 
.................... #define TICK_SECOND				((QWORD)TICKS_PER_SECOND) 
.................... // Represents one minute in Ticks 
.................... #define TICK_MINUTE				((QWORD)TICKS_PER_SECOND*60ull) 
.................... // Represents one hour in Ticks 
.................... #define TICK_HOUR				((QWORD)TICKS_PER_SECOND*3600ull) 
....................  
....................  
.................... void TickInit(void); 
.................... DWORD TickGet(void); 
.................... DWORD TickGetDiv256(void); 
.................... DWORD TickGetDiv64K(void); 
.................... DWORD TickConvertToMilliseconds(DWORD dwTickValue); 
.................... void TickUpdate(void); 
....................  
.................... #endif 
....................  
.................... #include "TCPIP Stack/MAC.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  ********************************************************************/ 
.................... #ifndef __MAC_H 
.................... #define __MAC_H 
....................  
.................... #include "HardwareProfile.h" 
.................... // hardwareprofile.h 
....................  
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #if STACK_USE_CCS_EWLWIFIB || STACK_USE_CCS_EWLWIFIG 
....................  
....................    #bit WF_CS_TRIS1   =     0xF96.1 //E1 
....................    #define WF_CS_TRIS WF_CS_TRIS1 
....................    #bit WF_CS_IO     =  0xF8D.1    //LatE1 
....................    #bit WF_SDI_TRIS  =  0xF94.4    // (TRISCbits.TRISC4) 
....................    #bit WF_SCK_TRIS  =  0xF94.3    // (TRISCbits.TRISC3) 
....................    #bit WF_SDO_TRIS  =  0xF94.5    // (TRISCbits.TRISC5) 
....................    #bit WF_RESET_TRIS=  0xF93.1    //(TRISBbits.TRISB1) 
....................    #bit WF_RESET_IO  =  0xF8A.1     //(LATBbits.LATB1)   
....................    #bit WF_INT_TRIS  =  0xF93.0     // (TRISBbits.TRISB0)  // INT1 
....................    #bit WF_INT_IO    =  0xF81.0   //(PORTBbits.RB0)  
....................    #bit WF_HIBERNATE_TRIS= 0xF93.2  //(TRISBbits.TRISB2)  
....................    #bit   WF_HIBERNATE_IO=  0xF81.2    //(PORTBbits.RB2) 
....................     
....................    #bit WF_INT_EDGE  =  0xFF1.6      //(INTCON2bits.INTEDG0) 
....................    #bit WF_INT_IE    =  0xFF2.4   //(INTCONbits.INT0IE) 
....................    #bit WF_INT_IF    =  0xFF2.1   //(INTCONbits.INT0IF) 
....................    #define WF_SSPBUF  (SSP1BUF) 
....................    #define WF_SPISTAT  (SSP1STATbits) 
....................    #define WF_SPISTATbits SSP1STATbits     //(SSP1STATbits) 
....................    #define WF_SPICON1  (SSP1CON1bits) 
....................    #define WF_SPICON1bits WF_SPICON1    // (SSP1CON1bits) 
....................    #define WF_SPICON2  (SSP1CON2bits) 
....................    #bit WF_SPI_IE    =   0xF9D.3  //(PIE1bits.SSPIE) 
....................    #bit WF_SPI_IP    =   0xF9F.3  //(IPR1bits.SSPIP) 
....................    #bit WF_SPI_IF    =   0xF9E.3  //(PIR1bits.SSPIF) 
....................     
.................... #else 
....................  
.................... //#error define necessary hardware for TCPIP stack 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #if defined(WF_CS_TRIS) 
....................    // Do not use the DMA and other goodies that Microchip Ethernet modules have 
....................    #define NON_MCHP_MAC 
.................... #endif 
....................  
.................... #if defined(ENC_CS_TRIS) && defined(WF_CS_TRIS) 
....................    #error "Error in HardwareProfile.h.  Must select either the ENC28J60 or the MRF24WB10 but not both ENC_CS_TRIS and WF_CS_TRIS." 
.................... #endif 
.................... #if defined(ENC100_INTERFACE_MODE) && defined(WF_CS_TRIS) 
....................    #error "Error in HardwareProfile.h.  Must select either the ENCX24J600 or the MRF24WB10 but not both ENC100_INTERFACE_MODE and WF_CS_TRIS." 
.................... #endif 
.................... #if defined(ENC100_INTERFACE_MODE) && defined(ENC_CS_TRIS) 
....................    #error "Error in HardwareProfile.h.  Must select either the ENC28J60 or the ENCX24J600 but not both ENC_CS_TRIS and ENC100_INTERFACE_MODE." 
.................... #endif 
....................  
....................  
....................  
.................... #if !defined(ENC_CS_TRIS) && !defined(WF_CS_TRIS) && !defined(ENC100_INTERFACE_MODE) && \ 
....................     (defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) || \ 
....................      defined(_18F97J60) ||  defined(_18F96J65) ||  defined(_18F96J60) ||  defined(_18F87J60) ||  defined(_18F86J65) ||  defined(_18F86J60) ||  defined(_18F67J60) ||  defined(_18F66J65) ||  defined(_18F66J60)) 
....................    #include "TCPIP Stack/ETH97J60.h" 
.................... #elif defined(ENC_CS_TRIS) || defined(WF_CS_TRIS) 
....................    #include "TCPIP Stack/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  ********************************************************************/ 
....................  
.................... #ifndef __ENC28J60_H 
.................... #define __ENC28J60_H 
.................... #include "GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... #ifdef BYTE 
.................... #undef BYTE 
.................... #endif 
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		WORD	 		ByteCount; 
.................... 		unsigned char	CollisionCount:4; 
.................... 		unsigned char	CRCError:1; 
.................... 		unsigned char	LengthCheckError:1; 
.................... 		unsigned char	LengthOutOfRange:1; 
.................... 		unsigned char	Done:1; 
.................... 		unsigned char	Multicast:1; 
.................... 		unsigned char	Broadcast:1; 
.................... 		unsigned char	PacketDefer:1; 
.................... 		unsigned char	ExcessiveDefer:1; 
.................... 		unsigned char	MaximumCollisions:1; 
.................... 		unsigned char	LateCollision:1; 
.................... 		unsigned char	Giant:1; 
.................... 		unsigned char	Underrun:1; 
.................... 		WORD 	 		BytesTransmittedOnWire; 
.................... 		unsigned char	ControlFrame:1; 
.................... 		unsigned char	PAUSEControlFrame:1; 
.................... 		unsigned char	BackpressureApplied:1; 
.................... 		unsigned char	VLANTaggedFrame:1; 
.................... 		unsigned char	Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	BYTE v[4]; 
.................... 	struct { 
.................... 		WORD	 		ByteCount; 
.................... 		unsigned char	PreviouslyIgnored:1; 
.................... 		unsigned char	RXDCPreviouslySeen:1; 
.................... 		unsigned char	CarrierPreviouslySeen:1; 
.................... 		unsigned char	CodeViolation:1; 
.................... 		unsigned char	CRCError:1; 
.................... 		unsigned char	LengthCheckError:1; 
.................... 		unsigned char	LengthOutOfRange:1; 
.................... 		unsigned char	ReceiveOk:1; 
.................... 		unsigned char	Multicast:1; 
.................... 		unsigned char	Broadcast:1; 
.................... 		unsigned char	DribbleNibble:1; 
.................... 		unsigned char	ControlFrame:1; 
.................... 		unsigned char	PauseControlFrame:1; 
.................... 		unsigned char	UnsupportedOpcode:1; 
.................... 		unsigned char	VLANType:1; 
.................... 		unsigned char	Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG  
.................... { 
.................... 	BYTE Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char :1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char BUFER:1; 
.................... 		unsigned char INT:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char :3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
.................... 		 
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
.................... 		 
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
.................... 		 
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
.................... 		 
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDREN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDREN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
.................... 		 
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char :1; 
.................... 	} MACON4bits; 
.................... 		 
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char :6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
.................... 		 
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char :5; 
.................... 	} MISTATbits; 
.................... 		 
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char :5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char :5; 
.................... 	} ECOCONbits2; 
.................... 		 
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char :5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char :5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	WORD Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		unsigned :8; 
.................... 		unsigned PDPXMD:1; 
.................... 		unsigned :2; 
.................... 		unsigned PPWRSV:1; 
.................... 		unsigned :2; 
.................... 		unsigned PLOOPBK:1; 
.................... 		unsigned PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		unsigned :1; 
.................... 		unsigned JBSTAT:1; 
.................... 		unsigned LLSTAT:1; 
.................... 		unsigned :5; 
.................... 		unsigned :3; 
.................... 		unsigned PHDPX:1; 
.................... 		unsigned PFDPX:1; 
.................... 		unsigned :3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		unsigned PREV0:1; 
.................... 		unsigned PREV1:1; 
.................... 		unsigned PREV2:1; 
.................... 		unsigned PREV3:1; 
.................... 		unsigned PPN0:1; 
.................... 		unsigned PPN1:1; 
.................... 		unsigned PPN2:1; 
.................... 		unsigned PPN3:1; 
.................... 		unsigned PPN4:1; 
.................... 		unsigned PPN5:1; 
.................... 		unsigned PID19:1; 
.................... 		unsigned PID20:1; 
.................... 		unsigned PID21:1; 
.................... 		unsigned PID22:1; 
.................... 		unsigned PID23:1; 
.................... 		unsigned PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		unsigned PREV:4; 
.................... 		unsigned PPNL:4; 
.................... 		unsigned PPNH:2; 
.................... 		unsigned PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		unsigned :8; 
.................... 		unsigned HDLDIS:1; 
.................... 		unsigned :1; 
.................... 		unsigned JABBER:1; 
.................... 		unsigned :2; 
.................... 		unsigned TXDIS:1; 
.................... 		unsigned FRCLNK:1; 
.................... 		unsigned :1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		unsigned :5; 
.................... 		unsigned PLRITY:1; 
.................... 		unsigned :2; 
.................... 		unsigned :1; 
.................... 		unsigned DPXSTAT:1; 
.................... 		unsigned LSTAT:1; 
.................... 		unsigned COLSTAT:1; 
.................... 		unsigned RXSTAT:1; 
.................... 		unsigned TXSTAT:1; 
.................... 		unsigned :2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		unsigned :1; 
.................... 		unsigned PGEIE:1; 
.................... 		unsigned :2; 
.................... 		unsigned PLNKIE:1; 
.................... 		unsigned :3; 
.................... 		unsigned :8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		unsigned :2; 
.................... 		unsigned PGIF:1; 
.................... 		unsigned :1; 
.................... 		unsigned PLNKIF:1; 
.................... 		unsigned :3; 
.................... 		unsigned :8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		unsigned :1; 
.................... 		unsigned STRCH:1; 
.................... 		unsigned LFRQ0:1; 
.................... 		unsigned LFRQ1:1; 
.................... 		unsigned LBCFG0:1; 
.................... 		unsigned LBCFG1:1; 
.................... 		unsigned LBCFG2:1; 
.................... 		unsigned LBCFG3:1; 
.................... 		unsigned LACFG0:1; 
.................... 		unsigned LACFG1:1; 
.................... 		unsigned LACFG2:1; 
.................... 		unsigned LACFG3:1; 
.................... 		unsigned :4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		unsigned :1; 
.................... 		unsigned STRCH:1; 
.................... 		unsigned LFRQ:2; 
.................... 		unsigned LBCFG:4; 
.................... 		unsigned LACFG:4; 
.................... 		unsigned :4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
.................... 	 
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFER		(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
.................... 	 
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
.................... 	 
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
.................... 	 
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
.................... 	 
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
.................... 	 
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDREN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
.................... 	 
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
.................... 	 
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
.................... 	 
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
.................... 	 
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
.................... #elif defined(ENC100_INTERFACE_MODE) 
....................    #include "TCPIP Stack/ENCX24J600.h" 
....................    #define PHYREG WORD 
.................... #elif defined(__PIC32MX__) && defined(_ETH) 
....................    // extra includes for PIC32MX with embedded ETH Controller 
.................... #else 
....................    #error No Ethernet/WiFi controller defined in HardwareProfile.h.  Defines for an ENC28J60, ENC424J600/624J600, or WiFi MRF24WB10 must be present. 
.................... #endif 
....................  
....................  
.................... #define MAC_TX_BUFFER_SIZE         (1500ul) 
....................  
.................... // A generic structure representing the Ethernet header starting all Ethernet 
.................... // frames 
.................... typedef struct   
.................... #if defined(__CCS__) 
.................... __attribute__((packed)) 
.................... #else 
.................... __attribute__((aligned(2), packed)) 
.................... #endif 
.................... { 
....................    MAC_ADDR        DestMACAddr; 
....................    MAC_ADDR        SourceMACAddr; 
....................    WORD_VAL        Type; 
.................... } ETHER_HEADER; 
....................  
....................  
.................... #define MAC_IP         (0x00u) 
.................... #define MAC_ARP        (0x06u) 
.................... #define MAC_UNKNOWN    (0xFFu) 
....................  
....................  
.................... #if !defined(STACK_USE_HTTP2_SERVER) 
....................    #define RESERVED_HTTP_MEMORY 0ul 
.................... #endif 
....................  
.................... #if !defined(STACK_USE_SSL) 
....................    #define RESERVED_SSL_MEMORY 0ul 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #define MAX_PACKET_SIZE     (1514ul) 
.................... #endif 
....................  
.................... // MAC RAM definitions 
.................... #if defined(ENC100_INTERFACE_MODE) 
....................    #define RESERVED_CRYPTO_MEMORY   (128ul) 
....................    #define RAMSIZE         (24*1024ul) 
....................    #define TXSTART       (0x0000ul) 
....................    #define RXSTART       ((TXSTART + 1518ul + TCP_ETH_RAM_SIZE + RESERVED_HTTP_MEMORY + RESERVED_SSL_MEMORY + RESERVED_CRYPTO_MEMORY + 1ul) & 0xFFFE) 
....................    #define   RXSTOP         (RAMSIZE-1ul) 
....................    #define RXSIZE         (RXSTOP-RXSTART+1ul) 
....................    #define BASE_TX_ADDR   (TXSTART) 
....................    #define BASE_TCB_ADDR   (BASE_TX_ADDR + 1518ul) 
....................    #define BASE_HTTPB_ADDR (BASE_TCB_ADDR + TCP_ETH_RAM_SIZE) 
....................    #define BASE_SSLB_ADDR   (BASE_HTTPB_ADDR + RESERVED_HTTP_MEMORY) 
....................    #define BASE_CRYPTOB_ADDR   (BASE_SSLB_ADDR + RESERVED_SSL_MEMORY) 
.................... #elif defined(WF_CS_TRIS) 
....................    #define RAMSIZE       (14170ul - 8192ul - RESERVED_HTTP_MEMORY - RESERVED_SSL_MEMORY) 
....................    #define TXSTART       (RAMSIZE - (4ul + MAX_PACKET_SIZE + 4ul)) 
....................    #define RXSTART       (0ul) 
....................    #define RXSTOP         ((TXSTART-2ul) | 0x0001ul) 
....................    #define RXSIZE         (RXSTOP-RXSTART+1ul) 
....................    #define BASE_TX_ADDR   (TXSTART + 4ul) 
....................    #define BASE_SCRATCH_ADDR (BASE_TX_ADDR + (MAX_PACKET_SIZE + 4ul)) 
....................    #define BASE_HTTPB_ADDR  (BASE_SCRATCH_ADDR) 
....................    #define BASE_SSLB_ADDR   (BASE_HTTPB_ADDR + RESERVED_HTTP_MEMORY) 
....................    #define BASE_TCB_ADDR   (BASE_SSLB_ADDR + RESERVED_SSL_MEMORY) 
.................... #elif defined(__PIC32MX__) && defined(_ETH) && !defined(ENC_CS_TRIS) 
....................    #define BASE_TX_ADDR   (MACGetTxBaseAddr()) 
....................    #define BASE_HTTPB_ADDR   (MACGetHttpBaseAddr()) 
....................    #define BASE_SSLB_ADDR   (MACGetSslBaseAddr()) 
....................    #define RXSIZE         (EMAC_RX_BUFF_SIZE) 
....................    #define RAMSIZE         (2*RXSIZE)   // not used but silences the compiler 
.................... #else   // ENC28J60 or PIC18F97J60 family internal Ethernet controller 
....................    #define RAMSIZE         (8*1024ul) 
....................    #define TXSTART       (RAMSIZE - (1ul+1518ul+7ul) - TCP_ETH_RAM_SIZE - RESERVED_HTTP_MEMORY - RESERVED_SSL_MEMORY) 
....................    #define RXSTART         (0ul)                  // Should be an even memory address; must be 0 for errata 
....................    #define   RXSTOP         ((TXSTART-2ul) | 0x0001ul)   // Odd for errata workaround 
....................    #define RXSIZE         (RXSTOP-RXSTART+1ul) 
....................    #define BASE_TX_ADDR   (TXSTART + 1ul) 
....................    #define BASE_TCB_ADDR   (BASE_TX_ADDR + (1514ul+7ul)) 
....................    #define BASE_HTTPB_ADDR (BASE_TCB_ADDR + TCP_ETH_RAM_SIZE) 
....................    #define BASE_SSLB_ADDR   (BASE_HTTPB_ADDR + RESERVED_HTTP_MEMORY) 
.................... #endif 
....................  
.................... #if (RXSIZE < 1400) || (RXSIZE > RAMSIZE) 
....................    #error Warning, Ethernet RX buffer is tiny.  Reduce TCP socket count, the size of each TCP socket, or move sockets to a different RAM 
.................... #endif 
....................  
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void   MACEDPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... #if defined(ENC_CS_TRIS) || defined(ENC100_INTERFACE_MODE) || \ 
....................    (defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) || \ 
....................      defined(_18F97J60) ||  defined(_18F96J65) ||  defined(_18F96J60) ||  defined(_18F87J60) ||  defined(_18F86J65) ||  defined(_18F86J60) ||  defined(_18F67J60) ||  defined(_18F66J65) ||  defined(_18F66J60)) 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... #endif 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
.................... // ENC28J60 specific 
.................... void   SetCLKOUT(BYTE NewConfig); 
.................... BYTE   GetCLKOUT(void); 
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
....................  
.................... void MACInit(void); 
.................... void MACProcess(void); 
.................... BOOL MACIsLinked(void); 
....................  
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void MACSetReadPtrInRx(WORD offset); 
.................... PTR_BASE MACSetWritePtr(PTR_BASE address); 
.................... PTR_BASE MACSetReadPtr(PTR_BASE address); 
.................... BYTE MACGet(void); 
.................... WORD MACGetArray(BYTE *val, WORD len); 
.................... void MACDiscardRx(void); 
.................... WORD MACGetFreeRxSize(void); 
.................... void MACMemCopyAsync(PTR_BASE destAddr, PTR_BASE sourceAddr, WORD len); 
.................... BOOL MACIsMemCopyDone(void); 
....................  
.................... void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen); 
.................... BOOL MACIsTxReady(void); 
.................... void MACPut(BYTE val); 
.................... void MACPutArray(BYTE *val, WORD len); 
.................... void MACFlush(void); 
....................  
....................  
.................... // ROM function variants for PIC18 
.................... #if defined(__18CXX) 
....................    void MACPutROMArray(ROM BYTE *val, WORD len); 
.................... #else 
....................    #define MACPutROMArray(a,b)   MACPutArray((BYTE*)a,b) 
.................... #endif 
....................  
.................... // PIC32MX with embedded ETHC functions 
.................... #if defined(__PIC32MX__) && defined(_ETH) 
....................    PTR_BASE MACGetTxBaseAddr(void); 
....................    PTR_BASE MACGetHttpBaseAddr(void); 
....................    PTR_BASE MACGetSslBaseAddr(void); 
.................... #endif 
....................  
....................     
.................... #endif 
....................  
.................... #include "TCPIP Stack/IP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  ********************************************************************/ 
.................... #ifndef __IP_H 
.................... #define __IP_H 
....................  
....................  
.................... #define IP_PROT_ICMP    (1u) 
.................... #define IP_PROT_TCP     (6u) 
.................... #define IP_PROT_UDP     (17u) 
....................  
....................  
.................... // IP packet header definition 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
.................... } IP_HEADER; 
....................  
.................... // IP Pseudo header as defined by RFC 793 (needed for TCP and UDP  
.................... // checksum calculations/verification) 
.................... typedef struct _PSEUDO_HEADER 
.................... { 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................     BYTE Zero; 
....................     BYTE Protocol; 
....................     WORD Length; 
.................... } PSEUDO_HEADER; 
....................  
.................... #define SwapPseudoHeader(h)  (h.Length = swaps(h.Length)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady()       MACIsTxReady() 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(b) MACSetWritePtr(b + BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by  
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset  
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "TCPIP Stack/ARP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder      8/17/06   Combined ARP.h and ARPTsk.h into ARP.h 
....................  ********************************************************************/ 
.................... #ifndef __ARP_H 
.................... #define __ARP_H 
....................  
.................... #ifdef STACK_CLIENT_MODE 
....................    void ARPInit(void); 
.................... #else 
....................    #define ARPInit() 
.................... #endif 
....................  
.................... #define ARP_OPERATION_REQ       0x0001u      // Operation code indicating an ARP Request 
.................... #define ARP_OPERATION_RESP      0x0002u      // Operation code indicating an ARP Response 
....................  
.................... #define HW_ETHERNET             (0x0001u)   // ARP Hardware type as defined by IEEE 802.3 
.................... #define ARP_IP                  (0x0800u)   // ARP IP packet type as defined by IEEE 802.3 
....................  
....................  
.................... // ARP packet structure 
.................... typedef struct  
.................... #if defined(__CCS__) 
.................... __attribute__((packed)) 
.................... #else 
.................... __attribute__((aligned(2), packed)) 
.................... #endif 
.................... { 
....................     WORD        HardwareType;   // Link-layer protocol type (Ethernet is 1). 
....................     WORD        Protocol;       // The upper-layer protocol issuing an ARP request (0x0800 for IPv4).. 
....................     BYTE        MACAddrLen;     // MAC address length (6). 
....................     BYTE        ProtocolLen;    // Length of addresses used in the upper-layer protocol (4). 
....................     WORD        Operation;      // The operation the sender is performing (ARP_REQ or ARP_RESP). 
....................     MAC_ADDR    SenderMACAddr;  // The sender's hardware (MAC) address. 
....................     IP_ADDR     SenderIPAddr;   // The sender's IP address. 
....................     MAC_ADDR    TargetMACAddr;  // The target node's hardware (MAC) address. 
....................     IP_ADDR     TargetIPAddr;   // The target node's IP address. 
.................... } ARP_PACKET; 
....................  
.................... BOOL ARPProcess(void); 
.................... void ARPResolve(IP_ADDR* IPAddr); 
.................... BOOL ARPIsResolved(IP_ADDR* IPAddr, MAC_ADDR* MACAddr); 
.................... void SwapARPPacket(ARP_PACKET* p); 
....................  
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................    /* API specific Definitions */ 
....................    #define ARP_REQ       0x0001u      // Operation code indicating an ARP Request 
....................    #define ARP_RESP      0x0002u      // Operation code indicating an ARP Response 
....................  
....................    struct arp_app_callbacks { 
....................        BOOL used; 
....................        void (*ARPPkt_notify)(DWORD SenderIPAddr, DWORD TargetIPAddr,  
....................                              MAC_ADDR* SenderMACAddr, MAC_ADDR* TargetMACAddr, BYTE op_req); 
....................    }; 
....................    CHAR ARPRegisterCallbacks(struct arp_app_callbacks *app); 
....................    BOOL ARPDeRegisterCallbacks(CHAR id); 
.................... #endif 
....................    BOOL ARPSendPkt(DWORD SrcIPAddr, DWORD DestIPAddr, BYTE op_req ); 
.................... #endif 
....................  
....................  
....................  
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... /********************************************************************* 
....................  * 
....................  *               External serial data EEPROM Access Defs. 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        XEEPROM.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/20/02     Original (Rev. 1.0) 
.................... ********************************************************************/ 
.................... #ifndef __XEEPROM_H 
.................... #define __XEEPROM_H 
....................  
.................... #include "HardwareProfile.h" 
.................... // hardwareprofile.h 
....................  
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #if STACK_USE_CCS_EWLWIFIB || STACK_USE_CCS_EWLWIFIG 
....................  
....................    #bit WF_CS_TRIS1   =     0xF96.1 //E1 
....................    #define WF_CS_TRIS WF_CS_TRIS1 
....................    #bit WF_CS_IO     =  0xF8D.1    //LatE1 
....................    #bit WF_SDI_TRIS  =  0xF94.4    // (TRISCbits.TRISC4) 
....................    #bit WF_SCK_TRIS  =  0xF94.3    // (TRISCbits.TRISC3) 
....................    #bit WF_SDO_TRIS  =  0xF94.5    // (TRISCbits.TRISC5) 
....................    #bit WF_RESET_TRIS=  0xF93.1    //(TRISBbits.TRISB1) 
....................    #bit WF_RESET_IO  =  0xF8A.1     //(LATBbits.LATB1)   
....................    #bit WF_INT_TRIS  =  0xF93.0     // (TRISBbits.TRISB0)  // INT1 
....................    #bit WF_INT_IO    =  0xF81.0   //(PORTBbits.RB0)  
....................    #bit WF_HIBERNATE_TRIS= 0xF93.2  //(TRISBbits.TRISB2)  
....................    #bit   WF_HIBERNATE_IO=  0xF81.2    //(PORTBbits.RB2) 
....................     
....................    #bit WF_INT_EDGE  =  0xFF1.6      //(INTCON2bits.INTEDG0) 
....................    #bit WF_INT_IE    =  0xFF2.4   //(INTCONbits.INT0IE) 
....................    #bit WF_INT_IF    =  0xFF2.1   //(INTCONbits.INT0IF) 
....................    #define WF_SSPBUF  (SSP1BUF) 
....................    #define WF_SPISTAT  (SSP1STATbits) 
....................    #define WF_SPISTATbits SSP1STATbits     //(SSP1STATbits) 
....................    #define WF_SPICON1  (SSP1CON1bits) 
....................    #define WF_SPICON1bits WF_SPICON1    // (SSP1CON1bits) 
....................    #define WF_SPICON2  (SSP1CON2bits) 
....................    #bit WF_SPI_IE    =   0xF9D.3  //(PIE1bits.SSPIE) 
....................    #bit WF_SPI_IP    =   0xF9F.3  //(IPR1bits.SSPIP) 
....................    #bit WF_SPI_IF    =   0xF9E.3  //(PIR1bits.SSPIF) 
....................     
.................... #else 
....................  
.................... //#error define necessary hardware for TCPIP stack 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... typedef BOOL XEE_RESULT; 
.................... #define XEE_SUCCESS FALSE 
....................  
.................... #if defined(EEPROM_CS_TRIS)	 
.................... 	void XEEInit(void); 
.................... 	XEE_RESULT XEEBeginWrite(DWORD address); 
.................... 	XEE_RESULT XEEWrite(BYTE val); 
.................... 	void XEEWriteArray(BYTE *val, WORD wLen); 
.................... 	XEE_RESULT XEEEndWrite(void); 
.................... 	XEE_RESULT XEEBeginRead(DWORD address); 
.................... 	BYTE XEERead(void); 
.................... 	XEE_RESULT XEEReadArray(DWORD address, BYTE *buffer, WORD length); 
.................... 	XEE_RESULT XEEEndRead(void); 
.................... 	BOOL XEEIsBusy(void); 
.................... #else 
.................... 	// If you get any of these linker errors, it means that you either have an  
.................... 	// error in your HardwareProfile.h or TCPIPConfig.h definitions.  The code  
.................... 	// is attempting to call a function that can't possibly work because you  
.................... 	// have not specified what pins and SPI module the physical SPI EEPROM chip  
.................... 	// is connected to.  Alternatively, if you don't have an SPI EERPOM chip, it  
.................... 	// means you have enabled a stack feature that requires SPI EEPROM hardware. 
.................... 	// In this case, you need to edit TCPIPConfig.h and disable this stack  
.................... 	// feature.  The linker error tells you which object file this error was  
.................... 	// generated from.  It should be a clue as to what feature you need to  
.................... 	// disable. 
.................... 	void 		You_cannot_call_the_XEEInit_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEBeginWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void 		You_cannot_call_the_XEEWriteArray_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEEndWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEBeginRead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	BYTE 		You_cannot_call_the_XEERead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEReadArray_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEEndRead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	BOOL 		You_cannot_call_the_XEEIsBusy_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	#define XEEInit()				You_cannot_call_the_XEEInit_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEBeginWrite(a) 		You_cannot_call_the_XEEBeginWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEWrite(a)				You_cannot_call_the_XEEWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEWriteArray(a,b)		You_cannot_call_the_XEEWriteArray_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEEndWrite()			You_cannot_call_the_XEEEndWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEBeginRead(a)			You_cannot_call_the_XEEBeginRead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEERead(a)				You_cannot_call_the_XEERead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEReadArray(a, b, c)	You_cannot_call_the_XEEReadArray_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEEndRead()			You_cannot_call_the_XEEEndRead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEIsBusy()				You_cannot_call_the_XEEIsBusy_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... #endif 
....................  
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... /********************************************************************* 
....................  * 
....................  *  SPI Flash Memory Driver Header 
....................  *	- Tested to be compatible with SST25VF016B 
....................  *  - Expected compatibility with other SST (Microchip) SST25 series  
....................  *    devices 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        SPIFlash.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * E. Wood				3/20/08	Original 
.................... ********************************************************************/ 
.................... #ifndef __SPIFLASH_H 
.................... #define __SPIFLASH_H 
....................  
.................... #include "HardwareProfile.h" 
....................  
.................... #define SPI_FLASH_SECTOR_SIZE		(4096ul) 
.................... #define SPI_FLASH_PAGE_SIZE			(0ul)		// SST has no page boundary requirements 
....................  
.................... #define SPI_FLASH_SECTOR_MASK		(SPI_FLASH_SECTOR_SIZE - 1) 
....................  
....................  
.................... #if defined(SPIFLASH_CS_TRIS) 
.................... 	void SPIFlashInit(void);		 
.................... 	void SPIFlashReadArray(DWORD dwAddress, BYTE *vData, WORD wLen); 
.................... 	void SPIFlashBeginWrite(DWORD dwAddr); 
.................... 	void SPIFlashWrite(BYTE vData); 
.................... 	void SPIFlashWriteArray(BYTE *vData, WORD wLen); 
.................... 	void SPIFlashEraseSector(DWORD dwAddr); 
.................... #else 
.................... 	// If you get any of these linker errors, it means that you either have an  
.................... 	// error in your HardwareProfile.h or TCPIPConfig.h definitions.  The code  
.................... 	// is attempting to call a function that can't possibly work because you  
.................... 	// have not specified what pins and SPI module the physical SPI Flash chip  
.................... 	// is connected to.  Alternatively, if you don't have an SPI Flash chip, it  
.................... 	// means you have enabled a stack feature that requires SPI Flash hardware. 
.................... 	// In this case, you need to edit TCPIPConfig.h and disable this stack  
.................... 	// feature.  The linker error tells you which object file this error was  
.................... 	// generated from.  It should be a clue as to what feature you need to  
.................... 	// disable. 
.................... 	void You_cannot_call_the_SPIFlashInit_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashReadArray_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashBeginWrite_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashWrite_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashWriteArray_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashEraseSector_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	#define SPIFlashInit()				You_cannot_call_the_SPIFlashInit_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashReadArray(a,b,c)	You_cannot_call_the_SPIFlashReadArray_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashBeginWrite(a)		You_cannot_call_the_SPIFlashBeginWrite_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashWrite(a)			You_cannot_call_the_SPIFlashWrite_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashWriteArray(a,b)		You_cannot_call_the_SPIFlashWriteArray_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashEraseSector(a)		You_cannot_call_the_SPIFlashEraseSector_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... #endif 
....................  
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/SPIRAM.h" 
.................... /********************************************************************* 
....................  * 
....................  * Data SPI RAM Access Routines 
....................  *  -Tested with AMI Semiconductor N256S0830HDA 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        SPIRAM.h 
....................  * Dependencies:    Compiler.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * \file SPIRAM.h 
....................  * \author Howard Henry Schlunder 
....................  * \date 25 July 2007 
.................... ********************************************************************/ 
.................... #ifndef __SPIRAM_H 
.................... #define __SPIRAM_H 
....................  
.................... #include "HardwareProfile.h" 
.................... // hardwareprofile.h 
....................  
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #if STACK_USE_CCS_EWLWIFIB || STACK_USE_CCS_EWLWIFIG 
....................  
....................    #bit WF_CS_TRIS1   =     0xF96.1 //E1 
....................    #define WF_CS_TRIS WF_CS_TRIS1 
....................    #bit WF_CS_IO     =  0xF8D.1    //LatE1 
....................    #bit WF_SDI_TRIS  =  0xF94.4    // (TRISCbits.TRISC4) 
....................    #bit WF_SCK_TRIS  =  0xF94.3    // (TRISCbits.TRISC3) 
....................    #bit WF_SDO_TRIS  =  0xF94.5    // (TRISCbits.TRISC5) 
....................    #bit WF_RESET_TRIS=  0xF93.1    //(TRISBbits.TRISB1) 
....................    #bit WF_RESET_IO  =  0xF8A.1     //(LATBbits.LATB1)   
....................    #bit WF_INT_TRIS  =  0xF93.0     // (TRISBbits.TRISB0)  // INT1 
....................    #bit WF_INT_IO    =  0xF81.0   //(PORTBbits.RB0)  
....................    #bit WF_HIBERNATE_TRIS= 0xF93.2  //(TRISBbits.TRISB2)  
....................    #bit   WF_HIBERNATE_IO=  0xF81.2    //(PORTBbits.RB2) 
....................     
....................    #bit WF_INT_EDGE  =  0xFF1.6      //(INTCON2bits.INTEDG0) 
....................    #bit WF_INT_IE    =  0xFF2.4   //(INTCONbits.INT0IE) 
....................    #bit WF_INT_IF    =  0xFF2.1   //(INTCONbits.INT0IF) 
....................    #define WF_SSPBUF  (SSP1BUF) 
....................    #define WF_SPISTAT  (SSP1STATbits) 
....................    #define WF_SPISTATbits SSP1STATbits     //(SSP1STATbits) 
....................    #define WF_SPICON1  (SSP1CON1bits) 
....................    #define WF_SPICON1bits WF_SPICON1    // (SSP1CON1bits) 
....................    #define WF_SPICON2  (SSP1CON2bits) 
....................    #bit WF_SPI_IE    =   0xF9D.3  //(PIE1bits.SSPIE) 
....................    #bit WF_SPI_IP    =   0xF9F.3  //(IPR1bits.SSPIP) 
....................    #bit WF_SPI_IF    =   0xF9E.3  //(PIR1bits.SSPIF) 
....................     
.................... #else 
....................  
.................... //#error define necessary hardware for TCPIP stack 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #if defined(SPIRAM_CS_TRIS) 
.................... 	void SPIRAMInit(void); 
.................... 	void SPIRAMGetArray(WORD wAddress, BYTE *vData, WORD wLength); 
.................... 	void SPIRAMPutArray(WORD wAddress, BYTE *vData, WORD wLength); 
.................... 	 
.................... 	#define SPIRAMPutString(a,b)			SPIRAMPutArray(a, strlen((char*)b)) 
.................... 	 
.................... 	#if defined(__18CXX) 
.................... 		void SPIRAMPutROMArray(WORD wAddress, ROM BYTE *vData, WORD wLength); 
.................... 		#define SPIRAMPutROMString(a,b)		SPIRAMPutROMArray(a, strlenpgm((ROM char*)b)) 
.................... 	#else 
.................... 		#define SPIRAMPutROMString(a,b)		SPIRAMPutArray(a, strlen((char*)b)) 
.................... 		#define SPIRAMPutROMArray(a,b,c)	SPIRAMPutROMArray(a, b, c) 
.................... 	#endif 
.................... #else 
.................... 	// If you get any of these linker errors, it means that you either have an  
.................... 	// error in your HardwareProfile.h or TCPIPConfig.h definitions.  The code  
.................... 	// is attempting to call a function that can't possibly work because you  
.................... 	// have not specified what pins and SPI module the physical SPI SRAM chip  
.................... 	// is connected to.  Alternatively, if you don't have an SPI SRAM chip, it  
.................... 	// means you have enabled a stack feature that requires SPI SRAM hardware. 
.................... 	// In this case, you need to edit TCPIPConfig.h and disable this stack  
.................... 	// feature.  The linker error tells you which object file this error was  
.................... 	// generated from.  It should be a clue as to what feature you need to  
.................... 	// disable. 
.................... 	void You_cannot_call_the_SPIRAMInit_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMGetArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMPutArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMPutString_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMPutROMArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMPutROMString_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	#define SPIRAMInit()				You_cannot_call_the_SPIRAMInit_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMGetArray(a,b,c)		You_cannot_call_the_SPIRAMGetArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMPutArray(a,b,c)		You_cannot_call_the_SPIRAMPutArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMPutString(a,b)		You_cannot_call_the_SPIRAMPutString_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMPutROMArray(a,b,c)	You_cannot_call_the_SPIRAMPutROMArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMPutROMString(a,b)		You_cannot_call_the_SPIRAMPutROMString_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... #endif 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCP.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    	Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01  	Original        (Rev 1.0) 
....................  * Howard Schlunder		11/30/06	See "TCPIP Stack Version.txt" file 
....................  ********************************************************************/ 
.................... #ifndef __TCP_HITECH_WORKAROUND_H 
.................... #define __TCP_HITECH_WORKAROUND_H 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	Type Definitions 
....................   ***************************************************************************/ 
....................  
.................... // A TCP_SOCKET is stored as a single BYTE 
.................... typedef BYTE TCP_SOCKET; 
....................  
.................... #define INVALID_SOCKET      (0xFE)	// The socket is invalid or could not be opened 
.................... #define UNKNOWN_SOCKET      (0xFF)	// The socket is not known 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	State Machine Variables 
....................   ***************************************************************************/ 
....................  
.................... // TCP States as defined by RFC 793 
.................... typedef enum 
.................... { 
.................... 	TCP_GET_DNS_MODULE,		// Special state for TCP client mode sockets 
.................... 	TCP_DNS_RESOLVE,		// Special state for TCP client mode sockets 
.................... 	TCP_GATEWAY_SEND_ARP,	// Special state for TCP client mode sockets 
.................... 	TCP_GATEWAY_GET_ARP,	// Special state for TCP client mode sockets 
....................  
....................     TCP_LISTEN,				// Socket is listening for connections 
....................     TCP_SYN_SENT,			// A SYN has been sent, awaiting an SYN+ACK 
....................     TCP_SYN_RECEIVED,		// A SYN has been received, awaiting an ACK 
....................     TCP_ESTABLISHED,		// Socket is connected and connection is established 
....................     TCP_FIN_WAIT_1,			// FIN WAIT state 1 
....................     TCP_FIN_WAIT_2,			// FIN WAIT state 2 
....................     TCP_CLOSING,			// Socket is closing 
.................... //	TCP_TIME_WAIT, state is not implemented 
.................... 	TCP_CLOSE_WAIT,			// Waiting to close the socket 
....................     TCP_LAST_ACK,			// The final ACK has been sent 
....................     TCP_CLOSED,				// Socket is idle and unallocated 
....................  
....................     TCP_CLOSED_BUT_RESERVED	// Special state for TCP client mode sockets.  Socket is idle, but still allocated pending application closure of the handle. 
.................... } TCP_STATE; 
....................  
.................... typedef enum 
.................... { 
.................... 	SSL_NONE = 0,			// No security is enabled 
.................... 	SSL_HANDSHAKING,		// Handshake is progressing (no application data allowed) 
.................... 	SSL_ESTABLISHED,		// Connection is established and secured 
.................... 	SSL_CLOSED				// Connection has been closed (no applicaiton data is allowed) 
.................... } SSL_STATE; 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	TCB Definitions 
....................   ***************************************************************************/ 
....................  
.................... // TCP Control Block (TCB) stub data storage.  Stubs are stored in local PIC RAM for speed. 
.................... // Current size is 34 bytes (PIC18), 36 bytes (PIC24/dsPIC), or 56 (PIC32) 
.................... typedef struct 
.................... { 
.................... 	PTR_BASE bufferTxStart;		// First byte of TX buffer 
.................... 	PTR_BASE bufferRxStart;		// First byte of RX buffer.  TX buffer ends 1 byte prior 
.................... 	PTR_BASE bufferEnd;			// Last byte of RX buffer 
.................... 	PTR_BASE txHead;			// Head pointer for TX 
.................... 	PTR_BASE txTail;			// Tail pointer for TX 
.................... 	PTR_BASE rxHead;			// Head pointer for RX 
.................... 	PTR_BASE rxTail;			// Tail pointer for RX 
....................     DWORD eventTime;			// Packet retransmissions, state changes 
.................... 	WORD eventTime2;			// Window updates, automatic transmission 
.................... 	union 
.................... 	{ 
.................... 		WORD delayedACKTime;	// Delayed Acknowledgement timer 
.................... 		WORD closeWaitTime;		// TCP_CLOSE_WAIT timeout timer 
.................... 	} OverlappedTimers; 
....................     TCP_STATE smState;			// State of this socket 
....................     struct 
....................     { 
.................... 	    unsigned char vUnackedKeepalives : 3;		// Count of how many keepalives have been sent with no response 
....................         unsigned char bServer : 1;					// Socket should return to listening state when closed 
.................... 		unsigned char bTimerEnabled	: 1;			// Timer is enabled 
.................... 		unsigned char bTimer2Enabled : 1;			// Second timer is enabled 
.................... 		unsigned char bDelayedACKTimerEnabled : 1;	// DelayedACK timer is enabled 
.................... 		unsigned char bOneSegmentReceived : 1;		// A segment has been received 
.................... 		unsigned char bHalfFullFlush : 1;			// Flush is for being half full 
.................... 		unsigned char bTXASAP : 1;					// Transmit as soon as possible (for Flush) 
.................... 		unsigned char bTXASAPWithoutTimerReset : 1;	// Transmit as soon as possible (for Flush), but do not reset retransmission timers 
.................... 		unsigned char bTXFIN : 1;					// FIN needs to be transmitted 
.................... 		unsigned char bSocketReset : 1;				// Socket has been reset (self-clearing semaphore) 
.................... 		unsigned char bSSLHandshaking : 1;			// Socket is in an SSL handshake 
.................... 		unsigned char filler : 2;					// Future expansion 
....................     } Flags; 
.................... 	WORD_VAL remoteHash;	// Consists of remoteIP, remotePort, localPort for connected sockets.  It is a localPort number only for listening server sockets. 
....................  
....................     #if defined(STACK_USE_SSL) 
....................     PTR_BASE sslTxHead;		// Position of data being written in next SSL application record 
....................     						//   Also serves as cache of localSSLPort when smState = TCP_LISTENING 
....................     PTR_BASE sslRxHead;		// Position of incoming data not yet handled by SSL 
....................     BYTE sslStubID;			// Which sslStub is associated with this connection 
....................     BYTE sslReqMessage;		// Currently requested SSL message 
....................     #endif 
....................  
.................... 	BYTE vMemoryMedium;		// Which memory medium the TCB is actually stored 
.................... 	 
.................... } TCB_STUB; 
....................  
.................... // Remainder of TCP Control Block data. 
.................... // The rest of the TCB is stored in Ethernet buffer RAM or elsewhere as defined by vMemoryMedium. 
.................... // Current size is 41 (PIC18), 42 (PIC24/dsPIC), or 48 bytes (PIC32) 
.................... typedef struct 
.................... { 
.................... 	DWORD		retryInterval;			// How long to wait before retrying transmission 
.................... 	DWORD		MySEQ;					// Local sequence number 
.................... 	DWORD		RemoteSEQ;				// Remote sequence number 
.................... 	PTR_BASE	txUnackedTail;			// TX tail pointer for data that is not yet acked 
....................     WORD_VAL	remotePort;				// Remote port number 
....................     WORD_VAL	localPort;				// Local port number 
.................... 	WORD		remoteWindow;			// Remote window size 
.................... 	WORD		wFutureDataSize;		// How much out-of-order data has been received 
.................... 	union 
.................... 	{ 
.................... 		NODE_INFO	niRemoteMACIP;		// 10 bytes for MAC and IP address 
.................... 		DWORD		dwRemoteHost;		// RAM or ROM pointer to a hostname string (ex: "www.microchip.com") 
.................... 	} remote; 
.................... 	SHORT		sHoleSize;				// Size of the hole, or -1 for none exists.  (0 indicates hole has just been filled) 
....................     struct 
....................     { 
....................         unsigned char bFINSent : 1;		// A FIN has been sent 
.................... 		unsigned char bSYNSent : 1;		// A SYN has been sent 
.................... 		unsigned char bRemoteHostIsROM : 1;	// Remote host is stored in ROM 
.................... 		unsigned char bRXNoneACKed1 : 1;	// A duplicate ACK was likely received 
.................... 		unsigned char bRXNoneACKed2 : 1;	// A second duplicate ACK was likely received 
.................... 		unsigned char filler : 3;		// future use 
....................     } flags; 
.................... 	WORD		wRemoteMSS;				// Maximum Segment Size option advirtised by the remote node during initial handshaking 
....................     #if defined(STACK_USE_SSL) 
....................     WORD_VAL	localSSLPort;			// Local SSL port number (for listening sockets) 
....................     #endif 
.................... 	BYTE		retryCount;				// Counter for transmission retries 
.................... 	BYTE		vSocketPurpose;			// Purpose of socket (as defined in TCPIPConfig.h) 
.................... } TCB; 
....................  
.................... // Information about a socket 
.................... typedef struct 
.................... { 
.................... 	NODE_INFO remote;		// NODE_INFO structure for remote node 
.................... 	WORD_VAL remotePort;	// Port number associated with remote node 
.................... } SOCKET_INFO; 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	Function Declarations 
....................   ***************************************************************************/ 
....................  
.................... void TCPInit(void); 
.................... SOCKET_INFO* TCPGetRemoteInfo(TCP_SOCKET hTCP); 
.................... BOOL TCPWasReset(TCP_SOCKET hTCP); 
.................... BOOL TCPIsConnected(TCP_SOCKET hTCP); 
.................... void TCPDisconnect(TCP_SOCKET hTCP); 
.................... void TCPClose(TCP_SOCKET hTCP); 
.................... WORD TCPIsPutReady(TCP_SOCKET hTCP); 
.................... BOOL TCPPut(TCP_SOCKET hTCP, BYTE byte); 
.................... WORD TCPPutArray(TCP_SOCKET hTCP, BYTE* Data, WORD Len); 
.................... BYTE* TCPPutString(TCP_SOCKET hTCP, BYTE* Data); 
.................... WORD TCPIsGetReady(TCP_SOCKET hTCP); 
.................... WORD TCPGetRxFIFOFree(TCP_SOCKET hTCP); 
.................... BOOL TCPGet(TCP_SOCKET hTCP, BYTE* byte); 
.................... WORD TCPGetArray(TCP_SOCKET hTCP, BYTE* buffer, WORD count); 
.................... BYTE TCPPeek(TCP_SOCKET hTCP, WORD wStart); 
.................... WORD TCPPeekArray(TCP_SOCKET hTCP, BYTE *vBuffer, WORD wLen, WORD wStart); 
.................... WORD TCPFindEx(TCP_SOCKET hTCP, BYTE cFind, WORD wStart, WORD wSearchLen, BOOL bTextCompare); 
.................... WORD TCPFindArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare); 
.................... void TCPDiscard(TCP_SOCKET hTCP); 
.................... BOOL TCPProcess(NODE_INFO* remote, IP_ADDR* localIP, WORD len); 
.................... void TCPTick(void); 
.................... void TCPFlush(TCP_SOCKET hTCP); 
....................  
.................... // Create a server socket and ignore dwRemoteHost. 
.................... #define TCP_OPEN_SERVER		0u 
.................... #if defined(STACK_CLIENT_MODE) 
.................... 	#if defined(STACK_USE_DNS) 
.................... 		// Create a client socket and use dwRemoteHost as a RAM pointer to a hostname string. 
.................... 		#define TCP_OPEN_RAM_HOST	1u 
.................... 		// Create a client socket and use dwRemoteHost as a ROM pointer to a hostname string. 
.................... 		#define TCP_OPEN_ROM_HOST	2u 
.................... 	#else 
.................... 		// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_RAM_HOST while the DNS client module is not enabled.  
.................... 		#define TCP_OPEN_RAM_HOST	You_need_to_enable_STACK_USE_DNS_to_use_TCP_OPEN_RAM_HOST 
.................... 		// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_ROM_HOST while the DNS client module is not enabled.  
.................... 		#define TCP_OPEN_ROM_HOST	You_need_to_enable_STACK_USE_DNS_to_use_TCP_OPEN_ROM_HOST 
.................... 	#endif 
.................... 	// Create a client socket and use dwRemoteHost as a literal IP address. 
.................... 	#define TCP_OPEN_IP_ADDRESS	3u 
.................... 	// Create a client socket and use dwRemoteHost as a pointer to a NODE_INFO structure containing the exact remote IP address and MAC address to use. 
.................... 	#define TCP_OPEN_NODE_INFO	4u 
.................... #else 
.................... 	// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_RAM_HOST while STACK_CLIENT_MODE feature is not enabled.  
.................... 	#define TCP_OPEN_RAM_HOST	You_need_to_enable_STACK_CLIENT_MODE_to_use_TCP_OPEN_RAM_HOST 
.................... 	// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_ROM_HOST while STACK_CLIENT_MODE feature is not enabled.  
.................... 	#define TCP_OPEN_ROM_HOST	You_need_to_enable_STACK_CLIENT_MODE_to_use_TCP_OPEN_ROM_HOST 
.................... 	// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_IP_ADDRESS while STACK_CLIENT_MODE feature is not enabled.  
.................... 	#define TCP_OPEN_IP_ADDRESS	You_need_to_enable_STACK_CLIENT_MODE_to_use_TCP_OPEN_IP_ADDRESS 
.................... 	// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_NODE_INFO while STACK_CLIENT_MODE feature is not enabled.  
.................... 	#define TCP_OPEN_NODE_INFO	You_need_to_enable_STACK_CLIENT_MODE_to_use_TCP_OPEN_NODE_INFO 
.................... #endif 
.................... TCP_SOCKET TCPOpen(DWORD dwRemoteHost, BYTE vRemoteHostType, WORD wPort, BYTE vSocketPurpose); 
....................  
.................... #if defined(__18CXX) 
.................... 	WORD TCPFindROMArrayEx(TCP_SOCKET hTCP, ROM BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare); 
....................  
.................... 	/***************************************************************************** 
.................... 	  Summary: 
.................... 		Alias to TCPFindROMArrayEx with no length parameter. 
.................... 	 
.................... 	  Description: 
.................... 		This function is an alias to TCPFindROMArrayEx with no length parameter.   
.................... 		It is provided for backwards compatibility with an older API. 
.................... 	  ***************************************************************************/ 
.................... 	#define TCPFindROMArray(a,b,c,d,e)		TCPFindROMArrayEx(a,b,c,d,0,e) 
.................... 	 
.................... 	WORD TCPPutROMArray(TCP_SOCKET hTCP, ROM BYTE* Data, WORD Len); 
.................... 	ROM BYTE* TCPPutROMString(TCP_SOCKET hTCP, ROM BYTE* Data); 
.................... #else 
.................... 	#define TCPFindROMArray(a,b,c,d,e) 		TCPFindArray(a,(BYTE*)b,c,d,e) 
.................... 	#define TCPFindROMArrayEx(a,b,c,d,e,f) 	TCPFindArrayEx(a,(BYTE*)b,c,d,e,f) 
.................... 	#define TCPPutROMArray(a,b,c)			TCPPutArray(a,(BYTE*)b,c) 
.................... 	#define TCPPutROMString(a,b)			TCPPutString(a,(BYTE*)b) 
.................... #endif 
....................  
.................... WORD TCPGetTxFIFOFull(TCP_SOCKET hTCP); 
.................... // Alias to TCPIsGetReady provided for API completeness 
.................... #define TCPGetRxFIFOFull(a)					TCPIsGetReady(a) 
.................... // Alias to TCPIsPutReady provided for API completeness 
.................... #define TCPGetTxFIFOFree(a) 				TCPIsPutReady(a) 
....................  
.................... #define TCP_ADJUST_GIVE_REST_TO_RX	0x01u	// Resize flag: extra bytes go to RX  
.................... #define TCP_ADJUST_GIVE_REST_TO_TX	0x02u	// Resize flag: extra bytes go to TX 
.................... #define TCP_ADJUST_PRESERVE_RX		0x04u	// Resize flag: attempt to preserve RX buffer 
.................... #define TCP_ADJUST_PRESERVE_TX		0x08u	// Resize flag: attempt to preserve TX buffer 
.................... BOOL TCPAdjustFIFOSize(TCP_SOCKET hTCP, WORD wMinRXSize, WORD wMinTXSize, BYTE vFlags); 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... BOOL TCPStartSSLClient(TCP_SOCKET hTCP, BYTE* host); 
.................... BOOL TCPStartSSLClientEx(TCP_SOCKET hTCP, BYTE* host, void * buffer, BYTE suppDataType); 
.................... BOOL TCPStartSSLServer(TCP_SOCKET hTCP); 
.................... BOOL TCPAddSSLListener(TCP_SOCKET hTCP, WORD port); 
.................... BOOL TCPRequestSSLMessage(TCP_SOCKET hTCP, BYTE msg); 
.................... BOOL TCPSSLIsHandshaking(TCP_SOCKET hTCP); 
.................... BOOL TCPIsSSL(TCP_SOCKET hTCP); 
.................... void TCPSSLHandshakeComplete(TCP_SOCKET hTCP); 
.................... void TCPSSLDecryptMAC(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, WORD len); 
.................... void TCPSSLInPlaceMACEncrypt(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, BYTE* MACSecret, WORD len); 
.................... void TCPSSLPutRecordHeader(TCP_SOCKET hTCP, BYTE* hdr, BOOL recDone); 
.................... WORD TCPSSLGetPendingTxSize(TCP_SOCKET hTCP); 
.................... void TCPSSLHandleIncoming(TCP_SOCKET hTCP); 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Summary: 
.................... 	Alias to TCPFindEx with no length parameter. 
....................  
....................   Description: 
.................... 	This function is an alias to TCPFindEx with no length parameter.  It is 
.................... 	provided for backwards compatibility with an older API. 
....................   ***************************************************************************/ 
.................... #define TCPFind(a,b,c,d)					TCPFindEx(a,b,c,0,d) 
....................  
....................  
.................... /***************************************************************************** 
....................   Summary: 
.................... 	Alias to TCPFindArrayEx with no length parameter. 
....................  
....................   Description: 
.................... 	This function is an alias to TCPFindArrayEx with no length parameter.  It is 
.................... 	provided for backwards compatibility with an older API. 
....................   ***************************************************************************/ 
.................... #define TCPFindArray(a,b,c,d,e)				TCPFindArrayEx(a,b,c,d,0,e) 
....................  
.................... /***************************************************************************** 
....................   Summary: 
.................... 	Alias to TCPOpen as a server. 
....................  
....................   Description: 
.................... 	This function is an alias to TCPOpen for server sockets.  It is provided 
.................... 	for backwards compatibility with older versions of the stack.  New 
.................... 	applications should use the TCPOpen API instead. 
....................   ***************************************************************************/ 
.................... #define TCPListen(port)			TCPOpen(0, TCP_OPEN_SERVER, port, TCP_PURPOSE_DEFAULT) 
....................  
.................... /***************************************************************************** 
....................   Summary: 
.................... 	Alias to TCPOpen as a client. 
....................  
....................   Description: 
.................... 	This function is an alias to TCPOpen for client sockets.  It is provided 
.................... 	for backwards compatibility with older versions of the stack.  New 
.................... 	applications should use the TCPOpen API instead. 
....................   ***************************************************************************/ 
.................... #define TCPConnect(remote,port)	TCPOpen((DWORD)remote, TCP_OPEN_NODE_INFO, port, TCP_PURPOSE_DEFAULT) 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    	Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		03/16/07	Original 
....................  ********************************************************************/ 
.................... #ifndef __ICMP_H 
.................... #define __ICMP_H 
....................  
.................... void ICMPProcess(NODE_INFO *remote, WORD len); 
....................  
.................... BOOL ICMPBeginUsage(void); 
.................... void ICMPSendPing(DWORD dwRemoteIP); 
.................... void ICMPSendPingToHost(BYTE * szRemoteHost); 
.................... LONG ICMPGetReply(void); 
.................... void ICMPEndUsage(void); 
....................  
.................... #if defined(__18CXX) 
.................... 	void ICMPSendPingToHostROM(ROM BYTE * szRemoteHost); 
.................... #else 
.................... 	#define ICMPSendPingToHostROM(a) 	ICMPSendPingToHost((BYTE*)(a)) 
.................... #endif 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #if defined(MRF24WG) 
....................  #define WF_DisplayModuleAssertInfo() 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_CCS_HTTP1_SERVER) 
....................    #include "ccs_HTTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    #include "ccs_HTTP2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_TWITTER) 
....................    #include "ccs_twitter.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SMTP) 
....................    #include "ccs_SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_TFTP_SERVER) 
....................    #include "ccs_TFTPs.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    #include "ccs_SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_GRATUITOUS_ARP) 
....................    #include "ccs_gratarp.h" 
.................... #endif 
....................  
.................... #define TickGetDiff(a, b)  (a-b) 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................        #if !defined(STACK_USE_DNS) 
....................            #define STACK_USE_DNS 
....................        #endif 
....................        #if !defined(STACK_USE_UDP) 
....................            #define STACK_USE_UDP 
....................        #endif        
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    #ifndef STACK_USE_MPFS 
....................       #define STACK_USE_MPFS 
....................     #endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    #if !defined(STACK_CLIENT_MODE) 
....................        #define STACK_CLIENT_MODE 
....................    #endif 
.................... #endif 
....................  
.................... #if STACK_USE_WIFI 
....................    // if defined, MyWFIsConnected() won't return TRUE in AdHoc mode until after 
....................    // it receives some IP traffic.  It will then stay connected until after 5 
....................    // minutes of no activity. 
....................    #define WIFI_ADHOC_CONNECTION_TIMER ((TICK)TICKS_PER_SECOND * 300) 
....................     
....................    #if defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    extern int1 g_WifiAdhocIsConn; 
....................    extern TICK g_WifiAdhocTickConn; 
....................    #endif 
....................     
....................    extern unsigned int8 WIFI_channelList[16]; 
....................    extern unsigned int8 WIFI_numChannelsInList; 
....................    extern unsigned int8 WIFI_region; 
....................    extern int1 g_WifiConnectFail; 
....................     
....................    // this is similar to MACIsLinked() and WFisConnected().  this one has some 
....................    // filters and extra UI logic to better represent link status to the user. 
....................    // use this for UI displays. 
....................    // REMOVED - Use IsLinked() instead 
....................    //int1 MyWFisConnected(void); 
....................     
....................    // This routine does a few things: 
....................    //  * Reset WIFI unit if no it goes a long time without a connection, 
....................    //       because old modules would hang on WPA connect failure. 
....................    //  * Ad-Hoc connection timer support (WIFI_ADHOC_CONNECTION_TIMER) 
....................    //  * LED Traffic flickering and LED connection status 
....................    void WIFIConnectTask(void); 
....................     
....................    #if defined(WF_FORCE_NO_PS_POLL) 
....................       void WF_CCS_PsPollDisable(void); 
....................    #endif 
.................... #endif 
....................  
.................... int1 DHCPBoundOrDisabled(void); 
....................  
.................... // A higher level version of MACIsLinked(). 
.................... //  - returns FALSE if MACIsLinked() is TRUE -but- DHCP is enabled and not 
.................... //       bound. 
.................... //  - returns FALSE in WIFI if using AdHoc mode and it has been a while 
.................... //       since no traffic 
.................... //  - else, returns MACIsLinked() 
.................... int1 IsLinked(void); 
....................  
.................... //this macro called by stack when new tcp/ip traffic tx/rx. 
.................... #if STACK_USE_WIFI 
....................    #define STACK_USE_CCS_TX_EVENT()  LinkTraffic(TRUE) 
....................    #define STACK_USE_CCS_RX_EVENT()  LinkTraffic(FALSE) 
....................    void LinkTraffic(int1 isTx); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS) 
....................    #include "TCPIP Stack/mpfs.h" 
....................     
....................    extern MPFS _MpfsEofLoc; 
....................     
....................    //returns number of bytes read before EOF. 
....................    //if it returns n then no EOF. 
....................    unsigned int16 MPFSGetBytes(unsigned int8 *pDest, unsigned int16 n); 
.................... #endif 
....................  
.................... #if defined(__PCH__) 
.................... TICK TickGetSafe(void); 
.................... #endif 
....................  
.................... BYTE GenerateRandomByteFromTimers(void); 
....................  
.................... #endif 
....................  
....................  
.................... #if STACK_USE_CCS_INI 
....................    #include "ee.h" 
....................    #include "ccsui.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS) 
....................    #if !defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)  
....................       #if defined(__PCD__) 
....................          #import(RAW, file="mpfs/mpfsimg.bin", location=MPFS_Start, bpi=2) 
....................       #else 
....................          #import(RAW, file="mpfs/mpfsimg.bin", location=MPFS_Start) 
....................       #endif 
....................    #endif 
.................... #endif 
....................  
....................  
.................... void DebugPutc(char c) 
.................... { 
....................    fputc(c, STREAM_UI); 
.................... } 
....................  
.................... //#define debug_tftp   printf 
.................... //#define debug_tftp_putc DebugPutc 
....................  
.................... //#define debug_html         printf 
.................... //#define debug_html_putc    DebugPutc 
....................  
.................... //#define debug_mpfs         printf 
.................... //#define debug_mpfs_putc    DebugPutc 
....................  
.................... //#define debug_enc28j60  printf 
.................... //#define debug_enc28j60_putc  DebugPutc 
.................... //void MACToString(char *str, MAC_ADDR *mac); 
....................  
.................... //#define debug_dhcp   printf 
.................... //#define debug_dhcp_putc DebugPutc 
....................  
.................... //#define debug_tcp printf 
.................... //#define debug_tcp_putc  DebugPutc 
....................  
.................... #include "tcpip/StackTsk2.c" 
.................... // 'glue' file for using Microchip's TCP/IP stack inside CCS C Compiler without 
.................... // a linker.   
.................... // Also includes some macros/defines for porting older V3 stack to this current 
.................... // stack. 
.................... // Also provides extra routines written by CCS to improve the stack. 
.................... // 
.................... // __DISABLE_WIFI_INTERRUPT__ was supported in an older 5.3x version of the 
.................... // stack, but it is currently not supported anymore. 
....................  
.................... #ifndef __CCS_STACKTSK2_C__ 
.................... #define __CCS_STACKTSK2_C__ 
....................  
.................... #if defined(__DISABLE_WIFI_INTERRUPT__) 
....................    #error This has been removed. 
.................... #endif 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if defined(__PCH__) 
.................... #int_timer0 NOCLEAR 
.................... void ISRTimer0(void) 
.................... { 
....................    TickUpdate(); 
*
000B0:  BRA    0096
.................... } 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) && !defined(__DISABLE_WIFI_INTERRUPT__) 
.................... #int_EXT HIGH NOCLEAR 
....................    void ISREXT0(void) 
....................    { 
....................          WFEintISR(); 
....................        
....................    } 
.................... #endif 
....................  
.................... #if defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    int1 g_WifiAdhocIsConn = FALSE; 
....................    TICK g_WifiAdhocTickConn; 
....................    #define WIFIAdhocConnectionPing()   g_WifiAdhocIsConn=TRUE; g_WifiAdhocTickConn=TickGet() 
....................    #define WIFIAdhocConnectionReset()  g_WifiAdhocIsConn = FALSE 
.................... #endif 
....................  
.................... #include "StackTsk.c" 
.................... /********************************************************************* 
....................  * 
....................  *   TCP/IP Stack Manager 
....................  *  Module for Microchip TCP/IP Stack 
....................  *    -Handles internal RX packet pre-processing prior to dispatching  
....................  *    to upper application layers. 
....................  *    -Reference: AN833 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.c 
....................  * Dependencies:    ARP, IP, Network layer interface (ENC28J60.c,  
....................  *               ETH97J60.c, ENCX24J600.c, or WFMac.c) 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  * 
....................  * Darren Rook/CCS       4/13/11    Added some CCS modules (see STACK_USE_CCS_*) 
....................  *                                  Added STACK_USE_CCS_RX_EVENT() macro on TCP/IP traffic.  
.................... ********************************************************************/ 
.................... #define __STACKTSK_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
000B2:  GOTO   0054
.................... #if defined( WF_CS_TRIS ) 
....................     #if defined( WF_CONFIG_CONSOLE ) 
....................         #include "TCPIP Stack/WFConsole.h" 
....................     #endif 
....................     #if defined( STACK_USE_EZ_CONFIG ) || defined( EZ_CONFIG_SCAN ) 
....................         #include "TCPIP Stack/WFEasyConfig.h" 
....................     #endif 
....................    #include "TCPIP Stack/WFApi.h" 
.................... #endif 
....................  
.................... // Stack FSM states. 
.................... typedef enum 
.................... { 
....................     SM_STACK_IDLE, 
....................     SM_STACK_MAC, 
....................     SM_STACK_IP, 
....................     SM_STACK_ARP, 
....................     SM_STACK_TCP, 
....................     SM_STACK_UDP 
.................... } SM_STACK; 
.................... static SM_STACK smStack; 
....................  
.................... NODE_INFO remoteNode; 
....................  
.................... #if defined (WF_CS_TRIS) && defined (STACK_USE_DHCP_CLIENT) 
.................... BOOL g_DhcpRenew = FALSE; 
.................... extern void SetDhcpProgressState(void); 
.................... UINT32 g_DhcpRetryTimer = 0; 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componets are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines are used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void) 
.................... { 
....................    static BOOL once = FALSE; 
....................     smStack                     = SM_STACK_IDLE; 
*
0164E:  CLRF   5C
....................  
.................... #if defined(STACK_USE_IP_GLEANING) || defined(STACK_USE_DHCP_CLIENT) 
....................     /* 
....................      * If DHCP or IP Gleaning is enabled, 
....................      * startup in Config Mode. 
....................      */ 
....................     AppConfig.Flags.bInConfigMode = TRUE; 
....................  
.................... #endif 
....................  
.................... #if defined (WF_CS_TRIS) && defined (STACK_USE_DHCP_CLIENT) 
....................    g_DhcpRenew = FALSE; 
....................    g_DhcpRetryTimer = 0; 
.................... #endif 
....................  
....................    if (!once) { 
01650:  BTFSC  67.0
01652:  BRA    167E
....................       // Seed the LFSRRand() function 
....................       LFSRSeedRand(GenerateRandomDWORD()); 
01654:  CALL   0774
01658:  MOVFF  03,16F
0165C:  MOVFF  02,16E
01660:  MOVFF  01,16D
01664:  MOVFF  00,16C
01668:  MOVFF  03,190
0166C:  MOVFF  02,18F
01670:  MOVFF  01,18E
01674:  MOVFF  00,18D
01678:  CALL   0712
....................       once = TRUE; 
0167C:  BSF    67.0
....................    } 
....................  
....................     MACInit(); 
0167E:  GOTO   0AC8
....................  
.................... #if defined (WF_AGGRESSIVE_PS) && defined (WF_CS_TRIS) 
....................    WFEnableAggressivePowerSave(); 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) && defined(STACK_USE_EZ_CONFIG) && !defined(__18CXX) 
....................     WFEasyConfigInit(); 
.................... #endif     
....................  
....................     ARPInit(); 
01682:  GOTO   0CE6
....................  
.................... #if defined(STACK_USE_UDP) 
....................     UDPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
....................     TCPInit(); 
01686:  BRA    14AA
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
....................    BerkeleySocketInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
....................     HTTPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
....................    RSAInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
....................     SSLInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) && defined(STACK_USE_MPFS2) 
....................     FTPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
....................    SNMPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) 
....................    DHCPInit(0); 
....................     if(!AppConfig.Flags.bIsDHCPEnabled) 
....................     { 
....................         DHCPDisable(0); 
....................     } 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     AutoIPInit(0); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
....................    DDNSInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
....................    RandomInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SMTP) 
....................    SMTPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    NTPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_GRATUITOUS_ARP) 
....................    GratArpInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP1_SERVER) || defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    HTTPInit(); 
.................... #endif 
....................  
....................    #if defined(STACK_USE_CCS_TFTP_SERVER) 
01688:  GOTO   664E (RETURN)
....................    TFTPSInit(); 
....................    #endif 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically to 
....................  *                  ensure timely responses. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void) 
.................... { 
....................     WORD dataCount; 
....................     IP_ADDR tempLocalIP; 
....................    BYTE cFrameType; 
....................    BYTE cIPFrameType; 
....................  
....................     
....................     #if defined( WF_CS_TRIS ) 
....................         // This task performs low-level MAC processing specific to the MRF24W 
....................         MACProcess(); 
....................         #if defined( STACK_USE_EZ_CONFIG ) && !defined(__18CXX) 
....................             WFEasyConfigMgr(); 
....................         #endif 
....................          
....................        #if defined(STACK_USE_DHCP_CLIENT) 
....................            // Normally, an application would not include  DHCP module 
....................            // if it is not enabled. But in case some one wants to disable 
....................            // DHCP module at run-time, remember to not clear our IP 
....................            // address if link is removed. 
....................            if(AppConfig.Flags.bIsDHCPEnabled) 
....................            { 
....................               if(g_DhcpRenew == TRUE) 
....................               { 
....................                  g_DhcpRenew = FALSE; 
....................                   AppConfig.MyIPAddr.Val = AppConfig.DefaultIPAddr.Val; 
....................                  AppConfig.MyMask.Val = AppConfig.DefaultMask.Val; 
....................                  AppConfig.Flags.bInConfigMode = TRUE; 
....................                  DHCPInit(0); 
....................                g_DhcpRetryTimer = (UINT32)TickGet(); 
....................               } else { 
....................                  if (g_DhcpRetryTimer && TickGet() - g_DhcpRetryTimer >= TICKS_PER_SECOND * 8) { 
....................                   DHCPInit(0); 
....................                   g_DhcpRetryTimer = (UINT32)TickGet(); 
....................                  } 
....................               } 
....................             
....................               // DHCP must be called all the time even after IP configuration is 
....................               // discovered. 
....................               // DHCP has to account lease expiration time and renew the configuration 
....................               // time. 
....................               DHCPTask(); 
....................                
....................               if(DHCPIsBound(0)) { 
....................                  AppConfig.Flags.bInConfigMode = FALSE; 
....................                g_DhcpRetryTimer = 0; 
....................               } 
....................            } 
....................        #endif // STACK_USE_DHCP_CLIENT 
....................          
....................     #endif // WF_CS_TRIS 
....................  
....................  
....................    #if defined(STACK_USE_DHCP_CLIENT) && !defined(WF_CS_TRIS) 
....................    // Normally, an application would not include  DHCP module 
....................    // if it is not enabled. But in case some one wants to disable 
....................    // DHCP module at run-time, remember to not clear our IP 
....................    // address if link is removed. 
....................    if(AppConfig.Flags.bIsDHCPEnabled) 
....................    { 
....................       static BOOL bLastLinkState = FALSE; 
....................       BOOL bCurrentLinkState; 
....................        
....................       bCurrentLinkState = MACIsLinked(); 
....................       if(bCurrentLinkState != bLastLinkState) 
....................       { 
....................          bLastLinkState = bCurrentLinkState; 
....................          if(!bCurrentLinkState) 
....................          { 
....................             AppConfig.MyIPAddr.Val = AppConfig.DefaultIPAddr.Val; 
....................             AppConfig.MyMask.Val = AppConfig.DefaultMask.Val; 
....................             AppConfig.Flags.bInConfigMode = TRUE; 
....................             DHCPInit(0); 
....................          } 
....................       } 
....................     
....................       // DHCP must be called all the time even after IP configuration is 
....................       // discovered. 
....................       // DHCP has to account lease expiration time and renew the configuration 
....................       // time. 
....................       DHCPTask(); 
....................        
....................       if(DHCPIsBound(0)) 
....................          AppConfig.Flags.bInConfigMode = FALSE; 
....................    } 
....................    #endif 
....................     
....................  
....................     #if defined (STACK_USE_AUTO_IP) 
....................     AutoIPTasks(); 
....................     #endif 
....................  
....................    #if defined(STACK_USE_TCP) 
....................    // Perform all TCP time related tasks (retransmit, send acknowledge, close connection, etc) 
....................    TCPTick(); 
*
059CA:  GOTO   3180
....................    #endif 
....................  
....................  
....................    #if defined(STACK_USE_UDP) 
....................    UDPTask(); 
....................    #endif 
....................  
....................   #if defined(STACK_USE_CCS_GRATUITOUS_ARP) 
....................    GratArpTask(); 
....................   #endif 
....................  
....................    // Process as many incomming packets as we can 
....................    while(1) 
....................    { 
....................       //if using the random module, generate entropy 
....................       #if defined(STACK_USE_RANDOM) 
....................          RandomAdd(remoteNode.MACAddr.v[5]); 
....................       #endif 
....................  
....................       // We are about to fetch a new packet, make sure that the  
....................       // UDP module knows that any old RX data it has laying  
....................       // around will now be gone. 
....................       #if defined(STACK_USE_UDP) 
....................          UDPDiscard(); 
....................       #endif 
....................  
....................       // Fetch a packet (throws old one away, if not thrown away  
....................       // yet) 
....................       if(!MACGetHeader(&remoteNode.MACAddr, &cFrameType)) 
059CE:  MOVLB  1
059D0:  CLRF   x75
059D2:  MOVLW  61
059D4:  MOVWF  x74
059D6:  MOVLW  01
059D8:  MOVWF  x77
059DA:  MOVLW  72
059DC:  MOVWF  x76
059DE:  MOVLB  0
059E0:  GOTO   3A56
059E4:  MOVF   01,F
059E6:  BNZ   59EA
....................          break; 
059E8:  BRA    5B00
....................  
....................       // When using a WiFi module, filter out all incoming packets that have  
....................       // the same source MAC address as our own MAC address.  This is to  
....................       // prevent receiving and passing our own broadcast packets up to other  
....................       // layers and avoid, for example, having our own gratuitous ARPs get  
....................       // answered by ourself. 
....................       #if defined(WF_CS_TRIS) 
....................          if(memcmp((void*)&remoteNode.MACAddr, (void*)&AppConfig.MyMACAddr, 6) == 0u) 
....................             continue; 
....................       #endif 
....................        
....................       #if defined(STACK_USE_CCS_RX_EVENT) 
....................       STACK_USE_CCS_RX_EVENT();  //__CCS__ 
....................       #endif 
....................        
....................       // Dispatch the packet to the appropriate handler 
....................       switch(cFrameType) 
059EA:  MOVLB  1
059EC:  MOVF   x72,W
059EE:  XORLW  06
059F0:  MOVLB  0
059F2:  BZ    59FA
059F4:  XORLW  06
059F6:  BZ    5A00
059F8:  BRA    5AFE
....................       { 
....................          case MAC_ARP: 
....................             ARPProcess(); 
059FA:  GOTO   3BA2
....................             break; 
059FE:  BRA    5AFE
....................     
....................          case MAC_IP: 
....................             if(!IPGetHeader(&tempLocalIP, &remoteNode, &cIPFrameType, &dataCount)) 
05A00:  MOVLW  01
05A02:  MOVLB  1
05A04:  MOVWF  x75
05A06:  MOVLW  6E
05A08:  MOVWF  x74
05A0A:  CLRF   x77
05A0C:  MOVLW  5D
05A0E:  MOVWF  x76
05A10:  MOVLW  01
05A12:  MOVWF  x79
05A14:  MOVLW  73
05A16:  MOVWF  x78
05A18:  MOVLW  01
05A1A:  MOVWF  x7B
05A1C:  MOVLW  6C
05A1E:  MOVWF  x7A
05A20:  MOVLB  0
05A22:  GOTO   3DEC
05A26:  MOVF   01,F
05A28:  BNZ   5A2C
....................                break; 
05A2A:  BRA    5AFE
....................  
....................             #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................             if(cIPFrameType == IP_PROT_ICMP) 
05A2C:  MOVLB  1
05A2E:  DECFSZ x73,W
05A30:  BRA    5AD8
....................             { 
....................                #if defined(STACK_USE_IP_GLEANING) 
....................                if(AppConfig.Flags.bInConfigMode && AppConfig.Flags.bIsDHCPEnabled) 
....................                { 
....................                   // According to "IP Gleaning" procedure, 
....................                   // when we receive an ICMP packet with a valid 
....................                   // IP address while we are still in configuration 
....................                   // mode, accept that address as ours and conclude 
....................                   // configuration mode. 
....................                   if(tempLocalIP.Val != 0xffffffff) 
....................                   { 
....................                      AppConfig.Flags.bInConfigMode = FALSE; 
....................                      AppConfig.MyIPAddr = tempLocalIP; 
....................                   } 
....................                } 
....................                #endif 
....................  
....................                // Process this ICMP packet if it the destination IP address matches our address or one of the broadcast IP addressees 
....................                if( (tempLocalIP.Val == AppConfig.MyIPAddr.Val) || 
....................                   (tempLocalIP.Val == 0xFFFFFFFF) || 
.................... #if defined(STACK_USE_ZEROCONF_LINK_LOCAL) || defined(STACK_USE_ZEROCONF_MDNS_SD) 
....................                                                 (tempLocalIP.Val == 0xFB0000E0) || 
.................... #endif 
....................                   (tempLocalIP.Val == ((AppConfig.MyIPAddr.Val & AppConfig.MyMask.Val) | ~AppConfig.MyMask.Val))) 
05A32:  MOVF   29,W
05A34:  SUBWF  x6E,W
05A36:  BNZ   5A4A
05A38:  MOVF   2A,W
05A3A:  SUBWF  x6F,W
05A3C:  BNZ   5A4A
05A3E:  MOVF   2B,W
05A40:  SUBWF  x70,W
05A42:  BNZ   5A4A
05A44:  MOVF   2C,W
05A46:  SUBWF  x71,W
05A48:  BZ    5ABC
05A4A:  INCFSZ x6E,W
05A4C:  BRA    5A5C
05A4E:  INCFSZ x6F,W
05A50:  BRA    5A5C
05A52:  INCFSZ x70,W
05A54:  BRA    5A5C
05A56:  INCFSZ x71,W
05A58:  BRA    5A5C
05A5A:  BRA    5ABC
05A5C:  MOVF   29,W
05A5E:  ANDWF  2D,W
05A60:  MOVWF  x74
05A62:  MOVF   2A,W
05A64:  ANDWF  2E,W
05A66:  MOVWF  x75
05A68:  MOVF   2B,W
05A6A:  ANDWF  2F,W
05A6C:  MOVWF  x76
05A6E:  MOVF   2C,W
05A70:  ANDWF  30,W
05A72:  MOVWF  x77
05A74:  MOVFF  2D,00
05A78:  COMF   00,F
05A7A:  MOVFF  2E,01
05A7E:  COMF   01,F
05A80:  MOVFF  2F,02
05A84:  COMF   02,F
05A86:  MOVFF  30,03
05A8A:  COMF   03,F
05A8C:  MOVF   00,W
05A8E:  IORWF  x74,W
05A90:  MOVWF  00
05A92:  MOVF   01,W
05A94:  IORWF  x75,W
05A96:  MOVWF  01
05A98:  MOVF   02,W
05A9A:  IORWF  x76,W
05A9C:  MOVWF  02
05A9E:  MOVF   03,W
05AA0:  IORWF  x77,W
05AA2:  MOVWF  03
05AA4:  MOVF   00,W
05AA6:  SUBWF  x6E,W
05AA8:  BNZ   5AD2
05AAA:  MOVF   01,W
05AAC:  SUBWF  x6F,W
05AAE:  BNZ   5AD2
05AB0:  MOVF   02,W
05AB2:  SUBWF  x70,W
05AB4:  BNZ   5AD2
05AB6:  MOVF   03,W
05AB8:  SUBWF  x71,W
05ABA:  BNZ   5AD2
....................                { 
....................                   ICMPProcess(&remoteNode, dataCount); 
05ABC:  CLRF   x75
05ABE:  MOVLW  5D
05AC0:  MOVWF  x74
05AC2:  MOVFF  16D,177
05AC6:  MOVFF  16C,176
05ACA:  MOVLB  0
05ACC:  GOTO   3EF0
05AD0:  MOVLB  1
....................                } 
....................  
....................                break; 
05AD2:  MOVLB  0
05AD4:  BRA    5AFE
05AD6:  MOVLB  1
....................             } 
....................             #endif 
....................              
....................             #if defined(STACK_USE_TCP) 
....................             if(cIPFrameType == IP_PROT_TCP) 
05AD8:  MOVF   x73,W
05ADA:  SUBLW  06
05ADC:  BNZ   5AFC
....................             { 
....................                TCPProcess(&remoteNode, &tempLocalIP, dataCount); 
05ADE:  CLRF   x75
05AE0:  MOVLW  5D
05AE2:  MOVWF  x74
05AE4:  MOVLW  01
05AE6:  MOVWF  x77
05AE8:  MOVLW  6E
05AEA:  MOVWF  x76
05AEC:  MOVFF  16D,179
05AF0:  MOVFF  16C,178
05AF4:  MOVLB  0
05AF6:  BRA    584E
....................                break; 
05AF8:  BRA    5AFE
05AFA:  MOVLB  1
....................             } 
....................             #endif 
....................              
....................             #if defined(STACK_USE_UDP) 
....................             if(cIPFrameType == IP_PROT_UDP) 
....................             { 
....................                // Stop processing packets if we came upon a UDP frame with application data in it 
....................                if(UDPProcess(&remoteNode, &tempLocalIP, dataCount)) 
....................                   return; 
....................             } 
....................             #endif 
....................  
....................             break; 
05AFC:  MOVLB  0
....................       } 
05AFE:  BRA    59CE
....................    } 
05B00:  GOTO   6658 (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackApplications(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Calls all loaded application modules. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called periodically to 
....................  *                  ensure timely responses. 
....................  * 
....................  ********************************************************************/ 
.................... void StackApplications(void) 
.................... { 
....................    #if defined(STACK_USE_HTTP2_SERVER) 
....................    HTTPServer(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_FTP_SERVER) && defined(STACK_USE_MPFS2) 
....................    FTPServer(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_SNMP_SERVER) 
....................    SNMPTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_ANNOUNCE) 
....................    DiscoveryTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_NBNS) 
....................    NBNSTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_DHCP_SERVER) 
....................    DHCPServerTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_DNS_SERVER) 
....................    DNSServerTask(); 
....................    #endif 
....................     
....................    #if defined (STACK_USE_DYNAMICDNS_CLIENT) 
....................    DDNSTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_TELNET_SERVER) 
....................    TelnetTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_REBOOT_SERVER) 
....................    RebootTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_SNTP_CLIENT) 
....................    SNTPClient(); 
....................    #endif 
....................  
....................    #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
....................    UDPPerformanceTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
....................    TCPPerformanceTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_SMTP_CLIENT) 
....................    SMTPTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_UART2TCP_BRIDGE) 
....................    UART2TCPBridgeTask(); 
....................    #endif 
....................  
....................    #if defined(STACK_USE_CCS_SMTP) 
....................    SMTPTask(); 
....................    #endif    
....................  
....................    #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    NTPTask(); 
....................    #endif 
....................  
....................    #if defined(STACK_USE_CCS_HTTP1_SERVER) || defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    HTTPServer(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_CCS_TFTP_SERVER) 
....................    TFTPSTask(); 
....................    #endif 
....................  
....................    #if defined(STACK_USE_TWITTER)   //should be renamed STACK_USE_CCS_TWITTER 
....................    TwitterTask();         // processes TCP tasks including the Tweet tasks 
....................    #endif    
.................... } 
....................  
.................... #if defined(WF_CS_TRIS) && defined(STACK_USE_DHCP_CLIENT) 
.................... void RenewDhcp(void) 
.................... { 
....................     g_DhcpRenew = TRUE; 
....................     SetDhcpProgressState(); 
.................... }     
....................      
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "Helpers.c" 
.................... /********************************************************************* 
....................   
....................  Helper Functions for Microchip TCPIP Stack 
....................   
....................  FileName:      Helpers.c 
....................  Dependencies:  See INCLUDES section 
....................  Processor:     PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:      Microchip C18, C30, C32 
....................  Company:       Microchip Technology, Inc. 
....................  
....................  Software License Agreement 
....................  
....................  Copyright (C) 2002-2011 Microchip Technology Inc.  All rights 
....................  reserved. 
....................  
....................  Microchip licenses to you the right to use, modify, copy, and 
....................  distribute: 
....................  (i)  the Software when embedded on a Microchip microcontroller or 
....................       digital signal controller product ("Device") which is 
....................       integrated into Licensee's product; or 
....................  (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................       ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................       used in conjunction with a Microchip ethernet controller for 
....................       the sole purpose of interfacing with the ethernet controller. 
....................  
....................  You should refer to the license agreement accompanying this 
....................  Software for additional information regarding your rights and 
....................  obligations. 
....................  
....................  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  
....................  ******************************************************************** 
....................  File Description: 
....................   
....................  Change History: 
....................   
....................   Rev         Description 
....................   ----------  ------------------------------------------------------- 
....................   1.0 - 5.31  Initial release; Rewritten CalcIPChecksum() to avoid 
....................               multi-byte shift operation; Added hexatob(), 
....................               btohexa_high(), and btohexa_low(); Optimized swapl(); 
....................               Added leftRotateDWORD() 
....................   5.36        Updated compile time check for ultoa(); 
....................  
....................    DARREN ROOK/CCS   Remove leftRotateDWORD() 
....................  
....................  ********************************************************************/ 
.................... #define __HELPERS_C 
....................  
.................... #include <stdarg.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDARG 
....................  
.................... #define _STDARG 
....................  
.................... typedef char * va_list; 
....................  
.................... #define va_start(a,b)  a=_VA_LIST 
.................... #define va_arg(a,b)    *(b *)_va_arg(a) 
.................... #define va_end 
.................... #define nargs          _nargs(&_va_list) 
....................  
.................... int8 _nargs(int8 * ptr) { 
....................   int8 n; 
....................  
....................   n=0; 
....................   while(*ptr) { 
....................     n++; 
....................     ptr+=*ptr; 
....................   } 
....................   return(n); 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
....................  
.................... // Default Random Number Generator seed. 0x41FE9F9E corresponds to calling LFSRSeedRand(1) 
.................... static DWORD dwLFSRRandSeed = 0x41FE9F9E; 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    DWORD LFSRSeedRand(DWORD dwSeed) 
....................  
....................   Summary: 
....................    Seeds the LFSR random number generator invoked by the LFSRRand() function.   
....................    The prior seed is returned. 
....................  
....................   Description: 
....................    Seeds the LFSR random number generator invoked by the LFSRRand() function.   
....................    The prior seed is returned. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    wSeed - The new 32-bit seed value to assign to the LFSR. 
....................  
....................   Returns: 
....................      The last seed in use.  This can be saved and restored by a subsequent call  
....................    to LFSRSeedRand() if you wish to use LFSRRand() in multiple contexts  
....................    without disrupting the random number sequence from the alternative  
....................    context.  For example, if App 1 needs a given sequence of random numbers  
....................    to perform a test, if you save and restore the seed in App 2, it is  
....................    possible for App 2 to not disrupt the random number sequence provided to  
....................    App 1, even if the number of times App 2 calls LFSRRand() varies. 
....................       
....................   Side Effects: 
....................    None 
....................     
....................   Remarks: 
....................    Upon initial power up, the internal seed is initialized to 0x1.  Using a  
....................    dwSeed value of 0x0 will return the same sequence of random numbers as  
....................    using the seed of 0x1. 
....................   ***************************************************************************/ 
.................... DWORD LFSRSeedRand(DWORD dwSeed) 
.................... { 
....................    DWORD dwOldSeed; 
....................    BYTE i; 
....................  
....................    // Save original seed to be returned later 
....................    dwOldSeed = dwLFSRRandSeed; 
*
00712:  MOVFF  6B,194
00716:  MOVFF  6A,193
0071A:  MOVFF  69,192
0071E:  MOVFF  68,191
....................  
....................    // Ensure zero isn't selected as a seed value, this would result in all  
....................    // 0x0000 output values from the LFSR 
....................    if(dwSeed == 0u) 
00722:  MOVLB  1
00724:  MOVF   x8D,F
00726:  BNZ   073E
00728:  MOVF   x8E,F
0072A:  BNZ   073E
0072C:  MOVF   x8F,F
0072E:  BNZ   073E
00730:  MOVF   x90,F
00732:  BNZ   073E
....................       dwSeed = 1; 
00734:  CLRF   x90
00736:  CLRF   x8F
00738:  CLRF   x8E
0073A:  MOVLW  01
0073C:  MOVWF  x8D
....................        
....................    // Set the new seed 
....................    dwLFSRRandSeed = dwSeed; 
0073E:  MOVFF  190,6B
00742:  MOVFF  18F,6A
00746:  MOVFF  18E,69
0074A:  MOVFF  18D,68
....................     
....................    // Run the LFSR a few times to get rid of obvious start up artifacts for  
....................    // seed values that don't have many set bits. 
....................    for(i = 0; i < 16; i++) 
0074E:  CLRF   x95
00750:  MOVF   x95,W
00752:  SUBLW  0F
00754:  BNC   0760
....................       LFSRRand(); 
00756:  MOVLB  0
00758:  RCALL  0698
0075A:  MOVLB  1
0075C:  INCF   x95,F
0075E:  BRA    0750
....................     
....................    // Return saved old seed 
....................    return dwOldSeed; 
00760:  MOVFF  191,00
00764:  MOVFF  192,01
00768:  MOVFF  193,02
0076C:  MOVFF  194,03
00770:  MOVLB  0
00772:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD LFSRRand(void) 
....................  
....................   Summary: 
....................    Returns a pseudo-random 16-bit unsigned integer in the range from 0  
....................    to 65535 (0x0000 to 0xFFFF). 
....................  
....................   Description: 
....................    Returns a pseudo-random 16-bit unsigned integer in the range from 0  
....................    to 65535 (0x0000 to 0xFFFF).  The random number is generated using a  
....................    Linear Feedback Shift Register (LFSR) type pseudo-random number generator  
....................    algorithm.  The LFSR can be seeded by calling the LFSRSeedRand() function 
....................    to generate the same sequence of random numbers as a prior string of calls. 
....................     
....................    The internal LFSR will repeat after 2^32-1 iterations. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................      Random 16-bit unsigned integer. 
....................       
....................   Side Effects: 
....................    The internal LFSR seed is updated so that the next call to LFSRRand()  
....................    will return a different random number. 
....................     
....................   Remarks: 
....................    None 
....................   ***************************************************************************/ 
.................... WORD LFSRRand(void) 
.................... { 
....................    BYTE i; 
....................     
....................    // Taps: 32 31 29 1 
....................    // Characteristic polynomial: x^32 + x^31 + x^29 + x + 1 
....................    // Repeat 15 times to make the shift pattern less obvious 
....................    for(i = 0; i < 15; i++) 
*
00698:  MOVLB  2
0069A:  CLRF   x6D
0069C:  MOVF   x6D,W
0069E:  SUBLW  0E
006A0:  BNC   0706
....................       dwLFSRRandSeed = (dwLFSRRandSeed >> 1) ^ ((0ul - (dwLFSRRandSeed & 1ul)) & 0xD0000001ul); 
006A2:  BCF    FD8.0
006A4:  RRCF   6B,W
006A6:  MOVWF  x72
006A8:  RRCF   6A,W
006AA:  MOVWF  x71
006AC:  RRCF   69,W
006AE:  MOVWF  x70
006B0:  RRCF   68,W
006B2:  MOVWF  x6F
006B4:  MOVF   68,W
006B6:  ANDLW  01
006B8:  MOVWF  00
006BA:  CLRF   01
006BC:  CLRF   02
006BE:  CLRF   03
006C0:  MOVLW  00
006C2:  BSF    FD8.0
006C4:  SUBFWB 00,W
006C6:  MOVWF  x73
006C8:  MOVLW  00
006CA:  SUBFWB 01,W
006CC:  MOVWF  x74
006CE:  MOVLW  00
006D0:  SUBFWB 02,W
006D2:  MOVWF  x75
006D4:  MOVLW  00
006D6:  SUBFWB 03,W
006D8:  MOVWF  x76
006DA:  MOVF   x73,W
006DC:  ANDLW  01
006DE:  MOVWF  00
006E0:  CLRF   01
006E2:  CLRF   02
006E4:  MOVF   x76,W
006E6:  ANDLW  D0
006E8:  MOVWF  03
006EA:  MOVF   00,W
006EC:  XORWF  x6F,W
006EE:  MOVWF  68
006F0:  MOVF   01,W
006F2:  XORWF  x70,W
006F4:  MOVWF  69
006F6:  MOVF   02,W
006F8:  XORWF  x71,W
006FA:  MOVWF  6A
006FC:  MOVF   03,W
006FE:  XORWF  x72,W
00700:  MOVWF  6B
00702:  INCF   x6D,F
00704:  BRA    069C
....................  
....................    // Return 16-bits as pseudo-random number 
....................    return (WORD)dwLFSRRandSeed; 
00706:  MOVFF  68,01
0070A:  MOVFF  69,02
0070E:  MOVLB  0
00710:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    DWORD GenerateRandomDWORD(void) 
....................  
....................   Summary: 
....................    Generates a random DWORD. 
....................  
....................   Description: 
....................    This function generates a random 32-bit integer.  It collects 
....................    randomness by comparing the A/D converter's internal R/C oscillator 
....................    clock with our main system clock.  By passing collected entropy to the 
....................    LFSRSeedRand()/LFSRRand() functions, the output is normalized (deskewed)  
....................    in the hopes of meeting statistical randomness tests. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................      Random 32-bit number. 
....................       
....................   Side Effects: 
....................    This function uses the A/D converter (and so you must disable  
....................    interrupts if you use the A/D converted in your ISR).  The LFSRRand()  
....................    function will be reseeded, and Timer0 (PIC18) and Timer1 (PIC24,  
....................    dsPIC, and PIC32) will be used.  TMR#H:TMR#L will have a new value. 
....................    Note that this is the same timer used by the Tick module. 
....................     
....................   Remarks: 
....................    This function times out after 1 second of attempting to generate the  
....................    random DWORD.  In such a case, the output may not be truly random.   
....................    Typically, this function executes in around 500,000 instruction cycles. 
....................     
....................    The intent of this function is to produce statistically random and 
....................    cryptographically secure random number.  Whether or not this is true on 
....................    all (or any) devices/voltages/temperatures is not tested. 
....................   ***************************************************************************/ 
.................... DWORD GenerateRandomDWORD(void) 
.................... { 
....................    BYTE vBitCount; 
....................    WORD w, wTime, wLastValue; 
....................    DWORD dwTotalTime; 
....................    union 
....................    { 
....................       DWORD   dw; 
....................       WORD   w[2]; 
....................    } randomResult; 
....................  
.................... #if defined __18CXX    
.................... { 
....................    BYTE ADCON0Save, ADCON2Save; 
....................    BYTE T0CONSave, TMR0HSave, TMR0LSave; 
....................  
....................    // Save hardware SFRs 
....................    ADCON0Save = ADCON0; 
*
00774:  MOVFF  FC2,186
....................    ADCON2Save = ADCON2; 
00778:  MOVFF  FC0,187
....................    T0CONSave = T0CON; 
0077C:  MOVFF  FD5,188
....................    TMR0LSave = TMR0L; 
00780:  MOVFF  FD6,18A
....................    TMR0HSave = TMR0H; 
00784:  MOVFF  FD7,189
....................  
....................    // Set up Timer and A/D converter module 
....................    ADCON0 = 0x01;   // Turn on the A/D module 
00788:  MOVLW  01
0078A:  MOVWF  FC2
....................    ADCON2 = 0x3F;   // 20 Tad acquisition, Frc A/D clock used for conversion 
0078C:  MOVLW  3F
0078E:  MOVWF  FC0
....................    T0CON = 0x88;   // TMR0ON = 1, no prescalar 
00790:  MOVLW  88
00792:  MOVWF  FD5
....................    vBitCount = 0; 
00794:  MOVLB  1
00796:  CLRF   x77
....................    dwTotalTime = 0; 
00798:  CLRF   x81
0079A:  CLRF   x80
0079C:  CLRF   x7F
0079E:  CLRF   x7E
....................    wLastValue = 0; 
007A0:  CLRF   x7D
007A2:  CLRF   x7C
....................    randomResult.dw = LFSRRand(); 
007A4:  MOVLB  0
007A6:  RCALL  0698
007A8:  MOVLB  1
007AA:  CLRF   x85
007AC:  CLRF   x84
007AE:  MOVFF  02,183
007B2:  MOVFF  01,182
....................    while(1) 
....................    { 
....................       // Time the duration of an A/D acquisition and conversion 
....................       TMR0H = 0x00; 
007B6:  CLRF   FD7
....................       TMR0L = 0x00; 
007B8:  CLRF   FD6
....................       ADCON0bits.GO = 1; 
007BA:  BSF    FC2.1
....................       ClrWdt(); 
007BC:  CLRWDT
....................       while(ADCON0bits.GO); 
007BE:  BTFSC  FC2.1
007C0:  BRA    07BE
....................       ((BYTE*)&wTime)[0] = TMR0L; 
007C2:  MOVFF  FD6,17A
....................       ((BYTE*)&wTime)[1] = TMR0H; 
007C6:  MOVFF  FD7,17B
....................       w = LFSRRand(); 
007CA:  MOVLB  0
007CC:  RCALL  0698
007CE:  MOVFF  02,179
007D2:  MOVFF  01,178
....................     
....................       // Wait no longer than 1 second obtaining entropy 
....................       dwTotalTime += wTime; 
007D6:  MOVLB  1
007D8:  MOVF   x7A,W
007DA:  ADDWF  x7E,F
007DC:  MOVF   x7B,W
007DE:  ADDWFC x7F,F
007E0:  MOVLW  00
007E2:  ADDWFC x80,F
007E4:  ADDWFC x81,F
....................       if(dwTotalTime >= GetInstructionClock()) 
007E6:  MOVF   x81,F
007E8:  BNZ   0804
007EA:  MOVF   x80,W
007EC:  SUBLW  97
007EE:  BC    0822
007F0:  XORLW  FF
007F2:  BNZ   0804
007F4:  MOVF   x7F,W
007F6:  SUBLW  95
007F8:  BC    0822
007FA:  XORLW  FF
007FC:  BNZ   0804
007FE:  MOVF   x7E,W
00800:  SUBLW  7F
00802:  BC    0822
....................       { 
....................          randomResult.w[0] ^= LFSRRand(); 
00804:  MOVLB  0
00806:  RCALL  0698
00808:  MOVF   01,W
0080A:  MOVLB  1
0080C:  XORWF  x82,F
0080E:  MOVF   02,W
00810:  XORWF  x83,F
....................          randomResult.w[1] ^= LFSRRand(); 
00812:  MOVLB  0
00814:  RCALL  0698
00816:  MOVF   01,W
00818:  MOVLB  1
0081A:  XORWF  x84,F
0081C:  MOVF   02,W
0081E:  XORWF  x85,F
....................          break; 
00820:  BRA    0890
....................       } 
....................     
....................       // Keep sampling if minimal entropy was likely obtained this round 
....................       if(wLastValue == wTime) 
00822:  MOVF   x7A,W
00824:  SUBWF  x7C,W
00826:  BNZ   0830
00828:  MOVF   x7B,W
0082A:  SUBWF  x7D,W
0082C:  BNZ   0830
....................          continue; 
0082E:  BRA    07B6
....................     
....................       // Add this entropy into the pseudo random number generator by reseeding 
....................       LFSRSeedRand(w + (wLastValue - wTime)); 
00830:  MOVF   x7A,W
00832:  SUBWF  x7C,W
00834:  MOVWF  00
00836:  MOVF   x7B,W
00838:  SUBWFB x7D,W
0083A:  MOVWF  03
0083C:  MOVF   00,W
0083E:  ADDWF  x78,W
00840:  MOVWF  x8B
00842:  MOVF   03,W
00844:  ADDWFC x79,W
00846:  MOVWF  x8C
00848:  CLRF   x90
0084A:  CLRF   x8F
0084C:  MOVWF  x8E
0084E:  MOVFF  18B,18D
00852:  MOVLB  0
00854:  RCALL  0712
....................       wLastValue = wTime; 
00856:  MOVFF  17B,17D
0085A:  MOVFF  17A,17C
....................     
....................       // Accumulate at least 32 bits of randomness over time 
....................       randomResult.dw <<= 1; 
0085E:  BCF    FD8.0
00860:  MOVLB  1
00862:  RLCF   x82,F
00864:  RLCF   x83,F
00866:  RLCF   x84,F
00868:  RLCF   x85,F
....................       if(LFSRRand() & 0x0080) 
0086A:  MOVLB  0
0086C:  RCALL  0698
0086E:  MOVFF  02,18C
00872:  MOVFF  01,18B
00876:  MOVLB  1
00878:  MOVF   01,W
0087A:  ANDLW  80
0087C:  MOVWF  00
0087E:  CLRF   03
00880:  MOVF   00,W
00882:  IORWF  03,W
00884:  BZ    0888
....................          randomResult.w[0] |= 0x1; 
00886:  BSF    x82.0
....................     
....................       // See if we've collected a fair amount of entropy and can quit early 
....................       if(++vBitCount == 0u) 
00888:  INCF   x77,F
0088A:  BNZ   088E
....................          break; 
0088C:  BRA    0890
0088E:  BRA    07B6
....................    } 
....................  
....................    // Restore hardware SFRs 
....................    ADCON0 = ADCON0Save; 
00890:  MOVFF  186,FC2
....................    ADCON2 = ADCON2Save; 
00894:  MOVFF  187,FC0
....................    TMR0H = TMR0HSave; 
00898:  MOVFF  189,FD7
....................    TMR0L = TMR0LSave; 
0089C:  MOVFF  18A,FD6
....................    T0CON = T0CONSave; 
008A0:  MOVFF  188,FD5
.................... } 
.................... #else 
.................... { 
....................    WORD AD1CON1Save, AD1CON2Save, AD1CON3Save; 
....................    WORD T1CONSave, PR1Save; 
....................  
....................    // Save hardware SFRs 
....................    AD1CON1Save = AD1CON1; 
....................    AD1CON2Save = AD1CON2; 
....................    AD1CON3Save = AD1CON3; 
....................    T1CONSave = T1CON; 
....................    PR1Save = PR1; 
....................  
....................    // Set up Timer and A/D converter module 
....................    AD1CON1 = 0x0000;      // Turn off the ADC so we can write to it 
....................    AD1CON3 = 0x9F00;      // Frc A/D clock, 31 Tad acquisition 
....................    AD1CON2 = 0x003F;      // Interrupt after every 16th sample/convert 
....................    AD1CON1 = 0x80E4;      // Turn on the A/D module, auto-convert 
....................    T1CON = 0x8000;         // TON = 1, no prescalar 
....................    PR1 = 0xFFFF;         // Don't clear timer early 
....................    vBitCount = 0; 
....................    dwTotalTime = 0; 
....................    wLastValue = 0; 
....................    randomResult.dw = LFSRRand(); 
....................    while(1) 
....................    { 
....................       ClrWdt(); 
....................       #if defined(__C30__) 
....................          while(!IFS0bits.AD1IF); 
....................       #else 
....................          while(!IFS1bits.AD1IF); 
....................       #endif 
....................       wTime = TMR1; 
....................       TMR1 = 0x0000; 
....................  
....................       #if defined(__C30__) 
....................          IFS0bits.AD1IF = 0; 
....................       #else 
....................          IFS1CLR = _IFS1_AD1IF_MASK; 
....................       #endif 
....................       w = LFSRRand(); 
....................     
....................       // Wait no longer than 1 second obtaining entropy 
....................       dwTotalTime += wTime; 
....................       if(dwTotalTime >= GetInstructionClock()) 
....................       { 
....................          randomResult.w[0] ^= LFSRRand(); 
....................          randomResult.w[1] ^= LFSRRand(); 
....................          break; 
....................       } 
....................     
....................       // Keep sampling if minimal entropy was likely obtained this round 
....................       if(wLastValue == wTime) 
....................          continue; 
....................     
....................       // Add this entropy into the pseudo random number generator by reseeding 
....................       LFSRSeedRand(w + (wLastValue - wTime)); 
....................       wLastValue = wTime; 
....................     
....................       // Accumulate at least 32 bits of randomness over time 
....................       randomResult.dw <<= 1; 
....................       if(LFSRRand() & 0x0080) 
....................          randomResult.w[0] |= 0x1; 
....................     
....................       // See if we've collected a fair amount of entropy and can quit early 
....................       if(++vBitCount == 0u) 
....................          break; 
....................    } 
....................  
....................  
....................    // Restore hardware SFRs 
....................    AD1CON1 = 0x0000;      // Turn off the ADC so we can write to it 
....................    AD1CON3 = AD1CON3Save; 
....................    AD1CON2 = AD1CON2Save; 
....................    AD1CON1 = AD1CON1Save; 
....................    T1CON = T1CONSave; 
....................    PR1 = PR1Save; 
.................... } 
.................... #endif 
....................  
....................    return randomResult.dw; 
008A4:  MOVFF  182,00
008A8:  MOVFF  183,01
008AC:  MOVFF  184,02
008B0:  MOVFF  185,03
008B4:  MOVLB  0
008B6:  RETURN 0
.................... } 
....................  
....................  
.................... #if defined(STACK_USE_HTTP_SERVER) 
.................... /***************************************************************************** 
....................   Function: 
....................    void UnencodeURL(BYTE* URL) 
....................  
....................   Summary: 
....................    Decodes a URL-encoded string. 
....................  
....................   Description: 
....................    This function is deprecated except for use with HTTP Classic.  It 
....................    attempts to decode a URL encoded string, converting all hex escape 
....................    sequences into a literal byte.  However, it is inefficient over long 
....................    strings and does not handle URL-encoded data strings ('&' and '='). 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    URL - the null-terminated string to decode 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... void UnencodeURL(BYTE* URL) 
.................... { 
....................    BYTE *Right, *Copy; 
....................    WORD_VAL Number; 
....................  
....................    while((Right = (BYTE*)strchr((char*)URL, '%'))) 
....................    { 
....................       // Make sure the string is long enough 
....................       if(Right[1] == '\0') 
....................          break; 
....................       if(Right[2] == '\0') 
....................          break; 
....................  
....................       // Update the string in place 
....................       Number.v[0] = Right[2]; 
....................       Number.v[1] = Right[1]; 
....................       *Right++ = hexatob(Number); 
....................       URL = Right; 
....................  
....................       // Remove two blank spots by shifting all remaining characters right two 
....................       Copy = Right + 2; 
....................       while((*Right++ = *Copy++)); 
....................    } 
.................... }           
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL StringToIPAddress(BYTE* str, IP_ADDR* IPAddress) 
....................  
....................   Summary: 
....................    Converts a string to an IP address 
....................  
....................   Description: 
....................    This function parses a dotted-quad decimal IP address string into an  
....................    IP_ADDR struct.  The output result is big-endian. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    str - Pointer to a dotted-quad IP address string 
....................    IPAddress - Pointer to IP_ADDR in which to store the result 
....................  
....................   Return Values: 
....................      TRUE - an IP address was successfully decoded 
....................      FALSE - no IP address could be found, or the format was incorrect 
....................   ***************************************************************************/ 
.................... BOOL StringToIPAddress(BYTE* str, IP_ADDR* IPAddress) 
.................... { 
....................    DWORD_VAL dwVal; 
....................    BYTE i, charLen, currentOctet; 
....................  
....................    charLen = 0; 
....................    currentOctet = 0; 
....................    dwVal.Val = 0; 
....................    while((i = *str++)) 
....................    { 
....................       if(currentOctet > 3u) 
....................          break; 
....................  
....................       i -= '0'; 
....................        
....................  
....................       // Validate the character is a numerical digit or dot, depending on location 
....................       if(charLen == 0u) 
....................       { 
....................          if(i > 9u) 
....................             return FALSE; 
....................       } 
....................       else if(charLen == 3u) 
....................       { 
....................          if(i != (BYTE)('.' - '0')) 
....................             return FALSE; 
....................  
....................          if(dwVal.Val > 0x00020505ul) 
....................             return FALSE; 
....................  
....................          IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................          charLen = 0; 
....................          dwVal.Val = 0; 
....................          continue; 
....................       } 
....................       else 
....................       { 
....................          if(i == (BYTE)('.' - '0')) 
....................          { 
....................             if(dwVal.Val > 0x00020505ul) 
....................                return FALSE; 
....................  
....................             IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................             charLen = 0; 
....................             dwVal.Val = 0; 
....................             continue; 
....................          } 
....................          if(i > 9u) 
....................             return FALSE; 
....................       } 
....................  
....................       charLen++; 
....................       dwVal.Val <<= 8; 
....................       dwVal.v[0] = i; 
....................    } 
....................  
....................    // Make sure the very last character is a valid termination character  
....................    // (i.e., not more hostname, which could be legal and not an IP  
....................    // address as in "10.5.13.233.picsaregood.com" 
....................    if(i != 0u && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t' && i != ':') 
....................       return FALSE; 
....................  
....................    // Verify and convert the last octet and return the result 
....................    if(dwVal.Val > 0x00020505ul) 
....................       return FALSE; 
....................  
....................    IPAddress->v[3] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................  
....................    return TRUE; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL ROMStringToIPAddress(ROM BYTE* str, IP_ADDR* IPAddress) 
....................  
....................   Summary: 
....................    Converts a string to an IP address 
....................  
....................   Description: 
....................    This function parses a dotted-quad decimal IP address string into an  
....................    IP_ADDR struct.  The output result is big-endian. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    str - Pointer to a dotted-quad IP address string 
....................    IPAddress - Pointer to IP_ADDR in which to store the result 
....................  
....................   Return Values: 
....................      TRUE - an IP address was successfully decoded 
....................      FALSE - no IP address could be found, or the format was incorrect 
....................    
....................   Remarks: 
....................    This function is aliased to StringToIPAddress on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... BOOL ROMStringToIPAddress(ROM BYTE* str, IP_ADDR* IPAddress) 
.................... { 
....................    DWORD_VAL dwVal; 
....................    BYTE i, charLen, currentOctet; 
....................  
....................    charLen = 0; 
....................    currentOctet = 0; 
....................    dwVal.Val = 0; 
....................    while(i = *str++) 
....................    { 
....................       if(currentOctet > 3u) 
....................          break; 
....................  
....................       i -= '0'; 
....................        
....................  
....................       // Validate the character is a numerical digit or dot, depending on location 
....................       if(charLen == 0u) 
....................       { 
....................          if(i > 9u) 
....................             return FALSE; 
....................       } 
....................       else if(charLen == 3u) 
....................       { 
....................          if(i != (BYTE)('.' - '0')) 
....................             return FALSE; 
....................  
....................          if(dwVal.Val > 0x00020505ul) 
....................             return FALSE; 
....................  
....................          IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................          charLen = 0; 
....................          dwVal.Val = 0; 
....................          continue; 
....................       } 
....................       else 
....................       { 
....................          if(i == (BYTE)('.' - '0')) 
....................          { 
....................             if(dwVal.Val > 0x00020505ul) 
....................                return FALSE; 
....................  
....................             IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................             charLen = 0; 
....................             dwVal.Val = 0; 
....................             continue; 
....................          } 
....................          if(i > 9u) 
....................             return FALSE; 
....................       } 
....................  
....................       charLen++; 
....................       dwVal.Val <<= 8; 
....................       dwVal.v[0] = i; 
....................    } 
....................  
....................    // Make sure the very last character is a valid termination character  
....................    // (i.e., not more hostname, which could be legal and not an IP  
....................    // address as in "10.5.13.233.picsaregood.com" 
....................    if(i != 0u && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t') 
....................       return FALSE; 
....................  
....................    // Verify and convert the last octet and return the result 
....................    if(dwVal.Val > 0x00020505ul) 
....................       return FALSE; 
....................  
....................    IPAddress->v[3] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................  
....................    return TRUE; 
.................... } 
.................... #endif 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD Base64Decode(BYTE* cSourceData, WORD wSourceLen,  
....................                   BYTE* cDestData, WORD wDestLen) 
....................  
....................   Description: 
....................    Decodes a Base-64 array to its literal representation. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    cSourceData - Pointer to a string of Base-64 encoded data 
....................    wSourceLen   - Length of the Base-64 source data 
....................    cDestData   - Pointer to write the decoded data 
....................    wSourceLen   - Maximum length that can be written to cDestData 
....................  
....................   Returns: 
....................      Number of decoded bytes written to cDestData. 
....................    
....................   Remarks: 
....................    This function is binary safe and will ignore invalid characters (CR, LF,  
....................    etc).  If cSourceData is equal to cDestData, the data will be converted 
....................    in-place.  If cSourceData is not equal to cDestData, but the regions  
....................    overlap, the behavior is undefined. 
....................     
....................    Decoded data is always at least 1/4 smaller than the source data. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_BASE64_DECODE) 
.................... WORD Base64Decode(BYTE* cSourceData, WORD wSourceLen, BYTE* cDestData, WORD wDestLen) 
.................... { 
....................    BYTE i; 
....................    BYTE vByteNumber; 
....................    WORD wBytesOutput; 
....................  
....................    vByteNumber = 0; 
....................    wBytesOutput = 0; 
....................  
....................    // Loop over all provided bytes 
....................    while(wSourceLen--) 
....................    { 
....................       // Fetch a Base64 byte and decode it to the original 6 bits 
....................       i = *cSourceData++; 
....................       if(i >= 'A' && i <= 'Z')   // Regular data 
....................          i -= 'A' - 0; 
....................       else if(i >= 'a' && i <= 'z') 
....................          i -= 'a' - 26; 
....................       else if(i >= '0' && i <= '9') 
....................          i -= '0' - 52; 
....................       else if(i == '+' || i == '-') 
....................          i = 62; 
....................       else if(i == '/' || i == '_') 
....................          i = 63; 
....................       else                   // Skip all padding (=) and non-Base64 characters 
....................          continue; 
....................  
....................  
....................       // Write the 6 bits to the correct destination location(s) 
....................       if(vByteNumber == 0u) 
....................       { 
....................          vByteNumber++; 
....................          if(wBytesOutput >= wDestLen) 
....................             break; 
....................          wBytesOutput++; 
....................          *cDestData = i << 2; 
....................       } 
....................       else if(vByteNumber == 1u) 
....................       { 
....................          vByteNumber++; 
....................          *cDestData++ |= i >> 4; 
....................          if(wBytesOutput >= wDestLen) 
....................             break; 
....................          wBytesOutput++; 
....................          *cDestData = i << 4; 
....................       } 
....................       else if(vByteNumber == 2u) 
....................       { 
....................          vByteNumber++; 
....................          *cDestData++ |= i >> 2; 
....................          if(wBytesOutput >= wDestLen) 
....................             break; 
....................          wBytesOutput++; 
....................          *cDestData = i << 6; 
....................       } 
....................       else 
....................       { 
....................          vByteNumber = 0; 
....................          *cDestData++ |= i; 
....................       } 
....................    } 
....................  
....................    return wBytesOutput; 
.................... } 
.................... #endif   // #if defined(STACK_USE_BASE64_DECODE) 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD Base64Encode(BYTE* cSourceData, WORD wSourceLen, 
....................                   BYTE* cDestData, WORD wDestLen) 
....................  
....................   Description: 
....................    Encodes a binary array to Base-64. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    cSourceData - Pointer to a string of binary data 
....................    wSourceLen   - Length of the binary source data 
....................    cDestData   - Pointer to write the Base-64 encoded data 
....................    wSourceLen   - Maximum length that can be written to cDestData 
....................  
....................   Returns: 
....................      Number of encoded bytes written to cDestData.  This will always be 
....................      a multiple of 4. 
....................    
....................   Remarks: 
....................    Encoding cannot be performed in-place.  If cSourceData overlaps with  
....................    cDestData, the behavior is undefined. 
....................     
....................    Encoded data is always at least 1/3 larger than the source data.  It may 
....................    be 1 or 2 bytes larger than that. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_BASE64_ENCODE) || defined(STACK_USE_SMTP_CLIENT) || defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... WORD Base64Encode(BYTE* cSourceData, WORD wSourceLen, BYTE* cDestData, WORD wDestLen) 
.................... { 
....................    BYTE i, j; 
....................    BYTE vOutput[4]; 
....................    WORD wOutputLen; 
....................  
....................    wOutputLen = 0; 
....................    while(wDestLen >= 4u) 
....................    { 
....................       // Start out treating the output as all padding 
....................       vOutput[0] = 0xFF; 
....................       vOutput[1] = 0xFF; 
....................       vOutput[2] = 0xFF; 
....................       vOutput[3] = 0xFF; 
....................  
....................       // Get 3 input octets and split them into 4 output hextets (6-bits each)  
....................       if(wSourceLen == 0u) 
....................          break; 
....................       i = *cSourceData++; 
....................       wSourceLen--; 
....................       vOutput[0] = (i & 0xFC)>>2; 
....................       vOutput[1] = (i & 0x03)<<4; 
....................       if(wSourceLen) 
....................       { 
....................          i = *cSourceData++; 
....................          wSourceLen--; 
....................          vOutput[1] |= (i & 0xF0)>>4; 
....................          vOutput[2] = (i & 0x0F)<<2; 
....................          if(wSourceLen) 
....................          { 
....................             i = *cSourceData++; 
....................             wSourceLen--; 
....................             vOutput[2] |= (i & 0xC0)>>6; 
....................             vOutput[3] = i & 0x3F; 
....................          } 
....................       } 
....................     
....................       // Convert hextets into Base 64 alphabet and store result 
....................       for(i = 0; i < 4u; i++) 
....................       { 
....................          j = vOutput[i]; 
....................  
....................          if(j <= 25u) 
....................             j += 'A' - 0; 
....................          else if(j <= 51u) 
....................             j += 'a' - 26; 
....................          else if(j <= 61u) 
....................             j += '0' - 52; 
....................          else if(j == 62u) 
....................             j = '+'; 
....................          else if(j == 63u) 
....................             j = '/'; 
....................          else            // Padding 
....................             j = '='; 
....................  
....................          *cDestData++ = j; 
....................       } 
....................  
....................       // Update counters 
....................       wDestLen -= 4; 
....................       wOutputLen += 4; 
....................    } 
....................  
....................    return wOutputLen; 
.................... } 
.................... #endif // #if defined(STACK_USE_BASE64_ENCODE) || defined(STACK_USE_SMTP) || defined(STACK_USE_DYNAMICDNS_CLIENT) 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void uitoa(WORD Value, BYTE* Buffer) 
....................  
....................   Summary: 
....................    Converts an unsigned integer to a decimal string. 
....................     
....................   Description: 
....................    Converts a 16-bit unsigned integer to a null-terminated decimal string. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    Value   - The number to be converted 
....................    Buffer   - Pointer in which to store the converted string 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... void uitoa(WORD Value, BYTE* Buffer) 
.................... { 
....................    BYTE i; 
....................    WORD Digit; 
....................    WORD Divisor; 
....................    BOOL Printed = FALSE; 
....................  
....................    if(Value) 
....................    { 
....................       for(i = 0, Divisor = 10000; i < 5u; i++) 
....................       { 
....................          Digit = Value/Divisor; 
....................          if(Digit || Printed) 
....................          { 
....................             *Buffer++ = '0' + Digit; 
....................             Value -= Digit*Divisor; 
....................             Printed = TRUE; 
....................          } 
....................          Divisor /= 10; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       *Buffer++ = '0'; 
....................    } 
....................  
....................    *Buffer = '\0'; 
.................... }              
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ultoa(DWORD Value, BYTE* Buffer) 
....................  
....................   Summary: 
....................    Converts an unsigned integer to a decimal string. 
....................     
....................   Description: 
....................    Converts a 32-bit unsigned integer to a null-terminated decimal string. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    Value   - The number to be converted 
....................    Buffer   - Pointer in which to store the converted string 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... // HI-TECH PICC-18 PRO 9.63, C30 v3.25, and C32 v1.12 already have a ultoa() library function 
.................... // C18 already has a ultoa() function that more-or-less matches this one 
.................... // C32 < 1.12 and C30 < v3.25 need this function 
.................... #if (defined(__PIC32MX__) && (__C32_VERSION__ < 112)) || (defined (__C30__) && (__C30_VERSION__ < 325)) || defined(__C30_LEGACY_LIBC__) || defined(__C32_LEGACY_LIBC__) 
.................... void ultoa(DWORD Value, BYTE* Buffer) 
.................... { 
....................    BYTE i; 
....................    DWORD Digit; 
....................    DWORD Divisor; 
....................    BOOL Printed = FALSE; 
....................  
....................    if(Value) 
....................    { 
....................       for(i = 0, Divisor = 1000000000; i < 10; i++) 
....................       { 
....................          Digit = Value/Divisor; 
....................          if(Digit || Printed) 
....................          { 
....................             *Buffer++ = '0' + Digit; 
....................             Value -= Digit*Divisor; 
....................             Printed = TRUE; 
....................          } 
....................          Divisor /= 10; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       *Buffer++ = '0'; 
....................    } 
....................  
....................    *Buffer = '\0'; 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE hexatob(WORD_VAL AsciiChars) 
....................  
....................   Summary: 
....................    Converts a hex string to a single byte. 
....................     
....................   Description: 
....................    Converts a two-character ASCII hex string to a single packed byte. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    AsciiChars - WORD_VAL where .v[0] is the ASCII value for the lower nibble 
....................                and .v[1] is the ASCII value for the upper nibble.  Each 
....................                must range from '0'-'9', 'A'-'F', or 'a'-'f'. 
....................  
....................   Returns: 
....................      Resulting packed byte 0x00 - 0xFF. 
....................   ***************************************************************************/ 
.................... BYTE hexatob(WORD_VAL AsciiChars) 
.................... { 
....................    // Convert lowercase to uppercase 
....................    if(AsciiChars.v[1] > 'F') 
....................       AsciiChars.v[1] -= 'a'-'A'; 
....................    if(AsciiChars.v[0] > 'F') 
....................       AsciiChars.v[0] -= 'a'-'A'; 
....................  
....................    // Convert 0-9, A-F to 0x0-0xF 
....................    if(AsciiChars.v[1] > '9') 
....................       AsciiChars.v[1] -= 'A' - 10; 
....................    else 
....................       AsciiChars.v[1] -= '0'; 
....................  
....................    if(AsciiChars.v[0] > '9') 
....................       AsciiChars.v[0] -= 'A' - 10; 
....................    else 
....................       AsciiChars.v[0] -= '0'; 
....................  
....................    // Concatenate 
....................    return (AsciiChars.v[1]<<4) |  AsciiChars.v[0]; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE btohexa_high(BYTE b) 
....................  
....................   Summary: 
....................    Converts the upper nibble of a binary value to a hexadecimal ASCII byte. 
....................  
....................   Description: 
....................    Converts the upper nibble of a binary value to a hexadecimal ASCII byte. 
....................    For example, btohexa_high(0xAE) will return 'A'. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    b - the byte to convert 
....................  
....................   Returns: 
....................      The upper hexadecimal ASCII byte '0'-'9' or 'A'-'F'. 
....................   ***************************************************************************/ 
.................... BYTE btohexa_high(BYTE b) 
.................... { 
....................    b >>= 4; 
....................    return (b>0x9u) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE btohexa_high(BYTE b) 
....................  
....................   Summary: 
....................    Converts the lower nibble of a binary value to a hexadecimal ASCII byte. 
....................  
....................   Description: 
....................    Converts the lower nibble of a binary value to a hexadecimal ASCII byte. 
....................    For example, btohexa_high(0xAE) will return 'E'. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    b - the byte to convert 
....................  
....................   Returns: 
....................      The lower hexadecimal ASCII byte '0'-'9' or 'A'-'F'. 
....................   ***************************************************************************/ 
.................... BYTE btohexa_low(BYTE b) 
.................... { 
....................    b &= 0x0F; 
....................    return (b>9u) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    signed char stricmppgm2ram(BYTE* a, ROM BYTE* b) 
....................  
....................   Summary: 
....................    Case-insensitive comparison of a string in RAM to a string in ROM. 
....................  
....................   Description: 
....................    Performs a case-insensitive comparison of a string in RAM to a string 
....................    in ROM.  This function performs identically to strcmppgm2ram, except that 
....................    the comparison is not case-sensitive. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    a - Pinter to tring in RAM 
....................    b - Pointer to string in ROM 
....................  
....................   Return Values: 
....................      \-1 - a < b 
....................      0   - a = b 
....................      1   - a > b 
....................   ***************************************************************************/ 
.................... signed char stricmppgm2ram(BYTE* a, ROM BYTE* b) 
.................... { 
....................    BYTE cA, cB; 
....................     
....................    // Load first two characters 
....................    cA = *a; 
....................    cB = *b; 
....................     
....................    // Loop until one string terminates 
....................    while(cA != '\0' && cB != '\0') 
....................    { 
....................       // Shift case if necessary 
....................       if(cA >= 'a' && cA <= 'z') 
....................          cA -= 'a' - 'A'; 
....................       if(cB >= 'a' && cB <= 'z') 
....................          cB -= 'a' - 'A'; 
....................           
....................       // Compare 
....................       if(cA > cB) 
....................          return 1; 
....................       if(cA < cB) 
....................          return -1; 
....................        
....................       // Characters matched, so continue 
....................       a++; 
....................       b++; 
....................       cA = *a; 
....................       cB = *b; 
....................    } 
....................     
....................    // See if one string terminated first 
....................    if(cA > cB) 
....................       return 1; 
....................    if(cA < cB) 
....................       return -1; 
....................        
....................    // Strings match 
....................    return 0; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD swaps(WORD v) 
....................  
....................   Description: 
....................    Swaps the endian-ness of a WORD. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    v - the WORD to swap 
....................  
....................   Returns: 
....................    The swapped version of v. 
....................   ***************************************************************************/ 
.................... WORD swaps(WORD v) 
.................... { 
....................    WORD_VAL t; 
....................    BYTE b; 
....................  
....................    t.Val   = v; 
*
01C00:  MOVFF  2BC,2BE
01C04:  MOVFF  2BB,2BD
....................    b       = t.v[1]; 
01C08:  MOVFF  2BE,2BF
....................    t.v[1]  = t.v[0]; 
01C0C:  MOVFF  2BD,2BE
....................    t.v[0]  = b; 
01C10:  MOVFF  2BF,2BD
....................  
....................    return t.Val; 
01C14:  MOVLB  2
01C16:  MOVFF  2BD,01
01C1A:  MOVFF  2BE,02
01C1E:  MOVLB  0
01C20:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    DWORD swapl(DWORD v) 
....................  
....................   Description: 
....................    Swaps the endian-ness of a DWORD. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    v - the DWORD to swap 
....................  
....................   Returns: 
....................    The swapped version of v. 
....................   ***************************************************************************/ 
.................... #if defined(__C32__) 
.................... DWORD   __attribute__((nomips16)) swapl(DWORD v) 
.................... #else 
.................... DWORD swapl(DWORD v) 
.................... #endif 
.................... { 
....................    // Swap bytes 0 and 3 
....................    ((DWORD_VAL*)&v)->v[0] ^= ((DWORD_VAL*)&v)->v[3]; 
01C22:  MOVLW  02
01C24:  MOVLB  2
01C26:  MOVWF  xA9
01C28:  MOVLW  A4
01C2A:  MOVWF  01
01C2C:  MOVFF  2A9,FEA
01C30:  MOVWF  FE9
01C32:  MOVFF  FEF,2AC
01C36:  MOVLW  02
01C38:  MOVWF  xAE
01C3A:  MOVLW  A4
01C3C:  MOVWF  xAD
01C3E:  MOVLW  03
01C40:  ADDWF  xAD,W
01C42:  MOVWF  FE9
01C44:  MOVLW  00
01C46:  ADDWFC xAE,W
01C48:  MOVWF  FEA
01C4A:  MOVF   FEF,W
01C4C:  XORWF  xAC,W
01C4E:  MOVFF  2A9,FEA
01C52:  MOVFF  01,FE9
01C56:  MOVWF  FEF
....................    ((DWORD_VAL*)&v)->v[3] ^= ((DWORD_VAL*)&v)->v[0]; 
01C58:  MOVLW  02
01C5A:  MOVWF  xA9
01C5C:  MOVLW  A4
01C5E:  MOVWF  xA8
01C60:  MOVLW  03
01C62:  ADDWF  xA8,W
01C64:  MOVWF  01
01C66:  MOVLW  00
01C68:  ADDWFC xA9,W
01C6A:  MOVWF  03
01C6C:  MOVWF  FEA
01C6E:  MOVFF  01,FE9
01C72:  MOVFF  FEF,2AC
01C76:  MOVLW  02
01C78:  MOVWF  xAE
01C7A:  MOVLW  A4
01C7C:  MOVWF  FE9
01C7E:  MOVFF  2AE,FEA
01C82:  MOVF   FEF,W
01C84:  XORWF  xAC,W
01C86:  MOVFF  03,FEA
01C8A:  MOVFF  01,FE9
01C8E:  MOVWF  FEF
....................    ((DWORD_VAL*)&v)->v[0] ^= ((DWORD_VAL*)&v)->v[3]; 
01C90:  MOVLW  02
01C92:  MOVWF  xA9
01C94:  MOVLW  A4
01C96:  MOVWF  01
01C98:  MOVFF  2A9,FEA
01C9C:  MOVWF  FE9
01C9E:  MOVFF  FEF,2AC
01CA2:  MOVLW  02
01CA4:  MOVWF  xAE
01CA6:  MOVLW  A4
01CA8:  MOVWF  xAD
01CAA:  MOVLW  03
01CAC:  ADDWF  xAD,W
01CAE:  MOVWF  FE9
01CB0:  MOVLW  00
01CB2:  ADDWFC xAE,W
01CB4:  MOVWF  FEA
01CB6:  MOVF   FEF,W
01CB8:  XORWF  xAC,W
01CBA:  MOVFF  2A9,FEA
01CBE:  MOVFF  01,FE9
01CC2:  MOVWF  FEF
....................  
....................    // Swap bytes 1 and 2 
....................    ((DWORD_VAL*)&v)->v[1] ^= ((DWORD_VAL*)&v)->v[2]; 
01CC4:  MOVLW  02
01CC6:  MOVWF  xA9
01CC8:  MOVLW  A4
01CCA:  MOVWF  xA8
01CCC:  MOVLW  01
01CCE:  ADDWF  xA8,W
01CD0:  MOVWF  01
01CD2:  MOVLW  00
01CD4:  ADDWFC xA9,W
01CD6:  MOVWF  03
01CD8:  MOVWF  FEA
01CDA:  MOVFF  01,FE9
01CDE:  MOVFF  FEF,2AC
01CE2:  MOVLW  02
01CE4:  MOVWF  xAE
01CE6:  MOVLW  A4
01CE8:  MOVWF  xAD
01CEA:  MOVLW  02
01CEC:  ADDWF  xAD,W
01CEE:  MOVWF  FE9
01CF0:  MOVLW  00
01CF2:  ADDWFC xAE,W
01CF4:  MOVWF  FEA
01CF6:  MOVF   FEF,W
01CF8:  XORWF  xAC,W
01CFA:  MOVFF  03,FEA
01CFE:  MOVFF  01,FE9
01D02:  MOVWF  FEF
....................    ((DWORD_VAL*)&v)->v[2] ^= ((DWORD_VAL*)&v)->v[1]; 
01D04:  MOVLW  02
01D06:  MOVWF  xA9
01D08:  MOVLW  A4
01D0A:  MOVWF  xA8
01D0C:  MOVLW  02
01D0E:  ADDWF  xA8,W
01D10:  MOVWF  01
01D12:  MOVLW  00
01D14:  ADDWFC xA9,W
01D16:  MOVWF  03
01D18:  MOVWF  FEA
01D1A:  MOVFF  01,FE9
01D1E:  MOVFF  FEF,2AC
01D22:  MOVLW  02
01D24:  MOVWF  xAE
01D26:  MOVLW  A4
01D28:  MOVWF  xAD
01D2A:  MOVLW  01
01D2C:  ADDWF  xAD,W
01D2E:  MOVWF  FE9
01D30:  MOVLW  00
01D32:  ADDWFC xAE,W
01D34:  MOVWF  FEA
01D36:  MOVF   FEF,W
01D38:  XORWF  xAC,W
01D3A:  MOVFF  03,FEA
01D3E:  MOVFF  01,FE9
01D42:  MOVWF  FEF
....................    ((DWORD_VAL*)&v)->v[1] ^= ((DWORD_VAL*)&v)->v[2]; 
01D44:  MOVLW  02
01D46:  MOVWF  xA9
01D48:  MOVLW  A4
01D4A:  MOVWF  xA8
01D4C:  MOVLW  01
01D4E:  ADDWF  xA8,W
01D50:  MOVWF  01
01D52:  MOVLW  00
01D54:  ADDWFC xA9,W
01D56:  MOVWF  03
01D58:  MOVWF  FEA
01D5A:  MOVFF  01,FE9
01D5E:  MOVFF  FEF,2AC
01D62:  MOVLW  02
01D64:  MOVWF  xAE
01D66:  MOVLW  A4
01D68:  MOVWF  xAD
01D6A:  MOVLW  02
01D6C:  ADDWF  xAD,W
01D6E:  MOVWF  FE9
01D70:  MOVLW  00
01D72:  ADDWFC xAE,W
01D74:  MOVWF  FEA
01D76:  MOVF   FEF,W
01D78:  XORWF  xAC,W
01D7A:  MOVFF  03,FEA
01D7E:  MOVFF  01,FE9
01D82:  MOVWF  FEF
....................  
....................    return v; 
01D84:  MOVFF  2A4,00
01D88:  MOVFF  2A5,01
01D8C:  MOVFF  2A6,02
01D90:  MOVFF  2A7,03
01D94:  MOVLB  0
01D96:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD CalcIPChecksum(BYTE* buffer, WORD count) 
....................  
....................   Summary: 
....................    Calculates an IP checksum value. 
....................  
....................   Description: 
....................    This function calculates an IP checksum over an array of input data.  The 
....................    checksum is the 16-bit one's complement of one's complement sum of all  
....................    words in the data (with zero-padding if an odd number of bytes are  
....................    summed).  This checksum is defined in RFC 793. 
....................  
....................   Precondition: 
....................    buffer is WORD aligned (even memory address) on 16- and 32-bit PICs. 
....................  
....................   Parameters: 
....................    buffer - pointer to the data to be checksummed 
....................    count  - number of bytes to be checksummed 
....................  
....................   Returns: 
....................    The calculated checksum. 
....................     
....................   Internal: 
....................    This function could be improved to do 32-bit sums on PIC32 platforms. 
....................   ***************************************************************************/ 
.................... WORD CalcIPChecksum(BYTE* buffer, WORD count) 
.................... { 
....................    WORD i; 
....................    WORD *val; 
....................    union 
....................    { 
....................       WORD w[2]; 
....................       DWORD dw; 
....................    } sum; 
....................  
....................    i = count >> 1; 
*
01FB4:  BCF    FD8.0
01FB6:  MOVLB  2
01FB8:  RRCF   xBA,W
01FBA:  MOVWF  xBC
01FBC:  RRCF   xB9,W
01FBE:  MOVWF  xBB
....................    val = (WORD*)buffer; 
01FC0:  MOVFF  2B8,2BE
01FC4:  MOVFF  2B7,2BD
....................  
....................    // Calculate the sum of all words 
....................    sum.dw = 0x00000000ul; 
01FC8:  CLRF   xC2
01FCA:  CLRF   xC1
01FCC:  CLRF   xC0
01FCE:  CLRF   xBF
....................    while(i--) 
01FD0:  MOVFF  2BC,03
01FD4:  MOVF   xBB,W
01FD6:  BTFSC  FD8.2
01FD8:  DECF   xBC,F
01FDA:  DECF   xBB,F
01FDC:  IORWF  03,W
01FDE:  BZ    201C
....................       sum.dw += (DWORD)*val++; 
01FE0:  MOVFF  2BE,03
01FE4:  MOVFF  2BD,00
01FE8:  MOVLW  02
01FEA:  ADDWF  xBD,F
01FEC:  BTFSC  FD8.0
01FEE:  INCF   xBE,F
01FF0:  MOVFF  00,FE9
01FF4:  MOVFF  03,FEA
01FF8:  MOVFF  FEC,03
01FFC:  MOVF   FED,F
01FFE:  MOVFF  FEF,00
02002:  MOVFF  03,01
02006:  CLRF   02
02008:  CLRF   03
0200A:  MOVF   00,W
0200C:  ADDWF  xBF,F
0200E:  MOVF   01,W
02010:  ADDWFC xC0,F
02012:  MOVF   02,W
02014:  ADDWFC xC1,F
02016:  MOVF   03,W
02018:  ADDWFC xC2,F
0201A:  BRA    1FD0
....................  
....................    // Add in the sum of the remaining byte, if present 
....................    if(count & 0x1) 
0201C:  MOVF   xB9,W
0201E:  ANDLW  01
02020:  MOVWF  00
02022:  CLRF   03
02024:  MOVF   00,W
02026:  IORWF  03,W
02028:  BZ    2050
....................       sum.dw += (DWORD)*(BYTE*)val; 
0202A:  MOVFF  2BE,03
0202E:  MOVFF  2BD,FE9
02032:  MOVFF  2BE,FEA
02036:  MOVFF  FEF,00
0203A:  CLRF   01
0203C:  CLRF   02
0203E:  CLRF   03
02040:  MOVF   00,W
02042:  ADDWF  xBF,F
02044:  MOVF   01,W
02046:  ADDWFC xC0,F
02048:  MOVF   02,W
0204A:  ADDWFC xC1,F
0204C:  MOVF   03,W
0204E:  ADDWFC xC2,F
....................  
....................    // Do an end-around carry (one's complement arrithmatic) 
....................    sum.dw = (DWORD)sum.w[0] + (DWORD)sum.w[1]; 
02050:  CLRF   xC6
02052:  CLRF   xC5
02054:  MOVFF  2C0,2C4
02058:  MOVFF  2BF,2C3
0205C:  MOVFF  2C1,00
02060:  MOVFF  2C2,01
02064:  CLRF   02
02066:  CLRF   03
02068:  MOVF   xC1,W
0206A:  ADDWF  xBF,W
0206C:  MOVWF  xBF
0206E:  MOVF   xC2,W
02070:  ADDWFC xC0,W
02072:  MOVWF  xC0
02074:  MOVF   02,W
02076:  ADDWFC xC5,W
02078:  MOVWF  xC1
0207A:  MOVF   03,W
0207C:  ADDWFC xC6,W
0207E:  MOVWF  xC2
....................  
....................    // Do another end-around carry in case if the prior add  
....................    // caused a carry out 
....................    sum.w[0] += sum.w[1]; 
02080:  MOVF   xC1,W
02082:  ADDWF  xBF,F
02084:  MOVF   xC2,W
02086:  ADDWFC xC0,F
....................  
....................    // Return the resulting checksum 
....................    return ~sum.w[0]; 
02088:  MOVFF  2C0,03
0208C:  COMF   03,F
0208E:  MOVF   xBF,W
02090:  XORLW  FF
02092:  MOVWF  01
02094:  MOVFF  03,02
02098:  MOVLB  0
0209A:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    char* strupr(char* s) 
....................  
....................   Summary: 
....................    Converts a string to uppercase. 
....................  
....................   Description: 
....................    This function converts strings to uppercase on platforms that do not 
....................    already have this function defined.  All lower-case characters are 
....................    converted, an characters not included in 'a'-'z' are left as-is. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    s - the null-terminated string to be converted. 
....................  
....................   Returns: 
....................    Pointer to the initial string. 
....................   ***************************************************************************/ 
.................... #if (!defined(__PCD__) && !defined(__18CXX)) || defined(HI_TECH_C) 
.................... char* strupr(char* s) 
.................... { 
....................    char c; 
....................    char *t; 
....................  
....................    t = s; 
....................    while( (c = *t) ) 
....................    { 
....................       if(c >= 'a' && c <= 'z') 
....................       { 
....................          *t -= ('a' - 'A'); 
....................       } 
....................       t++; 
....................    } 
....................    return s; 
.................... } 
.................... #endif 
....................  
.................... #if defined(__18CXX) //&& !defined(__PCH__) 
.................... // Make this variable global for the following function. 
.................... // Hi-Tech PICC18 cannot access local function variables from inline asm. 
.................... DWORD_VAL toRotate;  
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    DWORD leftRotateDWORD(DWORD val, BYTE bits) 
....................  
....................   Summary: 
....................    Left-rotates a DWORD. 
....................  
....................   Description: 
....................    This function rotates the bits in a 32-bit DWORD left by a specific  
....................    number of bits. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    val      - the DWORD to be rotated 
....................    bits   - the number of bits by which to shift 
....................  
....................   Returns: 
....................    Rotated DWORD value. 
....................     
....................   Remarks: 
....................    This function is only implemented on 8-bit platforms for now.  The  
....................    8-bit compilers generate excessive code for this function, while C30 
....................    and C32 already generate compact code.  Those compilers are served 
....................    by a macro defined in Helpers.h. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... DWORD leftRotateDWORD(DWORD val, BYTE bits) 
.................... { 
....................    BYTE i, t; 
....................    //DWORD_VAL toRotate; 
....................    toRotate.Val = val; 
....................     
....................    for(i = bits; i >= 8u; i -= 8) 
....................    { 
....................       t = toRotate.v[3]; 
....................       toRotate.v[3] = toRotate.v[2]; 
....................       toRotate.v[2] = toRotate.v[1]; 
....................       toRotate.v[1] = toRotate.v[0]; 
....................       toRotate.v[0] = t; 
....................    } 
....................     
....................     
....................    #if defined(HI_TECH_C) 
....................    for(; i != 0; i--) 
....................    { 
....................       asm("movlb (_toRotate)>>8"); 
....................       //asm("bcf _STATUS,0,C"); 
....................       asm("bcf 0xFD8,0,C");      // HI-TECH PICC-18 PRO 9.63PL1 doesn't define _STATUS 
....................       asm("btfsc (_toRotate)&0ffh+3,7,B"); 
....................       //asm("bsf _STATUS,0,C"); 
....................       asm("bsf 0xFD8,0,C");      // HI-TECH PICC-18 PRO 9.63PL1 doesn't define _STATUS 
....................       asm("rlcf (_toRotate)&0ffh+0,F,B"); 
....................       asm("rlcf (_toRotate)&0ffh+1,F,B"); 
....................       asm("rlcf (_toRotate)&0ffh+2,F,B"); 
....................       asm("rlcf (_toRotate)&0ffh+3,F,B"); 
....................    } 
....................    #else 
....................    for(; i != 0u; i--) 
....................    { 
....................       _asm 
....................       movlb toRotate 
....................       bcf STATUS,0,0 
....................       btfsc toRotate+3,7,1 
....................       bsf STATUS,0,0 
....................       rlcf toRotate+0,1,1 
....................       rlcf toRotate+1,1,1 
....................       rlcf toRotate+2,1,1 
....................       rlcf toRotate+3,1,1 
....................       _endasm 
....................    } 
....................    #endif 
....................     
....................    return toRotate.Val; 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void FormatNetBIOSName(BYTE Name[]) 
....................  
....................   Summary: 
....................    Formats a string to a valid NetBIOS name. 
....................  
....................   Description: 
....................    This function formats a string to a valid NetBIOS name.  Names will be 
....................    exactly 16 characters, as defined by the NetBIOS spec.  The 16th  
....................    character will be a 0x00 byte, while the other 15 will be the  
....................    provided string, padded with spaces as necessary. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    Name - the string to format as a NetBIOS name.  This parameter must have 
....................      at least 16 bytes allocated. 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... void FormatNetBIOSName(BYTE Name[]) 
.................... { 
....................    BYTE i; 
....................  
....................    Name[15] = '\0'; 
....................    strupr((char*)Name); 
....................    i = 0; 
....................    while(i < 15u) 
....................    { 
....................       if(Name[i] == '\0') 
....................       { 
....................          while(i < 15u) 
....................          { 
....................             Name[i++] = ' '; 
....................          } 
....................          break; 
....................       } 
....................       i++; 
....................    } 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    char * strnchr(const char *searchString, size_t count, char c) 
....................  
....................   Summary: 
....................    Searches a string up to a specified number of characters for a specific  
....................    character. 
....................  
....................   Description: 
....................    Searches a string up to a specified number of characters for a specific  
....................    character.  The string is searched forward and the first occurance  
....................    location is returned.  If the search character is not present in the  
....................    string, or if the maximum character count is reached first, then a NULL  
....................    pointer is returned. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    searchString - Pointer to a null terminated string to search.  If count is  
....................       less than the string size, then the string need not be null terminated. 
....................    count - Maximum number of characters to search before aborting. 
....................    c - Character to search for 
....................     
....................   Returns: 
....................    Pointer to the first occurance of the character c in the string  
....................    searchString.  If the character is not found or the maximum count is  
....................    reached, a NULL pointer is returned. 
....................   ***************************************************************************/ 
.................... char * strnchr(const char *searchString, size_t count, char c) 
.................... { 
....................    char c2; 
....................     
....................    while(count--) 
....................    { 
....................       c2  = *searchString++; 
....................       if(c2 == 0u) 
....................          return NULL; 
....................       if(c2 == c) 
....................          return (char*)--searchString; 
....................    } 
....................    return NULL; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    char* strncpy_m(char* destStr, size_t destSize, int nStrings, ...) 
....................  
....................   Summary: 
....................    Copies multiple strings to a destination 
....................  
....................   Description: 
....................    Copies multiple strings to a destination 
....................     but doesn't copy more than destSize characters. 
....................     Useful where the destination is actually an array and an extra \0 
....................     won't be appended to overflow the buffer 
....................      
....................   Precondition: 
....................    - valid string pointers 
....................     - destSize should be > 0 
....................  
....................   Parameters: 
....................    destStr - Pointer to a string to be initialized with the multiple strings provided as arguments. 
....................  
....................     destSize    - the maximum size of the destStr field, that cannot be exceeded. 
....................                   An \0 won't be appended if the resulting size is > destSize 
....................  
....................     nStrings    - number of string parameters to be copied into destStr 
....................  
....................     ...         - variable number of arguments 
....................      
....................     
....................   Returns: 
....................    Length of the destination string, terminating \0 (if exists) not included 
....................   ***************************************************************************/ 
.................... size_t strncpy_m(char* destStr, size_t destSize, int nStrings, ...) 
.................... { 
....................     va_list     args; 
....................     const char* str; 
....................     char*       end; 
....................     size_t      len; 
....................  
....................     destStr[0] = '\0'; 
....................     end = destStr + destSize - 1; 
....................     *end = '\0'; 
....................     len = 0; 
....................      
....................     va_start( args, nStrings ); 
....................      
....................     while(nStrings--) 
....................     { 
....................         if(*end) 
....................         {   // if already full don't calculate strlen outside the string area 
....................             len = destSize; 
....................             break; 
....................         } 
....................          
....................         str = va_arg(args, const char*); 
....................         strncpy(destStr + len, str, destSize - len); 
....................         len += strlen(str); 
....................     } 
....................  
....................     va_end( args ); 
....................      
....................     return len; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE ExtractURLFields(BYTE *vURL,  
....................                     PROTOCOLS *protocol,  
....................                     BYTE *vUsername, WORD *wUsernameLen,  
....................                     BYTE *vPassword, WORD *wPasswordLen,  
....................                     BYTE *vHostname, WORD *wHostnameLen,  
....................                     WORD *wPort,  
....................                     BYTE *vFilePath, WORD *wFilePathLen) 
....................  
....................   Summary: 
....................    Extracts all parameters from an URL string (ex:  
....................    "http://admin:passwd@www.microchip.com:8080/myfile.gif" is split into  
....................    {PROTOCOL_HTTP, "admin", "passwd", "www.microchip.com", 8080, "/myfile.gif"}. 
....................  
....................   Description: 
....................    Extracts all parameters from an URL string (ex:  
....................    "http://admin:passwd@www.microchip.com:8080/myfile.gif" is split into  
....................    {PROTOCOL_HTTP, "admin", "passwd", "www.microchip.com", 8080, "/myfile.gif"}. 
....................     
....................    The URL string can be null terminated, or alternatively could be terminated  
....................    by a carriage return or line feed. 
....................     
....................    If the protocol is unrecognized or the protocol is recognized but the URL  
....................    is malformed, than an error is safely returned.  For more information on  
....................    URL/URI interpretation see RFC 2396. 
....................  
....................   Precondition: 
....................    This function is commented out by default to save code space because  
....................    it is not used by any current stack features.  However, if you want to use  
....................    it, go ahead and uncomment it.  It has been tested, so it (should) work  
....................    correctly. 
....................  
....................   Parameters: 
....................    vURL -   Pointer to null terminated URL to decode and extract from.  This  
....................       parameter is required and needs to have the minimum RFC 1738 components  
....................       in it (protocol and hostname). 
....................        
....................    protocol - Optional pointer to a PROTOCOLS enum to retrieve the decoded  
....................       protocol type.  If this parameter is unneeded, specify a NULL pointer.   
....................       The protocol is a required part of the URL, so it must always be  
....................       present.  The protocol also determines what scheme all other parameters  
....................       are decoded using, so the function will fail if an unrecognized  
....................       protocol is provided.  The PROTOCOLS enum members show all of the  
....................       currently supported protocols for this function. 
....................        
....................       <p>For the example URL provided in the function description,  
....................       PROTOCOL_HTTP would be returned for this field. 
....................        
....................    vUsername - Optional pointer to a buffer to write the decoded username  
....................       portion of the URL.  If the URL does not contain a username or a NULL  
....................       pointer is supplied, then this field is ignored. 
....................  
....................       <p>For the example URL provided in the function description, "admin"  
....................       would be returned for this field. 
....................        
....................    wUsernameLen - 
....................       On call\: Optional pointer to a WORD specifying the maximum length of  
....................       the vUsername buffer, including the null terminator character. 
....................        
....................       <p>Upon return\: If wUsernameLen and vUsername are non-NULL, the  
....................       *wUsernameLen WORD is updated with the actual number of characters  
....................       written to the vUsername buffer, including the null terminator  
....................       character.  If vUsername is NULL but wUsernameLen is non-NULL, then no  
....................       characters are copied, but *wUsernameLen will return the number of  
....................       characters required to fit the full username string.  If wUsernameLen  
....................       is NULL, then the username field in the URL, if present, is ignored and  
....................       the vUsername pointer is not used. 
....................        
....................       <p>If zero characters were written, this indicates that the URL did not  
....................       contain a username field.  If one character was written, this indicates  
....................       that a username field was present, but was a zero character string  
....................       (ex\: ""). 
....................         
....................       <p>For the example URL provided in the function description, 6 (0x0006)  
....................       would be returned for this field. 
....................        
....................    vPassword - Optional pointer to a buffer to write the decoded password  
....................       portion of the URL.  If the URL does not contain a password or a NULL  
....................       pointer is supplied, then this field is ignored. 
....................  
....................       <p>For the example URL provided in the function description, "passwd"  
....................       would be returned for this field. 
....................        
....................    wPasswordLen - 
....................       On call\: Optional pointer to a WORD specifying the maximum length of  
....................       the vPassword buffer, including the null terminator character. 
....................        
....................       <p>Upon return\: If wPasswordLen and vPassword are non-NULL, the  
....................       *wPasswordLen WORD is updated with the actual number of characters  
....................       written to the vPassword buffer, including the null terminator  
....................       character.  If vPassword is NULL but wPasswordLen is non-NULL, then no  
....................       characters are copied, but *wPasswordLen will return the number of  
....................       characters required to fit the full password string.  If wPasswordLen  
....................       is NULL, then the password field in the URL, if present, is ignored and  
....................       the vPassword pointer is not used. 
....................        
....................       <p>If zero characters were written, this indicates that the URL did not  
....................       contain a password field.  If one character was written, this indicates  
....................       that a password field was present, but was a zero character string  
....................       (ex\: ""). 
....................         
....................       <p>For the example URL provided in the function description, 7 (0x0007)  
....................       would be returned for this field. 
....................        
....................    vHostname - Optional pointer to a buffer to write the decoded hostname  
....................       portion of the URL.  All Internet URLs must contain a hostname or IP  
....................       address, however, if a NULL pointer is supplied, then this field is  
....................       ignored. 
....................  
....................       <p>For the example URL provided in the function description,  
....................       "www.microchip.com" would be returned for this field.  If the URL was  
....................       "http://192.168.0.1", then this field would be returned as  
....................       "192.168.0.1".   The IP address would not be decoded to a DWORD (use the  
....................       StringToIPAddress() helper function to do this). 
....................        
....................    wHostnameLen - 
....................       On call\: Optional pointer to a WORD specifying the maximum length of  
....................       the vHostname buffer, including the null terminator character. 
....................        
....................       <p>Upon return\: If wHostnameLen and vHostname are non-NULL, the  
....................       *wHostnameLen WORD is updated with the actual number of characters  
....................       written to the vHostname buffer, including the null terminator  
....................       character.  If vHostname is NULL but wHostnameLen is non-NULL, then no  
....................       characters are copied, but *wHostnameLen will return the number of  
....................       characters required to fit the full hostname string.  If wHostnameLen  
....................       is NULL, then the hostname field in the URL, is ignored and the  
....................       vHostname pointer is not used. 
....................        
....................       <p>For the example URL provided in the function description,  
....................       18 (0x0012) would be returned for this field.  If the URL was  
....................       "http://192.168.0.1", then this field would be returned as 12 (0x000C). 
....................        
....................    wPort - Optional pointer to a WORD specifying the TCP or UDP port that the  
....................       server is listening on.  If the port field is absent from the URL, then  
....................       this parameter will specify the default port for the protocol.  For  
....................       example, "http://www.microchip.com" would result in 80 being return as  
....................       the specified port. 
....................         
....................       <p>If the wPort pointer is NULL, then the port field in the URL  
....................       is ignored, if present. 
....................        
....................    vFilePath - Optional pointer to a buffer to write the decoded file path  
....................       portion of the URL.  If a NULL pointer is supplied, then this field is  
....................       ignored.  If a file path is not present in the URL, then "/" will be  
....................       returned in this field.   
....................  
....................       <p>For the example URL provided in the function description,  
....................       "/myfile.gif" would be returned for this field. 
....................        
....................    wFilePathLen - 
....................       On call\: Optional pointer to a WORD specifying the maximum length of  
....................       the vFilePath buffer, including the null terminator character. 
....................        
....................       <p>Upon return\: If wFilePathLen and vFilePath are non-NULL, the  
....................       *wFilePathLen WORD is updated with the actual number of characters  
....................       written to the vFilePath buffer, including the null terminator  
....................       character.  If vFilePath is NULL but wFilePathLen is non-NULL, then no  
....................       characters are copied, but *wFilePathLen will return the number of  
....................       characters required to fit the full file path string.  If wFilePathLen  
....................       is NULL, then the file path field in the URL, if present, is ignored and  
....................       the vFilePath pointer is not used. 
....................        
....................       <p>This function always returns "/" if no file path is present, so 
....................       *wFilePathLen will also be at least 2 characters ('/' and null  
....................       terminator) if the pointer is non-NULL. 
....................     
....................       <p>For the example URL provided in the function description, 12 (0x000C)  
....................       would be returned for this field. 
....................        
....................   Returns: 
....................    Zero on success.  Nonzero indicates an error code.  If a nonzero error code  
....................    is returned, none of the returned buffers or pointer values should be  
....................    treated as valid, but some of them may have been written to.  The following  
....................    are all possible return values. 
....................    <table> 
....................       0   No error 
....................       1   Protocol unknown (additional code needs to be added to  
....................           ExtractURLFields() and the PROTOCOLS enum needs to be updated if  
....................           you want to decode URLs of this protocol type. 
....................       2   URL malformed. Illegal or unknown URL format encountered. 
....................       3   Buffer too small.  One of the input buffer sizes is too small to  
....................           contain the URL parameter. 
....................    </table> 
....................   ***************************************************************************/ 
.................... #if 0    
.................... BYTE ExtractURLFields(BYTE *vURL, PROTOCOLS *protocol, BYTE *vUsername, WORD *wUsernameLen, BYTE *vPassword, WORD *wPasswordLen, BYTE *vHostname, WORD *wHostnameLen, WORD *wPort, BYTE *vFilePath, WORD *wFilePathLen) 
.................... { 
....................    // These two arrays must exactly match up each other and the PROTOCOLS enum  
....................    // elements.  The protocol name strings must also be specified in all  
....................    // lowercase. 
....................    static ROM char * ROM   vProtocolNames[] = {"http", "https", "mms", "rtsp"}; 
....................    static ROM WORD       wProtocolPorts[] = { 80,     443,     1755,  554}; 
....................    WORD w, w2; 
....................    BYTE i, j; 
....................    PROTOCOLS prot; 
....................    BYTE *temp, *temp2; 
....................    WORD wURLLen; 
....................    WORD wLocalPort; 
....................     
....................     
....................    // Calculate how long this URL is 
....................    wURLLen = strlen((char*)vURL); 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, '\r'); 
....................    if(temp) 
....................       wURLLen = temp - vURL; 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, '\n'); 
....................    if(temp) 
....................       wURLLen = temp - vURL; 
....................     
....................  
....................    // Parse starting protocol field 
....................    // Find out how long the protocol name field is 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, ':'); 
....................    if(temp == NULL) 
....................       return 2; 
....................     
....................    // Search protocol list to see if this is a recognized protocol 
....................    for(prot = 0; (BYTE)prot < sizeof(wProtocolPorts)/sizeof(wProtocolPorts[0]); prot++) 
....................    { 
....................       w = strlenpgm(vProtocolNames[prot]); 
....................       if((WORD)(temp - vURL) == w) 
....................       { 
....................          w2 = 0; 
....................          temp2 = vURL; 
....................          while(w) 
....................          { 
....................             i = *temp2++; 
....................             if((i >= 'A') && (i <= 'Z')) 
....................                i += 'a' - 'A'; 
....................             if(i != (BYTE)vProtocolNames[prot][w2++]) 
....................                break; 
....................             w--; 
....................          } 
....................          if(w == 0u) 
....................          { 
....................             if(protocol) 
....................                *protocol = prot; 
....................             break; 
....................          } 
....................       } 
....................    } 
....................  
....................    // If we've search the whole list and didn't find a match, then  
....................    // this protocol is unknown and this URL cannot be parsed. 
....................    if((BYTE)prot >= sizeof(wProtocolPorts)/sizeof(wProtocolPorts[0])) 
....................       return 1; 
....................     
....................    w = temp - vURL + 1; 
....................    vURL += w; 
....................    wURLLen -= w; 
....................  
....................    // Protocols using the authority field all must have a double  
....................    // slash "//" prefix 
....................    if(wURLLen < 2u) 
....................       return 2; 
....................    for(j = 0; j < 2u; j++) 
....................    { 
....................       i = *vURL++; 
....................       if(i != '/') 
....................          return 2; 
....................    } 
....................    wURLLen -= 2; 
....................     
....................  
....................    // Parse username and password fields 
....................    // See if there is a @ sign, indicating that there is at  
....................    // least a username and possibly a password in this URL 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, '@'); 
....................    if(temp == NULL) 
....................    { 
....................       if(wUsernameLen) 
....................          *wUsernameLen = 0; 
....................       if(wPasswordLen) 
....................          *wPasswordLen = 0; 
....................    } 
....................    else 
....................    { 
....................       // If we get down here, there is a user name present, let's  
....................       // see if a password is also present by searching for a  
....................       // colon between the current string position and the @  
....................       // symbol. 
....................       temp2 = (BYTE*)strnchr((char*)vURL, temp - vURL, ':'); 
....................        
....................       // Calculate username length and password length, including  
....................       // null terminator (if the field exists) 
....................       if(temp2 == NULL) 
....................       { 
....................          w = temp - vURL + 1;   // Username 
....................          w2 = 0;               // Password 
....................       } 
....................       else 
....................       { 
....................          w = temp2 - vURL + 1;   // Username 
....................          w2 = temp - temp2;      // Password 
....................       } 
....................        
....................       if(wUsernameLen) 
....................       { 
....................          if(vUsername) 
....................          { 
....................             if(*wUsernameLen < w) 
....................                return 3; 
....................             memcpy((void*)vUsername, (void*)vURL, w - 1); 
....................             vUsername[w-1] = 0; 
....................          } 
....................          *wUsernameLen = w; 
....................       } 
....................     
....................       if(wPasswordLen) 
....................       { 
....................          if(vPassword) 
....................          { 
....................             if(*wPasswordLen < w2) 
....................                return 3; 
....................             if(w2) 
....................             { 
....................                memcpy((void*)vPassword, (void*)temp2+1, w2 - 1); 
....................                vPassword[w2-1] = 0; 
....................             } 
....................          } 
....................          *wPasswordLen = w2; 
....................       } 
....................     
....................       vURL += w; 
....................       wURLLen -= w; 
....................       if(w2) 
....................       { 
....................          vURL += w2; 
....................          wURLLen -= w2; 
....................       } 
....................    } 
....................  
....................  
....................    // Parse hostname field 
....................    // Find the length of the hostname, including NULL  
....................    // terminator 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, ':'); 
....................    temp2 = (BYTE*)strnchr((char*)vURL, wURLLen, '/'); 
....................    if(temp && temp2) 
....................    { 
....................       if(temp > temp2) 
....................          temp = NULL; 
....................    } 
....................    if(temp == NULL) 
....................    { 
....................       temp = temp2; 
....................       if(temp2 == NULL) 
....................          temp = vURL + wURLLen; 
....................    } 
....................    w = temp - vURL + 1; 
....................    if(wHostnameLen) 
....................    { 
....................       if(vHostname) 
....................       { 
....................          if(*wHostnameLen < w) 
....................             return 3; 
....................          memcpy((void*)vHostname, (void*)vURL, w - 1); 
....................          vHostname[w-1] = 0; 
....................       } 
....................       *wHostnameLen = w; 
....................    } 
....................    vURL += w - 1; 
....................    wURLLen -= w - 1; 
....................  
....................  
....................    // Parse port field 
....................    if(*vURL == ':') 
....................    { 
....................       vURL++; 
....................       wURLLen--; 
....................       wLocalPort = 0; 
....................       w = wURLLen; 
....................       temp = (BYTE*)strnchr((char*)vURL, wURLLen, '/'); 
....................       if(temp != NULL) 
....................          w = temp - vURL; 
....................       w2 = w; 
....................       if(wPort) 
....................       { 
....................          while(w--) 
....................          { 
....................             wLocalPort *= 10; 
....................             wLocalPort += *vURL++ - '0'; 
....................          } 
....................          *wPort = wLocalPort; 
....................       } 
....................       else 
....................          vURL += w2; 
....................       wURLLen -= w2; 
....................    } 
....................    else if(wPort) 
....................       *wPort = wProtocolPorts[prot]; 
....................  
....................  
....................    // Parse file path field 
....................    if(wFilePathLen) 
....................    { 
....................       w = ++wURLLen; 
....................       if(wURLLen == 1u) 
....................          w = 2; 
....................       if(vFilePath) 
....................       { 
....................          if(*wFilePathLen < w) 
....................             return 3; 
....................          if(wURLLen == 1u) 
....................             vFilePath[0] = '/'; 
....................          else 
....................             memcpy((void*)vFilePath, (void*)vURL, wURLLen - 1); 
....................          vFilePath[w - 1] = 0; 
....................          *wFilePathLen = w; 
....................          return 0; 
....................       } 
....................       *wFilePathLen = w; 
....................    } 
....................    return 0; 
.................... } 
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    SHORT Replace(BYTE *vExpression, ROM BYTE *vFind, ROM BYTE *vReplacement,  
....................               WORD wMaxLen, BOOL bSearchCaseInsensitive) 
....................  
....................   Summary: 
....................    Replaces all instances of a particular substring with a new string 
....................  
....................   Description: 
....................    Searches a string (vExpression) and replaces all instances of a particular  
....................    substring (vFind) with a new string (vReplacement).  The start offset to  
....................    being searching and a maximum number of replacements can be specified.  The  
....................    search can be performed in a case sensitive or case insensitive manner. 
....................  
....................   Precondition: 
....................    This function is commented out by default to save code space because  
....................    it is not used by any current stack features.  However, if you want to use  
....................    it, go ahead and uncomment it.  It has been tested, so it (should) work  
....................    correctly. 
....................  
....................   Parameters: 
....................    vExpression - Null terminated string to search and make replacements within. 
....................    vFind - Null terminated string to search for. 
....................    vReplacement - Null terminated string to replace all instances of vFind with. 
....................    wMaxLen - Maximum length of the output vExpression string if string  
....................       expansion is going to occur (replacement length is longer than find  
....................       length).  If the replacements will cause this maximum string length to  
....................       be exceeded, then no replacements will be made and a negative result  
....................       will be returned, indicating failure.  If the replacement length is  
....................       shorter or equal to the search length, then this parameter is ignored. 
....................    bSearchCaseInsensitive - Boolean indicating if the search should be  
....................       performed in a case insensitive manner.  Specify TRUE for case  
....................       insensitive searches (slower) or FALSE for case sensitive  
....................       searching (faster). 
....................  
....................   Remarks: 
....................    If the replacement string length is shorter than or equal to the search  
....................    string length and the search string occurs in multiple overlapping  
....................    locations (ex\: expression is "aaa", find is "aa", and replacement is "bb")  
....................    then the first find match occuring when searching from left to right will  
....................    be replaced.  (ex\: output expression will be "bba"). 
....................     
....................    However, if the replacement string length is longer than the search string  
....................    length, the search will occur starting from the end of the string and  
....................    proceed to the beginning (right to left searching).  In this case if the  
....................    expression was "aaa", find was "aa", and replacement was "bbb", then the  
....................    final output expression will be "abbb".   
....................  
....................   Returns: 
....................    If zero or greater, indicates the count of how many replacements were made.   
....................    If less than zero (negative result), indicates that wMaxLen was too small  
....................    to make the necessary replacements.  In this case, no replacements were  
....................    made. 
....................   ***************************************************************************/ 
.................... #if 0 
.................... SHORT Replace(BYTE *vExpression, ROM BYTE *vFind, ROM BYTE *vReplacement, WORD wMaxLen, BOOL bSearchCaseInsensitive) 
.................... { 
....................    WORD wExpressionLen, wFindLen, wFindLenMinusOne, wReplacementLen; 
....................    WORD wFindCount, wReplacementsLeft; 
....................    BYTE i, j; 
....................    BYTE vFirstFindChar; 
....................    WORD wBytesLeft; 
....................    BYTE *vDest; 
....................    BYTE *vExpressionCompare; 
....................    ROM BYTE *vFindCompare; 
....................    WORD w; 
....................  
....................    wFindLen = strlenpgm((ROM char*)vFind); 
....................    if(wFindLen == 0u) 
....................       return 0; 
....................     
....................    wExpressionLen = strlen((char*)vExpression); 
....................    wReplacementLen = strlenpgm((ROM char*)vReplacement); 
....................  
....................    wFindCount = 0; 
....................    wFindLenMinusOne = wFindLen - 1; 
....................    vFirstFindChar = *vFind++; 
....................    if(bSearchCaseInsensitive)   // Convert to all lowercase if needed 
....................       if((vFirstFindChar >= (BYTE)'A') && (vFirstFindChar <= (BYTE)'Z')) 
....................          vFirstFindChar += 'a' - 'A'; 
....................  
....................    // If the replacement string is the same length as the search string, then  
....................    // we can immediately do the needed replacements inline and return. 
....................    if(wFindLen == wReplacementLen) 
....................    { 
....................       for(wBytesLeft = wExpressionLen; wBytesLeft; wBytesLeft--) 
....................       { 
....................          i = *vExpression++; 
....................          if(bSearchCaseInsensitive) 
....................          { 
....................             if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                i += 'a' - 'A'; 
....................             if(i != vFirstFindChar) 
....................                continue; 
....................             vExpressionCompare = vExpression; 
....................             vFindCompare = vFind; 
....................             w = wFindLenMinusOne; 
....................             while(w) 
....................             { 
....................                i = *vExpressionCompare++; 
....................                j = *vFindCompare++; 
....................                if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                   i += 'a' - 'A'; 
....................                if((j >= (BYTE)'A') && (j <= (BYTE)'Z')) 
....................                   j += 'a' - 'A'; 
....................                if(i != j) 
....................                   break; 
....................                w--; 
....................             } 
....................             if(w) 
....................                continue; 
....................          } 
....................          else 
....................          { 
....................             if(i != vFirstFindChar) 
....................                continue; 
....................             if(memcmppgm2ram((void*)vExpression, (ROM void*)vFind, wFindLenMinusOne)) 
....................                continue; 
....................          } 
....................     
....................          memcpypgm2ram((void*)vExpression-1, (ROM void*)vReplacement, wReplacementLen); 
....................          wFindCount++; 
....................          vExpression += wFindLenMinusOne; 
....................          wBytesLeft -= wFindLenMinusOne; 
....................       } 
....................       return wFindCount; 
....................    } 
....................     
....................     
....................    // If the replacement string is shorter than the search string, then we can  
....................    // search from left to right and move the string over as we find occurrences. 
....................    if(wFindLen > wReplacementLen) 
....................    { 
....................       vDest = vExpression; 
....................       for(wBytesLeft = wExpressionLen; wBytesLeft; wBytesLeft--) 
....................       { 
....................          i = *vExpression++; 
....................          *vDest++ = i; 
....................          if(bSearchCaseInsensitive) 
....................          { 
....................             if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                i += 'a' - 'A'; 
....................             if(i != vFirstFindChar) 
....................                continue; 
....................             vExpressionCompare = vExpression; 
....................             vFindCompare = vFind; 
....................             w = wFindLenMinusOne; 
....................             while(w) 
....................             { 
....................                i = *vExpressionCompare++; 
....................                j = *vFindCompare++; 
....................                if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                   i += 'a' - 'A'; 
....................                if((j >= (BYTE)'A') && (j <= (BYTE)'Z')) 
....................                   j += 'a' - 'A'; 
....................                if(i != j) 
....................                   break; 
....................                w--; 
....................             } 
....................             if(w) 
....................                continue; 
....................          } 
....................          else 
....................          { 
....................             if(i != vFirstFindChar) 
....................                continue; 
....................             if(memcmppgm2ram((void*)vExpression, (ROM void*)vFind, wFindLenMinusOne)) 
....................                continue; 
....................          } 
....................     
....................          memcpypgm2ram((void*)vDest-1, (ROM void*)vReplacement, wReplacementLen); 
....................          vDest += wReplacementLen-1; 
....................          wFindCount++; 
....................          vExpression += wFindLenMinusOne; 
....................          wBytesLeft -= wFindLenMinusOne; 
....................       } 
....................       *vDest = 0x00;   // Write new null terminator since the string may have shrunk 
....................       return wFindCount; 
....................    } 
....................     
....................    // If the replacement string is longer than the search string, then we will  
....................    // take a two pass approach.  On the first pass, we will merely count how  
....................    // many replacements to make.  With this we can calculate how long the  
....................    // final string is going to be.  On the second pass, we will search from  
....................    // right to left and expand the string as needed. 
....................  
....................    // Pass 1: count how many occurrences of vFind are in vExpression 
....................    for(wBytesLeft = wExpressionLen; wBytesLeft; wBytesLeft--) 
....................    { 
....................       i = *vExpression++; 
....................       if(bSearchCaseInsensitive) 
....................       { 
....................          if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................             i += 'a' - 'A'; 
....................          if(i != vFirstFindChar) 
....................             continue; 
....................          vExpressionCompare = vExpression; 
....................          vFindCompare = vFind; 
....................          w = wFindLenMinusOne; 
....................          while(w) 
....................          { 
....................             i = *vExpressionCompare++; 
....................             j = *vFindCompare++; 
....................             if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                i += 'a' - 'A'; 
....................             if((j >= (BYTE)'A') && (j <= (BYTE)'Z')) 
....................                j += 'a' - 'A'; 
....................             if(i != j) 
....................                break; 
....................             w--; 
....................          } 
....................          if(w) 
....................             continue; 
....................       } 
....................       else 
....................       { 
....................          if(i != vFirstFindChar) 
....................             continue; 
....................          if(memcmppgm2ram((void*)vExpression, (ROM void*)vFind, wFindLenMinusOne)) 
....................             continue; 
....................       } 
....................  
....................       wFindCount++; 
....................       vExpression += wFindLenMinusOne; 
....................       wBytesLeft -= wFindLenMinusOne; 
....................    } 
....................     
....................    // Return immediately if no replacements are needed 
....................    if(wFindCount == 0u) 
....................       return 0; 
....................  
....................    // Pass 2: make replacements and move string over 
....................    vDest = vExpression + wFindCount * (wReplacementLen - wFindLen); 
....................    if(vDest > vExpression - wExpressionLen + wMaxLen) 
....................       return -1; 
....................    *vDest-- = 0x00;   // Write new null terminator 
....................    vExpression -= 1; 
....................    vFind -= 1; 
....................    vFirstFindChar = vFind[wFindLenMinusOne]; 
....................    if(bSearchCaseInsensitive)   // Convert to all lowercase if needed 
....................       if((vFirstFindChar >= (BYTE)'A') && (vFirstFindChar <= (BYTE)'Z')) 
....................          vFirstFindChar += 'a' - 'A'; 
....................    wReplacementsLeft = wFindCount; 
....................    while(wReplacementsLeft) 
....................    { 
....................       i = *vExpression--; 
....................       *vDest-- = i; 
....................       if(bSearchCaseInsensitive) 
....................       { 
....................          if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................             i += 'a' - 'A'; 
....................          if(i != vFirstFindChar) 
....................             continue; 
....................          vExpressionCompare = vExpression; 
....................          vFindCompare = &vFind[wFindLenMinusOne-1]; 
....................          w = wFindLenMinusOne; 
....................          while(w) 
....................          { 
....................             i = *vExpressionCompare--; 
....................             j = *vFindCompare--; 
....................             if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                i += 'a' - 'A'; 
....................             if((j >= (BYTE)'A') && (j <= (BYTE)'Z')) 
....................                j += 'a' - 'A'; 
....................             if(i != j) 
....................                break; 
....................             w--; 
....................          } 
....................          if(w) 
....................             continue; 
....................       } 
....................       else 
....................       { 
....................          if(i != vFirstFindChar) 
....................             continue; 
....................          if(memcmppgm2ram((void*)vExpression-wFindLenMinusOne, (ROM void*)vFind, wFindLenMinusOne)) 
....................             continue; 
....................       } 
....................       memcpypgm2ram((void*)vDest-wReplacementLen+2, (ROM void*)vReplacement, wReplacementLen); 
....................       vDest -= wReplacementLen-1; 
....................  
....................       vExpression -= wFindLenMinusOne; 
....................       wBytesLeft -= wFindLenMinusOne; 
....................       wReplacementsLeft--; 
....................    } 
....................    return wFindCount; 
.................... } 
.................... #endif 
....................  
.................... //#include "Delay.c" //not needed, we overrode this in StackTsk2.h 
.................... #include "Tick.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for Timekeeping 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.c 
....................  * Dependencies:    Timer 0 (PIC18) or Timer 1 (PIC24F, PIC24H,  
....................  *					dsPIC30F, dsPIC33F, PIC32) 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.10b or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder		6/13/07		Changed to use timer without  
....................  *									writing for perfect accuracy. 
.................... ********************************************************************/ 
.................... #define __TICK_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... // Internal counter to store Ticks.  This variable is incremented in an ISR and  
.................... // therefore must be marked volatile to prevent the compiler optimizer from  
.................... // reordering code to use this value in the main context while interrupts are  
.................... // disabled. 
.................... static volatile DWORD dwInternalTicks = 0; 
....................  
.................... // 6-byte value to store Ticks.  Allows for use over longer periods of time. 
.................... static BYTE vTickReading[6]; 
....................  
.................... static void GetTickCopy(void); 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	void TickInit(void) 
....................  
....................   Summary: 
.................... 	Initializes the Tick manager module. 
....................  
....................   Description: 
.................... 	Configures the Tick module and any necessary hardware resources. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	None 
....................   	 
....................   Remarks: 
.................... 	This function is called only one during lifetime of the application. 
....................   ***************************************************************************/ 
.................... void TickInit(void) 
.................... { 
.................... #if defined(__18CXX) 
.................... 	// Use Timer0 for 8 bit processors 
....................     // Initialize the time 
....................     TMR0H = 0; 
*
0033A:  CLRF   FD7
....................     TMR0L = 0; 
0033C:  CLRF   FD6
....................  
.................... 	// Set up the timer interrupt 
.................... 	INTCON2bits.TMR0IP = 0;		// Low priority 
0033E:  BCF    FF1.2
....................     INTCONbits.TMR0IF = 0; 
00340:  BCF    FF2.2
....................     INTCONbits.TMR0IE = 1;		// Enable interrupt 
00342:  BSF    FF2.5
....................  
....................     // Timer0 on, 16-bit, internal timer, 1:256 prescalar 
....................     T0CON = 0x87; 
00344:  MOVLW  87
00346:  MOVWF  FD5
....................  
.................... #else 
00348:  GOTO   0354 (RETURN)
.................... 	// Use Timer 1 for 16-bit and 32-bit processors 
.................... 	// 1:256 prescale 
.................... 	T1CONbits.TCKPS = 3; 
.................... 	// Base 
.................... 	PR1 = 0xFFFF; 
.................... 	// Clear counter 
.................... 	TMR1 = 0; 
....................  
.................... 	// Enable timer interrupt 
.................... 	#if defined(__C30__) 
.................... 		IPC0bits.T1IP = 2;	// Interrupt priority 2 (low) 
.................... 		IFS0bits.T1IF = 0; 
.................... 		IEC0bits.T1IE = 1; 
.................... 	#else 
.................... 		IPC1bits.T1IP = 2;	// Interrupt priority 2 (low) 
.................... 		IFS0CLR = _IFS0_T1IF_MASK; 
.................... 		IEC0SET = _IEC0_T1IE_MASK; 
.................... 	#endif 
....................  
.................... 	// Start timer 
.................... 	T1CONbits.TON = 1; 
.................... #endif 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	static void GetTickCopy(void) 
....................  
....................   Summary: 
.................... 	Reads the tick value. 
....................  
....................   Description: 
.................... 	This function performs an interrupt-safe and synchronized read of the  
.................... 	48-bit Tick value. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	None 
....................   ***************************************************************************/ 
.................... static void GetTickCopy(void) 
.................... { 
.................... 	// Perform an Interrupt safe and synchronized read of the 48-bit  
.................... 	// tick value 
.................... #if defined(__18CXX) 
.................... 	do 
.................... 	{ 
.................... 		INTCONbits.TMR0IE = 1;		// Enable interrupt 
*
01A44:  BSF    FF2.5
.................... 		Nop(); 
01A46:  NOP   
.................... 		INTCONbits.TMR0IE = 0;		// Disable interrupt 
01A48:  BCF    FF2.5
.................... 		vTickReading[0] = TMR0L; 
01A4A:  MOVFF  FD6,74
.................... 		vTickReading[1] = TMR0H; 
01A4E:  MOVFF  FD7,75
.................... 		*((DWORD*)&vTickReading[2]) = dwInternalTicks; 
01A52:  MOVLB  2
01A54:  CLRF   x9D
01A56:  MOVLW  76
01A58:  MOVWF  FE9
01A5A:  MOVFF  29D,FEA
01A5E:  MOVFF  70,FEF
01A62:  MOVFF  71,FEC
01A66:  MOVFF  72,FEC
01A6A:  MOVFF  73,FEC
.................... 	} while(INTCONbits.TMR0IF); 
01A6E:  BTFSS  FF2.2
01A70:  BRA    1A76
01A72:  MOVLB  0
01A74:  BRA    1A44
.................... 	INTCONbits.TMR0IE = 1;			// Enable interrupt 
01A76:  BSF    FF2.5
.................... #elif defined(__C30__) 
01A78:  MOVLB  0
01A7A:  RETURN 0
.................... 	do 
.................... 	{ 
.................... 		DWORD dwTempTicks; 
.................... 		 
.................... 		IEC0bits.T1IE = 1;			// Enable interrupt 
.................... 		Nop(); 
.................... 		IEC0bits.T1IE = 0;			// Disable interrupt 
....................  
.................... 		// Get low 2 bytes 
.................... 		((WORD*)vTickReading)[0] = TMR1; 
.................... 		 
.................... 		// Correct corner case where interrupt increments byte[4+] but  
.................... 		// TMR1 hasn't rolled over to 0x0000 yet 
.................... 		dwTempTicks = dwInternalTicks; 
.................... 		if(((WORD*)vTickReading)[0] == 0xFFFFu) 
.................... 			dwTempTicks--; 
.................... 		 
.................... 		// Get high 4 bytes 
.................... 		vTickReading[2] = ((BYTE*)&dwTempTicks)[0]; 
.................... 		vTickReading[3] = ((BYTE*)&dwTempTicks)[1]; 
.................... 		vTickReading[4] = ((BYTE*)&dwTempTicks)[2]; 
.................... 		vTickReading[5] = ((BYTE*)&dwTempTicks)[3]; 
.................... 	} while(IFS0bits.T1IF); 
.................... 	IEC0bits.T1IE = 1;				// Enable interrupt 
.................... #else	// PIC32 
.................... 	do 
.................... 	{ 
.................... 		DWORD dwTempTicks; 
.................... 		 
.................... 		IEC0SET = _IEC0_T1IE_MASK;	// Enable interrupt 
.................... 		Nop(); 
.................... 		IEC0CLR = _IEC0_T1IE_MASK;	// Disable interrupt 
.................... 		 
.................... 		// Get low 2 bytes 
.................... 		((volatile WORD*)vTickReading)[0] = TMR1; 
.................... 		 
.................... 		// Correct corner case where interrupt increments byte[4+] but  
.................... 		// TMR1 hasn't rolled over to 0x0000 yet 
.................... 		dwTempTicks = dwInternalTicks; 
....................  
.................... 		// PIC32MX3XX/4XX devices trigger the timer interrupt when TMR1 == PR1  
.................... 		// (TMR1 prescalar is 0x00), requiring us to undo the ISR's increment  
.................... 		// of the upper 32 bits of our 48 bit timer in the special case when  
.................... 		// TMR1 == PR1 == 0xFFFF.  For other PIC32 families, the ISR is  
.................... 		// triggered when TMR1 increments from PR1 to 0x0000, making no special  
.................... 		// corner case. 
.................... 		#if __PIC32_FEATURE_SET__ <= 460 
.................... 			if(((WORD*)vTickReading)[0] == 0xFFFFu) 
.................... 				dwTempTicks--; 
.................... 		#elif !defined(__PIC32_FEATURE_SET__) 
.................... 			#error __PIC32_FEATURE_SET__ macro must be defined.  You need to download a newer C32 compiler version. 
.................... 		#endif 
.................... 		 
.................... 		// Get high 4 bytes 
.................... 		vTickReading[2] = ((BYTE*)&dwTempTicks)[0]; 
.................... 		vTickReading[3] = ((BYTE*)&dwTempTicks)[1]; 
.................... 		vTickReading[4] = ((BYTE*)&dwTempTicks)[2]; 
.................... 		vTickReading[5] = ((BYTE*)&dwTempTicks)[3]; 
.................... 	} while(IFS0bits.T1IF); 
.................... 	IEC0SET = _IEC0_T1IE_MASK;		// Enable interrupt 
.................... #endif 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	DWORD TickGet(void) 
....................  
....................   Summary: 
.................... 	Obtains the current Tick value. 
....................  
....................   Description: 
.................... 	This function retrieves the current Tick value, allowing timing and 
.................... 	measurement code to be written in a non-blocking fashion.  This function 
.................... 	retrieves the least significant 32 bits of the internal tick counter,  
.................... 	and is useful for measuring time increments ranging from a few  
.................... 	microseconds to a few hours.  Use TickGetDiv256 or TickGetDiv64K for 
.................... 	longer periods of time. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	Lower 32 bits of the current Tick value. 
....................   ***************************************************************************/ 
.................... DWORD TickGet(void) 
.................... { 
.................... 	GetTickCopy(); 
*
01AC2:  RCALL  1A44
.................... 	return *((DWORD*)&vTickReading[0]); 
01AC4:  MOVLB  2
01AC6:  CLRF   x9D
01AC8:  MOVLW  74
01ACA:  MOVFF  29D,03
01ACE:  MOVWF  FE9
01AD0:  MOVFF  29D,FEA
01AD4:  MOVFF  FEF,00
01AD8:  MOVFF  FEC,01
01ADC:  MOVFF  FEC,02
01AE0:  MOVFF  FEC,03
01AE4:  MOVLB  0
01AE6:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	DWORD TickGetDiv256(void) 
....................  
....................   Summary: 
.................... 	Obtains the current Tick value divided by 256. 
....................  
....................   Description: 
.................... 	This function retrieves the current Tick value, allowing timing and 
.................... 	measurement code to be written in a non-blocking fashion.  This function 
.................... 	retrieves the middle 32 bits of the internal tick counter,  
.................... 	and is useful for measuring time increments ranging from a few  
.................... 	minutes to a few weeks.  Use TickGet for shorter periods or TickGetDiv64K 
.................... 	for longer ones. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	Middle 32 bits of the current Tick value. 
....................   ***************************************************************************/ 
.................... DWORD TickGetDiv256(void) 
.................... { 
.................... 	DWORD dw; 
....................  
.................... 	GetTickCopy(); 
*
01A7C:  RCALL  1A44
.................... 	((BYTE*)&dw)[0] = vTickReading[1];	// Note: This copy must be done one  
01A7E:  MOVFF  75,271
.................... 	((BYTE*)&dw)[1] = vTickReading[2];	// byte at a time to prevent misaligned  
01A82:  MOVFF  76,272
.................... 	((BYTE*)&dw)[2] = vTickReading[3];	// memory reads, which will reset the PIC. 
01A86:  MOVFF  77,273
.................... 	((BYTE*)&dw)[3] = vTickReading[4]; 
01A8A:  MOVFF  78,274
.................... 	 
.................... 	return dw; 
01A8E:  MOVFF  271,00
01A92:  MOVFF  272,01
01A96:  MOVFF  273,02
01A9A:  MOVFF  274,03
01A9E:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	DWORD TickGetDiv64K(void) 
....................  
....................   Summary: 
.................... 	Obtains the current Tick value divided by 64K. 
....................  
....................   Description: 
.................... 	This function retrieves the current Tick value, allowing timing and 
.................... 	measurement code to be written in a non-blocking fashion.  This function 
.................... 	retrieves the most significant 32 bits of the internal tick counter,  
.................... 	and is useful for measuring time increments ranging from a few  
.................... 	days to a few years, or for absolute time measurements.  Use TickGet or 
.................... 	TickGetDiv256 for shorter periods of time. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	Upper 32 bits of the current Tick value. 
....................   ***************************************************************************/ 
.................... DWORD TickGetDiv64K(void) 
.................... { 
.................... 	DWORD dw; 
....................  
.................... 	GetTickCopy(); 
.................... 	((BYTE*)&dw)[0] = vTickReading[2];	// Note: This copy must be done one  
.................... 	((BYTE*)&dw)[1] = vTickReading[3];	// byte at a time to prevent misaligned  
.................... 	((BYTE*)&dw)[2] = vTickReading[4];	// memory reads, which will reset the PIC. 
.................... 	((BYTE*)&dw)[3] = vTickReading[5]; 
.................... 	 
.................... 	return dw; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	DWORD TickConvertToMilliseconds(DWORD dwTickValue) 
....................  
....................   Summary: 
.................... 	Converts a Tick value or difference to milliseconds. 
....................  
....................   Description: 
.................... 	This function converts a Tick value or difference to milliseconds.  For 
.................... 	example, TickConvertToMilliseconds(32768) returns 1000 when a 32.768kHz  
.................... 	clock with no prescaler drives the Tick module interrupt. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	dwTickValue	- Value to convert to milliseconds 
....................  
....................   Returns: 
....................   	Input value expressed in milliseconds. 
....................  
....................   Remarks: 
.................... 	This function performs division on DWORDs, which is slow.  Avoid using 
.................... 	it unless you absolutely must (such as displaying data to a user).  For 
.................... 	timeout comparisons, compare the current value to a multiple or fraction  
.................... 	of TICK_SECOND, which will be calculated only once at compile time. 
....................   ***************************************************************************/ 
.................... DWORD TickConvertToMilliseconds(DWORD dwTickValue) 
.................... { 
.................... 	return (dwTickValue+(TICKS_PER_SECOND/2000ul))/((DWORD)(TICKS_PER_SECOND/1000ul)); 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	void TickUpdate(void) 
....................  
....................   Description: 
.................... 	Updates the tick value when an interrupt occurs. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	None 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... void TickUpdate(void) 
.................... { 
....................     if(INTCONbits.TMR0IF) 
*
00096:  BTFSS  FF2.2
00098:  BRA    00AC
....................     { 
.................... 		// Increment internal high tick counter 
.................... 		dwInternalTicks++; 
0009A:  MOVLW  01
0009C:  ADDWF  70,F
0009E:  BTFSC  FD8.0
000A0:  INCF   71,F
000A2:  BTFSC  FD8.2
000A4:  INCF   72,F
000A6:  BTFSC  FD8.2
000A8:  INCF   73,F
....................  
.................... 		// Reset interrupt flag 
....................         INTCONbits.TMR0IF = 0; 
000AA:  BCF    FF2.2
....................     } 
000AC:  GOTO   00B2 (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	void _ISR _T1Interrupt(void) 
....................  
....................   Description: 
.................... 	Updates the tick value when an interrupt occurs. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	None 
....................   ***************************************************************************/ 
.................... #elif defined(__PIC32MX__) 
.................... void __attribute((interrupt(ipl2), vector(_TIMER_1_VECTOR), nomips16)) _T1Interrupt(void) 
.................... { 
.................... 	// Increment internal high tick counter 
.................... 	dwInternalTicks++; 
....................  
.................... 	// Reset interrupt flag 
.................... 	IFS0CLR = _IFS0_T1IF_MASK; 
.................... } 
.................... #else 
.................... #if defined(__PCD__)  //__CCS__ __PCH__ __PCD__ ccs added 
.................... #int_timer1 NOCLEAR 
.................... void _T1Interrupt(void) 
.................... #elif __C30_VERSION__ >= 300 
.................... void _ISR __attribute__((__no_auto_psv__)) _T1Interrupt(void) 
.................... #else 
.................... void _ISR _T1Interrupt(void) 
.................... #endif 
.................... { 
.................... 	// Increment internal high tick counter 
.................... 	dwInternalTicks++; 
....................  
.................... 	// Reset interrupt flag 
.................... 	IFS0bits.T1IF = 0; 
.................... } 
.................... #endif 
....................  
.................... #if !defined(ENC_CS_TRIS) && !defined(WF_CS_TRIS) && !defined(ENC100_INTERFACE_MODE) && \ 
....................     (defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) || \ 
....................      defined(_18F97J60) ||  defined(_18F96J65) ||  defined(_18F96J60) ||  defined(_18F87J60) ||  defined(_18F86J65) ||  defined(_18F86J60) ||  defined(_18F67J60) ||  defined(_18F66J65) ||  defined(_18F66J60)) 
....................    #include "ETH97J60.c" 
.................... #elif defined(WF_CS_TRIS) 
....................       #include "WF_Config.c" 
....................       #if defined(WF_USE_SCAN_FUNCTIONS) 
....................          #include "WFScan.c" 
....................       #endif 
....................       #if defined(WF_USE_POWER_SAVE_FUNCTIONS) 
....................          #include "WFPowerSave.c" 
....................       #else 
....................          BOOL GetAppPowerSaveMode(void) {return(TRUE);} 
....................       #endif 
....................       #if defined(WF_USE_TX_POWER_CONTROL_FUNCTIONS) 
....................          #include "WFTxPower.c" 
....................       #endif 
....................       #include "WF_Spi.c" 
....................       #include "WF_Eint.c" 
....................       #include "WFConnectionProfile.c" 
....................       #include "WFConnectionAlgorithm.c" 
....................       #include "WFConnectionManager.c" 
....................       #include "WFEventHandler.c" 
....................       #include "WFInit.c" 
....................      #if defined(MRF24WG) 
....................       #include "WFDriverCom_24G.c" 
....................       #include "WFDriverRaw_24G.c" 
....................       #include "WFMac_24G.c" 
....................       #include "WFMgmtMsg_24G.c" 
....................       #include "WFParamMsg_24G.c"      
....................      #else 
....................       #include "WFDriverCom.c" 
....................       #include "WFDriverRaw.c" 
....................       #include "WFMac.c" 
....................       #include "WFMgmtMsg.c" 
....................       #include "WFParamMsg.c" 
....................      #endif 
.................... #elif defined(ENC_CS_TRIS) 
....................    #include "tcpip\ENC28J60.c" 
.................... /********************************************************************* 
....................  * 
....................  *  Medium Access Control (MAC) Layer for Microchip ENC28J60 
....................  *  Module for Microchip TCP/IP Stack 
....................  *   -Provides access to ENC28J60 Ethernet controller 
....................  *   -Reference: ENC28J60 Data sheet, IEEE 802.3 Standard 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.c 
....................  * Dependencies:    ENC28J60.h 
....................  *                  MAC.h 
....................  *                  string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  Delay.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder     6/28/04 Original 
....................  * Howard Schlunder     10/8/04 Cleanup 
....................  * Howard Schlunder     10/19/04 Small optimizations and more cleanup 
....................  * Howard Schlunder     11/29/04 Added Set/GetCLKOUT 
....................  * Howard Schlunder     12/23/05 Added B1 silicon errata workarounds 
....................  * Howard Schlunder     1/09/06 Added comments and minor mods 
....................  * Howard Schlunder     1/18/06 Added more silicon errata workarounds 
....................  * Howard Schlunder     6/16/06 Synchronized with PIC18F97J60 code 
....................  * Howard Schlunder     7/17/06 Updated TestMemory() for C30 
....................  * Howard Schlunder     8/07/06 Added SetRXHashTableEntry() function 
.................... ********************************************************************/ 
.................... #define __ENC28J60_C 
....................  
.................... #include "HardwareProfile.h" 
.................... // hardwareprofile.h 
....................  
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #if STACK_USE_CCS_EWLWIFIB || STACK_USE_CCS_EWLWIFIG 
....................  
....................    #bit WF_CS_TRIS1   =     0xF96.1 //E1 
....................    #define WF_CS_TRIS WF_CS_TRIS1 
....................    #bit WF_CS_IO     =  0xF8D.1    //LatE1 
....................    #bit WF_SDI_TRIS  =  0xF94.4    // (TRISCbits.TRISC4) 
....................    #bit WF_SCK_TRIS  =  0xF94.3    // (TRISCbits.TRISC3) 
....................    #bit WF_SDO_TRIS  =  0xF94.5    // (TRISCbits.TRISC5) 
....................    #bit WF_RESET_TRIS=  0xF93.1    //(TRISBbits.TRISB1) 
....................    #bit WF_RESET_IO  =  0xF8A.1     //(LATBbits.LATB1)   
....................    #bit WF_INT_TRIS  =  0xF93.0     // (TRISBbits.TRISB0)  // INT1 
....................    #bit WF_INT_IO    =  0xF81.0   //(PORTBbits.RB0)  
....................    #bit WF_HIBERNATE_TRIS= 0xF93.2  //(TRISBbits.TRISB2)  
....................    #bit   WF_HIBERNATE_IO=  0xF81.2    //(PORTBbits.RB2) 
....................     
....................    #bit WF_INT_EDGE  =  0xFF1.6      //(INTCON2bits.INTEDG0) 
....................    #bit WF_INT_IE    =  0xFF2.4   //(INTCONbits.INT0IE) 
....................    #bit WF_INT_IF    =  0xFF2.1   //(INTCONbits.INT0IF) 
....................    #define WF_SSPBUF  (SSP1BUF) 
....................    #define WF_SPISTAT  (SSP1STATbits) 
....................    #define WF_SPISTATbits SSP1STATbits     //(SSP1STATbits) 
....................    #define WF_SPICON1  (SSP1CON1bits) 
....................    #define WF_SPICON1bits WF_SPICON1    // (SSP1CON1bits) 
....................    #define WF_SPICON2  (SSP1CON2bits) 
....................    #bit WF_SPI_IE    =   0xF9D.3  //(PIE1bits.SSPIE) 
....................    #bit WF_SPI_IP    =   0xF9F.3  //(IPR1bits.SSPIP) 
....................    #bit WF_SPI_IF    =   0xF9E.3  //(PIR1bits.SSPIF) 
....................     
.................... #else 
....................  
.................... //#error define necessary hardware for TCPIP stack 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... // Make sure that this hardware profile has an ENC28J60 in it 
.................... #if defined(ENC_CS_TRIS) 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... /** D E F I N I T I O N S ****************************************************/ 
.................... // IMPORTANT SPI NOTE: The code in this file expects that the SPI interrupt 
.................... //      flag (ENC_SPI_IF) be clear at all times.  If the SPI is shared with 
.................... //      other hardware, the other code should clear the ENC_SPI_IF when it is 
.................... //      done using the SPI. 
....................  
.................... // Since the ENC28J60 doesn't support auto-negotiation, full-duplex mode is 
.................... // not compatible with most switches/routers.  If a dedicated network is used 
.................... // where the duplex of the remote node can be manually configured, you may 
.................... // change this configuration.  Otherwise, half duplex should always be used. 
.................... #define HALF_DUPLEX 
.................... //#define FULL_DUPLEX 
.................... //#define LEDB_DUPLEX 
....................  
.................... // Pseudo Functions 
.................... #define LOW(a)                  ((a) & 0xFF) 
.................... #define HIGH(a)                 (((a)>>8) & 0xFF) 
....................  
.................... // ENC28J60 Opcodes (to be ORed with a 5 bit address) 
.................... #define WCR (0x2<<5)            // Write Control Register command 
.................... #define BFS (0x4<<5)            // Bit Field Set command 
.................... #define BFC (0x5<<5)            // Bit Field Clear command 
.................... #define RCR (0x0<<5)            // Read Control Register command 
.................... #define RBM ((0x1<<5) | 0x1A)   // Read Buffer Memory command 
.................... #define WBM ((0x3<<5) | 0x1A)   // Write Buffer Memory command 
.................... #define SR  ((0x7<<5) | 0x1F)   // System Reset command does not use an address. 
....................                                 //   It requires 0x1F, however. 
....................  
.................... // Maximum SPI frequency specified in data sheet 
.................... #define ENC_MAX_SPI_FREQ    (20000000ul)    // Hz 
....................  
.................... #define ETHER_IP    (0x00u) 
.................... #define ETHER_ARP   (0x06u) 
....................  
.................... // A header appended at the start of all RX frames by the hardware 
.................... #if defined(__CCS__) 
.................... typedef struct  __attribute__((packed)) 
.................... #else 
.................... typedef struct  __attribute__((aligned(2), packed)) 
.................... #endif 
.................... { 
....................     WORD            NextPacketPointer; 
....................     RXSTATUS        StatusVector; 
....................  
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ENC_PREAMBLE; 
....................  
....................  
.................... #if defined (__18CXX) 
....................     #define ClearSPIDoneFlag()  {ENC_SPI_IF = 0;} 
....................     #define WaitForDataByte()   {while(!ENC_SPI_IF); ENC_SPI_IF = 0;} 
....................     #define SPI_ON_BIT          (ENC_SPICON1bits.SSPEN) 
.................... #elif defined(__C30__) 
....................     #define ClearSPIDoneFlag() 
....................     static inline __attribute__((__always_inline__)) void WaitForDataByte( void ) 
....................     { 
....................         while ((ENC_SPISTATbits.SPITBF == 1) || (ENC_SPISTATbits.SPIRBF == 0)); 
....................     } 
....................  
....................     #define SPI_ON_BIT          (ENC_SPISTATbits.SPIEN) 
.................... #elif defined( __PIC32MX__ ) 
....................     #define ClearSPIDoneFlag() 
....................     static inline __attribute__((__always_inline__)) void WaitForDataByte( void ) 
....................     { 
....................         while (!ENC_SPISTATbits.SPITBE || !ENC_SPISTATbits.SPIRBF); 
....................     } 
....................  
....................     #define SPI_ON_BIT          (ENC_SPICON1bits.ON) 
.................... #else 
....................     #error Determine SPI flag mechanism 
.................... #endif 
....................  
....................  
.................... // Prototypes of functions intended for MAC layer use only. 
.................... static void BankSel(WORD Register); 
.................... static REG ReadETHReg(BYTE Address); 
.................... static REG ReadMACReg(BYTE Address); 
.................... static void WriteReg(BYTE Address, BYTE Data); 
.................... static void BFCReg(BYTE Address, BYTE Data); 
.................... static void BFSReg(BYTE Address, BYTE Data); 
.................... static void SendSystemReset(void); 
.................... //static void GetRegs(void); 
.................... //void Get8KBRAM(void); 
....................  
.................... // Internal MAC level variables and flags. 
.................... static WORD_VAL NextPacketLocation; 
.................... static WORD_VAL CurrentPacketLocation; 
.................... static BOOL WasDiscarded; 
.................... static BYTE ENCRevID; 
....................  
....................  
.................... //NOTE: All code in this module expects Bank 0 to be currently selected.  If code ever changes the bank, it must restore it to Bank 0 before returning. 
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACInit sets up the PIC's SPI module and all the 
....................  *                  registers in the ENC28J60 so that normal operation can 
....................  *                  begin. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACInit(void) 
.................... { 
....................     BYTE i; 
....................  
....................     // Set up the SPI module on the PIC for communications with the ENC28J60 
....................     ENC_CS_IO = 1; 
*
00AC8:  BSF    F8C.1
....................     ENC_CS_TRIS = 0;        // Make the Chip Select pin an output 
00ACA:  BCF    F95.1
....................  
.................... #if defined(__18CXX) 
....................     ENC_SCK_TRIS = 0; 
00ACC:  BCF    F94.3
....................     ENC_SDO_TRIS = 0; 
00ACE:  BCF    F94.5
....................     ENC_SDI_TRIS = 1; 
00AD0:  BSF    F94.4
.................... #endif 
....................  
....................     // If the RESET pin is connected, take the chip out of reset 
.................... #if defined(ENC_RST_IO) 
....................     ENC_RST_IO      = 1; 
....................     ENC_RST_TRIS    = 0; 
.................... #endif 
....................  
....................     // Set up SPI 
....................     ClearSPIDoneFlag(); 
00AD2:  BCF    F9E.3
.................... #if defined(__18CXX) 
....................     ENC_SPICON1 = 0x20;     // SSPEN bit is set, SPI in master mode, FOSC/4, 
00AD4:  MOVLW  20
00AD6:  MOVWF  FC6
....................                             //   IDLE state is low level 
....................     ENC_SPISTATbits.CKE = 1;// Transmit data on rising edge of clock 
00AD8:  BSF    FC7.6
....................     ENC_SPISTATbits.SMP = 0;// Input sampled at middle of data output time 
00ADA:  BCF    FC7.7
.................... #elif defined(__C30__) 
....................     ENC_SPISTAT = 0;        // clear SPI 
....................     #if defined(__PIC24H__) || defined(__dsPIC33F__) || defined(__dsPIC33E__)|| defined(__PIC24E__) 
....................         ENC_SPICON1 = 0x0F;     // 1:1 primary prescale, 5:1 secondary prescale (8MHz  @ 40MIPS) 
....................     //    ENC_SPICON1 = 0x1E;   // 4:1 primary prescale, 1:1 secondary prescale (10MHz @ 40MIPS, Doesn't work.  CLKRDY is incorrectly reported as being clear.  Problem caused by dsPIC33/PIC24H ES silicon bug.) 
....................     #elif defined(__PIC24F__) || defined(__PIC24FK__) 
....................         ENC_SPICON1 = 0x1B;     // 1:1 primary prescale, 2:1 secondary prescale (8MHz  @ 16MIPS) 
....................     #else   // dsPIC30F 
....................         ENC_SPICON1 = 0x17;     // 1:1 primary prescale, 3:1 secondary prescale (10MHz @ 30MIPS) 
....................     #endif 
....................     ENC_SPICON2 = 0; 
....................     ENC_SPICON1bits.CKE = 1; 
....................     ENC_SPICON1bits.MSTEN = 1; 
....................     ENC_SPISTATbits.SPIEN = 1; 
.................... #elif defined(__C32__) 
....................     ENC_SPIBRG = (GetPeripheralClock()-1ul)/2ul/ENC_MAX_SPI_FREQ; 
....................    ENC_SPICON1bits.SMP = 1;   // Delay SDI input sampling (PIC perspective) by 1/2 SPI clock 
....................     ENC_SPICON1bits.CKE = 1; 
....................     ENC_SPICON1bits.MSTEN = 1; 
....................     ENC_SPICON1bits.ON = 1; 
.................... #endif 
....................  
....................     // RESET the entire ENC28J60, clearing all registers 
....................     // Also wait for CLKRDY to become set. 
....................     // Bit 3 in ESTAT is an unimplemented bit.  If it reads out as '1' that 
....................     // means the part is in RESET or there is something wrong with the SPI 
....................     // connection.  This loop makes sure that we can communicate with the 
....................     // ENC28J60 before proceeding. 
....................     do 
....................     { 
....................         SendSystemReset(); 
00ADC:  BRA    08E2
....................         i = ReadETHReg(ESTAT).Val; 
00ADE:  MOVLW  1D
00AE0:  MOVLB  2
00AE2:  MOVWF  xBC
00AE4:  MOVLB  0
00AE6:  RCALL  091A
00AE8:  MOVFF  01,16C
....................     } while((i & 0x08) || (~i & ESTAT_CLKRDY)); 
00AEC:  MOVLB  1
00AEE:  BTFSS  x6C.3
00AF0:  BRA    0AF6
00AF2:  MOVLB  0
00AF4:  BRA    0ADC
00AF6:  MOVF   x6C,W
00AF8:  XORLW  FF
00AFA:  ANDLW  01
00AFC:  BTFSC  FD8.2
00AFE:  BRA    0B04
00B00:  MOVLB  0
00B02:  BRA    0ADC
....................  
....................     // Start up in Bank 0 and configure the receive buffer boundary pointers 
....................     // and the buffer write protect pointer (receive buffer read pointer) 
....................     WasDiscarded = TRUE; 
00B04:  BSF    67.1
....................     NextPacketLocation.Val = RXSTART; 
00B06:  CLRF   7B
00B08:  CLRF   7A
....................  
....................     WriteReg(ERXSTL, LOW(RXSTART)); 
00B0A:  MOVLW  08
00B0C:  MOVLB  2
00B0E:  MOVWF  xC1
00B10:  CLRF   xC2
00B12:  MOVLB  0
00B14:  RCALL  0944
....................     WriteReg(ERXSTH, HIGH(RXSTART)); 
00B16:  MOVLW  09
00B18:  MOVLB  2
00B1A:  MOVWF  xC1
00B1C:  CLRF   xC2
00B1E:  MOVLB  0
00B20:  RCALL  0944
....................     WriteReg(ERXRDPTL, LOW(RXSTOP));    // Write low byte first 
00B22:  MOVLW  0C
00B24:  MOVLB  2
00B26:  MOVWF  xC1
00B28:  MOVLW  09
00B2A:  MOVWF  xC2
00B2C:  MOVLB  0
00B2E:  RCALL  0944
....................     WriteReg(ERXRDPTH, HIGH(RXSTOP));   // Write high byte last 
00B30:  MOVLW  0D
00B32:  MOVLB  2
00B34:  MOVWF  xC1
00B36:  MOVLW  15
00B38:  MOVWF  xC2
00B3A:  MOVLB  0
00B3C:  RCALL  0944
....................     WriteReg(ERXNDL, LOW(RXSTOP)); 
00B3E:  MOVLW  0A
00B40:  MOVLB  2
00B42:  MOVWF  xC1
00B44:  MOVLW  09
00B46:  MOVWF  xC2
00B48:  MOVLB  0
00B4A:  RCALL  0944
....................     WriteReg(ERXNDH, HIGH(RXSTOP)); 
00B4C:  MOVLW  0B
00B4E:  MOVLB  2
00B50:  MOVWF  xC1
00B52:  MOVLW  15
00B54:  MOVWF  xC2
00B56:  MOVLB  0
00B58:  RCALL  0944
....................     WriteReg(ETXSTL, LOW(TXSTART)); 
00B5A:  MOVLW  04
00B5C:  MOVLB  2
00B5E:  MOVWF  xC1
00B60:  MOVLW  0A
00B62:  MOVWF  xC2
00B64:  MOVLB  0
00B66:  RCALL  0944
....................     WriteReg(ETXSTH, HIGH(TXSTART)); 
00B68:  MOVLW  05
00B6A:  MOVLB  2
00B6C:  MOVWF  xC1
00B6E:  MOVLW  15
00B70:  MOVWF  xC2
00B72:  MOVLB  0
00B74:  RCALL  0944
....................  
....................     // Write a permanant per packet control byte of 0x00 
....................     WriteReg(EWRPTL, LOW(TXSTART)); 
00B76:  MOVLW  02
00B78:  MOVLB  2
00B7A:  MOVWF  xC1
00B7C:  MOVLW  0A
00B7E:  MOVWF  xC2
00B80:  MOVLB  0
00B82:  RCALL  0944
....................     WriteReg(EWRPTH, HIGH(TXSTART)); 
00B84:  MOVLW  03
00B86:  MOVLB  2
00B88:  MOVWF  xC1
00B8A:  MOVLW  15
00B8C:  MOVWF  xC2
00B8E:  MOVLB  0
00B90:  RCALL  0944
....................     MACPut(0x00); 
00B92:  MOVLB  2
00B94:  CLRF   xBF
00B96:  MOVLB  0
00B98:  RCALL  096E
....................  
....................  
....................     // Enter Bank 1 and configure Receive Filters 
....................     // (No need to reconfigure - Unicast OR Broadcast with CRC checking is 
....................     // acceptable) 
....................     // Write ERXFCON_CRCEN only to ERXFCON to enter promiscuous mode 
....................  
....................     // Promiscious mode example: 
....................     //BankSel(ERXFCON); 
....................     //WriteReg((BYTE)ERXFCON, ERXFCON_CRCEN); 
....................  
....................     // Enter Bank 2 and configure the MAC 
....................     BankSel(MACON1); 
00B9A:  MOVLW  02
00B9C:  MOVLB  2
00B9E:  MOVWF  xA1
00BA0:  CLRF   xA0
00BA2:  MOVLB  0
00BA4:  RCALL  09BC
....................  
....................     // Enable the receive portion of the MAC 
....................     WriteReg((BYTE)MACON1, MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN); 
00BA6:  MOVLB  2
00BA8:  CLRF   xC1
00BAA:  MOVLW  0D
00BAC:  MOVWF  xC2
00BAE:  MOVLB  0
00BB0:  RCALL  0944
....................  
....................     // Pad packets to 60 bytes, add CRC, and check Type/Length field. 
.................... #if defined(FULL_DUPLEX) 
....................     WriteReg((BYTE)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN | MACON3_FULDPX); 
....................     WriteReg((BYTE)MABBIPG, 0x15); 
.................... #else 
....................     WriteReg((BYTE)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN); 
00BB2:  MOVLW  02
00BB4:  MOVLB  2
00BB6:  MOVWF  xC1
00BB8:  MOVLW  32
00BBA:  MOVWF  xC2
00BBC:  MOVLB  0
00BBE:  RCALL  0944
....................     WriteReg((BYTE)MABBIPG, 0x12); 
00BC0:  MOVLW  04
00BC2:  MOVLB  2
00BC4:  MOVWF  xC1
00BC6:  MOVLW  12
00BC8:  MOVWF  xC2
00BCA:  MOVLB  0
00BCC:  RCALL  0944
.................... #endif 
....................  
....................     // Allow infinite deferals if the medium is continuously busy 
....................     // (do not time out a transmission if the half duplex medium is 
....................     // completely saturated with other people's data) 
....................     WriteReg((BYTE)MACON4, MACON4_DEFER); 
00BCE:  MOVLW  03
00BD0:  MOVLB  2
00BD2:  MOVWF  xC1
00BD4:  MOVLW  40
00BD6:  MOVWF  xC2
00BD8:  MOVLB  0
00BDA:  RCALL  0944
....................  
....................     // Late collisions occur beyond 63+8 bytes (8 bytes for preamble/start of frame delimiter) 
....................     // 55 is all that is needed for IEEE 802.3, but ENC28J60 B5 errata for improper link pulse 
....................     // collisions will occur less often with a larger number. 
....................     WriteReg((BYTE)MACLCON2, 63); 
00BDC:  MOVLW  09
00BDE:  MOVLB  2
00BE0:  MOVWF  xC1
00BE2:  MOVLW  3F
00BE4:  MOVWF  xC2
00BE6:  MOVLB  0
00BE8:  RCALL  0944
....................  
....................     // Set non-back-to-back inter-packet gap to 9.6us.  The back-to-back 
....................     // inter-packet gap (MABBIPG) is set by MACSetDuplex() which is called 
....................     // later. 
....................     WriteReg((BYTE)MAIPGL, 0x12); 
00BEA:  MOVLW  06
00BEC:  MOVLB  2
00BEE:  MOVWF  xC1
00BF0:  MOVLW  12
00BF2:  MOVWF  xC2
00BF4:  MOVLB  0
00BF6:  RCALL  0944
....................     WriteReg((BYTE)MAIPGH, 0x0C); 
00BF8:  MOVLW  07
00BFA:  MOVLB  2
00BFC:  MOVWF  xC1
00BFE:  MOVLW  0C
00C00:  MOVWF  xC2
00C02:  MOVLB  0
00C04:  RCALL  0944
....................  
....................     // Set the maximum packet size which the controller will accept 
....................     WriteReg((BYTE)MAMXFLL, LOW(6+6+2+1500+4));  // 1518 is the IEEE 802.3 specified limit 
00C06:  MOVLW  0A
00C08:  MOVLB  2
00C0A:  MOVWF  xC1
00C0C:  MOVLW  EE
00C0E:  MOVWF  xC2
00C10:  MOVLB  0
00C12:  RCALL  0944
....................     WriteReg((BYTE)MAMXFLH, HIGH(6+6+2+1500+4)); // 1518 is the IEEE 802.3 specified limit 
00C14:  MOVLW  0B
00C16:  MOVLB  2
00C18:  MOVWF  xC1
00C1A:  MOVLW  05
00C1C:  MOVWF  xC2
00C1E:  MOVLB  0
00C20:  RCALL  0944
....................  
....................     // Enter Bank 3 and initialize physical MAC address registers 
....................     BankSel(MAADR1); 
00C22:  MOVLW  03
00C24:  MOVLB  2
00C26:  MOVWF  xA1
00C28:  MOVLW  04
00C2A:  MOVWF  xA0
00C2C:  MOVLB  0
00C2E:  RCALL  09BC
....................     WriteReg((BYTE)MAADR1, AppConfig.MyMACAddr.v[0]); 
00C30:  MOVLW  04
00C32:  MOVLB  2
00C34:  MOVWF  xC1
00C36:  MOVFF  56,2C2
00C3A:  MOVLB  0
00C3C:  RCALL  0944
....................     WriteReg((BYTE)MAADR2, AppConfig.MyMACAddr.v[1]); 
00C3E:  MOVLW  05
00C40:  MOVLB  2
00C42:  MOVWF  xC1
00C44:  MOVFF  57,2C2
00C48:  MOVLB  0
00C4A:  RCALL  0944
....................     WriteReg((BYTE)MAADR3, AppConfig.MyMACAddr.v[2]); 
00C4C:  MOVLW  02
00C4E:  MOVLB  2
00C50:  MOVWF  xC1
00C52:  MOVFF  58,2C2
00C56:  MOVLB  0
00C58:  RCALL  0944
....................     WriteReg((BYTE)MAADR4, AppConfig.MyMACAddr.v[3]); 
00C5A:  MOVLW  03
00C5C:  MOVLB  2
00C5E:  MOVWF  xC1
00C60:  MOVFF  59,2C2
00C64:  MOVLB  0
00C66:  RCALL  0944
....................     WriteReg((BYTE)MAADR5, AppConfig.MyMACAddr.v[4]); 
00C68:  MOVLB  2
00C6A:  CLRF   xC1
00C6C:  MOVFF  5A,2C2
00C70:  MOVLB  0
00C72:  RCALL  0944
....................     WriteReg((BYTE)MAADR6, AppConfig.MyMACAddr.v[5]); 
00C74:  MOVLW  01
00C76:  MOVLB  2
00C78:  MOVWF  xC1
00C7A:  MOVFF  5B,2C2
00C7E:  MOVLB  0
00C80:  RCALL  0944
....................  
....................     // Disable the CLKOUT output to reduce EMI generation 
....................     WriteReg((BYTE)ECOCON, 0x00);   // Output off (0V) 
00C82:  MOVLW  15
00C84:  MOVLB  2
00C86:  MOVWF  xC1
00C88:  CLRF   xC2
00C8A:  MOVLB  0
00C8C:  RCALL  0944
....................     //WriteReg((BYTE)ECOCON, 0x01); // 25.000MHz 
....................     //WriteReg((BYTE)ECOCON, 0x03); // 8.3333MHz (*4 with PLL is 33.3333MHz) 
....................  
....................     // Get the Rev ID so that we can implement the correct errata workarounds 
....................     ENCRevID = ReadETHReg((BYTE)EREVID).Val; 
00C8E:  MOVLW  12
00C90:  MOVLB  2
00C92:  MOVWF  xBC
00C94:  MOVLB  0
00C96:  RCALL  091A
00C98:  MOVFF  01,7E
....................  
....................     // Disable half duplex loopback in PHY.  Bank bits changed to Bank 2 as a 
....................     // side effect. 
....................     WritePHYReg(PHCON2, PHCON2_HDLDIS); 
00C9C:  MOVLW  10
00C9E:  MOVLB  1
00CA0:  MOVWF  x6D
00CA2:  MOVLW  01
00CA4:  MOVWF  x6F
00CA6:  CLRF   x6E
00CA8:  MOVLB  0
00CAA:  RCALL  0A28
....................  
....................     // Configure LEDA to display LINK status, LEDB to display TX/RX activity 
....................     SetLEDConfig(0x3472); 
00CAC:  MOVLW  14
00CAE:  MOVLB  1
00CB0:  MOVWF  x6D
00CB2:  MOVLW  34
00CB4:  MOVWF  x6F
00CB6:  MOVLW  72
00CB8:  MOVWF  x6E
00CBA:  MOVLB  0
00CBC:  RCALL  0A28
....................  
....................     // Set the MAC and PHY into the proper duplex state 
.................... #if defined(FULL_DUPLEX) 
....................     WritePHYReg(PHCON1, PHCON1_PDPXMD); 
.................... #elif defined(HALF_DUPLEX) 
....................     WritePHYReg(PHCON1, 0x0000); 
00CBE:  MOVLB  1
00CC0:  CLRF   x6D
00CC2:  CLRF   x6F
00CC4:  CLRF   x6E
00CC6:  MOVLB  0
00CC8:  RCALL  0A28
.................... #else 
....................     // Use the external LEDB polarity to determine weather full or half duplex 
....................     // communication mode should be set. 
....................     { 
....................         REG Register; 
....................         PHYREG PhyReg; 
....................  
....................         // Read the PHY duplex mode 
....................         PhyReg = ReadPHYReg(PHCON1); 
....................         DuplexState = PhyReg.PHCON1bits.PDPXMD; 
....................  
....................         // Set the MAC to the proper duplex mode 
....................         BankSel(MACON3); 
....................         Register = ReadMACReg((BYTE)MACON3); 
....................         Register.MACON3bits.FULDPX = PhyReg.PHCON1bits.PDPXMD; 
....................         WriteReg((BYTE)MACON3, Register.Val); 
....................  
....................         // Set the back-to-back inter-packet gap time to IEEE specified 
....................         // requirements.  The meaning of the MABBIPG value changes with the duplex 
....................         // state, so it must be updated in this function. 
....................         // In full duplex, 0x15 represents 9.6us; 0x12 is 9.6us in half duplex 
....................         WriteReg((BYTE)MABBIPG, PhyReg.PHCON1bits.PDPXMD ? 0x15 : 0x12); 
....................     } 
.................... #endif 
....................  
....................     BankSel(ERDPTL);        // Return to default Bank 0 
00CCA:  MOVLB  2
00CCC:  CLRF   xA1
00CCE:  CLRF   xA0
00CD0:  MOVLB  0
00CD2:  RCALL  09BC
....................  
....................     // Enable packet reception 
....................     BFSReg(ECON1, ECON1_RXEN); 
00CD4:  MOVLW  1F
00CD6:  MOVLB  2
00CD8:  MOVWF  xB6
00CDA:  MOVLW  04
00CDC:  MOVWF  xB7
00CDE:  MOVLB  0
00CE0:  RCALL  0992
00CE2:  GOTO   1682 (RETURN)
.................... }//end MACInit 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsLinked(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: If the PHY reports that a link partner is present 
....................  *                        and the link has been up continuously since the last 
....................  *                        call to MACIsLinked() 
....................  *                  FALSE: If the PHY reports no link partner, or the link went 
....................  *                         down momentarily since the last call to MACIsLinked() 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the PHSTAT1.LLSTAT bit. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsLinked(void) 
.................... { 
....................     // LLSTAT is a latching low link status bit.  Therefore, if the link 
....................     // goes down and comes back up before a higher level stack program calls 
....................     // MACIsLinked(), MACIsLinked() will still return FALSE.  The next 
....................     // call to MACIsLinked() will return TRUE (unless the link goes down 
....................     // again). 
....................     return ReadPHYReg(PHSTAT1).PHSTAT1bits.LLSTAT; 
*
01748:  MOVLW  01
0174A:  MOVLB  1
0174C:  MOVWF  x6C
0174E:  MOVLB  0
01750:  BRA    168C
01752:  MOVFF  01,16C
01756:  MOVLW  00
01758:  MOVLB  1
0175A:  BTFSC  01.2
0175C:  MOVLW  01
0175E:  MOVWF  01
01760:  MOVLB  0
01762:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsTxReady(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: If no Ethernet transmission is in progress 
....................  *                  FALSE: If a previous transmission was started, and it has 
....................  *                         not completed yet.  While FALSE, the data in the 
....................  *                         transmit buffer and the TXST/TXND pointers must not 
....................  *                         be changed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the ECON1.TXRTS bit 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsTxReady(void) 
.................... { 
....................     return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
*
01A1C:  MOVLW  1F
01A1E:  MOVLB  2
01A20:  MOVWF  xBC
01A22:  MOVLB  0
01A24:  CALL   091A
01A28:  MOVFF  01,29C
01A2C:  MOVLW  00
01A2E:  MOVLB  2
01A30:  BTFSC  01.3
01A32:  MOVLW  01
01A34:  XORLW  00
01A36:  BZ    1A3C
01A38:  MOVLW  00
01A3A:  BRA    1A3E
01A3C:  MOVLW  01
01A3E:  MOVWF  01
01A40:  MOVLB  0
01A42:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDiscardRx(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Marks the last received packet (obtained using 
....................  *                  MACGetHeader())as being processed and frees the buffer 
....................  *                  memory associated with it 
....................  * 
....................  * Note:            Is is safe to call this function multiple times between 
....................  *                  MACGetHeader() calls.  Extra packets won't be thrown away 
....................  *                  until MACGetHeader() makes it available. 
....................  *****************************************************************************/ 
.................... void MACDiscardRx(void) 
.................... { 
....................     WORD_VAL NewRXRDLocation; 
....................  
....................     // Make sure the current packet was not already discarded 
....................     if(WasDiscarded) 
*
039F6:  BTFSS  67.1
039F8:  BRA    39FC
....................         return; 
039FA:  BRA    3A54
....................     WasDiscarded = TRUE; 
039FC:  BSF    67.1
....................  
....................     // Decrement the next packet pointer before writing it into 
....................     // the ERXRDPT registers.  This is a silicon errata workaround. 
....................     // RX buffer wrapping must be taken into account if the 
....................     // NextPacketLocation is precisely RXSTART. 
....................     NewRXRDLocation.Val = NextPacketLocation.Val - 1; 
039FE:  MOVLW  01
03A00:  SUBWF  7A,W
03A02:  MOVLB  1
03A04:  MOVWF  x9F
03A06:  MOVLW  00
03A08:  SUBWFB 7B,W
03A0A:  MOVWF  xA0
....................     if(NewRXRDLocation.Val > RXSTOP) 
03A0C:  MOVF   xA0,W
03A0E:  SUBLW  14
03A10:  BC    3A24
03A12:  XORLW  FF
03A14:  BNZ   3A1C
03A16:  MOVF   x9F,W
03A18:  SUBLW  09
03A1A:  BC    3A24
....................     { 
....................         NewRXRDLocation.Val = RXSTOP; 
03A1C:  MOVLW  15
03A1E:  MOVWF  xA0
03A20:  MOVLW  09
03A22:  MOVWF  x9F
....................     } 
....................  
....................     // Decrement the RX packet counter register, EPKTCNT 
....................     BFSReg(ECON2, ECON2_PKTDEC); 
03A24:  MOVLW  1E
03A26:  MOVLB  2
03A28:  MOVWF  xB6
03A2A:  MOVLW  40
03A2C:  MOVWF  xB7
03A2E:  MOVLB  0
03A30:  CALL   0992
....................  
....................     // Move the receive read pointer to unwrite-protect the memory used by the 
....................     // last packet.  The writing order is important: set the low byte first, 
....................     // high byte last. 
....................     WriteReg(ERXRDPTL, NewRXRDLocation.v[0]); 
03A34:  MOVLW  0C
03A36:  MOVLB  2
03A38:  MOVWF  xC1
03A3A:  MOVFF  19F,2C2
03A3E:  MOVLB  0
03A40:  CALL   0944
....................     WriteReg(ERXRDPTH, NewRXRDLocation.v[1]); 
03A44:  MOVLW  0D
03A46:  MOVLB  2
03A48:  MOVWF  xC1
03A4A:  MOVFF  1A0,2C2
03A4E:  MOVLB  0
03A50:  CALL   0944
03A54:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetFreeRxSize(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          A WORD estimate of how much RX buffer space is free at 
....................  *                  the present time. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetFreeRxSize(void) 
.................... { 
....................     WORD_VAL ReadPT, WritePT; 
....................  
....................     // Read the Ethernet hardware buffer write pointer.  Because packets can be 
....................     // received at any time, it can change between reading the low and high 
....................     // bytes.  A loop is necessary to make certain a proper low/high byte pair 
....................     // is read. 
....................     BankSel(EPKTCNT); 
*
01AE8:  MOVLW  01
01AEA:  MOVLB  2
01AEC:  MOVWF  xA1
01AEE:  MOVLW  19
01AF0:  MOVWF  xA0
01AF2:  MOVLB  0
01AF4:  CALL   09BC
....................     do { 
....................         // Save EPKTCNT in a temporary location 
....................         ReadPT.v[0] = ReadETHReg((BYTE)EPKTCNT).Val; 
01AF8:  MOVLW  19
01AFA:  MOVLB  2
01AFC:  MOVWF  xBC
01AFE:  MOVLB  0
01B00:  CALL   091A
01B04:  MOVFF  01,29C
....................  
....................         BankSel(ERXWRPTL); 
01B08:  MOVLB  2
01B0A:  CLRF   xA1
01B0C:  MOVLW  0E
01B0E:  MOVWF  xA0
01B10:  MOVLB  0
01B12:  CALL   09BC
....................         WritePT.v[0] = ReadETHReg(ERXWRPTL).Val; 
01B16:  MOVLW  0E
01B18:  MOVLB  2
01B1A:  MOVWF  xBC
01B1C:  MOVLB  0
01B1E:  CALL   091A
01B22:  MOVFF  01,29E
....................         WritePT.v[1] = ReadETHReg(ERXWRPTH).Val; 
01B26:  MOVLW  0F
01B28:  MOVLB  2
01B2A:  MOVWF  xBC
01B2C:  MOVLB  0
01B2E:  CALL   091A
01B32:  MOVFF  01,29F
....................  
....................         BankSel(EPKTCNT); 
01B36:  MOVLW  01
01B38:  MOVLB  2
01B3A:  MOVWF  xA1
01B3C:  MOVLW  19
01B3E:  MOVWF  xA0
01B40:  MOVLB  0
01B42:  CALL   09BC
....................     } while(ReadETHReg((BYTE)EPKTCNT).Val != ReadPT.v[0]); 
01B46:  MOVLW  19
01B48:  MOVLB  2
01B4A:  MOVWF  xBC
01B4C:  MOVLB  0
01B4E:  CALL   091A
01B52:  MOVFF  01,2A0
01B56:  MOVLB  2
01B58:  MOVF   x9C,W
01B5A:  SUBWF  01,W
01B5C:  BTFSC  FD8.2
01B5E:  BRA    1B64
01B60:  MOVLB  0
01B62:  BRA    1AF8
....................  
....................     // Determine where the write protection pointer is 
....................     BankSel(ERXRDPTL); 
01B64:  CLRF   xA1
01B66:  MOVLW  0C
01B68:  MOVWF  xA0
01B6A:  MOVLB  0
01B6C:  CALL   09BC
....................     ReadPT.v[0] = ReadETHReg(ERXRDPTL).Val; 
01B70:  MOVLW  0C
01B72:  MOVLB  2
01B74:  MOVWF  xBC
01B76:  MOVLB  0
01B78:  CALL   091A
01B7C:  MOVFF  01,29C
....................     ReadPT.v[1] = ReadETHReg(ERXRDPTH).Val; 
01B80:  MOVLW  0D
01B82:  MOVLB  2
01B84:  MOVWF  xBC
01B86:  MOVLB  0
01B88:  CALL   091A
01B8C:  MOVFF  01,29D
....................  
....................     // Calculate the difference between the pointers, taking care to account 
....................     // for buffer wrapping conditions 
....................     if(WritePT.Val > ReadPT.Val) 
01B90:  MOVLB  2
01B92:  MOVF   x9D,W
01B94:  SUBWF  x9F,W
01B96:  BNC   1BC4
01B98:  BNZ   1BA0
01B9A:  MOVF   x9E,W
01B9C:  SUBWF  x9C,W
01B9E:  BC    1BC4
....................     { 
....................         return (RXSTOP - RXSTART) - (WritePT.Val - ReadPT.Val); 
01BA0:  MOVF   x9C,W
01BA2:  SUBWF  x9E,W
01BA4:  MOVWF  00
01BA6:  MOVF   x9D,W
01BA8:  SUBWFB x9F,W
01BAA:  MOVWF  03
01BAC:  MOVF   00,W
01BAE:  XORLW  FF
01BB0:  ADDLW  0A
01BB2:  MOVWF  00
01BB4:  MOVLW  15
01BB6:  SUBFWB 03,F
01BB8:  MOVFF  00,01
01BBC:  MOVFF  03,02
01BC0:  BRA    1BFA
....................     } 
01BC2:  BRA    1BFA
....................     else if(WritePT.Val == ReadPT.Val) 
01BC4:  MOVF   x9C,W
01BC6:  SUBWF  x9E,W
01BC8:  BNZ   1BDC
01BCA:  MOVF   x9D,W
01BCC:  SUBWF  x9F,W
01BCE:  BNZ   1BDC
....................     { 
....................         return RXSIZE - 1; 
01BD0:  MOVLW  09
01BD2:  MOVWF  01
01BD4:  MOVLW  15
01BD6:  MOVWF  02
01BD8:  BRA    1BFA
....................     } 
01BDA:  BRA    1BFA
....................     else 
....................     { 
....................         return ReadPT.Val - WritePT.Val - 1; 
01BDC:  MOVF   x9E,W
01BDE:  SUBWF  x9C,W
01BE0:  MOVWF  xA0
01BE2:  MOVF   x9F,W
01BE4:  SUBWFB x9D,W
01BE6:  MOVWF  xA1
01BE8:  MOVLW  01
01BEA:  SUBWF  xA0,W
01BEC:  MOVWF  00
01BEE:  MOVLW  00
01BF0:  SUBWFB xA1,W
01BF2:  MOVWF  03
01BF4:  MOVFF  00,01
01BF8:  MOVWF  02
....................     } 
01BFA:  MOVLB  0
01BFC:  GOTO   2B4C (RETURN)
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           *remote: Location to store the Source MAC address of the 
....................  *                           received frame. 
....................  *                  *type: Location of a BYTE to store the constant 
....................  *                         MAC_UNKNOWN, ETHER_IP, or ETHER_ARP, representing 
....................  *                         the contents of the Ethernet type field. 
....................  * 
....................  * Output:          TRUE: If a packet was waiting in the RX buffer.  The 
....................  *                        remote, and type values are updated. 
....................  *                  FALSE: If a packet was not pending.  remote and type are 
....................  *                         not changed. 
....................  * 
....................  * Side Effects:    Last packet is discarded if MACDiscardRx() hasn't already 
....................  *                  been called. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
.................... { 
....................     ENC_PREAMBLE header; 
....................     BYTE PacketCount; 
....................  
....................     // Test if at least one packet has been received and is waiting 
....................     BankSel(EPKTCNT); 
*
03A56:  MOVLW  01
03A58:  MOVLB  2
03A5A:  MOVWF  xA1
03A5C:  MOVLW  19
03A5E:  MOVWF  xA0
03A60:  MOVLB  0
03A62:  CALL   09BC
....................     PacketCount = ReadETHReg((BYTE)EPKTCNT).Val; 
03A66:  MOVLW  19
03A68:  MOVLB  2
03A6A:  MOVWF  xBC
03A6C:  MOVLB  0
03A6E:  CALL   091A
03A72:  MOVFF  01,18C
....................     BankSel(ERDPTL); 
03A76:  MOVLB  2
03A78:  CLRF   xA1
03A7A:  CLRF   xA0
03A7C:  MOVLB  0
03A7E:  CALL   09BC
....................     if(PacketCount == 0u) 
03A82:  MOVLB  1
03A84:  MOVF   x8C,F
03A86:  BNZ   3A8E
....................         return FALSE; 
03A88:  MOVLW  00
03A8A:  MOVWF  01
03A8C:  BRA    3B9C
....................  
....................     // Make absolutely certain that any previous packet was discarded 
....................     if(WasDiscarded == FALSE) 
03A8E:  BTFSC  67.1
03A90:  BRA    3A9E
....................     { 
....................         MACDiscardRx(); 
03A92:  MOVLB  0
03A94:  RCALL  39F6
....................         return FALSE; 
03A96:  MOVLW  00
03A98:  MOVWF  01
03A9A:  MOVLB  1
03A9C:  BRA    3B9C
....................     } 
....................  
....................     // Set the SPI read pointer to the beginning of the next unprocessed packet 
....................     CurrentPacketLocation.Val = NextPacketLocation.Val; 
03A9E:  MOVFF  7B,7D
03AA2:  MOVFF  7A,7C
....................     WriteReg(ERDPTL, CurrentPacketLocation.v[0]); 
03AA6:  MOVLB  2
03AA8:  CLRF   xC1
03AAA:  MOVFF  7C,2C2
03AAE:  MOVLB  0
03AB0:  CALL   0944
....................     WriteReg(ERDPTH, CurrentPacketLocation.v[1]); 
03AB4:  MOVLW  01
03AB6:  MOVLB  2
03AB8:  MOVWF  xC1
03ABA:  MOVFF  7D,2C2
03ABE:  MOVLB  0
03AC0:  CALL   0944
....................  
....................     // Obtain the MAC header from the Ethernet buffer 
....................     MACGetArray((BYTE*)&header, sizeof(header)); 
03AC4:  MOVLW  01
03AC6:  MOVLB  1
03AC8:  MOVWF  x8E
03ACA:  MOVLW  78
03ACC:  MOVWF  x8D
03ACE:  MOVFF  18E,2BF
03AD2:  MOVFF  FE8,2BE
03AD6:  MOVLB  2
03AD8:  CLRF   xC1
03ADA:  MOVLW  14
03ADC:  MOVWF  xC0
03ADE:  MOVLB  0
03AE0:  CALL   0EDC
....................  
....................     // The EtherType field, like most items transmitted on the Ethernet medium 
....................     // are in big endian. 
....................     header.Type.Val = swaps(header.Type.Val); 
03AE4:  MOVFF  18B,2BC
03AE8:  MOVFF  18A,2BB
03AEC:  CALL   1C00
03AF0:  MOVFF  02,18B
03AF4:  MOVFF  01,18A
....................  
....................     // Validate the data returned from the ENC28J60.  Random data corruption, 
....................     // such as if a single SPI bit error occurs while communicating or a 
....................     // momentary power glitch could cause this to occur in rare circumstances. 
....................     if(header.NextPacketPointer > RXSTOP || ((BYTE_VAL*)(&header.NextPacketPointer))->bits.b0 || 
....................        header.StatusVector.bits.Zero || 
....................        header.StatusVector.bits.CRCError || 
....................        header.StatusVector.bits.ByteCount > 1518u || 
....................        !header.StatusVector.bits.ReceiveOk) 
03AF8:  MOVLB  1
03AFA:  MOVF   x79,W
03AFC:  SUBLW  14
03AFE:  BC    3B0A
03B00:  XORLW  FF
03B02:  BNZ   3B36
03B04:  MOVF   x78,W
03B06:  SUBLW  09
03B08:  BNC   3B36
03B0A:  MOVLW  01
03B0C:  MOVWF  x8E
03B0E:  MOVLW  78
03B10:  MOVWF  FE9
03B12:  MOVFF  18E,FEA
03B16:  BTFSC  FEF.0
03B18:  BRA    3B36
03B1A:  BTFSC  x7D.7
03B1C:  BRA    3B36
03B1E:  BTFSC  x7C.4
03B20:  BRA    3B36
03B22:  MOVF   x7B,W
03B24:  SUBLW  04
03B26:  BC    3B32
03B28:  XORLW  FF
03B2A:  BNZ   3B36
03B2C:  MOVF   x7A,W
03B2E:  SUBLW  EE
03B30:  BNC   3B36
03B32:  BTFSC  x7C.7
03B34:  BRA    3B38
....................     { 
....................         Reset(); 
03B36:  RESET
....................     } 
....................  
....................     // Save the location where the hardware will write the next packet to 
....................     NextPacketLocation.Val = header.NextPacketPointer; 
03B38:  MOVFF  179,7B
03B3C:  MOVFF  178,7A
....................  
....................     // Return the Ethernet frame's Source MAC address field to the caller 
....................     // This parameter is useful for replying to requests without requiring an 
....................     // ARP cycle. 
....................     memcpy((void*)remote->v, (void*)header.SourceMACAddr.v, sizeof(*remote)); 
03B40:  MOVFF  175,03
03B44:  MOVFF  174,18D
03B48:  MOVFF  175,18E
03B4C:  MOVLW  01
03B4E:  MOVWF  x90
03B50:  MOVLW  84
03B52:  MOVFF  175,FEA
03B56:  MOVFF  174,FE9
03B5A:  MOVFF  190,FE2
03B5E:  MOVWF  FE1
03B60:  MOVLW  06
03B62:  MOVWF  01
03B64:  MOVFF  FE6,FEE
03B68:  DECFSZ 01,F
03B6A:  BRA    3B64
....................  
....................     // Return a simplified version of the EtherType field to the caller 
....................     *type = MAC_UNKNOWN; 
03B6C:  MOVFF  177,03
03B70:  MOVFF  176,FE9
03B74:  MOVFF  03,FEA
03B78:  SETF   FEF
....................     if( (header.Type.v[1] == 0x08u) && 
....................         ((header.Type.v[0] == ETHER_IP) || (header.Type.v[0] == ETHER_ARP)) ) 
03B7A:  MOVF   x8B,W
03B7C:  SUBLW  08
03B7E:  BNZ   3B96
03B80:  MOVF   x8A,F
03B82:  BZ    3B8A
03B84:  MOVF   x8A,W
03B86:  SUBLW  06
03B88:  BNZ   3B96
....................     { 
....................         *type = header.Type.v[0]; 
03B8A:  MOVFF  176,FE9
03B8E:  MOVFF  177,FEA
03B92:  MOVFF  18A,FEF
....................     } 
....................  
....................     // Mark this packet as discardable 
....................     WasDiscarded = FALSE; 
03B96:  BCF    67.1
....................     return TRUE; 
03B98:  MOVLW  01
03B9A:  MOVWF  01
03B9C:  MOVLB  0
03B9E:  GOTO   59E4 (RETURN)
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen) 
....................  * 
....................  * PreCondition:    MACIsTxReady() must return TRUE. 
....................  * 
....................  * Input:           *remote: Pointer to memory which contains the destination 
....................  *                           MAC address (6 bytes) 
....................  *                  type: The constant ETHER_ARP or ETHER_IP, defining which 
....................  *                        value to write into the Ethernet header's type field. 
....................  *                  dataLen: Length of the Ethernet data payload 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Because of the dataLen parameter, it is probably 
....................  *                  advantagous to call this function immediately before 
....................  *                  transmitting a packet rather than initially when the 
....................  *                  packet is first created.  The order in which the packet 
....................  *                  is constructed (header first or data first) is not 
....................  *                  important. 
....................  *****************************************************************************/ 
.................... void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen) 
.................... { 
....................     // Set the SPI write pointer to the beginning of the transmit buffer (post per packet control byte) 
....................     WriteReg(EWRPTL, LOW(TXSTART+1)); 
*
02176:  MOVLW  02
02178:  MOVLB  2
0217A:  MOVWF  xC1
0217C:  MOVLW  0B
0217E:  MOVWF  xC2
02180:  MOVLB  0
02182:  CALL   0944
....................     WriteReg(EWRPTH, HIGH(TXSTART+1)); 
02186:  MOVLW  03
02188:  MOVLB  2
0218A:  MOVWF  xC1
0218C:  MOVLW  15
0218E:  MOVWF  xC2
02190:  MOVLB  0
02192:  CALL   0944
....................  
....................     // Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TXSTART; 
02196:  MOVLW  18
02198:  MOVLB  2
0219A:  ADDWF  xBC,F
0219C:  MOVLW  15
0219E:  ADDWFC xBD,F
....................  
....................     // Write the TXND pointer into the registers, given the dataLen given 
....................     WriteReg(ETXNDL, ((WORD_VAL*)&dataLen)->v[0]); 
021A0:  MOVLW  02
021A2:  MOVWF  xBF
021A4:  MOVLW  BC
021A6:  MOVWF  xBE
021A8:  MOVWF  FE9
021AA:  MOVFF  2BF,FEA
021AE:  MOVFF  FEF,2C0
021B2:  MOVLW  06
021B4:  MOVWF  xC1
021B6:  MOVFF  2C0,2C2
021BA:  MOVLB  0
021BC:  CALL   0944
....................     WriteReg(ETXNDH, ((WORD_VAL*)&dataLen)->v[1]); 
021C0:  MOVLW  02
021C2:  MOVLB  2
021C4:  MOVWF  xBF
021C6:  MOVLW  BC
021C8:  MOVWF  xBE
021CA:  MOVLW  01
021CC:  ADDWF  xBE,W
021CE:  MOVWF  FE9
021D0:  MOVLW  00
021D2:  ADDWFC xBF,W
021D4:  MOVWF  FEA
021D6:  MOVFF  FEF,2C0
021DA:  MOVLW  07
021DC:  MOVWF  xC1
021DE:  MOVFF  2C0,2C2
021E2:  MOVLB  0
021E4:  CALL   0944
....................  
....................     // Set the per-packet control byte and write the Ethernet destination 
....................     // address 
....................     MACPutArray((BYTE*)remote, sizeof(*remote)); 
021E8:  MOVFF  2BA,2C1
021EC:  MOVFF  2B9,2C0
021F0:  MOVLB  2
021F2:  CLRF   xC3
021F4:  MOVLW  06
021F6:  MOVWF  xC2
021F8:  MOVLB  0
021FA:  CALL   0E2A
....................  
....................     // Write our MAC address in the Ethernet source field 
....................     MACPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr)); 
021FE:  MOVLB  2
02200:  CLRF   xBF
02202:  MOVLW  56
02204:  MOVWF  xBE
02206:  MOVFF  2BF,2C1
0220A:  MOVWF  xC0
0220C:  CLRF   xC3
0220E:  MOVLW  06
02210:  MOVWF  xC2
02212:  MOVLB  0
02214:  CALL   0E2A
....................  
....................     // Write the appropriate Ethernet Type WORD for the protocol being used 
....................     MACPut(0x08); 
02218:  MOVLW  08
0221A:  MOVLB  2
0221C:  MOVWF  xBF
0221E:  MOVLB  0
02220:  CALL   096E
....................     MACPut((type == MAC_IP) ? ETHER_IP : ETHER_ARP); 
02224:  MOVLB  2
02226:  MOVF   xBB,F
02228:  BNZ   222E
0222A:  MOVLW  00
0222C:  BRA    2230
0222E:  MOVLW  06
02230:  MOVWF  xBE
02232:  MOVWF  xBF
02234:  MOVLB  0
02236:  CALL   096E
0223A:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACFlush(void) 
....................  * 
....................  * PreCondition:    A packet has been created by calling MACPut() and 
....................  *                  MACPutHeader(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACFlush causes the current TX packet to be sent out on 
....................  *                  the Ethernet medium.  The hardware MAC will take control 
....................  *                  and handle CRC generation, collision retransmission and 
....................  *                  other details. 
....................  * 
....................  * Note:            After transmission completes (MACIsTxReady() returns TRUE), 
....................  *                  the packet can be modified and transmitted again by calling 
....................  *                  MACFlush() again.  Until MACPutHeader() or MACPut() is 
....................  *                  called (in the TX data area), the data in the TX buffer 
....................  *                  will not be corrupted. 
....................  *****************************************************************************/ 
.................... void MACFlush(void) 
.................... { 
....................     // Reset transmit logic if a TX Error has previously occured 
....................     // This is a silicon errata workaround 
....................     BFSReg(ECON1, ECON1_TXRST); 
*
0246E:  MOVLW  1F
02470:  MOVLB  2
02472:  MOVWF  xB6
02474:  MOVLW  80
02476:  MOVWF  xB7
02478:  MOVLB  0
0247A:  CALL   0992
....................     BFCReg(ECON1, ECON1_TXRST); 
0247E:  MOVLW  1F
02480:  MOVLB  2
02482:  MOVWF  xB6
02484:  MOVLW  80
02486:  MOVWF  xB7
02488:  MOVLB  0
0248A:  CALL   08B8
....................     BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
0248E:  MOVLW  1C
02490:  MOVLB  2
02492:  MOVWF  xB6
02494:  MOVLW  0A
02496:  MOVWF  xB7
02498:  MOVLB  0
0249A:  CALL   08B8
....................  
....................     // Start the transmission 
....................     // After transmission completes (MACIsTxReady() returns TRUE), the packet 
....................     // can be modified and transmitted again by calling MACFlush() again. 
....................     // Until MACPutHeader() is called, the data in the TX buffer will not be 
....................     // corrupted. 
....................     BFSReg(ECON1, ECON1_TXRTS); 
0249E:  MOVLW  1F
024A0:  MOVLB  2
024A2:  MOVWF  xB6
024A4:  MOVLW  08
024A6:  MOVWF  xB7
024A8:  MOVLB  0
024AA:  CALL   0992
....................  
....................     // Revision B5 and B7 silicon errata workaround 
....................     if(ENCRevID == 0x05u || ENCRevID == 0x06u) 
024AE:  MOVF   7E,W
024B0:  SUBLW  05
024B2:  BZ    24BC
024B4:  MOVF   7E,W
024B6:  SUBLW  06
024B8:  BTFSS  FD8.2
024BA:  BRA    269C
....................     { 
....................         WORD AttemptCounter = 0x0000; 
024BC:  MOVLB  2
024BE:  CLRF   x9D
024C0:  CLRF   x9C
....................         while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF)) && (++AttemptCounter < 1000u)); 
024C2:  MOVLW  1C
024C4:  MOVWF  xBC
024C6:  MOVLB  0
024C8:  CALL   091A
024CC:  MOVFF  01,2AA
024D0:  MOVLB  2
024D2:  MOVF   01,W
024D4:  ANDLW  0A
024D6:  BNZ   24EC
024D8:  INCF   x9C,F
024DA:  BTFSC  FD8.2
024DC:  INCF   x9D,F
024DE:  MOVF   x9D,W
024E0:  SUBLW  03
024E2:  BNC   24EC
024E4:  BNZ   24C2
024E6:  MOVF   x9C,W
024E8:  SUBLW  E7
024EA:  BC    24C2
....................         if(ReadETHReg(EIR).EIRbits.TXERIF || (AttemptCounter >= 1000u)) 
024EC:  MOVLW  1C
024EE:  MOVWF  xBC
024F0:  MOVLB  0
024F2:  CALL   091A
024F6:  MOVFF  01,2AA
024FA:  MOVLW  00
024FC:  MOVLB  2
024FE:  BTFSC  01.1
02500:  MOVLW  01
02502:  XORLW  00
02504:  BNZ   251A
02506:  MOVF   x9D,W
02508:  SUBLW  02
0250A:  BTFSC  FD8.0
0250C:  BRA    269E
0250E:  XORLW  FF
02510:  BNZ   251A
02512:  MOVF   x9C,W
02514:  SUBLW  E7
02516:  BTFSC  FD8.0
02518:  BRA    269E
....................         { 
....................             WORD_VAL ReadPtrSave; 
....................             WORD_VAL TXEnd; 
....................             TXSTATUS TXStatus; 
....................             BYTE i; 
....................  
....................             // Cancel the previous transmission if it has become stuck set 
....................             BFCReg(ECON1, ECON1_TXRTS); 
0251A:  MOVLW  1F
0251C:  MOVWF  xB6
0251E:  MOVLW  08
02520:  MOVWF  xB7
02522:  MOVLB  0
02524:  CALL   08B8
....................  
....................             // Save the current read pointer (controlled by application) 
....................             ReadPtrSave.v[0] = ReadETHReg(ERDPTL).Val; 
02528:  MOVLB  2
0252A:  CLRF   xBC
0252C:  MOVLB  0
0252E:  CALL   091A
02532:  MOVFF  01,29E
....................             ReadPtrSave.v[1] = ReadETHReg(ERDPTH).Val; 
02536:  MOVLW  01
02538:  MOVLB  2
0253A:  MOVWF  xBC
0253C:  MOVLB  0
0253E:  CALL   091A
02542:  MOVFF  01,29F
....................  
....................             // Get the location of the transmit status vector 
....................             TXEnd.v[0] = ReadETHReg(ETXNDL).Val; 
02546:  MOVLW  06
02548:  MOVLB  2
0254A:  MOVWF  xBC
0254C:  MOVLB  0
0254E:  CALL   091A
02552:  MOVFF  01,2A0
....................             TXEnd.v[1] = ReadETHReg(ETXNDH).Val; 
02556:  MOVLW  07
02558:  MOVLB  2
0255A:  MOVWF  xBC
0255C:  MOVLB  0
0255E:  CALL   091A
02562:  MOVFF  01,2A1
....................             TXEnd.Val++; 
02566:  MOVLB  2
02568:  INCF   xA0,F
0256A:  BTFSC  FD8.2
0256C:  INCF   xA1,F
....................  
....................             // Read the transmit status vector 
....................             WriteReg(ERDPTL, TXEnd.v[0]); 
0256E:  CLRF   xC1
02570:  MOVFF  2A0,2C2
02574:  MOVLB  0
02576:  CALL   0944
....................             WriteReg(ERDPTH, TXEnd.v[1]); 
0257A:  MOVLW  01
0257C:  MOVLB  2
0257E:  MOVWF  xC1
02580:  MOVFF  2A1,2C2
02584:  MOVLB  0
02586:  CALL   0944
....................             MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
0258A:  MOVLW  02
0258C:  MOVLB  2
0258E:  MOVWF  xAB
02590:  MOVLW  A2
02592:  MOVWF  xAA
02594:  MOVFF  2AB,2BF
02598:  MOVWF  xBE
0259A:  CLRF   xC1
0259C:  MOVLW  07
0259E:  MOVWF  xC0
025A0:  MOVLB  0
025A2:  CALL   0EDC
....................  
....................             // Implement retransmission if a late collision occured (this can 
....................             // happen on B5 when certain link pulses arrive at the same time 
....................             // as the transmission) 
....................             for(i = 0; i < 16u; i++) 
025A6:  MOVLB  2
025A8:  CLRF   xA9
025AA:  MOVF   xA9,W
025AC:  SUBLW  0F
025AE:  BNC   2680
....................             { 
....................                 if(ReadETHReg(EIR).EIRbits.TXERIF && TXStatus.bits.LateCollision) 
025B0:  MOVLW  1C
025B2:  MOVWF  xBC
025B4:  MOVLB  0
025B6:  CALL   091A
025BA:  MOVFF  01,2AA
025BE:  MOVLW  00
025C0:  MOVLB  2
025C2:  BTFSC  01.1
025C4:  MOVLW  01
025C6:  XORLW  00
025C8:  BZ    2676
025CA:  BTFSS  xA5.5
025CC:  BRA    2676
....................                 { 
....................                     // Reset the TX logic 
....................                     BFSReg(ECON1, ECON1_TXRST); 
025CE:  MOVLW  1F
025D0:  MOVWF  xB6
025D2:  MOVLW  80
025D4:  MOVWF  xB7
025D6:  MOVLB  0
025D8:  CALL   0992
....................                     BFCReg(ECON1, ECON1_TXRST); 
025DC:  MOVLW  1F
025DE:  MOVLB  2
025E0:  MOVWF  xB6
025E2:  MOVLW  80
025E4:  MOVWF  xB7
025E6:  MOVLB  0
025E8:  CALL   08B8
....................                     BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
025EC:  MOVLW  1C
025EE:  MOVLB  2
025F0:  MOVWF  xB6
025F2:  MOVLW  0A
025F4:  MOVWF  xB7
025F6:  MOVLB  0
025F8:  CALL   08B8
....................  
....................                     // Transmit the packet again 
....................                     BFSReg(ECON1, ECON1_TXRTS); 
025FC:  MOVLW  1F
025FE:  MOVLB  2
02600:  MOVWF  xB6
02602:  MOVLW  08
02604:  MOVWF  xB7
02606:  MOVLB  0
02608:  CALL   0992
....................                     while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
0260C:  MOVLW  1C
0260E:  MOVLB  2
02610:  MOVWF  xBC
02612:  MOVLB  0
02614:  CALL   091A
02618:  MOVFF  01,2AA
0261C:  MOVLB  2
0261E:  MOVF   01,W
02620:  ANDLW  0A
02622:  BTFSS  FD8.2
02624:  BRA    262A
02626:  MOVLB  0
02628:  BRA    260C
....................  
....................                     // Cancel the previous transmission if it has become stuck set 
....................                     BFCReg(ECON1, ECON1_TXRTS); 
0262A:  MOVLW  1F
0262C:  MOVWF  xB6
0262E:  MOVLW  08
02630:  MOVWF  xB7
02632:  MOVLB  0
02634:  CALL   08B8
....................  
....................                     // Read transmit status vector 
....................                     WriteReg(ERDPTL, TXEnd.v[0]); 
02638:  MOVLB  2
0263A:  CLRF   xC1
0263C:  MOVFF  2A0,2C2
02640:  MOVLB  0
02642:  CALL   0944
....................                     WriteReg(ERDPTH, TXEnd.v[1]); 
02646:  MOVLW  01
02648:  MOVLB  2
0264A:  MOVWF  xC1
0264C:  MOVFF  2A1,2C2
02650:  MOVLB  0
02652:  CALL   0944
....................                     MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
02656:  MOVLW  02
02658:  MOVLB  2
0265A:  MOVWF  xAB
0265C:  MOVLW  A2
0265E:  MOVWF  xAA
02660:  MOVFF  2AB,2BF
02664:  MOVWF  xBE
02666:  CLRF   xC1
02668:  MOVLW  07
0266A:  MOVWF  xC0
0266C:  MOVLB  0
0266E:  CALL   0EDC
....................                 } 
02672:  BRA    267A
02674:  MOVLB  2
....................                 else 
....................                 { 
....................                     break; 
02676:  BRA    2680
02678:  MOVLB  0
....................                 } 
0267A:  MOVLB  2
0267C:  INCF   xA9,F
0267E:  BRA    25AA
....................             } 
....................  
....................             // Restore the current read pointer 
....................             WriteReg(ERDPTL, ReadPtrSave.v[0]); 
02680:  CLRF   xC1
02682:  MOVFF  29E,2C2
02686:  MOVLB  0
02688:  CALL   0944
....................             WriteReg(ERDPTH, ReadPtrSave.v[1]); 
0268C:  MOVLW  01
0268E:  MOVLB  2
02690:  MOVWF  xC1
02692:  MOVFF  29F,2C2
02696:  MOVLB  0
02698:  CALL   0944
0269C:  MOVLB  2
....................         } 
....................     } 
0269E:  MOVLB  0
026A0:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetReadPtrInRx(WORD offset) 
....................  * 
....................  * PreCondition:    A packet has been obtained by calling MACGetHeader() and 
....................  *                  getting a TRUE result. 
....................  * 
....................  * Input:           offset: WORD specifying how many bytes beyond the Ethernet 
....................  *                          header's type field to relocate the SPI read 
....................  *                          pointer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read pointer are updated.  All calls to 
....................  *                  MACGet() and MACGetArray() will use these new values. 
....................  * 
....................  * Note:            RXSTOP must be statically defined as being > RXSTART for 
....................  *                  this function to work correctly.  In other words, do not 
....................  *                  define an RX buffer which spans the 0x1FFF->0x0000 memory 
....................  *                  boundary. 
....................  *****************************************************************************/ 
.................... void MACSetReadPtrInRx(WORD offset) 
.................... { 
....................     WORD_VAL ReadPT; 
....................  
....................     // Determine the address of the beginning of the entire packet 
....................     // and adjust the address to the desired location 
....................     ReadPT.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
03D9A:  MOVLW  14
03D9C:  ADDWF  7C,W
03D9E:  MOVLB  1
03DA0:  MOVWF  xCB
03DA2:  MOVLW  00
03DA4:  ADDWFC 7D,W
03DA6:  MOVWF  xCC
03DA8:  MOVF   xC7,W
03DAA:  ADDWF  xCB,W
03DAC:  MOVWF  xC9
03DAE:  MOVF   xC8,W
03DB0:  ADDWFC xCC,W
03DB2:  MOVWF  xCA
....................  
....................     // Since the receive buffer is circular, adjust if a wraparound is needed 
....................     if(ReadPT.Val > RXSTOP) 
03DB4:  MOVF   xCA,W
03DB6:  SUBLW  14
03DB8:  BC    3DCC
03DBA:  XORLW  FF
03DBC:  BNZ   3DC4
03DBE:  MOVF   xC9,W
03DC0:  SUBLW  09
03DC2:  BC    3DCC
....................         ReadPT.Val -= RXSIZE; 
03DC4:  MOVLW  0A
03DC6:  SUBWF  xC9,F
03DC8:  MOVLW  15
03DCA:  SUBWFB xCA,F
....................  
....................     // Set the SPI read pointer to the new calculated value 
....................     WriteReg(ERDPTL, ReadPT.v[0]); 
03DCC:  MOVLB  2
03DCE:  CLRF   xC1
03DD0:  MOVFF  1C9,2C2
03DD4:  MOVLB  0
03DD6:  CALL   0944
....................     WriteReg(ERDPTH, ReadPT.v[1]); 
03DDA:  MOVLW  01
03DDC:  MOVLB  2
03DDE:  MOVWF  xC1
03DE0:  MOVFF  1CA,2C2
03DE4:  MOVLB  0
03DE6:  CALL   0944
03DEA:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        PTR_BASE MACSetWritePtr(PTR_BASE Address) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           Address: Address to seek to 
....................  * 
....................  * Output:          WORD: Old EWRPT location 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI write pointer is updated.  All calls to 
....................  *                  MACPut() and MACPutArray() will use this new value. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PTR_BASE MACSetWritePtr(PTR_BASE address) 
.................... { 
....................     WORD_VAL oldVal; 
....................  
....................     oldVal.v[0] = ReadETHReg(EWRPTL).Val; 
*
00DBA:  MOVLW  02
00DBC:  MOVLB  2
00DBE:  MOVWF  xBC
00DC0:  MOVLB  0
00DC2:  RCALL  091A
00DC4:  MOVFF  01,2AD
....................     oldVal.v[1] = ReadETHReg(EWRPTH).Val; 
00DC8:  MOVLW  03
00DCA:  MOVLB  2
00DCC:  MOVWF  xBC
00DCE:  MOVLB  0
00DD0:  RCALL  091A
00DD2:  MOVFF  01,2AE
....................  
....................     // Set the SPI write pointer to the new calculated value 
....................     WriteReg(EWRPTL, ((WORD_VAL*)&address)->v[0]); 
00DD6:  MOVLW  02
00DD8:  MOVLB  2
00DDA:  MOVWF  xB0
00DDC:  MOVLW  AB
00DDE:  MOVWF  xAF
00DE0:  MOVWF  FE9
00DE2:  MOVFF  2B0,FEA
00DE6:  MOVFF  FEF,2B1
00DEA:  MOVLW  02
00DEC:  MOVWF  xC1
00DEE:  MOVFF  2B1,2C2
00DF2:  MOVLB  0
00DF4:  RCALL  0944
....................     WriteReg(EWRPTH, ((WORD_VAL*)&address)->v[1]); 
00DF6:  MOVLW  02
00DF8:  MOVLB  2
00DFA:  MOVWF  xB0
00DFC:  MOVLW  AB
00DFE:  MOVWF  xAF
00E00:  MOVLW  01
00E02:  ADDWF  xAF,W
00E04:  MOVWF  FE9
00E06:  MOVLW  00
00E08:  ADDWFC xB0,W
00E0A:  MOVWF  FEA
00E0C:  MOVFF  FEF,2B1
00E10:  MOVLW  03
00E12:  MOVWF  xC1
00E14:  MOVFF  2B1,2C2
00E18:  MOVLB  0
00E1A:  RCALL  0944
....................  
....................     return oldVal.Val; 
00E1C:  MOVLB  2
00E1E:  MOVFF  2AD,01
00E22:  MOVFF  2AE,02
00E26:  MOVLB  0
00E28:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        PTR_BASE MACSetReadPtr(PTR_BASE Address) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           Address: Address to seek to 
....................  * 
....................  * Output:          WORD: Old ERDPT value 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI write pointer is updated.  All calls to 
....................  *                  MACPut() and MACPutArray() will use this new value. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PTR_BASE MACSetReadPtr(PTR_BASE address) 
.................... { 
....................     WORD_VAL oldVal; 
....................  
....................     oldVal.v[0] = ReadETHReg(ERDPTL).Val; 
*
00E70:  MOVLB  2
00E72:  CLRF   xBC
00E74:  MOVLB  0
00E76:  RCALL  091A
00E78:  MOVFF  01,2AD
....................     oldVal.v[1] = ReadETHReg(ERDPTH).Val; 
00E7C:  MOVLW  01
00E7E:  MOVLB  2
00E80:  MOVWF  xBC
00E82:  MOVLB  0
00E84:  RCALL  091A
00E86:  MOVFF  01,2AE
....................  
....................     // Set the SPI write pointer to the new calculated value 
....................     WriteReg(ERDPTL, ((WORD_VAL*)&address)->v[0]); 
00E8A:  MOVLW  02
00E8C:  MOVLB  2
00E8E:  MOVWF  xB0
00E90:  MOVLW  AB
00E92:  MOVWF  xAF
00E94:  MOVWF  FE9
00E96:  MOVFF  2B0,FEA
00E9A:  MOVFF  FEF,2B1
00E9E:  CLRF   xC1
00EA0:  MOVFF  2B1,2C2
00EA4:  MOVLB  0
00EA6:  RCALL  0944
....................     WriteReg(ERDPTH, ((WORD_VAL*)&address)->v[1]); 
00EA8:  MOVLW  02
00EAA:  MOVLB  2
00EAC:  MOVWF  xB0
00EAE:  MOVLW  AB
00EB0:  MOVWF  xAF
00EB2:  MOVLW  01
00EB4:  ADDWF  xAF,W
00EB6:  MOVWF  FE9
00EB8:  MOVLW  00
00EBA:  ADDWFC xB0,W
00EBC:  MOVWF  FEA
00EBE:  MOVFF  FEF,2B1
00EC2:  MOVLW  01
00EC4:  MOVWF  xC1
00EC6:  MOVFF  2B1,2C2
00ECA:  MOVLB  0
00ECC:  RCALL  0944
....................  
....................     return oldVal.Val; 
00ECE:  MOVLB  2
00ED0:  MOVFF  2AD,01
00ED4:  MOVFF  2AE,02
00ED8:  MOVLB  0
00EDA:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcRxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset  - Number of bytes beyond the beginning of the 
....................  *                          Ethernet data (first byte after the type field) 
....................  *                          where the checksum should begin 
....................  *                  len     - Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by RFC 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcRxChecksum(WORD offset, WORD len) 
.................... { 
....................     WORD_VAL temp; 
....................     WORD_VAL RDSave; 
....................  
....................     // Add the offset requested by firmware plus the Ethernet header 
....................     temp.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
03CEC:  MOVLW  14
03CEE:  ADDWF  7C,W
03CF0:  MOVLB  1
03CF2:  MOVWF  x9A
03CF4:  MOVLW  00
03CF6:  ADDWFC 7D,W
03CF8:  MOVWF  x9B
03CFA:  MOVF   x92,W
03CFC:  ADDWF  x9A,W
03CFE:  MOVWF  x96
03D00:  MOVF   x93,W
03D02:  ADDWFC x9B,W
03D04:  MOVWF  x97
....................     if(temp.Val > RXSTOP)       // Adjust value if a wrap is needed 
03D06:  MOVF   x97,W
03D08:  SUBLW  14
03D0A:  BC    3D1E
03D0C:  XORLW  FF
03D0E:  BNZ   3D16
03D10:  MOVF   x96,W
03D12:  SUBLW  09
03D14:  BC    3D1E
....................     { 
....................         temp.Val -= RXSIZE; 
03D16:  MOVLW  0A
03D18:  SUBWF  x96,F
03D1A:  MOVLW  15
03D1C:  SUBWFB x97,F
....................     } 
....................  
....................     RDSave.v[0] = ReadETHReg(ERDPTL).Val; 
03D1E:  MOVLB  2
03D20:  CLRF   xBC
03D22:  MOVLB  0
03D24:  CALL   091A
03D28:  MOVFF  01,198
....................     RDSave.v[1] = ReadETHReg(ERDPTH).Val; 
03D2C:  MOVLW  01
03D2E:  MOVLB  2
03D30:  MOVWF  xBC
03D32:  MOVLB  0
03D34:  CALL   091A
03D38:  MOVFF  01,199
....................  
....................     WriteReg(ERDPTL, temp.v[0]); 
03D3C:  MOVLB  2
03D3E:  CLRF   xC1
03D40:  MOVFF  196,2C2
03D44:  MOVLB  0
03D46:  CALL   0944
....................     WriteReg(ERDPTH, temp.v[1]); 
03D4A:  MOVLW  01
03D4C:  MOVLB  2
03D4E:  MOVWF  xC1
03D50:  MOVFF  197,2C2
03D54:  MOVLB  0
03D56:  CALL   0944
....................  
....................     temp.Val = CalcIPBufferChecksum(len); 
03D5A:  MOVFF  195,29D
03D5E:  MOVFF  194,29C
03D62:  CALL   2326
03D66:  MOVFF  02,197
03D6A:  MOVFF  01,196
....................  
....................     WriteReg(ERDPTL, RDSave.v[0]); 
03D6E:  MOVLB  2
03D70:  CLRF   xC1
03D72:  MOVFF  198,2C2
03D76:  MOVLB  0
03D78:  CALL   0944
....................     WriteReg(ERDPTH, RDSave.v[1]); 
03D7C:  MOVLW  01
03D7E:  MOVLB  2
03D80:  MOVWF  xC1
03D82:  MOVFF  199,2C2
03D86:  MOVLB  0
03D88:  CALL   0944
....................  
....................     return temp.Val; 
03D8C:  MOVLB  1
03D8E:  MOVFF  196,01
03D92:  MOVFF  197,02
03D96:  MOVLB  0
03D98:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    Read buffer pointer set to starting of checksum data 
....................  * 
....................  * Input:           len: Total number of bytes to calculate the checksum over. 
....................  *                       The first byte included in the checksum is the byte 
....................  *                       pointed to by ERDPT, which is updated by calls to 
....................  *                       MACSetReadPtr(), MACGet(), MACGetArray(), 
....................  *                       MACGetHeader(), etc. 
....................  * 
....................  * Output:          16-bit checksum as defined by RFC 793 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself.  The ENC28J60 has a hardware DMA module 
....................  *                  which can calculate the checksum faster than software, so 
....................  *                  this function replaces the CaclIPBufferChecksum() function 
....................  *                  defined in the helpers.c file.  Through the use of 
....................  *                  preprocessor defines, this replacement is automatic. 
....................  * 
....................  * Note:            This function works either in the RX buffer area or the TX 
....................  *                  buffer area.  No validation is done on the len parameter. 
....................  *****************************************************************************/ 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................     WORD_VAL Start; 
....................     DWORD_VAL Checksum = {0x00000000ul}; 
*
02326:  MOVLB  2
02328:  CLRF   xA0
0232A:  CLRF   xA1
0232C:  CLRF   xA2
0232E:  CLRF   xA3
....................     WORD ChunkLen; 
....................     WORD DataBuffer[10]; 
....................     WORD *DataPtr; 
....................  
....................     // Save the SPI read pointer starting address 
....................     Start.v[0] = ReadETHReg(ERDPTL).Val; 
02330:  CLRF   xBC
02332:  MOVLB  0
02334:  CALL   091A
02338:  MOVFF  01,29E
....................     Start.v[1] = ReadETHReg(ERDPTH).Val; 
0233C:  MOVLW  01
0233E:  MOVLB  2
02340:  MOVWF  xBC
02342:  MOVLB  0
02344:  CALL   091A
02348:  MOVFF  01,29F
....................  
....................     while(len) 
0234C:  MOVLB  2
0234E:  MOVF   x9C,W
02350:  IORWF  x9D,W
02352:  BZ    2404
....................     { 
....................         // Obtain a chunk of data (less SPI overhead compared 
....................         // to requesting one byte at a time) 
....................         ChunkLen = len > sizeof(DataBuffer) ? sizeof(DataBuffer) : len; 
02354:  MOVF   x9D,F
02356:  BNZ   235E
02358:  MOVF   x9C,W
0235A:  SUBLW  14
0235C:  BC    2364
0235E:  CLRF   03
02360:  MOVLW  14
02362:  BRA    236A
02364:  MOVFF  29D,03
02368:  MOVF   x9C,W
0236A:  MOVWF  xA4
0236C:  MOVFF  03,2A5
....................         MACGetArray((BYTE*)DataBuffer, ChunkLen); 
02370:  MOVLW  02
02372:  MOVWF  xBD
02374:  MOVLW  A6
02376:  MOVWF  xBC
02378:  MOVFF  2BD,2BF
0237C:  MOVWF  xBE
0237E:  MOVFF  2A5,2C1
02382:  MOVFF  2A4,2C0
02386:  MOVLB  0
02388:  CALL   0EDC
....................  
....................         len -= ChunkLen; 
0238C:  MOVLB  2
0238E:  MOVF   xA4,W
02390:  SUBWF  x9C,F
02392:  MOVF   xA5,W
02394:  SUBWFB x9D,F
....................  
....................         // Take care of a last odd numbered data byte 
....................         if(((WORD_VAL*)&ChunkLen)->bits.b0) 
02396:  MOVLW  02
02398:  MOVWF  xBD
0239A:  MOVLW  A4
0239C:  MOVWF  FE9
0239E:  MOVFF  2BD,FEA
023A2:  BTFSS  FEF.0
023A4:  BRA    23BE
....................         { 
....................             ((BYTE*)DataBuffer)[ChunkLen] = 0x00; 
023A6:  MOVLW  02
023A8:  MOVWF  xBD
023AA:  MOVLW  A6
023AC:  ADDWF  xA4,W
023AE:  MOVWF  FE9
023B0:  MOVF   xBD,W
023B2:  ADDWFC xA5,W
023B4:  MOVWF  FEA
023B6:  CLRF   FEF
....................             ChunkLen++; 
023B8:  INCF   xA4,F
023BA:  BTFSC  FD8.2
023BC:  INCF   xA5,F
....................         } 
....................  
....................         // Calculate the checksum over this chunk 
....................         DataPtr = DataBuffer; 
023BE:  MOVLW  02
023C0:  MOVWF  xBB
023C2:  MOVLW  A6
023C4:  MOVWF  xBA
....................         while(ChunkLen) 
023C6:  MOVF   xA4,W
023C8:  IORWF  xA5,W
023CA:  BZ    2402
....................         { 
....................             Checksum.Val += *DataPtr++; 
023CC:  MOVFF  2BB,03
023D0:  MOVFF  2BA,00
023D4:  MOVLW  02
023D6:  ADDWF  xBA,F
023D8:  BTFSC  FD8.0
023DA:  INCF   xBB,F
023DC:  MOVFF  00,FE9
023E0:  MOVFF  03,FEA
023E4:  MOVFF  FEC,03
023E8:  MOVF   FED,F
023EA:  MOVF   FEF,W
023EC:  ADDWF  xA0,F
023EE:  MOVF   03,W
023F0:  ADDWFC xA1,F
023F2:  MOVLW  00
023F4:  ADDWFC xA2,F
023F6:  ADDWFC xA3,F
....................             ChunkLen -= 2; 
023F8:  MOVLW  02
023FA:  SUBWF  xA4,F
023FC:  MOVLW  00
023FE:  SUBWFB xA5,F
02400:  BRA    23C6
....................         } 
02402:  BRA    234E
....................     } 
....................  
....................     // Restore old read pointer location 
....................     WriteReg(ERDPTL, Start.v[0]); 
02404:  CLRF   xC1
02406:  MOVFF  29E,2C2
0240A:  MOVLB  0
0240C:  CALL   0944
....................     WriteReg(ERDPTH, Start.v[1]); 
02410:  MOVLW  01
02412:  MOVLB  2
02414:  MOVWF  xC1
02416:  MOVFF  29F,2C2
0241A:  MOVLB  0
0241C:  CALL   0944
....................  
....................     // Do an end-around carry (one's complement arrithmatic) 
....................     Checksum.Val = (DWORD)Checksum.w[0] + (DWORD)Checksum.w[1]; 
02420:  MOVLB  2
02422:  CLRF   xBF
02424:  CLRF   xBE
02426:  MOVFF  2A1,2BD
0242A:  MOVFF  2A0,2BC
0242E:  MOVFF  2A2,00
02432:  MOVFF  2A3,01
02436:  CLRF   02
02438:  CLRF   03
0243A:  MOVF   xA2,W
0243C:  ADDWF  xA0,W
0243E:  MOVWF  xA0
02440:  MOVF   xA3,W
02442:  ADDWFC xA1,W
02444:  MOVWF  xA1
02446:  MOVF   02,W
02448:  ADDWFC xBE,W
0244A:  MOVWF  xA2
0244C:  MOVF   03,W
0244E:  ADDWFC xBF,W
02450:  MOVWF  xA3
....................  
....................     // Do another end-around carry in case if the prior add 
....................     // caused a carry out 
....................     Checksum.w[0] += Checksum.w[1]; 
02452:  MOVF   xA2,W
02454:  ADDWF  xA0,F
02456:  MOVF   xA3,W
02458:  ADDWFC xA1,F
....................  
....................     // Return the resulting checksum 
....................     return ~Checksum.w[0]; 
0245A:  MOVFF  2A1,03
0245E:  COMF   03,F
02460:  MOVF   xA0,W
02462:  XORLW  FF
02464:  MOVWF  01
02466:  MOVFF  03,02
0246A:  MOVLB  0
0246C:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACMemCopyAsync(PTR_BASE destAddr, PTR_BASE sourceAddr, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           destAddr:   Destination address in the Ethernet memory to 
....................  *                              copy to.  If (PTR_BASE)-1 is specified, the  
....................  *                        current EWRPT value will be used instead. 
....................  *                  sourceAddr: Source address to read from.  If (PTR_BASE)-1 is 
....................  *                              specified, the current ERDPT value will be used 
....................  *                              instead. 
....................  *                  len:        Number of bytes to copy 
....................  * 
....................  * Output:          Byte read from the ENC28J60's RAM 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Bytes are asynchrnously transfered within the buffer.  Call 
....................  *                  MACIsMemCopyDone() to see when the transfer is complete. 
....................  * 
....................  * Note:            If a prior transfer is already in progress prior to 
....................  *                  calling this function, this function will block until it 
....................  *                  can start this transfer. 
....................  * 
....................  *                  If (PTR_BASE)-1 is used for the sourceAddr or destAddr 
....................  *                  parameters, then that pointer will get updated with the 
....................  *                  next address after the read or write. 
....................  *****************************************************************************/ 
.................... void MACMemCopyAsync(PTR_BASE destAddr, PTR_BASE sourceAddr, WORD len) 
*
00F7C:  MOVLB  2
00F7E:  BCF    xB5.0
00F80:  BCF    xB5.1
.................... { 
....................     WORD_VAL ReadSave, WriteSave; 
....................     BOOL UpdateWritePointer = FALSE; 
....................     BOOL UpdateReadPointer = FALSE; 
....................  
....................     if(destAddr == (PTR_BASE)-1) 
00F82:  INCFSZ xAB,W
00F84:  BRA    0FAA
00F86:  INCFSZ xAC,W
00F88:  BRA    0FAA
....................     { 
....................         UpdateWritePointer = TRUE; 
00F8A:  BSF    xB5.0
....................         destAddr = ReadETHReg(EWRPTL).Val; 
00F8C:  MOVLW  02
00F8E:  MOVWF  xBC
00F90:  MOVLB  0
00F92:  RCALL  091A
00F94:  MOVLB  2
00F96:  CLRF   xAC
00F98:  MOVFF  01,2AB
....................         ((BYTE*)&destAddr)[1] = ReadETHReg(EWRPTH).Val; 
00F9C:  MOVLW  03
00F9E:  MOVWF  xBC
00FA0:  MOVLB  0
00FA2:  RCALL  091A
00FA4:  MOVFF  01,2AC
00FA8:  MOVLB  2
....................     } 
....................     if(sourceAddr == (PTR_BASE)-1) 
00FAA:  INCFSZ xAD,W
00FAC:  BRA    0FD0
00FAE:  INCFSZ xAE,W
00FB0:  BRA    0FD0
....................     { 
....................         UpdateReadPointer = TRUE; 
00FB2:  BSF    xB5.1
....................         sourceAddr = ReadETHReg(ERDPTL).Val; 
00FB4:  CLRF   xBC
00FB6:  MOVLB  0
00FB8:  RCALL  091A
00FBA:  MOVLB  2
00FBC:  CLRF   xAE
00FBE:  MOVFF  01,2AD
....................         ((BYTE*)&sourceAddr)[1] = ReadETHReg(ERDPTH).Val; 
00FC2:  MOVLW  01
00FC4:  MOVWF  xBC
00FC6:  MOVLB  0
00FC8:  RCALL  091A
00FCA:  MOVFF  01,2AE
00FCE:  MOVLB  2
....................     } 
....................  
....................     // Handle special conditions where len == 0 or len == 1 
....................     // The DMA module is not capable of handling those corner cases 
....................     if(len <= 1u) 
00FD0:  MOVF   xB0,F
00FD2:  BTFSS  FD8.2
00FD4:  BRA    10B4
00FD6:  MOVF   xAF,W
00FD8:  SUBLW  01
00FDA:  BTFSS  FD8.0
00FDC:  BRA    10B4
....................     { 
....................         if(!UpdateReadPointer) 
00FDE:  BTFSC  xB5.1
00FE0:  BRA    0FFC
....................         { 
....................             ReadSave.v[0] = ReadETHReg(ERDPTL).Val; 
00FE2:  CLRF   xBC
00FE4:  MOVLB  0
00FE6:  RCALL  091A
00FE8:  MOVFF  01,2B1
....................             ReadSave.v[1] = ReadETHReg(ERDPTH).Val; 
00FEC:  MOVLW  01
00FEE:  MOVLB  2
00FF0:  MOVWF  xBC
00FF2:  MOVLB  0
00FF4:  RCALL  091A
00FF6:  MOVFF  01,2B2
00FFA:  MOVLB  2
....................         } 
....................         if(!UpdateWritePointer) 
00FFC:  BTFSC  xB5.0
00FFE:  BRA    101C
....................         { 
....................             WriteSave.v[0] = ReadETHReg(EWRPTL).Val; 
01000:  MOVLW  02
01002:  MOVWF  xBC
01004:  MOVLB  0
01006:  RCALL  091A
01008:  MOVFF  01,2B3
....................             WriteSave.v[1] = ReadETHReg(EWRPTH).Val; 
0100C:  MOVLW  03
0100E:  MOVLB  2
01010:  MOVWF  xBC
01012:  MOVLB  0
01014:  RCALL  091A
01016:  MOVFF  01,2B4
0101A:  MOVLB  2
....................         } 
....................         WriteReg(ERDPTL, ((BYTE*)&sourceAddr)[0]); 
0101C:  CLRF   xC1
0101E:  MOVFF  2AD,2C2
01022:  MOVLB  0
01024:  RCALL  0944
....................         WriteReg(ERDPTH, ((BYTE*)&sourceAddr)[1]); 
01026:  MOVLW  01
01028:  MOVLB  2
0102A:  MOVWF  xC1
0102C:  MOVFF  2AE,2C2
01030:  MOVLB  0
01032:  RCALL  0944
....................         WriteReg(EWRPTL, ((BYTE*)&destAddr)[0]); 
01034:  MOVLW  02
01036:  MOVLB  2
01038:  MOVWF  xC1
0103A:  MOVFF  2AB,2C2
0103E:  MOVLB  0
01040:  RCALL  0944
....................         WriteReg(EWRPTH, ((BYTE*)&destAddr)[1]); 
01042:  MOVLW  03
01044:  MOVLB  2
01046:  MOVWF  xC1
01048:  MOVFF  2AC,2C2
0104C:  MOVLB  0
0104E:  RCALL  0944
....................         while(len--) 
01050:  MOVLB  2
01052:  MOVFF  2B0,03
01056:  MOVF   xAF,W
01058:  BTFSC  FD8.2
0105A:  DECF   xB0,F
0105C:  DECF   xAF,F
0105E:  IORWF  03,W
01060:  BZ    1074
....................             MACPut(MACGet()); 
01062:  MOVLB  0
01064:  RCALL  0F52
01066:  MOVFF  01,2B6
0106A:  MOVFF  01,2BF
0106E:  RCALL  096E
01070:  BRA    1050
01072:  MOVLB  2
....................         if(!UpdateReadPointer) 
01074:  BTFSC  xB5.1
01076:  BRA    1092
....................         { 
....................             WriteReg(ERDPTL, ReadSave.v[0]); 
01078:  CLRF   xC1
0107A:  MOVFF  2B1,2C2
0107E:  MOVLB  0
01080:  RCALL  0944
....................             WriteReg(ERDPTH, ReadSave.v[1]); 
01082:  MOVLW  01
01084:  MOVLB  2
01086:  MOVWF  xC1
01088:  MOVFF  2B2,2C2
0108C:  MOVLB  0
0108E:  RCALL  0944
01090:  MOVLB  2
....................         } 
....................         if(!UpdateWritePointer) 
01092:  BTFSC  xB5.0
01094:  BRA    10B2
....................         { 
....................             WriteReg(EWRPTL, WriteSave.v[0]); 
01096:  MOVLW  02
01098:  MOVWF  xC1
0109A:  MOVFF  2B3,2C2
0109E:  MOVLB  0
010A0:  RCALL  0944
....................             WriteReg(EWRPTH, WriteSave.v[1]); 
010A2:  MOVLW  03
010A4:  MOVLB  2
010A6:  MOVWF  xC1
010A8:  MOVFF  2B4,2C2
010AC:  MOVLB  0
010AE:  RCALL  0944
010B0:  MOVLB  2
....................         } 
....................     } 
010B2:  BRA    11F8
....................     else 
....................     { 
....................         if(UpdateWritePointer) 
010B4:  BTFSS  xB5.0
010B6:  BRA    10E0
....................         { 
....................             WriteSave.Val = destAddr + len; 
010B8:  MOVF   xAF,W
010BA:  ADDWF  xAB,W
010BC:  MOVWF  xB3
010BE:  MOVF   xB0,W
010C0:  ADDWFC xAC,W
010C2:  MOVWF  xB4
....................             WriteReg(EWRPTL, WriteSave.v[0]); 
010C4:  MOVLW  02
010C6:  MOVWF  xC1
010C8:  MOVFF  2B3,2C2
010CC:  MOVLB  0
010CE:  RCALL  0944
....................             WriteReg(EWRPTH, WriteSave.v[1]); 
010D0:  MOVLW  03
010D2:  MOVLB  2
010D4:  MOVWF  xC1
010D6:  MOVFF  2B4,2C2
010DA:  MOVLB  0
010DC:  RCALL  0944
010DE:  MOVLB  2
....................         } 
....................         len += sourceAddr - 1; 
010E0:  MOVLW  01
010E2:  SUBWF  xAD,W
010E4:  MOVWF  00
010E6:  MOVLW  00
010E8:  SUBWFB xAE,W
010EA:  MOVWF  03
010EC:  MOVF   00,W
010EE:  ADDWF  xAF,F
010F0:  MOVF   03,W
010F2:  ADDWFC xB0,F
....................         while(ReadETHReg(ECON1).ECON1bits.DMAST); 
010F4:  MOVLW  1F
010F6:  MOVWF  xBC
010F8:  MOVLB  0
010FA:  RCALL  091A
010FC:  MOVFF  01,2B6
01100:  MOVLW  00
01102:  MOVLB  2
01104:  BTFSC  01.5
01106:  MOVLW  01
01108:  XORLW  00
0110A:  BNZ   10F4
....................         WriteReg(EDMASTL, ((BYTE*)&sourceAddr)[0]); 
0110C:  MOVLW  10
0110E:  MOVWF  xC1
01110:  MOVFF  2AD,2C2
01114:  MOVLB  0
01116:  RCALL  0944
....................         WriteReg(EDMASTH, ((BYTE*)&sourceAddr)[1]); 
01118:  MOVLW  11
0111A:  MOVLB  2
0111C:  MOVWF  xC1
0111E:  MOVFF  2AE,2C2
01122:  MOVLB  0
01124:  RCALL  0944
....................         WriteReg(EDMADSTL, ((BYTE*)&destAddr)[0]); 
01126:  MOVLW  14
01128:  MOVLB  2
0112A:  MOVWF  xC1
0112C:  MOVFF  2AB,2C2
01130:  MOVLB  0
01132:  RCALL  0944
....................         WriteReg(EDMADSTH, ((BYTE*)&destAddr)[1]); 
01134:  MOVLW  15
01136:  MOVLB  2
01138:  MOVWF  xC1
0113A:  MOVFF  2AC,2C2
0113E:  MOVLB  0
01140:  RCALL  0944
....................         if((sourceAddr <= RXSTOP) && (len > RXSTOP)) //&& (sourceAddr >= RXSTART)) 
01142:  MOVLB  2
01144:  MOVF   xAE,W
01146:  SUBLW  15
01148:  BNC   116A
0114A:  BNZ   1152
0114C:  MOVF   xAD,W
0114E:  SUBLW  09
01150:  BNC   116A
01152:  MOVF   xB0,W
01154:  SUBLW  14
01156:  BC    116A
01158:  XORLW  FF
0115A:  BNZ   1162
0115C:  MOVF   xAF,W
0115E:  SUBLW  09
01160:  BC    116A
....................             len -= RXSIZE; 
01162:  MOVLW  0A
01164:  SUBWF  xAF,F
01166:  MOVLW  15
01168:  SUBWFB xB0,F
....................         WriteReg(EDMANDL, ((BYTE*)&len)[0]); 
0116A:  MOVLW  12
0116C:  MOVWF  xC1
0116E:  MOVFF  2AF,2C2
01172:  MOVLB  0
01174:  CALL   0944
....................         WriteReg(EDMANDH, ((BYTE*)&len)[1]); 
01178:  MOVLW  13
0117A:  MOVLB  2
0117C:  MOVWF  xC1
0117E:  MOVFF  2B0,2C2
01182:  MOVLB  0
01184:  CALL   0944
....................         BFCReg(ECON1, ECON1_CSUMEN); 
01188:  MOVLW  1F
0118A:  MOVLB  2
0118C:  MOVWF  xB6
0118E:  MOVLW  10
01190:  MOVWF  xB7
01192:  MOVLB  0
01194:  CALL   08B8
....................         BFSReg(ECON1, ECON1_DMAST); 
01198:  MOVLW  1F
0119A:  MOVLB  2
0119C:  MOVWF  xB6
0119E:  MOVLW  20
011A0:  MOVWF  xB7
011A2:  MOVLB  0
011A4:  CALL   0992
....................         if(UpdateReadPointer) 
011A8:  MOVLB  2
011AA:  BTFSS  xB5.1
011AC:  BRA    11F8
....................         { 
....................             len++; 
011AE:  INCF   xAF,F
011B0:  BTFSC  FD8.2
011B2:  INCF   xB0,F
....................             if((sourceAddr <= RXSTOP) && (len > RXSTOP)) //&& (sourceAddr >= RXSTART)) 
011B4:  MOVF   xAE,W
011B6:  SUBLW  15
011B8:  BNC   11DA
011BA:  BNZ   11C2
011BC:  MOVF   xAD,W
011BE:  SUBLW  09
011C0:  BNC   11DA
011C2:  MOVF   xB0,W
011C4:  SUBLW  14
011C6:  BC    11DA
011C8:  XORLW  FF
011CA:  BNZ   11D2
011CC:  MOVF   xAF,W
011CE:  SUBLW  09
011D0:  BC    11DA
....................                 len -= RXSIZE; 
011D2:  MOVLW  0A
011D4:  SUBWF  xAF,F
011D6:  MOVLW  15
011D8:  SUBWFB xB0,F
....................             WriteReg(ERDPTL, ((BYTE*)&len)[0]); 
011DA:  CLRF   xC1
011DC:  MOVFF  2AF,2C2
011E0:  MOVLB  0
011E2:  CALL   0944
....................             WriteReg(ERDPTH, ((BYTE*)&len)[1]); 
011E6:  MOVLW  01
011E8:  MOVLB  2
011EA:  MOVWF  xC1
011EC:  MOVFF  2B0,2C2
011F0:  MOVLB  0
011F2:  CALL   0944
011F6:  MOVLB  2
....................         } 
....................     } 
011F8:  MOVLB  0
011FA:  RETURN 0
.................... } 
....................  
.................... BOOL MACIsMemCopyDone(void) 
.................... { 
....................     return !ReadETHReg(ECON1).ECON1bits.DMAST; 
011FC:  MOVLW  1F
011FE:  MOVLB  2
01200:  MOVWF  xBC
01202:  MOVLB  0
01204:  CALL   091A
01208:  MOVFF  01,2AB
0120C:  MOVLW  00
0120E:  MOVLB  2
01210:  BTFSC  01.5
01212:  MOVLW  01
01214:  XORLW  00
01216:  BZ    121C
01218:  MOVLW  00
0121A:  BRA    121E
0121C:  MOVLW  01
0121E:  MOVWF  01
01220:  MOVLB  0
01222:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE MACGet() 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Byte read from the ENC28J60's RAM 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACGet returns the byte pointed to by ERDPT and 
....................  *                  increments ERDPT so MACGet() can be called again.  The 
....................  *                  increment will follow the receive buffer wrapping boundary. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE MACGet() 
.................... { 
....................     BYTE Result; 
....................  
....................     ENC_CS_IO = 0; 
*
00F52:  BCF    F8C.1
....................    ClearSPIDoneFlag(); 
00F54:  BCF    F9E.3
....................  
....................     #if defined(__C32__) 
....................     { 
....................         // Send the opcode and read a byte in one 16-bit operation 
....................         ENC_SPICON1bits.MODE16 = 1; 
....................         ENC_SSPBUF = RBM<<8 | 0x00; // Send Read Buffer Memory command plus 8 dummy bits to generate clocks for the return result 
....................         WaitForDataByte();          // Wait until WORD is transmitted 
....................         ENC_SPICON1bits.MODE16 = 0; 
....................     } 
....................     #elif defined(__C30__) 
....................     { 
....................         // Send the opcode and read a byte in one 16-bit operation 
....................         ENC_SPISTATbits.SPIEN = 0; 
....................         ENC_SPICON1bits.MODE16 = 1; 
....................         ENC_SPISTATbits.SPIEN = 1; 
....................         ENC_SSPBUF = RBM<<8 | 0x00; // Send Read Buffer Memory command plus 8 dummy bits to generate clocks for the return result 
....................         WaitForDataByte();          // Wait until WORD is transmitted 
....................         ENC_SPISTATbits.SPIEN = 0; 
....................         ENC_SPICON1bits.MODE16 = 0; 
....................         ENC_SPISTATbits.SPIEN = 1; 
....................     } 
....................     #else 
....................     { 
....................         // Send the opcode and read a byte in two 8-bit operations 
....................         ENC_SSPBUF = RBM; 
00F56:  MOVLW  3A
00F58:  MOVWF  FC9
....................         WaitForDataByte();      // Wait until opcode/address is transmitted. 
00F5A:  BTFSS  F9E.3
00F5C:  BRA    0F5A
00F5E:  BCF    F9E.3
....................         Result = ENC_SSPBUF; 
00F60:  MOVFF  FC9,2B6
....................  
....................         ENC_SSPBUF = 0;         // Send a dummy byte to receive the register 
00F64:  CLRF   FC9
....................                                 //   contents. 
....................         WaitForDataByte();      // Wait until register is received. 
00F66:  BTFSS  F9E.3
00F68:  BRA    0F66
00F6A:  BCF    F9E.3
....................     } 
....................     #endif 
....................  
....................     Result = ENC_SSPBUF; 
00F6C:  MOVFF  FC9,2B6
....................     ENC_CS_IO = 1; 
00F70:  BSF    F8C.1
....................  
....................     return Result; 
00F72:  MOVLB  2
00F74:  MOVFF  2B6,01
00F78:  MOVLB  0
00F7A:  RETURN 0
.................... }//end MACGet 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           *val: Pointer to storage location 
....................  *                  len:  Number of bytes to read from the data buffer. 
....................  * 
....................  * Output:          Byte(s) of data read from the data buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Burst reads several sequential bytes from the data buffer 
....................  *                  and places them into local memory.  With SPI burst support, 
....................  *                  it performs much faster than multiple MACGet() calls. 
....................  *                  ERDPT is incremented after each byte, following the same 
....................  *                  rules as MACGet(). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetArray(BYTE *val, WORD len) 
.................... { 
.................... // Workaround needed on HPC Explorer (classic) board to prevent interference 
.................... // with I2C temperature sensor on the same SPI wires 
.................... #if defined(__18F8722) || defined(_18F8722) ||  defined(__18F8723) || defined(_18F8723) 
....................     WORD i; 
....................     volatile BYTE Dummy; 
....................  
....................     i = len; 
....................     Dummy = 0xFF; 
....................     ClearSPIDoneFlag(); 
....................     while(i--) 
....................     { 
....................         if(((BYTE_VAL*)&Dummy)->bits.b0) 
....................         { 
....................             // End bust operation 
....................             ENC_CS_IO = 1; 
....................             ((BYTE_VAL*)&Dummy)->bits.b0 = 0; 
....................  
....................             // Start the burst operation 
....................             ENC_CS_IO = 0; 
....................             ENC_SSPBUF = RBM;       // Send the Read Buffer Memory opcode. 
....................             WaitForDataByte();      // Wait until opcode/address is transmitted. 
....................         } 
....................         else 
....................             Dummy = 0xFF; 
....................  
....................         ENC_SSPBUF = 0;     // Send a dummy byte to receive a byte 
....................         if(val) 
....................         { 
....................             WaitForDataByte();  // Wait until byte is received. 
....................             *val++ = ENC_SSPBUF; 
....................         } 
....................         else 
....................         { 
....................             WaitForDataByte();  // Wait until byte is received. 
....................         } 
....................     } 
....................  
....................     ENC_CS_IO = 1; 
....................  
....................     return len; 
.................... #else 
....................     WORD i; 
....................     volatile BYTE Dummy; 
....................  
....................     // Start the burst operation 
....................     ENC_CS_IO = 0; 
*
00EDC:  BCF    F8C.1
....................     ClearSPIDoneFlag(); 
00EDE:  BCF    F9E.3
....................     ENC_SSPBUF = RBM;       // Send the Read Buffer Memory opcode. 
00EE0:  MOVLW  3A
00EE2:  MOVWF  FC9
....................     i = 0; 
00EE4:  MOVLB  2
00EE6:  CLRF   xC3
00EE8:  CLRF   xC2
....................     if(val) 
00EEA:  MOVF   xBE,W
00EEC:  IORWF  xBF,W
00EEE:  BZ    0EF8
....................         val--; 
00EF0:  MOVF   xBE,W
00EF2:  BTFSC  FD8.2
00EF4:  DECF   xBF,F
00EF6:  DECF   xBE,F
....................     WaitForDataByte();      // Wait until opcode/address is transmitted. 
00EF8:  BTFSS  F9E.3
00EFA:  BRA    0EF8
00EFC:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
00EFE:  MOVFF  FC9,2C4
....................  
....................     #if defined(__C32__) 
....................     { 
....................         DWORD_VAL dwv; 
....................  
....................         // Read the data, 4 bytes at a time, for as long as possible 
....................         if(len >= 4) 
....................         { 
....................             ENC_SPICON1bits.MODE32 = 1; 
....................             while(1) 
....................             { 
....................                 ENC_SSPBUF = 0x00000000;    // Send a dummy DWORD to generate 32 clocks 
....................                 i += 4; 
....................                 WaitForDataByte();         // Wait until DWORD is transmitted 
....................                 dwv.Val = ENC_SSPBUF; 
....................                 if(val) 
....................                 { 
....................                     *(++val) = dwv.v[3]; 
....................                     *(++val) = dwv.v[2]; 
....................                     *(++val) = dwv.v[1]; 
....................                     *(++val) = dwv.v[0]; 
....................                 } 
....................                 if(len - i < 4) 
....................                     break; 
....................             }; 
....................             ENC_SPICON1bits.MODE32 = 0; 
....................         } 
....................     } 
....................     #elif defined(__C30__) 
....................     { 
....................         WORD_VAL wv; 
....................  
....................         // Read the data, 2 bytes at a time, for as long as possible 
....................         if(len >= 2) 
....................         { 
....................             ENC_SPISTATbits.SPIEN = 0; 
....................             ENC_SPICON1bits.MODE16 = 1; 
....................             ENC_SPISTATbits.SPIEN = 1; 
....................             while(1) 
....................             { 
....................                 ENC_SSPBUF = 0x0000;    // Send a dummy WORD to generate 32 clocks 
....................                 i += 2; 
....................                 WaitForDataByte();      // Wait until WORD is transmitted 
....................                 wv.Val = ENC_SSPBUF; 
....................                 if(val) 
....................                 { 
....................                     *(++val) = wv.v[1]; 
....................                     *(++val) = wv.v[0]; 
....................                 } 
....................                 if(len - i < 2) 
....................                     break; 
....................             }; 
....................             ENC_SPISTATbits.SPIEN = 0; 
....................             ENC_SPICON1bits.MODE16 = 0; 
....................             ENC_SPISTATbits.SPIEN = 1; 
....................         } 
....................     } 
....................     #endif 
....................  
....................     // Read the data 
....................     while(i<len) 
00F02:  MOVF   xC3,W
00F04:  SUBWF  xC1,W
00F06:  BNC   0F44
00F08:  BNZ   0F10
00F0A:  MOVF   xC0,W
00F0C:  SUBWF  xC2,W
00F0E:  BC    0F44
....................     { 
....................         ENC_SSPBUF = 0;     // Send a dummy byte to receive a byte 
00F10:  CLRF   FC9
....................         i++; 
00F12:  INCF   xC2,F
00F14:  BTFSC  FD8.2
00F16:  INCF   xC3,F
....................         if(val) 
00F18:  MOVF   xBE,W
00F1A:  IORWF  xBF,W
00F1C:  BZ    0F38
....................         { 
....................             val++; 
00F1E:  INCF   xBE,F
00F20:  BTFSC  FD8.2
00F22:  INCF   xBF,F
....................             WaitForDataByte();  // Wait until byte is received. 
00F24:  BTFSS  F9E.3
00F26:  BRA    0F24
00F28:  BCF    F9E.3
....................             *val = ENC_SSPBUF; 
00F2A:  MOVFF  2BE,FE9
00F2E:  MOVFF  2BF,FEA
00F32:  MOVFF  FC9,FEF
....................         } 
00F36:  BRA    0F42
....................         else 
....................         { 
....................             WaitForDataByte();  // Wait until byte is received. 
00F38:  BTFSS  F9E.3
00F3A:  BRA    0F38
00F3C:  BCF    F9E.3
....................             Dummy = ENC_SSPBUF; 
00F3E:  MOVFF  FC9,2C4
....................         } 
00F42:  BRA    0F02
....................     }; 
....................  
....................     // Terminate the burst operation 
....................     ENC_CS_IO = 1; 
00F44:  BSF    F8C.1
....................  
....................     return i; 
00F46:  MOVFF  2C2,01
00F4A:  MOVFF  2C3,02
.................... #endif 
00F4E:  MOVLB  0
00F50:  RETURN 0
.................... }//end MACGetArray 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPut(BYTE val) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           Byte to write into the ENC28J60 buffer memory 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPut outputs the Write Buffer Memory opcode/constant 
....................  *                  (8 bits) and data to write (8 bits) over the SPI. 
....................  *                  EWRPT is incremented after the write. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPut(BYTE val) 
.................... { 
....................     volatile BYTE Dummy; 
....................  
....................     ENC_CS_IO = 0; 
*
0096E:  BCF    F8C.1
....................     ClearSPIDoneFlag(); 
00970:  BCF    F9E.3
....................  
....................     #if defined(__C32__) 
....................     { 
....................         // Send the Write Buffer Memory and data, in on 16-bit write 
....................         ENC_SPICON1bits.MODE16 = 1; 
....................         ENC_SSPBUF = (WBM<<8) | (WORD)val;  // Start sending the WORD 
....................         WaitForDataByte();                  // Wait until WORD is transmitted 
....................         ENC_SPICON1bits.MODE16 = 0; 
....................     } 
....................     #elif defined(__C30__) 
....................     { 
....................         // Send the Write Buffer Memory and data, in on 16-bit write 
....................         ENC_SPISTATbits.SPIEN = 0; 
....................         ENC_SPICON1bits.MODE16 = 1; 
....................         ENC_SPISTATbits.SPIEN = 1; 
....................         ENC_SSPBUF = (WBM<<8) | (WORD)val;  // Start sending the WORD 
....................         WaitForDataByte();                  // Wait until WORD is transmitted 
....................         ENC_SPISTATbits.SPIEN = 0; 
....................         ENC_SPICON1bits.MODE16 = 0; 
....................         ENC_SPISTATbits.SPIEN = 1; 
....................     } 
....................     #else 
....................     { 
....................         ENC_SSPBUF = WBM;       // Send the opcode and constant. 
00972:  MOVLW  7A
00974:  MOVWF  FC9
....................         WaitForDataByte();      // Wait until opcode/constant is transmitted. 
00976:  BTFSS  F9E.3
00978:  BRA    0976
0097A:  BCF    F9E.3
....................         Dummy = ENC_SSPBUF; 
0097C:  MOVFF  FC9,2C0
....................         ENC_SSPBUF = val;       // Send the byte to be writen. 
00980:  MOVFF  2BF,FC9
....................         WaitForDataByte();      // Wait until finished transmitting 
00984:  BTFSS  F9E.3
00986:  BRA    0984
00988:  BCF    F9E.3
....................     } 
....................     #endif 
....................  
....................     Dummy = ENC_SSPBUF; 
0098A:  MOVFF  FC9,2C0
....................     ENC_CS_IO = 1; 
0098E:  BSF    F8C.1
00990:  RETURN 0
.................... }//end MACPut 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPutArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           *val: Pointer to source of bytes to copy. 
....................  *                  len:  Number of bytes to write to the data buffer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPutArray writes several sequential bytes to the 
....................  *                  ENC28J60 RAM.  It performs faster than multiple MACPut() 
....................  *                  calls.  EWRPT is incremented by len. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPutArray(BYTE *val, WORD len) 
.................... { 
.................... // Workaround needed on HPC Explorer (classic) board to prevent interference 
.................... // with I2C temperature sensor on the same SPI wires 
.................... #if defined(__18F8722) || defined(_18F8722) ||  defined(__18F8723) || defined(_18F8723) 
....................     WORD i; 
....................     volatile BYTE Dummy; 
....................  
....................     i = len; 
....................     Dummy = 0xFF; 
....................     ClearSPIDoneFlag(); 
....................     while(i--) 
....................     { 
....................         if(((BYTE_VAL*)&Dummy)->bits.b0) 
....................         { 
....................             // End bust operation 
....................             ENC_CS_IO = 1; 
....................             ((BYTE_VAL*)&Dummy)->bits.b0 = 0; 
....................  
....................             // Start the burst operation 
....................             ENC_CS_IO = 0; 
....................             ENC_SSPBUF = WBM;       // Send the Read Buffer Memory opcode. 
....................             WaitForDataByte();      // Wait until opcode/address is transmitted. 
....................         } 
....................         else 
....................             Dummy = 0xFF; 
....................  
....................         ENC_SSPBUF = *val++;    // Send byte 
....................         WaitForDataByte();      // Wait until byte is sent 
....................     } 
....................  
....................     ENC_CS_IO = 1; 
....................  
....................     return; 
.................... #else 
....................     volatile BYTE Dummy; 
....................  
....................     // Select the chip and send the proper opcode 
....................     ENC_CS_IO = 0; 
*
00E2A:  BCF    F8C.1
....................     ClearSPIDoneFlag(); 
00E2C:  BCF    F9E.3
....................     ENC_SSPBUF = WBM;       // Send the Write Buffer Memory opcode 
00E2E:  MOVLW  7A
00E30:  MOVWF  FC9
....................     WaitForDataByte();      // Wait until opcode/constant is transmitted. 
00E32:  BTFSS  F9E.3
00E34:  BRA    0E32
00E36:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
00E38:  MOVFF  FC9,2C4
....................  
....................     #if defined(__C32__) 
....................     { 
....................         DWORD_VAL dwv; 
....................  
....................         // Send the data, 4 bytes at a time, for as long as possible 
....................         if(len >= 4) 
....................         { 
....................             dwv.v[3] = *val++; 
....................             dwv.v[2] = *val++; 
....................             dwv.v[1] = *val++; 
....................             dwv.v[0] = *val++; 
....................             ENC_SPICON1bits.MODE32 = 1; 
....................             while(1) 
....................             { 
....................                 ENC_SSPBUF = dwv.Val;       // Start sending the DWORD 
....................                 len -= 4; 
....................                 if(len < 4) 
....................                     break; 
....................                 dwv.v[3] = *val++; 
....................                 dwv.v[2] = *val++; 
....................                 dwv.v[1] = *val++; 
....................                 dwv.v[0] = *val++; 
....................                 WaitForDataByte();          // Wait until DWORD is transmitted 
....................                 Dummy = ENC_SSPBUF; 
....................             }; 
....................             WaitForDataByte();              // Wait until DWORD is transmitted 
....................             Dummy = ENC_SSPBUF; 
....................             ENC_SPICON1bits.MODE32 = 0; 
....................         } 
....................     } 
....................     #elif defined(__C30__) 
....................     { 
....................         WORD_VAL wv; 
....................  
....................         // Send the data, 2 bytes at a time, for as long as possible 
....................         if(len >= 2) 
....................         { 
....................             wv.v[1] = *val++; 
....................             wv.v[0] = *val++; 
....................             ENC_SPISTATbits.SPIEN = 0; 
....................             ENC_SPICON1bits.MODE16 = 1; 
....................             ENC_SPISTATbits.SPIEN = 1; 
....................             while(1) 
....................             { 
....................                 ENC_SSPBUF = wv.Val;        // Start sending the WORD 
....................                 len -= 2; 
....................                 if(len < 2) 
....................                     break; 
....................                 wv.v[1] = *val++; 
....................                 wv.v[0] = *val++; 
....................                 WaitForDataByte();          // Wait until WORD is transmitted 
....................                 Dummy = ENC_SSPBUF; 
....................             }; 
....................             WaitForDataByte();              // Wait until WORD is transmitted 
....................             Dummy = ENC_SSPBUF; 
....................             ENC_SPISTATbits.SPIEN = 0; 
....................             ENC_SPICON1bits.MODE16 = 0; 
....................             ENC_SPISTATbits.SPIEN = 1; 
....................         } 
....................     } 
....................     #endif 
....................  
....................     // Send the data, one byte at a time 
....................     while(len) 
00E3C:  MOVLB  2
00E3E:  MOVF   xC2,W
00E40:  IORWF  xC3,W
00E42:  BZ    0E6A
....................     { 
....................         ENC_SSPBUF = *val;  // Start sending the byte 
00E44:  MOVFF  2C0,FE9
00E48:  MOVFF  2C1,FEA
00E4C:  MOVFF  FEF,FC9
....................         val++;              // Increment after writing to ENC_SSPBUF to increase speed 
00E50:  INCF   xC0,F
00E52:  BTFSC  FD8.2
00E54:  INCF   xC1,F
....................         len--;              // Decrement after writing to ENC_SSPBUF to increase speed 
00E56:  MOVF   xC2,W
00E58:  BTFSC  FD8.2
00E5A:  DECF   xC3,F
00E5C:  DECF   xC2,F
....................         WaitForDataByte();  // Wait until byte is transmitted 
00E5E:  BTFSS  F9E.3
00E60:  BRA    0E5E
00E62:  BCF    F9E.3
....................         Dummy = ENC_SSPBUF; 
00E64:  MOVFF  FC9,2C4
00E68:  BRA    0E3E
....................     }; 
....................  
....................     // Terminate the burst operation 
....................     ENC_CS_IO = 1; 
00E6A:  BSF    F8C.1
.................... #endif 
00E6C:  MOVLB  0
00E6E:  RETURN 0
.................... }//end MACPutArray 
....................  
....................  
.................... #if defined(__18CXX) 
.................... /****************************************************************************** 
....................  * Function:        void MACPutROMArray(ROM BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           *val: Pointer to source of bytes to copy. 
....................  *                  len:  Number of bytes to write to the data buffer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPutArray writes several sequential bytes to the 
....................  *                  ENC28J60 RAM.  It performs faster than multiple MACPut() 
....................  *                  calls.  EWRPT is incremented by len. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPutROMArray(ROM BYTE *val, WORD len) 
.................... { 
.................... // Workaround needed on HPC Explorer (classic) board to prevent interference 
.................... // with I2C temperature sensor on the same SPI wires 
.................... #if defined(__18F8722) || defined(_18F8722) ||  defined(__18F8723) || defined(_18F8723) 
....................     WORD i; 
....................     volatile BYTE Dummy; 
....................  
....................     i = len; 
....................     Dummy = 0xFF; 
....................     ClearSPIDoneFlag(); 
....................     while(i--) 
....................     { 
....................         if(((BYTE_VAL*)&Dummy)->bits.b0) 
....................         { 
....................             // End bust operation 
....................             ENC_CS_IO = 1; 
....................             ((BYTE_VAL*)&Dummy)->bits.b0 = 0; 
....................  
....................             // Start the burst operation 
....................             ENC_CS_IO = 0; 
....................             ENC_SSPBUF = WBM;       // Send the Read Buffer Memory opcode. 
....................             WaitForDataByte();      // Wait until opcode/address is transmitted. 
....................         } 
....................         else 
....................             Dummy = 0xFF; 
....................  
....................         ENC_SSPBUF = *val++;    // Send byte 
....................         WaitForDataByte();      // Wait until byte is sent 
....................     } 
....................  
....................     ENC_CS_IO = 1; 
....................  
....................     return; 
.................... #else 
....................     volatile BYTE Dummy; 
....................  
....................     // Select the chip and send the proper opcode 
....................     ENC_CS_IO = 0; 
....................     ClearSPIDoneFlag(); 
....................     ENC_SSPBUF = WBM;       // Send the Write Buffer Memory opcode 
....................     WaitForDataByte();      // Wait until opcode/constant is transmitted. 
....................     Dummy = ENC_SSPBUF; 
....................  
....................     // Send the data 
....................     while(len) 
....................     { 
....................         ENC_SSPBUF = *val;  // Start sending the byte 
....................         val++;              // Increment after writing to ENC_SSPBUF to increase speed 
....................         len--;              // Decrement after writing to ENC_SSPBUF to increase speed 
....................         WaitForDataByte();  // Wait until byte is transmitted 
....................         Dummy = ENC_SSPBUF; 
....................     }; 
....................  
....................     // Terminate the burst operation 
....................     ENC_CS_IO = 1; 
.................... #endif 
.................... }//end MACPutROMArray 
.................... #endif 
....................  
.................... /****************************************************************************** 
....................  * Function:        static void SendSystemReset(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SendSystemReset sends the System Reset SPI command to 
....................  *                  the Ethernet controller.  It resets all register contents 
....................  *                  (except for ECOCON) and returns the device to the power 
....................  *                  on default state. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void SendSystemReset(void) 
.................... { 
....................     volatile BYTE Dummy; 
....................  
....................     // Note: The power save feature may prevent the reset from executing, so 
....................     // we must make sure that the device is not in power save before issuing 
....................     // a reset. 
....................     BFCReg(ECON2, ECON2_PWRSV); 
*
008E2:  MOVLW  1E
008E4:  MOVLB  2
008E6:  MOVWF  xB6
008E8:  MOVLW  20
008EA:  MOVWF  xB7
008EC:  MOVLB  0
008EE:  RCALL  08B8
....................  
....................     // Give some opportunity for the regulator to reach normal regulation and 
....................     // have all clocks running 
....................     DelayMs(1); 
008F0:  MOVLW  01
008F2:  MOVLB  1
008F4:  MOVWF  x71
008F6:  MOVLB  0
008F8:  RCALL  037E
....................  
....................     // Execute the System Reset command 
....................     ENC_CS_IO = 0; 
008FA:  BCF    F8C.1
....................     ClearSPIDoneFlag(); 
008FC:  BCF    F9E.3
....................     ENC_SSPBUF = SR; 
008FE:  SETF   FC9
....................     WaitForDataByte();      // Wait until the command is transmitted. 
00900:  BTFSS  F9E.3
00902:  BRA    0900
00904:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
00906:  MOVFF  FC9,16D
....................     ENC_CS_IO = 1; 
0090A:  BSF    F8C.1
....................  
....................     // Wait for the oscillator start up timer and PHY to become ready 
....................     DelayMs(1); 
0090C:  MOVLW  01
0090E:  MOVLB  1
00910:  MOVWF  x71
00912:  MOVLB  0
00914:  RCALL  037E
00916:  GOTO   0ADE (RETURN)
.................... }//end SendSystemReset 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadETHReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  Bank select bits must be set corresponding to the register 
....................  *                  to read from. 
....................  * 
....................  * Input:           5 bit address of the ETH control register to read from. 
....................  *                    The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's ETH register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadETHReg sends the 8 bit RCR opcode/Address byte over 
....................  *                  the SPI and then retrives the register contents in the 
....................  *                  next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access MAC/MII or PHY 
....................  *                  registers.  Use ReadMACReg() or ReadPHYReg() for that 
....................  *                  purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadETHReg(BYTE Address) 
.................... { 
....................     REG r; 
....................  
....................     // Select the chip and send the Read Control Register opcode/address 
....................     ENC_CS_IO = 0; 
0091A:  BCF    F8C.1
....................     ClearSPIDoneFlag(); 
0091C:  BCF    F9E.3
....................     ENC_SSPBUF = RCR | Address; 
0091E:  MOVLB  2
00920:  MOVFF  2BC,FC9
....................  
....................     WaitForDataByte();      // Wait until the opcode/address is transmitted 
00924:  BTFSS  F9E.3
00926:  BRA    0924
00928:  BCF    F9E.3
....................     r.Val = ENC_SSPBUF; 
0092A:  MOVFF  FC9,2BD
....................     ENC_SSPBUF = 0;         // Send a dummy byte to receive the register 
0092E:  CLRF   FC9
....................                             //   contents 
....................     WaitForDataByte();      // Wait until the register is received 
00930:  BTFSS  F9E.3
00932:  BRA    0930
00934:  BCF    F9E.3
....................     r.Val = ENC_SSPBUF; 
00936:  MOVFF  FC9,2BD
....................     ENC_CS_IO = 1; 
0093A:  BSF    F8C.1
....................  
....................     return r; 
0093C:  MOVFF  2BD,01
00940:  MOVLB  0
00942:  RETURN 0
.................... }//end ReadETHReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadMACReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  Bank select bits must be set corresponding to the register 
....................  *                  to read from. 
....................  * 
....................  * Input:           5 bit address of the MAC or MII register to read from. 
....................  *                    The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's MAC/MII register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadMACReg sends the 8 bit RCR opcode/Address byte as well 
....................  *                  as a dummy byte over the SPI and then retrives the 
....................  *                  register contents in the last 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access ETH or PHY 
....................  *                  registers.  Use ReadETHReg() or ReadPHYReg() for that 
....................  *                  purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadMACReg(BYTE Address) 
.................... { 
....................     REG r; 
....................  
....................     ENC_CS_IO = 0; 
*
009F2:  BCF    F8C.1
....................     ClearSPIDoneFlag(); 
009F4:  BCF    F9E.3
....................     ENC_SSPBUF = RCR | Address; // Send the Read Control Register opcode and 
009F6:  MOVLB  1
009F8:  MOVFF  170,FC9
....................                                 //   address. 
....................     WaitForDataByte();          // Wait until opcode/address is transmitted. 
009FC:  BTFSS  F9E.3
009FE:  BRA    09FC
00A00:  BCF    F9E.3
....................     r.Val = ENC_SSPBUF; 
00A02:  MOVFF  FC9,171
....................     ENC_SSPBUF = 0;             // Send a dummy byte 
00A06:  CLRF   FC9
....................     WaitForDataByte();          // Wait for the dummy byte to be transmitted 
00A08:  BTFSS  F9E.3
00A0A:  BRA    0A08
00A0C:  BCF    F9E.3
....................     r.Val = ENC_SSPBUF; 
00A0E:  MOVFF  FC9,171
....................     ENC_SSPBUF = 0;             // Send another dummy byte to receive the register 
00A12:  CLRF   FC9
....................                                 //   contents. 
....................     WaitForDataByte();          // Wait until register is received. 
00A14:  BTFSS  F9E.3
00A16:  BRA    0A14
00A18:  BCF    F9E.3
....................     r.Val = ENC_SSPBUF; 
00A1A:  MOVFF  FC9,171
....................     ENC_CS_IO = 1; 
00A1E:  BSF    F8C.1
....................  
....................     return r; 
00A20:  MOVFF  171,01
00A24:  MOVLB  0
00A26:  RETURN 0
.................... }//end ReadMACReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        ReadPHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to read from. 
....................  * 
....................  * Output:          16 bits of data read from the PHY register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadPHYReg performs an MII read operation.  While in 
....................  *                  progress, it simply polls the MII BUSY bit wasting time 
....................  *                  (10.24us). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PHYREG ReadPHYReg(BYTE Register) 
.................... { 
....................     PHYREG Result; 
....................  
....................     // Set the right address and start the register read operation 
....................     BankSel(MIREGADR); 
*
0168C:  MOVLW  02
0168E:  MOVLB  2
01690:  MOVWF  xA1
01692:  MOVLW  14
01694:  MOVWF  xA0
01696:  MOVLB  0
01698:  CALL   09BC
....................     WriteReg((BYTE)MIREGADR, Register); 
0169C:  MOVLW  14
0169E:  MOVLB  2
016A0:  MOVWF  xC1
016A2:  MOVFF  16C,2C2
016A6:  MOVLB  0
016A8:  CALL   0944
....................     WriteReg((BYTE)MICMD, MICMD_MIIRD); 
016AC:  MOVLW  12
016AE:  MOVLB  2
016B0:  MOVWF  xC1
016B2:  MOVLW  01
016B4:  MOVWF  xC2
016B6:  MOVLB  0
016B8:  CALL   0944
....................  
....................     // Loop to wait until the PHY register has been read through the MII 
....................     // This requires 10.24us 
....................     BankSel(MISTAT); 
016BC:  MOVLW  03
016BE:  MOVLB  2
016C0:  MOVWF  xA1
016C2:  MOVLW  0A
016C4:  MOVWF  xA0
016C6:  MOVLB  0
016C8:  CALL   09BC
....................     while(ReadMACReg((BYTE)MISTAT).MISTATbits.BUSY); 
016CC:  MOVLW  0A
016CE:  MOVLB  1
016D0:  MOVWF  x70
016D2:  MOVLB  0
016D4:  CALL   09F2
016D8:  MOVFF  01,16F
016DC:  MOVLW  00
016DE:  MOVLB  1
016E0:  BTFSC  01.0
016E2:  MOVLW  01
016E4:  XORLW  00
016E6:  BTFSC  FD8.2
016E8:  BRA    16EE
016EA:  MOVLB  0
016EC:  BRA    16CC
....................  
....................     // Stop reading 
....................     BankSel(MIREGADR); 
016EE:  MOVLW  02
016F0:  MOVLB  2
016F2:  MOVWF  xA1
016F4:  MOVLW  14
016F6:  MOVWF  xA0
016F8:  MOVLB  0
016FA:  CALL   09BC
....................     WriteReg((BYTE)MICMD, 0x00); 
016FE:  MOVLW  12
01700:  MOVLB  2
01702:  MOVWF  xC1
01704:  CLRF   xC2
01706:  MOVLB  0
01708:  CALL   0944
....................  
....................     // Obtain results and return 
....................     Result.VAL.v[0] = ReadMACReg((BYTE)MIRDL).Val; 
0170C:  MOVLW  18
0170E:  MOVLB  1
01710:  MOVWF  x70
01712:  MOVLB  0
01714:  CALL   09F2
01718:  MOVFF  01,16D
....................     Result.VAL.v[1] = ReadMACReg((BYTE)MIRDH).Val; 
0171C:  MOVLW  19
0171E:  MOVLB  1
01720:  MOVWF  x70
01722:  MOVLB  0
01724:  CALL   09F2
01728:  MOVFF  01,16E
....................  
....................     BankSel(ERDPTL);    // Return to Bank 0 
0172C:  MOVLB  2
0172E:  CLRF   xA1
01730:  CLRF   xA0
01732:  MOVLB  0
01734:  CALL   09BC
....................     return Result; 
01738:  MOVLB  1
0173A:  MOVFF  16D,01
0173E:  MOVFF  16E,02
01742:  MOVLB  0
01744:  GOTO   1752 (RETURN)
.................... }//end ReadPHYReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void WriteReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  Bank select bits must be set corresponding to the register 
....................  *                  to modify. 
....................  * 
....................  * Input:           5 bit address of the ETH, MAC, or MII register to modify. 
....................  *                    The top 3 bits must be 0. 
....................  *                  Byte to be written into the register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        WriteReg sends the 8 bit WCR opcode/Address byte over the 
....................  *                  SPI and then sends the data to write in the next 8 SPI 
....................  *                  clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the BFCReg() and 
....................  *                  BFSReg() functions.  It is seperate to maximize speed. 
....................  *                  Unlike the ReadETHReg/ReadMACReg functions, WriteReg() 
....................  *                  can write to any ETH or MAC register.  Writing to PHY 
....................  *                  registers must be accomplished with WritePHYReg(). 
....................  *****************************************************************************/ 
.................... static void WriteReg(BYTE Address, BYTE Data) 
.................... { 
....................     volatile BYTE Dummy; 
....................  
....................     ENC_CS_IO = 0; 
*
00944:  BCF    F8C.1
....................     ClearSPIDoneFlag(); 
00946:  BCF    F9E.3
....................  
....................     #if defined(__C32__) 
....................     { 
....................         // Send the Write Buffer Memory and data, in on 16-bit write 
....................         ENC_SPICON1bits.MODE16 = 1; 
....................         ENC_SSPBUF = ((WCR | Address)<<8) | (WORD)Data; // Start sending the WORD 
....................         WaitForDataByte();                  // Wait until WORD is transmitted 
....................         ENC_SPICON1bits.MODE16 = 0; 
....................     } 
....................     #else 
....................     { 
....................         ENC_SSPBUF = WCR | Address; // Send the opcode and address. 
00948:  MOVLB  2
0094A:  MOVF   xC1,W
0094C:  IORLW  40
0094E:  MOVWF  FC9
....................         WaitForDataByte();          // Wait until opcode/constant is transmitted. 
00950:  BTFSS  F9E.3
00952:  BRA    0950
00954:  BCF    F9E.3
....................         Dummy = ENC_SSPBUF; 
00956:  MOVFF  FC9,2C3
....................         ENC_SSPBUF = Data;          // Send the byte to be writen. 
0095A:  MOVFF  2C2,FC9
....................         WaitForDataByte();          // Wait until finished transmitting 
0095E:  BTFSS  F9E.3
00960:  BRA    095E
00962:  BCF    F9E.3
....................     } 
....................     #endif 
....................  
....................     Dummy = ENC_SSPBUF; 
00964:  MOVFF  FC9,2C3
....................  
....................  
....................    // For faster processors (dsPIC), delay for a few clock cycles to ensure  
....................    // the MAC/MII register write Chip Select hold time minimum of 210ns is met. 
....................    #if (GetInstructionClock() > 30000000) 
....................       Nop(); 
....................       Nop(); 
....................    #endif 
....................    #if (GetInstructionClock() > 40000000) 
....................       Nop(); 
....................       Nop(); 
....................    #endif 
....................    #if (GetInstructionClock() > 50000000) 
....................       Nop(); 
....................       Nop(); 
....................    #endif 
....................  
....................    ENC_CS_IO = 1; 
00968:  BSF    F8C.1
0096A:  MOVLB  0
0096C:  RETURN 0
.................... }//end WriteReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFCReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  Bank select bits must be set corresponding to the register 
....................  *                    to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                    must be 0. 
....................  *                  Byte to be used with the Bit Field Clear operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFCReg sends the 8 bit BFC opcode/Address byte over the 
....................  *                  SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *                  BFSReg() functions.  It is separate to maximize speed. 
....................  *                  BFCReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFCReg(BYTE Address, BYTE Data) 
.................... { 
....................     volatile BYTE Dummy; 
....................  
....................     ENC_CS_IO = 0; 
*
008B8:  BCF    F8C.1
....................     ClearSPIDoneFlag(); 
008BA:  BCF    F9E.3
....................     ENC_SSPBUF = BFC | Address; // Send the opcode and address. 
008BC:  MOVLB  2
008BE:  MOVF   xB6,W
008C0:  IORLW  A0
008C2:  MOVWF  FC9
....................     WaitForDataByte();          // Wait until opcode/address is transmitted. 
008C4:  BTFSS  F9E.3
008C6:  BRA    08C4
008C8:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
008CA:  MOVFF  FC9,2B8
....................     ENC_SSPBUF = Data;          // Send the byte to be writen. 
008CE:  MOVFF  2B7,FC9
....................     WaitForDataByte();          // Wait until register is written. 
008D2:  BTFSS  F9E.3
008D4:  BRA    08D2
008D6:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
008D8:  MOVFF  FC9,2B8
....................     ENC_CS_IO = 1; 
008DC:  BSF    F8C.1
008DE:  MOVLB  0
008E0:  RETURN 0
.................... }//end BFCReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFSReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  Bank select bits must be set corresponding to the register 
....................  *                  to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                    must be 0. 
....................  *                  Byte to be used with the Bit Field Set operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFSReg sends the 8 bit BFC opcode/Address byte over the 
....................  *                  SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *                  BFCReg() functions.  It is separate to maximize speed. 
....................  *                  BFSReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFSReg(BYTE Address, BYTE Data) 
.................... { 
....................     volatile BYTE Dummy; 
....................  
....................     ENC_CS_IO = 0; 
*
00992:  BCF    F8C.1
....................     ClearSPIDoneFlag(); 
00994:  BCF    F9E.3
....................     ENC_SSPBUF = BFS | Address; // Send the opcode and address. 
00996:  MOVLB  2
00998:  MOVF   xB6,W
0099A:  IORLW  80
0099C:  MOVWF  FC9
....................     WaitForDataByte();          // Wait until opcode/address is transmitted. 
0099E:  BTFSS  F9E.3
009A0:  BRA    099E
009A2:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
009A4:  MOVFF  FC9,2B8
....................     ENC_SSPBUF = Data;          // Send the byte to be writen. 
009A8:  MOVFF  2B7,FC9
....................     WaitForDataByte();          // Wait until register is written. 
009AC:  BTFSS  F9E.3
009AE:  BRA    09AC
009B0:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
009B2:  MOVFF  FC9,2B8
....................     ENC_CS_IO = 1; 
009B6:  BSF    F8C.1
009B8:  MOVLB  0
009BA:  RETURN 0
.................... }//end BFSReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WritePHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to write to. 
....................  *                  16 bits of data to write to PHY register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 3 
....................  * 
....................  * Overview:        WritePHYReg performs an MII write operation.  While in 
....................  *                  progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void WritePHYReg(BYTE Register, WORD Data) 
.................... { 
....................     // Write the register address 
....................     BankSel(MIREGADR); 
*
00A28:  MOVLW  02
00A2A:  MOVLB  2
00A2C:  MOVWF  xA1
00A2E:  MOVLW  14
00A30:  MOVWF  xA0
00A32:  MOVLB  0
00A34:  RCALL  09BC
....................     WriteReg((BYTE)MIREGADR, Register); 
00A36:  MOVLW  14
00A38:  MOVLB  2
00A3A:  MOVWF  xC1
00A3C:  MOVFF  16D,2C2
00A40:  MOVLB  0
00A42:  RCALL  0944
....................  
....................     // Write the data 
....................     // Order is important: write low byte first, high byte last 
....................     WriteReg((BYTE)MIWRL, ((WORD_VAL*)&Data)->v[0]); 
00A44:  MOVLW  01
00A46:  MOVLB  1
00A48:  MOVWF  x71
00A4A:  MOVLW  6E
00A4C:  MOVWF  x70
00A4E:  MOVWF  FE9
00A50:  MOVFF  171,FEA
00A54:  MOVFF  FEF,172
00A58:  MOVLW  16
00A5A:  MOVLB  2
00A5C:  MOVWF  xC1
00A5E:  MOVFF  172,2C2
00A62:  MOVLB  0
00A64:  RCALL  0944
....................     WriteReg((BYTE)MIWRH, ((WORD_VAL*)&Data)->v[1]); 
00A66:  MOVLW  01
00A68:  MOVLB  1
00A6A:  MOVWF  x71
00A6C:  MOVLW  6E
00A6E:  MOVWF  x70
00A70:  MOVLW  01
00A72:  ADDWF  x70,W
00A74:  MOVWF  FE9
00A76:  MOVLW  00
00A78:  ADDWFC x71,W
00A7A:  MOVWF  FEA
00A7C:  MOVFF  FEF,172
00A80:  MOVLW  17
00A82:  MOVLB  2
00A84:  MOVWF  xC1
00A86:  MOVFF  172,2C2
00A8A:  MOVLB  0
00A8C:  RCALL  0944
....................  
....................     // Wait until the PHY register has been written 
....................     BankSel(MISTAT); 
00A8E:  MOVLW  03
00A90:  MOVLB  2
00A92:  MOVWF  xA1
00A94:  MOVLW  0A
00A96:  MOVWF  xA0
00A98:  MOVLB  0
00A9A:  RCALL  09BC
....................     while(ReadMACReg((BYTE)MISTAT).MISTATbits.BUSY); 
00A9C:  MOVLW  0A
00A9E:  MOVLB  1
00AA0:  MOVWF  x70
00AA2:  MOVLB  0
00AA4:  RCALL  09F2
00AA6:  MOVFF  01,170
00AAA:  MOVLW  00
00AAC:  MOVLB  1
00AAE:  BTFSC  01.0
00AB0:  MOVLW  01
00AB2:  XORLW  00
00AB4:  BTFSC  FD8.2
00AB6:  BRA    0ABC
00AB8:  MOVLB  0
00ABA:  BRA    0A9C
....................  
....................     BankSel(ERDPTL);    // Return to Bank 0 
00ABC:  MOVLB  2
00ABE:  CLRF   xA1
00AC0:  CLRF   xA0
00AC2:  MOVLB  0
00AC4:  RCALL  09BC
00AC6:  RETURN 0
.................... }//end WritePHYReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BankSel 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Register address with the high byte containing the 2 bank 
....................  *                    select 2 bits. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BankSel takes the high byte of a register address and 
....................  *                  changes the bank select bits in ETHCON1 to match. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void BankSel(WORD Register) 
.................... { 
....................     BFCReg(ECON1, ECON1_BSEL1 | ECON1_BSEL0); 
*
009BC:  MOVLW  1F
009BE:  MOVLB  2
009C0:  MOVWF  xB6
009C2:  MOVLW  03
009C4:  MOVWF  xB7
009C6:  MOVLB  0
009C8:  RCALL  08B8
....................     BFSReg(ECON1, ((WORD_VAL*)&Register)->v[1]); 
009CA:  MOVLW  02
009CC:  MOVLB  2
009CE:  MOVWF  xA3
009D0:  MOVLW  A0
009D2:  MOVWF  xA2
009D4:  MOVLW  01
009D6:  ADDWF  xA2,W
009D8:  MOVWF  FE9
009DA:  MOVLW  00
009DC:  ADDWFC xA3,W
009DE:  MOVWF  FEA
009E0:  MOVFF  FEF,2A4
009E4:  MOVLW  1F
009E6:  MOVWF  xB6
009E8:  MOVFF  2A4,2B7
009EC:  MOVLB  0
009EE:  RCALL  0992
009F0:  RETURN 0
.................... }//end BankSel 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerDown(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerDown puts the ENC28J60 in low power sleep mode. In 
....................  *                  sleep mode, no packets can be transmitted or received. 
....................  *                  All MAC and PHY registers should not be accessed. 
....................  * 
....................  * Note:            If a packet is being transmitted while this function is 
....................  *                  called, this function will block until it is it complete. 
....................  *                  If anything is being received, it will be completed. 
....................  *****************************************************************************/ 
.................... void MACPowerDown(void) 
.................... { 
....................     // Disable packet reception 
....................     BFCReg(ECON1, ECON1_RXEN); 
....................  
....................     // Make sure any last packet which was in-progress when RXEN was cleared 
....................     // is completed 
....................     while(ReadETHReg(ESTAT).ESTATbits.RXBUSY); 
....................  
....................     // If a packet is being transmitted, wait for it to finish 
....................     while(ReadETHReg(ECON1).ECON1bits.TXRTS); 
....................  
....................     // Enter sleep mode 
....................     BFSReg(ECON2, ECON2_PWRSV); 
.................... }//end MACPowerDown 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerUp(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerUp returns the ENC28J60 back to normal operation 
....................  *                  after a previous call to MACPowerDown().  Calling this 
....................  *                  function when already powered up will have no effect. 
....................  * 
....................  * Note:            If a link partner is present, it will take 10s of 
....................  *                  milliseconds before a new link will be established after 
....................  *                  waking up.  While not linked, packets which are 
....................  *                  transmitted will most likely be lost.  MACIsLinked() can 
....................  *                  be called to determine if a link is established. 
....................  *****************************************************************************/ 
.................... void MACPowerUp(void) 
.................... { 
....................     // Leave power down mode 
....................     BFCReg(ECON2, ECON2_PWRSV); 
....................  
....................     // Wait for the 300us Oscillator Startup Timer (OST) to time out.  This 
....................     // delay is required for the PHY module to return to an operational state. 
....................     while(!ReadETHReg(ESTAT).ESTATbits.CLKRDY); 
....................  
....................     // Enable packet reception 
....................     BFSReg(ECON1, ECON1_RXEN); 
.................... }//end MACPowerUp 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void SetCLKOUT(BYTE NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - 0x00: CLKOUT disabled (pin driven low) 
....................  *                              0x01: Divide by 1 (25 MHz) 
....................  *                              0x02: Divide by 2 (12.5 MHz) 
....................  *                              0x03: Divide by 3 (8.333333 MHz) 
....................  *                              0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                              0x05: Divide by 8 (3.125 MHz) 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the ECOCON register. 
....................  *                  The CLKOUT pin will beginning outputting the new frequency 
....................  *                  immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... void SetCLKOUT(BYTE NewConfig) 
.................... { 
....................     BankSel(ECOCON); 
....................     WriteReg((BYTE)ECOCON, NewConfig); 
....................     BankSel(ERDPTL); 
.................... }//end SetCLKOUT 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE GetCLKOUT(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          BYTE - 0x00: CLKOUT disabled (pin driven low) 
....................  *                         0x01: Divide by 1 (25 MHz) 
....................  *                         0x02: Divide by 2 (12.5 MHz) 
....................  *                         0x03: Divide by 3 (8.333333 MHz) 
....................  *                         0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                         0x05: Divide by 8 (3.125 MHz) 
....................  *                         0x06: Reserved 
....................  *                         0x07: Reserved 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the ECOCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE GetCLKOUT(void) 
.................... { 
....................     BYTE i; 
....................  
....................     BankSel(ECOCON); 
....................     i = ReadETHReg((BYTE)ECOCON).Val; 
....................     BankSel(ERDPTL); 
....................     return i; 
.................... }//end GetCLKOUT 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void SetRXHashTableEntry(MAC_ADDR DestMACAddr) 
....................  * 
....................  * PreCondition:    SPI interface must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           DestMACAddr: 6 byte group destination MAC address to allow  
....................  *                         through the Hash Table Filter.  If DestMACAddr  
....................  *                         is set to 00-00-00-00-00-00, then the hash  
....................  *                         table will be cleared of all entries and the  
....................  *                         filter will be disabled. 
....................  * 
....................  * Output:          Sets the appropriate bit in the EHT* registers to allow  
....................  *               packets sent to DestMACAddr to be received and enables the  
....................  *               Hash Table receive filter (if not already). 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Calculates a CRC-32 using polynomial 0x4C11DB7 and then,  
....................  *               using bits 28:23 of the CRC, sets the appropriate bit in  
....................  *               the EHT0-EHT7 registers. 
....................  * 
....................  * Note:            This code is commented out to save code space on systems  
....................  *               that do not need this function.  Change the  
....................  *               "#if STACK_USE_ZEROCONF_MDNS_SD" line to "#if 1" to  
....................  *               uncomment it, assuming you aren't using the Zeroconf module,  
....................  *               which requires mutlicast support and enables this function  
....................  *               automatically. 
....................  * 
....................  *               There is no way to individually unset destination MAC  
....................  *               addresses from the hash table since it is possible to have  
....................  *               a hash collision and therefore multiple MAC addresses  
....................  *               relying on the same hash table bit.  The stack would have  
....................  *               to individually store each 6 byte MAC address to support  
....................  *               this feature, which would waste a lot of RAM and be  
....................  *               unnecessary in most applications.  As a simple compromise,  
....................  *               you can call SetRXHashTableEntry() using a  
....................  *               00-00-00-00-00-00 destination MAC address, which will clear  
....................  *               the entire hash table and disable the hash table filter.   
....................  *               This will allow you to then re-add the necessary  
....................  *               destination address(es). 
....................  * 
....................  *               This function is intended to be used when  
....................  *               ERXFCON.ANDOR == 0 (OR). 
....................  *****************************************************************************/ 
.................... #if defined(STACK_USE_ZEROCONF_MDNS_SD) 
.................... void SetRXHashTableEntry(MAC_ADDR DestMACAddr) 
.................... { 
....................     DWORD_VAL CRC = {0xFFFFFFFF}; 
....................     BYTE HTRegister; 
....................     BYTE i, j; 
....................  
....................    // Select proper bank for ERXFCON and EHT0-EHT7 register access 
....................    BankSel(ERXFCON); 
....................  
....................    // Clear the Hash Table bits and disable the Hash Table Filter if a special  
....................    // 00-00-00-00-00-00 destination MAC address is provided. 
....................    if((DestMACAddr.v[0] | DestMACAddr.v[1] | DestMACAddr.v[2] | DestMACAddr.v[3] | DestMACAddr.v[4] | DestMACAddr.v[5]) == 0x00u) 
....................    { 
....................       // Disable the Hash Table receive filter and clear the hash table 
....................       BFCReg((BYTE)ERXFCON, ERXFCON_HTEN); 
....................       for(i = (BYTE)EHT0; i <= (BYTE)EHT7; i++) 
....................          WriteReg(i, 0x00); 
....................    } 
....................    else 
....................    { 
....................       // Calculate a CRC-32 over the 6 byte MAC address 
....................       // using polynomial 0x4C11DB7 
....................       for(i = 0; i < sizeof(MAC_ADDR); i++) 
....................       { 
....................          BYTE  crcnext; 
....................  
....................          // shift in 8 bits 
....................          for(j = 0; j < 8; j++) 
....................          { 
....................             crcnext = 0; 
....................             if(((BYTE_VAL*)&(CRC.v[3]))->bits.b7) 
....................                crcnext = 1; 
....................             crcnext ^= (((BYTE_VAL*)&DestMACAddr.v[i])->bits.b0); 
....................  
....................             CRC.Val <<= 1; 
....................             if(crcnext) 
....................                CRC.Val ^= 0x4C11DB7; 
....................             // next bit 
....................             DestMACAddr.v[i] >>= 1; 
....................          } 
....................       } 
....................  
....................       // CRC-32 calculated, now extract bits 28:23 
....................       // Bits 25:23 define where within the Hash Table byte the bit needs to be set 
....................       // Bits 28:26 define which of the 8 Hash Table bytes that bits 25:23 apply to 
....................       i = CRC.v[3] & 0x1F; 
....................       HTRegister = (i >> 2) + (BYTE)EHT0; 
....................       i = (i << 1) & 0x06; 
....................       ((BYTE_VAL*)&i)->bits.b0 = ((BYTE_VAL*)&CRC.v[2])->bits.b7; 
....................  
....................       // Set the proper bit in the Hash Table 
....................       BFSReg(HTRegister, 1<<i); 
....................  
....................       // Ensure that the Hash Table receive filter is enabled 
....................       BFSReg((BYTE)ERXFCON, ERXFCON_HTEN); 
....................    } 
....................  
....................     BankSel(ERDPTL);            // Return to Bank 0 
.................... } 
.................... #endif 
....................  
.................... //// GetRegs is a function for debugging purposes only.  It will read all 
.................... //// registers and store them in the PIC's RAM so they can be viewed with 
.................... //// the ICD2. 
.................... //REG Regs[4][32]; 
.................... //void GetRegs(void) 
.................... //{ 
.................... //  BYTE i; 
.................... // 
.................... //  BankSel(0x000); 
.................... //  for(i=0; i<0x1A; i++) 
.................... //      Regs[0][i] = ReadETHReg(i); 
.................... //  for(i=0x1B; i<32; i++) 
.................... //      Regs[0][i] = ReadETHReg(i); 
.................... // 
.................... //  BankSel(0x100); 
.................... //  for(i=0; i<0x1A; i++) 
.................... //      Regs[1][i] = ReadETHReg(i); 
.................... //  for(i=0x1B; i<32; i++) 
.................... //      Regs[1][i] = ReadETHReg(i); 
.................... // 
.................... //  BankSel(0x200); 
.................... //  for(i=0; i<5; i++) 
.................... //      Regs[2][i] = ReadMACReg(i); 
.................... //  Regs[2][5] = ReadETHReg(i); 
.................... //  for(i=6; i<0x0F; i++) 
.................... //      Regs[2][i] = ReadMACReg(i); 
.................... //  Regs[2][0x0F] = ReadETHReg(i); 
.................... //  for(i=0x10; i<0x13; i++) 
.................... //      Regs[2][i] = ReadMACReg(i); 
.................... //  Regs[2][0x13] = ReadETHReg(i); 
.................... //  for(i=0x14; i<0x1A; i++) 
.................... //      Regs[2][i] = ReadMACReg(i); 
.................... //  for(i=0x1B; i<32; i++) 
.................... //      Regs[2][i] = ReadETHReg(i); 
.................... // 
.................... //  BankSel(0x300); 
.................... //  for(i=0; i<0x06; i++) 
.................... //      Regs[3][i] = ReadMACReg(i); 
.................... //  for(i=6; i<0x0A; i++) 
.................... //      Regs[3][i] = ReadETHReg(i); 
.................... //  Regs[3][0x0A] = ReadMACReg(i); 
.................... //  for(i=0x0B; i<0x1A; i++) 
.................... //      Regs[3][i] = ReadETHReg(i); 
.................... //  for(i=0x1B; i<32; i++) 
.................... //      Regs[3][i] = ReadETHReg(i); 
.................... // 
.................... //  Regs[0][0x1A].Val = 0; 
.................... //  Regs[1][0x1A].Val = 0; 
.................... //  Regs[2][0x1A].Val = 0; 
.................... //  Regs[3][0x1A].Val = 0; 
.................... // 
.................... //  BankSel(ERDPTL); 
.................... // 
.................... //  return; 
.................... //} 
....................  
.................... //// Get8KBMem is a function intended for debugging purposes.  It will read all 
.................... //// Ethernet RAM and output it in hex out the UART 
.................... //void Get8KBMem(void) 
.................... //{ 
.................... //  WORD_VAL i; 
.................... //  BYTE v; 
.................... //  WORD_VAL RDSave; 
.................... // 
.................... //  RDSave.v[0] = ReadETHReg(ERDPTL).Val; 
.................... //  RDSave.v[1] = ReadETHReg(ERDPTH).Val; 
.................... // 
.................... //  for(i.Val = 0; i.Val < 8192; i.Val++) 
.................... //  { 
.................... //      WriteReg(ERDPTL, i.v[0]); 
.................... //      WriteReg(ERDPTH, i.v[1]); 
.................... //      v = MACGet(); 
.................... // 
.................... //      putcUART('0'); 
.................... //      while(BusyUART()); 
.................... //      putcUART('x'); 
.................... //      while(BusyUART()); 
.................... //      putcUART(btohexa_high(v)); 
.................... //      while(BusyUART()); 
.................... //      putcUART(btohexa_low(v)); 
.................... //      while(BusyUART()); 
.................... //  } 
.................... // 
.................... //  WriteReg(ERDPTL, RDSave.v[0]); 
.................... //  WriteReg(ERDPTH, RDSave.v[1]); 
.................... // 
.................... //} 
....................  
.................... #endif //#if defined(ENC_CS_TRIS) 
....................  
.................... #elif defined(ENC100_INTERFACE_MODE) 
....................    #include "ENCX24J600.c" 
....................    #define PHYREG WORD 
.................... #elif defined(__PIC32MX__) && defined(_ETH) 
....................    // extra includes for PIC32MX with embedded ETH Controller 
.................... #else 
....................    #error No Ethernet/WiFi controller defined in HardwareProfile.h.  Defines for an ENC28J60, ENC424J600/624J600, or ZeroG ZG2100 must be present. 
.................... #endif 
.................... #include "IP.c" 
.................... /********************************************************************* 
....................  * 
....................  *  Internet Protocol (IP) Version 4 Communications Layer 
....................  *  Module for Microchip TCP/IP Stack 
....................  *   -Provides a transport for TCP, UDP, and ICMP messages 
....................  *	 -Reference: RFC 791 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.c 
....................  * Dependencies:    Network Layer interface (ENC28J60.c, ETH97J60.c,  
....................  *					ENCX24J600.c or WFMac.c) 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder		8/31/04	Beta Rev 0.9 (See version.log for detail) 
....................  * Howard Schlunder		1/5/06	Improved DMA checksum efficiency 
....................  * Darren Rook			9/21/06	Corrected IPHeaderLen not being  
....................  * 								initialized when NON_MCHP_MAC defined. 
....................  ********************************************************************/ 
.................... #define __IP_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... // This is left shifted by 4.  Actual value is 0x04. 
.................... #define IPv4                (0x40u) 
.................... #define IP_VERSION          IPv4 
....................  
.................... // IHL (Internet Header Length) is # of DWORDs in a header. 
.................... // Since, we do not support options, our IP header length will be 
.................... // minimum i.e. 20 bytes : IHL = 20 / 4 = 5. 
.................... #define IP_IHL              (0x05) 
....................  
.................... #define IP_SERVICE_NW_CTRL  (0x07) 
.................... #define IP_SERVICE_IN_CTRL  (0x06) 
.................... #define IP_SERVICE_ECP      (0x05) 
.................... #define IP_SERVICE_OVR      (0x04) 
.................... #define IP_SERVICE_FLASH    (0x03) 
.................... #define IP_SERVICE_IMM      (0x02) 
.................... #define IP_SERVICE_PRIOR    (0x01) 
.................... #define IP_SERVICE_ROUTINE  (0x00) 
....................  
.................... #define IP_SERVICE_N_DELAY  (0x00) 
.................... #define IP_SERCICE_L_DELAY  (0x08) 
.................... #define IP_SERVICE_N_THRPT  (0x00) 
.................... #define IP_SERVICE_H_THRPT  (0x10) 
.................... #define IP_SERVICE_N_RELIB  (0x00) 
.................... #define IP_SERVICE_H_RELIB  (0x20) 
....................  
.................... #define IP_SERVICE          (IP_SERVICE_ROUTINE | IP_SERVICE_N_DELAY) 
....................  
.................... #if defined(STACK_USE_ZEROCONF_MDNS_SD) 
....................   #define MY_IP_TTL           (255)  // Time-To-Live in hops  
....................   // IP TTL is set to 255 for Multicast DNS compatibility. See mDNS-draft-08, section 4. 
.................... #else 
....................   #define MY_IP_TTL           (100)  // Time-To-Live in hops 
.................... #endif 
....................  
....................  
....................  
.................... static WORD _Identifier = 0; 
.................... static BYTE IPHeaderLen; 
....................  
....................  
.................... static void SwapIPHeader(IP_HEADER* h); 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len) 
.................... { 
....................     WORD_VAL    CalcChecksum; 
....................     IP_HEADER   header; 
....................  
.................... #if defined(NON_MCHP_MAC) 
....................     WORD_VAL    ReceivedChecksum; 
....................     WORD        checksums[2]; 
....................     BYTE        optionsLen; 
.................... 	#define MAX_OPTIONS_LEN     (40u)            // As per RFC 791. 
....................     BYTE        options[MAX_OPTIONS_LEN]; 
.................... #endif 
....................  
....................     // Read IP header. 
....................     MACGetArray((BYTE*)&header, sizeof(header)); 
*
03DEC:  MOVLW  01
03DEE:  MOVLB  1
03DF0:  MOVWF  x93
03DF2:  MOVLW  7E
03DF4:  MOVWF  x92
03DF6:  MOVFF  193,2BF
03DFA:  MOVFF  FE8,2BE
03DFE:  MOVLB  2
03E00:  CLRF   xC1
03E02:  MOVLW  14
03E04:  MOVWF  xC0
03E06:  MOVLB  0
03E08:  CALL   0EDC
....................  
....................     // Make sure that this is an IPv4 packet. 
....................     if((header.VersionIHL & 0xf0) != IP_VERSION) 
03E0C:  MOVLB  1
03E0E:  MOVF   x7E,W
03E10:  ANDLW  F0
03E12:  SUBLW  40
03E14:  BZ    3E1C
....................     	return FALSE; 
03E16:  MOVLW  00
03E18:  MOVWF  01
03E1A:  BRA    3EEA
....................  
.................... 	// Throw this packet away if it is a fragment.   
.................... 	// We don't have enough RAM for IP fragment reconstruction. 
.................... 	if(header.FragmentInfo & 0xFF1F) 
03E1C:  MOVF   x84,W
03E1E:  ANDLW  1F
03E20:  MOVWF  00
03E22:  MOVFF  185,03
03E26:  MOVF   00,W
03E28:  IORWF  x85,W
03E2A:  BZ    3E32
.................... 		return FALSE; 
03E2C:  MOVLW  00
03E2E:  MOVWF  01
03E30:  BRA    3EEA
....................  
.................... 	IPHeaderLen = (header.VersionIHL & 0x0f) << 2; 
03E32:  MOVF   x7E,W
03E34:  ANDLW  0F
03E36:  MOVWF  00
03E38:  RLCF   00,W
03E3A:  MOVLB  0
03E3C:  MOVWF  x81
03E3E:  RLCF   x81,F
03E40:  MOVLW  FC
03E42:  ANDWF  x81,F
....................  
.................... #if !defined(NON_MCHP_MAC) 
.................... 	// Validate the IP header.  If it is correct, the checksum  
.................... 	// will come out to 0x0000 (because the header contains a  
.................... 	// precomputed checksum).  A corrupt header will have a  
.................... 	// nonzero checksum. 
.................... 	CalcChecksum.Val = MACCalcRxChecksum(0, IPHeaderLen); 
03E44:  MOVLB  1
03E46:  CLRF   x93
03E48:  CLRF   x92
03E4A:  CLRF   x95
03E4C:  MOVFF  81,194
03E50:  MOVLB  0
03E52:  RCALL  3CEC
03E54:  MOVFF  02,17D
03E58:  MOVFF  01,17C
....................  
.................... 	// Seek to the end of the IP header 
.................... 	MACSetReadPtrInRx(IPHeaderLen); 
03E5C:  MOVLB  1
03E5E:  CLRF   xC8
03E60:  MOVFF  81,1C7
03E64:  MOVLB  0
03E66:  RCALL  3D9A
....................  
....................     if(CalcChecksum.Val) 
03E68:  MOVLB  1
03E6A:  MOVF   x7C,W
03E6C:  IORWF  x7D,W
03E6E:  BZ    3E76
.................... #else 
....................     // Calculate options length in this header, if there is any. 
....................     // IHL is in terms of numbers of 32-bit DWORDs; i.e. actual 
....................     // length is 4 times IHL. 
....................     optionsLen = IPHeaderLen - sizeof(header); 
....................  
....................     // If there is any option(s), read it so that we can include them 
....................     // in checksum calculation. 
....................     if ( optionsLen > MAX_OPTIONS_LEN ) 
....................         return FALSE; 
....................  
....................     if ( optionsLen > 0u ) 
....................         MACGetArray(options, optionsLen); 
....................  
....................     // Save header checksum; clear it and recalculate it ourselves. 
....................     ReceivedChecksum.Val = header.HeaderChecksum; 
....................     header.HeaderChecksum = 0; 
....................  
....................     // Calculate checksum of header including options bytes. 
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&header, sizeof(header)); 
....................  
....................     // Calculate Options checksum too, if they are present. 
....................     if ( optionsLen > 0u ) 
....................         checksums[1] = ~CalcIPChecksum((BYTE*)options, optionsLen); 
....................     else 
....................         checksums[1] = 0; 
....................  
....................     CalcChecksum.Val  = CalcIPChecksum((BYTE*)checksums, 
....................                                             2 * sizeof(WORD)); 
....................  
....................     // Make sure that checksum is correct 
....................     if ( ReceivedChecksum.Val != CalcChecksum.Val ) 
.................... #endif 
....................     { 
....................         // Bad packet. The function caller will be notified by means of the FALSE  
....................         // return value and it should discard the packet. 
....................         return FALSE; 
03E70:  MOVLW  00
03E72:  MOVWF  01
03E74:  BRA    3EEA
....................     } 
....................  
....................     // Network to host conversion. 
....................     SwapIPHeader(&header); 
03E76:  MOVLW  01
03E78:  MOVLB  2
03E7A:  MOVWF  xB6
03E7C:  MOVLW  7E
03E7E:  MOVWF  xB5
03E80:  MOVLB  0
03E82:  CALL   209C
....................  
....................     // If caller is intrested, return destination IP address 
....................     // as seen in this IP header. 
....................     if ( localIP ) 
03E86:  MOVLB  1
03E88:  MOVF   x74,W
03E8A:  IORWF  x75,W
03E8C:  BZ    3EA6
....................         localIP->Val    = header.DestAddress.Val; 
03E8E:  MOVFF  174,FE9
03E92:  MOVFF  175,FEA
03E96:  MOVFF  18E,FEF
03E9A:  MOVFF  18F,FEC
03E9E:  MOVFF  190,FEC
03EA2:  MOVFF  191,FEC
....................  
....................     remote->IPAddr.Val  = header.SourceAddress.Val; 
03EA6:  MOVFF  176,FE9
03EAA:  MOVF   x77,W
03EAC:  MOVWF  FEA
03EAE:  MOVFF  18A,FEF
03EB2:  MOVFF  18B,FEC
03EB6:  MOVFF  18C,FEC
03EBA:  MOVFF  18D,FEC
....................     *protocol           = header.Protocol; 
03EBE:  MOVFF  178,FE9
03EC2:  MOVFF  179,FEA
03EC6:  MOVFF  187,FEF
....................     *len 				= header.TotalLength - IPHeaderLen; 
03ECA:  MOVFF  17A,FE9
03ECE:  MOVFF  17B,FEA
03ED2:  MOVLB  0
03ED4:  MOVF   x81,W
03ED6:  MOVLB  1
03ED8:  SUBWF  x80,W
03EDA:  MOVWF  00
03EDC:  MOVLW  00
03EDE:  SUBWFB x81,W
03EE0:  MOVFF  00,FEF
03EE4:  MOVWF  FEC
....................  
....................     return TRUE; 
03EE6:  MOVLW  01
03EE8:  MOVWF  01
03EEA:  MOVLB  0
03EEC:  GOTO   5A26 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function: WORD IPPutHeader(NODE_INFO *remote, 
....................  *           				  BYTE protocol, 
....................  *                			  WORD len) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           *remote     - Destination node address 
....................  *                  protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          (WORD)0 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  ********************************************************************/ 
.................... WORD IPPutHeader(NODE_INFO *remote, 
....................                  BYTE protocol, 
....................                  WORD len) 
.................... { 
....................     IP_HEADER   header; 
....................      
....................     IPHeaderLen = sizeof(IP_HEADER); 
*
0223C:  MOVLW  14
0223E:  MOVWF  x81
....................  
....................     header.VersionIHL       = IP_VERSION | IP_IHL; 
02240:  MOVLW  45
02242:  MOVLB  2
02244:  MOVWF  xA1
....................     header.TypeOfService    = IP_SERVICE; 
02246:  CLRF   xA2
....................     header.TotalLength      = sizeof(header) + len; 
02248:  MOVLW  14
0224A:  ADDWF  x9F,W
0224C:  MOVWF  xA3
0224E:  MOVLW  00
02250:  ADDWFC xA0,W
02252:  MOVWF  xA4
....................     header.Identification   = ++_Identifier; 
02254:  INCF   7F,F
02256:  BTFSS  FD8.2
02258:  BRA    2260
0225A:  MOVLB  0
0225C:  INCF   x80,F
0225E:  MOVLB  2
02260:  MOVFF  80,2A6
02264:  MOVFF  7F,2A5
....................     header.FragmentInfo     = 0; 
02268:  CLRF   xA8
0226A:  CLRF   xA7
....................     header.TimeToLive       = MY_IP_TTL; 
0226C:  MOVLW  64
0226E:  MOVWF  xA9
....................     header.Protocol         = protocol; 
02270:  MOVFF  29E,2AA
....................     header.HeaderChecksum   = 0; 
02274:  CLRF   xAC
02276:  CLRF   xAB
.................... 	header.SourceAddress 	= AppConfig.MyIPAddr; 
02278:  MOVFF  2C,2B0
0227C:  MOVFF  2B,2AF
02280:  MOVFF  2A,2AE
02284:  MOVFF  29,2AD
....................  
....................     header.DestAddress.Val = remote->IPAddr.Val; 
02288:  MOVFF  29C,FE9
0228C:  MOVFF  29D,FEA
02290:  MOVFF  FEF,2B1
02294:  MOVFF  FEC,2B2
02298:  MOVFF  FEC,2B3
0229C:  MOVFF  FEC,2B4
....................  
....................     SwapIPHeader(&header); 
022A0:  MOVLW  02
022A2:  MOVWF  xB6
022A4:  MOVLW  A1
022A6:  MOVWF  xB5
022A8:  MOVLB  0
022AA:  RCALL  209C
....................  
....................     header.HeaderChecksum   = CalcIPChecksum((BYTE*)&header, sizeof(header)); 
022AC:  MOVLW  02
022AE:  MOVLB  2
022B0:  MOVWF  xB6
022B2:  MOVLW  A1
022B4:  MOVWF  xB5
022B6:  MOVFF  2B6,2B8
022BA:  MOVWF  xB7
022BC:  CLRF   xBA
022BE:  MOVLW  14
022C0:  MOVWF  xB9
022C2:  MOVLB  0
022C4:  RCALL  1FB4
022C6:  MOVFF  02,2AC
022CA:  MOVFF  01,2AB
....................  
....................     MACPutHeader(&remote->MACAddr, MAC_IP, (sizeof(header)+len)); 
022CE:  MOVLW  04
022D0:  MOVLB  2
022D2:  ADDWF  x9C,W
022D4:  MOVWF  01
022D6:  MOVLW  00
022D8:  ADDWFC x9D,W
022DA:  MOVWF  03
022DC:  MOVFF  01,2B5
022E0:  MOVWF  xB6
022E2:  MOVLW  14
022E4:  ADDWF  x9F,W
022E6:  MOVWF  xB7
022E8:  MOVLW  00
022EA:  ADDWFC xA0,W
022EC:  MOVWF  xB8
022EE:  MOVFF  03,2BA
022F2:  MOVFF  01,2B9
022F6:  CLRF   xBB
022F8:  MOVWF  xBD
022FA:  MOVFF  2B7,2BC
022FE:  MOVLB  0
02300:  RCALL  2176
....................     MACPutArray((BYTE*)&header, sizeof(header)); 
02302:  MOVLW  02
02304:  MOVLB  2
02306:  MOVWF  xB6
02308:  MOVLW  A1
0230A:  MOVWF  xB5
0230C:  MOVFF  2B6,2C1
02310:  MOVWF  xC0
02312:  CLRF   xC3
02314:  MOVLW  14
02316:  MOVWF  xC2
02318:  MOVLB  0
0231A:  CALL   0E2A
....................  
....................     return 0x0000; 
0231E:  MOVLW  00
02320:  MOVWF  01
02322:  MOVWF  02
02324:  RETURN 0
....................  
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by  
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset  
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset)  
.................... { 
.................... 	MACSetReadPtrInRx(Offset+IPHeaderLen); 
*
03FDA:  MOVF   x81,W
03FDC:  MOVLB  1
03FDE:  ADDWF  xC3,W
03FE0:  MOVWF  xC5
03FE2:  MOVLW  00
03FE4:  ADDWFC xC4,W
03FE6:  MOVWF  xC6
03FE8:  MOVWF  xC8
03FEA:  MOVFF  1C5,1C7
03FEE:  MOVLB  0
03FF0:  RCALL  3D9A
03FF2:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... static void SwapIPHeader(IP_HEADER* h) 
.................... { 
....................     h->TotalLength      = swaps(h->TotalLength); 
*
0209C:  MOVLW  02
0209E:  MOVLB  2
020A0:  ADDWF  xB5,W
020A2:  MOVWF  01
020A4:  MOVLW  00
020A6:  ADDWFC xB6,W
020A8:  MOVWF  03
020AA:  MOVFF  01,2B7
020AE:  MOVWF  xB8
020B0:  MOVLW  02
020B2:  ADDWF  xB5,W
020B4:  MOVWF  FE9
020B6:  MOVLW  00
020B8:  ADDWFC xB6,W
020BA:  MOVWF  FEA
020BC:  MOVFF  FEC,2BA
020C0:  MOVF   FED,F
020C2:  MOVFF  FEF,2B9
020C6:  MOVFF  2BA,2BC
020CA:  MOVFF  2B9,2BB
020CE:  MOVLB  0
020D0:  RCALL  1C00
020D2:  MOVFF  2B8,FEA
020D6:  MOVFF  2B7,FE9
020DA:  MOVFF  02,FEC
020DE:  MOVF   FED,F
020E0:  MOVFF  01,FEF
....................     h->Identification   = swaps(h->Identification); 
020E4:  MOVLW  04
020E6:  MOVLB  2
020E8:  ADDWF  xB5,W
020EA:  MOVWF  01
020EC:  MOVLW  00
020EE:  ADDWFC xB6,W
020F0:  MOVWF  03
020F2:  MOVFF  01,2B7
020F6:  MOVWF  xB8
020F8:  MOVLW  04
020FA:  ADDWF  xB5,W
020FC:  MOVWF  FE9
020FE:  MOVLW  00
02100:  ADDWFC xB6,W
02102:  MOVWF  FEA
02104:  MOVFF  FEC,2BA
02108:  MOVF   FED,F
0210A:  MOVFF  FEF,2B9
0210E:  MOVFF  2BA,2BC
02112:  MOVFF  2B9,2BB
02116:  MOVLB  0
02118:  RCALL  1C00
0211A:  MOVFF  2B8,FEA
0211E:  MOVFF  2B7,FE9
02122:  MOVFF  02,FEC
02126:  MOVF   FED,F
02128:  MOVFF  01,FEF
....................     h->HeaderChecksum   = swaps(h->HeaderChecksum); 
0212C:  MOVLW  0A
0212E:  MOVLB  2
02130:  ADDWF  xB5,W
02132:  MOVWF  01
02134:  MOVLW  00
02136:  ADDWFC xB6,W
02138:  MOVWF  03
0213A:  MOVFF  01,2B7
0213E:  MOVWF  xB8
02140:  MOVLW  0A
02142:  ADDWF  xB5,W
02144:  MOVWF  FE9
02146:  MOVLW  00
02148:  ADDWFC xB6,W
0214A:  MOVWF  FEA
0214C:  MOVFF  FEC,2BA
02150:  MOVF   FED,F
02152:  MOVFF  FEF,2B9
02156:  MOVFF  2BA,2BC
0215A:  MOVFF  2B9,2BB
0215E:  MOVLB  0
02160:  RCALL  1C00
02162:  MOVFF  2B8,FEA
02166:  MOVFF  2B7,FE9
0216A:  MOVFF  02,FEC
0216E:  MOVF   FED,F
02170:  MOVFF  01,FEF
02174:  RETURN 0
.................... } 
....................  
.................... #include "ARP.c" 
.................... /********************************************************************* 
....................  * 
....................  *   Address Resolution Protocol (ARP) Client and Server 
....................  *  Module for Microchip TCP/IP Stack 
....................  *    -Provides IP address to Ethernet MAC address translation 
....................  *    -Reference: RFC 826 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.c 
....................  * Dependencies:    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  ARP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder      8/17/06   Combined ARP.c and ARPTsk.c into ARP.c;  
....................  *                        rewrote some of it to look more linear 
....................  * Darren Rook/CCS      Added call to GratArpReset() if using STACK_USE_CCS_GRATUITOUS_ARP 
....................  ********************************************************************/ 
.................... #define __ARP_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Constants and Variables 
....................   ***************************************************************************/ 
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... //#define ARP_OPERATION_REQ       0x01u      // Operation code indicating an ARP Request 
.................... //#define ARP_OPERATION_RESP      0x02u      // Operation code indicating an ARP Response 
....................  
.................... #define HW_ETHERNET             (0x0001u)   // ARP Hardware type as defined by IEEE 802.3 
.................... #define ARP_IP                  (0x0800u)   // ARP IP packet type as defined by IEEE 802.3 
.................... #endif 
....................  
.................... #ifdef STACK_CLIENT_MODE 
.................... static NODE_INFO Cache;                  // Cache for one ARP response 
.................... #endif 
....................  
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... #define MAX_REG_APPS            2           // MAX num allowed registrations of Modules/Apps 
.................... static struct arp_app_callbacks reg_apps[MAX_REG_APPS]; // Call-Backs storage for MAX of two Modules/Apps 
.................... /* 
.................... // ARP packet structure 
.................... typedef struct __attribute__((aligned(2), packed)) 
.................... { 
....................     WORD        HardwareType; 
....................     WORD        Protocol; 
....................     BYTE        MACAddrLen; 
....................     BYTE        ProtocolLen; 
....................     WORD        Operation; 
....................     MAC_ADDR    SenderMACAddr; 
....................     IP_ADDR     SenderIPAddr; 
....................     MAC_ADDR    TargetMACAddr; 
....................     IP_ADDR     TargetIPAddr; 
.................... } ARP_PACKET; 
.................... */ 
.................... #endif 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Helper Function Prototypes 
....................   ***************************************************************************/ 
....................  
.................... static BOOL ARPPut(ARP_PACKET* packet); 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Function Implementations 
....................   ***************************************************************************/ 
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... /************ User Application APIs ****************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    CHAR ARPRegisterCallbacks(struct arp_app_callbacks *app) 
....................  
....................   Summary: 
....................    Registering callback with ARP module to get notified about certian events. 
....................     
....................   Description: 
....................      This function allows end user application to register with callbacks, which 
....................     will be called by ARP module to give notification to user-application about  
....................     events occurred at ARP layer. For ex: when a ARP-packet is received, which is 
....................     conflicting with our own pair of addresses (MAC-Address and IP-address). 
....................     This is an extension for zeroconf protocol implementation (ZeroconfLL.c) 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    app - ARP-Application callbacks structure supplied by user-application  
....................      
....................   Returns: 
....................     id > 0 - Returns non-negative value that represents the id of registration 
....................              The same id needs to be used in de-registration 
....................     -1     - When registered applications exceed MAX_REG_APPS and there is no 
....................              free slot for registration 
....................   
....................   ***************************************************************************/ 
.................... CHAR ARPRegisterCallbacks(struct arp_app_callbacks *app) 
.................... { 
....................     BYTE i; 
....................     for(i=0; i<MAX_REG_APPS; i++) 
....................     { 
....................         if(!reg_apps[i].used) 
....................         { 
....................             reg_apps[i].ARPPkt_notify = app->ARPPkt_notify; 
....................             reg_apps[i].used = 1; 
....................             return (i+1); // Return Code. Should be used in deregister. 
....................         } 
....................     } 
....................     return -1; // No space for registration 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL ARPDeRegisterCallbacks(CHAR reg_id) 
....................  
....................   Summary: 
....................    De-Registering callbacks with ARP module that are registered previously. 
....................     
....................   Description: 
....................      This function allows end user-application to de-register with callbacks,  
....................     which were registered previously. 
....................     This is called by user-application, when its no longer interested in  
....................     notifications from ARP-Module. This allows the other application to get  
....................     registered with ARP-module.    
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    reg_id - Registration-id returned in ARPRegisterCallbacks call 
....................      
....................   Returns: 
....................     TRUE  - On success 
....................     FALSE - Failure to indicate invalid reg_id   
....................   ***************************************************************************/  
.................... BOOL ARPDeRegisterCallbacks(CHAR reg_id) 
.................... { 
....................     if(reg_id <= 0 || reg_id > MAX_REG_APPS) 
....................         return FALSE; 
....................  
....................     reg_apps[reg_id-1].used = 0; // To indicate free slot for registration 
....................    return TRUE; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ARPProcessRxPkt(ARP_PACKET* packet) 
....................  
....................   Summary: 
....................    Processes Received-ARP packet (ARP request/Reply). 
....................     
....................   Description: 
....................      This function is to pass-on the ARP-packet to registered application, 
....................     with the notification of Rx-ARP packet.  
....................  
....................   Precondition: 
....................    ARP packet is received completely from MAC 
....................  
....................   Parameters: 
....................    packet - Rx packet to be processed      
....................  
....................   Returns: 
....................     None    
....................   ***************************************************************************/ 
.................... void ARPProcessRxPkt(ARP_PACKET* packet) 
.................... { 
....................     BYTE pass_on = 0; // Flag to indicate whether need to be forwarded 
....................     BYTE i; 
....................  
....................     // Probing Stage 
....................     if(AppConfig.MyIPAddr.Val == 0x00) 
....................     { 
....................         pass_on = 1; // Pass to Registered-Application for further processing         
....................     } 
....................     else if(AppConfig.MyIPAddr.Val) 
....................     { 
....................         /* Late-conflict */ 
....................         if(packet->SenderIPAddr.Val == AppConfig.MyIPAddr.Val) 
....................         { 
....................             pass_on = 1; 
....................         } 
....................     } 
....................     if(pass_on) 
....................     { 
....................      
....................         for(i =0; i< MAX_REG_APPS; i++) 
....................         { 
....................             if(reg_apps[i].used) 
....................             { 
....................                 reg_apps[i].ARPPkt_notify(packet->SenderIPAddr.Val, 
....................                                       packet->TargetIPAddr.Val, 
....................                                       &packet->SenderMACAddr, 
....................                                       &packet->TargetMACAddr, 
....................                                       packet->Operation);                 
....................             } 
....................         } 
....................     } 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ARPSendPkt(IP_ADDR* SrcIPAddr, IP_ADDR* DestIPAddr, int op_req ) 
....................  
....................   Summary: 
....................    Transmits an ARP request/Reply initated by Application or external module. 
....................     
....................   Description: 
....................      This function transmits and ARP request/reply to determine the hardware 
....................      address of a given IP address (or) Announce self-address to all nodes in 
....................     network. Extended for zeroconf protocol.  
....................  
....................   Precondition: 
....................    ARP packet is ready in the MAC buffer. 
....................  
....................   Parameters: 
....................    SrcIPAddr - The Source IP-address  
....................     DestIPAddr - The Destination IP-Address 
....................     op_req     - Operation Request (ARP_REQ/ARP_RESP) 
....................  
....................   Returns: 
....................     TRUE - The ARP packet was generated properly 
....................      FALSE - Not possible return value 
....................  
....................   Remarks: 
....................      This API is to give control over AR-packet to external modules.  
....................   ***************************************************************************/ 
.................... BOOL ARPSendPkt(DWORD SrcIPAddr, DWORD DestIPAddr, BYTE op_req ) 
.................... { 
....................     ARP_PACKET packet; 
....................  
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... #define KS_ARP_IP_MULTICAST_HACK y 
.................... #ifdef KS_ARP_IP_MULTICAST_HACK 
....................    DWORD_VAL *DestAddr = (DWORD_VAL *)&DestIPAddr; 
....................    if ((DestAddr->v[0] >= 224) &&(DestAddr->v[0] <= 239)) { 
....................       // "Resolve" the IP to MAC address mapping for 
....................       // IP multicast address range from 224.0.0.0 to 239.255.255.255 
....................     
....................       Cache.MACAddr.v[0] = 0x01; 
....................       Cache.MACAddr.v[1] = 0x00; 
....................       Cache.MACAddr.v[2] = 0x5E; 
....................       Cache.MACAddr.v[3] = 0x7f & DestAddr->v[1]; 
....................       Cache.MACAddr.v[4] = DestAddr->v[2]; 
....................       Cache.MACAddr.v[5] = DestAddr->v[3]; 
....................     
....................       Cache.IPAddr.Val = DestAddr->Val; 
....................     
....................       return TRUE; 
....................    } 
.................... #endif 
.................... #endif 
....................  
....................     packet.Operation = op_req; 
....................    packet.TargetMACAddr.v[0]   = 0xff; 
....................    packet.TargetMACAddr.v[1]   = 0xff; 
....................    packet.TargetMACAddr.v[2]   = 0xff; 
....................    packet.TargetMACAddr.v[3]   = 0xff; 
....................    packet.TargetMACAddr.v[4]   = 0xff; 
....................    packet.TargetMACAddr.v[5]   = 0xff; 
....................  
....................     packet.TargetIPAddr.Val   = DestIPAddr; 
....................     packet.SenderIPAddr.Val = SrcIPAddr; 
....................  
....................     return ( ARPPut(&packet) ); 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static BOOL ARPPut(ARP_PACKET* packet) 
....................  
....................   Description: 
....................    Writes an ARP packet to the MAC. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    packet - A pointer to an ARP_PACKET structure with correct operation 
....................             and target preconfigured. 
....................  
....................   Return Values: 
....................      TRUE - The ARP packet was generated properly 
....................      FALSE - Not a possible return value 
....................   ***************************************************************************/ 
.................... static BOOL ARPPut(ARP_PACKET* packet) 
.................... { 
....................    while(!MACIsTxReady()); 
*
02ED2:  CALL   1A1C
02ED6:  MOVF   01,F
02ED8:  BZ    2ED2
....................    MACSetWritePtr(BASE_TX_ADDR); 
02EDA:  MOVLW  15
02EDC:  MOVLB  2
02EDE:  MOVWF  xAC
02EE0:  MOVLW  0B
02EE2:  MOVWF  xAB
02EE4:  MOVLB  0
02EE6:  CALL   0DBA
....................     
....................  
....................     packet->HardwareType  = HW_ETHERNET; 
02EEA:  MOVLB  1
02EEC:  MOVFF  197,FE9
02EF0:  MOVFF  198,FEA
02EF4:  CLRF   FEC
02EF6:  MOVF   FED,F
02EF8:  MOVLW  01
02EFA:  MOVWF  FEF
....................     packet->Protocol      = ARP_IP; 
02EFC:  MOVLW  02
02EFE:  ADDWF  x97,W
02F00:  MOVWF  FE9
02F02:  MOVLW  00
02F04:  ADDWFC x98,W
02F06:  MOVWF  FEA
02F08:  MOVLW  08
02F0A:  MOVWF  FEC
02F0C:  MOVF   FED,F
02F0E:  CLRF   FEF
....................     packet->MACAddrLen    = sizeof(MAC_ADDR); 
02F10:  MOVLW  04
02F12:  ADDWF  x97,W
02F14:  MOVWF  FE9
02F16:  MOVLW  00
02F18:  ADDWFC x98,W
02F1A:  MOVWF  FEA
02F1C:  MOVLW  06
02F1E:  MOVWF  FEF
....................     packet->ProtocolLen   = sizeof(IP_ADDR); 
02F20:  MOVLW  05
02F22:  ADDWF  x97,W
02F24:  MOVWF  FE9
02F26:  MOVLW  00
02F28:  ADDWFC x98,W
02F2A:  MOVWF  FEA
02F2C:  MOVLW  04
02F2E:  MOVWF  FEF
.................... //    packet->SenderMACAddr = AppConfig.MyMACAddr;   // HI-TECH PICC-18 compiler can't handle this statement, use memcpy() as a workaround 
....................    memcpy(&packet->SenderMACAddr, (void*)&AppConfig.MyMACAddr, sizeof(packet->SenderMACAddr)); 
02F30:  MOVLW  08
02F32:  ADDWF  x97,W
02F34:  MOVWF  01
02F36:  MOVLW  00
02F38:  ADDWFC x98,W
02F3A:  MOVWF  03
02F3C:  MOVFF  01,199
02F40:  MOVWF  x9A
02F42:  CLRF   x9C
02F44:  MOVLW  56
02F46:  MOVFF  03,FEA
02F4A:  MOVFF  01,FE9
02F4E:  MOVFF  19C,FE2
02F52:  MOVWF  FE1
02F54:  MOVLW  06
02F56:  MOVWF  01
02F58:  MOVFF  FE6,FEE
02F5C:  DECFSZ 01,F
02F5E:  BRA    2F58
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................     //packet->SenderIPAddr  = AppConfig.MyIPAddr; /* Removed for ZCLL, SenderIPAddr should be filled in */ 
.................... #else 
....................     packet->SenderIPAddr  = AppConfig.MyIPAddr; 
02F60:  MOVLW  0E
02F62:  ADDWF  x97,W
02F64:  MOVWF  FE9
02F66:  MOVLW  00
02F68:  ADDWFC x98,W
02F6A:  MOVWF  FEA
02F6C:  MOVFF  29,FEF
02F70:  MOVFF  2A,FEC
02F74:  MOVFF  2B,FEC
02F78:  MOVFF  2C,FEC
.................... #endif 
....................  
....................     SwapARPPacket(packet); 
02F7C:  MOVFF  198,19A
02F80:  MOVFF  197,199
02F84:  MOVLB  0
02F86:  RCALL  2DF8
....................  
....................     MACPutHeader(&packet->TargetMACAddr, MAC_ARP, sizeof(*packet)); 
02F88:  MOVLW  12
02F8A:  MOVLB  1
02F8C:  ADDWF  x97,W
02F8E:  MOVWF  01
02F90:  MOVLW  00
02F92:  ADDWFC x98,W
02F94:  MOVWF  03
02F96:  MOVFF  01,199
02F9A:  MOVWF  x9A
02F9C:  MOVFF  FE8,2BA
02FA0:  MOVFF  01,2B9
02FA4:  MOVLW  06
02FA6:  MOVLB  2
02FA8:  MOVWF  xBB
02FAA:  CLRF   xBD
02FAC:  MOVLW  1C
02FAE:  MOVWF  xBC
02FB0:  MOVLB  0
02FB2:  CALL   2176
....................     MACPutArray((BYTE*)packet, sizeof(*packet)); 
02FB6:  MOVFF  198,2C1
02FBA:  MOVFF  197,2C0
02FBE:  MOVLB  2
02FC0:  CLRF   xC3
02FC2:  MOVLW  1C
02FC4:  MOVWF  xC2
02FC6:  MOVLB  0
02FC8:  CALL   0E2A
....................     MACFlush(); 
02FCC:  CALL   246E
....................     
....................    return TRUE; 
02FD0:  MOVLW  01
02FD2:  MOVWF  01
02FD4:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ARPInit(void) 
....................  
....................   Summary: 
....................    Initializes the ARP module. 
....................     
....................   Description: 
....................      Initializes the ARP module.  Call this function once at boot to  
....................      invalidate the cached lookup. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................      None 
....................    
....................   Remarks: 
....................      This function is only required when the stack is a client, and therefore 
....................      is only enabled when STACK_CLIENT_MODE is enabled. 
....................   ***************************************************************************/ 
.................... #ifdef STACK_CLIENT_MODE 
.................... void ARPInit(void) 
.................... { 
....................     Cache.MACAddr.v[0] = 0xff; 
*
00CE6:  SETF   x86
....................     Cache.MACAddr.v[1] = 0xff; 
00CE8:  SETF   x87
....................     Cache.MACAddr.v[2] = 0xff; 
00CEA:  SETF   x88
....................     Cache.MACAddr.v[3] = 0xff; 
00CEC:  SETF   x89
....................     Cache.MACAddr.v[4] = 0xff; 
00CEE:  SETF   x8A
....................     Cache.MACAddr.v[5] = 0xff; 
00CF0:  SETF   x8B
....................  
....................    Cache.IPAddr.Val = 0xfffffffful; 
00CF2:  SETF   x85
00CF4:  SETF   x84
00CF6:  SETF   x83
00CF8:  SETF   x82
00CFA:  GOTO   1686 (RETURN)
.................... } 
.................... #endif 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL ARPProcess(void) 
....................  
....................   Summary: 
....................    Processes an incoming ARP packet. 
....................     
....................   Description: 
....................      Retrieves an ARP packet from the MAC buffer and determines if it is a 
....................      response to our request (in which case the ARP is resolved) or if it 
....................      is a request requiring our response (in which case we transmit one.) 
....................  
....................   Precondition: 
....................    ARP packet is ready in the MAC buffer. 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Return Values: 
....................      TRUE - All processing of this ARP packet is complete.  Do not call  
....................            again until a new ARP packet is waiting in the RX buffer. 
....................      FALSE - This function must be called again.  More time is needed to  
....................            send an ARP response. 
....................   ***************************************************************************/ 
.................... BOOL ARPProcess(void) 
.................... { 
....................    ARP_PACKET packet; 
....................    static NODE_INFO Target; 
....................     #if defined(STACK_USE_AUTO_IP) 
....................         BYTE i; 
....................     #endif 
....................    static enum 
....................    { 
....................        SM_ARP_IDLE = 0, 
....................        SM_ARP_REPLY 
....................    } smARP = SM_ARP_IDLE; 
....................  
....................     switch(smARP) 
*
03BA2:  MOVLW  00
03BA4:  BTFSC  67.2
03BA6:  MOVLW  01
03BA8:  XORLW  00
03BAA:  BZ    3BB4
03BAC:  XORLW  01
03BAE:  BTFSC  FD8.2
03BB0:  BRA    3C90
03BB2:  BRA    3CE0
....................     { 
....................        case SM_ARP_IDLE: 
....................          // Obtain the incoming ARP packet 
....................           MACGetArray((BYTE*)&packet, sizeof(packet));       
03BB4:  MOVLW  01
03BB6:  MOVLB  1
03BB8:  MOVWF  x91
03BBA:  MOVLW  74
03BBC:  MOVWF  x90
03BBE:  MOVFF  191,2BF
03BC2:  MOVFF  FE8,2BE
03BC6:  MOVLB  2
03BC8:  CLRF   xC1
03BCA:  MOVLW  1C
03BCC:  MOVWF  xC0
03BCE:  MOVLB  0
03BD0:  CALL   0EDC
....................           MACDiscardRx(); 
03BD4:  RCALL  39F6
....................           SwapARPPacket(&packet); 
03BD6:  MOVLW  01
03BD8:  MOVLB  1
03BDA:  MOVWF  x9A
03BDC:  MOVLW  74
03BDE:  MOVWF  x99
03BE0:  MOVLB  0
03BE2:  CALL   2DF8
....................        
....................          // Validate the ARP packet 
....................           if ( packet.HardwareType != HW_ETHERNET     || 
....................                packet.MACAddrLen != sizeof(MAC_ADDR)  || 
....................                packet.ProtocolLen != sizeof(IP_ADDR) ) 
03BE6:  MOVLB  1
03BE8:  DECFSZ x74,W
03BEA:  BRA    3BFC
03BEC:  MOVF   x75,F
03BEE:  BNZ   3BFC
03BF0:  MOVF   x78,W
03BF2:  SUBLW  06
03BF4:  BNZ   3BFC
03BF6:  MOVF   x79,W
03BF8:  SUBLW  04
03BFA:  BZ    3C02
....................           { 
....................                return TRUE; 
03BFC:  MOVLW  01
03BFE:  MOVWF  01
03C00:  BRA    3CE6
....................           } 
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................          ARPProcessRxPkt(&packet); 
.................... #endif 
....................  
.................... #ifdef STACK_USE_AUTO_IP 
....................             if (packet.SenderIPAddr.Val == AppConfig.MyIPAddr.Val) 
....................             { 
....................                 AutoIPConflict(0); 
....................                 return TRUE;                 
....................             } 
.................... #endif 
.................... #ifdef STACK_USE_CCS_GRATUITOUS_ARP 
.................... GratArpReset(); 
.................... #endif 
....................          // Handle incoming ARP responses 
.................... #ifdef STACK_CLIENT_MODE 
....................          if(packet.Operation == ARP_OPERATION_RESP) 
03C02:  MOVF   x7A,W
03C04:  SUBLW  02
03C06:  BNZ   3C3C
03C08:  MOVF   x7B,F
03C0A:  BNZ   3C3C
....................          { 
.................... /*                #if defined(STACK_USE_AUTO_IP) 
....................                 for (i = 0; i < NETWORK_INTERFACES; i++) 
....................                     if (AutoIPConfigIsInProgress(i)) 
....................                         AutoIPConflict(i); 
....................                 #endif*/ 
....................             Cache.MACAddr = packet.SenderMACAddr; 
03C0C:  CLRF   FEA
03C0E:  MOVLW  86
03C10:  MOVWF  FE9
03C12:  MOVLW  01
03C14:  MOVWF  FE2
03C16:  MOVLW  7C
03C18:  MOVWF  FE1
03C1A:  MOVLW  06
03C1C:  MOVWF  01
03C1E:  MOVFF  FE6,FEE
03C22:  DECFSZ 01,F
03C24:  BRA    3C1E
....................             Cache.IPAddr = packet.SenderIPAddr; 
03C26:  MOVFF  185,85
03C2A:  MOVFF  184,84
03C2E:  MOVFF  183,83
03C32:  MOVFF  182,82
....................             return TRUE; 
03C36:  MOVLW  01
03C38:  MOVWF  01
03C3A:  BRA    3CE6
....................          } 
.................... #endif 
....................  
....................          // Handle incoming ARP requests for our MAC address 
....................          if(packet.Operation == ARP_OPERATION_REQ) 
03C3C:  DECFSZ x7A,W
03C3E:  BRA    3C8E
03C40:  MOVF   x7B,F
03C42:  BNZ   3C8E
....................          { 
....................             if(packet.TargetIPAddr.Val != AppConfig.MyIPAddr.Val) 
03C44:  MOVF   29,W
03C46:  SUBWF  x8C,W
03C48:  BNZ   3C5C
03C4A:  MOVF   2A,W
03C4C:  SUBWF  x8D,W
03C4E:  BNZ   3C5C
03C50:  MOVF   2B,W
03C52:  SUBWF  x8E,W
03C54:  BNZ   3C5C
03C56:  MOVF   2C,W
03C58:  SUBWF  x8F,W
03C5A:  BZ    3C62
....................             { 
....................                return TRUE; 
03C5C:  MOVLW  01
03C5E:  MOVWF  01
03C60:  BRA    3CE6
....................             } 
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................                                /* Fix for Loop-Back suppression: 
....................                                 * For ZCLL-Claim packets, host should not respond. 
....................                                 * Check Sender's MAC-address with own MAC-address and  
....................                                 * if it is matched, response will not be sent back. This 
....................                                 * was leading to flooding of ARP-answeres */ 
....................                                 if(!memcmp (&packet.SenderMACAddr, &AppConfig.MyMACAddr, 6)) 
....................                                 { 
....................                                      putsUART("Loopback answer suppressed \r\n"); 
....................                                      return TRUE; 
....................                                 } 
.................... #endif 
....................                 #if defined(STACK_USE_AUTO_IP) 
....................                 for (i = 0; i < NETWORK_INTERFACES; i++) 
....................                     if (AutoIPConfigIsInProgress(i)) 
....................                     { 
....................                         AutoIPConflict(i); 
....................                         return TRUE; 
....................                     }              
....................                 #endif 
....................             Target.IPAddr = packet.SenderIPAddr; 
03C62:  MOVFF  185,8F
03C66:  MOVFF  184,8E
03C6A:  MOVFF  183,8D
03C6E:  MOVFF  182,8C
....................             Target.MACAddr = packet.SenderMACAddr; 
03C72:  CLRF   FEA
03C74:  MOVLW  90
03C76:  MOVWF  FE9
03C78:  MOVLW  01
03C7A:  MOVWF  FE2
03C7C:  MOVLW  7C
03C7E:  MOVWF  FE1
03C80:  MOVLW  06
03C82:  MOVWF  01
03C84:  MOVFF  FE6,FEE
03C88:  DECFSZ 01,F
03C8A:  BRA    3C84
....................  
....................             smARP = SM_ARP_REPLY; 
03C8C:  BSF    67.2
03C8E:  MOVLB  0
....................          } 
....................          // Do not break.  If we get down here, we need to send a reply.    
....................  
....................        case SM_ARP_REPLY: 
....................            packet.Operation      = ARP_OPERATION_RESP; 
03C90:  MOVLB  1
03C92:  CLRF   x7B
03C94:  MOVLW  02
03C96:  MOVWF  x7A
....................             #if defined(STACK_USE_AUTO_IP) 
....................             if (AutoIPIsConfigured(0)) 
....................             { 
....................                 packet.TargetMACAddr.v[0] = 0xFF; 
....................                 packet.TargetMACAddr.v[1] = 0xFF; 
....................                 packet.TargetMACAddr.v[2] = 0xFF; 
....................                 packet.TargetMACAddr.v[3] = 0xFF; 
....................                 packet.TargetMACAddr.v[4] = 0xFF; 
....................                 packet.TargetMACAddr.v[5] = 0xFF; 
....................             } 
....................             else 
....................             #endif 
....................                packet.TargetMACAddr   = Target.MACAddr; 
03C98:  MOVLW  01
03C9A:  MOVWF  FEA
03C9C:  MOVLW  86
03C9E:  MOVWF  FE9
03CA0:  CLRF   FE2
03CA2:  MOVLW  90
03CA4:  MOVWF  FE1
03CA6:  MOVLW  06
03CA8:  MOVWF  01
03CAA:  MOVFF  FE6,FEE
03CAE:  DECFSZ 01,F
03CB0:  BRA    3CAA
....................            packet.TargetIPAddr      = Target.IPAddr; 
03CB2:  MOVFF  8F,18F
03CB6:  MOVFF  8E,18E
03CBA:  MOVFF  8D,18D
03CBE:  MOVFF  8C,18C
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................             packet.SenderIPAddr      = AppConfig.MyIPAddr; 
.................... #endif 
....................  
....................          // Send an ARP response to a previously received request 
....................          if(!ARPPut(&packet)) 
03CC2:  MOVLW  01
03CC4:  MOVWF  x98
03CC6:  MOVLW  74
03CC8:  MOVWF  x97
03CCA:  MOVLB  0
03CCC:  CALL   2ED2
03CD0:  MOVF   01,F
03CD2:  BNZ   3CDE
....................          { 
....................               return FALSE; 
03CD4:  MOVLW  00
03CD6:  MOVWF  01
03CD8:  MOVLB  1
03CDA:  BRA    3CE6
03CDC:  MOVLB  0
....................          } 
....................  
....................          // Begin listening for ARP requests again 
....................          smARP = SM_ARP_IDLE; 
03CDE:  BCF    67.2
....................            break; 
....................    } 
....................  
....................     return TRUE; 
03CE0:  MOVLW  01
03CE2:  MOVWF  01
03CE4:  MOVLB  1
03CE6:  MOVLB  0
03CE8:  GOTO   5AFE (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ARPResolve(IP_ADDR* IPAddr) 
....................  
....................   Summary: 
....................    Transmits an ARP request to resolve an IP address. 
....................     
....................   Description: 
....................      This function transmits and ARP request to determine the hardware 
....................      address of a given IP address. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    IPAddr - The IP address to be resolved.  The address must be specified  
....................           in network byte order (big endian). 
....................  
....................   Returns: 
....................      None 
....................  
....................   Remarks: 
....................      This function is only required when the stack is a client, and therefore 
....................      is only enabled when STACK_CLIENT_MODE is enabled. 
....................  
....................    To retrieve the ARP query result, call the ARPIsResolved() function. 
....................   ***************************************************************************/ 
.................... #ifdef STACK_CLIENT_MODE 
.................... void ARPResolve(IP_ADDR* IPAddr) 
.................... { 
....................     ARP_PACKET packet; 
....................  
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... #define KS_ARP_IP_MULTICAST_HACK y 
.................... #ifdef KS_ARP_IP_MULTICAST_HACK 
....................     if ((IPAddr->v[0] >= 224) &&(IPAddr->v[0] <= 239)) 
....................     { 
....................       // "Resolve" the IP to MAC address mapping for 
....................       // IP multicast address range from 224.0.0.0 to 239.255.255.255 
....................  
....................       Cache.MACAddr.v[0] = 0x01; 
....................       Cache.MACAddr.v[1] = 0x00; 
....................       Cache.MACAddr.v[2] = 0x5E; 
....................       Cache.MACAddr.v[3] = 0x7f & IPAddr->v[1]; 
....................       Cache.MACAddr.v[4] = IPAddr->v[2]; 
....................       Cache.MACAddr.v[5] = IPAddr->v[3]; 
....................  
....................       Cache.IPAddr.Val = IPAddr->Val; 
....................  
....................       return; 
....................    } 
.................... #endif 
.................... #endif 
....................  
....................    packet.Operation            = ARP_OPERATION_REQ; 
*
02FD6:  MOVLB  1
02FD8:  CLRF   x82
02FDA:  MOVLW  01
02FDC:  MOVWF  x81
....................    packet.TargetMACAddr.v[0]   = 0xff; 
02FDE:  SETF   x8D
....................    packet.TargetMACAddr.v[1]   = 0xff; 
02FE0:  SETF   x8E
....................    packet.TargetMACAddr.v[2]   = 0xff; 
02FE2:  SETF   x8F
....................    packet.TargetMACAddr.v[3]   = 0xff; 
02FE4:  SETF   x90
....................    packet.TargetMACAddr.v[4]   = 0xff; 
02FE6:  SETF   x91
....................    packet.TargetMACAddr.v[5]   = 0xff; 
02FE8:  SETF   x92
....................  
....................  
....................     // ARP query either the IP address directly (on our subnet), or do an ARP query for our Gateway if off of our subnet 
....................    packet.TargetIPAddr         = ((AppConfig.MyIPAddr.Val ^ IPAddr->Val) & AppConfig.MyMask.Val) ? AppConfig.MyGateway : *IPAddr; 
02FEA:  MOVFF  179,FE9
02FEE:  MOVFF  17A,FEA
02FF2:  MOVFF  FEF,00
02FF6:  MOVFF  FEC,01
02FFA:  MOVFF  FEC,02
02FFE:  MOVFF  FEC,03
03002:  MOVF   00,W
03004:  XORWF  29,W
03006:  MOVWF  x97
03008:  MOVF   01,W
0300A:  XORWF  2A,W
0300C:  MOVWF  x98
0300E:  MOVF   02,W
03010:  XORWF  2B,W
03012:  MOVWF  x99
03014:  MOVF   03,W
03016:  XORWF  2C,W
03018:  MOVWF  x9A
0301A:  MOVF   x97,W
0301C:  ANDWF  2D,W
0301E:  MOVWF  00
03020:  MOVF   x98,W
03022:  ANDWF  2E,W
03024:  MOVWF  01
03026:  MOVF   x99,W
03028:  ANDWF  2F,W
0302A:  MOVWF  02
0302C:  MOVF   x9A,W
0302E:  ANDWF  30,W
03030:  MOVWF  03
03032:  MOVF   00,F
03034:  BNZ   3042
03036:  MOVF   01,F
03038:  BNZ   3042
0303A:  MOVF   02,F
0303C:  BNZ   3042
0303E:  MOVF   03,F
03040:  BZ    3054
03042:  MOVFF  31,00
03046:  MOVFF  32,01
0304A:  MOVFF  33,02
0304E:  MOVFF  34,03
03052:  BRA    306C
03054:  MOVFF  179,FE9
03058:  MOVFF  17A,FEA
0305C:  MOVFF  FEF,00
03060:  MOVFF  FEC,01
03064:  MOVFF  FEC,02
03068:  MOVFF  FEC,03
0306C:  MOVFF  00,193
03070:  MOVFF  01,194
03074:  MOVFF  02,195
03078:  MOVFF  03,196
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................    packet.SenderIPAddr         = AppConfig.MyIPAddr; 
.................... #endif 
....................  
....................     ARPPut(&packet); 
0307C:  MOVLW  01
0307E:  MOVWF  x98
03080:  MOVLW  7B
03082:  MOVWF  x97
03084:  MOVLB  0
03086:  RCALL  2ED2
03088:  GOTO   366A (RETURN)
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL ARPIsResolved(IP_ADDR* IPAddr, MAC_ADDR* MACAddr) 
....................  
....................   Summary: 
....................    Determines if an ARP request has been resolved yet. 
....................     
....................   Description: 
....................      This function checks if an ARP request has been resolved yet, and if 
....................      so, stores the resolved MAC address in the pointer provided. 
....................  
....................   Precondition: 
....................    ARP packet is ready in the MAC buffer. 
....................  
....................   Parameters: 
....................    IPAddr - The IP address to be resolved.  This must match the IP address  
....................           provided to the ARPResolve() function call. 
....................    MACAddr - A buffer to store the corresponding MAC address retrieved from  
....................           the ARP query. 
....................  
....................   Return Values: 
....................      TRUE - The IP address has been resolved and MACAddr MAC address field 
....................          indicates the response. 
....................      FALSE -   The IP address is not yet resolved.  Try calling ARPIsResolved()  
....................          again at a later time.  If you don't get a response after a  
....................          application specific timeout period, you may want to call  
....................          ARPResolve() again to transmit another ARP query (in case if the  
....................          original query or response was lost on the network).  If you never  
....................          receive an ARP response, this may indicate that the IP address  
....................          isn't in use. 
....................  
....................   Remarks: 
....................      This function is only required when the stack is a client, and therefore 
....................      is only enabled when STACK_CLIENT_MODE is enabled. 
....................   ***************************************************************************/ 
.................... #ifdef STACK_CLIENT_MODE 
.................... BOOL ARPIsResolved(IP_ADDR* IPAddr, MAC_ADDR* MACAddr) 
.................... { 
....................     if((Cache.IPAddr.Val == IPAddr->Val) ||  
....................      ((Cache.IPAddr.Val == AppConfig.MyGateway.Val) && ((AppConfig.MyIPAddr.Val ^ IPAddr->Val) & AppConfig.MyMask.Val))) 
0308C:  MOVLB  1
0308E:  MOVFF  179,FE9
03092:  MOVFF  17A,FEA
03096:  MOVFF  FEF,00
0309A:  MOVFF  FEC,01
0309E:  MOVFF  FEC,02
030A2:  MOVFF  FEC,03
030A6:  MOVF   00,W
030A8:  MOVLB  0
030AA:  SUBWF  x82,W
030AC:  BNZ   30C0
030AE:  MOVF   01,W
030B0:  SUBWF  x83,W
030B2:  BNZ   30C0
030B4:  MOVF   02,W
030B6:  SUBWF  x84,W
030B8:  BNZ   30C0
030BA:  MOVF   03,W
030BC:  SUBWF  x85,W
030BE:  BZ    314C
030C0:  MOVF   31,W
030C2:  SUBWF  x82,W
030C4:  BNZ   3174
030C6:  MOVF   32,W
030C8:  SUBWF  x83,W
030CA:  BNZ   3174
030CC:  MOVF   33,W
030CE:  SUBWF  x84,W
030D0:  BNZ   3174
030D2:  MOVF   34,W
030D4:  SUBWF  x85,W
030D6:  BNZ   3174
030D8:  MOVLB  1
030DA:  MOVFF  179,FE9
030DE:  MOVFF  17A,FEA
030E2:  MOVFF  FEF,00
030E6:  MOVFF  FEC,01
030EA:  MOVFF  FEC,02
030EE:  MOVFF  FEC,03
030F2:  MOVF   00,W
030F4:  XORWF  29,W
030F6:  MOVWF  x7D
030F8:  MOVF   01,W
030FA:  XORWF  2A,W
030FC:  MOVWF  x7E
030FE:  MOVF   02,W
03100:  XORWF  2B,W
03102:  MOVWF  x7F
03104:  MOVF   03,W
03106:  XORWF  2C,W
03108:  MOVWF  x80
0310A:  MOVF   x7D,W
0310C:  ANDWF  2D,W
0310E:  MOVWF  00
03110:  MOVF   x7E,W
03112:  ANDWF  2E,W
03114:  MOVWF  01
03116:  MOVF   x7F,W
03118:  ANDWF  2F,W
0311A:  MOVWF  02
0311C:  MOVF   x80,W
0311E:  ANDWF  30,W
03120:  MOVWF  03
03122:  MOVF   00,F
03124:  BTFSC  FD8.2
03126:  BRA    312C
03128:  MOVLB  0
0312A:  BRA    314C
0312C:  MOVF   01,F
0312E:  BTFSC  FD8.2
03130:  BRA    3136
03132:  MOVLB  0
03134:  BRA    314C
03136:  MOVF   02,F
03138:  BTFSC  FD8.2
0313A:  BRA    3140
0313C:  MOVLB  0
0313E:  BRA    314C
03140:  MOVF   03,F
03142:  BTFSS  FD8.2
03144:  BRA    314A
03146:  MOVLB  0
03148:  BRA    3174
0314A:  MOVLB  0
....................     { 
....................         *MACAddr = Cache.MACAddr; 
0314C:  MOVFF  17C,03
03150:  MOVLB  1
03152:  MOVFF  17B,FE9
03156:  MOVFF  17C,FEA
0315A:  CLRF   FE2
0315C:  MOVLW  86
0315E:  MOVWF  FE1
03160:  MOVLW  06
03162:  MOVWF  01
03164:  MOVFF  FE6,FEE
03168:  DECFSZ 01,F
0316A:  BRA    3164
....................         return TRUE; 
0316C:  MOVLW  01
0316E:  MOVWF  01
03170:  BRA    317A
03172:  MOVLB  0
....................     } 
....................     return FALSE; 
03174:  MOVLW  00
03176:  MOVWF  01
03178:  MOVLB  1
0317A:  MOVLB  0
0317C:  GOTO   3684 (RETURN)
.................... } 
.................... #endif 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void SwapARPPacket(ARP_PACKET* p) 
....................  
....................   Description: 
....................      Swaps endian-ness of header information in an ARP packet. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    p - The ARP packet to be swapped 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... void SwapARPPacket(ARP_PACKET* p) 
.................... { 
....................     p->HardwareType     = swaps(p->HardwareType); 
*
02DF8:  MOVLB  1
02DFA:  MOVFF  199,01
02DFE:  MOVFF  19A,03
02E02:  MOVFF  199,19B
02E06:  MOVFF  19A,19C
02E0A:  MOVFF  199,FE9
02E0E:  MOVFF  19A,FEA
02E12:  MOVFF  FEC,19E
02E16:  MOVF   FED,F
02E18:  MOVFF  FEF,19D
02E1C:  MOVFF  19E,2BC
02E20:  MOVFF  19D,2BB
02E24:  MOVLB  0
02E26:  CALL   1C00
02E2A:  MOVFF  19C,FEA
02E2E:  MOVFF  19B,FE9
02E32:  MOVFF  02,FEC
02E36:  MOVF   FED,F
02E38:  MOVFF  01,FEF
....................     p->Protocol         = swaps(p->Protocol); 
02E3C:  MOVLW  02
02E3E:  MOVLB  1
02E40:  ADDWF  x99,W
02E42:  MOVWF  01
02E44:  MOVLW  00
02E46:  ADDWFC x9A,W
02E48:  MOVWF  03
02E4A:  MOVFF  01,19B
02E4E:  MOVWF  x9C
02E50:  MOVLW  02
02E52:  ADDWF  x99,W
02E54:  MOVWF  FE9
02E56:  MOVLW  00
02E58:  ADDWFC x9A,W
02E5A:  MOVWF  FEA
02E5C:  MOVFF  FEC,19E
02E60:  MOVF   FED,F
02E62:  MOVFF  FEF,19D
02E66:  MOVFF  19E,2BC
02E6A:  MOVFF  19D,2BB
02E6E:  MOVLB  0
02E70:  CALL   1C00
02E74:  MOVFF  19C,FEA
02E78:  MOVFF  19B,FE9
02E7C:  MOVFF  02,FEC
02E80:  MOVF   FED,F
02E82:  MOVFF  01,FEF
....................     p->Operation        = swaps(p->Operation); 
02E86:  MOVLW  06
02E88:  MOVLB  1
02E8A:  ADDWF  x99,W
02E8C:  MOVWF  01
02E8E:  MOVLW  00
02E90:  ADDWFC x9A,W
02E92:  MOVWF  03
02E94:  MOVFF  01,19B
02E98:  MOVWF  x9C
02E9A:  MOVLW  06
02E9C:  ADDWF  x99,W
02E9E:  MOVWF  FE9
02EA0:  MOVLW  00
02EA2:  ADDWFC x9A,W
02EA4:  MOVWF  FEA
02EA6:  MOVFF  FEC,19E
02EAA:  MOVF   FED,F
02EAC:  MOVFF  FEF,19D
02EB0:  MOVFF  19E,2BC
02EB4:  MOVFF  19D,2BB
02EB8:  MOVLB  0
02EBA:  CALL   1C00
02EBE:  MOVFF  19C,FEA
02EC2:  MOVFF  19B,FE9
02EC6:  MOVFF  02,FEC
02ECA:  MOVF   FED,F
02ECC:  MOVFF  01,FEF
02ED0:  RETURN 0
.................... } 
....................  
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) 
....................    #include "ICMP.c" 
.................... /********************************************************************* 
....................  * 
....................  *  Internet Control Message Protocol (ICMP) Server 
....................  *  Module for Microchip TCP/IP Stack 
....................  *   -Provides "ping" diagnostics 
....................  *	 -Reference: RFC 792 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.c 
....................  * Dependencies:    IP, ARP 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    	Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		03/16/07	Original 
....................  ********************************************************************/ 
.................... #define __ICMP_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................  
.................... #if defined(STACK_USE_ICMP_CLIENT) 
....................  
.................... // ICMP Timeout Value 
.................... #define ICMP_TIMEOUT	(4ul*TICK_SECOND) 
....................  
.................... // ICMP Packet Structure 
.................... typedef struct 
.................... { 
.................... 	BYTE vType; 
.................... 	BYTE vCode; 
.................... 	WORD wChecksum; 
.................... 	WORD wIdentifier; 
.................... 	WORD wSequenceNumber; 
.................... 	WORD wData; 
.................... } ICMP_PACKET; 
....................  
.................... // ICMP Sequence Number 
.................... static WORD wICMPSequenceNumber; 
.................... // ICMP tick timer variable 
.................... static DWORD ICMPTimer; 
....................  
.................... // ICMP Flag structure 
.................... static struct 
.................... { 
.................... 	unsigned char bICMPInUse:1;         // Indicates that the ICMP Client is in use 
.................... 	unsigned char bReplyValid:1;        // Indicates that a correct Ping response to one of our pings was received 
.................... 	unsigned char bRemoteHostIsROM:1;   // Indicates that a remote host name was passed as a ROM pointer argument 
.................... } ICMPFlags = {0x00}; 
....................  
.................... // ICMP Static Variables 
.................... static union 
.................... { 
.................... 	union 
.................... 	{ 
.................... 		ROM BYTE *szROM; 
.................... 		BYTE *szRAM; 
.................... 	} RemoteHost; 
.................... 	NODE_INFO ICMPRemote; 
.................... } StaticVars; 
....................  
.................... // ICMP State Machine Enumeration 
.................... static enum 
.................... { 
.................... 	SM_IDLE = 0, 
.................... 	SM_DNS_SEND_QUERY, 
.................... 	SM_DNS_GET_RESPONSE, 
.................... 	SM_ARP_SEND_QUERY, 
.................... 	SM_ARP_GET_RESPONSE, 
.................... 	SM_ICMP_SEND_ECHO_REQUEST, 
.................... 	SM_ICMP_GET_ECHO_RESPONSE 
.................... } ICMPState; 
....................  
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPProcess(void) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           *remote: Pointer to a NODE_INFO structure of the  
....................  *					ping requester 
....................  *					len: Count of how many bytes the ping header and  
....................  *					payload are in this IP packet 
....................  * 
....................  * Output:          Generates an echo reply, if requested 
....................  *					Validates and sets ICMPFlags.bReplyValid if a  
....................  *					correct ping response to one of ours is received. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPProcess(NODE_INFO *remote, WORD len) 
.................... { 
.................... 	DWORD_VAL dwVal; 
....................  
....................     // Obtain the ICMP header Type, Code, and Checksum fields 
....................     MACGetArray((BYTE*)&dwVal, sizeof(dwVal)); 
*
03EF0:  MOVLW  01
03EF2:  MOVLB  1
03EF4:  MOVWF  x7D
03EF6:  MOVLW  78
03EF8:  MOVWF  x7C
03EFA:  MOVFF  17D,2BF
03EFE:  MOVFF  FE8,2BE
03F02:  MOVLB  2
03F04:  CLRF   xC1
03F06:  MOVLW  04
03F08:  MOVWF  xC0
03F0A:  MOVLB  0
03F0C:  CALL   0EDC
.................... 	 
.................... 	// See if this is an ICMP echo (ping) request 
.................... 	if(dwVal.w[0] == 0x0008u) 
03F10:  MOVLB  1
03F12:  MOVF   x78,W
03F14:  SUBLW  08
03F16:  BNZ   3FD4
03F18:  MOVF   x79,F
03F1A:  BNZ   3FD4
.................... 	{ 
.................... 		// Validate the checksum using the Microchip MAC's DMA module 
.................... 		// The checksum data includes the precomputed checksum in the  
.................... 		// header, so a valid packet will always have a checksum of  
.................... 		// 0x0000 if the packet is not disturbed. 
.................... 		if(MACCalcRxChecksum(0+sizeof(IP_HEADER), len)) 
03F1C:  CLRF   x93
03F1E:  MOVLW  14
03F20:  MOVWF  x92
03F22:  MOVFF  177,195
03F26:  MOVFF  176,194
03F2A:  MOVLB  0
03F2C:  RCALL  3CEC
03F2E:  MOVF   01,W
03F30:  IORWF  02,W
03F32:  BZ    3F36
.................... 			return; 
03F34:  BRA    3FD2
.................... 	 
.................... 		// Calculate new Type, Code, and Checksum values 
.................... 		dwVal.v[0] = 0x00;	// Type: 0 (ICMP echo/ping reply) 
03F36:  MOVLB  1
03F38:  CLRF   x78
.................... 		dwVal.v[2] += 8;	// Subtract 0x0800 from the checksum 
03F3A:  MOVLW  08
03F3C:  ADDWF  x7A,F
.................... 		if(dwVal.v[2] < 8u) 
03F3E:  MOVF   x7A,W
03F40:  SUBLW  07
03F42:  BNC   3F4C
.................... 		{ 
.................... 			dwVal.v[3]++; 
03F44:  INCF   x7B,F
.................... 			if(dwVal.v[3] == 0u) 
03F46:  MOVF   x7B,F
03F48:  BNZ   3F4C
.................... 				dwVal.v[2]++; 
03F4A:  INCF   x7A,F
.................... 		} 
.................... 	 
.................... 	    // Wait for TX hardware to become available (finish transmitting  
.................... 	    // any previous packet) 
.................... 	    while(!IPIsTxReady()); 
03F4C:  MOVLB  0
03F4E:  CALL   1A1C
03F52:  MOVF   01,F
03F54:  BZ    3F4E
....................  
.................... 		// Position the write pointer for the next IPPutHeader operation 
.................... 		// NOTE: do not put this before the IPIsTxReady() call for WF compatbility 
.................... 	    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER)); 
03F56:  MOVLW  15
03F58:  MOVLB  2
03F5A:  MOVWF  xAC
03F5C:  MOVLW  19
03F5E:  MOVWF  xAB
03F60:  MOVLB  0
03F62:  CALL   0DBA
....................         	 
.................... 		// Create IP header in TX memory 
.................... 		IPPutHeader(remote, IP_PROT_ICMP, len); 
03F66:  MOVFF  175,29D
03F6A:  MOVFF  174,29C
03F6E:  MOVLW  01
03F70:  MOVLB  2
03F72:  MOVWF  x9E
03F74:  MOVFF  177,2A0
03F78:  MOVFF  176,29F
03F7C:  MOVLB  0
03F7E:  CALL   223C
.................... 	 
.................... 		// Copy ICMP response into the TX memory 
.................... 		MACPutArray((BYTE*)&dwVal, sizeof(dwVal)); 
03F82:  MOVLW  01
03F84:  MOVLB  1
03F86:  MOVWF  x7D
03F88:  MOVLW  78
03F8A:  MOVWF  x7C
03F8C:  MOVFF  17D,2C1
03F90:  MOVFF  FE8,2C0
03F94:  MOVLB  2
03F96:  CLRF   xC3
03F98:  MOVLW  04
03F9A:  MOVWF  xC2
03F9C:  MOVLB  0
03F9E:  CALL   0E2A
.................... 		MACMemCopyAsync(-1, -1, len-4); 
03FA2:  MOVLW  04
03FA4:  MOVLB  1
03FA6:  SUBWF  x76,W
03FA8:  MOVWF  x7C
03FAA:  MOVLW  00
03FAC:  SUBWFB x77,W
03FAE:  MOVWF  x7D
03FB0:  MOVLB  2
03FB2:  SETF   xAC
03FB4:  SETF   xAB
03FB6:  SETF   xAE
03FB8:  SETF   xAD
03FBA:  MOVWF  xB0
03FBC:  MOVFF  17C,2AF
03FC0:  MOVLB  0
03FC2:  CALL   0F7C
.................... 		while(!MACIsMemCopyDone()); 
03FC6:  CALL   11FC
03FCA:  MOVF   01,F
03FCC:  BZ    3FC6
.................... 	 
.................... 		// Transmit the echo reply packet 
.................... 	    MACFlush(); 
03FCE:  CALL   246E
03FD2:  MOVLB  1
.................... 	} 
.................... #if defined(STACK_USE_ICMP_CLIENT) 
03FD4:  MOVLB  0
03FD6:  GOTO   5AD0 (RETURN)
.................... 	else if(dwVal.w[0] == 0x0000u)	// See if this an ICMP Echo reply to our request 
.................... 	{ 
.................... 		// Get the sequence number and identifier fields 
.................... 		MACGetArray((BYTE*)&dwVal, sizeof(dwVal)); 
.................... 		 
.................... 		// See if the identifier matches the one we sent 
.................... 		if(dwVal.w[0] != 0xEFBE)	 
.................... 			return; 
.................... 	 
.................... 		if(dwVal.w[1] != wICMPSequenceNumber) 
.................... 			return; 
....................  
.................... 		// Validate the ICMP checksum field 
.................... 	    IPSetRxBuffer(0); 
.................... 		if(CalcIPBufferChecksum(sizeof(ICMP_PACKET)))	// Two bytes of payload were sent in the echo request 
.................... 			return; 
.................... 		 
.................... 		// Flag that we received the response and stop the timer ticking 
.................... 		ICMPFlags.bReplyValid = 1; 
.................... 		ICMPTimer = TickGet() - ICMPTimer; 
.................... 	} 
.................... #endif 
.................... } 
....................  
.................... #if defined(STACK_USE_ICMP_CLIENT) 
.................... /********************************************************************* 
....................  * Function:        void ICMPSendPing(DWORD dwRemoteIP) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() returned TRUE 
....................  * 
....................  * Input:           dwRemoteIP: IP Address to ping.  Must be stored  
....................  *								big endian.  Ex. 192.168.0.1 should be 
....................  *								passed as 0x0100A8C0. 
....................  * 
....................  * Output:          Begins the process of transmitting an ICMP echo  
....................  *					request.  This normally involves an ARP  
....................  *					resolution procedure first. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPSendPing(DWORD dwRemoteIP) 
.................... { 
.................... 	ICMPFlags.bReplyValid = 0; 
.................... 	ICMPTimer = TickGet(); 
.................... 	StaticVars.ICMPRemote.IPAddr.Val = dwRemoteIP; 
.................... 	ICMPState = SM_ARP_SEND_QUERY; 
.................... } 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... /********************************************************************* 
....................  * Function:        void ICMPSendPingToHost (BYTE * szRemoteHost) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() returned TRUE 
....................  * 
....................  * Input:           szRemoteHost: Host name to ping.  Must be stored  
....................  *								  in RAM if being called by PIC18. 
....................  *								  Ex. www.microchip.com 
....................  * 
....................  * Output:          Begins the process of transmitting an ICMP echo  
....................  *					request.  This normally involves an ARP  
....................  *					resolution procedure first. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPSendPingToHost(BYTE * szRemoteHost) 
.................... { 
.................... 	ICMPFlags.bReplyValid = 0; 
.................... 	ICMPTimer = TickGet(); 
.................... 	ICMPFlags.bRemoteHostIsROM = 0; 
.................... 	StaticVars.RemoteHost.szRAM = szRemoteHost; 
.................... 	ICMPState = SM_DNS_SEND_QUERY; 
.................... } 
....................  
.................... #if defined(__18CXX) 
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPSendPingToHostROM (ROM BYTE * szRemoteHost) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() returned TRUE 
....................  * 
....................  * Input:           szRemoteHost: Host name to ping.  Must be stored  
....................  *								  in ROM. Should only be called by PIC18. 
....................  *								  Ex. www.microchip.com 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Begins the process of transmitting an ICMP echo  
....................  *					request.  This normally involves an ARP  
....................  *					resolution procedure first. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPSendPingToHostROM(ROM BYTE * szRemoteHost) 
.................... { 
.................... 	ICMPFlags.bReplyValid = 0; 
.................... 	ICMPTimer = TickGet(); 
.................... 	ICMPFlags.bRemoteHostIsROM = 1; 
.................... 	StaticVars.RemoteHost.szROM = szRemoteHost; 
.................... 	ICMPState = SM_DNS_SEND_QUERY; 
.................... } 
....................  
.................... #endif 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        LONG ICMPGetReply(void) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() returned TRUE and ICMPSendPing()  
....................  *					was called 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          -3: Could not resolve hostname (DNS timeout or  
....................  *			    	    hostname invalid) 
....................  *					-2: No response received yet 
....................  *					-1: Operation timed out (longer than ICMP_TIMEOUT)  
....................  *						has elapsed. 
....................  *					>=0: Number of TICKs that elapsed between  
....................  *						 initial ICMP transmission and reception of  
....................  *						 a valid echo. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... LONG ICMPGetReply(void) 
.................... { 
.................... 	ICMP_PACKET ICMPPacket; 
....................  
.................... 	switch(ICMPState) 
.................... 	{ 
.................... #if defined(STACK_USE_DNS) 
.................... 		case SM_DNS_SEND_QUERY: 
.................... 			// Obtain DNS module ownership 
.................... 			if(!DNSBeginUsage()) 
.................... 				break; 
.................... 			 
.................... 			// Send DNS query 
.................... 			if(ICMPFlags.bRemoteHostIsROM) 
.................... 				DNSResolveROM(StaticVars.RemoteHost.szROM, DNS_TYPE_A); 
.................... 			else 
.................... 				DNSResolve(StaticVars.RemoteHost.szRAM, DNS_TYPE_A); 
.................... 			 
.................... 			ICMPState = SM_DNS_GET_RESPONSE; 
.................... 			break; 
.................... 				 
.................... 		case SM_DNS_GET_RESPONSE: 
.................... 			// See if DNS is done, and if so, get the remote IP address 
.................... 			if(!DNSIsResolved(&StaticVars.ICMPRemote.IPAddr)) 
.................... 				break; 
.................... 			 
.................... 			// Free the DNS module 
.................... 			DNSEndUsage(); 
.................... 			 
.................... 			// Return error code if the DNS query failed 
.................... 			if(StaticVars.ICMPRemote.IPAddr.Val == 0x00000000ul) 
.................... 			{ 
.................... 				ICMPState = SM_IDLE; 
.................... 				return -3; 
.................... 			} 
....................  
.................... 			ICMPState = SM_ARP_SEND_QUERY;	 
.................... 			// No break;	 
.................... #endif 
....................  
.................... 		case SM_ARP_SEND_QUERY: 
.................... 			ARPResolve(&StaticVars.ICMPRemote.IPAddr); 
.................... 			ICMPState = SM_ARP_GET_RESPONSE; 
.................... 			break; 
.................... 			 
.................... 		case SM_ARP_GET_RESPONSE: 
.................... 			// See if the ARP reponse was successfully received 
.................... 			if(!ARPIsResolved(&StaticVars.ICMPRemote.IPAddr, &StaticVars.ICMPRemote.MACAddr)) 
.................... 				break; 
.................... 			 
.................... 			ICMPState = SM_ICMP_SEND_ECHO_REQUEST; 
.................... 			// No break;  
.................... 		 
.................... 		case SM_ICMP_SEND_ECHO_REQUEST: 
.................... 		    if(!IPIsTxReady()) 
.................... 		    	break; 
....................  
.................... 			// Set up the ping packet 
.................... 			ICMPPacket.vType = 0x08;	// 0x08: Echo (ping) request 
.................... 			ICMPPacket.vCode = 0x00; 
.................... 			ICMPPacket.wChecksum = 0x0000; 
.................... 			ICMPPacket.wIdentifier = 0xEFBE; 
.................... 			wICMPSequenceNumber++;  
.................... 			ICMPPacket.wSequenceNumber = wICMPSequenceNumber; 
.................... 			ICMPPacket.wData = 0x2860; 
.................... 			ICMPPacket.wChecksum = CalcIPChecksum((BYTE*)&ICMPPacket, sizeof(ICMPPacket)); 
.................... 		 
.................... 			// Record the current time.  This will be used as a basis for  
.................... 			// finding the echo response time, which exludes the ARP and DNS  
.................... 			// steps 
.................... 			ICMPTimer = TickGet(); 
....................  
.................... 			// Position the write pointer for the next IPPutHeader operation 
.................... 		    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER)); 
.................... 		 
.................... 			// Create IP header in TX memory 
.................... 			IPPutHeader(&StaticVars.ICMPRemote, IP_PROT_ICMP, sizeof(ICMPPacket)); 
.................... 			MACPutArray((BYTE*)&ICMPPacket, sizeof(ICMPPacket)); 
.................... 			MACFlush(); 
....................  
.................... 			// Echo sent, advance state 
.................... 			ICMPState = SM_ICMP_GET_ECHO_RESPONSE; 
.................... 			break; 
....................  
.................... 		case SM_ICMP_GET_ECHO_RESPONSE: 
.................... 			// See if the echo was successfully received 
.................... 			if(ICMPFlags.bReplyValid) 
.................... 				return (LONG)ICMPTimer; 
.................... 		 
.................... 			break; 
.................... 		 
.................... 		// SM_IDLE or illegal/impossible state: 
.................... 		default: 
.................... 			return -1; 
.................... 	} 
....................  
.................... 	// See if the DNS/ARP/echo request timed out 
.................... 	if(TickGet() - ICMPTimer > ICMP_TIMEOUT) 
.................... 	{ 
.................... 		// Free DNS module if we have it in use 
.................... 		#if defined(STACK_USE_DNS) 
.................... 			if(ICMPState == SM_DNS_GET_RESPONSE) 
.................... 				DNSEndUsage(); 
.................... 		#endif 
.................... 		 
.................... 		// Stop ICMP echo test and return error to caller 
.................... 		ICMPState = SM_IDLE; 
.................... 		return -1; 
.................... 	} 
....................  
.................... 	// Still working.  No response to report yet. 
.................... 	return -2; 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPBeginUsage(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: You have successfully gained ownership of  
....................  *						  the ICMP client module and can now use the  
....................  *						  ICMPSendPing() and ICMPGetReply() functions. 
....................  *					FALSE: Some other application is using the ICMP  
....................  *						   client module.  Calling ICMPSendPing()  
....................  *						   will corrupt the other application's ping  
....................  *						   result. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Claims ownership of the ICMP module. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPBeginUsage(void) 
.................... { 
.................... 	if(ICMPFlags.bICMPInUse) 
.................... 		return FALSE; 
....................  
.................... 	ICMPFlags.bICMPInUse = TRUE; 
.................... 	return TRUE; 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPEndUsage(void) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() was called by you and it  
....................  *					returned TRUE. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Your ownership of the ICMP module is released.   
....................  *					You can no longer use ICMPSendPing(). 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Gives up ownership of the ICMP module. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPEndUsage(void) 
.................... { 
.................... 	ICMPFlags.bICMPInUse = FALSE; 
.................... } 
....................  
.................... #endif //#if defined(STACK_USE_ICMP_CLIENT) 
....................  
.................... #endif //#if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP) 
....................    #include "UDP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) 
....................    #include "DHCP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_SERVER) 
....................    #include "DHCPs.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS_SERVER) 
....................    #include "DNSs.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
....................    #include "TCP.c" 
.................... /********************************************************************* 
....................  * 
....................  *   Transmission Control Protocol (TCP) Communications Layer 
....................  *  Module for Microchip TCP/IP Stack 
....................  *    -Provides reliable, handshaked transport of application stream  
....................  *    oriented data with flow control 
....................  *    -Reference: RFC 793 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCP.c 
....................  * Dependencies:    IP, Tick, Ethernet/WiFi (ENC28J60.c, ETH97J60.c,  
....................  *               ENCX24J600.c, or WFMac.c), ARP (optional),  
....................  *               DNS (optional) 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date       Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01     Original        (Rev 1.0) 
....................  * Howard Schlunder      12/11/06   Changed almost everything to  
....................  *                           better meet RFC 793. 
....................  * Darren Rook          04/14/11 Changed TCP_SOCKET_COUNT to use TCP_CONFIGURATION. 
....................  ********************************************************************/ 
.................... #define __TCP_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_TCP) 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Configuration Parameters 
....................   ***************************************************************************/ 
....................  
.................... // Starting port for client sockets 
.................... #define LOCAL_PORT_START_NUMBER (1024u) 
.................... // End port for client sockets 
.................... #define LOCAL_PORT_END_NUMBER   (5000u) 
....................  
.................... // For debugging only.  Normal applications should never enable these 
.................... //#define DEBUG_GENERATE_TX_LOSS      62257 
.................... //#define DEBUG_GENERATE_RX_LOSS      64225 
....................  
.................... // A lot of pointer dereference code can be removed if you  
.................... // locally copy TCBStubs to an absolute memory location. 
.................... // If you define TCP_OPTIMIZE_FOR_SIZE, local caching will  
.................... // occur and will substantially decrease the entire TCP ROM  
.................... // footprint (up to 35%).  If you leave TCP_OPTIMIZE_FOR_SIZE  
.................... // undefined, the local caching will be disabled.  On PIC18  
.................... // products, this will improve TCP performance/throughput by  
.................... // approximately 15%. 
.................... #define TCP_OPTIMIZE_FOR_SIZE 
....................  
.................... // For smallest size and best throughput, TCP_OPTIMIZE_FOR_SIZE  
.................... // should always be enabled on PIC24/dsPIC products.  On PIC32  
.................... // products there is very little difference and depnds on compiler  
.................... // optimization level 
.................... #if defined(__C30__) && !defined(TCP_OPTIMIZE_FOR_SIZE) 
....................    #define TCP_OPTIMIZE_FOR_SIZE 
.................... #elif defined(__C32__) && defined(TCP_OPTIMIZE_FOR_SIZE) 
....................    #undef TCP_OPTIMIZE_FOR_SIZE 
.................... #endif 
....................  
.................... // TCP Maximum Segment Size for TX.  The TX maximum segment size is actually  
.................... // govered by the remote node's MSS option advirtised during connection  
.................... // establishment.  However, if the remote node specifies an unhandlably large  
.................... // MSS (ex: > Ethernet MTU), this define sets a hard limit so that we don't  
.................... // cause any TX buffer overflows.  If the remote node does not advirtise a MSS  
.................... // option, all TX segments are fixed at 536 bytes maximum. 
.................... #define TCP_MAX_SEG_SIZE_TX         (1460u) 
....................  
.................... // TCP Maximum Segment Size for RX.  This value is advirtised during connection  
.................... // establishment and the remote node should obey it.  This should be set to 536  
.................... // to avoid IP layer fragmentation from causing packet loss.  However, raising  
.................... // its value can enhance performance at the (small) risk of introducing  
.................... // incompatibility with certain special remote nodes (ex: ones connected via a  
.................... // slow dial up modem). 
.................... #define TCP_MAX_SEG_SIZE_RX         (536u) 
....................  
.................... // TCP Timeout and retransmit numbers 
.................... #define TCP_START_TIMEOUT_VAL      ((DWORD)TICK_SECOND*1)   // Timeout to retransmit unacked data 
.................... #define TCP_DELAYED_ACK_TIMEOUT      ((DWORD)TICK_SECOND/10)   // Timeout for delayed-acknowledgement algorithm 
.................... #define TCP_FIN_WAIT_2_TIMEOUT      ((DWORD)TICK_SECOND*5)   // Timeout for FIN WAIT 2 state 
.................... #define TCP_KEEP_ALIVE_TIMEOUT      ((DWORD)TICK_SECOND*10)   // Timeout for keep-alive messages when no traffic is sent 
.................... #define TCP_CLOSE_WAIT_TIMEOUT      ((DWORD)TICK_SECOND/5)   // Timeout for the CLOSE_WAIT state 
.................... #define TCP_MAX_RETRIES             (5u)               // Maximum number of retransmission attempts 
.................... #define TCP_MAX_UNACKED_KEEP_ALIVES   (6u)               // Maximum number of keep-alive messages that can be sent without receiving a response before automatically closing the connection 
.................... #define TCP_MAX_SYN_RETRIES         (2u)   // Smaller than all other retries to reduce SYN flood DoS duration 
....................  
.................... #define TCP_AUTO_TRANSMIT_TIMEOUT_VAL   (TICK_SECOND/25ull)   // Timeout before automatically transmitting unflushed data 
.................... #define TCP_WINDOW_UPDATE_TIMEOUT_VAL   (TICK_SECOND/5ull)   // Timeout before automatically transmitting a window update due to a TCPGet() or TCPGetArray() function call 
....................  
.................... #define TCP_SYN_QUEUE_MAX_ENTRIES   (3u)                // Number of TCP RX SYN packets to save if they cannot be serviced immediately 
.................... #define TCP_SYN_QUEUE_TIMEOUT      ((DWORD)TICK_SECOND*3)   // Timeout for when SYN queue entries are deleted if unserviceable 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    TCP Header Data Types 
....................   ***************************************************************************/ 
....................  
.................... #define FIN     (0x01)      // FIN Flag as defined in RFC 
.................... #define SYN     (0x02)      // SYN Flag as defined in RFC 
.................... #define RST     (0x04)      // Reset Flag as defined in RFC 
.................... #define PSH     (0x08)      // Push Flag as defined in RFC 
.................... #define ACK     (0x10)      // Acknowledge Flag as defined in RFC 
.................... #define URG     (0x20)      // Urgent Flag as defined in RFC 
....................  
.................... // TCP Header Data Structure 
.................... typedef struct 
.................... { 
....................    WORD    SourcePort;      // Local port number 
....................    WORD    DestPort;      // Remote port number 
....................    DWORD   SeqNumber;      // Local sequence number 
....................    DWORD   AckNumber;      // Acknowledging remote sequence number 
....................  
....................    struct 
....................    { 
....................       unsigned char Reserved3      : 4; 
....................       unsigned char Val            : 4; 
....................    } DataOffset;         // Data offset flags nibble 
....................  
....................    union 
....................    { 
....................       struct 
....................       { 
....................          unsigned char flagFIN    : 1; 
....................          unsigned char flagSYN    : 1; 
....................          unsigned char flagRST    : 1; 
....................          unsigned char flagPSH    : 1; 
....................          unsigned char flagACK    : 1; 
....................          unsigned char flagURG    : 1; 
....................          unsigned char Reserved2  : 2; 
....................       } bits; 
....................       BYTE byte; 
....................    } Flags;            // TCP Flags as defined in RFC 
....................  
....................    WORD    Window;         // Local free RX buffer window 
....................    WORD    Checksum;      // Data payload checksum 
....................    WORD    UrgentPointer;   // Urgent pointer 
.................... } TCP_HEADER; 
....................  
.................... #define TCP_OPTIONS_END_OF_LIST     (0x00u)      // End of List TCP Option Flag 
.................... #define TCP_OPTIONS_NO_OP           (0x01u)      // No Op TCP Option 
.................... #define TCP_OPTIONS_MAX_SEG_SIZE    (0x02u)      // Maximum segment size TCP flag 
.................... typedef struct 
.................... { 
....................    BYTE        Kind;                     // Type of option 
....................    BYTE        Length;                     // Length 
....................    WORD_VAL    MaxSegSize;                  // Maximum segment size 
.................... } TCP_OPTIONS;                           // TCP Options data structure                      
....................  
.................... // Structure containing all the important elements of an incomming  
.................... // SYN packet in order to establish a connection at a future time  
.................... // if all sockets on the listening port are already connected to  
.................... // someone 
.................... typedef struct  
.................... { 
....................    NODE_INFO   niSourceAddress;// Remote IP address and MAC address 
....................    WORD      wSourcePort;   // Remote TCP port number that the response SYN needs to be sent to 
....................    DWORD      dwSourceSEQ;   // Remote TCP SEQuence number that must be ACKnowledged when we send our response SYN 
....................    WORD      wDestPort;      // Local TCP port which the original SYN was destined for 
....................    WORD      wTimestamp;      // Timer to expire old SYN packets that can't be serviced at all 
.................... } TCP_SYN_QUEUE; 
....................  
....................  
.................... #if defined(STACK_CLIENT_MODE) 
.................... static WORD NextPort __attribute__((persistent));   // Tracking variable for next local client port number 
.................... #endif 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    TCB Definitions 
....................   ***************************************************************************/ 
....................  
.................... // Determines the number of defined TCP sockets 
.................... //#define TCP_SOCKET_COUNT   (sizeof(TCPSocketInitializer)/sizeof(TCPSocketInitializer[0])) 
.................... #define TCP_SOCKET_COUNT   TCP_CONFIGURATION    //ccs changed 
....................  
.................... #if defined(HI_TECH_C) 
....................    // The initializer forces this large array out of the bss section  
....................    // so we can link correctly. 
....................    #pragma psect bigdata=TCB_uRAM_BIG 
....................    #pragma psect data=TCB_uRAM 
....................    static TCB_STUB TCBStubs[TCP_SOCKET_COUNT] = {'\0'};    
....................    #pragma psect data=ordinary_data_sect 
....................    #pragma psect bigdata=ordinary_data_sect_big 
.................... #else 
....................    // The TCB array is very large.  With the C18 compiler, one must  
....................    // modify the linker script to make an array that spans more than  
....................    // one memory bank.  To do this, make the necessary changes to your  
....................    // processor's linker script (.lkr).  Here is an example showing  
....................    // gpr11 and 128 bytes of gpr12 being combined into one 384 byte  
....................    // block used exclusively by the TCB_uRAM data section: 
....................    // ... 
....................    // //DATABANK   NAME=gpr11      START=0xB00          END=0xBFF 
....................    // //DATABANK   NAME=gpr12      START=0xC00          END=0xCFF 
....................    // DATABANK   NAME=gpr11b     START=0xB00          END=0xC7F           PROTECTED 
....................    // DATABANK   NAME=gpr12      START=0xC80          END=0xCFF 
....................    // ... 
....................    // SECTION    NAME=TCB_uRAM    RAM=gpr11b 
....................    // ... 
....................    #if defined(__18CXX) && !defined(HI_TECH_C)    
....................       #pragma udata TCB_uRAM 
....................    #endif 
....................    static TCB_STUB TCBStubs[TCP_SOCKET_COUNT]; 
....................    #if defined(__18CXX) && !defined(HI_TECH_C)    
....................       #pragma udata               // Return to any other RAM section 
....................    #endif 
.................... #endif 
....................  
.................... static TCB MyTCB;                           // Currently loaded TCB 
.................... static TCP_SOCKET hCurrentTCP = INVALID_SOCKET;      // Current TCP socket 
.................... #if TCP_SYN_QUEUE_MAX_ENTRIES 
....................    #if defined(__18CXX) && !defined(HI_TECH_C)    
....................       #pragma udata SYN_QUEUE_RAM_SECT 
....................    #endif 
....................    static TCP_SYN_QUEUE SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES];   // Array of saved incoming SYN requests that need to be serviced later 
....................    #if defined(__18CXX) && !defined(HI_TECH_C)    
....................       #pragma udata 
....................    #endif 
.................... #endif 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Function Prototypes 
....................   ***************************************************************************/ 
....................  
.................... static void TCPRAMCopy(PTR_BASE wDest, BYTE vDestType, PTR_BASE wSource, BYTE vSourceType, WORD wLength); 
....................  
.................... #if defined(__18CXX) 
....................    static void TCPRAMCopyROM(PTR_BASE wDest, BYTE wDestType, ROM BYTE* wSource, WORD wLength); 
.................... #else 
....................    #define TCPRAMCopyROM(a,b,c,d)   TCPRAMCopy(a,b,c,TCP_PIC_RAM,d) 
.................... #endif 
....................  
.................... static void SendTCP(BYTE vTCPFlags, BYTE vSendFlags); 
.................... static void HandleTCPSeg(TCP_HEADER* h, WORD len); 
.................... static BOOL FindMatchingTCPSocket(TCP_HEADER* h, NODE_INFO* remote); 
.................... static void SwapTCPHeader(TCP_HEADER* header); 
.................... static void CloseSocket(void); 
.................... static void SyncTCB(void); 
....................  
.................... #if defined(WF_CS_TRIS) 
.................... UINT16 WFGetTCBSize(void); 
.................... #endif 
....................  
.................... // Indicates if this packet is a retransmission (no reset) or a new packet (reset required) 
.................... #define SENDTCP_RESET_TIMERS   0x01 
.................... // Instead of transmitting normal data, a garbage octet is transmitted according to RFC 1122 section 4.2.3.6 
.................... #define SENDTCP_KEEP_ALIVE      0x02 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    TCB Optimization Configuration 
....................   ***************************************************************************/ 
....................  
.................... #if defined(TCP_OPTIMIZE_FOR_SIZE) 
....................    static TCB_STUB MyTCBStub; 
....................     
....................    // Flushes MyTCBStub cache and loads up the specified TCB_STUB. 
....................    // Does nothing on cache hit. 
....................    static void SyncTCBStub(TCP_SOCKET hTCP) 
....................    { 
....................       if(hCurrentTCP == hTCP) 
*
00D1A:  MOVLB  2
00D1C:  MOVF   x73,W
00D1E:  MOVLB  0
00D20:  SUBWF  xDB,W
00D22:  BNZ   0D26
....................          return; 
00D24:  BRA    0DB8
....................     
....................       if(hCurrentTCP != INVALID_SOCKET) 
00D26:  MOVF   xDB,W
00D28:  SUBLW  FE
00D2A:  BZ    0D68
....................       { 
....................          // Save the current TCB stub 
....................          memcpy((void*)&TCBStubs[hCurrentTCP], (void*)&MyTCBStub, sizeof(MyTCBStub)); 
00D2C:  MOVF   xDB,W
00D2E:  MULLW  1C
00D30:  MOVF   FF3,W
00D32:  CLRF   03
00D34:  ADDLW  98
00D36:  MOVWF  01
00D38:  MOVLW  00
00D3A:  ADDWFC 03,F
00D3C:  MOVFF  01,274
00D40:  MOVLB  2
00D42:  MOVFF  03,275
00D46:  MOVLW  01
00D48:  MOVWF  x77
00D4A:  MOVLW  18
00D4C:  MOVFF  03,FEA
00D50:  MOVFF  01,FE9
00D54:  MOVFF  277,FE2
00D58:  MOVWF  FE1
00D5A:  MOVLW  1C
00D5C:  MOVWF  01
00D5E:  MOVFF  FE6,FEE
00D62:  DECFSZ 01,F
00D64:  BRA    0D5E
00D66:  MOVLB  0
....................       } 
....................     
....................       hCurrentTCP = hTCP; 
00D68:  MOVFF  273,DB
....................     
....................       if(hTCP == INVALID_SOCKET) 
00D6C:  MOVLB  2
00D6E:  MOVF   x73,W
00D70:  SUBLW  FE
00D72:  BNZ   0D7A
....................          return; 
00D74:  MOVLB  0
00D76:  BRA    0DB8
00D78:  MOVLB  2
....................     
....................       // Load up the new TCB stub 
....................       memcpy((void*)&MyTCBStub, (void*)&TCBStubs[hTCP], sizeof(MyTCBStub)); 
00D7A:  MOVLW  01
00D7C:  MOVWF  x75
00D7E:  MOVLW  18
00D80:  MOVWF  x74
00D82:  MOVF   x73,W
00D84:  MULLW  1C
00D86:  MOVF   FF3,W
00D88:  CLRF   03
00D8A:  ADDLW  98
00D8C:  MOVWF  01
00D8E:  MOVLW  00
00D90:  ADDWFC 03,F
00D92:  MOVFF  01,276
00D96:  MOVFF  03,277
00D9A:  MOVFF  275,FEA
00D9E:  MOVFF  274,FE9
00DA2:  MOVFF  03,FE2
00DA6:  MOVFF  01,FE1
00DAA:  MOVLW  1C
00DAC:  MOVWF  01
00DAE:  MOVFF  FE6,FEE
00DB2:  DECFSZ 01,F
00DB4:  BRA    0DAE
00DB6:  MOVLB  0
00DB8:  RETURN 0
....................    } 
.................... #else 
....................    // Flushes MyTCBStub cache and loads up the specified TCB_STUB. 
....................    // Does nothing on cache hit. 
....................    #define SyncTCBStub(a)   hCurrentTCP = (a) 
....................    // Alias to current TCP stub. 
....................    #define MyTCBStub      TCBStubs[hCurrentTCP] 
.................... #endif 
....................  
....................  
....................  
.................... // Flushes MyTCB cache and loads up the specified TCB. 
.................... // Does nothing on cache hit. 
.................... static void SyncTCB(void) 
.................... { 
....................    static TCP_SOCKET hLastTCB = INVALID_SOCKET; 
....................     
....................    if(hLastTCB == hCurrentTCP) 
*
0130A:  MOVF   xDB,W
0130C:  MOVLB  1
0130E:  SUBWF  x34,W
01310:  BNZ   1314
....................       return; 
01312:  BRA    13DA
....................  
....................    if(hLastTCB != INVALID_SOCKET) 
01314:  MOVF   x34,W
01316:  SUBLW  FE
01318:  BZ    1396
....................    { 
....................       // Save the current TCB 
....................       TCPRAMCopy(TCBStubs[hLastTCB].bufferTxStart - sizeof(MyTCB), TCBStubs[hLastTCB].vMemoryMedium, (PTR_BASE)&MyTCB, TCP_PIC_RAM, sizeof(MyTCB)); 
0131A:  MOVF   x34,W
0131C:  MULLW  1C
0131E:  MOVF   FF3,W
01320:  MOVLB  2
01322:  CLRF   x9D
01324:  MOVWF  x9C
01326:  MOVLW  98
01328:  ADDWF  x9C,W
0132A:  MOVWF  FE9
0132C:  MOVLW  00
0132E:  ADDWFC x9D,W
01330:  MOVWF  FEA
01332:  MOVFF  FEC,29F
01336:  MOVF   FED,F
01338:  MOVFF  FEF,29E
0133C:  MOVLW  27
0133E:  SUBWF  x9E,F
01340:  MOVLW  00
01342:  SUBWFB x9F,F
01344:  MOVLB  1
01346:  MOVF   x34,W
01348:  MULLW  1C
0134A:  MOVF   FF3,W
0134C:  MOVLB  2
0134E:  CLRF   xA1
01350:  MOVWF  xA0
01352:  MOVLW  1B
01354:  ADDWF  xA0,W
01356:  MOVWF  01
01358:  MOVLW  00
0135A:  ADDWFC xA1,W
0135C:  MOVWF  03
0135E:  MOVF   01,W
01360:  ADDLW  98
01362:  MOVWF  FE9
01364:  MOVLW  00
01366:  ADDWFC 03,W
01368:  MOVWF  FEA
0136A:  MOVFF  FEF,2A0
0136E:  CLRF   xA2
01370:  MOVLW  B4
01372:  MOVWF  xA1
01374:  MOVFF  29F,2A4
01378:  MOVFF  29E,2A3
0137C:  MOVFF  2A0,2A5
01380:  MOVFF  2A2,2A7
01384:  MOVWF  xA6
01386:  MOVLW  01
01388:  MOVWF  xA8
0138A:  CLRF   xAA
0138C:  MOVLW  27
0138E:  MOVWF  xA9
01390:  MOVLB  0
01392:  RCALL  1224
01394:  MOVLB  1
....................    } 
....................  
....................    // Load up the new TCB 
....................    hLastTCB = hCurrentTCP; 
01396:  MOVFF  DB,134
....................    TCPRAMCopy((PTR_BASE)&MyTCB, TCP_PIC_RAM, MyTCBStub.bufferTxStart - sizeof(MyTCB), MyTCBStub.vMemoryMedium, sizeof(MyTCB)); 
0139A:  MOVLB  2
0139C:  CLRF   x9D
0139E:  MOVLW  B4
013A0:  MOVWF  x9C
013A2:  MOVLW  27
013A4:  MOVLB  1
013A6:  SUBWF  x18,W
013A8:  MOVLB  2
013AA:  MOVWF  x9E
013AC:  MOVLW  00
013AE:  MOVLB  1
013B0:  SUBWFB x19,W
013B2:  MOVLB  2
013B4:  MOVWF  x9F
013B6:  MOVFF  29D,2A4
013BA:  MOVFF  29C,2A3
013BE:  MOVLW  01
013C0:  MOVWF  xA5
013C2:  MOVFF  29F,2A7
013C6:  MOVFF  29E,2A6
013CA:  MOVFF  133,2A8
013CE:  CLRF   xAA
013D0:  MOVLW  27
013D2:  MOVWF  xA9
013D4:  MOVLB  0
013D6:  RCALL  1224
013D8:  MOVLB  1
013DA:  MOVLB  0
013DC:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPInit(void) 
....................  
....................   Summary: 
....................    Initializes the TCP module. 
....................  
....................   Description: 
....................    Initializes the TCP module.  This function sets up the TCP buffers 
....................    in memory and initializes each socket to the CLOSED state.  If 
....................    insufficient memory was allocated for the TCP sockets, the function 
....................    will hang here to be captured by the debugger. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................      None 
....................       
....................   Remarks: 
....................    This function is called only one during lifetime of the application. 
....................   ***************************************************************************/ 
.................... void TCPInit(void) 
*
014AA:  MOVLW  1A
014AC:  MOVLB  1
014AE:  MOVWF  x76
014B0:  MOVLW  FC
014B2:  MOVWF  x75
.................... { 
....................    BYTE i; 
....................    BYTE vSocketsAllocated; 
....................    WORD wTXSize, wRXSize; 
....................    PTR_BASE ptrBaseAddress; 
....................    BYTE vMedium; 
....................    #if TCP_ETH_RAM_SIZE > 0 
....................    WORD wCurrentETHAddress = TCP_ETH_RAM_BASE_ADDRESS; 
....................    #endif 
....................    #if TCP_PIC_RAM_SIZE > 0 
....................    PTR_BASE ptrCurrentPICAddress = TCP_PIC_RAM_BASE_ADDRESS; 
....................    #endif 
....................    #if TCP_SPI_RAM_SIZE > 0 
....................    WORD wCurrentSPIAddress = TCP_SPI_RAM_BASE_ADDRESS; 
....................    #endif 
....................  
....................    #if defined(STACK_CLIENT_MODE) 
....................       // Initialize NextPort to a random value if it is zero (such as after  
....................       // reset on a PIC32 or PIC18 when the static memory initializer is  
....................       // used).  By starting with a random number, we decrease the risk of  
....................       // reusing a port number that was previously used if the user power  
....................       // cycles the device. 
....................       if(NextPort == 0u) 
014B4:  MOVLB  0
014B6:  MOVF   x96,F
014B8:  BNZ   14DA
014BA:  MOVF   x97,F
014BC:  BNZ   14DA
....................          NextPort = (((WORD)GenerateRandomDWORD()) & 0x07FFu) + LOCAL_PORT_START_NUMBER; 
014BE:  CALL   0774
014C2:  MOVFF  01,178
014C6:  MOVLW  07
014C8:  MOVLB  1
014CA:  ANDWF  x78,F
014CC:  MOVFF  00,96
014D0:  MOVLW  04
014D2:  MOVLB  1
014D4:  ADDWF  x78,W
014D6:  MOVLB  0
014D8:  MOVWF  x97
....................    #endif 
....................  
....................  
....................    // Mark all SYN Queue entries as invalid by zeroing the memory 
....................    #if TCP_SYN_QUEUE_MAX_ENTRIES 
....................       memset((void*)SYNQueue, 0x00, sizeof(SYNQueue)); 
014DA:  MOVLB  1
014DC:  CLRF   x78
014DE:  MOVLW  DC
014E0:  MOVWF  x77
014E2:  MOVFF  178,FEA
014E6:  MOVWF  FE9
014E8:  CLRF   00
014EA:  CLRF   02
014EC:  MOVLW  3C
014EE:  MOVWF  01
014F0:  MOVLB  0
014F2:  BRA    0CFE
....................    #endif 
....................     
....................    // Allocate all socket FIFO addresses 
....................    vSocketsAllocated = 0; 
014F4:  MOVLB  1
014F6:  CLRF   x6D
....................    for(i = 0; i < TCP_SOCKET_COUNT; i++) 
014F8:  CLRF   x6C
014FA:  MOVF   x6C,F
014FC:  BTFSS  FD8.2
014FE:  BRA    1648
....................    { 
....................       // Generate all needed sockets of each type (TCP_PURPOSE_*) 
....................       SyncTCBStub(i); 
01500:  MOVFF  16C,273
01504:  MOVLB  0
01506:  RCALL  0D1A
....................     
....................       vMedium = TCPSocketInitializer[i].vMemoryMedium; 
01508:  MOVLB  1
0150A:  MOVF   x6C,W
0150C:  MULLW  06
0150E:  MOVF   FF3,W
01510:  CLRF   x78
01512:  MOVWF  x77
01514:  MOVLW  01
01516:  ADDWF  x77,W
01518:  MOVWF  01
0151A:  MOVLW  00
0151C:  ADDWFC x78,W
0151E:  MOVWF  03
01520:  MOVF   01,W
01522:  ADDLW  23
01524:  MOVWF  FE9
01526:  MOVLW  00
01528:  ADDWFC 03,W
0152A:  MOVWF  FEA
0152C:  MOVFF  FEF,174
....................       wTXSize = TCPSocketInitializer[i].wTXBufferSize; 
01530:  MOVF   x6C,W
01532:  MULLW  06
01534:  MOVF   FF3,W
01536:  CLRF   x78
01538:  MOVWF  x77
0153A:  MOVLW  02
0153C:  ADDWF  x77,W
0153E:  MOVWF  01
01540:  MOVLW  00
01542:  ADDWFC x78,W
01544:  MOVWF  03
01546:  MOVF   01,W
01548:  ADDLW  23
0154A:  MOVWF  FE9
0154C:  MOVLW  00
0154E:  ADDWFC 03,W
01550:  MOVWF  FEA
01552:  MOVFF  FEC,16F
01556:  MOVF   FED,F
01558:  MOVFF  FEF,16E
....................       wRXSize = TCPSocketInitializer[i].wRXBufferSize; 
0155C:  MOVF   x6C,W
0155E:  MULLW  06
01560:  MOVF   FF3,W
01562:  CLRF   x78
01564:  MOVWF  x77
01566:  MOVLW  04
01568:  ADDWF  x77,W
0156A:  MOVWF  01
0156C:  MOVLW  00
0156E:  ADDWFC x78,W
01570:  MOVWF  03
01572:  MOVF   01,W
01574:  ADDLW  23
01576:  MOVWF  FE9
01578:  MOVLW  00
0157A:  ADDWFC 03,W
0157C:  MOVWF  FEA
0157E:  MOVFF  FEC,171
01582:  MOVF   FED,F
01584:  MOVFF  FEF,170
....................     
....................       switch(vMedium) 
01588:  MOVF   x74,W
0158A:  XORLW  00
0158C:  MOVLB  0
0158E:  BZ    1592
01590:  BRA    15E0
....................       { 
....................          #if TCP_ETH_RAM_SIZE > 0 
....................          case TCP_ETH_RAM: 
....................             ptrBaseAddress = wCurrentETHAddress; 
01592:  MOVFF  176,173
01596:  MOVFF  175,172
....................             wCurrentETHAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1; 
0159A:  MOVLW  27
0159C:  MOVLB  1
0159E:  ADDWF  x6E,W
015A0:  MOVWF  x77
015A2:  MOVLW  00
015A4:  ADDWFC x6F,W
015A6:  MOVWF  x78
015A8:  MOVLW  01
015AA:  ADDWF  x77,F
015AC:  MOVLW  00
015AE:  ADDWFC x78,F
015B0:  MOVF   x70,W
015B2:  ADDWF  x77,F
015B4:  MOVF   x71,W
015B6:  ADDWFC x78,F
015B8:  MOVLW  01
015BA:  ADDWF  x77,W
015BC:  MOVWF  01
015BE:  MOVLW  00
015C0:  ADDWFC x78,W
015C2:  MOVWF  03
015C4:  MOVF   01,W
015C6:  ADDWF  x75,F
015C8:  MOVF   03,W
015CA:  ADDWFC x76,F
....................             // Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us. 
....................             // If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in TCPIPConfig.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken. 
.................... #if defined(WF_CS_TRIS) 
....................             while(wCurrentETHAddress > TCP_ETH_RAM_BASE_ADDRESS + WFGetTCBSize()/*TCP_ETH_RAM_SIZE*/); 
.................... #else 
....................             while(wCurrentETHAddress > TCP_ETH_RAM_BASE_ADDRESS + TCP_ETH_RAM_SIZE); 
015CC:  MOVF   x76,W
015CE:  SUBLW  1E
015D0:  BC    15DC
015D2:  XORLW  FF
015D4:  BNZ   15CC
015D6:  MOVF   x75,W
015D8:  SUBLW  FC
015DA:  BNC   15CC
.................... #endif 
....................             break; 
015DC:  BRA    15E4
015DE:  MOVLB  0
....................          #endif 
....................              
....................          #if TCP_PIC_RAM_SIZE > 0 
....................          case TCP_PIC_RAM: 
....................             ptrBaseAddress = ptrCurrentPICAddress; 
....................             ptrCurrentPICAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1; 
....................             // Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us. 
....................             // If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in TCPIPConfig.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken. 
....................             while(ptrCurrentPICAddress > TCP_PIC_RAM_BASE_ADDRESS + TCP_PIC_RAM_SIZE); 
....................             break; 
....................          #endif 
....................              
....................          #if TCP_SPI_RAM_SIZE > 0 
....................          case TCP_SPI_RAM: 
....................             ptrBaseAddress = wCurrentSPIAddress; 
....................             wCurrentSPIAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1; 
....................             // Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us. 
....................             // If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in TCPIPConfig.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken. 
....................             while(wCurrentSPIAddress > TCP_SPI_RAM_BASE_ADDRESS + TCP_SPI_RAM_SIZE); 
....................             break; 
....................          #endif 
....................           
....................          default: 
....................             while(1); // Undefined allocation medium.  Go fix your TCPIPConfig.h TCP memory allocations. 
015E0:  BRA    15E0
015E2:  MOVLB  1
....................       } 
....................     
....................       MyTCBStub.vMemoryMedium = vMedium; 
015E4:  MOVFF  174,133
....................       MyTCBStub.bufferTxStart   = ptrBaseAddress + sizeof(TCB); 
015E8:  MOVLW  27
015EA:  ADDWF  x72,W
015EC:  MOVWF  x18
015EE:  MOVLW  00
015F0:  ADDWFC x73,W
015F2:  MOVWF  x19
....................       MyTCBStub.bufferRxStart   = MyTCBStub.bufferTxStart + wTXSize + 1; 
015F4:  MOVF   x6E,W
015F6:  ADDWF  x18,W
015F8:  MOVWF  x77
015FA:  MOVF   x6F,W
015FC:  ADDWFC x19,W
015FE:  MOVWF  x78
01600:  MOVLW  01
01602:  ADDWF  x77,W
01604:  MOVWF  x1A
01606:  MOVLW  00
01608:  ADDWFC x78,W
0160A:  MOVWF  x1B
....................       MyTCBStub.bufferEnd      = MyTCBStub.bufferRxStart + wRXSize; 
0160C:  MOVF   x70,W
0160E:  ADDWF  x1A,W
01610:  MOVWF  x1C
01612:  MOVF   x71,W
01614:  ADDWFC x1B,W
01616:  MOVWF  x1D
....................       MyTCBStub.smState      = TCP_CLOSED; 
01618:  MOVLW  0D
0161A:  MOVWF  x2E
....................       MyTCBStub.Flags.bServer   = FALSE; 
0161C:  BCF    x2F.3
....................       #if defined(STACK_USE_SSL) 
....................       MyTCBStub.sslStubID = SSL_INVALID_ID; 
....................       #endif       
....................  
....................       SyncTCB(); 
0161E:  MOVLB  0
01620:  RCALL  130A
....................       MyTCB.vSocketPurpose = TCPSocketInitializer[i].vSocketPurpose; 
01622:  MOVLB  1
01624:  MOVF   x6C,W
01626:  MULLW  06
01628:  MOVF   FF3,W
0162A:  CLRF   x78
0162C:  MOVWF  x77
0162E:  MOVLW  23
01630:  ADDWF  x77,W
01632:  MOVWF  FE9
01634:  MOVLW  00
01636:  ADDWFC x78,W
01638:  MOVWF  FEA
0163A:  MOVFF  FEF,DA
....................       CloseSocket(); 
0163E:  MOVLB  0
01640:  RCALL  13DE
01642:  MOVLB  1
01644:  INCF   x6C,F
01646:  BRA    14FA
....................    } 
01648:  MOVLB  0
0164A:  GOTO   1688 (RETURN)
.................... } 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Connection Management Functions 
....................   ***************************************************************************/ 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    TCP_SOCKET TCPOpen(DWORD dwRemoteHost, BYTE vRemoteHostType, WORD wPort, BYTE vSocketPurpose) 
....................      
....................   Summary: 
....................     Opens a TCP socket for listening or as a client. 
....................  
....................   Description: 
....................     Provides a unified method for opening TCP sockets. This function can 
....................     open both client and server sockets. For client sockets, it can accept 
....................     a host name string to query in DNS, an IP address as a string, an IP 
....................     address in binary form, or a previously resolved NODE_INFO structure 
....................     containing the remote IP address and associated MAC address. When a 
....................     host name or IP address only is provided, the TCP module will 
....................     internally perform the necessary DNS and/or ARP resolution steps before 
....................     reporting that the TCP socket is connected (via a call to 
....................     TCPISConnected returning TRUE). Server sockets ignore this destination 
....................     parameter and listen only on the indicated port. 
....................      
....................     The vSocketPurpose field allows sockets to be opened with varying 
....................     buffer size parameters and memory storage mediums. This field 
....................     corresponds to pre-defined sockets allocated in the 
....................     TCPSocketInitializer[] array in TCPIPConfig.h. The TCPIPConfig.h file 
....................     can be edited using the TCP/IP Configuration Wizard. 
....................      
....................     Sockets are statically allocated on boot, but can be claimed with this 
....................     \function and freed using TCPDisconnect or TCPClose (for client 
....................     sockets). Server sockets can be freed using TCPClose only (calls to 
....................     TCPDisconnect will return server sockets to the listening state, 
....................     allowing reuse). 
....................  
....................   Conditions: 
....................     TCP is initialized. 
....................  
....................   Input: 
....................     dwRemoteHost -     For client sockets only. Provide a pointer to a 
....................                        null\-terminated string of the remote host name (ex\: 
....................                        "www.microchip.com" or "192.168.1.123"), a literal 
....................                        destination IP address (ex\: 0x7B01A8C0 or an IP_ADDR 
....................                        data type), or a pointer to a NODE_INFO structure 
....................                        with the remote IP address and remote node or gateway 
....................                        MAC address specified. If a string is provided, note 
....................                        that it must be statically allocated in memory and 
....................                        cannot be modified or deallocated until 
....................                        TCPIsConnected returns TRUE.<p />This parameter is 
....................                        ignored for server sockets. 
....................     vRemoteHostType -  Any one of the following flags to identify the 
....................                        meaning of the dwRemoteHost parameter\: 
....................                        * TCP_OPEN_SERVER &#45; Open a server socket and 
....................                          ignore the dwRemoteHost parameter. 
....................                        * TCP_OPEN_RAM_HOST &#45; Open a client socket and 
....................                          connect it to a remote host who's name is stored as a 
....................                          null terminated string in a RAM array. Ex\: 
....................                          "www.microchip.com" or "192.168.0.123" (BYTE&#42; 
....................                          type) 
....................                        * TCP_OPEN_ROM_HOST &#45; Open a client socket and 
....................                          connect it to a remote host who's name is stored as a 
....................                          null terminated string in a literal string or ROM 
....................                          array. Ex\: "www.microchip.com" or "192.168.0.123" 
....................                          (ROM BYTE&#42; type) 
....................                        * TCP_OPEN_IP_ADDRESS &#45; Open a client socket and 
....................                          connect it to a remote IP address. Ex\: 0x7B01A8C0 
....................                          for 192.168.1.123 (DWORD type). Note that the byte 
....................                          ordering is big endian. 
....................                        * TCP_OPEN_NODE_INFO &#45; Open a client socket and 
....................                          connect it to a remote IP and MAC addresses pair 
....................                          stored in a NODE_INFO structure. dwRemoteHost must be 
....................                          a pointer to the NODE_INFO structure. This option is 
....................                          provided for backwards compatibility with 
....................                          applications built against prior stack versions that 
....................                          only implemented the TCPConnect() function. It can 
....................                          also be used to skip DNS and ARP resolution steps if 
....................                          connecting to a remote node which you've already 
....................                          connected to and have cached addresses for. 
....................     wPort -            TCP port to listen on or connect to\: 
....................                        * Client sockets &#45; the remote TCP port to which a 
....................                          connection should be made. The local port for client 
....................                          sockets will be automatically picked by the TCP 
....................                          module. 
....................                        * Server sockets &#45; the local TCP port on which to 
....................                          listen for connections. 
....................     vSocketPurpose -   Any of the TCP_PURPOSE_* constants defined in 
....................                        TCPIPConfig.h or the TCPIPConfig utility (see 
....................                        TCPSocketInitializer[] array). 
....................  
....................   Return Values: 
....................     INVALID_SOCKET -  No sockets of the specified type were available to be 
....................                       opened. 
....................     Otherwise -       A TCP_SOCKET handle. Save this handle and use it when 
....................                       calling all other TCP APIs. 
....................  
....................   Remarks: 
....................     This function replaces the old TCPConnect and TCPListen functions. 
....................      
....................     If TCP_OPEN_RAM_HOST or TCP_OPEN_ROM_HOST are used for the destination 
....................     type, the DNS client module must also be enabled (STACK_USE_DNS must be 
....................     defined in TCPIPConfig.h). 
....................  
....................   Example: 
....................     \ \  
....................     <code> 
....................     // Open a server socket 
....................     skt = TCPOpen(NULL, TCP_OPEN_SERVER, HTTP_PORT, TCP_PURPOSE_HTTP_SERVER); 
....................      
....................     // Open a client socket to www.microchip.com 
....................     // The double cast here prevents compiler warnings 
....................     skt = TCPOpen((DWORD)(PTR_BASE)"www.microchip.com", 
....................                     TCP_OPEN_ROM_HOST, 80, TCP_PURPOSE_DEFAULT); 
....................      
....................     // Reopen a client socket without repeating DNS or ARP 
....................     SOCKET_INFO cache = TCPGetSocketInfo(skt);  // Call with the old socket 
....................     skt = TCPOpen((DWORD)(PTR_BASE)&amp;cache.remote, TCP_OPEN_NODE_INFO, 
....................                     cache.remotePort.Val, TCP_PURPOSE_DEFAULT); 
....................     </code>                                                     
....................   *****************************************************************************/ 
.................... TCP_SOCKET TCPOpen(DWORD dwRemoteHost, BYTE vRemoteHostType, WORD wPort, BYTE vSocketPurpose) 
.................... { 
....................    TCP_SOCKET hTCP; 
....................  
....................    // Find an available socket that matches the specified socket type 
....................    for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++) 
*
05B04:  MOVLB  2
05B06:  CLRF   x70
05B08:  MOVF   x70,F
05B0A:  BTFSS  FD8.2
05B0C:  BRA    5CD6
....................    { 
....................       SyncTCBStub(hTCP); 
05B0E:  MOVFF  270,273
05B12:  MOVLB  0
05B14:  CALL   0D1A
....................  
....................       // Sockets that are in use will be in a non-closed state 
....................       if(MyTCBStub.smState != TCP_CLOSED) 
05B18:  MOVLB  1
05B1A:  MOVF   x2E,W
05B1C:  SUBLW  0D
05B1E:  BZ    5B22
....................          continue; 
05B20:  BRA    5CD0
....................  
....................       SyncTCB(); 
05B22:  MOVLB  0
05B24:  CALL   130A
....................  
....................       // See if this socket matches the desired type 
....................       if(MyTCB.vSocketPurpose != vSocketPurpose) 
05B28:  MOVLB  2
05B2A:  MOVF   x6F,W
05B2C:  MOVLB  0
05B2E:  SUBWF  xDA,W
05B30:  BZ    5B38
....................          continue; 
05B32:  MOVLB  1
05B34:  BRA    5CD0
05B36:  MOVLB  0
....................  
....................       // Start out assuming worst case Maximum Segment Size (changes when MSS  
....................       // option is received from remote node) 
....................       MyTCB.wRemoteMSS = 536; 
05B38:  MOVLW  02
05B3A:  MOVWF  xD8
05B3C:  MOVLW  18
05B3E:  MOVWF  xD7
....................  
....................       // See if this is a server socket 
....................       if(vRemoteHostType == TCP_OPEN_SERVER) 
05B40:  MOVLB  2
05B42:  MOVF   x6C,F
05B44:  BNZ   5B62
....................       { 
....................          MyTCB.localPort.Val = wPort; 
05B46:  MOVFF  26E,C5
05B4A:  MOVFF  26D,C4
....................          MyTCBStub.Flags.bServer = TRUE; 
05B4E:  MOVLB  1
05B50:  BSF    x2F.3
....................          MyTCBStub.smState = TCP_LISTEN; 
05B52:  MOVLW  04
05B54:  MOVWF  x2E
....................          MyTCBStub.remoteHash.Val = wPort; 
05B56:  MOVFF  26E,132
05B5A:  MOVFF  26D,131
....................          #if defined(STACK_USE_SSL_SERVER) 
....................          MyTCB.localSSLPort.Val = 0; 
....................          #endif 
....................       } 
05B5E:  BRA    5CC6
05B60:  MOVLB  2
....................       // Handle all the client mode socket types 
....................       else 
....................       { 
....................          #if defined(STACK_CLIENT_MODE) 
....................          { 
....................             // Each new socket that is opened by this node, gets the  
....................             // next sequential local port number. 
....................             if(NextPort < LOCAL_PORT_START_NUMBER || NextPort > LOCAL_PORT_END_NUMBER) 
05B62:  MOVLB  0
05B64:  MOVF   x97,W
05B66:  SUBLW  03
05B68:  BC    5B7A
05B6A:  MOVF   x97,W
05B6C:  SUBLW  12
05B6E:  BC    5B80
05B70:  XORLW  FF
05B72:  BNZ   5B7A
05B74:  MOVF   x96,W
05B76:  SUBLW  88
05B78:  BC    5B80
....................                NextPort = LOCAL_PORT_START_NUMBER; 
05B7A:  MOVLW  04
05B7C:  MOVWF  x97
05B7E:  CLRF   x96
....................              
....................             // Set the non-zero TCB fields 
....................             MyTCB.localPort.Val = NextPort++; 
05B80:  MOVFF  97,03
05B84:  MOVF   x96,W
05B86:  INCF   x96,F
05B88:  BTFSC  FD8.2
05B8A:  INCF   x97,F
05B8C:  MOVWF  xC4
05B8E:  MOVFF  03,C5
....................             MyTCB.remotePort.Val = wPort; 
05B92:  MOVFF  26E,C3
05B96:  MOVFF  26D,C2
....................     
....................             // Flag to start the DNS, ARP, SYN processes 
....................             MyTCBStub.eventTime = TickGet(); 
05B9A:  CALL   1AC2
05B9E:  MOVFF  03,129
05BA2:  MOVFF  02,128
05BA6:  MOVFF  01,127
05BAA:  MOVFF  00,126
....................             MyTCBStub.Flags.bTimerEnabled = 1; 
05BAE:  MOVLB  1
05BB0:  BSF    x2F.4
....................     
....................             switch(vRemoteHostType) 
05BB2:  MOVLB  2
05BB4:  MOVF   x6C,W
05BB6:  XORLW  03
05BB8:  MOVLB  0
05BBA:  BZ    5BC2
05BBC:  XORLW  07
05BBE:  BZ    5C42
05BC0:  BRA    5CC4
....................             { 
....................                #if defined(STACK_USE_DNS) 
....................                case TCP_OPEN_RAM_HOST: 
....................                case TCP_OPEN_ROM_HOST: 
....................                   MyTCB.remote.dwRemoteHost = dwRemoteHost; 
....................                   MyTCB.flags.bRemoteHostIsROM = (vRemoteHostType == TCP_OPEN_ROM_HOST); 
....................                   MyTCBStub.smState = TCP_GET_DNS_MODULE; 
....................                   break; 
....................                #endif 
....................        
....................                case TCP_OPEN_IP_ADDRESS: 
....................                   // dwRemoteHost is a literal IP address.  This  
....................                   // doesn't need DNS and can skip directly to the  
....................                   // Gateway ARPing step. 
....................                   MyTCBStub.remoteHash.Val = (((DWORD_VAL*)&dwRemoteHost)->w[1]+((DWORD_VAL*)&dwRemoteHost)->w[0] + wPort) ^ MyTCB.localPort.Val; 
05BC2:  MOVLW  02
05BC4:  MOVLB  2
05BC6:  MOVWF  x72
05BC8:  MOVLW  68
05BCA:  MOVWF  x71
05BCC:  MOVLW  02
05BCE:  ADDWF  x71,W
05BD0:  MOVWF  FE9
05BD2:  MOVLW  00
05BD4:  ADDWFC x72,W
05BD6:  MOVWF  FEA
05BD8:  MOVFF  FEC,274
05BDC:  MOVF   FED,F
05BDE:  MOVFF  FEF,273
05BE2:  MOVLW  02
05BE4:  MOVWF  x76
05BE6:  MOVLW  68
05BE8:  MOVWF  FE9
05BEA:  MOVFF  276,FEA
05BEE:  MOVFF  FEC,03
05BF2:  MOVF   FED,F
05BF4:  MOVF   FEF,W
05BF6:  ADDWF  x73,F
05BF8:  MOVF   03,W
05BFA:  ADDWFC x74,F
05BFC:  MOVF   x6D,W
05BFE:  ADDWF  x73,F
05C00:  MOVF   x6E,W
05C02:  ADDWFC x74,F
05C04:  MOVF   x73,W
05C06:  MOVLB  0
05C08:  XORWF  xC4,W
05C0A:  MOVLB  1
05C0C:  MOVWF  x31
05C0E:  MOVLB  2
05C10:  MOVF   x74,W
05C12:  MOVLB  0
05C14:  XORWF  xC5,W
05C16:  MOVLB  1
05C18:  MOVWF  x32
....................                   MyTCB.remote.niRemoteMACIP.IPAddr.Val = dwRemoteHost; 
05C1A:  MOVFF  26B,CD
05C1E:  MOVFF  26A,CC
05C22:  MOVFF  269,CB
05C26:  MOVFF  268,CA
....................                   MyTCB.retryCount = 0; 
05C2A:  MOVLB  0
05C2C:  CLRF   xD9
....................                   MyTCB.retryInterval = (TICK_SECOND/4)/256; 
05C2E:  CLRF   xB7
05C30:  CLRF   xB6
05C32:  CLRF   xB5
05C34:  MOVLW  26
05C36:  MOVWF  xB4
....................                   MyTCBStub.smState = TCP_GATEWAY_SEND_ARP; 
05C38:  MOVLW  02
05C3A:  MOVLB  1
05C3C:  MOVWF  x2E
....................                   break; 
05C3E:  MOVLB  0
05C40:  BRA    5CC4
....................        
....................                case TCP_OPEN_NODE_INFO: 
....................                   MyTCBStub.remoteHash.Val = (((NODE_INFO*)(PTR_BASE)dwRemoteHost)->IPAddr.w[1]+((NODE_INFO*)(PTR_BASE)dwRemoteHost)->IPAddr.w[0] + wPort) ^ MyTCB.localPort.Val; 
05C42:  MOVLW  02
05C44:  MOVLB  2
05C46:  ADDWF  x68,W
05C48:  MOVWF  FE9
05C4A:  MOVLW  00
05C4C:  ADDWFC x69,W
05C4E:  MOVWF  FEA
05C50:  MOVFF  FEC,272
05C54:  MOVF   FED,F
05C56:  MOVFF  FEF,271
05C5A:  MOVFF  268,FE9
05C5E:  MOVFF  269,FEA
05C62:  MOVFF  FEC,03
05C66:  MOVF   FED,F
05C68:  MOVF   FEF,W
05C6A:  ADDWF  x71,F
05C6C:  MOVF   03,W
05C6E:  ADDWFC x72,F
05C70:  MOVF   x6D,W
05C72:  ADDWF  x71,F
05C74:  MOVF   x6E,W
05C76:  ADDWFC x72,F
05C78:  MOVF   x71,W
05C7A:  MOVLB  0
05C7C:  XORWF  xC4,W
05C7E:  MOVLB  1
05C80:  MOVWF  x31
05C82:  MOVLB  2
05C84:  MOVF   x72,W
05C86:  MOVLB  0
05C88:  XORWF  xC5,W
05C8A:  MOVLB  1
05C8C:  MOVWF  x32
....................                   memcpy((void*)(BYTE*)&MyTCB.remote, (void*)(BYTE*)(PTR_BASE)dwRemoteHost, sizeof(NODE_INFO)); 
05C8E:  MOVLB  2
05C90:  CLRF   x72
05C92:  MOVLW  CA
05C94:  MOVFF  272,FEA
05C98:  MOVWF  FE9
05C9A:  MOVFF  269,FE2
05C9E:  MOVFF  268,FE1
05CA2:  MOVLW  0A
05CA4:  MOVWF  01
05CA6:  MOVFF  FE6,FEE
05CAA:  DECFSZ 01,F
05CAC:  BRA    5CA6
....................                   MyTCBStub.smState = TCP_SYN_SENT; 
05CAE:  MOVLW  05
05CB0:  MOVLB  1
05CB2:  MOVWF  x2E
....................                   SendTCP(SYN, SENDTCP_RESET_TIMERS); 
05CB4:  MOVLW  02
05CB6:  MOVLB  2
05CB8:  MOVWF  x72
05CBA:  MOVLW  01
05CBC:  MOVWF  x73
05CBE:  MOVLB  0
05CC0:  CALL   26A2
....................                   break; 
05CC4:  MOVLB  1
....................             } 
....................          }       
....................          #else 
....................          { 
....................             return INVALID_SOCKET; 
....................          }    
....................          #endif 
....................       } 
....................        
....................       return hTCP;       
05CC6:  MOVLB  2
05CC8:  MOVFF  270,01
05CCC:  BRA    5CDA
05CCE:  MOVLB  1
05CD0:  MOVLB  2
05CD2:  INCF   x70,F
05CD4:  BRA    5B08
....................    } 
....................  
....................    // If there is no socket available, return error. 
....................    return INVALID_SOCKET; 
05CD6:  MOVLW  FE
05CD8:  MOVWF  01
05CDA:  MOVLB  0
05CDC:  GOTO   62B2 (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPWasReset(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Self-clearing semaphore inidicating socket reset. 
....................  
....................   Description: 
....................    This function is a self-clearing semaphore indicating whether or not 
....................    a socket has been disconnected since the previous call.  This function 
....................    works for all possible disconnections: a call to TCPDisconnect, a FIN  
....................    from the remote node, or an acknowledgement timeout caused by the loss 
....................    of a network link.  It also returns TRUE after the first call to TCPInit. 
....................    Applications should use this function to reset their state machines. 
....................     
....................    This function was added due to the possibility of an error when relying 
....................    on TCPIsConnected returing FALSE to check for a condition requiring a 
....................    state machine reset.  If a socket is closed (due to a FIN ACK) and then 
....................    immediately reopened (due to a the arrival of a new SYN) in the same 
....................    cycle of the stack, calls to TCPIsConnected by the application will  
....................    never return FALSE even though the socket has been disconnected.  This  
....................    can cause errors for protocols such as HTTP in which a client will  
....................    immediately open a new connection upon closing of a prior one.  Relying 
....................    on this function instead allows applications to trap those conditions  
....................    and properly reset their internal state for the new connection. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Return Values: 
....................      TRUE - The socket has been disconnected since the previous call. 
....................      FALSE - The socket has not been disconnected since the previous call. 
....................   ***************************************************************************/ 
.................... BOOL TCPWasReset(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return TRUE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    if(MyTCBStub.Flags.bSocketReset) 
....................    { 
....................       MyTCBStub.Flags.bSocketReset = 0; 
....................       return TRUE; 
....................    }    
....................     
....................    return FALSE; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPIsConnected(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines if a socket has an established connection. 
....................  
....................   Description: 
....................    This function determines if a socket has an established connection to  
....................    a remote node.  Call this function after calling TCPOpen to determine  
....................    when the connection is set up and ready for use.  This function was  
....................    historically used to check for disconnections, but TCPWasReset is now a 
....................    more appropriate solution.  
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Return Values: 
....................      TRUE - The socket has an established connection to a remote node. 
....................      FALSE - The socket is not currently connected. 
....................  
....................   Remarks: 
....................    A socket is said to be connected only if it is in the TCP_ESTABLISHED 
....................    state.  Sockets in the process of opening or closing will return FALSE. 
....................   ***************************************************************************/ 
.................... BOOL TCPIsConnected(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
0183C:  MOVLB  2
0183E:  MOVF   x68,W
01840:  SUBLW  00
01842:  BC    184A
....................     { 
....................         return FALSE; 
01844:  MOVLW  00
01846:  MOVWF  01
01848:  BRA    1866
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
0184A:  MOVFF  268,273
0184E:  MOVLB  0
01850:  CALL   0D1A
....................    return (MyTCBStub.smState == TCP_ESTABLISHED); 
01854:  MOVLB  1
01856:  MOVF   x2E,W
01858:  SUBLW  07
0185A:  BZ    1860
0185C:  MOVLW  00
0185E:  BRA    1862
01860:  MOVLW  01
01862:  MOVWF  01
01864:  MOVLB  2
01866:  MOVLB  0
01868:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPDisconnect(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Disconnects an open socket. 
....................  
....................   Description: 
....................    This function closes a connection to a remote node by sending a FIN (if  
....................    currently connected). 
....................     
....................    The function can be called a second time to force a socket closed by  
....................    sending a RST packet.  This is useful when the application knows that  
....................    the remote node will not send an ACK (if it has crashed or lost its link), 
....................    or when the application needs to reuse the socket immediately regardless 
....................    of whether or not the remote node would like to transmit more data before 
....................    closing. 
....................     
....................    For client mode sockets, upon return, the hTCP handle is relinquished to  
....................    the TCP/IP stack and must no longer be used by the application (except for  
....................    an immediate subsequent call to TCPDisconnect() to force a RST  
....................    transmission, if needed).   
....................     
....................    For server mode sockets, upon return, the hTCP handle is NOT relinquished  
....................    to the TCP/IP stack.  After closing, the socket returns to the listening  
....................    state allowing future connection requests to be serviced.  This leaves the  
....................    hTCP handle in a valid state and must be retained for future operations on  
....................    the socket.  If you want to close the server and relinquish the socket back  
....................    to the TCP/IP stack, call the TCPClose() API instead of TCPDisconnect(). 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    hTCP - Handle of the socket to disconnect. 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    If the socket is using SSL, a CLOSE_NOTIFY record will be transmitted 
....................    first to allow the SSL session to be resumed at a later time. 
....................   ***************************************************************************/ 
.................... void TCPDisconnect(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
02CFE:  MOVLB  2
02D00:  MOVF   x68,W
02D02:  SUBLW  00
02D04:  BC    2D08
....................     { 
....................         return; 
02D06:  BRA    2DF4
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
02D08:  MOVFF  268,273
02D0C:  MOVLB  0
02D0E:  CALL   0D1A
....................  
....................    // Delete all data in the RX FIFO 
....................    // In this stack's API, the application TCP handle is  
....................    // immediately invalid after calling this function, so there  
....................    // is no longer any way to receive data from the TCP RX FIFO,  
....................    // even though the data is still there.  Leaving the data there  
....................    // could interfere with the remote node sending us a FIN if our 
....................    // RX window is zero 
....................    MyTCBStub.rxTail = MyTCBStub.rxHead; 
02D12:  MOVFF  123,125
02D16:  MOVFF  122,124
....................  
....................    switch(MyTCBStub.smState) 
02D1A:  MOVLB  1
02D1C:  MOVF   x2E,W
02D1E:  XORLW  00
02D20:  MOVLB  0
02D22:  BZ    2D4E
02D24:  XORLW  02
02D26:  BZ    2D4E
02D28:  XORLW  01
02D2A:  BZ    2D4E
02D2C:  XORLW  06
02D2E:  BZ    2D4E
02D30:  XORLW  03
02D32:  BZ    2D54
02D34:  XORLW  01
02D36:  BZ    2D54
02D38:  XORLW  0C
02D3A:  BZ    2D96
02D3C:  XORLW  05
02D3E:  BZ    2DD8
02D40:  XORLW  06
02D42:  BZ    2DE2
02D44:  XORLW  01
02D46:  BZ    2DE2
02D48:  XORLW  05
02D4A:  BZ    2DE2
02D4C:  BRA    2DE2
....................    { 
....................       #if defined(STACK_CLIENT_MODE) && defined(STACK_USE_DNS) 
....................       case TCP_DNS_RESOLVE: 
....................          DNSEndUsage();   // Release the DNS module, since the user is aborting 
....................          CloseSocket(); 
....................          break; 
....................       #endif 
....................  
....................       case TCP_GET_DNS_MODULE: 
....................       case TCP_GATEWAY_SEND_ARP: 
....................       case TCP_GATEWAY_GET_ARP: 
....................       case TCP_SYN_SENT: 
....................          CloseSocket(); 
02D4E:  CALL   13DE
....................          break; 
02D52:  BRA    2DF2
....................  
....................       case TCP_SYN_RECEIVED: 
....................       case TCP_ESTABLISHED: 
....................          #if defined(STACK_USE_SSL) 
....................          // When disconnecting SSL sockets, send a close_notify so we can resume later 
....................          if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................          { 
....................             // Flush pending data and send close_notify 
....................             SSLTxRecord(hTCP, MyTCBStub.sslStubID, SSL_APPLICATION); 
....................             SSLTxMessage(hTCP, MyTCBStub.sslStubID, SSL_ALERT_CLOSE_NOTIFY); 
....................          } 
....................          #endif 
....................  
....................          // Send the FIN.  This is done in a loop to ensure that if we have  
....................          // more data wating in the TX FIFO than can be sent in a single  
....................          // packet (due to the remote Max Segment Size packet size limit),  
....................          // we will keep generating more packets until either all data gets  
....................          // transmitted or the remote node's receive window fills up. 
....................          do 
....................          { 
....................             SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS); 
02D54:  MOVLW  11
02D56:  MOVLB  2
02D58:  MOVWF  x72
02D5A:  MOVLW  01
02D5C:  MOVWF  x73
02D5E:  MOVLB  0
02D60:  RCALL  26A2
....................             if(MyTCB.remoteWindow == 0u) 
02D62:  MOVF   xC6,F
02D64:  BNZ   2D6C
02D66:  MOVF   xC7,F
02D68:  BNZ   2D6C
....................                break; 
02D6A:  BRA    2D8C
....................          } while(MyTCBStub.txHead != MyTCB.txUnackedTail); 
02D6C:  MOVF   xC0,W
02D6E:  MOVLB  1
02D70:  SUBWF  x1E,W
02D72:  BTFSC  FD8.2
02D74:  BRA    2D7A
02D76:  MOVLB  0
02D78:  BRA    2D54
02D7A:  MOVLB  0
02D7C:  MOVF   xC1,W
02D7E:  MOVLB  1
02D80:  SUBWF  x1F,W
02D82:  BTFSC  FD8.2
02D84:  BRA    2D8A
02D86:  MOVLB  0
02D88:  BRA    2D54
02D8A:  MOVLB  0
....................           
....................          MyTCBStub.smState = TCP_FIN_WAIT_1; 
02D8C:  MOVLW  08
02D8E:  MOVLB  1
02D90:  MOVWF  x2E
....................          break; 
02D92:  MOVLB  0
02D94:  BRA    2DF2
....................  
....................       case TCP_CLOSE_WAIT: 
....................          // Send the FIN.  This is done in a loop to ensure that if we have  
....................          // more data wating in the TX FIFO than can be sent in a single  
....................          // packet (due to the remote Max Segment Size packet size limit),  
....................          // we will keep generating more packets until either all data gets  
....................          // transmitted or the remote node's receive window fills up. 
....................          do 
....................          { 
....................             SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS); 
02D96:  MOVLW  11
02D98:  MOVLB  2
02D9A:  MOVWF  x72
02D9C:  MOVLW  01
02D9E:  MOVWF  x73
02DA0:  MOVLB  0
02DA2:  RCALL  26A2
....................             if(MyTCB.remoteWindow == 0u) 
02DA4:  MOVF   xC6,F
02DA6:  BNZ   2DAE
02DA8:  MOVF   xC7,F
02DAA:  BNZ   2DAE
....................                break; 
02DAC:  BRA    2DCE
....................          } while(MyTCBStub.txHead != MyTCB.txUnackedTail); 
02DAE:  MOVF   xC0,W
02DB0:  MOVLB  1
02DB2:  SUBWF  x1E,W
02DB4:  BTFSC  FD8.2
02DB6:  BRA    2DBC
02DB8:  MOVLB  0
02DBA:  BRA    2D96
02DBC:  MOVLB  0
02DBE:  MOVF   xC1,W
02DC0:  MOVLB  1
02DC2:  SUBWF  x1F,W
02DC4:  BTFSC  FD8.2
02DC6:  BRA    2DCC
02DC8:  MOVLB  0
02DCA:  BRA    2D96
02DCC:  MOVLB  0
....................  
....................          MyTCBStub.smState = TCP_LAST_ACK; 
02DCE:  MOVLW  0C
02DD0:  MOVLB  1
02DD2:  MOVWF  x2E
....................          break; 
02DD4:  MOVLB  0
02DD6:  BRA    2DF2
....................           
....................       // These states are all already closed or don't need explicit disconnecting -- they will disconnect by themselves after a while 
....................       //case TCP_CLOSED: 
....................       //case TCP_LISTEN: 
....................       //case TCP_CLOSING: 
....................       //case TCP_TIME_WAIT: 
....................       //   return; 
....................  
....................       case TCP_CLOSED_BUT_RESERVED: 
....................          MyTCBStub.smState = TCP_CLOSED; 
02DD8:  MOVLW  0D
02DDA:  MOVLB  1
02DDC:  MOVWF  x2E
....................          break; 
02DDE:  MOVLB  0
02DE0:  BRA    2DF2
....................  
....................       // These states will close themselves after some delay, however,  
....................       // this is handled so that the user can call TCPDisconnect()  
....................       // twice to immediately close a socket (using an RST) without  
....................       // having to get an ACK back from the remote node.  This is  
....................       // great for instance when the application determines that  
....................       // the remote node has been physically disconnected and  
....................       // already knows that no ACK will be returned.  Alternatively,  
....................       // if the application needs to immediately reuse the socket  
....................       // regardless of what the other node's state is in (half open). 
....................       case TCP_FIN_WAIT_1: 
....................       case TCP_FIN_WAIT_2: 
....................       case TCP_LAST_ACK: 
....................       default: 
....................          SendTCP(RST | ACK, 0); 
02DE2:  MOVLW  14
02DE4:  MOVLB  2
02DE6:  MOVWF  x72
02DE8:  CLRF   x73
02DEA:  MOVLB  0
02DEC:  RCALL  26A2
....................          CloseSocket(); 
02DEE:  CALL   13DE
....................          break; 
02DF2:  MOVLB  2
....................    } 
02DF4:  MOVLB  0
02DF6:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPClose(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Disconnects an open socket and destroys the socket handle, including server  
....................    mode socket handles. 
....................  
....................   Description: 
....................    Disconnects an open socket and destroys the socket handle, including server  
....................    mode socket handles.  This function performs identically to the  
....................    TCPDisconnect() function, except that both client and server mode socket  
....................    handles are relinquished to the TCP/IP stack upon return. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    hTCP - Handle to the socket to disconnect and close. 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... void TCPClose(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    MyTCBStub.Flags.bServer = FALSE; 
....................    TCPDisconnect(hTCP); 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    SOCKET_INFO* TCPGetRemoteInfo(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Obtains information about a currently open socket. 
....................  
....................   Description: 
....................    Returns the SOCKET_INFO structure associated with this socket.  This  
....................    contains the NODE_INFO structure with IP and MAC address (or gateway 
....................    MAC) and the remote port. 
....................  
....................   Precondition: 
....................    TCP is initialized and the socket is connected. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    The SOCKET_INFO structure associated with this socket.  This structure is  
....................    allocated statically by the function and is valid only until the next  
....................    time TCPGetRemoteInfo() is called. 
....................   ***************************************************************************/ 
.................... SOCKET_INFO* TCPGetRemoteInfo(TCP_SOCKET hTCP) 
.................... { 
....................    static SOCKET_INFO   RemoteInfo; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    SyncTCB(); 
....................    memcpy((void*)&RemoteInfo.remote, (void*)&MyTCB.remote, sizeof(NODE_INFO)); 
....................    RemoteInfo.remotePort.Val = MyTCB.remotePort.Val; 
....................  
....................    return &RemoteInfo; 
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Transmit Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPFlush(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Immediately transmits all pending TX data. 
....................  
....................   Description: 
....................    This function immediately transmits all pending TX data with a PSH  
....................    flag.  If this function is not called, data will automatically be sent 
....................    when either a) the TX buffer is half full or b) the  
....................    TCP_AUTO_TRANSMIT_TIMEOUT_VAL (default: 40ms) has elapsed. 
....................  
....................   Precondition: 
....................    TCP is initialized and the socket is connected. 
....................  
....................   Parameters: 
....................    hTCP - The socket whose data is to be transmitted. 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    SSL application data is automatically flushed, so this function has  
....................    no effect for SSL sockets. 
....................   ***************************************************************************/ 
.................... void TCPFlush(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
05FAA:  MOVLB  2
05FAC:  MOVF   x71,W
05FAE:  SUBLW  00
05FB0:  BC    5FB4
....................     { 
....................         return; 
05FB2:  BRA    5FE8
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
05FB4:  MOVFF  271,273
05FB8:  MOVLB  0
05FBA:  CALL   0D1A
....................    SyncTCB(); 
05FBE:  CALL   130A
....................  
....................    // NOTE: Pending SSL data will NOT be transferred here 
....................  
....................    if(MyTCBStub.txHead != MyTCB.txUnackedTail) 
05FC2:  MOVF   xC0,W
05FC4:  MOVLB  1
05FC6:  SUBWF  x1E,W
05FC8:  BNZ   5FD4
05FCA:  MOVLB  0
05FCC:  MOVF   xC1,W
05FCE:  MOVLB  1
05FD0:  SUBWF  x1F,W
05FD2:  BZ    5FE6
....................    { 
....................       // Send the TCP segment with all unacked bytes 
....................       SendTCP(ACK, SENDTCP_RESET_TIMERS); 
05FD4:  MOVLW  10
05FD6:  MOVLB  2
05FD8:  MOVWF  x72
05FDA:  MOVLW  01
05FDC:  MOVWF  x73
05FDE:  MOVLB  0
05FE0:  CALL   26A2
05FE4:  MOVLB  1
05FE6:  MOVLB  2
....................    } 
05FE8:  MOVLB  0
05FEA:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPIsPutReady(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines how much free space is available in the TCP TX buffer. 
....................  
....................   Description: 
....................    Call this function to determine how many bytes can be written to the  
....................    TCP TX buffer.  If this function returns zero, the application must  
....................    return to the main stack loop before continuing in order to transmit 
....................    more data. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    The number of bytes available to be written in the TCP TX buffer. 
....................   ***************************************************************************/ 
.................... WORD TCPIsPutReady(TCP_SOCKET hTCP) 
.................... { 
....................    BYTE i; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
05E10:  MOVLB  2
05E12:  MOVF   x71,W
05E14:  SUBLW  00
05E16:  BC    5E20
....................     { 
....................         return 0; 
05E18:  MOVLW  00
05E1A:  MOVWF  01
05E1C:  MOVWF  02
05E1E:  BRA    5EBA
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
05E20:  MOVFF  271,273
05E24:  MOVLB  0
05E26:  CALL   0D1A
....................  
....................    i = MyTCBStub.smState; 
05E2A:  MOVFF  12E,272
....................  
....................    // Unconnected sockets shouldn't be transmitting anything. 
....................    if(!( (i == (BYTE)TCP_ESTABLISHED) || (i == (BYTE)TCP_CLOSE_WAIT) )) 
05E2E:  MOVLB  2
05E30:  MOVF   x72,W
05E32:  SUBLW  07
05E34:  BZ    5E44
05E36:  MOVF   x72,W
05E38:  SUBLW  0B
05E3A:  BZ    5E44
....................       return 0; 
05E3C:  MOVLW  00
05E3E:  MOVWF  01
05E40:  MOVWF  02
05E42:  BRA    5EBA
....................  
....................    // Calculate the free space in this socket's TX FIFO 
....................    #if defined(STACK_USE_SSL) 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    {// Use sslTxHead as the head pointer when SSL is active 
....................       WORD rem; 
....................        
....................       // Find out raw free space 
....................       if(MyTCBStub.sslTxHead >= MyTCBStub.txTail) 
....................          rem = (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.sslTxHead - MyTCBStub.txTail); 
....................       else 
....................          rem = MyTCBStub.txTail - MyTCBStub.sslTxHead - 1; 
....................           
....................       // Reserve space for a new MAC and header 
....................       if(rem > 22u) 
....................          return rem - 22; 
....................       else 
....................          return 0; 
....................    } 
....................    #endif 
....................     
....................    if(MyTCBStub.txHead >= MyTCBStub.txTail) 
05E44:  MOVLB  1
05E46:  MOVF   x21,W
05E48:  SUBWF  x1F,W
05E4A:  BNC   5E96
05E4C:  BNZ   5E54
05E4E:  MOVF   x20,W
05E50:  SUBWF  x1E,W
05E52:  BNC   5E96
....................       return (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.txHead - MyTCBStub.txTail); 
05E54:  MOVF   x18,W
05E56:  SUBWF  x1A,W
05E58:  MOVLB  2
05E5A:  MOVWF  x73
05E5C:  MOVLB  1
05E5E:  MOVF   x19,W
05E60:  SUBWFB x1B,W
05E62:  MOVLB  2
05E64:  MOVWF  x74
05E66:  MOVLW  01
05E68:  SUBWF  x73,F
05E6A:  MOVLW  00
05E6C:  SUBWFB x74,F
05E6E:  MOVLB  1
05E70:  MOVF   x20,W
05E72:  SUBWF  x1E,W
05E74:  MOVWF  00
05E76:  MOVF   x21,W
05E78:  SUBWFB x1F,W
05E7A:  MOVWF  03
05E7C:  MOVF   00,W
05E7E:  MOVLB  2
05E80:  SUBWF  x73,W
05E82:  MOVWF  00
05E84:  MOVF   03,W
05E86:  SUBWFB x74,W
05E88:  MOVWF  03
05E8A:  MOVFF  00,01
05E8E:  MOVWF  02
05E90:  BRA    5EBA
05E92:  BRA    5EBA
05E94:  MOVLB  1
....................    else 
....................       return MyTCBStub.txTail - MyTCBStub.txHead - 1; 
05E96:  MOVF   x1E,W
05E98:  SUBWF  x20,W
05E9A:  MOVLB  2
05E9C:  MOVWF  x73
05E9E:  MOVLB  1
05EA0:  MOVF   x1F,W
05EA2:  SUBWFB x21,W
05EA4:  MOVLB  2
05EA6:  MOVWF  x74
05EA8:  MOVLW  01
05EAA:  SUBWF  x73,W
05EAC:  MOVWF  00
05EAE:  MOVLW  00
05EB0:  SUBWFB x74,W
05EB2:  MOVWF  03
05EB4:  MOVFF  00,01
05EB8:  MOVWF  02
05EBA:  MOVLB  0
05EBC:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPPut(TCP_SOCKET hTCP, BYTE byte) 
....................  
....................   Description: 
....................    Writes a single byte to a TCP socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    byte - The byte to write. 
....................  
....................   Return Values: 
....................    TRUE - The byte was written to the transmit buffer. 
....................    FALSE - The transmit buffer was full, or the socket is not connected. 
....................   ***************************************************************************/ 
.................... BOOL TCPPut(TCP_SOCKET hTCP, BYTE byte) 
.................... { 
....................    WORD wFreeTXSpace; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
05FEC:  MOVLB  2
05FEE:  MOVF   x6D,W
05FF0:  SUBLW  00
05FF2:  BC    5FFA
....................     { 
....................         return 0; 
05FF4:  MOVLW  00
05FF6:  MOVWF  01
05FF8:  BRA    6106
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
05FFA:  MOVFF  26D,273
05FFE:  MOVLB  0
06000:  CALL   0D1A
....................  
....................    wFreeTXSpace = TCPIsPutReady(hTCP); 
06004:  MOVFF  26D,271
06008:  RCALL  5E10
0600A:  MOVFF  02,270
0600E:  MOVFF  01,26F
....................    if(wFreeTXSpace == 0u) 
06012:  MOVLB  2
06014:  MOVF   x6F,F
06016:  BNZ   6024
06018:  MOVF   x70,F
0601A:  BNZ   6024
....................       return FALSE; 
0601C:  MOVLW  00
0601E:  MOVWF  01
06020:  BRA    6106
06022:  BRA    6036
....................    else if(wFreeTXSpace == 1u) // About to run out of space, lets transmit so the remote node might send an ACK back faster 
06024:  DECFSZ x6F,W
06026:  BRA    6036
06028:  MOVF   x70,F
0602A:  BNZ   6036
....................       TCPFlush(hTCP);    
0602C:  MOVFF  26D,271
06030:  MOVLB  0
06032:  RCALL  5FAA
06034:  MOVLB  2
....................  
....................    // Send all current bytes if we are crossing half full 
....................    // This is required to improve performance with the delayed  
....................    // acknowledgement algorithm 
....................    if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1))) 
06036:  MOVLB  1
06038:  BTFSC  x30.0
0603A:  BRA    6080
0603C:  MOVF   x18,W
0603E:  SUBWF  x1A,W
06040:  MOVLB  2
06042:  MOVWF  x71
06044:  MOVLB  1
06046:  MOVF   x19,W
06048:  SUBWFB x1B,W
0604A:  MOVLB  2
0604C:  MOVWF  x72
0604E:  BCF    FD8.0
06050:  RRCF   x72,W
06052:  MOVWF  03
06054:  RRCF   x71,W
06056:  MOVWF  02
06058:  MOVWF  01
0605A:  MOVF   x70,W
0605C:  SUBWF  03,W
0605E:  BTFSC  FD8.0
06060:  BRA    6066
06062:  MOVLB  1
06064:  BRA    6080
06066:  BNZ   6074
06068:  MOVF   x6F,W
0606A:  SUBWF  01,W
0606C:  BTFSC  FD8.0
0606E:  BRA    6074
06070:  MOVLB  1
06072:  BRA    6080
....................    { 
....................       TCPFlush(hTCP);    
06074:  MOVFF  26D,271
06078:  MOVLB  0
0607A:  RCALL  5FAA
....................       MyTCBStub.Flags.bHalfFullFlush = TRUE; 
0607C:  MOVLB  1
0607E:  BSF    x30.0
....................    } 
....................  
....................    #if defined(STACK_USE_SSL) 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    { 
....................       TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte)); 
....................       if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    else 
....................    { 
....................       TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte)); 
....................       if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    #else 
....................    TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte)); 
06080:  MOVLW  02
06082:  MOVLB  2
06084:  MOVWF  x72
06086:  MOVLW  6E
06088:  MOVWF  x71
0608A:  MOVFF  11F,2A4
0608E:  MOVFF  11E,2A3
06092:  MOVFF  133,2A5
06096:  MOVFF  272,2A7
0609A:  MOVWF  xA6
0609C:  MOVLW  01
0609E:  MOVWF  xA8
060A0:  CLRF   xAA
060A2:  MOVWF  xA9
060A4:  MOVLB  0
060A6:  CALL   1224
....................    if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart) 
060AA:  MOVLB  1
060AC:  INCF   x1E,F
060AE:  BTFSC  FD8.2
060B0:  INCF   x1F,F
060B2:  MOVF   x1B,W
060B4:  SUBWF  x1F,W
060B6:  BNC   60C8
060B8:  BNZ   60C0
060BA:  MOVF   x1A,W
060BC:  SUBWF  x1E,W
060BE:  BNC   60C8
....................       MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
060C0:  MOVFF  119,11F
060C4:  MOVFF  118,11E
....................    #endif 
....................     
....................  
....................    // Send the last byte as a separate packet (likely will make the remote node send back ACK faster) 
....................    if(wFreeTXSpace == 1u) 
060C8:  MOVLB  2
060CA:  DECFSZ x6F,W
060CC:  BRA    60DC
060CE:  MOVF   x70,F
060D0:  BNZ   60DC
....................    { 
....................       TCPFlush(hTCP); 
060D2:  MOVFF  26D,271
060D6:  MOVLB  0
060D8:  RCALL  5FAA
....................    } 
060DA:  BRA    6100
....................    // If not already enabled, start a timer so this data will  
....................    // eventually get sent even if the application doens't call 
....................    // TCPFlush() 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
060DC:  MOVLB  1
060DE:  BTFSC  x2F.5
060E0:  BRA    60FE
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
060E2:  BSF    x2F.5
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull; 
060E4:  MOVLB  0
060E6:  CALL   1A7C
060EA:  MOVLW  06
060EC:  MOVLB  2
060EE:  ADDWF  00,W
060F0:  MOVLB  1
060F2:  MOVWF  x2A
060F4:  MOVLW  00
060F6:  MOVLB  2
060F8:  ADDWFC 01,W
060FA:  MOVLB  1
060FC:  MOVWF  x2B
060FE:  MOVLB  0
....................    } 
....................  
....................    return TRUE; 
06100:  MOVLW  01
06102:  MOVWF  01
06104:  MOVLB  2
06106:  MOVLB  0
06108:  GOTO   6116 (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPPutArray(TCP_SOCKET hTCP, BYTE* data, WORD len) 
....................  
....................   Description: 
....................    Writes an array from RAM to a TCP socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    data - Pointer to the array to be written. 
....................    len  - Number of bytes to be written. 
....................  
....................   Returns: 
....................    The number of bytes written to the socket.  If less than len, the 
....................    buffer became full or the socket is not conected. 
....................   ***************************************************************************/ 
.................... WORD TCPPutArray(TCP_SOCKET hTCP, BYTE* data, WORD len) 
.................... { 
....................    WORD wActualLen; 
....................    WORD wFreeTXSpace; 
....................    WORD wRightLen = 0; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    wFreeTXSpace = TCPIsPutReady(hTCP); 
....................    if(wFreeTXSpace == 0u) 
....................    { 
....................       TCPFlush(hTCP); 
....................       return 0; 
....................    } 
....................  
....................    wActualLen = wFreeTXSpace; 
....................    if(wFreeTXSpace > len) 
....................       wActualLen = len; 
....................  
....................    // Send all current bytes if we are crossing half full 
....................    // This is required to improve performance with the delayed  
....................    // acknowledgement algorithm 
....................    if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1))) 
....................    { 
....................       TCPFlush(hTCP);    
....................       MyTCBStub.Flags.bHalfFullFlush = TRUE; 
....................    } 
....................     
....................    #if defined(STACK_USE_SSL) 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    { 
....................       // See if we need a two part put 
....................       if(MyTCBStub.sslTxHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................       { 
....................          wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead; 
....................          TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen); 
....................          data += wRightLen; 
....................          wActualLen -= wRightLen; 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................       } 
....................     
....................       TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen); 
....................       MyTCBStub.sslTxHead += wActualLen; 
....................    } 
....................    else 
....................    { 
....................       // See if we need a two part put 
....................       if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................       { 
....................          wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead; 
....................          TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen); 
....................          data += wRightLen; 
....................          wActualLen -= wRightLen; 
....................          MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................       } 
....................     
....................       TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen); 
....................       MyTCBStub.txHead += wActualLen; 
....................    } 
....................    #else 
....................    // See if we need a two part put 
....................    if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................    { 
....................       wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead; 
....................       TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen); 
....................       data += wRightLen; 
....................       wActualLen -= wRightLen; 
....................       MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................    } 
....................  
....................    TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen); 
....................    MyTCBStub.txHead += wActualLen; 
....................    #endif 
....................  
....................    // Send these bytes right now if we are out of TX buffer space 
....................    if(wFreeTXSpace <= len) 
....................    { 
....................       TCPFlush(hTCP); 
....................    } 
....................    // If not already enabled, start a timer so this data will  
....................    // eventually get sent even if the application doens't call 
....................    // TCPFlush() 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull; 
....................    } 
....................  
....................    return wActualLen + wRightLen; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPPutROMArray(TCP_SOCKET hTCP, ROM BYTE* data, WORD len) 
....................  
....................   Description: 
....................    Writes an array from ROM to a TCP socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    data - Pointer to the array to be written. 
....................    len  - Number of bytes to be written. 
....................  
....................   Returns: 
....................    The number of bytes written to the socket.  If less than len, the 
....................    buffer became full or the socket is not conected. 
....................  
....................   Remarks: 
....................    This function is aliased to TCPPutArray on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... WORD TCPPutROMArray(TCP_SOCKET hTCP, ROM BYTE* data, WORD len) 
.................... { 
....................    WORD wActualLen; 
....................    WORD wFreeTXSpace; 
....................    WORD wRightLen = 0; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    wFreeTXSpace = TCPIsPutReady(hTCP); 
....................    if(wFreeTXSpace == 0u) 
....................    { 
....................       TCPFlush(hTCP); 
....................       return 0; 
....................    } 
....................  
....................    // Send all current bytes if we are crossing half full 
....................    // This is required to improve performance with the delayed  
....................    // acknowledgement algorithm 
....................    if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1))) 
....................    { 
....................       TCPFlush(hTCP);    
....................       MyTCBStub.Flags.bHalfFullFlush = TRUE; 
....................    } 
....................     
....................    wActualLen = wFreeTXSpace; 
....................    if(wFreeTXSpace > len) 
....................       wActualLen = len; 
....................     
....................    #if defined(STACK_USE_SSL) 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    { 
....................       // See if we need a two part put 
....................       if(MyTCBStub.sslTxHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................       { 
....................          wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead; 
....................          TCPRAMCopyROM(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, data, wRightLen); 
....................          data += wRightLen; 
....................          wActualLen -= wRightLen; 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................       } 
....................     
....................       TCPRAMCopyROM(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, data, wActualLen); 
....................       MyTCBStub.sslTxHead += wActualLen; 
....................    } 
....................    else 
....................    { 
....................       // See if we need a two part put 
....................       if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................       { 
....................          wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead; 
....................          TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wRightLen); 
....................          data += wRightLen; 
....................          wActualLen -= wRightLen; 
....................          MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................       } 
....................     
....................       TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wActualLen); 
....................       MyTCBStub.txHead += wActualLen; 
....................    } 
....................    #else 
....................    // See if we need a two part put 
....................    if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................    { 
....................       wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead; 
....................       TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wRightLen); 
....................       data += wRightLen; 
....................       wActualLen -= wRightLen; 
....................       MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................    } 
....................  
....................    TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wActualLen); 
....................    MyTCBStub.txHead += wActualLen; 
....................    #endif 
....................  
....................    // Send these bytes right now if we are out of TX buffer space 
....................    if(wFreeTXSpace <= len) 
....................    { 
....................       TCPFlush(hTCP); 
....................    } 
....................    // If not already enabled, start a timer so this data will  
....................    // eventually get sent even if the application doens't call 
....................    // TCPFlush() 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull; 
....................    } 
....................  
....................    return wActualLen + wRightLen; 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE* TCPPutString(TCP_SOCKET hTCP, BYTE* data) 
....................  
....................   Description: 
....................    Writes a null-terminated string from RAM to a TCP socket.  The  
....................    null-terminator is not copied to the socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    data - Pointer to the string to be written. 
....................  
....................   Returns: 
....................    Pointer to the byte following the last byte written to the socket.  If 
....................    this pointer does not dereference to a NUL byte, the buffer became full 
....................    or the socket is not connected. 
....................  
....................   Remarks: 
....................    The return value of this function differs from that of TCPPutArray.  To 
....................    write long strings in a single state, initialize the *data pointer to the 
....................    first byte, then call this function repeatedly (breaking to the main  
....................    stack loop after each call) until the return value dereferences to a NUL 
....................    byte.  Save the return value as the new starting *data pointer otherwise. 
....................   ***************************************************************************/ 
.................... BYTE* TCPPutString(TCP_SOCKET hTCP, BYTE* data) 
.................... { 
....................    return data + TCPPutArray(hTCP, data, strlen((char*)data)); 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE* TCPPutROMString(TCP_SOCKET hTCP, ROM BYTE* data) 
....................  
....................   Description: 
....................    Writes a null-terminated string from ROM to a TCP socket.  The  
....................    null-terminator is not copied to the socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    data - Pointer to the string to be written. 
....................  
....................   Returns: 
....................    Pointer to the byte following the last byte written to the socket.  If 
....................    this pointer does not dereference to a NUL byte, the buffer became full 
....................    or the socket is not connected. 
....................  
....................   Remarks: 
....................    The return value of this function differs from that of TCPPutArray.  To 
....................    write long strings in a single state, initialize the *data pointer to the 
....................    first byte, then call this function repeatedly (breaking to the main  
....................    stack loop after each call) until the return value dereferences to a NUL 
....................    byte.  Save the return value as the new starting *data pointer otherwise. 
....................     
....................    This function is aliased to TCPPutString on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... ROM BYTE* TCPPutROMString(TCP_SOCKET hTCP, ROM BYTE* data) 
.................... { 
....................    return data + TCPPutROMArray(hTCP, data, strlenpgm((ROM char*)data)); 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPGetTxFIFOFull(TCP_SOCKET hTCP) 
....................  
....................   Description: 
....................    Determines how many bytes are pending in the TCP TX FIFO. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    Number of bytes pending to be flushed in the TCP TX FIFO. 
....................   ***************************************************************************/ 
.................... WORD TCPGetTxFIFOFull(TCP_SOCKET hTCP) 
.................... { 
....................    WORD wDataLen; 
....................    WORD wFIFOSize; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    // Calculate total usable FIFO size 
....................    wFIFOSize = MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1; 
....................  
....................    // Find out how many data bytes are free in the TX FIFO 
....................    wDataLen = TCPIsPutReady(hTCP); 
....................  
....................    return wFIFOSize - wDataLen; 
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Receive Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPDiscard(TCP_SOCKET hTCP) 
....................  
....................   Description: 
....................    Discards any pending data in the TCP RX FIFO. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket whose RX FIFO is to be cleared. 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... void TCPDiscard(TCP_SOCKET hTCP) 
.................... { 
....................    if(TCPIsGetReady(hTCP)) 
....................    { 
....................       SyncTCBStub(hTCP); 
....................     
....................       // Delete all data in the RX buffer 
....................       MyTCBStub.rxTail = MyTCBStub.rxHead; 
....................     
....................       // Send a Window update message to the remote node 
....................       SendTCP(ACK, SENDTCP_RESET_TIMERS); 
....................    } 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void WORD TCPIsGetReady(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines how many bytes can be read from the TCP RX buffer. 
....................  
....................   Description: 
....................    Call this function to determine how many bytes can be read from the  
....................    TCP RX buffer.  If this function returns zero, the application must  
....................    return to the main stack loop before continuing in order to wait for 
....................    more data to arrive. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    The number of bytes available to be read from the TCP RX buffer. 
....................   ***************************************************************************/ 
.................... WORD TCPIsGetReady(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
05CE0:  MOVLB  2
05CE2:  MOVF   x6D,W
05CE4:  SUBLW  00
05CE6:  BC    5CF0
....................     { 
....................         return 0; 
05CE8:  MOVLW  00
05CEA:  MOVWF  01
05CEC:  MOVWF  02
05CEE:  BRA    5D5C
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
05CF0:  MOVFF  26D,273
05CF4:  MOVLB  0
05CF6:  CALL   0D1A
....................        
....................    if(MyTCBStub.rxHead >= MyTCBStub.rxTail) 
05CFA:  MOVLB  1
05CFC:  MOVF   x25,W
05CFE:  SUBWF  x23,W
05D00:  BNC   5D24
05D02:  BNZ   5D0A
05D04:  MOVF   x24,W
05D06:  SUBWF  x22,W
05D08:  BNC   5D24
....................       return MyTCBStub.rxHead - MyTCBStub.rxTail; 
05D0A:  MOVF   x24,W
05D0C:  SUBWF  x22,W
05D0E:  MOVWF  00
05D10:  MOVF   x25,W
05D12:  SUBWFB x23,W
05D14:  MOVWF  03
05D16:  MOVFF  00,01
05D1A:  MOVWF  02
05D1C:  MOVLB  2
05D1E:  BRA    5D5C
05D20:  BRA    5D5C
05D22:  MOVLB  1
....................    else 
....................       return (MyTCBStub.bufferEnd - MyTCBStub.rxTail + 1) + (MyTCBStub.rxHead - MyTCBStub.bufferRxStart); 
05D24:  MOVF   x24,W
05D26:  SUBWF  x1C,W
05D28:  MOVLB  2
05D2A:  MOVWF  x6E
05D2C:  MOVLB  1
05D2E:  MOVF   x25,W
05D30:  SUBWFB x1D,W
05D32:  MOVLB  2
05D34:  MOVWF  x6F
05D36:  MOVLW  01
05D38:  ADDWF  x6E,F
05D3A:  MOVLW  00
05D3C:  ADDWFC x6F,F
05D3E:  MOVLB  1
05D40:  MOVF   x1A,W
05D42:  SUBWF  x22,W
05D44:  MOVWF  00
05D46:  MOVF   x1B,W
05D48:  SUBWFB x23,W
05D4A:  MOVWF  03
05D4C:  MOVF   00,W
05D4E:  MOVLB  2
05D50:  ADDWF  x6E,W
05D52:  MOVWF  01
05D54:  MOVF   x6F,W
05D56:  ADDWFC 03,F
05D58:  MOVFF  03,02
05D5C:  MOVLB  0
05D5E:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPGet(TCP_SOCKET hTCP, BYTE* byte) 
....................  
....................   Description: 
....................    Retrieves a single byte to a TCP socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket from which to read. 
....................    byte - Pointer to location in which the read byte should be stored. 
....................  
....................   Return Values: 
....................    TRUE - A byte was read from the buffer. 
....................    FALSE - The buffer was empty, or the socket is not connected. 
....................   ***************************************************************************/ 
.................... BOOL TCPGet(TCP_SOCKET hTCP, BYTE* byte) 
.................... { 
....................    WORD wGetReadyCount; 
....................  
....................    // See if there is any data which can be read 
....................    wGetReadyCount = TCPIsGetReady(hTCP); 
05D60:  MOVFF  268,26D
05D64:  RCALL  5CE0
05D66:  MOVFF  02,26C
05D6A:  MOVFF  01,26B
....................    if(wGetReadyCount == 0u) 
05D6E:  MOVLB  2
05D70:  MOVF   x6B,F
05D72:  BNZ   5D7E
05D74:  MOVF   x6C,F
05D76:  BNZ   5D7E
....................       return FALSE; 
05D78:  MOVLW  00
05D7A:  MOVWF  01
05D7C:  BRA    5E0A
....................  
....................    SyncTCBStub(hTCP); 
05D7E:  MOVFF  268,273
05D82:  MOVLB  0
05D84:  CALL   0D1A
....................     
....................    if(byte) 
05D88:  MOVLB  2
05D8A:  MOVF   x69,W
05D8C:  IORWF  x6A,W
05D8E:  BZ    5DB4
....................       TCPRAMCopy((PTR_BASE)byte, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, 1); 
05D90:  MOVFF  26A,2A4
05D94:  MOVFF  269,2A3
05D98:  MOVLW  01
05D9A:  MOVWF  xA5
05D9C:  MOVFF  125,2A7
05DA0:  MOVFF  124,2A6
05DA4:  MOVFF  133,2A8
05DA8:  CLRF   xAA
05DAA:  MOVWF  xA9
05DAC:  MOVLB  0
05DAE:  CALL   1224
05DB2:  MOVLB  2
....................    if(++MyTCBStub.rxTail > MyTCBStub.bufferEnd) 
05DB4:  MOVLB  1
05DB6:  INCF   x24,F
05DB8:  BTFSC  FD8.2
05DBA:  INCF   x25,F
05DBC:  MOVF   x1D,W
05DBE:  SUBWF  x25,W
05DC0:  BNC   5DD2
05DC2:  BNZ   5DCA
05DC4:  MOVF   x24,W
05DC6:  SUBWF  x1C,W
05DC8:  BC    5DD2
....................       MyTCBStub.rxTail = MyTCBStub.bufferRxStart; 
05DCA:  MOVFF  11B,125
05DCE:  MOVFF  11A,124
....................  
....................    // Send a window update if we've run out of data 
....................    if(wGetReadyCount == 1u) 
05DD2:  MOVLB  2
05DD4:  DECFSZ x6B,W
05DD6:  BRA    5DE2
05DD8:  MOVF   x6C,F
05DDA:  BNZ   5DE2
....................    { 
....................       MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
05DDC:  MOVLB  1
05DDE:  BSF    x30.2
....................    } 
05DE0:  BRA    5E04
....................    // If not already enabled, start a timer so a window  
....................    // update will get sent to the remote node at some point 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
05DE2:  MOVLB  1
05DE4:  BTFSC  x2F.5
05DE6:  BRA    5E04
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
05DE8:  BSF    x2F.5
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_WINDOW_UPDATE_TIMEOUT_VAL/256ull; 
05DEA:  MOVLB  0
05DEC:  CALL   1A7C
05DF0:  MOVLW  1E
05DF2:  MOVLB  2
05DF4:  ADDWF  00,W
05DF6:  MOVLB  1
05DF8:  MOVWF  x2A
05DFA:  MOVLW  00
05DFC:  MOVLB  2
05DFE:  ADDWFC 01,W
05E00:  MOVLB  1
05E02:  MOVWF  x2B
....................    } 
....................  
....................  
....................    return TRUE; 
05E04:  MOVLW  01
05E06:  MOVWF  01
05E08:  MOVLB  2
05E0A:  MOVLB  0
05E0C:  GOTO   6342 (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPGetArray(TCP_SOCKET hTCP, BYTE* buffer, WORD len) 
....................  
....................   Description: 
....................    Reads an array of data bytes from a TCP socket's receive FIFO.  The data  
....................    is removed from the FIFO in the process. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket from which data is to be read. 
....................    buffer - Pointer to the array to store data that was read. 
....................    len  - Number of bytes to be read. 
....................  
....................   Returns: 
....................    The number of bytes read from the socket.  If less than len, the 
....................    RX FIFO buffer became empty or the socket is not conected. 
....................   ***************************************************************************/ 
.................... WORD TCPGetArray(TCP_SOCKET hTCP, BYTE* buffer, WORD len) 
.................... { 
....................    WORD wGetReadyCount; 
....................    WORD RightLen = 0; 
....................  
....................    // See if there is any data which can be read 
....................    wGetReadyCount = TCPIsGetReady(hTCP); 
....................    if(wGetReadyCount == 0u) 
....................       return 0x0000u; 
....................  
....................    SyncTCBStub(hTCP); 
....................  
....................    // Make sure we don't try to read more data than is available 
....................    if(len > wGetReadyCount) 
....................       len = wGetReadyCount; 
....................  
....................    // See if we need a two part get 
....................    if(MyTCBStub.rxTail + len > MyTCBStub.bufferEnd) 
....................    { 
....................       RightLen = MyTCBStub.bufferEnd - MyTCBStub.rxTail + 1; 
....................       if(buffer) 
....................       { 
....................          TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, RightLen); 
....................          buffer += RightLen; 
....................       } 
....................       len -= RightLen; 
....................       MyTCBStub.rxTail = MyTCBStub.bufferRxStart; 
....................    } 
....................  
....................    if(buffer) 
....................       TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, len); 
....................    MyTCBStub.rxTail += len; 
....................    len += RightLen; 
....................  
....................    // Send a window update if we've run low on data 
....................    if(wGetReadyCount - len <= len) 
....................    { 
....................       MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
....................    } 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
....................    // If not already enabled, start a timer so a window  
....................    // update will get sent to the remote node at some point 
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_WINDOW_UPDATE_TIMEOUT_VAL/256ull; 
....................    } 
....................  
....................    return len; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPGetRxFIFOFree(TCP_SOCKET hTCP) 
....................  
....................   Description: 
....................    Determines how many bytes are free in the RX FIFO. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    The number of bytes free in the TCP RX FIFO.  If zero, no additional  
....................    data can be received until the application removes some data using one 
....................    of the TCPGet family functions. 
....................   ***************************************************************************/ 
.................... WORD TCPGetRxFIFOFree(TCP_SOCKET hTCP) 
.................... { 
....................    WORD wDataLen; 
....................    WORD wFIFOSize; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    // Calculate total usable FIFO size 
....................    wFIFOSize = MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart; 
....................  
....................    #if defined(STACK_USE_SSL) 
....................    { 
....................       PTR_BASE SSLtemp = MyTCBStub.rxHead; 
....................  
....................       // Move SSL pointer to determine full buffer size 
....................       if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................          MyTCBStub.rxHead = MyTCBStub.sslRxHead; 
....................  
....................       // Find out how many data bytes are actually in the RX FIFO 
....................       wDataLen = TCPIsGetReady(hTCP); 
....................        
....................       // Move SSL pointer back to proper location (if we changed it) 
....................       MyTCBStub.rxHead = SSLtemp; 
....................    } 
....................    #else 
....................    { 
....................       // Find out how many data bytes are actually in the RX FIFO 
....................       wDataLen = TCPIsGetReady(hTCP); 
....................    } 
....................    #endif 
....................     
....................    // Perform the calculation    
....................    return wFIFOSize - wDataLen; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPPeekArray(TCP_SOCKET hTCP, BYTE *vBuffer, WORD wLen, WORD wStart) 
....................  
....................   Summary: 
....................      Reads a specified number of data bytes from the TCP RX FIFO without  
....................      removing them from the buffer. 
....................  
....................   Description: 
....................    Reads a specified number of data bytes from the TCP RX FIFO without  
....................      removing them from the buffer.  No TCP control actions are taken as a  
....................      result of this function (ex: no window update is sent to the remote node). 
....................       
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to peak from (read without removing from stream). 
....................    vBuffer - Destination to write the peeked data bytes. 
....................    wLen - Length of bytes to peak from the RX FIFO and copy to vBuffer. 
....................    wStart - Zero-indexed starting position within the FIFO to start peeking  
....................       from. 
....................  
....................   Return Values: 
....................    Number of bytes actually peeked from the stream and copied to vBuffer.   
....................    This value can be less than wLen if wStart + wLen is greater than the  
....................    deepest possible character in the RX FIFO. 
....................  
....................   Remarks: 
....................      None 
....................   ***************************************************************************/ 
.................... WORD TCPPeekArray(TCP_SOCKET hTCP, BYTE *vBuffer, WORD wLen, WORD wStart) 
.................... { 
....................    PTR_BASE ptrRead; 
....................    WORD w; 
....................    WORD wBytesUntilWrap; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT || wLen == 0) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    // Find out how many bytes are in the RX FIFO and decrease read length  
....................    // if the start offset + read length is beyond the end of the FIFO 
....................    w = TCPIsGetReady(hTCP); 
....................    if(wStart + wLen > w) 
....................       wLen = w - wStart; 
....................  
....................    // Find the read start location 
....................    ptrRead = MyTCBStub.rxTail + wStart; 
....................    if(ptrRead > MyTCBStub.bufferEnd) 
....................       ptrRead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................  
....................    // Calculate how many bytes can be read in a single go 
....................    wBytesUntilWrap = MyTCBStub.bufferEnd - ptrRead + 1; 
....................    if(wLen <= wBytesUntilWrap) 
....................    { 
....................       // Read all at once 
....................       TCPRAMCopy((PTR_BASE)vBuffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, wLen); 
....................    } 
....................    else 
....................    { 
....................       // Read all bytes up to the wrap position and then read remaining bytes  
....................       // at the start of the buffer 
....................       TCPRAMCopy((PTR_BASE)vBuffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, wBytesUntilWrap); 
....................       TCPRAMCopy((PTR_BASE)vBuffer+wBytesUntilWrap, TCP_PIC_RAM, MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, wLen - wBytesUntilWrap); 
....................    } 
....................     
....................    return wLen; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE TCPPeek(TCP_SOCKET hTCP, WORD wStart) 
....................  
....................   Summary: 
....................      Peaks at one byte in the TCP RX FIFO without removing it from the buffer. 
....................  
....................   Description: 
....................    Peaks at one byte in the TCP RX FIFO without removing it from the buffer. 
....................       
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to peak from (read without removing from stream). 
....................    wStart - Zero-indexed starting position within the FIFO to peek from. 
....................  
....................   Return Values: 
....................    Byte peeked from the RX FIFO.  If there is no data in the buffer or an  
....................    illegal wStart starting offset is given, then an indeterminate value is  
....................    returned.  The caller must ensure that valid parameters are passed to avoid  
....................    (i.e ensure that TCPIsGetReady() returns a number that is less than wStart  
....................    before calling TCPPeek()). 
....................  
....................   Remarks: 
....................      Use the TCPPeekArray() function to read more than one byte.  It will  
....................      perform better than calling TCPPeek() in a loop. 
....................   ***************************************************************************/ 
.................... BYTE TCPPeek(TCP_SOCKET hTCP, WORD wStart) 
.................... { 
....................    BYTE i; 
....................     
....................    TCPPeekArray(hTCP, &i, 1, wStart); 
....................    return i; 
.................... } 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Search Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPFindArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen,  
....................                   WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
....................  
....................   Summary: 
....................      Searches for a string in the TCP RX buffer. 
....................  
....................   Description: 
....................    This function finds the first occurrance of an array of bytes in the 
....................    TCP RX buffer.  It can be used by an application to abstract searches  
....................    out of their own application code.  For increased efficiency, the  
....................    function is capable of limiting the scope of search to a specific 
....................    range of bytes.  It can also perform a case-insensitive search if 
....................    required. 
....................     
....................    For example, if the buffer contains "I love PIC MCUs!" and the search 
....................    array is "love" with a length of 4, a value of 2 will be returned. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to search within. 
....................    cFindArray - The array of bytes to find in the buffer. 
....................    wLen - Length of cFindArray. 
....................    wStart - Zero-indexed starting position within the buffer. 
....................    wSearchLen - Length from wStart to search in the buffer. 
....................    bTextCompare - TRUE for case-insensitive text search, FALSE for binary search 
....................  
....................   Return Values: 
....................    0xFFFF - Search array not found 
....................    Otherwise - Zero-indexed position of the first occurrance 
....................  
....................   Remarks: 
....................    Since this function usually must transfer data from external storage 
....................    to internal RAM for comparison, its performance degrades significantly 
....................    when the buffer is full and the array is not found.  For better  
....................    performance, try to search for characters that are expected to exist or 
....................    limit the scope of the search as much as possible.  The HTTP2 module,  
....................    for example, uses this function to parse headers.  However, it searches  
....................    for newlines, then the separating colon, then reads the header name to  
....................    RAM for final comparison.  This has proven to be significantly faster   
....................    than searching for full header name strings outright. 
....................   ***************************************************************************/ 
.................... WORD TCPFindArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
.................... { 
....................    PTR_BASE ptrRead; 
....................    WORD wDataLen; 
....................    WORD wBytesUntilWrap; 
....................    PTR_BASE ptrLocation; 
....................    WORD wLenStart; 
....................    BYTE *cFindArrayStart; 
....................    BYTE i, j, k; 
....................    BOOL isFinding; 
....................    BYTE buffer[32]; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT || wLen == 0) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    // Find out how many bytes are in the RX FIFO and return  
....................    // immediately if we won't possibly find a match 
....................    wDataLen = TCPIsGetReady(hTCP) - wStart; 
....................    if(wDataLen < wLen) 
....................       return 0xFFFFu; 
....................    if(wSearchLen && (wDataLen > wSearchLen)) 
....................       wDataLen = wSearchLen; 
....................  
....................    ptrLocation = MyTCBStub.rxTail + wStart; 
....................    if(ptrLocation > MyTCBStub.bufferEnd) 
....................       ptrLocation -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................    ptrRead = ptrLocation; 
....................    wBytesUntilWrap = MyTCBStub.bufferEnd - ptrLocation + 1; 
....................    ptrLocation = wStart; 
....................    wLenStart = wLen; 
....................    cFindArrayStart = cFindArray; 
....................    j = *cFindArray++; 
....................    isFinding = FALSE; 
....................    if(bTextCompare) 
....................    { 
....................       if(j >= 'a' && j <= 'z') 
....................          j += 'A'-'a'; 
....................    } 
....................  
....................    // Search for the array 
....................    while(1) 
....................    { 
....................       // Figure out how big of a chunk to read 
....................       k = sizeof(buffer); 
....................       if(k > wBytesUntilWrap) 
....................          k = wBytesUntilWrap; 
....................       if((WORD)k > wDataLen) 
....................          k = wDataLen; 
....................  
....................       // Read a chunk of data into the buffer 
....................       TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, (WORD)k); 
....................       ptrRead += k; 
....................       wBytesUntilWrap -= k; 
....................  
....................       if(wBytesUntilWrap == 0u) 
....................       { 
....................          ptrRead = MyTCBStub.bufferRxStart; 
....................          wBytesUntilWrap = 0xFFFFu; 
....................       } 
....................  
....................       // Convert everything to uppercase 
....................       if(bTextCompare) 
....................       { 
....................          for(i = 0; i < k; i++) 
....................          { 
....................             if(buffer[i] >= 'a' && buffer[i] <= 'z') 
....................                buffer[i] += 'A'-'a'; 
....................  
....................             if(j == buffer[i]) 
....................             { 
....................                if(--wLen == 0u) 
....................                   return ptrLocation-wLenStart + i + 1; 
....................                j = *cFindArray++; 
....................                isFinding = TRUE; 
....................                if(j >= 'a' && j <= 'z') 
....................                   j += 'A'-'a'; 
....................             } 
....................             else 
....................             { 
....................                wLen = wLenStart; 
....................                if(isFinding) 
....................                { 
....................                   cFindArray = cFindArrayStart; 
....................                   j = *cFindArray++; 
....................                   if(j >= 'a' && j <= 'z') 
....................                      j += 'A'-'a'; 
....................                   isFinding = FALSE; 
....................                } 
....................             } 
....................          } 
....................       } 
....................       else   // Compare as is 
....................       { 
....................          for(i = 0; i < k; i++) 
....................          { 
....................             if(j == buffer[i]) 
....................             { 
....................                if(--wLen == 0u) 
....................                   return ptrLocation-wLenStart + i + 1; 
....................                j = *cFindArray++; 
....................                isFinding = TRUE; 
....................             } 
....................             else 
....................             { 
....................                wLen = wLenStart; 
....................                if(isFinding) 
....................                { 
....................                   cFindArray = cFindArrayStart; 
....................                   j = *cFindArray++; 
....................                   isFinding = FALSE; 
....................                } 
....................             } 
....................          } 
....................       } 
....................  
....................       // Check to see if it is impossible to find a match 
....................       wDataLen -= k; 
....................       if(wDataLen < wLen) 
....................          return 0xFFFFu; 
....................  
....................       ptrLocation += k; 
....................    } 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPFindROMArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen,  
....................                   WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
....................  
....................   Summary: 
....................      Searches for a ROM string in the TCP RX buffer. 
....................  
....................   Description: 
....................    This function finds the first occurrance of an array of bytes in the 
....................    TCP RX buffer.  It can be used by an application to abstract searches  
....................    out of their own application code.  For increased efficiency, the  
....................    function is capable of limiting the scope of search to a specific 
....................    range of bytes.  It can also perform a case-insensitive search if 
....................    required. 
....................     
....................    For example, if the buffer contains "I love PIC MCUs!" and the search 
....................    array is "love" with a length of 4, a value of 2 will be returned. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to search within. 
....................    cFindArray - The array of bytes to find in the buffer. 
....................    wLen - Length of cFindArray. 
....................    wStart - Zero-indexed starting position within the buffer. 
....................    wSearchLen - Length from wStart to search in the buffer. 
....................    bTextCompare - TRUE for case-insensitive text search, FALSE for binary search 
....................  
....................   Return Values: 
....................    0xFFFF - Search array not found 
....................    Otherwise - Zero-indexed position of the first occurrance 
....................  
....................   Remarks: 
....................    Since this function usually must transfer data from external storage 
....................    to internal RAM for comparison, its performance degrades significantly 
....................    when the buffer is full and the array is not found.  For better  
....................    performance, try to search for characters that are expected to exist or 
....................    limit the scope of the search as much as possible.  The HTTP2 module,  
....................    for example, uses this function to parse headers.  However, it searches  
....................    for newlines, then the separating colon, then reads the header name to  
....................    RAM for final comparison.  This has proven to be significantly faster   
....................    than searching for full header name strings outright. 
....................     
....................    This function is aliased to TCPFindArrayEx on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... WORD TCPFindROMArrayEx(TCP_SOCKET hTCP, ROM BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
.................... { 
....................    PTR_BASE ptrRead; 
....................    WORD wDataLen; 
....................    WORD wBytesUntilWrap; 
....................    PTR_BASE ptrLocation; 
....................    WORD wLenStart; 
....................    ROM BYTE *cFindArrayStart; 
....................    BYTE i, j, k; 
....................    BOOL isFinding; 
....................    BYTE buffer[32]; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT || wLen == 0) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    // Find out how many bytes are in the RX FIFO and return  
....................    // immediately if we won't possibly find a match 
....................    wDataLen = TCPIsGetReady(hTCP) - wStart; 
....................    if(wDataLen < wLen) 
....................       return 0xFFFFu; 
....................    if(wSearchLen && (wDataLen > wSearchLen)) 
....................       wDataLen = wSearchLen; 
....................  
....................    ptrLocation = MyTCBStub.rxTail + wStart; 
....................    if(ptrLocation > MyTCBStub.bufferEnd) 
....................       ptrLocation -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................    ptrRead = ptrLocation; 
....................    wBytesUntilWrap = MyTCBStub.bufferEnd - ptrLocation + 1; 
....................    ptrLocation = wStart; 
....................    wLenStart = wLen; 
....................    cFindArrayStart = cFindArray; 
....................    j = *cFindArray++; 
....................    isFinding = FALSE; 
....................    if(bTextCompare) 
....................    { 
....................       if(j >= 'a' && j <= 'z') 
....................          j += 'A'-'a'; 
....................    } 
....................  
....................    // Search for the array 
....................    while(1) 
....................    { 
....................       // Figure out how big of a chunk to read 
....................       k = sizeof(buffer); 
....................       if(k > wBytesUntilWrap) 
....................          k = wBytesUntilWrap; 
....................       if((WORD)k > wDataLen) 
....................          k = wDataLen; 
....................  
....................       // Read a chunk of data into the buffer 
....................       TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, (WORD)k); 
....................       ptrRead += k; 
....................       wBytesUntilWrap -= k; 
....................  
....................       if(wBytesUntilWrap == 0u) 
....................       { 
....................          ptrRead = MyTCBStub.bufferRxStart; 
....................          wBytesUntilWrap = 0xFFFFu; 
....................       } 
....................  
....................       // Convert everything to uppercase 
....................       if(bTextCompare) 
....................       { 
....................          for(i = 0; i < k; i++) 
....................          { 
....................             if(buffer[i] >= 'a' && buffer[i] <= 'z') 
....................                buffer[i] += 'A'-'a'; 
....................  
....................             if(j == buffer[i]) 
....................             { 
....................                if(--wLen == 0u) 
....................                   return ptrLocation-wLenStart + i + 1; 
....................                j = *cFindArray++; 
....................                isFinding = TRUE; 
....................                if(j >= 'a' && j <= 'z') 
....................                   j += 'A'-'a'; 
....................             } 
....................             else 
....................             { 
....................                wLen = wLenStart; 
....................                if(isFinding) 
....................                { 
....................                   cFindArray = cFindArrayStart; 
....................                   j = *cFindArray++; 
....................                   if(j >= 'a' && j <= 'z') 
....................                      j += 'A'-'a'; 
....................                   isFinding = FALSE; 
....................                } 
....................             } 
....................          } 
....................       } 
....................       else   // Compare as is 
....................       { 
....................          for(i = 0; i < k; i++) 
....................          { 
....................             if(j == buffer[i]) 
....................             { 
....................                if(--wLen == 0u) 
....................                   return ptrLocation-wLenStart + i + 1; 
....................                j = *cFindArray++; 
....................                isFinding = TRUE; 
....................             } 
....................             else 
....................             { 
....................                wLen = wLenStart; 
....................                if(isFinding) 
....................                { 
....................                   cFindArray = cFindArrayStart; 
....................                   j = *cFindArray++; 
....................                   isFinding = FALSE; 
....................                } 
....................             } 
....................          } 
....................       } 
....................  
....................       // Check to see if it is impossible to find a match 
....................       wDataLen -= k; 
....................       if(wDataLen < wLen) 
....................          return 0xFFFFu; 
....................  
....................       ptrLocation += k; 
....................    } 
.................... } 
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPFindEx(TCP_SOCKET hTCP, BYTE cFind, 
....................                   WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
....................  
....................   Summary: 
....................      Searches for a byte in the TCP RX buffer. 
....................  
....................   Description: 
....................    This function finds the first occurrance of a byte in the TCP RX 
....................    buffer.  It can be used by an application to abstract searches  
....................    out of their own application code.  For increased efficiency, the  
....................    function is capable of limiting the scope of search to a specific 
....................    range of bytes.  It can also perform a case-insensitive search if 
....................    required. 
....................     
....................    For example, if the buffer contains "I love PIC MCUs!" and the cFind 
....................    byte is ' ', a value of 1 will be returned. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to search within. 
....................    cFind - The byte to find in the buffer. 
....................    wStart - Zero-indexed starting position within the buffer. 
....................    wSearchLen - Length from wStart to search in the buffer. 
....................    bTextCompare - TRUE for case-insensitive text search, FALSE for binary search 
....................  
....................   Return Values: 
....................    0xFFFF - Search array not found 
....................    Otherwise - Zero-indexed position of the first occurrance 
....................  
....................   Remarks: 
....................    Since this function usually must transfer data from external storage 
....................    to internal RAM for comparison, its performance degrades significantly 
....................    when the buffer is full and the array is not found.  For better  
....................    performance, try to search for characters that are expected to exist or 
....................    limit the scope of the search as much as possible.  The HTTP2 module,  
....................    for example, uses this function to parse headers.  However, it searches  
....................    for newlines, then the separating colon, then reads the header name to  
....................    RAM for final comparison.  This has proven to be significantly faster   
....................    than searching for full header name strings outright. 
....................   ***************************************************************************/ 
.................... WORD TCPFindEx(TCP_SOCKET hTCP, BYTE cFind, WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
.................... { 
....................    return TCPFindArrayEx(hTCP, &cFind, sizeof(cFind), wStart, wSearchLen, bTextCompare); 
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Data Processing Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPTick(void) 
....................  
....................   Summary: 
....................      Performs periodic TCP tasks. 
....................  
....................   Description: 
....................    This function performs any required periodic TCP tasks.  Each  
....................    socket's state machine is checked, and any elapsed timeout periods 
....................    are handled. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... void TCPTick(void) 
.................... { 
....................    TCP_SOCKET hTCP; 
....................    BOOL bRetransmit; 
....................    BOOL bCloseSocket; 
....................    BYTE vFlags; 
....................    WORD w; 
....................  
....................    // Periodically all "not closed" sockets must perform timed operations 
....................    for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++) 
*
03180:  MOVLB  1
03182:  CLRF   x74
03184:  MOVF   x74,F
03186:  BTFSS  FD8.2
03188:  BRA    386E
....................    { 
....................       SyncTCBStub(hTCP); 
0318A:  MOVFF  174,273
0318E:  MOVLB  0
03190:  CALL   0D1A
....................        
....................       // Handle any SSL Processing and Message Transmission 
....................       #if defined(STACK_USE_SSL) 
....................       if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       { 
....................          // Handle any periodic tasks, such as RSA operations 
....................          SSLPeriodic(hTCP, MyTCBStub.sslStubID); 
....................           
....................          // If unsent data is waiting, transmit it as an application record 
....................          if(MyTCBStub.sslTxHead != MyTCBStub.txHead && TCPSSLGetPendingTxSize(hTCP) != 0u) 
....................             SSLTxRecord(hTCP, MyTCBStub.sslStubID, SSL_APPLICATION); 
....................           
....................          // If an SSL message is requested, send it now 
....................          if(MyTCBStub.sslReqMessage != SSL_NO_MESSAGE) 
....................             SSLTxMessage(hTCP, MyTCBStub.sslStubID, MyTCBStub.sslReqMessage); 
....................       } 
....................       #endif 
....................        
....................       vFlags = 0x00; 
03194:  MOVLB  1
03196:  CLRF   x76
....................       bRetransmit = FALSE; 
03198:  BCF    x75.0
....................       bCloseSocket = FALSE; 
0319A:  BCF    x75.1
....................  
....................       // Transmit ASAP data if the medium is available 
....................       if(MyTCBStub.Flags.bTXASAP || MyTCBStub.Flags.bTXASAPWithoutTimerReset) 
0319C:  BTFSC  x30.1
0319E:  BRA    31A4
031A0:  BTFSS  x30.2
031A2:  BRA    31BA
....................       { 
....................          if(MACIsTxReady()) 
031A4:  MOVLB  0
031A6:  CALL   1A1C
031AA:  MOVF   01,F
031AC:  BZ    31BC
....................          { 
....................             vFlags = ACK; 
031AE:  MOVLW  10
031B0:  MOVLB  1
031B2:  MOVWF  x76
....................             bRetransmit = MyTCBStub.Flags.bTXASAPWithoutTimerReset; 
031B4:  BCF    x75.0
031B6:  BTFSC  x30.2
031B8:  BSF    x75.0
031BA:  MOVLB  0
....................          } 
....................       } 
....................  
....................       // Perform any needed window updates and data transmissions 
....................       if(MyTCBStub.Flags.bTimer2Enabled) 
031BC:  MOVLB  1
031BE:  BTFSS  x2F.5
031C0:  BRA    31EE
....................       { 
....................          // See if the timeout has occured, and we need to send a new window update and pending data 
....................          if((SHORT)(MyTCBStub.eventTime2 - (WORD)TickGetDiv256()) <= (SHORT)0) 
031C2:  MOVLB  0
031C4:  CALL   1A7C
031C8:  MOVF   00,W
031CA:  MOVLB  1
031CC:  SUBWF  x2A,W
031CE:  MOVWF  00
031D0:  MOVF   01,W
031D2:  SUBWFB x2B,W
031D4:  MOVWF  03
031D6:  MOVFF  00,179
031DA:  MOVWF  x7A
031DC:  BTFSC  FE8.7
031DE:  BRA    31EA
031E0:  MOVF   x7A,F
031E2:  BNZ   31EE
031E4:  MOVF   x79,W
031E6:  SUBLW  00
031E8:  BNC   31EE
....................             vFlags = ACK; 
031EA:  MOVLW  10
031EC:  MOVWF  x76
....................       } 
....................  
....................       // Process Delayed ACKnowledgement timer 
....................       if(MyTCBStub.Flags.bDelayedACKTimerEnabled) 
031EE:  BTFSS  x2F.6
031F0:  BRA    321E
....................       { 
....................          // See if the timeout has occured and delayed ACK needs to be sent 
....................          if((SHORT)(MyTCBStub.OverlappedTimers.delayedACKTime - (WORD)TickGetDiv256()) <= (SHORT)0) 
031F2:  MOVLB  0
031F4:  CALL   1A7C
031F8:  MOVF   00,W
031FA:  MOVLB  1
031FC:  SUBWF  x2C,W
031FE:  MOVWF  00
03200:  MOVF   01,W
03202:  SUBWFB x2D,W
03204:  MOVWF  03
03206:  MOVFF  00,179
0320A:  MOVWF  x7A
0320C:  BTFSC  FE8.7
0320E:  BRA    321A
03210:  MOVF   x7A,F
03212:  BNZ   321E
03214:  MOVF   x79,W
03216:  SUBLW  00
03218:  BNC   321E
....................             vFlags = ACK; 
0321A:  MOVLW  10
0321C:  MOVWF  x76
....................       } 
....................        
....................       // Process TCP_CLOSE_WAIT timer 
....................       if(MyTCBStub.smState == TCP_CLOSE_WAIT) 
0321E:  MOVF   x2E,W
03220:  SUBLW  0B
03222:  BNZ   3254
....................       { 
....................          // Automatically close the socket on our end if the application  
....................          // fails to call TCPDisconnect() is a reasonable amount of time. 
....................          if((SHORT)(MyTCBStub.OverlappedTimers.closeWaitTime - (WORD)TickGetDiv256()) <= (SHORT)0) 
03224:  MOVLB  0
03226:  CALL   1A7C
0322A:  MOVF   00,W
0322C:  MOVLB  1
0322E:  SUBWF  x2C,W
03230:  MOVWF  00
03232:  MOVF   01,W
03234:  SUBWFB x2D,W
03236:  MOVWF  03
03238:  MOVFF  00,179
0323C:  MOVWF  x7A
0323E:  BTFSC  FE8.7
03240:  BRA    324C
03242:  MOVF   x7A,F
03244:  BNZ   3254
03246:  MOVF   x79,W
03248:  SUBLW  00
0324A:  BNC   3254
....................          { 
....................             vFlags = FIN | ACK; 
0324C:  MOVLW  11
0324E:  MOVWF  x76
....................             MyTCBStub.smState = TCP_LAST_ACK; 
03250:  MOVLW  0C
03252:  MOVWF  x2E
....................          } 
....................       } 
....................  
....................       // Process listening server sockets that might have a SYN waiting in the SYNQueue[] 
....................       #if TCP_SYN_QUEUE_MAX_ENTRIES 
....................          if(MyTCBStub.smState == TCP_LISTEN) 
03254:  MOVF   x2E,W
03256:  SUBLW  04
03258:  BTFSS  FD8.2
0325A:  BRA    34FA
....................          { 
....................             for(w = 0; w < TCP_SYN_QUEUE_MAX_ENTRIES; w++) 
0325C:  CLRF   x78
0325E:  CLRF   x77
03260:  MOVF   x78,F
03262:  BTFSS  FD8.2
03264:  BRA    34FA
03266:  MOVF   x77,W
03268:  SUBLW  02
0326A:  BTFSS  FD8.0
0326C:  BRA    34FA
....................             { 
....................                // Abort search if there are no more valid records 
....................                if(SYNQueue[w].wDestPort == 0u) 
0326E:  MOVFF  178,1AA
03272:  MOVFF  177,1A9
03276:  CLRF   xAC
03278:  MOVLW  14
0327A:  MOVWF  xAB
0327C:  MOVLB  0
0327E:  CALL   1AA0
03282:  MOVFF  01,179
03286:  MOVLW  10
03288:  MOVLB  1
0328A:  ADDWF  01,W
0328C:  MOVWF  01
0328E:  MOVLW  00
03290:  ADDWFC 02,W
03292:  MOVWF  03
03294:  MOVF   01,W
03296:  ADDLW  DC
03298:  MOVWF  FE9
0329A:  MOVLW  00
0329C:  ADDWFC 03,W
0329E:  MOVWF  FEA
032A0:  MOVFF  FEC,17A
032A4:  MOVF   FED,F
032A6:  MOVFF  FEF,179
032AA:  MOVF   x79,F
032AC:  BNZ   32B4
032AE:  MOVF   x7A,F
032B0:  BNZ   32B4
....................                   break; 
032B2:  BRA    34FA
....................                 
....................                // Stop searching if this SYN queue entry can be used by this socket 
....................                #if defined(STACK_USE_SSL_SERVER) 
....................                if(SYNQueue[w].wDestPort == MyTCBStub.remoteHash.Val || SYNQueue[w].wDestPort == MyTCBStub.sslTxHead) 
....................                #else 
....................                if(SYNQueue[w].wDestPort == MyTCBStub.remoteHash.Val) 
032B4:  MOVFF  178,1AA
032B8:  MOVFF  177,1A9
032BC:  CLRF   xAC
032BE:  MOVLW  14
032C0:  MOVWF  xAB
032C2:  MOVLB  0
032C4:  CALL   1AA0
032C8:  MOVFF  01,179
032CC:  MOVLW  10
032CE:  MOVLB  1
032D0:  ADDWF  01,W
032D2:  MOVWF  01
032D4:  MOVLW  00
032D6:  ADDWFC 02,W
032D8:  MOVWF  03
032DA:  MOVF   01,W
032DC:  ADDLW  DC
032DE:  MOVWF  FE9
032E0:  MOVLW  00
032E2:  ADDWFC 03,W
032E4:  MOVWF  FEA
032E6:  MOVFF  FEC,17A
032EA:  MOVF   FED,F
032EC:  MOVFF  FEF,179
032F0:  MOVF   x31,W
032F2:  SUBWF  x79,W
032F4:  BTFSS  FD8.2
032F6:  BRA    34F2
032F8:  MOVF   x32,W
032FA:  SUBWF  x7A,W
032FC:  BTFSS  FD8.2
032FE:  BRA    34F2
....................                #endif 
....................                { 
....................                   // Set up our socket and generate a reponse SYN+ACK packet 
....................                   SyncTCB(); 
03300:  MOVLB  0
03302:  CALL   130A
....................                    
....................                   #if defined(STACK_USE_SSL_SERVER) 
....................                   // If this matches the SSL port, make sure that can be configured 
....................                   // before continuing.  If not, break and leave this in the queue 
....................                   if(SYNQueue[w].wDestPort == MyTCBStub.sslTxHead && !TCPStartSSLServer(hTCP)) 
....................                      break; 
....................                   #endif 
....................                    
....................                   memcpy((void*)&MyTCB.remote.niRemoteMACIP, (void*)&SYNQueue[w].niSourceAddress, sizeof(NODE_INFO)); 
03306:  MOVLB  1
03308:  CLRF   x7A
0330A:  MOVLW  CA
0330C:  MOVWF  x79
0330E:  MOVFF  178,1AA
03312:  MOVFF  177,1A9
03316:  CLRF   xAC
03318:  MOVLW  14
0331A:  MOVWF  xAB
0331C:  MOVLB  0
0331E:  CALL   1AA0
03322:  MOVFF  02,17C
03326:  MOVFF  01,17B
0332A:  MOVLW  DC
0332C:  MOVLB  1
0332E:  ADDWF  01,W
03330:  MOVWF  01
03332:  MOVLW  00
03334:  ADDWFC 02,W
03336:  MOVWF  03
03338:  MOVFF  01,17D
0333C:  MOVWF  x7E
0333E:  MOVFF  17A,FEA
03342:  MOVFF  179,FE9
03346:  MOVWF  FE2
03348:  MOVFF  01,FE1
0334C:  MOVLW  0A
0334E:  MOVWF  01
03350:  MOVFF  FE6,FEE
03354:  DECFSZ 01,F
03356:  BRA    3350
....................                   MyTCB.remotePort.Val = SYNQueue[w].wSourcePort; 
03358:  MOVFF  178,1AA
0335C:  MOVFF  177,1A9
03360:  CLRF   xAC
03362:  MOVLW  14
03364:  MOVWF  xAB
03366:  MOVLB  0
03368:  CALL   1AA0
0336C:  MOVFF  01,179
03370:  MOVLW  0A
03372:  MOVLB  1
03374:  ADDWF  01,W
03376:  MOVWF  01
03378:  MOVLW  00
0337A:  ADDWFC 02,W
0337C:  MOVWF  03
0337E:  MOVF   01,W
03380:  ADDLW  DC
03382:  MOVWF  FE9
03384:  MOVLW  00
03386:  ADDWFC 03,W
03388:  MOVWF  FEA
0338A:  MOVFF  FEC,C3
0338E:  MOVF   FED,F
03390:  MOVFF  FEF,C2
....................                   MyTCB.RemoteSEQ = SYNQueue[w].dwSourceSEQ + 1; 
03394:  MOVFF  178,1AA
03398:  MOVFF  177,1A9
0339C:  CLRF   xAC
0339E:  MOVLW  14
033A0:  MOVWF  xAB
033A2:  MOVLB  0
033A4:  CALL   1AA0
033A8:  MOVFF  01,179
033AC:  MOVLW  0C
033AE:  MOVLB  1
033B0:  ADDWF  01,W
033B2:  MOVWF  01
033B4:  MOVLW  00
033B6:  ADDWFC 02,W
033B8:  MOVWF  03
033BA:  MOVF   01,W
033BC:  ADDLW  DC
033BE:  MOVWF  FE9
033C0:  MOVLW  00
033C2:  ADDWFC 03,W
033C4:  MOVWF  FEA
033C6:  MOVFF  FEF,179
033CA:  MOVFF  FEC,17A
033CE:  MOVFF  FEC,17B
033D2:  MOVFF  FEC,17C
033D6:  MOVLW  01
033D8:  ADDWF  x79,W
033DA:  MOVLB  0
033DC:  MOVWF  xBC
033DE:  MOVLW  00
033E0:  MOVLB  1
033E2:  ADDWFC x7A,W
033E4:  MOVLB  0
033E6:  MOVWF  xBD
033E8:  MOVLW  00
033EA:  MOVLB  1
033EC:  ADDWFC x7B,W
033EE:  MOVLB  0
033F0:  MOVWF  xBE
033F2:  MOVLW  00
033F4:  MOVLB  1
033F6:  ADDWFC x7C,W
033F8:  MOVLB  0
033FA:  MOVWF  xBF
....................                   MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1] + MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val; 
033FC:  MOVF   xCA,W
033FE:  ADDWF  xCC,W
03400:  MOVLB  1
03402:  MOVWF  x79
03404:  MOVLB  0
03406:  MOVF   xCB,W
03408:  ADDWFC xCD,W
0340A:  MOVLB  1
0340C:  MOVWF  x7A
0340E:  MOVLB  0
03410:  MOVF   xC2,W
03412:  MOVLB  1
03414:  ADDWF  x79,F
03416:  MOVLB  0
03418:  MOVF   xC3,W
0341A:  MOVLB  1
0341C:  ADDWFC x7A,F
0341E:  MOVF   x79,W
03420:  MOVLB  0
03422:  XORWF  xC4,W
03424:  MOVLB  1
03426:  MOVWF  x31
03428:  MOVF   x7A,W
0342A:  MOVLB  0
0342C:  XORWF  xC5,W
0342E:  MOVLB  1
03430:  MOVWF  x32
....................                   vFlags = SYN | ACK; 
03432:  MOVLW  12
03434:  MOVWF  x76
....................                   MyTCBStub.smState = TCP_SYN_RECEIVED; 
03436:  MOVLW  06
03438:  MOVWF  x2E
....................                    
....................                   // Delete this SYN from the SYNQueue and compact the SYNQueue[] array 
....................                   TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE)); 
0343A:  MOVFF  178,1AA
0343E:  MOVFF  177,1A9
03442:  CLRF   xAC
03444:  MOVLW  14
03446:  MOVWF  xAB
03448:  MOVLB  0
0344A:  CALL   1AA0
0344E:  MOVFF  02,03
03452:  MOVF   01,W
03454:  ADDLW  DC
03456:  MOVWF  01
03458:  MOVLW  00
0345A:  ADDWFC 03,F
0345C:  MOVFF  01,179
03460:  MOVLB  1
03462:  MOVFF  03,17A
03466:  MOVLW  01
03468:  ADDWF  x77,W
0346A:  MOVWF  x7B
0346C:  MOVLW  00
0346E:  ADDWFC x78,W
03470:  MOVWF  x7C
03472:  MOVWF  xAA
03474:  MOVFF  17B,1A9
03478:  CLRF   xAC
0347A:  MOVLW  14
0347C:  MOVWF  xAB
0347E:  MOVLB  0
03480:  CALL   1AA0
03484:  MOVFF  02,03
03488:  MOVF   01,W
0348A:  ADDLW  DC
0348C:  MOVWF  01
0348E:  MOVLW  00
03490:  ADDWFC 03,F
03492:  MOVFF  01,17B
03496:  MOVLB  1
03498:  MOVFF  03,17C
0349C:  MOVLW  02
0349E:  BSF    FD8.0
034A0:  SUBFWB x77,W
034A2:  MOVWF  x7D
034A4:  MOVLW  00
034A6:  SUBFWB x78,W
034A8:  MOVWF  x7E
034AA:  MOVWF  xAA
034AC:  MOVFF  17D,1A9
034B0:  CLRF   xAC
034B2:  MOVLW  14
034B4:  MOVWF  xAB
034B6:  MOVLB  0
034B8:  CALL   1AA0
034BC:  MOVFF  02,17E
034C0:  MOVFF  01,17D
034C4:  MOVFF  17A,2A4
034C8:  MOVFF  179,2A3
034CC:  MOVLW  01
034CE:  MOVLB  2
034D0:  MOVWF  xA5
034D2:  MOVFF  17C,2A7
034D6:  MOVFF  17B,2A6
034DA:  MOVWF  xA8
034DC:  MOVFF  02,2AA
034E0:  MOVFF  01,2A9
034E4:  MOVLB  0
034E6:  CALL   1224
....................                   SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort = 0u; 
034EA:  MOVLB  1
034EC:  CLRF   x15
034EE:  CLRF   x14
....................     
....................                   break; 
034F0:  BRA    34FA
....................                } 
034F2:  INCF   x77,F
034F4:  BTFSC  FD8.2
034F6:  INCF   x78,F
034F8:  BRA    3260
....................             } 
....................          } 
....................       #endif 
....................  
....................       if(vFlags) 
034FA:  MOVF   x76,F
034FC:  BZ    351A
....................          SendTCP(vFlags, bRetransmit ? 0 : SENDTCP_RESET_TIMERS); 
034FE:  BTFSS  x75.0
03500:  BRA    3506
03502:  MOVLW  00
03504:  BRA    3508
03506:  MOVLW  01
03508:  MOVWF  x79
0350A:  MOVFF  176,272
0350E:  MOVFF  FE8,273
03512:  MOVLB  0
03514:  CALL   26A2
03518:  MOVLB  1
....................  
....................       // The TCP_CLOSED, TCP_LISTEN, and sometimes the TCP_ESTABLISHED  
....................       // state don't need any timeout events, so see if the timer is enabled 
....................       if(!MyTCBStub.Flags.bTimerEnabled) 
0351A:  BTFSC  x2F.4
0351C:  BRA    35CA
....................       { 
....................          #if defined(TCP_KEEP_ALIVE_TIMEOUT) 
....................             // Only the established state has any use for keep-alives 
....................             if(MyTCBStub.smState == TCP_ESTABLISHED) 
0351E:  MOVF   x2E,W
03520:  SUBLW  07
03522:  BNZ   35C8
....................             { 
....................                // If timeout has not occured, do not do anything. 
....................                if((LONG)(TickGet() - MyTCBStub.eventTime) < (LONG)0) 
03524:  MOVLB  0
03526:  CALL   1AC2
0352A:  MOVFF  03,17C
0352E:  MOVFF  02,17B
03532:  MOVFF  01,17A
03536:  MOVFF  00,179
0353A:  MOVLB  1
0353C:  MOVF   x26,W
0353E:  SUBWF  00,W
03540:  MOVWF  00
03542:  MOVF   x27,W
03544:  SUBWFB 01,W
03546:  MOVWF  01
03548:  MOVF   x28,W
0354A:  SUBWFB 02,W
0354C:  MOVWF  02
0354E:  MOVF   x29,W
03550:  SUBWFB 03,W
03552:  MOVWF  03
03554:  MOVWF  x7C
03556:  MOVFF  02,17B
0355A:  MOVFF  01,17A
0355E:  MOVFF  00,179
03562:  BTFSS  FE8.7
03564:  BRA    3568
....................                   continue; 
03566:  BRA    386A
....................        
....................                // If timeout has occured and the connection appears to be dead (no  
....................                // responses from remote node at all), close the connection so the  
....................                // application doesn't sit around indefinitely with a useless socket  
....................                // that it thinks is still open 
....................                if(MyTCBStub.Flags.vUnackedKeepalives == TCP_MAX_UNACKED_KEEP_ALIVES) 
03568:  MOVF   x2F,W
0356A:  ANDLW  07
0356C:  SUBLW  06
0356E:  BNZ   3594
....................                { 
....................                   vFlags = MyTCBStub.Flags.bServer; 
03570:  CLRF   x76
03572:  BTFSC  x2F.3
03574:  INCF   x76,F
....................  
....................                   // Force an immediate FIN and RST transmission 
....................                   // Double calling TCPDisconnect() will also place us  
....................                   // back in the listening state immediately if a server socket. 
....................                   TCPDisconnect(hTCP); 
03576:  MOVFF  174,268
0357A:  MOVLB  0
0357C:  CALL   2CFE
....................                   TCPDisconnect(hTCP); 
03580:  MOVFF  174,268
03584:  CALL   2CFE
....................                    
....................                   // Prevent client mode sockets from getting reused by other applications.   
....................                   // The application must call TCPDisconnect() with the handle to free this  
....................                   // socket (and the handle associated with it) 
....................                   if(!vFlags) 
03588:  MOVLB  1
0358A:  MOVF   x76,F
0358C:  BNZ   3592
....................                      MyTCBStub.smState = TCP_CLOSED_BUT_RESERVED; 
0358E:  MOVLW  0E
03590:  MOVWF  x2E
....................                    
....................                   continue; 
03592:  BRA    386A
....................                } 
....................                 
....................                // Otherwise, if a timeout occured, simply send a keep-alive packet 
....................                SyncTCB(); 
03594:  MOVLB  0
03596:  CALL   130A
....................                SendTCP(ACK, SENDTCP_KEEP_ALIVE); 
0359A:  MOVLW  10
0359C:  MOVLB  2
0359E:  MOVWF  x72
035A0:  MOVLW  02
035A2:  MOVWF  x73
035A4:  MOVLB  0
035A6:  CALL   26A2
....................                MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
035AA:  CALL   1AC2
035AE:  MOVLW  E6
035B0:  MOVLB  1
035B2:  ADDWF  00,W
035B4:  MOVWF  x26
035B6:  MOVLW  F5
035B8:  ADDWFC 01,W
035BA:  MOVWF  x27
035BC:  MOVLW  05
035BE:  ADDWFC 02,W
035C0:  MOVWF  x28
035C2:  MOVLW  00
035C4:  ADDWFC 03,W
035C6:  MOVWF  x29
....................             } 
....................          #endif 
....................          continue; 
035C8:  BRA    386A
....................       } 
....................  
....................       // If timeout has not occured, do not do anything. 
....................       if((LONG)(TickGet() - MyTCBStub.eventTime) < (LONG)0) 
035CA:  MOVLB  0
035CC:  CALL   1AC2
035D0:  MOVFF  03,17C
035D4:  MOVFF  02,17B
035D8:  MOVFF  01,17A
035DC:  MOVFF  00,179
035E0:  MOVLB  1
035E2:  MOVF   x26,W
035E4:  SUBWF  00,W
035E6:  MOVWF  00
035E8:  MOVF   x27,W
035EA:  SUBWFB 01,W
035EC:  MOVWF  01
035EE:  MOVF   x28,W
035F0:  SUBWFB 02,W
035F2:  MOVWF  02
035F4:  MOVF   x29,W
035F6:  SUBWFB 03,W
035F8:  MOVWF  03
035FA:  MOVWF  x7C
035FC:  MOVFF  02,17B
03600:  MOVFF  01,17A
03604:  MOVFF  00,179
03608:  BTFSS  FE8.7
0360A:  BRA    360E
....................          continue; 
0360C:  BRA    386A
....................  
....................       // Load up extended TCB information 
....................       SyncTCB(); 
0360E:  MOVLB  0
03610:  CALL   130A
....................  
....................       // A timeout has occured.  Respond to this timeout condition 
....................       // depending on what state this socket is in. 
....................       switch(MyTCBStub.smState) 
03614:  MOVLB  1
03616:  MOVF   x2E,W
03618:  XORLW  02
0361A:  MOVLB  0
0361C:  BZ    3652
0361E:  XORLW  01
03620:  BZ    3672
03622:  XORLW  06
03624:  BZ    36E6
03626:  XORLW  03
03628:  BTFSC  FD8.2
0362A:  BRA    370C
0362C:  XORLW  01
0362E:  BTFSC  FD8.2
03630:  BRA    3732
03632:  XORLW  0C
03634:  BTFSC  FD8.2
03636:  BRA    3732
03638:  XORLW  03
0363A:  BTFSC  FD8.2
0363C:  BRA    3750
0363E:  XORLW  01
03640:  BTFSC  FD8.2
03642:  BRA    376C
03644:  XORLW  03
03646:  BTFSC  FD8.2
03648:  BRA    3776
0364A:  XORLW  06
0364C:  BTFSC  FD8.2
0364E:  BRA    3792
03650:  BRA    37B0
....................       { 
....................          #if defined(STACK_CLIENT_MODE) 
....................          #if defined(STACK_USE_DNS) 
....................          case TCP_GET_DNS_MODULE: 
....................             if(DNSBeginUsage()) 
....................             { 
....................                MyTCBStub.smState = TCP_DNS_RESOLVE; 
....................                if(MyTCB.flags.bRemoteHostIsROM) 
....................                   DNSResolveROM((ROM BYTE*)(ROM_PTR_BASE)MyTCB.remote.dwRemoteHost, DNS_TYPE_A); 
....................                else 
....................                   DNSResolve((BYTE*)(PTR_BASE)MyTCB.remote.dwRemoteHost, DNS_TYPE_A); 
....................             } 
....................             break; 
....................              
....................          case TCP_DNS_RESOLVE: 
....................          { 
....................             IP_ADDR ipResolvedDNSIP; 
....................  
....................             // See if DNS resolution has finished.  Note that if the DNS  
....................             // fails, the &ipResolvedDNSIP will be written with 0x00000000.  
....................             // MyTCB.remote.dwRemoteHost is unioned with  
....................             // MyTCB.remote.niRemoteMACIP.IPAddr, so we can't directly write  
....................             // the DNS result into MyTCB.remote.niRemoteMACIP.IPAddr.  We  
....................             // must copy it over only if the DNS is resolution step was  
....................             // successful. 
....................             if(DNSIsResolved(&ipResolvedDNSIP)) 
....................             { 
....................                if(DNSEndUsage()) 
....................                { 
....................                   MyTCB.remote.niRemoteMACIP.IPAddr.Val = ipResolvedDNSIP.Val; 
....................                   MyTCBStub.smState = TCP_GATEWAY_SEND_ARP; 
....................                   MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1]+MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val; 
....................                   MyTCB.retryCount = 0; 
....................                   MyTCB.retryInterval = (TICK_SECOND/4)/256; 
....................                } 
....................                else 
....................                { 
....................                   MyTCBStub.eventTime = TickGet() + 10*TICK_SECOND; 
....................                   MyTCBStub.smState = TCP_GET_DNS_MODULE; 
....................                } 
....................             } 
....................             break; 
....................          } 
....................          #endif // #if defined(STACK_USE_DNS) 
....................              
....................          case TCP_GATEWAY_SEND_ARP: 
....................             // Obtain the MAC address associated with the server's IP address (either direct MAC address on same subnet, or the MAC address of the Gateway machine) 
....................             MyTCBStub.eventTime2 = (WORD)TickGetDiv256(); 
03652:  CALL   1A7C
03656:  MOVFF  01,12B
0365A:  MOVFF  00,12A
....................             ARPResolve(&MyTCB.remote.niRemoteMACIP.IPAddr); 
0365E:  MOVLB  1
03660:  CLRF   x7A
03662:  MOVLW  CA
03664:  MOVWF  x79
03666:  MOVLB  0
03668:  BRA    2FD6
....................             MyTCBStub.smState = TCP_GATEWAY_GET_ARP; 
0366A:  MOVLW  03
0366C:  MOVLB  1
0366E:  MOVWF  x2E
....................             break; 
03670:  BRA    37B2
....................  
....................          case TCP_GATEWAY_GET_ARP: 
....................             // Wait for the MAC address to finish being obtained 
....................             if(!ARPIsResolved(&MyTCB.remote.niRemoteMACIP.IPAddr, &MyTCB.remote.niRemoteMACIP.MACAddr)) 
03672:  MOVLB  1
03674:  CLRF   x7A
03676:  MOVLW  CA
03678:  MOVWF  x79
0367A:  CLRF   x7C
0367C:  MOVLW  CE
0367E:  MOVWF  x7B
03680:  MOVLB  0
03682:  BRA    308C
03684:  MOVF   01,F
03686:  BNZ   36D8
....................             { 
....................                // Time out if too much time is spent in this state 
....................                // Note that this will continuously send out ARP  
....................                // requests for an infinite time if the Gateway  
....................                // never responds 
....................                if((WORD)TickGetDiv256() - MyTCBStub.eventTime2 > (WORD)MyTCB.retryInterval) 
03688:  CALL   1A7C
0368C:  MOVFF  01,17A
03690:  MOVFF  00,179
03694:  MOVLB  1
03696:  MOVF   x2A,W
03698:  SUBWF  x79,F
0369A:  MOVF   x2B,W
0369C:  SUBWFB x7A,F
0369E:  MOVLB  0
036A0:  MOVF   xB5,W
036A2:  MOVLB  1
036A4:  SUBWF  x7A,W
036A6:  BNC   36D4
036A8:  BNZ   36BA
036AA:  MOVF   x79,W
036AC:  MOVLB  0
036AE:  SUBWF  xB4,W
036B0:  BTFSS  FD8.0
036B2:  BRA    36B8
036B4:  MOVLB  1
036B6:  BRA    36D4
036B8:  MOVLB  1
....................                { 
....................                   // Exponentially increase timeout until we reach 6 attempts then stay constant 
....................                   if(MyTCB.retryCount < 6u) 
036BA:  MOVLB  0
036BC:  MOVF   xD9,W
036BE:  SUBLW  05
036C0:  BNC   36CE
....................                   { 
....................                      MyTCB.retryCount++; 
036C2:  INCF   xD9,F
....................                      MyTCB.retryInterval <<= 1; 
036C4:  BCF    FD8.0
036C6:  RLCF   xB4,F
036C8:  RLCF   xB5,F
036CA:  RLCF   xB6,F
036CC:  RLCF   xB7,F
....................                   } 
....................  
....................                   // Retransmit ARP request 
....................                   MyTCBStub.smState = TCP_GATEWAY_SEND_ARP; 
036CE:  MOVLW  02
036D0:  MOVLB  1
036D2:  MOVWF  x2E
....................                } 
....................                break; 
036D4:  BRA    37B2
036D6:  MOVLB  0
....................             } 
....................              
....................             // Send out SYN connection request to remote node 
....................             // This automatically disables the Timer from  
....................             // continuously firing for this socket 
....................             vFlags = SYN; 
036D8:  MOVLW  02
036DA:  MOVLB  1
036DC:  MOVWF  x76
....................             bRetransmit = FALSE; 
036DE:  BCF    x75.0
....................             MyTCBStub.smState = TCP_SYN_SENT; 
036E0:  MOVLW  05
036E2:  MOVWF  x2E
....................             break; 
036E4:  BRA    37B2
....................          #endif // #if defined(STACK_CLIENT_MODE) 
....................           
....................          case TCP_SYN_SENT: 
....................             // Keep sending SYN until we hear from remote node. 
....................             // This may be for infinite time, in that case 
....................             // caller must detect it and do something. 
....................             vFlags = SYN; 
036E6:  MOVLW  02
036E8:  MOVLB  1
036EA:  MOVWF  x76
....................             bRetransmit = TRUE; 
036EC:  BSF    x75.0
....................  
....................             // Exponentially increase timeout until we reach TCP_MAX_RETRIES attempts then stay constant 
....................             if(MyTCB.retryCount >= (TCP_MAX_RETRIES - 1)) 
036EE:  MOVLB  0
036F0:  MOVF   xD9,W
036F2:  SUBLW  03
036F4:  BC    3708
....................             { 
....................                MyTCB.retryCount = TCP_MAX_RETRIES - 1; 
036F6:  MOVLW  04
036F8:  MOVWF  xD9
....................                MyTCB.retryInterval = TCP_START_TIMEOUT_VAL<<(TCP_MAX_RETRIES-1); 
036FA:  CLRF   xB7
036FC:  MOVLW  09
036FE:  MOVWF  xB6
03700:  MOVLW  89
03702:  MOVWF  xB5
03704:  MOVLW  70
03706:  MOVWF  xB4
....................             } 
....................             break; 
03708:  MOVLB  1
0370A:  BRA    37B2
....................     
....................          case TCP_SYN_RECEIVED: 
....................             // We must receive ACK before timeout expires. 
....................             // If not, resend SYN+ACK. 
....................             // Abort, if maximum attempts counts are reached. 
....................             if(MyTCB.retryCount < TCP_MAX_SYN_RETRIES) 
0370C:  MOVF   xD9,W
0370E:  SUBLW  01
03710:  BNC   371E
....................             { 
....................                vFlags = SYN | ACK; 
03712:  MOVLW  12
03714:  MOVLB  1
03716:  MOVWF  x76
....................                bRetransmit = TRUE; 
03718:  BSF    x75.0
....................             } 
0371A:  BRA    3730
0371C:  MOVLB  0
....................             else 
....................             { 
....................                if(MyTCBStub.Flags.bServer) 
0371E:  MOVLB  1
03720:  BTFSS  x2F.3
03722:  BRA    372C
....................                { 
....................                   vFlags = RST | ACK; 
03724:  MOVLW  14
03726:  MOVWF  x76
....................                   bCloseSocket = TRUE; 
03728:  BSF    x75.1
....................                } 
0372A:  BRA    3730
....................                else 
....................                { 
....................                   vFlags = SYN; 
0372C:  MOVLW  02
0372E:  MOVWF  x76
....................                } 
....................             } 
....................             break; 
03730:  BRA    37B2
....................     
....................          case TCP_ESTABLISHED: 
....................          case TCP_CLOSE_WAIT: 
....................             // Retransmit any unacknowledged data 
....................             if(MyTCB.retryCount < TCP_MAX_RETRIES) 
03732:  MOVF   xD9,W
03734:  SUBLW  04
03736:  BNC   3744
....................             { 
....................                vFlags = ACK; 
03738:  MOVLW  10
0373A:  MOVLB  1
0373C:  MOVWF  x76
....................                bRetransmit = TRUE; 
0373E:  BSF    x75.0
....................             } 
03740:  BRA    374E
03742:  MOVLB  0
....................             else 
....................             { 
....................                // No response back for too long, close connection 
....................                // This could happen, for instance, if the communication  
....................                // medium was lost 
....................                MyTCBStub.smState = TCP_FIN_WAIT_1; 
03744:  MOVLW  08
03746:  MOVLB  1
03748:  MOVWF  x2E
....................                vFlags = FIN | ACK; 
0374A:  MOVLW  11
0374C:  MOVWF  x76
....................             } 
....................             break; 
0374E:  BRA    37B2
....................     
....................          case TCP_FIN_WAIT_1: 
....................             if(MyTCB.retryCount < TCP_MAX_RETRIES) 
03750:  MOVF   xD9,W
03752:  SUBLW  04
03754:  BNC   3762
....................             { 
....................                // Send another FIN 
....................                vFlags = FIN | ACK; 
03756:  MOVLW  11
03758:  MOVLB  1
0375A:  MOVWF  x76
....................                bRetransmit = TRUE; 
0375C:  BSF    x75.0
....................             } 
0375E:  BRA    376A
03760:  MOVLB  0
....................             else 
....................             { 
....................                // Close on our own, we can't seem to communicate  
....................                // with the remote node anymore 
....................                vFlags = RST | ACK; 
03762:  MOVLW  14
03764:  MOVLB  1
03766:  MOVWF  x76
....................                bCloseSocket = TRUE; 
03768:  BSF    x75.1
....................             } 
....................             break; 
0376A:  BRA    37B2
....................     
....................          case TCP_FIN_WAIT_2: 
....................             // Close on our own, we can't seem to communicate  
....................             // with the remote node anymore 
....................             vFlags = RST | ACK; 
0376C:  MOVLW  14
0376E:  MOVLB  1
03770:  MOVWF  x76
....................             bCloseSocket = TRUE; 
03772:  BSF    x75.1
....................             break; 
03774:  BRA    37B2
....................  
....................          case TCP_CLOSING: 
....................             if(MyTCB.retryCount < TCP_MAX_RETRIES) 
03776:  MOVF   xD9,W
03778:  SUBLW  04
0377A:  BNC   3788
....................             { 
....................                // Send another ACK+FIN (the FIN is retransmitted  
....................                // automatically since it hasn't been acknowledged by  
....................                // the remote node yet) 
....................                vFlags = ACK; 
0377C:  MOVLW  10
0377E:  MOVLB  1
03780:  MOVWF  x76
....................                bRetransmit = TRUE; 
03782:  BSF    x75.0
....................             } 
03784:  BRA    3790
03786:  MOVLB  0
....................             else 
....................             { 
....................                // Close on our own, we can't seem to communicate  
....................                // with the remote node anymore 
....................                vFlags = RST | ACK; 
03788:  MOVLW  14
0378A:  MOVLB  1
0378C:  MOVWF  x76
....................                bCloseSocket = TRUE; 
0378E:  BSF    x75.1
....................             } 
....................             break; 
03790:  BRA    37B2
....................     
.................... //         case TCP_TIME_WAIT: 
.................... //            // Wait around for a while (2MSL) and then goto closed state 
.................... //            bCloseSocket = TRUE; 
.................... //            break; 
.................... //          
....................  
....................          case TCP_LAST_ACK: 
....................             // Send some more FINs or close anyway 
....................             if(MyTCB.retryCount < TCP_MAX_RETRIES) 
03792:  MOVF   xD9,W
03794:  SUBLW  04
03796:  BNC   37A4
....................             { 
....................                vFlags = FIN | ACK; 
03798:  MOVLW  11
0379A:  MOVLB  1
0379C:  MOVWF  x76
....................                bRetransmit = TRUE; 
0379E:  BSF    x75.0
....................             } 
037A0:  BRA    37AC
037A2:  MOVLB  0
....................             else 
....................             { 
....................                vFlags = RST | ACK; 
037A4:  MOVLW  14
037A6:  MOVLB  1
037A8:  MOVWF  x76
....................                bCloseSocket = TRUE; 
037AA:  BSF    x75.1
....................             } 
....................             break; 
037AC:  BRA    37B2
037AE:  MOVLB  0
....................           
....................          default: 
....................             break; 
037B0:  MOVLB  1
....................       } 
....................  
....................       if(vFlags) 
037B2:  MOVF   x76,F
037B4:  BZ    385E
....................       { 
....................          // Transmit all unacknowledged data over again 
....................          if(bRetransmit) 
037B6:  BTFSS  x75.0
037B8:  BRA    384C
....................          { 
....................             // Set the appropriate retry time 
....................             MyTCB.retryCount++; 
037BA:  MOVLB  0
037BC:  INCF   xD9,F
....................             MyTCB.retryInterval <<= 1; 
037BE:  BCF    FD8.0
037C0:  RLCF   xB4,F
037C2:  RLCF   xB5,F
037C4:  RLCF   xB6,F
037C6:  RLCF   xB7,F
....................        
....................             // Calculate how many bytes we have to roll back and retransmit 
....................             w = MyTCB.txUnackedTail - MyTCBStub.txTail; 
037C8:  MOVLB  1
037CA:  MOVF   x20,W
037CC:  MOVLB  0
037CE:  SUBWF  xC0,W
037D0:  MOVLB  1
037D2:  MOVWF  x77
037D4:  MOVF   x21,W
037D6:  MOVLB  0
037D8:  SUBWFB xC1,W
037DA:  MOVLB  1
037DC:  MOVWF  x78
....................             if(MyTCB.txUnackedTail < MyTCBStub.txTail) 
037DE:  MOVLB  0
037E0:  MOVF   xC1,W
037E2:  MOVLB  1
037E4:  SUBWF  x21,W
037E6:  BNC   380E
037E8:  BNZ   37FA
037EA:  MOVF   x20,W
037EC:  MOVLB  0
037EE:  SUBWF  xC0,W
037F0:  BTFSS  FD8.0
037F2:  BRA    37F8
037F4:  MOVLB  1
037F6:  BRA    380E
037F8:  MOVLB  1
....................                w += MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
037FA:  MOVF   x18,W
037FC:  SUBWF  x1A,W
037FE:  MOVWF  00
03800:  MOVF   x19,W
03802:  SUBWFB x1B,W
03804:  MOVWF  03
03806:  MOVF   00,W
03808:  ADDWF  x77,F
0380A:  MOVF   03,W
0380C:  ADDWFC x78,F
....................              
....................             // Perform roll back of local SEQuence counter, remote window  
....................             // adjustment, and cause all unacknowledged data to be  
....................             // retransmitted by moving the unacked tail pointer. 
....................             MyTCB.MySEQ -= w; 
0380E:  MOVF   x77,W
03810:  MOVLB  0
03812:  SUBWF  xB8,F
03814:  MOVLB  1
03816:  MOVF   x78,W
03818:  MOVLB  0
0381A:  SUBWFB xB9,F
0381C:  MOVLW  00
0381E:  SUBWFB xBA,F
03820:  SUBWFB xBB,F
....................             MyTCB.remoteWindow += w; 
03822:  MOVLB  1
03824:  MOVF   x77,W
03826:  MOVLB  0
03828:  ADDWF  xC6,F
0382A:  MOVLB  1
0382C:  MOVF   x78,W
0382E:  MOVLB  0
03830:  ADDWFC xC7,F
....................             MyTCB.txUnackedTail = MyTCBStub.txTail;       
03832:  MOVFF  121,C1
03836:  MOVFF  120,C0
....................             SendTCP(vFlags, 0); 
0383A:  MOVFF  176,272
0383E:  MOVLB  2
03840:  CLRF   x73
03842:  MOVLB  0
03844:  CALL   26A2
....................          } 
03848:  BRA    385C
0384A:  MOVLB  1
....................          else 
....................             SendTCP(vFlags, SENDTCP_RESET_TIMERS); 
0384C:  MOVFF  176,272
03850:  MOVLW  01
03852:  MOVLB  2
03854:  MOVWF  x73
03856:  MOVLB  0
03858:  CALL   26A2
0385C:  MOVLB  1
....................  
....................       } 
....................        
....................       if(bCloseSocket) 
0385E:  BTFSS  x75.1
03860:  BRA    386A
....................          CloseSocket(); 
03862:  MOVLB  0
03864:  CALL   13DE
03868:  MOVLB  1
....................    } 
....................     
....................     
....................    #if TCP_SYN_QUEUE_MAX_ENTRIES 
0386A:  INCF   x74,F
0386C:  BRA    3184
....................       // Process SYN Queue entry timeouts 
....................       for(w = 0; w < TCP_SYN_QUEUE_MAX_ENTRIES; w++) 
0386E:  CLRF   x78
03870:  CLRF   x77
03872:  MOVF   x78,F
03874:  BTFSS  FD8.2
03876:  BRA    39F0
03878:  MOVF   x77,W
0387A:  SUBLW  02
0387C:  BTFSS  FD8.0
0387E:  BRA    39F0
....................       { 
....................          // Abort search if there are no more valid records 
....................          if(SYNQueue[w].wDestPort == 0u) 
03880:  MOVFF  178,1AA
03884:  MOVFF  177,1A9
03888:  CLRF   xAC
0388A:  MOVLW  14
0388C:  MOVWF  xAB
0388E:  MOVLB  0
03890:  CALL   1AA0
03894:  MOVFF  01,179
03898:  MOVLW  10
0389A:  MOVLB  1
0389C:  ADDWF  01,W
0389E:  MOVWF  01
038A0:  MOVLW  00
038A2:  ADDWFC 02,W
038A4:  MOVWF  03
038A6:  MOVF   01,W
038A8:  ADDLW  DC
038AA:  MOVWF  FE9
038AC:  MOVLW  00
038AE:  ADDWFC 03,W
038B0:  MOVWF  FEA
038B2:  MOVFF  FEC,17A
038B6:  MOVF   FED,F
038B8:  MOVFF  FEF,179
038BC:  MOVF   x79,F
038BE:  BNZ   38C6
038C0:  MOVF   x7A,F
038C2:  BNZ   38C6
....................             break; 
038C4:  BRA    39F0
....................           
....................          // See if this SYN has timed out 
....................          if((WORD)TickGetDiv256() - SYNQueue[w].wTimestamp > (WORD)(TCP_SYN_QUEUE_TIMEOUT/256ull)) 
038C6:  MOVLB  0
038C8:  CALL   1A7C
038CC:  MOVFF  01,17A
038D0:  MOVFF  00,179
038D4:  MOVFF  178,1AA
038D8:  MOVFF  177,1A9
038DC:  MOVLB  1
038DE:  CLRF   xAC
038E0:  MOVLW  14
038E2:  MOVWF  xAB
038E4:  MOVLB  0
038E6:  CALL   1AA0
038EA:  MOVFF  02,17C
038EE:  MOVFF  01,17B
038F2:  MOVLW  12
038F4:  MOVLB  1
038F6:  ADDWF  01,W
038F8:  MOVWF  01
038FA:  MOVLW  00
038FC:  ADDWFC 02,W
038FE:  MOVWF  03
03900:  MOVF   01,W
03902:  ADDLW  DC
03904:  MOVWF  FE9
03906:  MOVLW  00
03908:  ADDWFC 03,W
0390A:  MOVWF  FEA
0390C:  MOVFF  FEC,03
03910:  MOVF   FED,F
03912:  MOVF   FEF,W
03914:  SUBWF  x79,F
03916:  MOVF   03,W
03918:  SUBWFB x7A,F
0391A:  MOVF   x7A,W
0391C:  SUBLW  00
0391E:  BC    39E8
03920:  XORLW  FF
03922:  BNZ   392A
03924:  MOVF   x79,W
03926:  SUBLW  C9
03928:  BC    39E8
....................          { 
....................             // Delete this SYN from the SYNQueue and compact the SYNQueue[] array 
....................             TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE)); 
0392A:  MOVFF  178,1AA
0392E:  MOVFF  177,1A9
03932:  CLRF   xAC
03934:  MOVLW  14
03936:  MOVWF  xAB
03938:  MOVLB  0
0393A:  CALL   1AA0
0393E:  MOVFF  02,03
03942:  MOVF   01,W
03944:  ADDLW  DC
03946:  MOVWF  01
03948:  MOVLW  00
0394A:  ADDWFC 03,F
0394C:  MOVFF  01,179
03950:  MOVLB  1
03952:  MOVFF  03,17A
03956:  MOVLW  01
03958:  ADDWF  x77,W
0395A:  MOVWF  x7B
0395C:  MOVLW  00
0395E:  ADDWFC x78,W
03960:  MOVWF  x7C
03962:  MOVWF  xAA
03964:  MOVFF  17B,1A9
03968:  CLRF   xAC
0396A:  MOVLW  14
0396C:  MOVWF  xAB
0396E:  MOVLB  0
03970:  CALL   1AA0
03974:  MOVFF  02,03
03978:  MOVF   01,W
0397A:  ADDLW  DC
0397C:  MOVWF  01
0397E:  MOVLW  00
03980:  ADDWFC 03,F
03982:  MOVFF  01,17B
03986:  MOVLB  1
03988:  MOVFF  03,17C
0398C:  MOVLW  02
0398E:  BSF    FD8.0
03990:  SUBFWB x77,W
03992:  MOVWF  x7D
03994:  MOVLW  00
03996:  SUBFWB x78,W
03998:  MOVWF  x7E
0399A:  MOVWF  xAA
0399C:  MOVFF  17D,1A9
039A0:  CLRF   xAC
039A2:  MOVLW  14
039A4:  MOVWF  xAB
039A6:  MOVLB  0
039A8:  CALL   1AA0
039AC:  MOVFF  02,17E
039B0:  MOVFF  01,17D
039B4:  MOVFF  17A,2A4
039B8:  MOVFF  179,2A3
039BC:  MOVLW  01
039BE:  MOVLB  2
039C0:  MOVWF  xA5
039C2:  MOVFF  17C,2A7
039C6:  MOVFF  17B,2A6
039CA:  MOVWF  xA8
039CC:  MOVFF  02,2AA
039D0:  MOVFF  01,2A9
039D4:  MOVLB  0
039D6:  CALL   1224
....................             SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort = 0u; 
039DA:  MOVLB  1
039DC:  CLRF   x15
039DE:  CLRF   x14
....................     
....................             // Since we deleted an entry, we need to roll back one  
....................             // index so next loop will process the correct record 
....................             w--;    
039E0:  MOVF   x77,W
039E2:  BTFSC  FD8.2
039E4:  DECF   x78,F
039E6:  DECF   x77,F
....................          } 
039E8:  INCF   x77,F
039EA:  BTFSC  FD8.2
039EC:  INCF   x78,F
039EE:  BRA    3872
....................       } 
....................    #endif 
039F0:  MOVLB  0
039F2:  GOTO   59CE (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPProcess(NODE_INFO* remote, IP_ADDR* localIP, WORD len) 
....................  
....................   Summary: 
....................      Handles incoming TCP segments. 
....................  
....................   Description: 
....................    This function handles incoming TCP segments.  When a segment arrives, it 
....................    is compared to open sockets using a hash of the remote port and IP.   
....................    On a match, the data is passed to HandleTCPSeg for further processing. 
....................  
....................   Precondition: 
....................    TCP is initialized and a TCP segment is ready in the MAC buffer. 
....................  
....................   Parameters: 
....................    remote - Remote NODE_INFO structure 
....................    localIP - This stack's IP address (for header checking) 
....................    len - Total length of the waiting TCP segment 
....................  
....................   Return Values: 
....................    TRUE - the segment was properly handled. 
....................    FALSE - otherwise 
....................   ***************************************************************************/ 
.................... BOOL TCPProcess(NODE_INFO* remote, IP_ADDR* localIP, WORD len) 
.................... { 
....................    TCP_HEADER      TCPHeader; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................    WORD_VAL        checksum1; 
....................    WORD_VAL        checksum2; 
....................    BYTE            optionsSize; 
....................  
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress      = remote->IPAddr; 
*
0584E:  MOVLB  1
05850:  MOVFF  174,FE9
05854:  MOVFF  175,FEA
05858:  MOVFF  FEF,00
0585C:  MOVFF  FEC,01
05860:  MOVFF  FEC,02
05864:  MOVFF  FEC,03
05868:  MOVFF  00,18E
0586C:  MOVFF  01,18F
05870:  MOVFF  02,190
05874:  MOVFF  03,191
....................    pseudoHeader.DestAddress        = *localIP; 
05878:  MOVFF  176,FE9
0587C:  MOVFF  177,FEA
05880:  MOVFF  FEF,00
05884:  MOVFF  FEC,01
05888:  MOVFF  FEC,02
0588C:  MOVFF  FEC,03
05890:  MOVFF  00,192
05894:  MOVFF  01,193
05898:  MOVFF  02,194
0589C:  MOVFF  03,195
....................    pseudoHeader.Zero               = 0x0; 
058A0:  CLRF   x96
....................    pseudoHeader.Protocol           = IP_PROT_TCP; 
058A2:  MOVLW  06
058A4:  MOVWF  x97
....................    pseudoHeader.Length             = len; 
058A6:  MOVFF  179,199
058AA:  MOVFF  178,198
....................  
....................    SwapPseudoHeader(pseudoHeader); 
058AE:  MOVFF  199,2BC
058B2:  MOVFF  198,2BB
058B6:  MOVLB  0
058B8:  CALL   1C00
058BC:  MOVFF  02,199
058C0:  MOVFF  01,198
....................  
....................    checksum1.Val = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
058C4:  MOVLW  01
058C6:  MOVLB  1
058C8:  MOVWF  xA0
058CA:  MOVLW  8E
058CC:  MOVWF  x9F
058CE:  MOVFF  1A0,2B8
058D2:  MOVFF  FE8,2B7
058D6:  MOVLB  2
058D8:  CLRF   xBA
058DA:  MOVLW  0C
058DC:  MOVWF  xB9
058DE:  MOVLB  0
058E0:  CALL   1FB4
058E4:  MOVFF  01,19A
058E8:  MOVLB  1
058EA:  COMF   x9A,F
058EC:  MOVFF  02,19B
058F0:  COMF   x9B,F
....................  
....................    // Now calculate TCP packet checksum in NIC RAM - should match 
....................    // pesudo header checksum 
....................    checksum2.Val = CalcIPBufferChecksum(len); 
058F2:  MOVFF  179,29D
058F6:  MOVFF  178,29C
058FA:  MOVLB  0
058FC:  CALL   2326
05900:  MOVFF  02,19D
05904:  MOVFF  01,19C
....................  
....................    // Compare checksums. 
....................    if(checksum1.Val != checksum2.Val) 
05908:  MOVLB  1
0590A:  MOVF   x9C,W
0590C:  SUBWF  x9A,W
0590E:  BNZ   5916
05910:  MOVF   x9D,W
05912:  SUBWF  x9B,W
05914:  BZ    5924
....................    { 
....................       MACDiscardRx(); 
05916:  MOVLB  0
05918:  CALL   39F6
....................       return TRUE; 
0591C:  MOVLW  01
0591E:  MOVWF  01
05920:  BRA    59C6
05922:  MOVLB  1
....................    } 
....................  
.................... #if defined(DEBUG_GENERATE_RX_LOSS) 
....................    // Throw RX packets away randomly 
....................    if(LFSRRand() > DEBUG_GENERATE_RX_LOSS) 
....................    { 
....................       MACDiscardRx(); 
....................       return TRUE; 
....................    } 
.................... #endif 
....................  
....................    // Retrieve TCP header. 
....................    IPSetRxBuffer(0); 
05924:  CLRF   xC4
05926:  CLRF   xC3
05928:  MOVLB  0
0592A:  CALL   3FDA
....................    MACGetArray((BYTE*)&TCPHeader, sizeof(TCPHeader)); 
0592E:  MOVLW  01
05930:  MOVLB  1
05932:  MOVWF  xA0
05934:  MOVLW  7A
05936:  MOVWF  x9F
05938:  MOVFF  1A0,2BF
0593C:  MOVFF  FE8,2BE
05940:  MOVLB  2
05942:  CLRF   xC1
05944:  MOVLW  14
05946:  MOVWF  xC0
05948:  MOVLB  0
0594A:  CALL   0EDC
....................    SwapTCPHeader(&TCPHeader); 
0594E:  MOVLW  01
05950:  MOVLB  2
05952:  MOVWF  x9D
05954:  MOVLW  7A
05956:  MOVWF  x9C
05958:  MOVLB  0
0595A:  CALL   1D98
....................  
....................  
....................    // Skip over options to retrieve data bytes 
....................    optionsSize = (BYTE)((TCPHeader.DataOffset.Val << 2)- 
....................       sizeof(TCPHeader)); 
0595E:  MOVLB  1
05960:  SWAPF  x86,W
05962:  ANDLW  0F
05964:  MOVWF  00
05966:  RLCF   00,F
05968:  RLCF   00,F
0596A:  MOVLW  FC
0596C:  ANDWF  00,F
0596E:  MOVF   00,W
05970:  ADDLW  EC
05972:  MOVWF  x9E
....................    len = len - optionsSize - sizeof(TCPHeader); 
05974:  MOVF   x9E,W
05976:  SUBWF  x78,W
05978:  MOVWF  x9F
0597A:  MOVLW  00
0597C:  SUBWFB x79,W
0597E:  MOVWF  xA0
05980:  MOVLW  14
05982:  SUBWF  x9F,W
05984:  MOVWF  x78
05986:  MOVLW  00
05988:  SUBWFB xA0,W
0598A:  MOVWF  x79
....................  
....................    // Find matching socket. 
....................    if(FindMatchingTCPSocket(&TCPHeader, remote)) 
0598C:  MOVLW  01
0598E:  MOVWF  xA0
05990:  MOVLW  7A
05992:  MOVWF  x9F
05994:  MOVFF  175,1A2
05998:  MOVFF  174,1A1
0599C:  MOVLB  0
0599E:  GOTO   3FF4
059A2:  MOVF   01,F
059A4:  BZ    59BE
....................    { 
....................       #if defined(STACK_USE_SSL) 
....................       PTR_BASE prevRxHead; 
....................       // For SSL connections, show HandleTCPSeg() the full data buffer 
....................       prevRxHead = MyTCBStub.rxHead; 
....................       if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................          MyTCBStub.rxHead = MyTCBStub.sslRxHead; 
....................       #endif 
....................        
....................       HandleTCPSeg(&TCPHeader, len); 
059A6:  MOVLW  01
059A8:  MOVLB  1
059AA:  MOVWF  xA0
059AC:  MOVLW  7A
059AE:  MOVWF  x9F
059B0:  MOVFF  179,1A2
059B4:  MOVFF  178,1A1
059B8:  MOVLB  0
059BA:  GOTO   4720
....................        
....................       #if defined(STACK_USE_SSL) 
....................       if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       { 
....................          // Restore the buffer state 
....................          MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................          MyTCBStub.rxHead = prevRxHead; 
....................  
....................          // Process the new SSL data, using the currently loaded stub 
....................          TCPSSLHandleIncoming(hCurrentTCP); 
....................       } 
....................       #endif 
....................    } 
.................... //   else 
.................... //   { 
.................... //      // NOTE: RFC 793 specifies that if the socket is closed and a segment  
.................... //      // arrives, we should send back a RST if the RST bit in the incoming  
.................... //      // packet is not set.  Instead, we will just silently ignore such a  
.................... //      // packet since this is what firewalls do on purpose to enhance  
.................... //      // security. 
.................... //      //if(!TCPHeader.Flags.bits.flagRST) 
.................... //      //   SendTCP(RST, SENDTCP_RESET_TIMERS); 
.................... //   } 
....................  
....................    // Finished with this packet, discard it and free the Ethernet RAM for new packets 
....................    MACDiscardRx(); 
059BE:  CALL   39F6
....................  
....................    return TRUE; 
059C2:  MOVLW  01
059C4:  MOVWF  01
059C6:  GOTO   5AFE (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void SendTCP(BYTE vTCPFlags, BYTE vSendFlags) 
....................  
....................   Summary: 
....................    Transmits a TPC segment. 
....................  
....................   Description: 
....................    This function assembles and transmits a TCP segment, including any  
....................    pending data.  It also supports retransmissions, keep-alives, and  
....................    other packet types. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    vTCPFlags - Additional TCP flags to include 
....................    vSendFlags - Any combinations of SENDTCP_* constants to modify the 
....................              transmit behavior or contents. 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... static void SendTCP(BYTE vTCPFlags, BYTE vSendFlags) 
.................... { 
....................    WORD_VAL        wVal; 
....................    TCP_HEADER      header; 
....................    TCP_OPTIONS     options; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................    WORD          len; 
....................     
....................    SyncTCB(); 
*
026A2:  CALL   130A
....................  
....................    // FINs must be handled specially 
....................    if(vTCPFlags & FIN) 
026A6:  MOVLB  2
026A8:  BTFSS  x72.0
026AA:  BRA    26B4
....................    { 
....................       MyTCBStub.Flags.bTXFIN = 1; 
026AC:  MOVLB  1
026AE:  BSF    x30.3
....................       vTCPFlags &= ~FIN; 
026B0:  MOVLB  2
026B2:  BCF    x72.0
....................    } 
....................  
....................    // Status will now be synched, disable automatic future  
....................    // status transmissions 
....................    MyTCBStub.Flags.bTimer2Enabled = 0; 
026B4:  MOVLB  1
026B6:  BCF    x2F.5
....................    MyTCBStub.Flags.bDelayedACKTimerEnabled = 0; 
026B8:  BCF    x2F.6
....................    MyTCBStub.Flags.bOneSegmentReceived = 0; 
026BA:  BCF    x2F.7
....................    MyTCBStub.Flags.bTXASAP = 0; 
026BC:  BCF    x30.1
....................    MyTCBStub.Flags.bTXASAPWithoutTimerReset = 0; 
026BE:  BCF    x30.2
....................    MyTCBStub.Flags.bHalfFullFlush = 0; 
026C0:  BCF    x30.0
....................  
....................    //  Make sure that we can write to the MAC transmit area 
....................    while(!IPIsTxReady()); 
026C2:  MOVLB  0
026C4:  CALL   1A1C
026C8:  MOVF   01,F
026CA:  BZ    26C4
....................  
....................    // Put all socket application data in the TX space 
....................    if(vTCPFlags & (SYN | RST)) 
026CC:  MOVLB  2
026CE:  MOVF   x72,W
026D0:  ANDLW  06
026D2:  BZ    26DA
....................    { 
....................       // Don't put any data in SYN and RST messages 
....................       len = 0; 
026D4:  CLRF   x9B
026D6:  CLRF   x9A
....................    } 
026D8:  BRA    2940
....................    else 
....................    { 
....................       // Begin copying any application data over to the TX space 
....................       if(MyTCBStub.txHead == MyTCB.txUnackedTail) 
026DA:  MOVLB  0
026DC:  MOVF   xC0,W
026DE:  MOVLB  1
026E0:  SUBWF  x1E,W
026E2:  BNZ   26F6
026E4:  MOVLB  0
026E6:  MOVF   xC1,W
026E8:  MOVLB  1
026EA:  SUBWF  x1F,W
026EC:  BNZ   26F6
....................       { 
....................          // All caught up on data TX, no real data for this packet 
....................          len = 0; 
026EE:  MOVLB  2
026F0:  CLRF   x9B
026F2:  CLRF   x9A
....................       } 
026F4:  BRA    2910
....................       else if(MyTCBStub.txHead > MyTCB.txUnackedTail) 
026F6:  MOVLB  0
026F8:  MOVF   xC1,W
026FA:  MOVLB  1
026FC:  SUBWF  x1F,W
026FE:  BNC   27B0
02700:  BNZ   2712
02702:  MOVF   x1E,W
02704:  MOVLB  0
02706:  SUBWF  xC0,W
02708:  BTFSS  FD8.0
0270A:  BRA    2710
0270C:  MOVLB  1
0270E:  BRA    27B0
02710:  MOVLB  1
....................       { 
....................          len = MyTCBStub.txHead - MyTCB.txUnackedTail; 
02712:  MOVLB  0
02714:  MOVF   xC0,W
02716:  MOVLB  1
02718:  SUBWF  x1E,W
0271A:  MOVLB  2
0271C:  MOVWF  x9A
0271E:  MOVLB  0
02720:  MOVF   xC1,W
02722:  MOVLB  1
02724:  SUBWFB x1F,W
02726:  MOVLB  2
02728:  MOVWF  x9B
....................  
....................          if(len > MyTCB.remoteWindow) 
0272A:  MOVLB  0
0272C:  MOVF   xC7,W
0272E:  MOVLB  2
02730:  SUBWF  x9B,W
02732:  BNC   274E
02734:  BNZ   2746
02736:  MOVF   x9A,W
02738:  MOVLB  0
0273A:  SUBWF  xC6,W
0273C:  BTFSS  FD8.0
0273E:  BRA    2744
02740:  MOVLB  2
02742:  BRA    274E
02744:  MOVLB  2
....................             len = MyTCB.remoteWindow; 
02746:  MOVFF  C7,29B
0274A:  MOVFF  C6,29A
....................  
....................          if(len > MyTCB.wRemoteMSS) 
0274E:  MOVLB  0
02750:  MOVF   xD8,W
02752:  MOVLB  2
02754:  SUBWF  x9B,W
02756:  BNC   2778
02758:  BNZ   276A
0275A:  MOVF   x9A,W
0275C:  MOVLB  0
0275E:  SUBWF  xD7,W
02760:  BTFSS  FD8.0
02762:  BRA    2768
02764:  MOVLB  2
02766:  BRA    2778
02768:  MOVLB  2
....................          { 
....................             len = MyTCB.wRemoteMSS; 
0276A:  MOVFF  D8,29B
0276E:  MOVFF  D7,29A
....................             MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
02772:  MOVLB  1
02774:  BSF    x30.2
02776:  MOVLB  2
....................          } 
....................  
....................          // Copy application data into the raw TX buffer 
....................          TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER), TCP_ETH_RAM, MyTCB.txUnackedTail, MyTCBStub.vMemoryMedium, len); 
02778:  MOVLW  15
0277A:  MOVWF  xA4
0277C:  MOVLW  41
0277E:  MOVWF  xA3
02780:  CLRF   xA5
02782:  MOVFF  C1,2A7
02786:  MOVFF  C0,2A6
0278A:  MOVFF  133,2A8
0278E:  MOVFF  29B,2AA
02792:  MOVFF  29A,2A9
02796:  MOVLB  0
02798:  CALL   1224
....................          MyTCB.txUnackedTail += len; 
0279C:  MOVLB  2
0279E:  MOVF   x9A,W
027A0:  MOVLB  0
027A2:  ADDWF  xC0,F
027A4:  MOVLB  2
027A6:  MOVF   x9B,W
027A8:  MOVLB  0
027AA:  ADDWFC xC1,F
....................       } 
027AC:  BRA    290E
027AE:  MOVLB  1
....................       else 
....................       { 
....................          pseudoHeader.Length = MyTCBStub.bufferRxStart - MyTCB.txUnackedTail; 
027B0:  MOVLB  0
027B2:  MOVF   xC0,W
027B4:  MOVLB  1
027B6:  SUBWF  x1A,W
027B8:  MOVLB  2
027BA:  MOVWF  x98
027BC:  MOVLB  0
027BE:  MOVF   xC1,W
027C0:  MOVLB  1
027C2:  SUBWFB x1B,W
027C4:  MOVLB  2
027C6:  MOVWF  x99
....................          len = pseudoHeader.Length + MyTCBStub.txHead - MyTCBStub.bufferTxStart; 
027C8:  MOVLB  1
027CA:  MOVF   x1E,W
027CC:  MOVLB  2
027CE:  ADDWF  x98,W
027D0:  MOVWF  x9C
027D2:  MOVLB  1
027D4:  MOVF   x1F,W
027D6:  MOVLB  2
027D8:  ADDWFC x99,W
027DA:  MOVWF  x9D
027DC:  MOVLB  1
027DE:  MOVF   x18,W
027E0:  MOVLB  2
027E2:  SUBWF  x9C,W
027E4:  MOVWF  x9A
027E6:  MOVLB  1
027E8:  MOVF   x19,W
027EA:  MOVLB  2
027EC:  SUBWFB x9D,W
027EE:  MOVWF  x9B
....................  
....................          if(len > MyTCB.remoteWindow) 
027F0:  MOVLB  0
027F2:  MOVF   xC7,W
027F4:  MOVLB  2
027F6:  SUBWF  x9B,W
027F8:  BNC   2814
027FA:  BNZ   280C
027FC:  MOVF   x9A,W
027FE:  MOVLB  0
02800:  SUBWF  xC6,W
02802:  BTFSS  FD8.0
02804:  BRA    280A
02806:  MOVLB  2
02808:  BRA    2814
0280A:  MOVLB  2
....................             len = MyTCB.remoteWindow; 
0280C:  MOVFF  C7,29B
02810:  MOVFF  C6,29A
....................  
....................          if(len > MyTCB.wRemoteMSS) 
02814:  MOVLB  0
02816:  MOVF   xD8,W
02818:  MOVLB  2
0281A:  SUBWF  x9B,W
0281C:  BNC   283E
0281E:  BNZ   2830
02820:  MOVF   x9A,W
02822:  MOVLB  0
02824:  SUBWF  xD7,W
02826:  BTFSS  FD8.0
02828:  BRA    282E
0282A:  MOVLB  2
0282C:  BRA    283E
0282E:  MOVLB  2
....................          { 
....................             len = MyTCB.wRemoteMSS; 
02830:  MOVFF  D8,29B
02834:  MOVFF  D7,29A
....................             MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
02838:  MOVLB  1
0283A:  BSF    x30.2
0283C:  MOVLB  2
....................          } 
....................  
....................          if(pseudoHeader.Length > len) 
0283E:  MOVF   x9B,W
02840:  SUBWF  x99,W
02842:  BNC   2854
02844:  BNZ   284C
02846:  MOVF   x98,W
02848:  SUBWF  x9A,W
0284A:  BC    2854
....................             pseudoHeader.Length = len; 
0284C:  MOVFF  29B,299
02850:  MOVFF  29A,298
....................  
....................          // Copy application data into the raw TX buffer 
....................          TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER), TCP_ETH_RAM, MyTCB.txUnackedTail, MyTCBStub.vMemoryMedium, pseudoHeader.Length); 
02854:  MOVLW  15
02856:  MOVWF  xA4
02858:  MOVLW  41
0285A:  MOVWF  xA3
0285C:  CLRF   xA5
0285E:  MOVFF  C1,2A7
02862:  MOVFF  C0,2A6
02866:  MOVFF  133,2A8
0286A:  MOVFF  299,2AA
0286E:  MOVFF  298,2A9
02872:  MOVLB  0
02874:  CALL   1224
....................          pseudoHeader.Length = len - pseudoHeader.Length; 
02878:  MOVLB  2
0287A:  MOVF   x98,W
0287C:  SUBWF  x9A,W
0287E:  MOVWF  x98
02880:  MOVF   x99,W
02882:  SUBWFB x9B,W
02884:  MOVWF  x99
....................     
....................          // Copy any left over chunks of application data over 
....................          if(pseudoHeader.Length) 
02886:  MOVF   x98,W
02888:  IORWF  x99,W
0288A:  BZ    28D2
....................          { 
....................             TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER)+(MyTCBStub.bufferRxStart-MyTCB.txUnackedTail), TCP_ETH_RAM, MyTCBStub.bufferTxStart, MyTCBStub.vMemoryMedium, pseudoHeader.Length); 
0288C:  MOVLB  0
0288E:  MOVF   xC0,W
02890:  MOVLB  1
02892:  SUBWF  x1A,W
02894:  MOVWF  00
02896:  MOVLB  0
02898:  MOVF   xC1,W
0289A:  MOVLB  1
0289C:  SUBWFB x1B,W
0289E:  MOVWF  03
028A0:  MOVF   00,W
028A2:  ADDLW  41
028A4:  MOVLB  2
028A6:  MOVWF  x9C
028A8:  MOVLW  15
028AA:  ADDWFC 03,W
028AC:  MOVWF  x9D
028AE:  MOVWF  xA4
028B0:  MOVFF  29C,2A3
028B4:  CLRF   xA5
028B6:  MOVFF  119,2A7
028BA:  MOVFF  118,2A6
028BE:  MOVFF  133,2A8
028C2:  MOVFF  299,2AA
028C6:  MOVFF  298,2A9
028CA:  MOVLB  0
028CC:  CALL   1224
028D0:  MOVLB  2
....................          } 
....................  
....................          MyTCB.txUnackedTail += len; 
028D2:  MOVF   x9A,W
028D4:  MOVLB  0
028D6:  ADDWF  xC0,F
028D8:  MOVLB  2
028DA:  MOVF   x9B,W
028DC:  MOVLB  0
028DE:  ADDWFC xC1,F
....................          if(MyTCB.txUnackedTail >= MyTCBStub.bufferRxStart) 
028E0:  MOVLB  1
028E2:  MOVF   x1B,W
028E4:  MOVLB  0
028E6:  SUBWF  xC1,W
028E8:  BNC   290E
028EA:  BNZ   28F6
028EC:  MOVLB  1
028EE:  MOVF   x1A,W
028F0:  MOVLB  0
028F2:  SUBWF  xC0,W
028F4:  BNC   290E
....................             MyTCB.txUnackedTail -= MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart; 
028F6:  MOVLB  1
028F8:  MOVF   x18,W
028FA:  SUBWF  x1A,W
028FC:  MOVWF  00
028FE:  MOVF   x19,W
02900:  SUBWFB x1B,W
02902:  MOVWF  03
02904:  MOVF   00,W
02906:  MOVLB  0
02908:  SUBWF  xC0,F
0290A:  MOVF   03,W
0290C:  SUBWFB xC1,F
0290E:  MOVLB  2
....................       } 
....................  
....................       // If we are to transmit a FIN, make sure we can put one in this packet 
....................       if(MyTCBStub.Flags.bTXFIN) 
02910:  MOVLB  1
02912:  BTFSS  x30.3
02914:  BRA    2942
....................       { 
....................          if((len != MyTCB.remoteWindow) && (len != MyTCB.wRemoteMSS)) 
02916:  MOVLB  0
02918:  MOVF   xC6,W
0291A:  MOVLB  2
0291C:  SUBWF  x9A,W
0291E:  BNZ   292A
02920:  MOVLB  0
02922:  MOVF   xC7,W
02924:  MOVLB  2
02926:  SUBWF  x9B,W
02928:  BZ    2940
0292A:  MOVLB  0
0292C:  MOVF   xD7,W
0292E:  MOVLB  2
02930:  SUBWF  x9A,W
02932:  BNZ   293E
02934:  MOVLB  0
02936:  MOVF   xD8,W
02938:  MOVLB  2
0293A:  SUBWF  x9B,W
0293C:  BZ    2940
....................             vTCPFlags |= FIN; 
0293E:  BSF    x72.0
02940:  MOVLB  1
....................       } 
....................    } 
....................  
....................    // Ensure that all packets with data of some kind are  
....................    // retransmitted by TCPTick() until acknowledged 
....................    // Pure ACK packets with no data are not ACKed back in TCP 
....................    if(len || (vTCPFlags & (SYN | FIN))) 
02942:  MOVLB  2
02944:  MOVF   x9A,W
02946:  IORWF  x9B,W
02948:  BNZ   2950
0294A:  MOVF   x72,W
0294C:  ANDLW  03
0294E:  BZ    29B8
....................    { 
....................       // Transmitting data, update remote window variable to reflect smaller  
....................       // window. 
....................       MyTCB.remoteWindow -= len; 
02950:  MOVF   x9A,W
02952:  MOVLB  0
02954:  SUBWF  xC6,F
02956:  MOVLB  2
02958:  MOVF   x9B,W
0295A:  MOVLB  0
0295C:  SUBWFB xC7,F
....................  
....................       // Push (PSH) all data for enhanced responsiveness on  
....................       // the remote end, especially with GUIs 
....................       if(len) 
0295E:  MOVLB  2
02960:  MOVF   x9A,W
02962:  IORWF  x9B,W
02964:  BZ    2968
....................          vTCPFlags |= PSH; 
02966:  BSF    x72.3
....................  
....................       if(vSendFlags & SENDTCP_RESET_TIMERS) 
02968:  BTFSS  x73.0
0296A:  BRA    297E
....................       { 
....................          MyTCB.retryCount = 0; 
0296C:  MOVLB  0
0296E:  CLRF   xD9
....................          MyTCB.retryInterval = TCP_START_TIMEOUT_VAL; 
02970:  CLRF   xB7
02972:  CLRF   xB6
02974:  MOVLW  98
02976:  MOVWF  xB5
02978:  MOVLW  97
0297A:  MOVWF  xB4
0297C:  MOVLB  2
....................       }    
....................  
....................       MyTCBStub.eventTime = TickGet() + MyTCB.retryInterval; 
0297E:  MOVLB  0
02980:  CALL   1AC2
02984:  MOVF   xB4,W
02986:  MOVLB  2
02988:  ADDWF  00,W
0298A:  MOVLB  1
0298C:  MOVWF  x26
0298E:  MOVLB  0
02990:  MOVF   xB5,W
02992:  MOVLB  2
02994:  ADDWFC 01,W
02996:  MOVLB  1
02998:  MOVWF  x27
0299A:  MOVLB  0
0299C:  MOVF   xB6,W
0299E:  MOVLB  2
029A0:  ADDWFC 02,W
029A2:  MOVLB  1
029A4:  MOVWF  x28
029A6:  MOVLB  0
029A8:  MOVF   xB7,W
029AA:  MOVLB  2
029AC:  ADDWFC 03,W
029AE:  MOVLB  1
029B0:  MOVWF  x29
....................       MyTCBStub.Flags.bTimerEnabled = 1; 
029B2:  BSF    x2F.4
....................    } 
029B4:  BRA    2A3A
029B6:  MOVLB  2
....................    else if(vSendFlags & SENDTCP_KEEP_ALIVE) 
029B8:  BTFSS  x73.1
029BA:  BRA    29E6
....................    { 
....................       // Increment Keep Alive TX counter to handle disconnection if not response is returned 
....................       MyTCBStub.Flags.vUnackedKeepalives++; 
029BC:  MOVLB  1
029BE:  MOVF   x2F,W
029C0:  ADDLW  01
029C2:  ANDLW  07
029C4:  MOVWF  00
029C6:  MOVLW  F8
029C8:  ANDWF  x2F,W
029CA:  IORWF  00,W
029CC:  MOVWF  x2F
....................        
....................       // Generate a dummy byte 
....................       MyTCB.MySEQ -= 1; 
029CE:  MOVLW  01
029D0:  MOVLB  0
029D2:  SUBWF  xB8,F
029D4:  MOVLW  00
029D6:  SUBWFB xB9,F
029D8:  SUBWFB xBA,F
029DA:  SUBWFB xBB,F
....................       len = 1; 
029DC:  MOVLB  2
029DE:  CLRF   x9B
029E0:  MOVLW  01
029E2:  MOVWF  x9A
....................    } 
029E4:  BRA    2A3C
....................    else if(MyTCBStub.Flags.bTimerEnabled)  
029E6:  MOVLB  1
029E8:  BTFSS  x2F.4
029EA:  BRA    2A3A
....................    { 
....................       // If we have data to transmit, but the remote RX window is zero,  
....................       // so we aren't transmitting any right now then make sure to not  
....................       // extend the retry counter or timer.  This will stall our TX  
....................       // with a periodic ACK sent to the remote node. 
....................       if(!(vSendFlags & SENDTCP_RESET_TIMERS)) 
029EC:  MOVLB  2
029EE:  BTFSC  x73.0
029F0:  BRA    2A06
....................       { 
....................          // Roll back retry counters since we can't send anything,  
....................          // but only if we incremented it in the first place 
....................          if(MyTCB.retryCount) 
029F2:  MOVLB  0
029F4:  MOVF   xD9,F
029F6:  BZ    2A04
....................          { 
....................             MyTCB.retryCount--; 
029F8:  DECF   xD9,F
....................             MyTCB.retryInterval >>= 1; 
029FA:  BCF    FD8.0
029FC:  RRCF   xB7,F
029FE:  RRCF   xB6,F
02A00:  RRCF   xB5,F
02A02:  RRCF   xB4,F
02A04:  MOVLB  2
....................          } 
....................       } 
....................     
....................       MyTCBStub.eventTime = TickGet() + MyTCB.retryInterval; 
02A06:  MOVLB  0
02A08:  CALL   1AC2
02A0C:  MOVF   xB4,W
02A0E:  MOVLB  2
02A10:  ADDWF  00,W
02A12:  MOVLB  1
02A14:  MOVWF  x26
02A16:  MOVLB  0
02A18:  MOVF   xB5,W
02A1A:  MOVLB  2
02A1C:  ADDWFC 01,W
02A1E:  MOVLB  1
02A20:  MOVWF  x27
02A22:  MOVLB  0
02A24:  MOVF   xB6,W
02A26:  MOVLB  2
02A28:  ADDWFC 02,W
02A2A:  MOVLB  1
02A2C:  MOVWF  x28
02A2E:  MOVLB  0
02A30:  MOVF   xB7,W
02A32:  MOVLB  2
02A34:  ADDWFC 03,W
02A36:  MOVLB  1
02A38:  MOVWF  x29
02A3A:  MOVLB  2
....................    } 
....................     
....................  
....................    header.SourcePort         = MyTCB.localPort.Val; 
02A3C:  MOVFF  C5,277
02A40:  MOVFF  C4,276
....................    header.DestPort            = MyTCB.remotePort.Val; 
02A44:  MOVFF  C3,279
02A48:  MOVFF  C2,278
....................    header.SeqNumber         = MyTCB.MySEQ; 
02A4C:  MOVFF  BB,27D
02A50:  MOVFF  BA,27C
02A54:  MOVFF  B9,27B
02A58:  MOVFF  B8,27A
....................    header.AckNumber         = MyTCB.RemoteSEQ; 
02A5C:  MOVFF  BF,281
02A60:  MOVFF  BE,280
02A64:  MOVFF  BD,27F
02A68:  MOVFF  BC,27E
....................    header.Flags.bits.Reserved2   = 0; 
02A6C:  MOVLW  3F
02A6E:  ANDWF  x83,W
02A70:  MOVWF  x83
....................    header.DataOffset.Reserved3   = 0; 
02A72:  MOVLW  F0
02A74:  ANDWF  x82,W
02A76:  MOVWF  x82
....................    header.Flags.byte         = vTCPFlags; 
02A78:  MOVFF  272,283
....................    header.UrgentPointer        = 0; 
02A7C:  CLRF   x89
02A7E:  CLRF   x88
....................  
....................    // Update our send sequence number and ensure retransmissions  
....................    // of SYNs and FINs use the right sequence number 
....................    MyTCB.MySEQ += (DWORD)len; 
02A80:  MOVFF  29B,01
02A84:  CLRF   02
02A86:  CLRF   03
02A88:  MOVF   x9A,W
02A8A:  MOVLB  0
02A8C:  ADDWF  xB8,F
02A8E:  MOVF   01,W
02A90:  ADDWFC xB9,F
02A92:  MOVF   02,W
02A94:  ADDWFC xBA,F
02A96:  MOVF   03,W
02A98:  ADDWFC xBB,F
....................    if(vTCPFlags & SYN) 
02A9A:  MOVLB  2
02A9C:  BTFSS  x72.1
02A9E:  BRA    2ADC
....................    { 
....................       // SEG.ACK needs to be zero for the first SYN packet for compatibility  
....................       // with certain paranoid TCP/IP stacks, even though the ACK flag isn't  
....................       // set (indicating that the AckNumber field is unused). 
....................       if(!(vTCPFlags & ACK)) 
02AA0:  BTFSC  x72.4
02AA2:  BRA    2AAC
....................          header.AckNumber = 0x00000000; 
02AA4:  CLRF   x81
02AA6:  CLRF   x80
02AA8:  CLRF   x7F
02AAA:  CLRF   x7E
....................  
....................       if(MyTCB.flags.bSYNSent) 
02AAC:  MOVLB  0
02AAE:  BTFSS  xD6.1
02AB0:  BRA    2AC8
....................          header.SeqNumber--; 
02AB2:  MOVLW  FF
02AB4:  MOVLB  2
02AB6:  ADDWF  x7A,F
02AB8:  BTFSS  FD8.0
02ABA:  ADDWF  x7B,F
02ABC:  BTFSS  FD8.0
02ABE:  ADDWF  x7C,F
02AC0:  BTFSS  FD8.0
02AC2:  ADDWF  x7D,F
02AC4:  BRA    2ADC
02AC6:  MOVLB  0
....................       else 
....................       { 
....................          MyTCB.MySEQ++; 
02AC8:  MOVLW  01
02ACA:  ADDWF  xB8,F
02ACC:  BTFSC  FD8.0
02ACE:  INCF   xB9,F
02AD0:  BTFSC  FD8.2
02AD2:  INCF   xBA,F
02AD4:  BTFSC  FD8.2
02AD6:  INCF   xBB,F
....................          MyTCB.flags.bSYNSent = 1; 
02AD8:  BSF    xD6.1
02ADA:  MOVLB  2
....................       } 
....................    } 
....................    if(vTCPFlags & FIN) 
02ADC:  BTFSS  x72.0
02ADE:  BRA    2AE6
....................    { 
....................         MyTCB.flags.bFINSent = 1;   // do not advance the seq no for FIN! 
02AE0:  MOVLB  0
02AE2:  BSF    xD6.0
02AE4:  MOVLB  2
....................    } 
....................  
....................    // Calculate the amount of free space in the RX buffer area of this socket 
....................    if(MyTCBStub.rxHead >= MyTCBStub.rxTail) 
02AE6:  MOVLB  1
02AE8:  MOVF   x25,W
02AEA:  SUBWF  x23,W
02AEC:  BNC   2B28
02AEE:  BNZ   2AF6
02AF0:  MOVF   x24,W
02AF2:  SUBWF  x22,W
02AF4:  BNC   2B28
....................       header.Window = (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart) - (MyTCBStub.rxHead - MyTCBStub.rxTail); 
02AF6:  MOVF   x1A,W
02AF8:  SUBWF  x1C,W
02AFA:  MOVLB  2
02AFC:  MOVWF  x9C
02AFE:  MOVLB  1
02B00:  MOVF   x1B,W
02B02:  SUBWFB x1D,W
02B04:  MOVLB  2
02B06:  MOVWF  x9D
02B08:  MOVLB  1
02B0A:  MOVF   x24,W
02B0C:  SUBWF  x22,W
02B0E:  MOVWF  00
02B10:  MOVF   x25,W
02B12:  SUBWFB x23,W
02B14:  MOVWF  03
02B16:  MOVF   00,W
02B18:  MOVLB  2
02B1A:  SUBWF  x9C,W
02B1C:  MOVWF  x84
02B1E:  MOVF   03,W
02B20:  SUBWFB x9D,W
02B22:  MOVWF  x85
02B24:  BRA    2B46
02B26:  MOVLB  1
....................    else 
....................       header.Window = MyTCBStub.rxTail - MyTCBStub.rxHead - 1; 
02B28:  MOVF   x22,W
02B2A:  SUBWF  x24,W
02B2C:  MOVLB  2
02B2E:  MOVWF  x9C
02B30:  MOVLB  1
02B32:  MOVF   x23,W
02B34:  SUBWFB x25,W
02B36:  MOVLB  2
02B38:  MOVWF  x9D
02B3A:  MOVLW  01
02B3C:  SUBWF  x9C,W
02B3E:  MOVWF  x84
02B40:  MOVLW  00
02B42:  SUBWFB x9D,W
02B44:  MOVWF  x85
....................  
....................    // Calculate the amount of free space in the MAC RX buffer area and adjust window if needed 
....................    wVal.Val = MACGetFreeRxSize(); 
02B46:  MOVLB  0
02B48:  GOTO   1AE8
02B4C:  MOVFF  02,275
02B50:  MOVFF  01,274
....................    if(wVal.Val < 64) 
02B54:  MOVLB  2
02B56:  MOVF   x75,F
02B58:  BNZ   2B66
02B5A:  MOVF   x74,W
02B5C:  SUBLW  3F
02B5E:  BNC   2B66
....................     { 
....................       wVal.Val = 0; 
02B60:  CLRF   x75
02B62:  CLRF   x74
....................     } 
02B64:  BRA    2B6E
....................     else 
....................     { 
....................       wVal.Val -= 64; 
02B66:  MOVLW  40
02B68:  SUBWF  x74,F
02B6A:  MOVLW  00
02B6C:  SUBWFB x75,F
....................     } 
....................    // Force the remote node to throttle back if we are running low on general RX buffer space 
....................    if(header.Window > wVal.Val) 
02B6E:  MOVF   x75,W
02B70:  SUBWF  x85,W
02B72:  BNC   2B84
02B74:  BNZ   2B7C
02B76:  MOVF   x84,W
02B78:  SUBWF  x74,W
02B7A:  BC    2B84
....................       header.Window = wVal.Val; 
02B7C:  MOVFF  275,285
02B80:  MOVFF  274,284
....................  
....................    SwapTCPHeader(&header); 
02B84:  MOVLW  02
02B86:  MOVWF  x9D
02B88:  MOVLW  76
02B8A:  MOVWF  x9C
02B8C:  MOVLB  0
02B8E:  CALL   1D98
....................  
....................  
....................    len += sizeof(header); 
02B92:  MOVLW  14
02B94:  MOVLB  2
02B96:  ADDWF  x9A,F
02B98:  MOVLW  00
02B9A:  ADDWFC x9B,F
....................    header.DataOffset.Val   = sizeof(header) >> 2; 
02B9C:  MOVLW  0F
02B9E:  ANDWF  x82,W
02BA0:  IORLW  50
02BA2:  MOVWF  x82
....................  
....................    // Insert the MSS (Maximum Segment Size) TCP option if this is SYN packet 
....................    if(vTCPFlags & SYN) 
02BA4:  BTFSS  x72.1
02BA6:  BRA    2BD6
....................    { 
....................       len += sizeof(options); 
02BA8:  MOVLW  04
02BAA:  ADDWF  x9A,F
02BAC:  MOVLW  00
02BAE:  ADDWFC x9B,F
....................       options.Kind = TCP_OPTIONS_MAX_SEG_SIZE; 
02BB0:  MOVLW  02
02BB2:  MOVWF  x8A
....................       options.Length = 0x04; 
02BB4:  MOVLW  04
02BB6:  MOVWF  x8B
....................  
....................       // Load MSS and swap to big endian 
....................       options.MaxSegSize.Val = (((TCP_MAX_SEG_SIZE_RX)&0x00FF)<<8) | (((TCP_MAX_SEG_SIZE_RX)&0xFF00)>>8); 
02BB8:  MOVLW  18
02BBA:  MOVWF  x8D
02BBC:  MOVLW  02
02BBE:  MOVWF  x8C
....................  
....................      #if defined(__PCD__)  //__PCD__ __PCH__ __CCS__ bug 
....................       unsigned int8 scr8; 
....................       scr8 = header.DataOffset.Val; 
....................       scr8 += sizeof(options) >> 2; 
....................       header.DataOffset.Val = scr8; 
....................      #else  //standard code 
....................       header.DataOffset.Val   += sizeof(options) >> 2; 
02BC0:  SWAPF  x82,W
02BC2:  ANDLW  0F
02BC4:  ADDLW  01
02BC6:  MOVWF  00
02BC8:  SWAPF  00,W
02BCA:  ANDLW  F0
02BCC:  MOVWF  00
02BCE:  MOVLW  0F
02BD0:  ANDWF  x82,W
02BD2:  IORWF  00,W
02BD4:  MOVWF  x82
....................      #endif 
....................    } 
....................  
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress   = AppConfig.MyIPAddr; 
02BD6:  MOVFF  2C,291
02BDA:  MOVFF  2B,290
02BDE:  MOVFF  2A,28F
02BE2:  MOVFF  29,28E
....................    pseudoHeader.DestAddress    = MyTCB.remote.niRemoteMACIP.IPAddr; 
02BE6:  MOVFF  CD,295
02BEA:  MOVFF  CC,294
02BEE:  MOVFF  CB,293
02BF2:  MOVFF  CA,292
....................    pseudoHeader.Zero           = 0x0; 
02BF6:  CLRF   x96
....................    pseudoHeader.Protocol       = IP_PROT_TCP; 
02BF8:  MOVLW  06
02BFA:  MOVWF  x97
....................    pseudoHeader.Length         = len; 
02BFC:  MOVFF  29B,299
02C00:  MOVFF  29A,298
....................    SwapPseudoHeader(pseudoHeader); 
02C04:  MOVFF  299,2BC
02C08:  MOVFF  298,2BB
02C0C:  MOVLB  0
02C0E:  CALL   1C00
02C12:  MOVFF  02,299
02C16:  MOVFF  01,298
....................    header.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader, sizeof(pseudoHeader)); 
02C1A:  MOVLW  02
02C1C:  MOVLB  2
02C1E:  MOVWF  x9D
02C20:  MOVLW  8E
02C22:  MOVWF  x9C
02C24:  MOVFF  29D,2B8
02C28:  MOVWF  xB7
02C2A:  CLRF   xBA
02C2C:  MOVLW  0C
02C2E:  MOVWF  xB9
02C30:  MOVLB  0
02C32:  CALL   1FB4
02C36:  MOVFF  01,286
02C3A:  MOVLB  2
02C3C:  COMF   x86,F
02C3E:  MOVFF  02,287
02C42:  COMF   x87,F
....................  
....................    // Write IP header 
....................    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER)); 
02C44:  MOVLW  15
02C46:  MOVWF  xAC
02C48:  MOVLW  19
02C4A:  MOVWF  xAB
02C4C:  MOVLB  0
02C4E:  CALL   0DBA
....................    IPPutHeader(&MyTCB.remote.niRemoteMACIP, IP_PROT_TCP, len); 
02C52:  MOVLB  2
02C54:  CLRF   x9D
02C56:  MOVLW  CA
02C58:  MOVWF  x9C
02C5A:  MOVLW  06
02C5C:  MOVWF  x9E
02C5E:  MOVFF  29B,2A0
02C62:  MOVFF  29A,29F
02C66:  MOVLB  0
02C68:  CALL   223C
....................    MACPutArray((BYTE*)&header, sizeof(header)); 
02C6C:  MOVLW  02
02C6E:  MOVLB  2
02C70:  MOVWF  x9D
02C72:  MOVLW  76
02C74:  MOVWF  x9C
02C76:  MOVFF  29D,2C1
02C7A:  MOVWF  xC0
02C7C:  CLRF   xC3
02C7E:  MOVLW  14
02C80:  MOVWF  xC2
02C82:  MOVLB  0
02C84:  CALL   0E2A
....................    if(vTCPFlags & SYN) 
02C88:  MOVLB  2
02C8A:  BTFSS  x72.1
02C8C:  BRA    2CAA
....................       MACPutArray((BYTE*)&options, sizeof(options)); 
02C8E:  MOVLW  02
02C90:  MOVWF  x9D
02C92:  MOVLW  8A
02C94:  MOVWF  x9C
02C96:  MOVFF  29D,2C1
02C9A:  MOVWF  xC0
02C9C:  CLRF   xC3
02C9E:  MOVLW  04
02CA0:  MOVWF  xC2
02CA2:  MOVLB  0
02CA4:  CALL   0E2A
02CA8:  MOVLB  2
....................  
....................    // Update the TCP checksum 
....................    MACSetReadPtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER)); 
02CAA:  MOVLW  15
02CAC:  MOVWF  xAC
02CAE:  MOVLW  2D
02CB0:  MOVWF  xAB
02CB2:  MOVLB  0
02CB4:  CALL   0E70
....................    wVal.Val = CalcIPBufferChecksum(len); 
02CB8:  MOVFF  29B,29D
02CBC:  MOVFF  29A,29C
02CC0:  CALL   2326
02CC4:  MOVFF  02,275
02CC8:  MOVFF  01,274
.................... #if defined(DEBUG_GENERATE_TX_LOSS) 
....................    // Damage TCP checksums on TX packets randomly 
....................    if(LFSRRand() > DEBUG_GENERATE_TX_LOSS) 
....................    { 
....................       wVal.Val++; 
....................    } 
.................... #endif 
....................    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER) + 16); 
02CCC:  MOVLW  15
02CCE:  MOVLB  2
02CD0:  MOVWF  xAC
02CD2:  MOVLW  3D
02CD4:  MOVWF  xAB
02CD6:  MOVLB  0
02CD8:  CALL   0DBA
....................    MACPutArray((BYTE*)&wVal, sizeof(WORD)); 
02CDC:  MOVLW  02
02CDE:  MOVLB  2
02CE0:  MOVWF  x9D
02CE2:  MOVLW  74
02CE4:  MOVWF  x9C
02CE6:  MOVFF  29D,2C1
02CEA:  MOVWF  xC0
02CEC:  CLRF   xC3
02CEE:  MOVLW  02
02CF0:  MOVWF  xC2
02CF2:  MOVLB  0
02CF4:  CALL   0E2A
....................  
....................    // Physically start the packet transmission over the network 
....................    MACFlush(); 
02CF8:  CALL   246E
02CFC:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static BOOL FindMatchingTCPSocket(TCP_HEADER* h, NODE_INFO* remote) 
....................  
....................   Summary: 
....................    Finds a suitable socket for a TCP segment. 
....................  
....................   Description: 
....................    This function searches through the sockets and attempts to match one with 
....................    a given TCP header and NODE_INFO structure.  If a socket is found, its  
....................    index is saved in hCurrentTCP and the associated MyTCBStub and MyTCB are 
....................    loaded. Otherwise, INVALID_SOCKET is placed in hCurrentTCP. 
....................     
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    h - TCP header to be matched against 
....................    remote - The remote node who sent this header 
....................  
....................   Return Values: 
....................    TRUE - A match was found and is loaded in hCurrentTCP 
....................    FALSE - No suitable socket was found and hCurrentTCP is INVALID_SOCKET 
....................   ***************************************************************************/ 
.................... static BOOL FindMatchingTCPSocket(TCP_HEADER* h, NODE_INFO* remote) 
.................... { 
....................    TCP_SOCKET hTCP; 
....................    TCP_SOCKET partialMatch; 
....................    WORD hash; 
....................  
....................    // Prevent connections on invalid port 0 
....................    if(h->DestPort == 0u) 
*
03FF4:  MOVLW  02
03FF6:  MOVLB  1
03FF8:  ADDWF  x9F,W
03FFA:  MOVWF  FE9
03FFC:  MOVLW  00
03FFE:  ADDWFC xA0,W
04000:  MOVWF  FEA
04002:  MOVFF  FEC,1AA
04006:  MOVF   FED,F
04008:  MOVFF  FEF,1A9
0400C:  MOVF   xA9,F
0400E:  BNZ   401A
04010:  MOVF   xAA,F
04012:  BNZ   401A
....................       return FALSE; 
04014:  MOVLW  00
04016:  MOVWF  01
04018:  BRA    45FA
....................  
....................    partialMatch = INVALID_SOCKET; 
0401A:  MOVLW  FE
0401C:  MOVWF  xA4
....................    hash = (remote->IPAddr.w[1]+remote->IPAddr.w[0] + h->SourcePort) ^ h->DestPort; 
0401E:  MOVLW  02
04020:  ADDWF  xA1,W
04022:  MOVWF  FE9
04024:  MOVLW  00
04026:  ADDWFC xA2,W
04028:  MOVWF  FEA
0402A:  MOVFF  FEC,1AA
0402E:  MOVF   FED,F
04030:  MOVFF  FEF,1A9
04034:  MOVFF  1A1,FE9
04038:  MOVFF  1A2,FEA
0403C:  MOVFF  FEC,03
04040:  MOVF   FED,F
04042:  MOVF   FEF,W
04044:  ADDWF  xA9,F
04046:  MOVF   03,W
04048:  ADDWFC xAA,F
0404A:  MOVFF  19F,FE9
0404E:  MOVFF  1A0,FEA
04052:  MOVFF  FEC,03
04056:  MOVF   FED,F
04058:  MOVF   FEF,W
0405A:  ADDWF  xA9,F
0405C:  MOVF   03,W
0405E:  ADDWFC xAA,F
04060:  MOVLW  02
04062:  ADDWF  x9F,W
04064:  MOVWF  FE9
04066:  MOVLW  00
04068:  ADDWFC xA0,W
0406A:  MOVWF  FEA
0406C:  MOVFF  FEC,03
04070:  MOVF   FED,F
04072:  MOVF   FEF,W
04074:  XORWF  xA9,W
04076:  MOVWF  xA5
04078:  MOVF   03,W
0407A:  XORWF  xAA,W
0407C:  MOVWF  xA6
....................  
....................    // Loop through all sockets looking for a socket that is expecting this  
....................    // packet or can handle it. 
....................    for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++ ) 
0407E:  CLRF   xA3
04080:  MOVF   xA3,F
04082:  BTFSS  FD8.2
04084:  BRA    4178
....................    { 
....................       SyncTCBStub(hTCP); 
04086:  MOVFF  1A3,273
0408A:  MOVLB  0
0408C:  CALL   0D1A
....................  
....................       if(MyTCBStub.smState == TCP_CLOSED) 
04090:  MOVLB  1
04092:  MOVF   x2E,W
04094:  SUBLW  0D
04096:  BNZ   409C
....................       { 
....................          continue; 
04098:  BRA    4174
....................       } 
0409A:  BRA    40D6
....................       else if(MyTCBStub.smState == TCP_LISTEN) 
0409C:  MOVF   x2E,W
0409E:  SUBLW  04
040A0:  BNZ   40C8
....................       {// For listening ports, check if this is the correct port 
....................          if(MyTCBStub.remoteHash.Val == h->DestPort) 
040A2:  MOVLW  02
040A4:  ADDWF  x9F,W
040A6:  MOVWF  FE9
040A8:  MOVLW  00
040AA:  ADDWFC xA0,W
040AC:  MOVWF  FEA
040AE:  MOVFF  FEC,03
040B2:  MOVF   FED,F
040B4:  MOVF   FEF,W
040B6:  SUBWF  x31,W
040B8:  BNZ   40C4
040BA:  MOVF   03,W
040BC:  SUBWF  x32,W
040BE:  BNZ   40C4
....................             partialMatch = hTCP; 
040C0:  MOVFF  1A3,1A4
....................           
....................          #if defined(STACK_USE_SSL_SERVER) 
....................          // Check the SSL port as well for SSL Servers 
....................          // 0 is defined as an invalid port number 
....................          if(MyTCBStub.sslTxHead == h->DestPort) 
....................             partialMatch = hTCP; 
....................          #endif 
....................           
....................          continue; 
040C4:  BRA    4174
....................       } 
040C6:  BRA    40D6
....................       else if(MyTCBStub.remoteHash.Val != hash) 
040C8:  MOVF   xA5,W
040CA:  SUBWF  x31,W
040CC:  BNZ   40D4
040CE:  MOVF   xA6,W
040D0:  SUBWF  x32,W
040D2:  BZ    40D6
....................       {// Ignore if the hash doesn't match 
....................          continue; 
040D4:  BRA    4174
....................       } 
....................  
....................       SyncTCB(); 
040D6:  MOVLB  0
040D8:  CALL   130A
....................       if(   h->DestPort == MyTCB.localPort.Val && 
....................          h->SourcePort == MyTCB.remotePort.Val && 
....................          remote->IPAddr.Val == MyTCB.remote.niRemoteMACIP.IPAddr.Val) 
040DC:  MOVLW  02
040DE:  MOVLB  1
040E0:  ADDWF  x9F,W
040E2:  MOVWF  FE9
040E4:  MOVLW  00
040E6:  ADDWFC xA0,W
040E8:  MOVWF  FEA
040EA:  MOVFF  FEC,1AA
040EE:  MOVF   FED,F
040F0:  MOVFF  FEF,1A9
040F4:  MOVLB  0
040F6:  MOVF   xC4,W
040F8:  MOVLB  1
040FA:  SUBWF  xA9,W
040FC:  BNZ   4174
040FE:  MOVLB  0
04100:  MOVF   xC5,W
04102:  MOVLB  1
04104:  SUBWF  xAA,W
04106:  BNZ   4174
04108:  MOVFF  19F,FE9
0410C:  MOVFF  1A0,FEA
04110:  MOVFF  FEC,1AA
04114:  MOVF   FED,F
04116:  MOVFF  FEF,1A9
0411A:  MOVLB  0
0411C:  MOVF   xC2,W
0411E:  MOVLB  1
04120:  SUBWF  xA9,W
04122:  BNZ   4174
04124:  MOVLB  0
04126:  MOVF   xC3,W
04128:  MOVLB  1
0412A:  SUBWF  xAA,W
0412C:  BNZ   4174
0412E:  MOVFF  1A1,FE9
04132:  MOVFF  1A2,FEA
04136:  MOVFF  FEF,1A9
0413A:  MOVFF  FEC,1AA
0413E:  MOVFF  FEC,1AB
04142:  MOVFF  FEC,1AC
04146:  MOVLB  0
04148:  MOVF   xCA,W
0414A:  MOVLB  1
0414C:  SUBWF  xA9,W
0414E:  BNZ   4174
04150:  MOVLB  0
04152:  MOVF   xCB,W
04154:  MOVLB  1
04156:  SUBWF  xAA,W
04158:  BNZ   4174
0415A:  MOVLB  0
0415C:  MOVF   xCC,W
0415E:  MOVLB  1
04160:  SUBWF  xAB,W
04162:  BNZ   4174
04164:  MOVLB  0
04166:  MOVF   xCD,W
04168:  MOVLB  1
0416A:  SUBWF  xAC,W
0416C:  BNZ   4174
....................       { 
....................          return TRUE; 
0416E:  MOVLW  01
04170:  MOVWF  01
04172:  BRA    45FA
....................       } 
04174:  INCF   xA3,F
04176:  BRA    4080
....................    } 
....................  
....................  
....................    // If there is a partial match, then a listening socket is currently  
....................    // available.  Set up the extended TCB with the info needed  
....................    // to establish a connection and return this socket to the  
....................    // caller. 
....................    if(partialMatch != INVALID_SOCKET) 
04178:  MOVF   xA4,W
0417A:  SUBLW  FE
0417C:  BZ    41F0
....................    { 
....................       SyncTCBStub(partialMatch); 
0417E:  MOVFF  1A4,273
04182:  MOVLB  0
04184:  CALL   0D1A
....................       SyncTCB(); 
04188:  CALL   130A
....................     
....................       // For SSL ports, begin the SSL Handshake 
....................       #if defined(STACK_USE_SSL_SERVER) 
....................       if(MyTCBStub.sslTxHead == h->DestPort) 
....................       { 
....................          // Try to start an SSL session.  If no stubs are available, 
....................          // we can't service this request right now, so ignore it. 
....................          if(!TCPStartSSLServer(partialMatch)) 
....................             partialMatch = INVALID_SOCKET; 
....................       } 
....................       #endif 
....................     
....................       // Make sure the above check didn't fail (this is unfortunately  
....................       // redundant for non-SSL sockets).  Otherwise, fall out to below 
....................       // and add to the SYN queue. 
....................       if(partialMatch != INVALID_SOCKET) 
0418C:  MOVLB  1
0418E:  MOVF   xA4,W
04190:  SUBLW  FE
04192:  BZ    41F0
....................       { 
....................          MyTCBStub.remoteHash.Val = hash; 
04194:  MOVFF  1A6,132
04198:  MOVFF  1A5,131
....................        
....................          memcpy((void*)&MyTCB.remote, (void*)remote, sizeof(NODE_INFO)); 
0419C:  CLRF   xAA
0419E:  MOVLW  CA
041A0:  MOVFF  1AA,FEA
041A4:  MOVWF  FE9
041A6:  MOVFF  1A2,FE2
041AA:  MOVFF  1A1,FE1
041AE:  MOVLW  0A
041B0:  MOVWF  01
041B2:  MOVFF  FE6,FEE
041B6:  DECFSZ 01,F
041B8:  BRA    41B2
....................          MyTCB.remotePort.Val = h->SourcePort; 
041BA:  MOVFF  19F,FE9
041BE:  MOVFF  1A0,FEA
041C2:  MOVFF  FEC,C3
041C6:  MOVF   FED,F
041C8:  MOVFF  FEF,C2
....................          MyTCB.localPort.Val = h->DestPort; 
041CC:  MOVLW  02
041CE:  ADDWF  x9F,W
041D0:  MOVWF  FE9
041D2:  MOVLW  00
041D4:  ADDWFC xA0,W
041D6:  MOVWF  FEA
041D8:  MOVFF  FEC,C5
041DC:  MOVF   FED,F
041DE:  MOVFF  FEF,C4
....................          MyTCB.txUnackedTail   = MyTCBStub.bufferTxStart; 
041E2:  MOVFF  119,C1
041E6:  MOVFF  118,C0
....................        
....................          // All done, and we have a match 
....................          return TRUE; 
041EA:  MOVLW  01
041EC:  MOVWF  01
041EE:  BRA    45FA
....................       } 
....................    } 
....................  
....................    // No available sockets are listening on this port.  (Or, for 
....................    // SSL requests, perhaps no SSL sessions were available.  However, 
....................    // there may be a server socket which is currently busy but  
....................    // could handle this packet, so we should check. 
....................    #if TCP_SYN_QUEUE_MAX_ENTRIES 
....................    { 
....................       WORD wQueueInsertPos; 
....................        
....................       // See if this is a SYN packet 
....................       if(!h->Flags.bits.flagSYN) 
041F0:  MOVLW  0D
041F2:  ADDWF  x9F,W
041F4:  MOVWF  FE9
041F6:  MOVLW  00
041F8:  ADDWFC xA0,W
041FA:  MOVWF  FEA
041FC:  BTFSC  FEF.1
041FE:  BRA    4206
....................          return FALSE; 
04200:  MOVLW  00
04202:  MOVWF  01
04204:  BRA    45FA
....................  
....................       // See if there is space in our SYN queue 
....................       if(SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort) 
04206:  MOVF   x14,W
04208:  IORWF  x15,W
0420A:  BZ    4212
....................          return FALSE; 
0420C:  MOVLW  00
0420E:  MOVWF  01
04210:  BRA    45FA
....................        
....................       // See if we have this SYN already in our SYN queue. 
....................       // If not already in the queue, find out where we  
....................       // should insert this SYN to the queue 
....................       for(wQueueInsertPos = 0; wQueueInsertPos < TCP_SYN_QUEUE_MAX_ENTRIES; wQueueInsertPos++) 
04212:  CLRF   xA8
04214:  CLRF   xA7
04216:  MOVF   xA8,F
04218:  BTFSS  FD8.2
0421A:  BRA    43E8
0421C:  MOVF   xA7,W
0421E:  SUBLW  02
04220:  BTFSS  FD8.0
04222:  BRA    43E8
....................       { 
....................          // Exit loop if we found a free record 
....................          if(SYNQueue[wQueueInsertPos].wDestPort == 0u) 
04224:  MOVFF  1A8,1AA
04228:  MOVFF  1A7,1A9
0422C:  CLRF   xAC
0422E:  MOVLW  14
04230:  MOVWF  xAB
04232:  MOVLB  0
04234:  CALL   1AA0
04238:  MOVFF  01,1A9
0423C:  MOVLW  10
0423E:  MOVLB  1
04240:  ADDWF  01,W
04242:  MOVWF  01
04244:  MOVLW  00
04246:  ADDWFC 02,W
04248:  MOVWF  03
0424A:  MOVF   01,W
0424C:  ADDLW  DC
0424E:  MOVWF  FE9
04250:  MOVLW  00
04252:  ADDWFC 03,W
04254:  MOVWF  FEA
04256:  MOVFF  FEC,1AA
0425A:  MOVF   FED,F
0425C:  MOVFF  FEF,1A9
04260:  MOVF   xA9,F
04262:  BNZ   426A
04264:  MOVF   xAA,F
04266:  BNZ   426A
....................             break; 
04268:  BRA    43E8
....................  
....................          // Check if this SYN packet is already in the SYN queue 
....................          if(SYNQueue[wQueueInsertPos].wDestPort != h->DestPort) 
0426A:  MOVFF  1A8,1AA
0426E:  MOVFF  1A7,1A9
04272:  CLRF   xAC
04274:  MOVLW  14
04276:  MOVWF  xAB
04278:  MOVLB  0
0427A:  CALL   1AA0
0427E:  MOVFF  01,1A9
04282:  MOVLW  10
04284:  MOVLB  1
04286:  ADDWF  01,W
04288:  MOVWF  01
0428A:  MOVLW  00
0428C:  ADDWFC 02,W
0428E:  MOVWF  03
04290:  MOVF   01,W
04292:  ADDLW  DC
04294:  MOVWF  FE9
04296:  MOVLW  00
04298:  ADDWFC 03,W
0429A:  MOVWF  FEA
0429C:  MOVFF  FEC,1AA
042A0:  MOVF   FED,F
042A2:  MOVFF  FEF,1A9
042A6:  MOVLW  02
042A8:  ADDWF  x9F,W
042AA:  MOVWF  FE9
042AC:  MOVLW  00
042AE:  ADDWFC xA0,W
042B0:  MOVWF  FEA
042B2:  MOVFF  FEC,03
042B6:  MOVF   FED,F
042B8:  MOVF   FEF,W
042BA:  SUBWF  xA9,W
042BC:  BNZ   42C4
042BE:  MOVF   03,W
042C0:  SUBWF  xAA,W
042C2:  BZ    42C6
....................             continue; 
042C4:  BRA    43E0
....................          if(SYNQueue[wQueueInsertPos].wSourcePort != h->SourcePort) 
042C6:  MOVFF  1A8,1AA
042CA:  MOVFF  1A7,1A9
042CE:  CLRF   xAC
042D0:  MOVLW  14
042D2:  MOVWF  xAB
042D4:  MOVLB  0
042D6:  CALL   1AA0
042DA:  MOVFF  01,1A9
042DE:  MOVLW  0A
042E0:  MOVLB  1
042E2:  ADDWF  01,W
042E4:  MOVWF  01
042E6:  MOVLW  00
042E8:  ADDWFC 02,W
042EA:  MOVWF  03
042EC:  MOVF   01,W
042EE:  ADDLW  DC
042F0:  MOVWF  FE9
042F2:  MOVLW  00
042F4:  ADDWFC 03,W
042F6:  MOVWF  FEA
042F8:  MOVFF  FEC,1AA
042FC:  MOVF   FED,F
042FE:  MOVFF  FEF,1A9
04302:  MOVFF  19F,FE9
04306:  MOVFF  1A0,FEA
0430A:  MOVFF  FEC,03
0430E:  MOVF   FED,F
04310:  MOVF   FEF,W
04312:  SUBWF  xA9,W
04314:  BNZ   431C
04316:  MOVF   03,W
04318:  SUBWF  xAA,W
0431A:  BZ    431E
....................             continue; 
0431C:  BRA    43E0
....................          if(SYNQueue[wQueueInsertPos].niSourceAddress.IPAddr.Val != remote->IPAddr.Val) 
0431E:  MOVFF  1A8,1AA
04322:  MOVFF  1A7,1A9
04326:  CLRF   xAC
04328:  MOVLW  14
0432A:  MOVWF  xAB
0432C:  MOVLB  0
0432E:  CALL   1AA0
04332:  MOVFF  02,1AA
04336:  MOVFF  01,1A9
0433A:  MOVLW  DC
0433C:  MOVLB  1
0433E:  ADDWF  01,W
04340:  MOVWF  FE9
04342:  MOVLW  00
04344:  ADDWFC 02,W
04346:  MOVWF  FEA
04348:  MOVFF  FEF,1AB
0434C:  MOVFF  FEC,1AC
04350:  MOVFF  FEC,1AD
04354:  MOVFF  FEC,1AE
04358:  MOVFF  1A1,FE9
0435C:  MOVFF  1A2,FEA
04360:  MOVFF  FEF,00
04364:  MOVFF  FEC,01
04368:  MOVFF  FEC,02
0436C:  MOVFF  FEC,03
04370:  MOVF   00,W
04372:  SUBWF  xAB,W
04374:  BNZ   4388
04376:  MOVF   01,W
04378:  SUBWF  xAC,W
0437A:  BNZ   4388
0437C:  MOVF   02,W
0437E:  SUBWF  xAD,W
04380:  BNZ   4388
04382:  MOVF   03,W
04384:  SUBWF  xAE,W
04386:  BZ    438A
....................             continue; 
04388:  BRA    43E0
....................  
....................          // SYN matches SYN queue entry.  Update timestamp and do nothing. 
....................          SYNQueue[wQueueInsertPos].wTimestamp = TickGetDiv256(); 
0438A:  MOVFF  1A8,1AA
0438E:  MOVFF  1A7,1A9
04392:  CLRF   xAC
04394:  MOVLW  14
04396:  MOVWF  xAB
04398:  MOVLB  0
0439A:  CALL   1AA0
0439E:  MOVFF  01,1A9
043A2:  MOVLW  12
043A4:  MOVLB  1
043A6:  ADDWF  01,W
043A8:  MOVWF  01
043AA:  MOVLW  00
043AC:  ADDWFC 02,W
043AE:  MOVWF  03
043B0:  MOVF   01,W
043B2:  ADDLW  DC
043B4:  MOVWF  01
043B6:  MOVLW  00
043B8:  ADDWFC 03,F
043BA:  MOVFF  01,1A9
043BE:  MOVFF  03,1AA
043C2:  MOVLB  0
043C4:  CALL   1A7C
043C8:  MOVFF  1AA,FEA
043CC:  MOVFF  1A9,FE9
043D0:  MOVFF  00,FEF
043D4:  MOVFF  01,FEC
....................          return FALSE; 
043D8:  MOVLW  00
043DA:  MOVWF  01
043DC:  MOVLB  1
043DE:  BRA    45FA
043E0:  INCF   xA7,F
043E2:  BTFSC  FD8.2
043E4:  INCF   xA8,F
043E6:  BRA    4216
....................       } 
....................        
....................       // Check to see if we have any server sockets which  
....................       // are currently connected, but could handle this SYN  
....................       // request at a later time if the client disconnects. 
....................       for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++) 
043E8:  CLRF   xA3
043EA:  MOVF   xA3,F
043EC:  BTFSS  FD8.2
043EE:  BRA    45F6
....................       { 
....................          SyncTCBStub(hTCP); 
043F0:  MOVFF  1A3,273
043F4:  MOVLB  0
043F6:  CALL   0D1A
....................          if(!MyTCBStub.Flags.bServer) 
043FA:  MOVLB  1
043FC:  BTFSC  x2F.3
043FE:  BRA    4402
....................             continue; 
04400:  BRA    45F2
....................  
....................          SyncTCB(); 
04402:  MOVLB  0
04404:  CALL   130A
....................          #if defined(STACK_USE_SSL_SERVER) 
....................          if((MyTCB.localPort.Val != h->DestPort) && (MyTCB.localSSLPort.Val != h->DestPort)) 
....................          #else 
....................          if(MyTCB.localPort.Val != h->DestPort) 
04408:  MOVLW  02
0440A:  MOVLB  1
0440C:  ADDWF  x9F,W
0440E:  MOVWF  FE9
04410:  MOVLW  00
04412:  ADDWFC xA0,W
04414:  MOVWF  FEA
04416:  MOVFF  FEC,03
0441A:  MOVF   FED,F
0441C:  MOVF   FEF,W
0441E:  MOVLB  0
04420:  SUBWF  xC4,W
04422:  BNZ   442A
04424:  MOVF   03,W
04426:  SUBWF  xC5,W
04428:  BZ    4430
....................          #endif 
....................             continue; 
0442A:  MOVLB  1
0442C:  BRA    45F2
0442E:  MOVLB  0
....................  
....................          // Generate the SYN queue entry 
....................          memcpy((void*)&SYNQueue[wQueueInsertPos].niSourceAddress, (void*)remote, sizeof(NODE_INFO)); 
04430:  MOVFF  1A8,1AA
04434:  MOVFF  1A7,1A9
04438:  MOVLB  1
0443A:  CLRF   xAC
0443C:  MOVLW  14
0443E:  MOVWF  xAB
04440:  MOVLB  0
04442:  CALL   1AA0
04446:  MOVFF  02,1AA
0444A:  MOVFF  01,1A9
0444E:  MOVLW  DC
04450:  MOVLB  1
04452:  ADDWF  01,W
04454:  MOVWF  01
04456:  MOVLW  00
04458:  ADDWFC 02,W
0445A:  MOVWF  03
0445C:  MOVFF  01,1AB
04460:  MOVWF  xAC
04462:  MOVWF  FEA
04464:  MOVFF  01,FE9
04468:  MOVFF  1A2,FE2
0446C:  MOVFF  1A1,FE1
04470:  MOVLW  0A
04472:  MOVWF  01
04474:  MOVFF  FE6,FEE
04478:  DECFSZ 01,F
0447A:  BRA    4474
....................          SYNQueue[wQueueInsertPos].wSourcePort = h->SourcePort; 
0447C:  MOVFF  1A8,1AA
04480:  MOVFF  1A7,1A9
04484:  CLRF   xAC
04486:  MOVLW  14
04488:  MOVWF  xAB
0448A:  MOVLB  0
0448C:  CALL   1AA0
04490:  MOVFF  01,1A9
04494:  MOVLW  0A
04496:  MOVLB  1
04498:  ADDWF  01,W
0449A:  MOVWF  01
0449C:  MOVLW  00
0449E:  ADDWFC 02,W
044A0:  MOVWF  03
044A2:  MOVF   01,W
044A4:  ADDLW  DC
044A6:  MOVWF  01
044A8:  MOVLW  00
044AA:  ADDWFC 03,F
044AC:  MOVFF  03,1AA
044B0:  MOVFF  19F,FE9
044B4:  MOVFF  1A0,FEA
044B8:  MOVFF  FEC,03
044BC:  MOVF   FED,F
044BE:  MOVFF  FEF,1AB
044C2:  MOVFF  1AA,FEA
044C6:  MOVFF  01,FE9
044CA:  MOVFF  03,FEC
044CE:  MOVF   FED,F
044D0:  MOVFF  1AB,FEF
....................          SYNQueue[wQueueInsertPos].dwSourceSEQ = h->SeqNumber; 
044D4:  MOVFF  1A8,1AA
044D8:  MOVFF  1A7,1A9
044DC:  CLRF   xAC
044DE:  MOVLW  14
044E0:  MOVWF  xAB
044E2:  MOVLB  0
044E4:  CALL   1AA0
044E8:  MOVFF  01,1A9
044EC:  MOVLW  0C
044EE:  MOVLB  1
044F0:  ADDWF  01,W
044F2:  MOVWF  01
044F4:  MOVLW  00
044F6:  ADDWFC 02,W
044F8:  MOVWF  03
044FA:  MOVF   01,W
044FC:  ADDLW  DC
044FE:  MOVWF  01
04500:  MOVLW  00
04502:  ADDWFC 03,F
04504:  MOVFF  01,1A9
04508:  MOVFF  03,1AA
0450C:  MOVLW  04
0450E:  ADDWF  x9F,W
04510:  MOVWF  FE9
04512:  MOVLW  00
04514:  ADDWFC xA0,W
04516:  MOVWF  FEA
04518:  MOVFF  FEF,00
0451C:  MOVFF  FEC,01
04520:  MOVFF  FEC,02
04524:  MOVFF  FEC,03
04528:  MOVFF  1AA,FEA
0452C:  MOVFF  1A9,FE9
04530:  MOVFF  00,FEF
04534:  MOVFF  01,FEC
04538:  MOVFF  02,FEC
0453C:  MOVFF  03,FEC
....................          SYNQueue[wQueueInsertPos].wDestPort = h->DestPort; 
04540:  MOVFF  1A8,1AA
04544:  MOVFF  1A7,1A9
04548:  CLRF   xAC
0454A:  MOVLW  14
0454C:  MOVWF  xAB
0454E:  MOVLB  0
04550:  CALL   1AA0
04554:  MOVFF  01,1A9
04558:  MOVLW  10
0455A:  MOVLB  1
0455C:  ADDWF  01,W
0455E:  MOVWF  01
04560:  MOVLW  00
04562:  ADDWFC 02,W
04564:  MOVWF  03
04566:  MOVF   01,W
04568:  ADDLW  DC
0456A:  MOVWF  01
0456C:  MOVLW  00
0456E:  ADDWFC 03,F
04570:  MOVFF  03,1AA
04574:  MOVLW  02
04576:  ADDWF  x9F,W
04578:  MOVWF  FE9
0457A:  MOVLW  00
0457C:  ADDWFC xA0,W
0457E:  MOVWF  FEA
04580:  MOVFF  FEC,03
04584:  MOVF   FED,F
04586:  MOVFF  FEF,1AB
0458A:  MOVFF  1AA,FEA
0458E:  MOVFF  01,FE9
04592:  MOVFF  03,FEC
04596:  MOVF   FED,F
04598:  MOVFF  1AB,FEF
....................          SYNQueue[wQueueInsertPos].wTimestamp = TickGetDiv256(); 
0459C:  MOVFF  1A8,1AA
045A0:  MOVFF  1A7,1A9
045A4:  CLRF   xAC
045A6:  MOVLW  14
045A8:  MOVWF  xAB
045AA:  MOVLB  0
045AC:  CALL   1AA0
045B0:  MOVFF  01,1A9
045B4:  MOVLW  12
045B6:  MOVLB  1
045B8:  ADDWF  01,W
045BA:  MOVWF  01
045BC:  MOVLW  00
045BE:  ADDWFC 02,W
045C0:  MOVWF  03
045C2:  MOVF   01,W
045C4:  ADDLW  DC
045C6:  MOVWF  01
045C8:  MOVLW  00
045CA:  ADDWFC 03,F
045CC:  MOVFF  01,1A9
045D0:  MOVFF  03,1AA
045D4:  MOVLB  0
045D6:  CALL   1A7C
045DA:  MOVFF  1AA,FEA
045DE:  MOVFF  1A9,FE9
045E2:  MOVFF  00,FEF
045E6:  MOVFF  01,FEC
....................  
....................          return FALSE; 
045EA:  MOVLW  00
045EC:  MOVWF  01
045EE:  MOVLB  1
045F0:  BRA    45FA
045F2:  INCF   xA3,F
045F4:  BRA    43EA
....................       } 
....................    } 
....................    #endif 
....................        
....................    return FALSE; 
045F6:  MOVLW  00
045F8:  MOVWF  01
045FA:  MOVLB  0
045FC:  GOTO   59A2 (RETURN)
....................  
.................... } 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void SwapTCPHeader(TCP_HEADER* header) 
....................  
....................   Summary: 
....................    Swaps endian-ness of a TCP header. 
....................  
....................   Description: 
....................    This function swaps the endian-ness of a given TCP header for comparison. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    header - The TCP header that is to be swapped 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... static void SwapTCPHeader(TCP_HEADER* header) 
.................... { 
....................    header->SourcePort      = swaps(header->SourcePort); 
*
01D98:  MOVLB  2
01D9A:  MOVFF  29C,01
01D9E:  MOVFF  29D,03
01DA2:  MOVFF  29C,29E
01DA6:  MOVFF  29D,29F
01DAA:  MOVFF  29C,FE9
01DAE:  MOVFF  29D,FEA
01DB2:  MOVFF  FEC,2A1
01DB6:  MOVF   FED,F
01DB8:  MOVFF  FEF,2A0
01DBC:  MOVFF  2A1,2BC
01DC0:  MOVFF  2A0,2BB
01DC4:  MOVLB  0
01DC6:  RCALL  1C00
01DC8:  MOVFF  29F,FEA
01DCC:  MOVFF  29E,FE9
01DD0:  MOVFF  02,FEC
01DD4:  MOVF   FED,F
01DD6:  MOVFF  01,FEF
....................    header->DestPort        = swaps(header->DestPort); 
01DDA:  MOVLW  02
01DDC:  MOVLB  2
01DDE:  ADDWF  x9C,W
01DE0:  MOVWF  01
01DE2:  MOVLW  00
01DE4:  ADDWFC x9D,W
01DE6:  MOVWF  03
01DE8:  MOVFF  01,29E
01DEC:  MOVWF  x9F
01DEE:  MOVLW  02
01DF0:  ADDWF  x9C,W
01DF2:  MOVWF  FE9
01DF4:  MOVLW  00
01DF6:  ADDWFC x9D,W
01DF8:  MOVWF  FEA
01DFA:  MOVFF  FEC,2A1
01DFE:  MOVF   FED,F
01E00:  MOVFF  FEF,2A0
01E04:  MOVFF  2A1,2BC
01E08:  MOVFF  2A0,2BB
01E0C:  MOVLB  0
01E0E:  RCALL  1C00
01E10:  MOVFF  29F,FEA
01E14:  MOVFF  29E,FE9
01E18:  MOVFF  02,FEC
01E1C:  MOVF   FED,F
01E1E:  MOVFF  01,FEF
....................    header->SeqNumber       = swapl(header->SeqNumber); 
01E22:  MOVLW  04
01E24:  MOVLB  2
01E26:  ADDWF  x9C,W
01E28:  MOVWF  01
01E2A:  MOVLW  00
01E2C:  ADDWFC x9D,W
01E2E:  MOVWF  03
01E30:  MOVFF  01,29E
01E34:  MOVWF  x9F
01E36:  MOVLW  04
01E38:  ADDWF  x9C,W
01E3A:  MOVWF  FE9
01E3C:  MOVLW  00
01E3E:  ADDWFC x9D,W
01E40:  MOVWF  FEA
01E42:  MOVFF  FEF,2A0
01E46:  MOVFF  FEC,2A1
01E4A:  MOVFF  FEC,2A2
01E4E:  MOVFF  FEC,2A3
01E52:  MOVFF  2A3,2A7
01E56:  MOVFF  2A2,2A6
01E5A:  MOVFF  2A1,2A5
01E5E:  MOVFF  2A0,2A4
01E62:  MOVLB  0
01E64:  RCALL  1C22
01E66:  MOVFF  29F,FEA
01E6A:  MOVFF  29E,FE9
01E6E:  MOVFF  00,FEF
01E72:  MOVFF  01,FEC
01E76:  MOVFF  02,FEC
01E7A:  MOVFF  03,FEC
....................    header->AckNumber       = swapl(header->AckNumber); 
01E7E:  MOVLW  08
01E80:  MOVLB  2
01E82:  ADDWF  x9C,W
01E84:  MOVWF  01
01E86:  MOVLW  00
01E88:  ADDWFC x9D,W
01E8A:  MOVWF  03
01E8C:  MOVFF  01,29E
01E90:  MOVWF  x9F
01E92:  MOVLW  08
01E94:  ADDWF  x9C,W
01E96:  MOVWF  FE9
01E98:  MOVLW  00
01E9A:  ADDWFC x9D,W
01E9C:  MOVWF  FEA
01E9E:  MOVFF  FEF,2A0
01EA2:  MOVFF  FEC,2A1
01EA6:  MOVFF  FEC,2A2
01EAA:  MOVFF  FEC,2A3
01EAE:  MOVFF  2A3,2A7
01EB2:  MOVFF  2A2,2A6
01EB6:  MOVFF  2A1,2A5
01EBA:  MOVFF  2A0,2A4
01EBE:  MOVLB  0
01EC0:  RCALL  1C22
01EC2:  MOVFF  29F,FEA
01EC6:  MOVFF  29E,FE9
01ECA:  MOVFF  00,FEF
01ECE:  MOVFF  01,FEC
01ED2:  MOVFF  02,FEC
01ED6:  MOVFF  03,FEC
....................    header->Window          = swaps(header->Window); 
01EDA:  MOVLW  0E
01EDC:  MOVLB  2
01EDE:  ADDWF  x9C,W
01EE0:  MOVWF  01
01EE2:  MOVLW  00
01EE4:  ADDWFC x9D,W
01EE6:  MOVWF  03
01EE8:  MOVFF  01,29E
01EEC:  MOVWF  x9F
01EEE:  MOVLW  0E
01EF0:  ADDWF  x9C,W
01EF2:  MOVWF  FE9
01EF4:  MOVLW  00
01EF6:  ADDWFC x9D,W
01EF8:  MOVWF  FEA
01EFA:  MOVFF  FEC,2A1
01EFE:  MOVF   FED,F
01F00:  MOVFF  FEF,2A0
01F04:  MOVFF  2A1,2BC
01F08:  MOVFF  2A0,2BB
01F0C:  MOVLB  0
01F0E:  RCALL  1C00
01F10:  MOVFF  29F,FEA
01F14:  MOVFF  29E,FE9
01F18:  MOVFF  02,FEC
01F1C:  MOVF   FED,F
01F1E:  MOVFF  01,FEF
....................    header->Checksum        = swaps(header->Checksum); 
01F22:  MOVLW  10
01F24:  MOVLB  2
01F26:  ADDWF  x9C,W
01F28:  MOVWF  01
01F2A:  MOVLW  00
01F2C:  ADDWFC x9D,W
01F2E:  MOVWF  03
01F30:  MOVFF  01,29E
01F34:  MOVWF  x9F
01F36:  MOVLW  10
01F38:  ADDWF  x9C,W
01F3A:  MOVWF  FE9
01F3C:  MOVLW  00
01F3E:  ADDWFC x9D,W
01F40:  MOVWF  FEA
01F42:  MOVFF  FEC,2A1
01F46:  MOVF   FED,F
01F48:  MOVFF  FEF,2A0
01F4C:  MOVFF  2A1,2BC
01F50:  MOVFF  2A0,2BB
01F54:  MOVLB  0
01F56:  RCALL  1C00
01F58:  MOVFF  29F,FEA
01F5C:  MOVFF  29E,FE9
01F60:  MOVFF  02,FEC
01F64:  MOVF   FED,F
01F66:  MOVFF  01,FEF
....................    header->UrgentPointer   = swaps(header->UrgentPointer); 
01F6A:  MOVLW  12
01F6C:  MOVLB  2
01F6E:  ADDWF  x9C,W
01F70:  MOVWF  01
01F72:  MOVLW  00
01F74:  ADDWFC x9D,W
01F76:  MOVWF  03
01F78:  MOVFF  01,29E
01F7C:  MOVWF  x9F
01F7E:  MOVLW  12
01F80:  ADDWF  x9C,W
01F82:  MOVWF  FE9
01F84:  MOVLW  00
01F86:  ADDWFC x9D,W
01F88:  MOVWF  FEA
01F8A:  MOVFF  FEC,2A1
01F8E:  MOVF   FED,F
01F90:  MOVFF  FEF,2A0
01F94:  MOVFF  2A1,2BC
01F98:  MOVFF  2A0,2BB
01F9C:  MOVLB  0
01F9E:  RCALL  1C00
01FA0:  MOVFF  29F,FEA
01FA4:  MOVFF  29E,FE9
01FA8:  MOVFF  02,FEC
01FAC:  MOVF   FED,F
01FAE:  MOVFF  01,FEF
01FB2:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void CloseSocket(void) 
....................  
....................   Summary: 
....................    Closes a TCP socket. 
....................  
....................   Description: 
....................    This function closes a TCP socket.  All socket state information is  
....................    reset, and any buffered bytes are discarded.  The socket is no longer 
....................    accessible by the application after this point. 
....................  
....................   Precondition: 
....................    The TCPStub corresponding to the socket to be closed is synced. 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... static void CloseSocket(void) 
.................... { 
....................    SyncTCB(); 
*
013DE:  RCALL  130A
....................  
....................    MyTCBStub.remoteHash.Val = MyTCB.localPort.Val; 
013E0:  MOVFF  C5,132
013E4:  MOVFF  C4,131
....................    MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
013E8:  MOVFF  119,11F
013EC:  MOVFF  118,11E
....................    MyTCBStub.txTail = MyTCBStub.bufferTxStart; 
013F0:  MOVFF  119,121
013F4:  MOVFF  118,120
....................    MyTCBStub.rxHead = MyTCBStub.bufferRxStart; 
013F8:  MOVFF  11B,123
013FC:  MOVFF  11A,122
....................    MyTCBStub.rxTail = MyTCBStub.bufferRxStart; 
01400:  MOVFF  11B,125
01404:  MOVFF  11A,124
....................    MyTCBStub.smState = MyTCBStub.Flags.bServer ? TCP_LISTEN : TCP_CLOSED; 
01408:  MOVLB  1
0140A:  BTFSS  x2F.3
0140C:  BRA    1412
0140E:  MOVLW  04
01410:  BRA    1414
01412:  MOVLW  0D
01414:  MOVWF  x2E
....................    MyTCBStub.Flags.vUnackedKeepalives = 0; 
01416:  MOVLW  F8
01418:  ANDWF  x2F,W
0141A:  MOVWF  x2F
....................    MyTCBStub.Flags.bTimerEnabled = 0; 
0141C:  BCF    x2F.4
....................    MyTCBStub.Flags.bTimer2Enabled = 0; 
0141E:  BCF    x2F.5
....................    MyTCBStub.Flags.bDelayedACKTimerEnabled = 0; 
01420:  BCF    x2F.6
....................    MyTCBStub.Flags.bOneSegmentReceived = 0; 
01422:  BCF    x2F.7
....................    MyTCBStub.Flags.bHalfFullFlush = 0; 
01424:  BCF    x30.0
....................    MyTCBStub.Flags.bTXASAP = 0; 
01426:  BCF    x30.1
....................    MyTCBStub.Flags.bTXASAPWithoutTimerReset = 0; 
01428:  BCF    x30.2
....................    MyTCBStub.Flags.bTXFIN = 0; 
0142A:  BCF    x30.3
....................    MyTCBStub.Flags.bSocketReset = 1; 
0142C:  BSF    x30.4
....................  
....................    #if defined(STACK_USE_SSL) 
....................    // If SSL is active, then we need to close it 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    { 
....................       SSLTerminate(MyTCBStub.sslStubID); 
....................       MyTCBStub.sslStubID = SSL_INVALID_ID; 
....................  
....................       // Swap the SSL port and local port back to proper values 
....................       MyTCBStub.remoteHash.Val = MyTCB.localSSLPort.Val; 
....................       MyTCB.localSSLPort.Val = MyTCB.localPort.Val; 
....................       MyTCB.localPort.Val = MyTCBStub.remoteHash.Val; 
....................    } 
....................  
....................    // Reset the SSL buffer pointers 
....................    MyTCBStub.sslRxHead = MyTCBStub.bufferRxStart; 
....................    MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    #endif 
....................     
....................    #if defined(STACK_USE_SSL_SERVER) 
....................    MyTCBStub.sslTxHead = MyTCB.localSSLPort.Val; 
....................    #endif 
....................  
....................    MyTCB.flags.bFINSent = 0; 
0142E:  MOVLB  0
01430:  BCF    xD6.0
....................    MyTCB.flags.bSYNSent = 0; 
01432:  BCF    xD6.1
....................    MyTCB.flags.bRXNoneACKed1 = 0; 
01434:  BCF    xD6.3
....................    MyTCB.flags.bRXNoneACKed2 = 0; 
01436:  BCF    xD6.4
....................    MyTCB.txUnackedTail = MyTCBStub.bufferTxStart; 
01438:  MOVFF  119,C1
0143C:  MOVFF  118,C0
....................    ((DWORD_VAL*)(&MyTCB.MySEQ))->w[0] = LFSRRand(); 
01440:  MOVLB  2
01442:  CLRF   x6A
01444:  MOVLW  B8
01446:  MOVWF  x69
01448:  MOVWF  01
0144A:  MOVFF  26A,03
0144E:  MOVWF  x6B
01450:  MOVFF  26A,26C
01454:  MOVLB  0
01456:  CALL   0698
0145A:  MOVFF  26C,FEA
0145E:  MOVFF  26B,FE9
01462:  MOVFF  02,FEC
01466:  MOVF   FED,F
01468:  MOVFF  01,FEF
....................    ((DWORD_VAL*)(&MyTCB.MySEQ))->w[1] = LFSRRand(); 
0146C:  MOVLB  2
0146E:  CLRF   x6A
01470:  MOVLW  B8
01472:  MOVWF  x69
01474:  MOVLW  02
01476:  ADDWF  x69,W
01478:  MOVWF  01
0147A:  MOVLW  00
0147C:  ADDWFC x6A,W
0147E:  MOVWF  03
01480:  MOVFF  01,26B
01484:  MOVWF  x6C
01486:  MOVLB  0
01488:  CALL   0698
0148C:  MOVFF  26C,FEA
01490:  MOVFF  26B,FE9
01494:  MOVFF  02,FEC
01498:  MOVF   FED,F
0149A:  MOVFF  01,FEF
....................    MyTCB.sHoleSize = -1; 
0149E:  SETF   xD5
014A0:  SETF   xD4
....................    MyTCB.remoteWindow = 1; 
014A2:  CLRF   xC7
014A4:  MOVLW  01
014A6:  MOVWF  xC6
014A8:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static WORD GetMaxSegSizeOption(void) 
....................  
....................   Summary: 
....................    Obtains the Maximum Segment Size (MSS) TCP Option out of the TCP header  
....................    for the current socket. 
....................  
....................   Description: 
....................    Parses the current TCP packet header and extracts the Maximum Segment Size  
....................    option.   
....................  
....................   Precondition: 
....................    Must be called while a TCP packet is present and being processed via  
....................    HandleTCPSeg() and only if the the TCP SYN flag is set. 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................    Maximum segment size option value.  If illegal or not present, a failsafe  
....................    value of 536 is returned.  If the option is larger than the  
....................    TCP_MAX_SEG_SIZE_TX upper limit, then TCP_MAX_SEG_SIZE_TX is returned. 
....................  
....................   Remarks: 
....................    The internal MAC Read Pointer is moved but not restored. 
....................   ***************************************************************************/ 
.................... static WORD GetMaxSegSizeOption(void) 
.................... { 
....................    BYTE vOptionsBytes; 
....................    BYTE vOption; 
....................    WORD wMSS; 
....................  
....................    // Find out how many options bytes are in this packet. 
....................    IPSetRxBuffer(2+2+4+4);   // Seek to data offset field, skipping Source port (2), Destination port (2), Sequence number (4), and Acknowledgement number (4) 
*
04600:  MOVLB  1
04602:  CLRF   xC4
04604:  MOVLW  0C
04606:  MOVWF  xC3
04608:  MOVLB  0
0460A:  RCALL  3FDA
....................    vOptionsBytes = MACGet(); 
0460C:  CALL   0F52
04610:  MOVFF  01,1BF
....................    vOptionsBytes = ((vOptionsBytes&0xF0)>>2) - sizeof(TCP_HEADER); 
04614:  MOVLB  1
04616:  MOVF   xBF,W
04618:  ANDLW  F0
0461A:  MOVWF  00
0461C:  RRCF   00,F
0461E:  RRCF   00,F
04620:  MOVLW  3F
04622:  ANDWF  00,F
04624:  MOVF   00,W
04626:  ADDLW  EC
04628:  MOVWF  xBF
....................  
....................    // Return minimum Maximum Segment Size value of 536 bytes if none are  
....................    // present 
....................    if(vOptionsBytes == 0u) 
0462A:  MOVF   xBF,F
0462C:  BNZ   4638
....................       return 536; 
0462E:  MOVLW  18
04630:  MOVWF  01
04632:  MOVLW  02
04634:  MOVWF  02
04636:  BRA    471C
....................        
....................    // Seek to beginning of options 
....................    MACGetArray(NULL, 7); 
04638:  MOVLB  2
0463A:  CLRF   xBF
0463C:  CLRF   xBE
0463E:  CLRF   xC1
04640:  MOVLW  07
04642:  MOVWF  xC0
04644:  MOVLB  0
04646:  CALL   0EDC
....................  
....................    // Search for the Maximum Segment Size option    
....................    while(vOptionsBytes--) 
0464A:  MOVLB  1
0464C:  MOVF   xBF,W
0464E:  DECF   xBF,F
04650:  XORLW  00
04652:  BTFSC  FD8.2
04654:  BRA    4714
....................    { 
....................       vOption = MACGet(); 
04656:  MOVLB  0
04658:  CALL   0F52
0465C:  MOVFF  01,1C0
....................        
....................       if(vOption == 0u)   // End of Options list 
04660:  MOVLB  1
04662:  MOVF   xC0,F
04664:  BNZ   4668
....................          break; 
04666:  BRA    4714
....................        
....................       if(vOption == 1u)   // NOP option 
04668:  DECFSZ xC0,W
0466A:  BRA    466E
....................          continue; 
0466C:  BRA    464C
....................           
....................       if(vOption == 2u)   // Maximum Segment Size option 
0466E:  MOVF   xC0,W
04670:  SUBLW  02
04672:  BNZ   46DE
....................       { 
....................          if(vOptionsBytes < 3u) 
04674:  MOVF   xBF,W
04676:  SUBLW  02
04678:  BNC   467C
....................             break; 
0467A:  BRA    4714
....................  
....................          wMSS = 0; 
0467C:  CLRF   xC2
0467E:  CLRF   xC1
....................              
....................          // Get option length 
....................          vOption = MACGet(); 
04680:  MOVLB  0
04682:  CALL   0F52
04686:  MOVFF  01,1C0
....................          if(vOption == 4u) 
0468A:  MOVLB  1
0468C:  MOVF   xC0,W
0468E:  SUBLW  04
04690:  BNZ   46A6
....................          {// Retrieve MSS and swap value to little endian 
....................             ((BYTE*)&wMSS)[1] = MACGet(); 
04692:  MOVLB  0
04694:  CALL   0F52
04698:  MOVFF  01,1C2
....................             ((BYTE*)&wMSS)[0] = MACGet(); 
0469C:  CALL   0F52
046A0:  MOVFF  01,1C1
046A4:  MOVLB  1
....................          } 
....................           
....................          if(wMSS < 536u) 
046A6:  MOVF   xC2,W
046A8:  SUBLW  02
046AA:  BNC   46B6
046AC:  BNZ   46B4
046AE:  MOVF   xC1,W
046B0:  SUBLW  17
046B2:  BNC   46B6
....................             break; 
046B4:  BRA    4714
....................          if(wMSS > TCP_MAX_SEG_SIZE_TX) 
046B6:  MOVF   xC2,W
046B8:  SUBLW  04
046BA:  BC    46D2
046BC:  XORLW  FF
046BE:  BNZ   46C6
046C0:  MOVF   xC1,W
046C2:  SUBLW  B4
046C4:  BC    46D2
....................             return TCP_MAX_SEG_SIZE_TX; 
046C6:  MOVLW  B4
046C8:  MOVWF  01
046CA:  MOVLW  05
046CC:  MOVWF  02
046CE:  BRA    471C
046D0:  BRA    46DC
....................          else  
....................             return wMSS; 
046D2:  MOVFF  1C1,01
046D6:  MOVFF  1C2,02
046DA:  BRA    471C
....................       } 
046DC:  BRA    4712
....................       else 
....................       { // Assume this is a multi byte option and throw it way 
....................          if(vOptionsBytes < 2u) 
046DE:  MOVF   xBF,W
046E0:  SUBLW  01
046E2:  BNC   46E6
....................             break; 
046E4:  BRA    4714
....................          vOption = MACGet(); 
046E6:  MOVLB  0
046E8:  CALL   0F52
046EC:  MOVFF  01,1C0
....................          if(vOptionsBytes < vOption) 
046F0:  MOVLB  1
046F2:  MOVF   xC0,W
046F4:  SUBWF  xBF,W
046F6:  BC    46FA
....................             break; 
046F8:  BRA    4714
....................          MACGetArray(NULL, vOption); 
046FA:  MOVLB  2
046FC:  CLRF   xBF
046FE:  CLRF   xBE
04700:  CLRF   xC1
04702:  MOVFF  1C0,2C0
04706:  MOVLB  0
04708:  CALL   0EDC
....................          vOptionsBytes -= vOption; 
0470C:  MOVLB  1
0470E:  MOVF   xC0,W
04710:  SUBWF  xBF,F
....................       } 
04712:  BRA    464C
....................        
....................    } 
....................     
....................    // Did not find MSS option, return worst case default 
....................    return 536; 
04714:  MOVLW  18
04716:  MOVWF  01
04718:  MOVLW  02
0471A:  MOVWF  02
0471C:  MOVLB  0
0471E:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void HandleTCPSeg(TCP_HEADER* h, WORD len) 
....................  
....................   Summary: 
....................    Processes an incoming TCP segment. 
....................  
....................   Description: 
....................    Once an incoming segment has been matched to a socket, this function 
....................    performs the necessary processing with the data.  Depending on the  
....................    segment and the state, this may include copying data to the TCP buffer, 
....................    re-assembling out-of order packets, continuing an initialization or  
....................    closing handshake, or closing the socket altogether. 
....................  
....................   Precondition: 
....................    TCP is initialized and the current TCP stub is already synced. 
....................  
....................   Parameters: 
....................    h - The TCP header for this packet 
....................    len - The total buffer length of this segment 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... static void HandleTCPSeg(TCP_HEADER* h, WORD len) 
.................... { 
....................    DWORD dwTemp; 
....................    PTR_BASE wTemp; 
....................    LONG lMissingBytes; 
....................    WORD wMissingBytes; 
....................    WORD wFreeSpace; 
....................    BYTE localHeaderFlags; 
....................    DWORD localAckNumber; 
....................    DWORD localSeqNumber; 
....................    WORD wSegmentLength; 
....................    BOOL bSegmentAcceptable; 
....................    WORD wNewWindow; 
....................  
....................  
....................    // Cache a few variables in local RAM.   
....................    // PIC18s take a fair amount of code and execution time to  
....................    // dereference pointers frequently. 
....................    localHeaderFlags = h->Flags.byte; 
04720:  MOVLW  0D
04722:  MOVLB  1
04724:  ADDWF  x9F,W
04726:  MOVWF  FE9
04728:  MOVLW  00
0472A:  ADDWFC xA0,W
0472C:  MOVWF  FEA
0472E:  MOVFF  FEF,1B1
....................    localAckNumber = h->AckNumber; 
04732:  MOVLW  08
04734:  ADDWF  x9F,W
04736:  MOVWF  FE9
04738:  MOVLW  00
0473A:  ADDWFC xA0,W
0473C:  MOVWF  FEA
0473E:  MOVFF  FEF,1B2
04742:  MOVFF  FEC,1B3
04746:  MOVFF  FEC,1B4
0474A:  MOVFF  FEC,1B5
....................    localSeqNumber = h->SeqNumber; 
0474E:  MOVLW  04
04750:  ADDWF  x9F,W
04752:  MOVWF  FE9
04754:  MOVLW  00
04756:  ADDWFC xA0,W
04758:  MOVWF  FEA
0475A:  MOVFF  FEF,1B6
0475E:  MOVFF  FEC,1B7
04762:  MOVFF  FEC,1B8
04766:  MOVFF  FEC,1B9
....................  
....................    // We received a packet, reset the keep alive timer and count 
....................    #if defined(TCP_KEEP_ALIVE_TIMEOUT) 
....................       MyTCBStub.Flags.vUnackedKeepalives = 0; 
0476A:  MOVLW  F8
0476C:  ANDWF  x2F,W
0476E:  MOVWF  x2F
....................       if(!MyTCBStub.Flags.bTimerEnabled) 
04770:  BTFSC  x2F.4
04772:  BRA    4794
....................          MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
04774:  MOVLB  0
04776:  CALL   1AC2
0477A:  MOVLW  E6
0477C:  MOVLB  1
0477E:  ADDWF  00,W
04780:  MOVWF  x26
04782:  MOVLW  F5
04784:  ADDWFC 01,W
04786:  MOVWF  x27
04788:  MOVLW  05
0478A:  ADDWFC 02,W
0478C:  MOVWF  x28
0478E:  MOVLW  00
04790:  ADDWFC 03,W
04792:  MOVWF  x29
....................    #endif 
....................  
....................    // Handle TCP_LISTEN and TCP_SYN_SENT states 
....................    // Both of these states will return, so code following this  
....................    // state machine need not check explicitly for these two  
....................    // states. 
....................    switch(MyTCBStub.smState) 
04794:  MOVF   x2E,W
04796:  XORLW  04
04798:  MOVLB  0
0479A:  BZ    47A2
0479C:  XORLW  01
0479E:  BZ    483A
047A0:  BRA    4964
....................    { 
....................       case TCP_LISTEN: 
....................          // First: check RST flag 
....................          if(localHeaderFlags & RST) 
047A2:  MOVLB  1
047A4:  BTFSS  xB1.2
047A6:  BRA    47B4
....................          { 
....................             CloseSocket();   // Unbind remote IP address/port info 
047A8:  MOVLB  0
047AA:  CALL   13DE
....................             return; 
047AE:  GOTO   5846
047B2:  MOVLB  1
....................          } 
....................  
....................          // Second: check ACK flag, which would be invalid 
....................          if(localHeaderFlags & ACK) 
047B4:  BTFSS  xB1.4
047B6:  BRA    47E0
....................          { 
....................             // Use a believable sequence number and reset the remote node 
....................             MyTCB.MySEQ = localAckNumber; 
047B8:  MOVFF  1B5,BB
047BC:  MOVFF  1B4,BA
047C0:  MOVFF  1B3,B9
047C4:  MOVFF  1B2,B8
....................             SendTCP(RST, 0); 
047C8:  MOVLW  04
047CA:  MOVLB  2
047CC:  MOVWF  x72
047CE:  CLRF   x73
047D0:  MOVLB  0
047D2:  CALL   26A2
....................             CloseSocket();   // Unbind remote IP address/port info 
047D6:  CALL   13DE
....................             return; 
047DA:  GOTO   5846
047DE:  MOVLB  1
....................          } 
....................  
....................          // Third: check for SYN flag, which is what we're looking for 
....................          if(localHeaderFlags & SYN) 
047E0:  BTFSS  xB1.1
047E2:  BRA    482C
....................          { 
....................             // We now have a sequence number for the remote node 
....................             MyTCB.RemoteSEQ = localSeqNumber + 1; 
047E4:  MOVLW  01
047E6:  ADDWF  xB6,W
047E8:  MOVLB  0
047EA:  MOVWF  xBC
047EC:  MOVLW  00
047EE:  MOVLB  1
047F0:  ADDWFC xB7,W
047F2:  MOVLB  0
047F4:  MOVWF  xBD
047F6:  MOVLW  00
047F8:  MOVLB  1
047FA:  ADDWFC xB8,W
047FC:  MOVLB  0
047FE:  MOVWF  xBE
04800:  MOVLW  00
04802:  MOVLB  1
04804:  ADDWFC xB9,W
04806:  MOVLB  0
04808:  MOVWF  xBF
....................  
....................             // Get MSS option 
....................             MyTCB.wRemoteMSS = GetMaxSegSizeOption(); 
0480A:  RCALL  4600
0480C:  MOVFF  02,D8
04810:  MOVFF  01,D7
....................  
....................             // Set Initial Send Sequence (ISS) number 
....................             // Nothing to do on this step... ISS already set in CloseSocket() 
....................              
....................             // Respond with SYN + ACK 
....................             SendTCP(SYN | ACK, SENDTCP_RESET_TIMERS); 
04814:  MOVLW  12
04816:  MOVLB  2
04818:  MOVWF  x72
0481A:  MOVLW  01
0481C:  MOVWF  x73
0481E:  MOVLB  0
04820:  CALL   26A2
....................             MyTCBStub.smState = TCP_SYN_RECEIVED; 
04824:  MOVLW  06
04826:  MOVLB  1
04828:  MOVWF  x2E
....................          } 
0482A:  BRA    4834
....................          else 
....................          { 
....................             CloseSocket();   // Unbind remote IP address/port info 
0482C:  MOVLB  0
0482E:  CALL   13DE
04832:  MOVLB  1
....................          } 
....................  
....................          // Fourth: check for other text and control 
....................          // Nothing to do since we don't support this 
....................          return; 
04834:  MOVLB  0
04836:  GOTO   5846
....................  
....................       case TCP_SYN_SENT: 
....................          // Second: check the RST bit 
....................          // This is out of order because this stack has no API for  
....................          // notifying the application that the connection seems to  
....................          // be failing.  Instead, the application must time out and  
....................          // the stack will just keep trying in the mean time. 
....................          if(localHeaderFlags & RST) 
0483A:  MOVLB  1
0483C:  BTFSS  xB1.2
0483E:  BRA    4848
....................             return; 
04840:  MOVLB  0
04842:  GOTO   5846
04846:  MOVLB  1
....................  
....................          // First: check ACK bit 
....................          if(localHeaderFlags & ACK) 
04848:  BTFSS  xB1.4
0484A:  BRA    48BA
....................          { 
....................             if(localAckNumber != MyTCB.MySEQ) 
0484C:  MOVLB  0
0484E:  MOVF   xB8,W
04850:  MOVLB  1
04852:  SUBWF  xB2,W
04854:  BNZ   4874
04856:  MOVLB  0
04858:  MOVF   xB9,W
0485A:  MOVLB  1
0485C:  SUBWF  xB3,W
0485E:  BNZ   4874
04860:  MOVLB  0
04862:  MOVF   xBA,W
04864:  MOVLB  1
04866:  SUBWF  xB4,W
04868:  BNZ   4874
0486A:  MOVLB  0
0486C:  MOVF   xBB,W
0486E:  MOVLB  1
04870:  SUBWF  xB5,W
04872:  BZ    48BA
....................             { 
....................                // Send a RST packet with SEQ = SEG.ACK, but retain our SEQ  
....................                // number for arivial of any other SYN+ACK packets 
....................                localSeqNumber = MyTCB.MySEQ;   // Save our original SEQ number 
04874:  MOVFF  BB,1B9
04878:  MOVFF  BA,1B8
0487C:  MOVFF  B9,1B7
04880:  MOVFF  B8,1B6
....................                MyTCB.MySEQ = localAckNumber;   // Set SEQ = SEG.ACK 
04884:  MOVFF  1B5,BB
04888:  MOVFF  1B4,BA
0488C:  MOVFF  1B3,B9
04890:  MOVFF  1B2,B8
....................                SendTCP(RST, SENDTCP_RESET_TIMERS);      // Send the RST 
04894:  MOVLW  04
04896:  MOVLB  2
04898:  MOVWF  x72
0489A:  MOVLW  01
0489C:  MOVWF  x73
0489E:  MOVLB  0
048A0:  CALL   26A2
....................                MyTCB.MySEQ = localSeqNumber;   // Restore original SEQ number 
048A4:  MOVFF  1B9,BB
048A8:  MOVFF  1B8,BA
048AC:  MOVFF  1B7,B9
048B0:  MOVFF  1B6,B8
....................                return; 
048B4:  GOTO   5846
048B8:  MOVLB  1
....................             } 
....................          } 
....................  
....................          // Third: check the security and precedence 
....................          // No such feature in this stack.  We want to accept all connections. 
....................  
....................          // Fourth: check the SYN bit 
....................          if(localHeaderFlags & SYN) 
048BA:  BTFSS  xB1.1
048BC:  BRA    495E
....................          { 
....................             // We now have an initial sequence number and window size 
....................             MyTCB.RemoteSEQ = localSeqNumber + 1; 
048BE:  MOVLW  01
048C0:  ADDWF  xB6,W
048C2:  MOVLB  0
048C4:  MOVWF  xBC
048C6:  MOVLW  00
048C8:  MOVLB  1
048CA:  ADDWFC xB7,W
048CC:  MOVLB  0
048CE:  MOVWF  xBD
048D0:  MOVLW  00
048D2:  MOVLB  1
048D4:  ADDWFC xB8,W
048D6:  MOVLB  0
048D8:  MOVWF  xBE
048DA:  MOVLW  00
048DC:  MOVLB  1
048DE:  ADDWFC xB9,W
048E0:  MOVLB  0
048E2:  MOVWF  xBF
....................             MyTCB.remoteWindow = h->Window; 
048E4:  MOVLW  0E
048E6:  MOVLB  1
048E8:  ADDWF  x9F,W
048EA:  MOVWF  FE9
048EC:  MOVLW  00
048EE:  ADDWFC xA0,W
048F0:  MOVWF  FEA
048F2:  MOVFF  FEC,C7
048F6:  MOVF   FED,F
048F8:  MOVFF  FEF,C6
....................  
....................             // Get MSS option 
....................             MyTCB.wRemoteMSS = GetMaxSegSizeOption(); 
048FC:  MOVLB  0
048FE:  RCALL  4600
04900:  MOVFF  02,D8
04904:  MOVFF  01,D7
....................  
....................             if(localHeaderFlags & ACK) 
04908:  MOVLB  1
0490A:  BTFSS  xB1.4
0490C:  BRA    4948
....................             { 
....................                SendTCP(ACK, SENDTCP_RESET_TIMERS); 
0490E:  MOVLW  10
04910:  MOVLB  2
04912:  MOVWF  x72
04914:  MOVLW  01
04916:  MOVWF  x73
04918:  MOVLB  0
0491A:  CALL   26A2
....................                MyTCBStub.smState = TCP_ESTABLISHED; 
0491E:  MOVLW  07
04920:  MOVLB  1
04922:  MOVWF  x2E
....................                // Set up keep-alive timer 
....................                #if defined(TCP_KEEP_ALIVE_TIMEOUT) 
....................                   MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
04924:  MOVLB  0
04926:  CALL   1AC2
0492A:  MOVLW  E6
0492C:  MOVLB  1
0492E:  ADDWF  00,W
04930:  MOVWF  x26
04932:  MOVLW  F5
04934:  ADDWFC 01,W
04936:  MOVWF  x27
04938:  MOVLW  05
0493A:  ADDWFC 02,W
0493C:  MOVWF  x28
0493E:  MOVLW  00
04940:  ADDWFC 03,W
04942:  MOVWF  x29
....................                #endif 
....................                MyTCBStub.Flags.bTimerEnabled = 0; 
04944:  BCF    x2F.4
....................             } 
04946:  BRA    495E
....................             else 
....................             { 
....................                SendTCP(SYN | ACK, SENDTCP_RESET_TIMERS); 
04948:  MOVLW  12
0494A:  MOVLB  2
0494C:  MOVWF  x72
0494E:  MOVLW  01
04950:  MOVWF  x73
04952:  MOVLB  0
04954:  CALL   26A2
....................                MyTCBStub.smState = TCP_SYN_RECEIVED; 
04958:  MOVLW  06
0495A:  MOVLB  1
0495C:  MOVWF  x2E
....................             } 
....................          } 
....................  
....................          // Fifth: drop the segment if neither SYN or RST is set 
....................          return; 
0495E:  MOVLB  0
04960:  GOTO   5846
....................  
....................       default: 
....................          break; 
....................    } 
....................  
....................    // 
....................    // First: check the sequence number 
....................    // 
....................    wSegmentLength = len; 
04964:  MOVFF  1A2,1BB
04968:  MOVFF  1A1,1BA
....................    if(localHeaderFlags & FIN) 
0496C:  MOVLB  1
0496E:  BTFSS  xB1.0
04970:  BRA    4978
....................       wSegmentLength++; 
04972:  INCF   xBA,F
04974:  BTFSC  FD8.2
04976:  INCF   xBB,F
....................    if(localHeaderFlags & SYN) 
04978:  BTFSS  xB1.1
0497A:  BRA    4982
....................       wSegmentLength++; 
0497C:  INCF   xBA,F
0497E:  BTFSC  FD8.2
04980:  INCF   xBB,F
....................  
....................    // Calculate the RX FIFO space 
....................    if(MyTCBStub.rxHead >= MyTCBStub.rxTail) 
04982:  MOVF   x25,W
04984:  SUBWF  x23,W
04986:  BNC   49B6
04988:  BNZ   4990
0498A:  MOVF   x24,W
0498C:  SUBWF  x22,W
0498E:  BNC   49B6
....................       wFreeSpace = (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart) - (MyTCBStub.rxHead - MyTCBStub.rxTail); 
04990:  MOVF   x1A,W
04992:  SUBWF  x1C,W
04994:  MOVWF  xBF
04996:  MOVF   x1B,W
04998:  SUBWFB x1D,W
0499A:  MOVWF  xC0
0499C:  MOVF   x24,W
0499E:  SUBWF  x22,W
049A0:  MOVWF  00
049A2:  MOVF   x25,W
049A4:  SUBWFB x23,W
049A6:  MOVWF  03
049A8:  MOVF   00,W
049AA:  SUBWF  xBF,W
049AC:  MOVWF  xAF
049AE:  MOVF   03,W
049B0:  SUBWFB xC0,W
049B2:  MOVWF  xB0
049B4:  BRA    49CE
....................    else 
....................       wFreeSpace = MyTCBStub.rxTail - MyTCBStub.rxHead - 1; 
049B6:  MOVF   x22,W
049B8:  SUBWF  x24,W
049BA:  MOVWF  xBF
049BC:  MOVF   x23,W
049BE:  SUBWFB x25,W
049C0:  MOVWF  xC0
049C2:  MOVLW  01
049C4:  SUBWF  xBF,W
049C6:  MOVWF  xAF
049C8:  MOVLW  00
049CA:  SUBWFB xC0,W
049CC:  MOVWF  xB0
....................  
....................    // Calculate the number of bytes ahead of our head pointer this segment skips 
....................    lMissingBytes = localSeqNumber - MyTCB.RemoteSEQ; 
049CE:  MOVLB  0
049D0:  MOVF   xBC,W
049D2:  MOVLB  1
049D4:  SUBWF  xB6,W
049D6:  MOVWF  00
049D8:  MOVLB  0
049DA:  MOVF   xBD,W
049DC:  MOVLB  1
049DE:  SUBWFB xB7,W
049E0:  MOVWF  01
049E2:  MOVLB  0
049E4:  MOVF   xBE,W
049E6:  MOVLB  1
049E8:  SUBWFB xB8,W
049EA:  MOVWF  02
049EC:  MOVLB  0
049EE:  MOVF   xBF,W
049F0:  MOVLB  1
049F2:  SUBWFB xB9,W
049F4:  MOVWF  xAC
049F6:  MOVFF  02,1AB
049FA:  MOVFF  01,1AA
049FE:  MOVFF  00,1A9
....................    wMissingBytes = (WORD)lMissingBytes; 
04A02:  MOVFF  1AA,1AE
04A06:  MOVFF  1A9,1AD
....................     
....................    // Run TCP acceptability tests to verify that this packet has a valid sequence number 
....................    bSegmentAcceptable = FALSE; 
04A0A:  BCF    xBC.0
....................    if(wSegmentLength) 
04A0C:  MOVF   xBA,W
04A0E:  IORWF  xBB,W
04A10:  BTFSC  FD8.2
04A12:  BRA    4B16
....................    { 
....................       // Check to see if we have free space, and if so, if any of the data falls within the freespace 
....................       if(wFreeSpace) 
04A14:  MOVF   xAF,W
04A16:  IORWF  xB0,W
04A18:  BTFSC  FD8.2
04A1A:  BRA    4B14
....................       { 
....................          // RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND 
....................          if((lMissingBytes >= (LONG)0) && (wFreeSpace > (DWORD)lMissingBytes)) 
04A1C:  BTFSC  xAC.7
04A1E:  BRA    4A3A
04A20:  MOVF   xAC,F
04A22:  BNZ   4A3A
04A24:  MOVF   xAB,F
04A26:  BNZ   4A3A
04A28:  MOVF   xAA,W
04A2A:  SUBWF  xB0,W
04A2C:  BNC   4A3A
04A2E:  BNZ   4A36
04A30:  MOVF   xAF,W
04A32:  SUBWF  xA9,W
04A34:  BC    4A3A
....................             bSegmentAcceptable = TRUE; 
04A36:  BSF    xBC.0
04A38:  BRA    4AC0
....................          else 
....................          { 
....................             // RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND 
....................             if((lMissingBytes + (LONG)wSegmentLength > (LONG)0) && (lMissingBytes <= (LONG)(SHORT)(wFreeSpace - wSegmentLength))) 
04A3A:  MOVFF  1BA,00
04A3E:  MOVFF  1BB,01
04A42:  CLRF   02
04A44:  CLRF   03
04A46:  MOVF   xBA,W
04A48:  ADDWF  xA9,W
04A4A:  MOVWF  xBF
04A4C:  MOVF   xBB,W
04A4E:  ADDWFC xAA,W
04A50:  MOVWF  xC0
04A52:  MOVF   02,W
04A54:  ADDWFC xAB,W
04A56:  MOVWF  xC1
04A58:  MOVF   03,W
04A5A:  ADDWFC xAC,W
04A5C:  MOVWF  xC2
04A5E:  BTFSC  FE8.7
04A60:  BRA    4AC0
04A62:  MOVF   xC2,F
04A64:  BNZ   4A74
04A66:  MOVF   xC1,F
04A68:  BNZ   4A74
04A6A:  MOVF   xC0,F
04A6C:  BNZ   4A74
04A6E:  MOVF   xBF,W
04A70:  SUBLW  00
04A72:  BC    4AC0
04A74:  MOVF   xBA,W
04A76:  SUBWF  xAF,W
04A78:  MOVWF  00
04A7A:  MOVF   xBB,W
04A7C:  SUBWFB xB0,W
04A7E:  MOVWF  03
04A80:  MOVF   00,W
04A82:  MOVFF  03,01
04A86:  CLRF   02
04A88:  CLRF   03
04A8A:  BTFSS  01.7
04A8C:  BRA    4A92
04A8E:  DECF   02,F
04A90:  DECF   03,F
04A92:  BTFSS  xAC.7
04A94:  BRA    4A9C
04A96:  BTFSS  03.7
04A98:  BRA    4ABE
04A9A:  BRA    4AA0
04A9C:  BTFSC  03.7
04A9E:  BRA    4AC0
04AA0:  MOVF   xAC,W
04AA2:  SUBWF  03,W
04AA4:  BNC   4AC0
04AA6:  BNZ   4ABE
04AA8:  MOVF   xAB,W
04AAA:  SUBWF  02,W
04AAC:  BNC   4AC0
04AAE:  BNZ   4ABE
04AB0:  MOVF   xAA,W
04AB2:  SUBWF  01,W
04AB4:  BNC   4AC0
04AB6:  BNZ   4ABE
04AB8:  MOVF   xA9,W
04ABA:  SUBWF  00,W
04ABC:  BNC   4AC0
....................                bSegmentAcceptable = TRUE; 
04ABE:  BSF    xBC.0
....................          } 
....................           
....................          if((lMissingBytes < (LONG)wFreeSpace) && ((SHORT)wMissingBytes + (SHORT)wSegmentLength > (SHORT)0)) 
04AC0:  MOVFF  1AF,00
04AC4:  MOVFF  1B0,01
04AC8:  CLRF   02
04ACA:  CLRF   03
04ACC:  BTFSS  xAC.7
04ACE:  BRA    4AD6
04AD0:  BTFSS  03.7
04AD2:  BRA    4AF8
04AD4:  BRA    4ADA
04AD6:  BTFSC  03.7
04AD8:  BRA    4B14
04ADA:  MOVF   xAC,W
04ADC:  SUBWF  03,W
04ADE:  BNC   4B14
04AE0:  BNZ   4AF8
04AE2:  MOVF   xAB,W
04AE4:  SUBWF  02,W
04AE6:  BNC   4B14
04AE8:  BNZ   4AF8
04AEA:  MOVF   xAA,W
04AEC:  SUBWF  01,W
04AEE:  BNC   4B14
04AF0:  BNZ   4AF8
04AF2:  MOVF   00,W
04AF4:  SUBWF  xA9,W
04AF6:  BC    4B14
04AF8:  MOVF   xBA,W
04AFA:  ADDWF  xAD,W
04AFC:  MOVWF  xBF
04AFE:  MOVF   xBB,W
04B00:  ADDWFC xAE,W
04B02:  MOVWF  xC0
04B04:  BTFSC  FE8.7
04B06:  BRA    4B14
04B08:  MOVF   xC0,F
04B0A:  BNZ   4B12
04B0C:  MOVF   xBF,W
04B0E:  SUBLW  00
04B10:  BC    4B14
....................             bSegmentAcceptable = TRUE; 
04B12:  BSF    xBC.0
....................       } 
....................       // Segments with data are not acceptable if we have no free space 
....................    } 
04B14:  BRA    4B46
....................    else 
....................    { 
....................       // Zero length packets are acceptable if they fall within our free space window 
....................       // SEG.SEQ = RCV.NXT 
....................       if(lMissingBytes == 0) 
04B16:  MOVF   xA9,F
04B18:  BNZ   4B2A
04B1A:  MOVF   xAA,F
04B1C:  BNZ   4B2A
04B1E:  MOVF   xAB,F
04B20:  BNZ   4B2A
04B22:  MOVF   xAC,F
04B24:  BNZ   4B2A
....................       { 
....................          bSegmentAcceptable = TRUE; 
04B26:  BSF    xBC.0
....................       } 
04B28:  BRA    4B46
....................       else 
....................       { 
....................          // RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND 
....................          if((lMissingBytes >= (LONG)0) && (wFreeSpace > (DWORD)lMissingBytes)) 
04B2A:  BTFSC  xAC.7
04B2C:  BRA    4B46
04B2E:  MOVF   xAC,F
04B30:  BNZ   4B46
04B32:  MOVF   xAB,F
04B34:  BNZ   4B46
04B36:  MOVF   xAA,W
04B38:  SUBWF  xB0,W
04B3A:  BNC   4B46
04B3C:  BNZ   4B44
04B3E:  MOVF   xAF,W
04B40:  SUBWF  xA9,W
04B42:  BC    4B46
....................             bSegmentAcceptable = TRUE; 
04B44:  BSF    xBC.0
....................       } 
....................    } 
....................     
....................    if(!bSegmentAcceptable) 
04B46:  BTFSC  xBC.0
04B48:  BRA    4B68
....................    { 
....................       // Unacceptable segment, drop it and respond appropriately 
....................       if(!(localHeaderFlags & RST))  
04B4A:  BTFSC  xB1.2
04B4C:  BRA    4B60
....................          SendTCP(ACK, SENDTCP_RESET_TIMERS); 
04B4E:  MOVLW  10
04B50:  MOVLB  2
04B52:  MOVWF  x72
04B54:  MOVLW  01
04B56:  MOVWF  x73
04B58:  MOVLB  0
04B5A:  CALL   26A2
04B5E:  MOVLB  1
....................       return; 
04B60:  MOVLB  0
04B62:  GOTO   5846
04B66:  MOVLB  1
....................    } 
....................  
....................  
....................    // 
....................    // Second: check the RST bit 
....................    // 
....................    // 
....................    // Fourth: check the SYN bit 
....................    // 
....................    // Note, that since the third step is not implemented, we can  
....................    // combine this second and fourth step into a single operation. 
....................    if(localHeaderFlags & (RST | SYN)) 
04B68:  MOVF   xB1,W
04B6A:  ANDLW  06
04B6C:  BZ    4B7A
....................    { 
....................       CloseSocket(); 
04B6E:  MOVLB  0
04B70:  CALL   13DE
....................       return; 
04B74:  GOTO   5846
04B78:  MOVLB  1
....................    } 
....................  
....................    // 
....................    // Third: check the security and precedence 
....................    // 
....................    // Feature not supported.  Let's process this segment. 
....................  
....................    // 
....................    // Fifth: check the ACK bit 
....................    // 
....................    if(!(localHeaderFlags & ACK)) 
04B7A:  BTFSC  xB1.4
04B7C:  BRA    4B86
....................       return; 
04B7E:  MOVLB  0
04B80:  GOTO   5846
04B84:  MOVLB  1
....................  
....................    switch(MyTCBStub.smState) 
04B86:  MOVF   x2E,W
04B88:  XORLW  06
04B8A:  MOVLB  0
04B8C:  BZ    4BAA
04B8E:  XORLW  01
04B90:  BZ    4C1C
04B92:  XORLW  0F
04B94:  BZ    4C1C
04B96:  XORLW  01
04B98:  BZ    4C1C
04B9A:  XORLW  02
04B9C:  BZ    4C1C
04B9E:  XORLW  01
04BA0:  BZ    4C1C
04BA2:  XORLW  06
04BA4:  BTFSC  FD8.2
04BA6:  BRA    5174
04BA8:  BRA    51BE
....................    { 
....................       case TCP_SYN_RECEIVED: 
....................          if(localAckNumber != MyTCB.MySEQ) 
04BAA:  MOVF   xB8,W
04BAC:  MOVLB  1
04BAE:  SUBWF  xB2,W
04BB0:  BNZ   4BD0
04BB2:  MOVLB  0
04BB4:  MOVF   xB9,W
04BB6:  MOVLB  1
04BB8:  SUBWF  xB3,W
04BBA:  BNZ   4BD0
04BBC:  MOVLB  0
04BBE:  MOVF   xBA,W
04BC0:  MOVLB  1
04BC2:  SUBWF  xB4,W
04BC4:  BNZ   4BD0
04BC6:  MOVLB  0
04BC8:  MOVF   xBB,W
04BCA:  MOVLB  1
04BCC:  SUBWF  xB5,W
04BCE:  BZ    4C16
....................          { 
....................             // Send a RST packet with SEQ = SEG.ACK, but retain our SEQ  
....................             // number for arivial of any other correct packets 
....................             localSeqNumber = MyTCB.MySEQ;   // Save our original SEQ number 
04BD0:  MOVFF  BB,1B9
04BD4:  MOVFF  BA,1B8
04BD8:  MOVFF  B9,1B7
04BDC:  MOVFF  B8,1B6
....................             MyTCB.MySEQ = localAckNumber;   // Set SEQ = SEG.ACK 
04BE0:  MOVFF  1B5,BB
04BE4:  MOVFF  1B4,BA
04BE8:  MOVFF  1B3,B9
04BEC:  MOVFF  1B2,B8
....................             SendTCP(RST, SENDTCP_RESET_TIMERS);      // Send the RST 
04BF0:  MOVLW  04
04BF2:  MOVLB  2
04BF4:  MOVWF  x72
04BF6:  MOVLW  01
04BF8:  MOVWF  x73
04BFA:  MOVLB  0
04BFC:  CALL   26A2
....................             MyTCB.MySEQ = localSeqNumber;   // Restore original SEQ number 
04C00:  MOVFF  1B9,BB
04C04:  MOVFF  1B8,BA
04C08:  MOVFF  1B7,B9
04C0C:  MOVFF  1B6,B8
....................             return; 
04C10:  GOTO   5846
04C14:  MOVLB  1
....................          } 
....................          MyTCBStub.smState = TCP_ESTABLISHED; 
04C16:  MOVLW  07
04C18:  MOVWF  x2E
04C1A:  MOVLB  0
....................          // No break 
....................  
....................       case TCP_ESTABLISHED: 
....................       case TCP_FIN_WAIT_1: 
....................       case TCP_FIN_WAIT_2: 
....................       case TCP_CLOSE_WAIT: 
....................       case TCP_CLOSING: 
....................          // Calculate what the highest possible SEQ number in our TX FIFO is 
....................          wTemp = MyTCBStub.txHead - MyTCB.txUnackedTail; 
04C1C:  MOVF   xC0,W
04C1E:  MOVLB  1
04C20:  SUBWF  x1E,W
04C22:  MOVWF  xA7
04C24:  MOVLB  0
04C26:  MOVF   xC1,W
04C28:  MOVLB  1
04C2A:  SUBWFB x1F,W
04C2C:  MOVWF  xA8
....................          if((SHORT)wTemp < (SHORT)0) 
04C2E:  BTFSS  xA8.7
04C30:  BRA    4C46
....................             wTemp += MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
04C32:  MOVF   x18,W
04C34:  SUBWF  x1A,W
04C36:  MOVWF  00
04C38:  MOVF   x19,W
04C3A:  SUBWFB x1B,W
04C3C:  MOVWF  03
04C3E:  MOVF   00,W
04C40:  ADDWF  xA7,F
04C42:  MOVF   03,W
04C44:  ADDWFC xA8,F
....................          dwTemp = MyTCB.MySEQ + (DWORD)wTemp; 
04C46:  CLRF   02
04C48:  CLRF   03
04C4A:  MOVF   xA7,W
04C4C:  MOVLB  0
04C4E:  ADDWF  xB8,W
04C50:  MOVLB  1
04C52:  MOVWF  xA3
04C54:  MOVF   xA8,W
04C56:  MOVLB  0
04C58:  ADDWFC xB9,W
04C5A:  MOVLB  1
04C5C:  MOVWF  xA4
04C5E:  MOVF   02,W
04C60:  MOVLB  0
04C62:  ADDWFC xBA,W
04C64:  MOVLB  1
04C66:  MOVWF  xA5
04C68:  MOVF   03,W
04C6A:  MOVLB  0
04C6C:  ADDWFC xBB,W
04C6E:  MOVLB  1
04C70:  MOVWF  xA6
....................  
....................          // Drop the packet if it ACKs something we haven't sent 
....................             dwTemp = (LONG)localAckNumber - (LONG)dwTemp; 
04C72:  MOVF   xA3,W
04C74:  SUBWF  xB2,W
04C76:  MOVWF  00
04C78:  MOVF   xA4,W
04C7A:  SUBWFB xB3,W
04C7C:  MOVWF  01
04C7E:  MOVF   xA5,W
04C80:  SUBWFB xB4,W
04C82:  MOVWF  02
04C84:  MOVF   xA6,W
04C86:  SUBWFB xB5,W
04C88:  MOVWF  xA6
04C8A:  MOVFF  02,1A5
04C8E:  MOVFF  01,1A4
04C92:  MOVFF  00,1A3
....................             if((LONG)dwTemp > 0) 
04C96:  BTFSC  xA6.7
04C98:  BRA    4CFE
04C9A:  MOVF   xA6,F
04C9C:  BNZ   4CAC
04C9E:  MOVF   xA5,F
04CA0:  BNZ   4CAC
04CA2:  MOVF   xA4,F
04CA4:  BNZ   4CAC
04CA6:  MOVF   xA3,W
04CA8:  SUBLW  00
04CAA:  BC    4CFE
....................             {   // acknowledged more than we've sent?? 
....................                 if(!MyTCB.flags.bFINSent || dwTemp != 1) 
04CAC:  MOVLB  0
04CAE:  BTFSS  xD6.0
04CB0:  BRA    4CD8
04CB2:  MOVLB  1
04CB4:  DECFSZ xA3,W
04CB6:  BRA    4CBA
04CB8:  BRA    4CBE
04CBA:  MOVLB  0
04CBC:  BRA    4CD8
04CBE:  MOVF   xA4,F
04CC0:  BTFSC  FD8.2
04CC2:  BRA    4CC8
04CC4:  MOVLB  0
04CC6:  BRA    4CD8
04CC8:  MOVF   xA5,F
04CCA:  BTFSC  FD8.2
04CCC:  BRA    4CD2
04CCE:  MOVLB  0
04CD0:  BRA    4CD8
04CD2:  MOVF   xA6,F
04CD4:  BZ    4CEE
04CD6:  MOVLB  0
....................                 { 
....................                     SendTCP(ACK, 0); 
04CD8:  MOVLW  10
04CDA:  MOVLB  2
04CDC:  MOVWF  x72
04CDE:  CLRF   x73
04CE0:  MOVLB  0
04CE2:  CALL   26A2
....................                     return; 
04CE6:  GOTO   5846
....................                 } 
04CEA:  BRA    4D00
04CEC:  MOVLB  1
....................                 else 
....................                 { 
....................                     localAckNumber--;   // since we don't count the FIN anyway 
04CEE:  MOVLW  FF
04CF0:  ADDWF  xB2,F
04CF2:  BTFSS  FD8.0
04CF4:  ADDWF  xB3,F
04CF6:  BTFSS  FD8.0
04CF8:  ADDWF  xB4,F
04CFA:  BTFSS  FD8.0
04CFC:  ADDWF  xB5,F
04CFE:  MOVLB  0
....................                 } 
....................             } 
....................  
....................          // Throw away all ACKnowledged TX data: 
....................          // Calculate what the last acknowledged sequence number was (ignoring any FINs we sent) 
....................          dwTemp = MyTCB.MySEQ - (LONG)(SHORT)(MyTCB.txUnackedTail - MyTCBStub.txTail); 
04D00:  MOVLB  1
04D02:  MOVF   x20,W
04D04:  MOVLB  0
04D06:  SUBWF  xC0,W
04D08:  MOVWF  00
04D0A:  MOVLB  1
04D0C:  MOVF   x21,W
04D0E:  MOVLB  0
04D10:  SUBWFB xC1,W
04D12:  MOVWF  03
04D14:  MOVF   00,W
04D16:  MOVFF  03,01
04D1A:  CLRF   02
04D1C:  CLRF   03
04D1E:  BTFSS  01.7
04D20:  BRA    4D26
04D22:  DECF   02,F
04D24:  DECF   03,F
04D26:  MOVF   00,W
04D28:  SUBWF  xB8,W
04D2A:  MOVWF  00
04D2C:  MOVF   01,W
04D2E:  SUBWFB xB9,W
04D30:  MOVWF  01
04D32:  MOVF   02,W
04D34:  SUBWFB xBA,W
04D36:  MOVWF  02
04D38:  MOVF   03,W
04D3A:  SUBWFB xBB,W
04D3C:  MOVFF  FE8,1A6
04D40:  MOVFF  02,1A5
04D44:  MOVFF  01,1A4
04D48:  MOVFF  00,1A3
....................          if(MyTCB.txUnackedTail < MyTCBStub.txTail) 
04D4C:  MOVF   xC1,W
04D4E:  MOVLB  1
04D50:  SUBWF  x21,W
04D52:  BNC   4D80
04D54:  BNZ   4D66
04D56:  MOVF   x20,W
04D58:  MOVLB  0
04D5A:  SUBWF  xC0,W
04D5C:  BTFSS  FD8.0
04D5E:  BRA    4D64
04D60:  MOVLB  1
04D62:  BRA    4D80
04D64:  MOVLB  1
....................             dwTemp -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
04D66:  MOVF   x18,W
04D68:  SUBWF  x1A,W
04D6A:  MOVWF  00
04D6C:  MOVF   x19,W
04D6E:  SUBWFB x1B,W
04D70:  MOVWF  03
04D72:  MOVF   00,W
04D74:  SUBWF  xA3,F
04D76:  MOVF   03,W
04D78:  SUBWFB xA4,F
04D7A:  MOVLW  00
04D7C:  SUBWFB xA5,F
04D7E:  SUBWFB xA6,F
....................     
....................          // Calcluate how many bytes were ACKed with this packet 
....................          dwTemp = localAckNumber - dwTemp; 
04D80:  MOVF   xA3,W
04D82:  SUBWF  xB2,W
04D84:  MOVWF  xA3
04D86:  MOVF   xA4,W
04D88:  SUBWFB xB3,W
04D8A:  MOVWF  xA4
04D8C:  MOVF   xA5,W
04D8E:  SUBWFB xB4,W
04D90:  MOVWF  xA5
04D92:  MOVF   xA6,W
04D94:  SUBWFB xB5,W
04D96:  MOVWF  xA6
....................          if(((LONG)(dwTemp) > (LONG)0) && (dwTemp <= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart)) 
04D98:  BTFSC  xA6.7
04D9A:  BRA    4F00
04D9C:  MOVF   xA6,F
04D9E:  BNZ   4DB0
04DA0:  MOVF   xA5,F
04DA2:  BNZ   4DB0
04DA4:  MOVF   xA4,F
04DA6:  BNZ   4DB0
04DA8:  MOVF   xA3,W
04DAA:  SUBLW  00
04DAC:  BTFSC  FD8.0
04DAE:  BRA    4F00
04DB0:  MOVF   x18,W
04DB2:  SUBWF  x1A,W
04DB4:  MOVWF  00
04DB6:  MOVF   x19,W
04DB8:  SUBWFB x1B,W
04DBA:  MOVWF  03
04DBC:  MOVFF  00,01
04DC0:  MOVF   xA6,F
04DC2:  BTFSS  FD8.2
04DC4:  BRA    4F00
04DC6:  MOVF   xA5,F
04DC8:  BTFSS  FD8.2
04DCA:  BRA    4F00
04DCC:  MOVF   xA4,W
04DCE:  SUBWF  03,W
04DD0:  BTFSS  FD8.0
04DD2:  BRA    4F00
04DD4:  BNZ   4DDE
04DD6:  MOVF   xA3,W
04DD8:  SUBWF  01,W
04DDA:  BTFSS  FD8.0
04DDC:  BRA    4F00
....................          { 
....................             MyTCB.flags.bRXNoneACKed1 = 0; 
04DDE:  MOVLB  0
04DE0:  BCF    xD6.3
....................             MyTCB.flags.bRXNoneACKed2 = 0; 
04DE2:  BCF    xD6.4
....................             MyTCBStub.Flags.bHalfFullFlush = FALSE; 
04DE4:  MOVLB  1
04DE6:  BCF    x30.0
....................     
....................             // Bytes ACKed, free up the TX FIFO space 
....................             wTemp = MyTCBStub.txTail; 
04DE8:  MOVFF  121,1A8
04DEC:  MOVFF  120,1A7
....................             MyTCBStub.txTail += dwTemp; 
04DF0:  MOVF   xA3,W
04DF2:  ADDWF  x20,F
04DF4:  MOVF   xA4,W
04DF6:  ADDWFC x21,F
....................             if(MyTCB.txUnackedTail >= wTemp) 
04DF8:  MOVF   xA8,W
04DFA:  MOVLB  0
04DFC:  SUBWF  xC1,W
04DFE:  BNC   4E58
04E00:  BNZ   4E0C
04E02:  MOVLB  1
04E04:  MOVF   xA7,W
04E06:  MOVLB  0
04E08:  SUBWF  xC0,W
04E0A:  BNC   4E58
....................             { 
....................                if(MyTCB.txUnackedTail < MyTCBStub.txTail) 
04E0C:  MOVF   xC1,W
04E0E:  MOVLB  1
04E10:  SUBWF  x21,W
04E12:  BNC   4E54
04E14:  BNZ   4E26
04E16:  MOVF   x20,W
04E18:  MOVLB  0
04E1A:  SUBWF  xC0,W
04E1C:  BTFSS  FD8.0
04E1E:  BRA    4E24
04E20:  MOVLB  1
04E22:  BRA    4E54
04E24:  MOVLB  1
....................                { 
....................                   MyTCB.MySEQ += MyTCBStub.txTail - MyTCB.txUnackedTail; 
04E26:  MOVLB  0
04E28:  MOVF   xC0,W
04E2A:  MOVLB  1
04E2C:  SUBWF  x20,W
04E2E:  MOVWF  00
04E30:  MOVLB  0
04E32:  MOVF   xC1,W
04E34:  MOVLB  1
04E36:  SUBWFB x21,W
04E38:  MOVWF  03
04E3A:  MOVF   00,W
04E3C:  MOVLB  0
04E3E:  ADDWF  xB8,F
04E40:  MOVF   03,W
04E42:  ADDWFC xB9,F
04E44:  MOVLW  00
04E46:  ADDWFC xBA,F
04E48:  ADDWFC xBB,F
....................                   MyTCB.txUnackedTail = MyTCBStub.txTail; 
04E4A:  MOVFF  121,C1
04E4E:  MOVFF  120,C0
04E52:  MOVLB  1
....................                } 
....................             } 
04E54:  BRA    4EAE
04E56:  MOVLB  0
....................             else 
....................             { 
....................                wTemp = MyTCB.txUnackedTail + (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart); 
04E58:  MOVLB  1
04E5A:  MOVF   x18,W
04E5C:  SUBWF  x1A,W
04E5E:  MOVWF  00
04E60:  MOVF   x19,W
04E62:  SUBWFB x1B,W
04E64:  MOVWF  03
04E66:  MOVF   00,W
04E68:  MOVLB  0
04E6A:  ADDWF  xC0,W
04E6C:  MOVLB  1
04E6E:  MOVWF  xA7
04E70:  MOVF   03,W
04E72:  MOVLB  0
04E74:  ADDWFC xC1,W
04E76:  MOVLB  1
04E78:  MOVWF  xA8
....................                if(wTemp < MyTCBStub.txTail) 
04E7A:  MOVF   xA8,W
04E7C:  SUBWF  x21,W
04E7E:  BNC   4EAE
04E80:  BNZ   4E88
04E82:  MOVF   x20,W
04E84:  SUBWF  xA7,W
04E86:  BC    4EAE
....................                { 
....................                   MyTCB.MySEQ += MyTCBStub.txTail - wTemp; 
04E88:  MOVF   xA7,W
04E8A:  SUBWF  x20,W
04E8C:  MOVWF  00
04E8E:  MOVF   xA8,W
04E90:  SUBWFB x21,W
04E92:  MOVWF  03
04E94:  MOVF   00,W
04E96:  MOVLB  0
04E98:  ADDWF  xB8,F
04E9A:  MOVF   03,W
04E9C:  ADDWFC xB9,F
04E9E:  MOVLW  00
04EA0:  ADDWFC xBA,F
04EA2:  ADDWFC xBB,F
....................                   MyTCB.txUnackedTail = MyTCBStub.txTail; 
04EA4:  MOVFF  121,C1
04EA8:  MOVFF  120,C0
04EAC:  MOVLB  1
....................                } 
....................             } 
....................             if(MyTCBStub.txTail >= MyTCBStub.bufferRxStart) 
04EAE:  MOVF   x1B,W
04EB0:  SUBWF  x21,W
04EB2:  BNC   4ED0
04EB4:  BNZ   4EBC
04EB6:  MOVF   x1A,W
04EB8:  SUBWF  x20,W
04EBA:  BNC   4ED0
....................                MyTCBStub.txTail -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
04EBC:  MOVF   x18,W
04EBE:  SUBWF  x1A,W
04EC0:  MOVWF  00
04EC2:  MOVF   x19,W
04EC4:  SUBWFB x1B,W
04EC6:  MOVWF  03
04EC8:  MOVF   00,W
04ECA:  SUBWF  x20,F
04ECC:  MOVF   03,W
04ECE:  SUBWFB x21,F
....................             if(MyTCB.txUnackedTail >= MyTCBStub.bufferRxStart) 
04ED0:  MOVF   x1B,W
04ED2:  MOVLB  0
04ED4:  SUBWF  xC1,W
04ED6:  BNC   4EFC
04ED8:  BNZ   4EE4
04EDA:  MOVLB  1
04EDC:  MOVF   x1A,W
04EDE:  MOVLB  0
04EE0:  SUBWF  xC0,W
04EE2:  BNC   4EFC
....................                MyTCB.txUnackedTail -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
04EE4:  MOVLB  1
04EE6:  MOVF   x18,W
04EE8:  SUBWF  x1A,W
04EEA:  MOVWF  00
04EEC:  MOVF   x19,W
04EEE:  SUBWFB x1B,W
04EF0:  MOVWF  03
04EF2:  MOVF   00,W
04EF4:  MOVLB  0
04EF6:  SUBWF  xC0,F
04EF8:  MOVF   03,W
04EFA:  SUBWFB xC1,F
....................          } 
04EFC:  BRA    4FDA
04EFE:  MOVLB  1
....................          else 
....................          { 
....................             // See if we have outstanding TX data that is waiting for an ACK 
....................             if(MyTCBStub.txTail != MyTCB.txUnackedTail) 
04F00:  MOVLB  0
04F02:  MOVF   xC0,W
04F04:  MOVLB  1
04F06:  SUBWF  x20,W
04F08:  BNZ   4F14
04F0A:  MOVLB  0
04F0C:  MOVF   xC1,W
04F0E:  MOVLB  1
04F10:  SUBWF  x21,W
04F12:  BZ    4FDC
....................             { 
....................                if(MyTCB.flags.bRXNoneACKed1) 
04F14:  MOVLB  0
04F16:  BTFSS  xD6.3
04F18:  BRA    4FD8
....................                { 
....................                   if(MyTCB.flags.bRXNoneACKed2) 
04F1A:  BTFSS  xD6.4
04F1C:  BRA    4FD6
....................                   { 
....................                      // Set up to perform a fast retransmission 
....................                      // Roll back unacknowledged TX tail pointer to cause retransmit to occur 
....................                      MyTCB.MySEQ -= (LONG)(SHORT)(MyTCB.txUnackedTail - MyTCBStub.txTail); 
04F1E:  MOVLB  1
04F20:  MOVF   x20,W
04F22:  MOVLB  0
04F24:  SUBWF  xC0,W
04F26:  MOVWF  00
04F28:  MOVLB  1
04F2A:  MOVF   x21,W
04F2C:  MOVLB  0
04F2E:  SUBWFB xC1,W
04F30:  MOVWF  03
04F32:  MOVF   00,W
04F34:  MOVFF  03,01
04F38:  CLRF   02
04F3A:  CLRF   03
04F3C:  BTFSS  01.7
04F3E:  BRA    4F44
04F40:  DECF   02,F
04F42:  DECF   03,F
04F44:  MOVF   00,W
04F46:  SUBWF  xB8,W
04F48:  MOVWF  00
04F4A:  MOVF   01,W
04F4C:  SUBWFB xB9,W
04F4E:  MOVWF  01
04F50:  MOVF   02,W
04F52:  SUBWFB xBA,W
04F54:  MOVWF  02
04F56:  MOVF   03,W
04F58:  SUBWFB xBB,W
04F5A:  MOVWF  xBB
04F5C:  MOVFF  02,BA
04F60:  MOVFF  01,B9
04F64:  MOVFF  00,B8
....................                      if(MyTCB.txUnackedTail < MyTCBStub.txTail) 
04F68:  MOVF   xC1,W
04F6A:  MOVLB  1
04F6C:  SUBWF  x21,W
04F6E:  BNC   4FCA
04F70:  BNZ   4F82
04F72:  MOVF   x20,W
04F74:  MOVLB  0
04F76:  SUBWF  xC0,W
04F78:  BTFSS  FD8.0
04F7A:  BRA    4F80
04F7C:  MOVLB  1
04F7E:  BRA    4FCA
04F80:  MOVLB  1
....................                         MyTCB.MySEQ -= (LONG)(SHORT)(MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart); 
04F82:  MOVF   x18,W
04F84:  SUBWF  x1A,W
04F86:  MOVWF  00
04F88:  MOVF   x19,W
04F8A:  SUBWFB x1B,W
04F8C:  MOVWF  03
04F8E:  MOVF   00,W
04F90:  MOVFF  03,01
04F94:  CLRF   02
04F96:  CLRF   03
04F98:  BTFSS  01.7
04F9A:  BRA    4FA0
04F9C:  DECF   02,F
04F9E:  DECF   03,F
04FA0:  MOVF   00,W
04FA2:  MOVLB  0
04FA4:  SUBWF  xB8,W
04FA6:  MOVWF  00
04FA8:  MOVF   01,W
04FAA:  SUBWFB xB9,W
04FAC:  MOVWF  01
04FAE:  MOVF   02,W
04FB0:  SUBWFB xBA,W
04FB2:  MOVWF  02
04FB4:  MOVF   03,W
04FB6:  SUBWFB xBB,W
04FB8:  MOVWF  03
04FBA:  MOVWF  xBB
04FBC:  MOVFF  02,BA
04FC0:  MOVFF  01,B9
04FC4:  MOVFF  00,B8
04FC8:  MOVLB  1
....................                      MyTCB.txUnackedTail = MyTCBStub.txTail; 
04FCA:  MOVFF  121,C1
04FCE:  MOVFF  120,C0
....................                      MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
04FD2:  BSF    x30.2
04FD4:  MOVLB  0
....................                   } 
....................                   MyTCB.flags.bRXNoneACKed2 = 1; 
04FD6:  BSF    xD6.4
....................                } 
....................                MyTCB.flags.bRXNoneACKed1 = 1; 
04FD8:  BSF    xD6.3
04FDA:  MOVLB  1
....................             } 
....................          } 
....................  
....................          // No need to keep our retransmit timer going if we have nothing that needs ACKing anymore 
....................          if(MyTCBStub.txTail == MyTCBStub.txHead) 
04FDC:  MOVF   x1E,W
04FDE:  SUBWF  x20,W
04FE0:  BNZ   5040
04FE2:  MOVF   x1F,W
04FE4:  SUBWF  x21,W
04FE6:  BNZ   5040
....................          { 
....................             // Make sure there isn't a "FIN byte in our TX FIFO" 
....................             if(MyTCBStub.Flags.bTXFIN == 0u) 
04FE8:  BTFSC  x30.3
04FEA:  BRA    5010
....................             { 
....................                // Convert retransmission timer to keep-alive timer 
....................                #if defined(TCP_KEEP_ALIVE_TIMEOUT) 
....................                   MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
04FEC:  MOVLB  0
04FEE:  CALL   1AC2
04FF2:  MOVLW  E6
04FF4:  MOVLB  1
04FF6:  ADDWF  00,W
04FF8:  MOVWF  x26
04FFA:  MOVLW  F5
04FFC:  ADDWFC 01,W
04FFE:  MOVWF  x27
05000:  MOVLW  05
05002:  ADDWFC 02,W
05004:  MOVWF  x28
05006:  MOVLW  00
05008:  ADDWFC 03,W
0500A:  MOVWF  x29
....................                #endif 
....................                MyTCBStub.Flags.bTimerEnabled = 0; 
0500C:  BCF    x2F.4
....................             } 
0500E:  BRA    5040
....................             else 
....................             { 
....................                // "Throw away" FIN byte from our TX FIFO if it has been ACKed 
....................                if((MyTCB.MySEQ == localAckNumber) && MyTCB.flags.bFINSent) 
05010:  MOVF   xB2,W
05012:  MOVLB  0
05014:  SUBWF  xB8,W
05016:  BNZ   5042
05018:  MOVLB  1
0501A:  MOVF   xB3,W
0501C:  MOVLB  0
0501E:  SUBWF  xB9,W
05020:  BNZ   5042
05022:  MOVLB  1
05024:  MOVF   xB4,W
05026:  MOVLB  0
05028:  SUBWF  xBA,W
0502A:  BNZ   5042
0502C:  MOVLB  1
0502E:  MOVF   xB5,W
05030:  MOVLB  0
05032:  SUBWF  xBB,W
05034:  BNZ   5042
05036:  BTFSS  xD6.0
05038:  BRA    5042
....................                { 
....................                   MyTCBStub.Flags.bTimerEnabled = 0; 
0503A:  MOVLB  1
0503C:  BCF    x2F.4
....................                   MyTCBStub.Flags.bTXFIN = 0; 
0503E:  BCF    x30.3
05040:  MOVLB  0
....................                } 
....................             } 
....................          } 
....................  
....................          // The window size advirtised in this packet is adjusted to account  
....................          // for any bytes that we have transmitted but haven't been ACKed yet  
....................          // by this segment. 
....................          wNewWindow = h->Window - ((WORD)(MyTCB.MySEQ - localAckNumber)); 
05042:  MOVLW  0E
05044:  MOVLB  1
05046:  ADDWF  x9F,W
05048:  MOVWF  FE9
0504A:  MOVLW  00
0504C:  ADDWFC xA0,W
0504E:  MOVWF  FEA
05050:  MOVFF  FEC,1C0
05054:  MOVF   FED,F
05056:  MOVFF  FEF,1BF
0505A:  MOVF   xB2,W
0505C:  MOVLB  0
0505E:  SUBWF  xB8,W
05060:  MOVWF  00
05062:  MOVLB  1
05064:  MOVF   xB3,W
05066:  MOVLB  0
05068:  SUBWFB xB9,W
0506A:  MOVWF  01
0506C:  MOVLB  1
0506E:  MOVF   xB4,W
05070:  MOVLB  0
05072:  SUBWFB xBA,W
05074:  MOVLB  1
05076:  MOVF   xB5,W
05078:  MOVLB  0
0507A:  SUBWFB xBB,W
0507C:  MOVF   00,W
0507E:  MOVLB  1
05080:  SUBWF  xBF,W
05082:  MOVWF  xBD
05084:  MOVF   01,W
05086:  SUBWFB xC0,W
05088:  MOVWF  xBE
....................  
....................          // Update the local stored copy of the RemoteWindow. 
....................          // If previously we had a zero window, and now we don't, then  
....................          // immediately send whatever was pending. 
....................          if((MyTCB.remoteWindow == 0u) && wNewWindow) 
0508A:  MOVLB  0
0508C:  MOVF   xC6,F
0508E:  BNZ   50A6
05090:  MOVF   xC7,F
05092:  BNZ   50A6
05094:  MOVLB  1
05096:  MOVF   xBD,W
05098:  IORWF  xBE,W
0509A:  BTFSS  FD8.2
0509C:  BRA    50A2
0509E:  MOVLB  0
050A0:  BRA    50A6
....................             MyTCBStub.Flags.bTXASAP = 1; 
050A2:  BSF    x30.1
050A4:  MOVLB  0
....................          MyTCB.remoteWindow = wNewWindow; 
050A6:  MOVFF  1BE,C7
050AA:  MOVFF  1BD,C6
....................  
....................          // A couple of states must do all of the TCP_ESTABLISHED stuff, but also a little more 
....................          if(MyTCBStub.smState == TCP_FIN_WAIT_1) 
050AE:  MOVLB  1
050B0:  MOVF   x2E,W
050B2:  SUBLW  08
050B4:  BNZ   510A
....................          { 
....................             // Check to see if our FIN has been ACKnowledged 
....................             if((MyTCB.MySEQ == localAckNumber) && MyTCB.flags.bFINSent) 
050B6:  MOVF   xB2,W
050B8:  MOVLB  0
050BA:  SUBWF  xB8,W
050BC:  BNZ   5106
050BE:  MOVLB  1
050C0:  MOVF   xB3,W
050C2:  MOVLB  0
050C4:  SUBWF  xB9,W
050C6:  BNZ   5106
050C8:  MOVLB  1
050CA:  MOVF   xB4,W
050CC:  MOVLB  0
050CE:  SUBWF  xBA,W
050D0:  BNZ   5106
050D2:  MOVLB  1
050D4:  MOVF   xB5,W
050D6:  MOVLB  0
050D8:  SUBWF  xBB,W
050DA:  BNZ   5106
050DC:  BTFSS  xD6.0
050DE:  BRA    5106
....................             { 
....................                // Reset our timer for forced closure if the remote node  
....................                // doesn't send us a FIN in a timely manner. 
....................                MyTCBStub.eventTime = TickGet() + TCP_FIN_WAIT_2_TIMEOUT; 
050E0:  CALL   1AC2
050E4:  MOVLW  F3
050E6:  MOVLB  1
050E8:  ADDWF  00,W
050EA:  MOVWF  x26
050EC:  MOVLW  FA
050EE:  ADDWFC 01,W
050F0:  MOVWF  x27
050F2:  MOVLW  02
050F4:  ADDWFC 02,W
050F6:  MOVWF  x28
050F8:  MOVLW  00
050FA:  ADDWFC 03,W
050FC:  MOVWF  x29
....................                MyTCBStub.Flags.bTimerEnabled = 1; 
050FE:  BSF    x2F.4
....................                MyTCBStub.smState = TCP_FIN_WAIT_2; 
05100:  MOVLW  09
05102:  MOVWF  x2E
05104:  MOVLB  0
....................             } 
....................          } 
05106:  BRA    5170
05108:  MOVLB  1
....................          else if(MyTCBStub.smState == TCP_FIN_WAIT_2) 
0510A:  MOVF   x2E,W
0510C:  SUBLW  09
0510E:  BNZ   513E
....................          { 
....................             // RFC noncompliance: 
....................             // The remote node should not keep sending us data  
....................             // indefinitely after we send a FIN to it.   
....................             // However, some bad stacks may still keep sending  
....................             // us data indefinitely after ACKing our FIN.  To  
....................             // prevent this from locking up our socket, let's  
....................             // send a RST right now and close forcefully on  
....................             // our side. 
....................             if(!(localHeaderFlags & FIN)) 
05110:  BTFSC  xB1.0
05112:  BRA    513C
....................             { 
....................                MyTCB.MySEQ = localAckNumber;   // Set SEQ = SEG.ACK 
05114:  MOVFF  1B5,BB
05118:  MOVFF  1B4,BA
0511C:  MOVFF  1B3,B9
05120:  MOVFF  1B2,B8
....................                SendTCP(RST | ACK, 0); 
05124:  MOVLW  14
05126:  MOVLB  2
05128:  MOVWF  x72
0512A:  CLRF   x73
0512C:  MOVLB  0
0512E:  CALL   26A2
....................                CloseSocket(); 
05132:  CALL   13DE
....................                return; 
05136:  GOTO   5846
0513A:  MOVLB  1
....................             } 
....................          } 
0513C:  BRA    5172
....................          else if(MyTCBStub.smState == TCP_CLOSING) 
0513E:  MOVF   x2E,W
05140:  SUBLW  0A
05142:  BNZ   5172
....................          { 
....................             // Check to see if our FIN has been ACKnowledged 
....................             if(MyTCB.MySEQ == localAckNumber) 
05144:  MOVF   xB2,W
05146:  MOVLB  0
05148:  SUBWF  xB8,W
0514A:  BNZ   516E
0514C:  MOVLB  1
0514E:  MOVF   xB3,W
05150:  MOVLB  0
05152:  SUBWF  xB9,W
05154:  BNZ   516E
05156:  MOVLB  1
05158:  MOVF   xB4,W
0515A:  MOVLB  0
0515C:  SUBWF  xBA,W
0515E:  BNZ   516E
05160:  MOVLB  1
05162:  MOVF   xB5,W
05164:  MOVLB  0
05166:  SUBWF  xBB,W
05168:  BNZ   516E
....................             { 
....................                // RFC not recommended: We should be going to  
....................                // the TCP_TIME_WAIT state right here and  
....................                // starting a 2MSL timer, but since we have so  
....................                // few precious sockets, we can't afford to  
....................                // leave a socket waiting around doing nothing  
....................                // for a long time.  If the remote node does  
....................                // not recieve this ACK, it'll have to figure  
....................                // out on it's own that the connection is now  
....................                // closed. 
....................                CloseSocket(); 
0516A:  CALL   13DE
....................             } 
....................  
....................             return; 
0516E:  BRA    5846
05170:  MOVLB  1
....................          } 
....................  
....................          break; 
05172:  BRA    51C0
....................  
....................       case TCP_LAST_ACK: 
....................          // Check to see if our FIN has been ACKnowledged 
....................          if(MyTCB.MySEQ + 1 == localAckNumber) 
05174:  MOVLW  01
05176:  ADDWF  xB8,W
05178:  MOVLB  1
0517A:  MOVWF  xBF
0517C:  MOVLW  00
0517E:  MOVLB  0
05180:  ADDWFC xB9,W
05182:  MOVLB  1
05184:  MOVWF  xC0
05186:  MOVLW  00
05188:  MOVLB  0
0518A:  ADDWFC xBA,W
0518C:  MOVLB  1
0518E:  MOVWF  xC1
05190:  MOVLW  00
05192:  MOVLB  0
05194:  ADDWFC xBB,W
05196:  MOVLB  1
05198:  MOVWF  xC2
0519A:  MOVF   xB2,W
0519C:  SUBWF  xBF,W
0519E:  BNZ   51BA
051A0:  MOVF   xB3,W
051A2:  SUBWF  xC0,W
051A4:  BNZ   51BA
051A6:  MOVF   xB4,W
051A8:  SUBWF  xC1,W
051AA:  BNZ   51BA
051AC:  MOVF   xB5,W
051AE:  SUBWF  xC2,W
051B0:  BNZ   51BA
....................             CloseSocket(); 
051B2:  MOVLB  0
051B4:  CALL   13DE
051B8:  MOVLB  1
....................          return; 
051BA:  MOVLB  0
051BC:  BRA    5846
....................  
.................... //      case TCP_TIME_WAIT: 
.................... //         // Nothing is supposed to arrive here.  If it does, reset the quiet timer. 
.................... //         SendTCP(ACK, SENDTCP_RESET_TIMERS); 
.................... //         return; 
....................  
....................       default: 
....................          break; 
051BE:  MOVLB  1
....................    } 
....................  
....................    // 
....................    // Sixth: Check the URG bit 
....................    // 
....................    // Urgent packets are not supported in this stack, so we 
....................    // will throw them away instead 
....................    if(localHeaderFlags & URG) 
051C0:  BTFSS  xB1.5
051C2:  BRA    51CA
....................       return; 
051C4:  MOVLB  0
051C6:  BRA    5846
051C8:  MOVLB  1
....................  
....................    // 
....................    // Seventh: Process the segment text 
....................    // 
....................    // Throw data away if in a state that doesn't accept data 
....................    if(MyTCBStub.smState == TCP_CLOSE_WAIT) 
051CA:  MOVF   x2E,W
051CC:  SUBLW  0B
051CE:  BNZ   51D6
....................       return; 
051D0:  MOVLB  0
051D2:  BRA    5846
051D4:  MOVLB  1
....................    if(MyTCBStub.smState == TCP_CLOSING) 
051D6:  MOVF   x2E,W
051D8:  SUBLW  0A
051DA:  BNZ   51E2
....................       return; 
051DC:  MOVLB  0
051DE:  BRA    5846
051E0:  MOVLB  1
....................    if(MyTCBStub.smState == TCP_LAST_ACK) 
051E2:  MOVF   x2E,W
051E4:  SUBLW  0C
051E6:  BNZ   51EE
....................       return; 
051E8:  MOVLB  0
051EA:  BRA    5846
051EC:  MOVLB  1
.................... //   if(MyTCBStub.smState == TCP_TIME_WAIT) 
.................... //      return; 
....................  
....................    // Copy any valid segment data into our RX FIFO, if any 
....................    if(len) 
051EE:  MOVF   xA1,W
051F0:  IORWF  xA2,W
051F2:  BTFSC  FD8.2
051F4:  BRA    56C0
....................    { 
....................       // See if there are bytes we must skip 
....................       if((SHORT)wMissingBytes <= 0) 
051F6:  BTFSC  xAE.7
051F8:  BRA    5208
051FA:  MOVF   xAE,F
051FC:  BTFSS  FD8.2
051FE:  BRA    53E8
05200:  MOVF   xAD,W
05202:  SUBLW  00
05204:  BTFSS  FD8.0
05206:  BRA    53E8
....................       { 
....................          // Position packet read pointer to start of useful data area. 
....................          IPSetRxBuffer((h->DataOffset.Val << 2) - wMissingBytes); 
05208:  MOVLW  0C
0520A:  ADDWF  x9F,W
0520C:  MOVWF  FE9
0520E:  MOVLW  00
05210:  ADDWFC xA0,W
05212:  MOVWF  FEA
05214:  MOVFF  FEF,00
05218:  SWAPF  00,W
0521A:  ANDLW  0F
0521C:  MOVWF  00
0521E:  RLCF   00,F
05220:  RLCF   00,F
05222:  MOVLW  FC
05224:  ANDWF  00,F
05226:  MOVF   00,W
05228:  BSF    FD8.0
0522A:  SUBFWB xAD,W
0522C:  MOVWF  xBF
0522E:  MOVLW  00
05230:  SUBFWB xAE,W
05232:  MOVWF  xC0
05234:  MOVWF  xC4
05236:  MOVFF  1BF,1C3
0523A:  MOVLB  0
0523C:  CALL   3FDA
....................          len += wMissingBytes;       
05240:  MOVLB  1
05242:  MOVF   xAD,W
05244:  ADDWF  xA1,F
05246:  MOVF   xAE,W
05248:  ADDWFC xA2,F
....................     
....................          // Truncate packets that would overflow our TCP RX FIFO 
....................          // and request a retransmit by sending a duplicate ACK 
....................          if(len > wFreeSpace) 
0524A:  MOVF   xB0,W
0524C:  SUBWF  xA2,W
0524E:  BNC   5260
05250:  BNZ   5258
05252:  MOVF   xA1,W
05254:  SUBWF  xAF,W
05256:  BC    5260
....................             len = wFreeSpace; 
05258:  MOVFF  1B0,1A2
0525C:  MOVFF  1AF,1A1
....................     
....................          MyTCB.RemoteSEQ += (DWORD)len; 
05260:  MOVFF  1A2,01
05264:  CLRF   02
05266:  CLRF   03
05268:  MOVF   xA1,W
0526A:  MOVLB  0
0526C:  ADDWF  xBC,F
0526E:  MOVF   01,W
05270:  ADDWFC xBD,F
05272:  MOVF   02,W
05274:  ADDWFC xBE,F
05276:  MOVF   03,W
05278:  ADDWFC xBF,F
....................        
....................          // Copy the application data from the packet into the socket RX FIFO 
....................          // See if we need a two part copy (spans bufferEnd->bufferRxStart) 
....................          if(MyTCBStub.rxHead + len > MyTCBStub.bufferEnd) 
0527A:  MOVLB  1
0527C:  MOVF   xA1,W
0527E:  ADDWF  x22,W
05280:  MOVWF  xBF
05282:  MOVF   xA2,W
05284:  ADDWFC x23,W
05286:  MOVWF  xC0
05288:  MOVF   x1D,W
0528A:  SUBWF  xC0,W
0528C:  BNC   531A
0528E:  BNZ   5296
05290:  MOVF   xBF,W
05292:  SUBWF  x1C,W
05294:  BC    531A
....................          { 
....................             wTemp = MyTCBStub.bufferEnd - MyTCBStub.rxHead + 1; 
05296:  MOVF   x22,W
05298:  SUBWF  x1C,W
0529A:  MOVWF  xBF
0529C:  MOVF   x23,W
0529E:  SUBWFB x1D,W
052A0:  MOVWF  xC0
052A2:  MOVLW  01
052A4:  ADDWF  xBF,W
052A6:  MOVWF  xA7
052A8:  MOVLW  00
052AA:  ADDWFC xC0,W
052AC:  MOVWF  xA8
....................             TCPRAMCopy(MyTCBStub.rxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, wTemp); 
052AE:  MOVFF  123,2A4
052B2:  MOVFF  122,2A3
052B6:  MOVFF  133,2A5
052BA:  MOVLB  2
052BC:  SETF   xA7
052BE:  SETF   xA6
052C0:  CLRF   xA8
052C2:  MOVFF  1A8,2AA
052C6:  MOVFF  1A7,2A9
052CA:  MOVLB  0
052CC:  CALL   1224
....................             TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len - wTemp); 
052D0:  MOVLB  1
052D2:  MOVF   xA7,W
052D4:  SUBWF  xA1,W
052D6:  MOVWF  xBF
052D8:  MOVF   xA8,W
052DA:  SUBWFB xA2,W
052DC:  MOVWF  xC0
052DE:  MOVFF  11B,2A4
052E2:  MOVFF  11A,2A3
052E6:  MOVFF  133,2A5
052EA:  MOVLB  2
052EC:  SETF   xA7
052EE:  SETF   xA6
052F0:  CLRF   xA8
052F2:  MOVWF  xAA
052F4:  MOVFF  1BF,2A9
052F8:  MOVLB  0
052FA:  CALL   1224
....................             MyTCBStub.rxHead = MyTCBStub.bufferRxStart + (len - wTemp); 
052FE:  MOVLB  1
05300:  MOVF   xA7,W
05302:  SUBWF  xA1,W
05304:  MOVWF  00
05306:  MOVF   xA8,W
05308:  SUBWFB xA2,W
0530A:  MOVWF  03
0530C:  MOVF   00,W
0530E:  ADDWF  x1A,W
05310:  MOVWF  x22
05312:  MOVF   03,W
05314:  ADDWFC x1B,W
05316:  MOVWF  x23
....................          } 
05318:  BRA    5346
....................          else 
....................          { 
....................             TCPRAMCopy(MyTCBStub.rxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len); 
0531A:  MOVFF  123,2A4
0531E:  MOVFF  122,2A3
05322:  MOVFF  133,2A5
05326:  MOVLB  2
05328:  SETF   xA7
0532A:  SETF   xA6
0532C:  CLRF   xA8
0532E:  MOVFF  1A2,2AA
05332:  MOVFF  1A1,2A9
05336:  MOVLB  0
05338:  CALL   1224
....................             MyTCBStub.rxHead += len; 
0533C:  MOVLB  1
0533E:  MOVF   xA1,W
05340:  ADDWF  x22,F
05342:  MOVF   xA2,W
05344:  ADDWFC x23,F
....................          } 
....................        
....................          // See if we have a hole and other data waiting already in the RX FIFO 
....................          if(MyTCB.sHoleSize != -1) 
05346:  MOVLB  0
05348:  INCFSZ xD4,W
0534A:  BRA    5352
0534C:  INCFSZ xD5,W
0534E:  BRA    5352
05350:  BRA    53E4
....................          { 
....................             MyTCB.sHoleSize -= len; 
05352:  MOVLB  1
05354:  MOVF   xA1,W
05356:  MOVLB  0
05358:  SUBWF  xD4,F
0535A:  MOVLB  1
0535C:  MOVF   xA2,W
0535E:  MOVLB  0
05360:  SUBWFB xD5,F
....................             wTemp = MyTCB.wFutureDataSize + MyTCB.sHoleSize; 
05362:  MOVF   xD4,W
05364:  ADDWF  xC8,W
05366:  MOVWF  01
05368:  MOVF   xD5,W
0536A:  ADDWFC xC9,W
0536C:  MOVFF  01,1A7
05370:  MOVLB  1
05372:  MOVWF  xA8
....................        
....................             // See if we just closed up a hole, and if so, advance head pointer 
....................             if((SHORT)wTemp < (SHORT)0) 
05374:  BTFSS  xA8.7
05376:  BRA    5380
....................             { 
....................                MyTCB.sHoleSize = -1; 
05378:  MOVLB  0
0537A:  SETF   xD5
0537C:  SETF   xD4
....................             } 
0537E:  BRA    53E4
....................             else if(MyTCB.sHoleSize <= 0) 
05380:  MOVLB  0
05382:  BTFSC  xD5.7
05384:  BRA    5390
05386:  MOVF   xD5,F
05388:  BNZ   53E4
0538A:  MOVF   xD4,W
0538C:  SUBLW  00
0538E:  BNC   53E4
....................             { 
....................                MyTCB.RemoteSEQ += wTemp; 
05390:  MOVLB  1
05392:  MOVF   xA7,W
05394:  MOVLB  0
05396:  ADDWF  xBC,F
05398:  MOVLB  1
0539A:  MOVF   xA8,W
0539C:  MOVLB  0
0539E:  ADDWFC xBD,F
053A0:  MOVLW  00
053A2:  ADDWFC xBE,F
053A4:  ADDWFC xBF,F
....................                MyTCBStub.rxHead += wTemp; 
053A6:  MOVLB  1
053A8:  MOVF   xA7,W
053AA:  ADDWF  x22,F
053AC:  MOVF   xA8,W
053AE:  ADDWFC x23,F
....................                if(MyTCBStub.rxHead > MyTCBStub.bufferEnd) 
053B0:  MOVF   x1D,W
053B2:  SUBWF  x23,W
053B4:  BNC   53DE
053B6:  BNZ   53BE
053B8:  MOVF   x22,W
053BA:  SUBWF  x1C,W
053BC:  BC    53DE
....................                   MyTCBStub.rxHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;                      
053BE:  MOVF   x1A,W
053C0:  SUBWF  x1C,W
053C2:  MOVWF  xBF
053C4:  MOVF   x1B,W
053C6:  SUBWFB x1D,W
053C8:  MOVWF  xC0
053CA:  MOVLW  01
053CC:  ADDWF  xBF,W
053CE:  MOVWF  01
053D0:  MOVLW  00
053D2:  ADDWFC xC0,W
053D4:  MOVWF  03
053D6:  MOVF   01,W
053D8:  SUBWF  x22,F
053DA:  MOVF   03,W
053DC:  SUBWFB x23,F
....................                MyTCB.sHoleSize = -1; 
053DE:  MOVLB  0
053E0:  SETF   xD5
053E2:  SETF   xD4
....................             } 
....................          } 
....................       } // This packet is out of order or we lost a packet, see if we can generate a hole to accomodate it 
053E4:  BRA    56BE
053E6:  MOVLB  1
....................       else if((SHORT)wMissingBytes > 0) 
053E8:  BTFSC  xAE.7
053EA:  BRA    56C0
053EC:  MOVF   xAE,F
053EE:  BNZ   53F8
053F0:  MOVF   xAD,W
053F2:  SUBLW  00
053F4:  BTFSC  FD8.0
053F6:  BRA    56C0
....................       { 
....................          // Truncate packets that would overflow our TCP RX FIFO 
....................          if(len + wMissingBytes > wFreeSpace) 
053F8:  MOVF   xAD,W
053FA:  ADDWF  xA1,W
053FC:  MOVWF  xBF
053FE:  MOVF   xAE,W
05400:  ADDWFC xA2,W
05402:  MOVWF  xC0
05404:  MOVF   xB0,W
05406:  SUBWF  xC0,W
05408:  BNC   541E
0540A:  BNZ   5412
0540C:  MOVF   xBF,W
0540E:  SUBWF  xAF,W
05410:  BC    541E
....................             len = wFreeSpace - wMissingBytes; 
05412:  MOVF   xAD,W
05414:  SUBWF  xAF,W
05416:  MOVWF  xA1
05418:  MOVF   xAE,W
0541A:  SUBWFB xB0,W
0541C:  MOVWF  xA2
....................        
....................          // Position packet read pointer to start of useful data area. 
....................          IPSetRxBuffer(h->DataOffset.Val << 2); 
0541E:  MOVLW  0C
05420:  ADDWF  x9F,W
05422:  MOVWF  FE9
05424:  MOVLW  00
05426:  ADDWFC xA0,W
05428:  MOVWF  FEA
0542A:  MOVFF  FEF,00
0542E:  SWAPF  00,W
05430:  ANDLW  0F
05432:  MOVWF  00
05434:  RLCF   00,W
05436:  MOVWF  xBF
05438:  RLCF   xBF,F
0543A:  MOVLW  FC
0543C:  ANDWF  xBF,F
0543E:  CLRF   xC4
05440:  MOVFF  1BF,1C3
05444:  MOVLB  0
05446:  CALL   3FDA
....................     
....................          // See if we need a two part copy (spans bufferEnd->bufferRxStart) 
....................          if(MyTCBStub.rxHead + wMissingBytes + len > MyTCBStub.bufferEnd) 
0544A:  MOVLB  1
0544C:  MOVF   xAD,W
0544E:  ADDWF  x22,W
05450:  MOVWF  xBF
05452:  MOVF   xAE,W
05454:  ADDWFC x23,W
05456:  MOVWF  xC0
05458:  MOVF   xA1,W
0545A:  ADDWF  xBF,F
0545C:  MOVF   xA2,W
0545E:  ADDWFC xC0,F
05460:  MOVF   x1D,W
05462:  SUBWF  xC0,W
05464:  BNC   5544
05466:  BNZ   546E
05468:  MOVF   xBF,W
0546A:  SUBWF  x1C,W
0546C:  BC    5544
....................          { 
....................             // Calculate number of data bytes to copy before wraparound 
....................             wTemp = MyTCBStub.bufferEnd - MyTCBStub.rxHead + 1 - wMissingBytes; 
0546E:  MOVF   x22,W
05470:  SUBWF  x1C,W
05472:  MOVWF  xBF
05474:  MOVF   x23,W
05476:  SUBWFB x1D,W
05478:  MOVWF  xC0
0547A:  MOVLW  01
0547C:  ADDWF  xBF,F
0547E:  MOVLW  00
05480:  ADDWFC xC0,F
05482:  MOVF   xAD,W
05484:  SUBWF  xBF,W
05486:  MOVWF  xA7
05488:  MOVF   xAE,W
0548A:  SUBWFB xC0,W
0548C:  MOVWF  xA8
....................             if((SHORT)wTemp >= 0) 
0548E:  BTFSC  xA8.7
05490:  BRA    54F2
....................             { 
....................                TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, wTemp); 
05492:  MOVF   xAD,W
05494:  ADDWF  x22,W
05496:  MOVWF  xBF
05498:  MOVF   xAE,W
0549A:  ADDWFC x23,W
0549C:  MOVWF  xC0
0549E:  MOVFF  FE8,2A4
054A2:  MOVFF  1BF,2A3
054A6:  MOVFF  133,2A5
054AA:  MOVLB  2
054AC:  SETF   xA7
054AE:  SETF   xA6
054B0:  CLRF   xA8
054B2:  MOVFF  1A8,2AA
054B6:  MOVFF  1A7,2A9
054BA:  MOVLB  0
054BC:  CALL   1224
....................                TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len - wTemp); 
054C0:  MOVLB  1
054C2:  MOVF   xA7,W
054C4:  SUBWF  xA1,W
054C6:  MOVWF  xBF
054C8:  MOVF   xA8,W
054CA:  SUBWFB xA2,W
054CC:  MOVWF  xC0
054CE:  MOVFF  11B,2A4
054D2:  MOVFF  11A,2A3
054D6:  MOVFF  133,2A5
054DA:  MOVLB  2
054DC:  SETF   xA7
054DE:  SETF   xA6
054E0:  CLRF   xA8
054E2:  MOVWF  xAA
054E4:  MOVFF  1BF,2A9
054E8:  MOVLB  0
054EA:  CALL   1224
....................             } 
054EE:  BRA    5540
054F0:  MOVLB  1
....................             else 
....................             { 
....................                TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes - (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1), MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len); 
054F2:  MOVF   xAD,W
054F4:  ADDWF  x22,W
054F6:  MOVWF  xBF
054F8:  MOVF   xAE,W
054FA:  ADDWFC x23,W
054FC:  MOVWF  xC0
054FE:  MOVF   x1A,W
05500:  SUBWF  x1C,W
05502:  MOVWF  xC1
05504:  MOVF   x1B,W
05506:  SUBWFB x1D,W
05508:  MOVWF  xC2
0550A:  MOVLW  01
0550C:  ADDWF  xC1,W
0550E:  MOVWF  01
05510:  MOVLW  00
05512:  ADDWFC xC2,W
05514:  MOVWF  03
05516:  MOVF   01,W
05518:  SUBWF  xBF,F
0551A:  MOVF   03,W
0551C:  SUBWFB xC0,F
0551E:  MOVFF  1C0,2A4
05522:  MOVFF  1BF,2A3
05526:  MOVFF  133,2A5
0552A:  MOVLB  2
0552C:  SETF   xA7
0552E:  SETF   xA6
05530:  CLRF   xA8
05532:  MOVFF  1A2,2AA
05536:  MOVFF  1A1,2A9
0553A:  MOVLB  0
0553C:  CALL   1224
....................             } 
....................          } 
05540:  BRA    5572
05542:  MOVLB  1
....................          else 
....................          { 
....................             TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len); 
05544:  MOVF   xAD,W
05546:  ADDWF  x22,W
05548:  MOVWF  xBF
0554A:  MOVF   xAE,W
0554C:  ADDWFC x23,W
0554E:  MOVWF  xC0
05550:  MOVFF  FE8,2A4
05554:  MOVFF  1BF,2A3
05558:  MOVFF  133,2A5
0555C:  MOVLB  2
0555E:  SETF   xA7
05560:  SETF   xA6
05562:  CLRF   xA8
05564:  MOVFF  1A2,2AA
05568:  MOVFF  1A1,2A9
0556C:  MOVLB  0
0556E:  CALL   1224
....................          } 
....................        
....................          // Record the hole is here 
....................          if(MyTCB.sHoleSize == -1) 
05572:  INCFSZ xD4,W
05574:  BRA    558C
05576:  INCFSZ xD5,W
05578:  BRA    558C
....................          { 
....................             MyTCB.sHoleSize = wMissingBytes; 
0557A:  MOVFF  1AE,D5
0557E:  MOVFF  1AD,D4
....................             MyTCB.wFutureDataSize = len; 
05582:  MOVFF  1A2,C9
05586:  MOVFF  1A1,C8
....................          } 
0558A:  BRA    56BE
....................          else 
....................          { 
....................             // We already have a hole, see if we can shrink the hole  
....................             // or extend the future data size 
....................             if(wMissingBytes < (WORD)MyTCB.sHoleSize) 
0558C:  MOVLB  1
0558E:  MOVF   xAE,W
05590:  MOVLB  0
05592:  SUBWF  xD5,W
05594:  BNC   5638
05596:  BNZ   55A8
05598:  MOVF   xD4,W
0559A:  MOVLB  1
0559C:  SUBWF  xAD,W
0559E:  BTFSS  FD8.0
055A0:  BRA    55A6
055A2:  MOVLB  0
055A4:  BRA    5638
055A6:  MOVLB  0
....................             { 
....................                if((wMissingBytes + len > (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize) || (wMissingBytes + len < (WORD)MyTCB.sHoleSize)) 
055A8:  MOVLB  1
055AA:  MOVF   xA1,W
055AC:  ADDWF  xAD,W
055AE:  MOVWF  xBF
055B0:  MOVF   xA2,W
055B2:  ADDWFC xAE,W
055B4:  MOVWF  xC0
055B6:  MOVLB  0
055B8:  MOVF   xC8,W
055BA:  ADDWF  xD4,W
055BC:  MOVWF  01
055BE:  MOVF   xC9,W
055C0:  ADDWFC xD5,W
055C2:  MOVWF  03
055C4:  MOVF   03,W
055C6:  MOVLB  1
055C8:  SUBWF  xC0,W
055CA:  BNC   55D4
055CC:  BNZ   55FC
055CE:  MOVF   xBF,W
055D0:  SUBWF  01,W
055D2:  BNC   55FC
055D4:  MOVF   xA1,W
055D6:  ADDWF  xAD,W
055D8:  MOVWF  xBF
055DA:  MOVF   xA2,W
055DC:  ADDWFC xAE,W
055DE:  MOVWF  xC0
055E0:  MOVLB  0
055E2:  SUBWF  xD5,W
055E4:  BNC   5608
055E6:  BTFSC  FD8.2
055E8:  BRA    55EE
055EA:  MOVLB  1
055EC:  BRA    55FC
055EE:  MOVF   xD4,W
055F0:  MOVLB  1
055F2:  SUBWF  xBF,W
055F4:  BTFSS  FD8.0
055F6:  BRA    55FC
055F8:  MOVLB  0
055FA:  BRA    5608
....................                   MyTCB.wFutureDataSize = len; 
055FC:  MOVFF  1A2,C9
05600:  MOVFF  1A1,C8
05604:  BRA    562E
05606:  MOVLB  0
....................                else 
....................                   MyTCB.wFutureDataSize = (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize - wMissingBytes; 
05608:  MOVF   xC8,W
0560A:  ADDWF  xD4,W
0560C:  MOVLB  1
0560E:  MOVWF  xBF
05610:  MOVLB  0
05612:  MOVF   xC9,W
05614:  ADDWFC xD5,W
05616:  MOVLB  1
05618:  MOVWF  xC0
0561A:  MOVF   xAD,W
0561C:  SUBWF  xBF,W
0561E:  MOVLB  0
05620:  MOVWF  xC8
05622:  MOVLB  1
05624:  MOVF   xAE,W
05626:  SUBWFB xC0,W
05628:  MOVLB  0
0562A:  MOVWF  xC9
0562C:  MOVLB  1
....................                MyTCB.sHoleSize = wMissingBytes; 
0562E:  MOVFF  1AE,D5
05632:  MOVFF  1AD,D4
....................             } 
05636:  BRA    56C0
....................             else if(wMissingBytes + len > (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize) 
05638:  MOVLB  1
0563A:  MOVF   xA1,W
0563C:  ADDWF  xAD,W
0563E:  MOVWF  xBF
05640:  MOVF   xA2,W
05642:  ADDWFC xAE,W
05644:  MOVWF  xC0
05646:  MOVLB  0
05648:  MOVF   xC8,W
0564A:  ADDWF  xD4,W
0564C:  MOVWF  01
0564E:  MOVF   xC9,W
05650:  ADDWFC xD5,W
05652:  MOVWF  03
05654:  MOVF   03,W
05656:  MOVLB  1
05658:  SUBWF  xC0,W
0565A:  BNC   56C0
0565C:  BNZ   5664
0565E:  MOVF   xBF,W
05660:  SUBWF  01,W
05662:  BC    56C0
....................             { 
....................                // Make sure that there isn't a second hole between  
....................                // our future data and this TCP segment's future data 
....................                if(wMissingBytes <= (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize) 
05664:  MOVLB  0
05666:  MOVF   xC8,W
05668:  ADDWF  xD4,W
0566A:  MOVWF  01
0566C:  MOVF   xC9,W
0566E:  ADDWFC xD5,W
05670:  MOVWF  03
05672:  MOVF   01,W
05674:  MOVLB  1
05676:  MOVF   xAE,W
05678:  SUBWF  03,W
0567A:  BNC   56C0
0567C:  BNZ   5684
0567E:  MOVF   xAD,W
05680:  SUBWF  01,W
05682:  BNC   56C0
....................                   MyTCB.wFutureDataSize += wMissingBytes + len - (WORD)MyTCB.sHoleSize - MyTCB.wFutureDataSize; 
05684:  MOVF   xA1,W
05686:  ADDWF  xAD,W
05688:  MOVWF  xBF
0568A:  MOVF   xA2,W
0568C:  ADDWFC xAE,W
0568E:  MOVWF  xC0
05690:  MOVLB  0
05692:  MOVF   xD4,W
05694:  MOVLB  1
05696:  SUBWF  xBF,F
05698:  MOVLB  0
0569A:  MOVF   xD5,W
0569C:  MOVLB  1
0569E:  SUBWFB xC0,F
056A0:  MOVLB  0
056A2:  MOVF   xC8,W
056A4:  MOVLB  1
056A6:  SUBWF  xBF,W
056A8:  MOVWF  00
056AA:  MOVLB  0
056AC:  MOVF   xC9,W
056AE:  MOVLB  1
056B0:  SUBWFB xC0,W
056B2:  MOVWF  03
056B4:  MOVF   00,W
056B6:  MOVLB  0
056B8:  ADDWF  xC8,F
056BA:  MOVF   03,W
056BC:  ADDWFC xC9,F
056BE:  MOVLB  1
....................             } 
....................              
....................          } 
....................       } 
....................    } 
....................  
....................    // Send back an ACK of the data (+SYN | FIN) we just received,  
....................    // if any.  To minimize bandwidth waste, we are implementing  
....................    // the delayed acknowledgement algorithm here, only sending  
....................    // back an immediate ACK if this is the second segment received.   
....................    // Otherwise, a 200ms timer will cause the ACK to be transmitted. 
....................    if(wSegmentLength) 
056C0:  MOVF   xBA,W
056C2:  IORWF  xBB,W
056C4:  BZ    570C
....................    { 
....................       // For non-established sockets, let's delete all data in  
....................       // the RX buffer immediately after receiving it.  This is  
....................       // not really how TCP was intended to operate since a  
....................       // socket cannot receive any response after it sends a FIN, 
....................       // but our TCP application API doesn't readily accomodate 
....................       // receiving data after calling TCPDisconnect(), which  
....................       // invalidates the application TCP handle.  By deleting all  
....................       // data, we'll ensure that the RX window is nonzero and  
....................       // the remote node will be able to send us a FIN response,  
....................       // which needs an RX window of at least 1. 
....................       if(MyTCBStub.smState != TCP_ESTABLISHED) 
056C6:  MOVF   x2E,W
056C8:  SUBLW  07
056CA:  BZ    56D4
....................          MyTCBStub.rxTail = MyTCBStub.rxHead; 
056CC:  MOVFF  123,125
056D0:  MOVFF  122,124
....................  
....................       if(MyTCBStub.Flags.bOneSegmentReceived) 
056D4:  BTFSS  x2F.7
056D6:  BRA    56F0
....................       { 
....................          SendTCP(ACK, SENDTCP_RESET_TIMERS); 
056D8:  MOVLW  10
056DA:  MOVLB  2
056DC:  MOVWF  x72
056DE:  MOVLW  01
056E0:  MOVWF  x73
056E2:  MOVLB  0
056E4:  CALL   26A2
....................          SyncTCB(); 
056E8:  CALL   130A
....................          // bOneSegmentReceived is cleared in SendTCP(), so no need here 
....................       } 
056EC:  BRA    570E
056EE:  MOVLB  1
....................       else 
....................       { 
....................          MyTCBStub.Flags.bOneSegmentReceived = TRUE;    
056F0:  BSF    x2F.7
....................        
....................          // Do not send an ACK immediately back.  Instead, we will  
....................          // perform delayed acknowledgements.  To do this, we will  
....................          // just start a timer 
....................          if(!MyTCBStub.Flags.bDelayedACKTimerEnabled) 
056F2:  BTFSC  x2F.6
056F4:  BRA    570C
....................          { 
....................             MyTCBStub.Flags.bDelayedACKTimerEnabled = 1; 
056F6:  BSF    x2F.6
....................             MyTCBStub.OverlappedTimers.delayedACKTime = (WORD)TickGetDiv256() + (WORD)((TCP_DELAYED_ACK_TIMEOUT)>>8); 
056F8:  MOVLB  0
056FA:  CALL   1A7C
056FE:  MOVLW  0F
05700:  MOVLB  1
05702:  ADDWF  00,W
05704:  MOVWF  x2C
05706:  MOVLW  00
05708:  ADDWFC 01,W
0570A:  MOVWF  x2D
0570C:  MOVLB  0
....................          } 
....................       } 
....................    } 
....................  
....................    // 
....................    // Eighth: check the FIN bit 
....................    // 
....................    if(localHeaderFlags & FIN) 
0570E:  MOVLB  1
05710:  BTFSS  xB1.0
05712:  BRA    5848
....................    { 
....................       // Note: Since we don't have a good means of storing "FIN bytes"  
....................       // in our TCP RX FIFO, we must ensure that FINs are processed  
....................       // in-order. 
....................       if(MyTCB.RemoteSEQ + 1 == localSeqNumber + (DWORD)wSegmentLength) 
05714:  MOVLW  01
05716:  MOVLB  0
05718:  ADDWF  xBC,W
0571A:  MOVLB  1
0571C:  MOVWF  xBF
0571E:  MOVLW  00
05720:  MOVLB  0
05722:  ADDWFC xBD,W
05724:  MOVLB  1
05726:  MOVWF  xC0
05728:  MOVLW  00
0572A:  MOVLB  0
0572C:  ADDWFC xBE,W
0572E:  MOVLB  1
05730:  MOVWF  xC1
05732:  MOVLW  00
05734:  MOVLB  0
05736:  ADDWFC xBF,W
05738:  MOVLB  1
0573A:  MOVWF  xC2
0573C:  MOVFF  1BA,00
05740:  MOVFF  1BB,01
05744:  CLRF   02
05746:  CLRF   03
05748:  MOVF   xB6,W
0574A:  ADDWF  00,F
0574C:  MOVF   xB7,W
0574E:  ADDWFC 01,F
05750:  MOVF   xB8,W
05752:  ADDWFC 02,F
05754:  MOVF   xB9,W
05756:  ADDWFC 03,F
05758:  MOVF   00,W
0575A:  SUBWF  xBF,W
0575C:  BTFSS  FD8.2
0575E:  BRA    5848
05760:  MOVF   01,W
05762:  SUBWF  xC0,W
05764:  BTFSS  FD8.2
05766:  BRA    5848
05768:  MOVF   02,W
0576A:  SUBWF  xC1,W
0576C:  BTFSS  FD8.2
0576E:  BRA    5848
05770:  MOVF   03,W
05772:  SUBWF  xC2,W
05774:  BTFSS  FD8.2
05776:  BRA    5848
....................       { 
....................          // FINs are treated as one byte of data for ACK sequencing 
....................          MyTCB.RemoteSEQ++; 
05778:  MOVLW  01
0577A:  MOVLB  0
0577C:  ADDWF  xBC,F
0577E:  BTFSC  FD8.0
05780:  INCF   xBD,F
05782:  BTFSC  FD8.2
05784:  INCF   xBE,F
05786:  BTFSC  FD8.2
05788:  INCF   xBF,F
....................           
....................          switch(MyTCBStub.smState) 
0578A:  MOVLB  1
0578C:  MOVF   x2E,W
0578E:  XORLW  06
05790:  MOVLB  0
05792:  BZ    57A2
05794:  XORLW  01
05796:  BZ    57BA
05798:  XORLW  0F
0579A:  BZ    57D6
0579C:  XORLW  01
0579E:  BZ    5820
057A0:  BRA    5834
....................          { 
....................             case TCP_SYN_RECEIVED: 
....................                // RFC in exact: Our API has no need for the user  
....................                // to explicitly close a socket that never really  
....................                // got opened fully in the first place, so just  
....................                // transmit a FIN automatically and jump to  
....................                // TCP_LAST_ACK 
....................                MyTCBStub.smState = TCP_LAST_ACK; 
057A2:  MOVLW  0C
057A4:  MOVLB  1
057A6:  MOVWF  x2E
....................                SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS); 
057A8:  MOVLW  11
057AA:  MOVLB  2
057AC:  MOVWF  x72
057AE:  MOVLW  01
057B0:  MOVWF  x73
057B2:  MOVLB  0
057B4:  CALL   26A2
....................                return; 
057B8:  BRA    5846
....................  
....................             case TCP_ESTABLISHED: 
....................                // Go to TCP_CLOSE_WAIT state 
....................                MyTCBStub.smState = TCP_CLOSE_WAIT; 
057BA:  MOVLW  0B
057BC:  MOVLB  1
057BE:  MOVWF  x2E
....................                 
....................                // For legacy applications that don't call  
....................                // TCPDisconnect() as needed and expect the TCP/IP  
....................                // Stack to automatically close sockets when the  
....................                // remote node sends a FIN, let's start a timer so  
....................                // that we will eventually close the socket automatically 
....................                MyTCBStub.OverlappedTimers.closeWaitTime = (WORD)TickGetDiv256() + (WORD)((TCP_CLOSE_WAIT_TIMEOUT)>>8); 
057C0:  MOVLB  0
057C2:  CALL   1A7C
057C6:  MOVLW  1E
057C8:  MOVLB  1
057CA:  ADDWF  00,W
057CC:  MOVWF  x2C
057CE:  MOVLW  00
057D0:  ADDWFC 01,W
057D2:  MOVWF  x2D
....................                break; 
057D4:  BRA    5836
....................     
....................             case TCP_FIN_WAIT_1: 
....................                if(MyTCB.MySEQ == localAckNumber) 
057D6:  MOVLB  1
057D8:  MOVF   xB2,W
057DA:  MOVLB  0
057DC:  SUBWF  xB8,W
057DE:  BNZ   5814
057E0:  MOVLB  1
057E2:  MOVF   xB3,W
057E4:  MOVLB  0
057E6:  SUBWF  xB9,W
057E8:  BNZ   5814
057EA:  MOVLB  1
057EC:  MOVF   xB4,W
057EE:  MOVLB  0
057F0:  SUBWF  xBA,W
057F2:  BNZ   5814
057F4:  MOVLB  1
057F6:  MOVF   xB5,W
057F8:  MOVLB  0
057FA:  SUBWF  xBB,W
057FC:  BNZ   5814
....................                { 
....................                   // RFC not recommended: We should be going to  
....................                   // the TCP_TIME_WAIT state right here and  
....................                   // starting a 2MSL timer, but since we have so  
....................                   // few precious sockets, we can't afford to  
....................                   // leave a socket waiting around doing nothing  
....................                   // for a long time.  If the remote node does  
....................                   // not recieve this ACK, it'll have to figure  
....................                   // out on it's own that the connection is now  
....................                   // closed. 
....................                   SendTCP(ACK, 0); 
057FE:  MOVLW  10
05800:  MOVLB  2
05802:  MOVWF  x72
05804:  CLRF   x73
05806:  MOVLB  0
05808:  CALL   26A2
....................                   CloseSocket(); 
0580C:  CALL   13DE
....................                   return; 
05810:  BRA    5846
....................                } 
05812:  BRA    581C
....................                else 
....................                { 
....................                   MyTCBStub.smState = TCP_CLOSING; 
05814:  MOVLW  0A
05816:  MOVLB  1
05818:  MOVWF  x2E
0581A:  MOVLB  0
....................                } 
....................                break; 
0581C:  MOVLB  1
0581E:  BRA    5836
....................     
....................             case TCP_FIN_WAIT_2: 
....................                // RFC not recommended: We should be going to  
....................                // the TCP_TIME_WAIT state right here and  
....................                // starting a 2MSL timer, but since we have so  
....................                // few precious sockets, we can't afford to  
....................                // leave a socket waiting around doing nothing  
....................                // for a long time.  If the remote node does  
....................                // not recieve this ACK, it'll have to figure  
....................                // out on it's own that the connection is now  
....................                // closed. 
....................                SendTCP(ACK, 0); 
05820:  MOVLW  10
05822:  MOVLB  2
05824:  MOVWF  x72
05826:  CLRF   x73
05828:  MOVLB  0
0582A:  CALL   26A2
....................                CloseSocket(); 
0582E:  CALL   13DE
....................                return; 
05832:  BRA    5846
....................  
....................             default: 
....................                break; 
05834:  MOVLB  1
....................          } 
....................  
....................          // Acknowledge receipt of FIN 
....................          SendTCP(ACK, SENDTCP_RESET_TIMERS); 
05836:  MOVLW  10
05838:  MOVLB  2
0583A:  MOVWF  x72
0583C:  MOVLW  01
0583E:  MOVWF  x73
05840:  MOVLB  0
05842:  CALL   26A2
05846:  MOVLB  1
....................       } 
....................    } 
05848:  MOVLB  0
0584A:  GOTO   59BE (RETURN)
.................... } 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Buffer Management Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPAdjustFIFOSize(TCP_SOCKET hTCP, WORD wMinRXSize,  
....................                      WORD wMinTXSize, BYTE vFlags) 
....................  
....................   Summary: 
....................    Adjusts the relative sizes of the RX and TX buffers. 
....................  
....................   Description: 
....................    This function can be used to adjust the relative sizes of the RX and 
....................    TX FIFO depending on the immediate needs of an application.  Since a  
....................    larger FIFO can allow more data to be sent in a given packet, adjusting  
....................    the relative sizes on the fly can allow for optimal transmission speed  
....................    for one-sided application protocols.  For example, HTTP typically  
....................    begins by receiving large amounts of data from the client, then switches 
....................    to serving large amounts of data back.  Adjusting the FIFO at these  
....................    points can increase performance substantially.  Once the FIFO is 
....................    adjusted, a window update is sent. 
....................     
....................    If neither or both of TCP_ADJUST_GIVE_REST_TO_TX and  
....................    TCP_ADJUST_GIVE_REST_TO_RX are set, the function distributes the 
....................    remaining space equally. 
....................     
....................    Received data can be preserved as long as the buffer is expanding and  
....................    has not wrapped. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP      - The socket to be adjusted 
....................    wMinRXSize   - Minimum number of byte for the RX FIFO 
....................    wMinTXSize    - Minimum number of bytes for the RX FIFO 
....................    vFlags      - Any combination of TCP_ADJUST_GIVE_REST_TO_RX,  
....................               TCP_ADJUST_GIVE_REST_TO_TX, TCP_ADJUST_PRESERVE_RX. 
....................               TCP_ADJUST_PRESERVE_TX is not currently supported. 
....................  
....................   Return Values: 
....................    TRUE - The FIFOs were adjusted successfully 
....................    FALSE - Minimum RX, Minimum TX, or flags couldn't be accommodated and 
....................          therefore the socket was left unchanged. 
....................  
....................   Side Effects: 
....................    Any unacknowledged or untransmitted data in the TX FIFO is always 
....................    deleted. 
....................  
....................   Remarks: 
....................    At least one byte must always be allocated to the RX buffer so that 
....................    a FIN can be received.  The function automatically corrects for this. 
....................   ***************************************************************************/ 
.................... BOOL TCPAdjustFIFOSize(TCP_SOCKET hTCP, WORD wMinRXSize, WORD wMinTXSize, BYTE vFlags) 
.................... { 
....................    PTR_BASE ptrTemp, ptrHead; 
....................    WORD wTXAllocation; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    // Load up info on this socket 
....................    SyncTCBStub(hTCP); 
....................  
....................    // RX has to be at least 1 byte to receive SYN and FIN bytes  
....................    // from the remote node, even if they aren't stored in the RX FIFO 
....................    if(wMinRXSize == 0u) 
....................       wMinRXSize = 1; 
....................        
....................    // SSL connections need to be able to send or receive at least  
....................    // a full Alert record, MAC, and FIN 
....................    #if defined(STACK_USE_SSL) 
....................    if(TCPIsSSL(hTCP) && wMinRXSize < 25u) 
....................       wMinRXSize = 25; 
....................    if(TCPIsSSL(hTCP) && wMinTXSize < 25u) 
....................       wMinTXSize = 25; 
....................    #endif 
....................     
....................    // Make sure space is available for minimums 
....................    ptrTemp = MyTCBStub.bufferEnd - MyTCBStub.bufferTxStart - 1; 
....................    if(wMinRXSize + wMinTXSize > ptrTemp) 
....................       return FALSE; 
....................  
....................    SyncTCB(); 
....................  
....................    // Set both allocation flags if none set 
....................    if(!(vFlags & (TCP_ADJUST_GIVE_REST_TO_TX | TCP_ADJUST_GIVE_REST_TO_RX))) 
....................       vFlags |= TCP_ADJUST_GIVE_REST_TO_TX | TCP_ADJUST_GIVE_REST_TO_RX; 
....................        
....................  
....................    // Allocate minimums 
....................    wTXAllocation = wMinTXSize; 
....................    ptrTemp -= wMinRXSize + wMinTXSize; 
....................  
....................    // Allocate extra 
....................    if(vFlags & TCP_ADJUST_GIVE_REST_TO_TX) 
....................    { 
....................       if(vFlags & TCP_ADJUST_GIVE_REST_TO_RX) 
....................       { 
....................          // Do a 50%/50% split with any odd byte always going to the RX FIFO 
....................          wTXAllocation += ptrTemp>>1; 
....................       } 
....................       else 
....................       { 
....................          wTXAllocation += ptrTemp; 
....................       } 
....................    } 
....................  
....................    // Calculate new bufferRxStart pointer 
....................    ptrTemp = MyTCBStub.bufferTxStart + wTXAllocation + 1; 
....................  
....................    // Find the head pointer to use 
....................    ptrHead = MyTCBStub.rxHead; 
....................    #if defined(STACK_USE_SSL) 
....................    if(TCPIsSSL(hTCP)) 
....................       ptrHead = MyTCBStub.sslRxHead; 
....................    #endif 
....................     
....................    // If there's out-of-order data pending, adjust the head pointer to compensate 
....................    if(MyTCB.sHoleSize != -1) 
....................    { 
....................       ptrHead += MyTCB.sHoleSize + MyTCB.wFutureDataSize; 
....................       if(ptrHead > MyTCBStub.bufferEnd) 
....................          ptrHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................    } 
....................  
....................    // Determine if resizing will lose any RX data 
....................    if(MyTCBStub.rxTail < ptrHead) 
....................    { 
....................       if(ptrTemp > MyTCBStub.rxTail) 
....................       { 
....................          if(vFlags & TCP_ADJUST_PRESERVE_RX) 
....................             return FALSE; 
....................          else 
....................          { 
....................             MyTCBStub.rxTail = ptrTemp; 
....................             MyTCBStub.rxHead = ptrTemp; 
....................  
....................             #if defined(STACK_USE_SSL) 
....................             MyTCBStub.sslRxHead = ptrTemp; 
....................             #endif 
....................          } 
....................       } 
....................    } 
....................    else if(MyTCBStub.rxTail > ptrHead) 
....................    { 
....................       if(ptrTemp > MyTCBStub.bufferRxStart) 
....................       { 
....................          if(vFlags & TCP_ADJUST_PRESERVE_RX) 
....................             return FALSE; 
....................          else 
....................          { 
....................             MyTCBStub.rxTail = ptrTemp; 
....................             MyTCBStub.rxHead = ptrTemp; 
....................              
....................             #if defined(STACK_USE_SSL) 
....................             MyTCBStub.sslRxHead = ptrTemp; 
....................             #endif 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       // No data to preserve, but we may need to move  
....................       // the pointers to stay in the RX space 
....................       MyTCBStub.rxTail = ptrTemp; 
....................       MyTCBStub.rxHead = ptrTemp; 
....................        
....................       #if defined(STACK_USE_SSL) 
....................       MyTCBStub.sslRxHead = ptrTemp; 
....................       #endif 
....................    } 
....................     
....................    // If we need to preserve data that wrapped in the ring, we must copy 
....................    if(ptrHead < MyTCBStub.rxTail && (vFlags & TCP_ADJUST_PRESERVE_RX)) 
....................    { 
....................       TCPRAMCopy(ptrTemp, MyTCBStub.vMemoryMedium,  
....................          MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, 
....................          ptrHead - MyTCBStub.bufferRxStart); 
....................  
....................       // Move the pointers if they were in front of the tail 
....................       #if defined(STACK_USE_SSL) 
....................       if(TCPIsSSL(hTCP) && MyTCBStub.sslRxHead < MyTCBStub.rxTail) 
....................          MyTCBStub.sslRxHead -= MyTCBStub.bufferRxStart - ptrTemp; 
....................       #endif 
....................       if(MyTCBStub.rxHead < MyTCBStub.rxTail) 
....................          MyTCBStub.rxHead -= MyTCBStub.bufferRxStart - ptrTemp; 
....................    } 
....................     
....................    // Move the RX buffer pointer - it's the one that divides the two 
....................    MyTCBStub.bufferRxStart = ptrTemp; 
....................  
....................    // Empty the TX buffer 
....................    MyTCB.txUnackedTail = MyTCBStub.bufferTxStart; 
....................    MyTCBStub.txTail = MyTCBStub.bufferTxStart; 
....................    MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................     
....................    #if defined(STACK_USE_SSL) 
....................    if(TCPIsSSL(hTCP)) 
....................       MyTCBStub.sslTxHead = MyTCBStub.txHead + 5; 
....................    #endif 
....................     
....................    // Send a window update to notify remote node of change 
....................    if(MyTCBStub.smState == TCP_ESTABLISHED) 
....................       SendTCP(ACK, SENDTCP_RESET_TIMERS); 
....................  
....................    return TRUE; 
....................  
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void TCPRAMCopy(PTR_BASE ptrDest, BYTE vDestType, PTR_BASE ptrSource,  
....................                      BYTE vSourceType, WORD wLength) 
....................  
....................   Summary: 
....................    Copies data to/from various memory mediums. 
....................  
....................   Description: 
....................    This function copies data between memory mediums (PIC RAM, SPI 
....................    RAM, and Ethernet buffer RAM). 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    ptrDest      - Address to write to 
....................    vDestType   - Destination meidum (TCP_PIC_RAM, TCP_ETH_RAM, TCP_SPI_RAM) 
....................    ptrSource   - Address to copy from 
....................    vSourceType - Source medium (TCP_PIC_RAM, TCP_ETH_RAM, or TCP_SPI_RAM) 
....................    wLength      - Number of bytes to copy 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    Copying to a destination region that overlaps with the source address  
....................    is supported only if the destination start address is at a lower memory  
....................    address (closer to 0x0000) than the source pointer.  However, if they do  
....................    overlap there must be at least 4 bytes of non-overlap to ensure correct  
....................    results due to hardware DMA requirements. 
....................   ***************************************************************************/ 
.................... static void TCPRAMCopy(PTR_BASE ptrDest, BYTE vDestType, PTR_BASE ptrSource, BYTE vSourceType, WORD wLength) 
.................... { 
....................    #if defined(SPIRAM_CS_TRIS) 
....................    BYTE vBuffer[16]; 
....................    WORD w; 
....................    #endif 
....................        
....................    switch(vSourceType) 
*
01224:  MOVLB  2
01226:  MOVF   xA8,W
01228:  XORLW  01
0122A:  MOVLB  0
0122C:  BZ    1234
0122E:  XORLW  01
01230:  BZ    12A6
01232:  BRA    1308
....................    { 
....................       case TCP_PIC_RAM: 
....................          switch(vDestType) 
01234:  MOVLB  2
01236:  MOVF   xA5,W
01238:  XORLW  01
0123A:  MOVLB  0
0123C:  BZ    1244
0123E:  XORLW  01
01240:  BZ    1276
01242:  BRA    12A4
....................          { 
....................             case TCP_PIC_RAM: 
....................                memcpy((void*)(BYTE*)ptrDest, (void*)(BYTE*)ptrSource, wLength); 
01244:  MOVFF  2A4,FEA
01248:  MOVFF  2A3,FE9
0124C:  MOVFF  2A7,FE2
01250:  MOVFF  2A6,FE1
01254:  MOVFF  2AA,02
01258:  MOVFF  2A9,01
0125C:  MOVF   01,F
0125E:  BZ    1264
01260:  INCF   02,F
01262:  BRA    1268
01264:  MOVF   02,F
01266:  BZ    1274
01268:  MOVFF  FE6,FEE
0126C:  DECFSZ 01,F
0126E:  BRA    1268
01270:  DECFSZ 02,F
01272:  BRA    1268
....................                break; 
01274:  BRA    12A4
....................     
....................             case TCP_ETH_RAM: 
....................                if(ptrDest!=(PTR_BASE)-1) 
01276:  MOVLB  2
01278:  INCFSZ xA3,W
0127A:  BRA    1282
0127C:  INCFSZ xA4,W
0127E:  BRA    1282
01280:  BRA    1290
....................                   MACSetWritePtr(ptrDest); 
01282:  MOVFF  2A4,2AC
01286:  MOVFF  2A3,2AB
0128A:  MOVLB  0
0128C:  RCALL  0DBA
0128E:  MOVLB  2
....................                MACPutArray((BYTE*)ptrSource, wLength); 
01290:  MOVFF  2A7,2C1
01294:  MOVFF  2A6,2C0
01298:  MOVFF  2AA,2C3
0129C:  MOVFF  2A9,2C2
012A0:  MOVLB  0
012A2:  RCALL  0E2A
....................                break; 
....................     
....................             #if defined(SPIRAM_CS_TRIS) 
....................             case TCP_SPI_RAM: 
....................                SPIRAMPutArray(ptrDest, (BYTE*)ptrSource, wLength); 
....................                break; 
....................             #endif 
....................          } 
....................          break; 
012A4:  BRA    1308
....................     
....................       case TCP_ETH_RAM: 
....................          switch(vDestType) 
012A6:  MOVLB  2
012A8:  MOVF   xA5,W
012AA:  XORLW  01
012AC:  MOVLB  0
012AE:  BZ    12B6
012B0:  XORLW  01
012B2:  BZ    12E6
012B4:  BRA    1306
....................          { 
....................             case TCP_PIC_RAM: 
....................                if(ptrSource!=(PTR_BASE)-1) 
012B6:  MOVLB  2
012B8:  INCFSZ xA6,W
012BA:  BRA    12C2
012BC:  INCFSZ xA7,W
012BE:  BRA    12C2
012C0:  BRA    12D0
....................                   MACSetReadPtr(ptrSource); 
012C2:  MOVFF  2A7,2AC
012C6:  MOVFF  2A6,2AB
012CA:  MOVLB  0
012CC:  RCALL  0E70
012CE:  MOVLB  2
....................                MACGetArray((BYTE*)ptrDest, wLength); 
012D0:  MOVFF  2A4,2BF
012D4:  MOVFF  2A3,2BE
012D8:  MOVFF  2AA,2C1
012DC:  MOVFF  2A9,2C0
012E0:  MOVLB  0
012E2:  RCALL  0EDC
....................                break; 
012E4:  BRA    1306
....................     
....................             case TCP_ETH_RAM: 
....................                MACMemCopyAsync(ptrDest, ptrSource, wLength); 
012E6:  MOVFF  2A4,2AC
012EA:  MOVFF  2A3,2AB
012EE:  MOVFF  2A7,2AE
012F2:  MOVFF  2A6,2AD
012F6:  MOVFF  2AA,2B0
012FA:  MOVFF  2A9,2AF
012FE:  RCALL  0F7C
....................                while(!MACIsMemCopyDone()); 
01300:  RCALL  11FC
01302:  MOVF   01,F
01304:  BZ    1300
....................                break; 
....................     
....................             #if defined(SPIRAM_CS_TRIS) 
....................             case TCP_SPI_RAM: 
....................                if(ptrSource!=(PTR_BASE)-1) 
....................                   MACSetReadPtr(ptrSource); 
....................                w = sizeof(vBuffer); 
....................                while(wLength) 
....................                { 
....................                   if(w > wLength) 
....................                      w = wLength; 
....................                    
....................                   // Read and write a chunk    
....................                   MACGetArray(vBuffer, w); 
....................                   SPIRAMPutArray(ptrDest, vBuffer, w); 
....................                   ptrDest += w; 
....................                   wLength -= w; 
....................                } 
....................                break; 
....................             #endif 
....................          } 
....................          break; 
01306:  BRA    1308
....................     
....................       #if defined(SPIRAM_CS_TRIS) 
....................       case TCP_SPI_RAM: 
....................          switch(vDestType) 
....................          { 
....................             case TCP_PIC_RAM: 
....................                SPIRAMGetArray(ptrSource, (BYTE*)ptrDest, wLength); 
....................                break; 
....................     
....................             case TCP_ETH_RAM: 
....................                if(ptrDest!=(PTR_BASE)-1) 
....................                   MACSetWritePtr(ptrDest); 
....................                w = sizeof(vBuffer); 
....................                while(wLength) 
....................                { 
....................                   if(w > wLength) 
....................                      w = wLength; 
....................                    
....................                   // Read and write a chunk    
....................                   SPIRAMGetArray(ptrSource, vBuffer, w); 
....................                   ptrSource += w; 
....................                   MACPutArray(vBuffer, w); 
....................                   wLength -= w; 
....................                } 
....................                break; 
....................     
....................             case TCP_SPI_RAM: 
....................                // Copy all of the data over in chunks 
....................                w = sizeof(vBuffer); 
....................                while(wLength) 
....................                { 
....................                   if(w > wLength) 
....................                      w = wLength; 
....................                       
....................                   SPIRAMGetArray(ptrSource, vBuffer, w); 
....................                   SPIRAMPutArray(ptrDest, vBuffer, w); 
....................                   ptrSource += w; 
....................                   ptrDest += w; 
....................                   wLength -= w; 
....................                } 
....................                break; 
....................          } 
....................          break; 
....................       #endif          
....................    } 
01308:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void TCPRAMCopyROM(PTR_BASE wDest, BYTE wDestType, ROM BYTE* wSource,  
....................                         WORD wLength) 
....................  
....................   Summary: 
....................    Copies data to/from various memory mediums. 
....................  
....................   Description: 
....................    This function copies data between memory mediums (PIC RAM, SPI 
....................    RAM, and Ethernet buffer RAM).  This function is to be used when  
....................    copying from ROM. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    wDest      - Address to write to 
....................    wDestType   - Destination meidum (TCP_PIC_RAM, TCP_ETH_RAM, TCP_SPI_RAM) 
....................    wSource      - Address to copy from 
....................    wLength      - Number of bytes to copy 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    Copying to a destination region that overlaps with the source address  
....................    is supported only if the destination start address is at a lower memory  
....................    address (closer to 0x0000) than the source pointer. 
....................     
....................    This function is aliased to TCPRAMCopy on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... static void TCPRAMCopyROM(PTR_BASE wDest, BYTE wDestType, ROM BYTE* wSource, WORD wLength) 
.................... { 
....................    BYTE vBuffer[16]; 
....................    WORD w; 
....................     
....................    switch(wDestType) 
....................    { 
....................       case TCP_PIC_RAM: 
....................          memcpypgm2ram((void*)(BYTE*)wDest, (ROM void*)wSource, wLength); 
....................          break; 
....................     
....................       case TCP_ETH_RAM: 
....................          if(wDest!=(PTR_BASE)-1) 
....................             MACSetWritePtr(wDest); 
....................          w = sizeof(vBuffer); 
....................          while(wLength) 
....................          { 
....................             if(w > wLength) 
....................                w = wLength; 
....................              
....................             // Read and write a chunk    
....................             memcpypgm2ram(vBuffer, (ROM void*)wSource, w); 
....................             MACPutArray(vBuffer, w); 
....................             wSource += w; 
....................             wLength -= w; 
....................          } 
....................          break; 
....................     
....................       #if defined(SPIRAM_CS_TRIS) 
....................       case TCP_SPI_RAM: 
....................          w = sizeof(vBuffer); 
....................          while(wLength) 
....................          { 
....................             if(w > wLength) 
....................                w = wLength; 
....................              
....................             // Read and write a chunk    
....................             memcpypgm2ram(vBuffer, (ROM void*)wSource, w); 
....................             SPIRAMPutArray(wDest, vBuffer, w); 
....................             wDest += w; 
....................             wSource += w; 
....................             wLength -= w; 
....................          } 
....................          break; 
....................       #endif 
....................    } 
.................... } 
.................... #endif 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    SSL Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPStartSSLClient(TCP_SOCKET hTCP, BYTE* host) 
....................  
....................   Summary: 
....................    Begins an SSL client session. 
....................  
....................   Description: 
....................    This function escalates the current connection to an SSL secured  
....................    connection by initiating an SSL client handshake. 
....................  
....................   Precondition: 
....................    TCP is initialized and hTCP is already connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to secure 
....................    host      - Expected host name on certificate (currently ignored) 
....................  
....................   Return Values: 
....................    TRUE       - an SSL connection was initiated 
....................    FALSE       - Insufficient SSL resources (stubs) were available 
....................  
....................   Remarks: 
....................    The host parameter is currently ignored and is not validated. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL_CLIENT) 
.................... BOOL TCPStartSSLClient(TCP_SOCKET hTCP, BYTE* host) 
.................... { 
....................    BYTE i; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    // Make sure SSL is not established already 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       return FALSE; 
....................     
....................    // Try to start the session 
....................    MyTCBStub.sslStubID = SSLStartSession(hTCP, NULL, 0); 
....................     
....................    // Make sure a session stub was obtained 
....................    if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................       return FALSE; 
....................  
....................    // Mark connection as handshaking and return 
....................    MyTCBStub.sslReqMessage = SSL_CLIENT_HELLO; 
....................    MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................    MyTCBStub.sslTxHead = MyTCBStub.txHead; 
....................    MyTCBStub.Flags.bSSLHandshaking = 1; 
....................    for(i = 0; i < 5u; i++) 
....................    {// Skip first 5 bytes in TX for the record header 
....................       if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    return TRUE; 
.................... } 
.................... #endif // SSL Client 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPStartSSLClientEx(TCP_SOCKET hTCP, BYTE* host, BYTE * buffer, BYTE suppDataType) 
....................  
....................   Summary: 
....................    Begins an SSL client session. 
....................  
....................   Description: 
....................    This function escalates the current connection to an SSL secured  
....................    connection by initiating an SSL client handshake. 
....................  
....................   Precondition: 
....................    TCP is initialized and hTCP is already connected. 
....................  
....................   Parameters: 
....................    hTCP         - TCP connection to secure 
....................    host         - Expected host name on certificate (currently ignored) 
....................    buffer         - Buffer for supplementary data return 
....................    suppDataType    - Type of supplementary data to copy 
....................  
....................   Return Values: 
....................    TRUE       - an SSL connection was initiated 
....................    FALSE       - Insufficient SSL resources (stubs) were available 
....................  
....................   Remarks: 
....................    The host parameter is currently ignored and is not validated. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL_CLIENT) 
.................... BOOL TCPStartSSLClientEx(TCP_SOCKET hTCP, BYTE* host, void * buffer, BYTE suppDataType) 
.................... { 
....................    BYTE i; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    // Make sure SSL is not established already 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       return FALSE; 
....................     
....................    // Try to start the session 
....................    MyTCBStub.sslStubID = SSLStartSession(hTCP, buffer, suppDataType); 
....................     
....................    // Make sure a session stub was obtained 
....................    if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................       return FALSE; 
....................  
....................    // Mark connection as handshaking and return 
....................    MyTCBStub.sslReqMessage = SSL_CLIENT_HELLO; 
....................    MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................    MyTCBStub.sslTxHead = MyTCBStub.txHead; 
....................    MyTCBStub.Flags.bSSLHandshaking = 1; 
....................    for(i = 0; i < 5u; i++) 
....................    {// Skip first 5 bytes in TX for the record header 
....................       if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    return TRUE; 
.................... } 
.................... #endif // SSL Client 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPStartSSLServer(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Begins an SSL server session. 
....................  
....................   Description: 
....................    This function sets up an SSL server session when a new connection is 
....................    established on an SSL port. 
....................  
....................   Precondition: 
....................    TCP is initialized and hTCP is already connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to secure 
....................  
....................   Return Values: 
....................    TRUE      - an SSL connection was initiated 
....................    FALSE      - Insufficient SSL resources (stubs) were available 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL_SERVER) 
.................... BOOL TCPStartSSLServer(TCP_SOCKET hTCP) 
.................... { 
....................    BYTE i; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    SyncTCB(); 
....................     
....................    // Make sure SSL is not established already 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       return TRUE; 
....................     
....................    // Try to start the session 
....................    MyTCBStub.sslStubID = SSLStartSession(hTCP, NULL, 0); 
....................     
....................    // Make sure a session stub was obtained 
....................    if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................       return FALSE; 
....................  
....................    // Swap the localPort and localSSLPort 
....................    MyTCBStub.remoteHash.Val = MyTCB.localPort.Val; 
....................    MyTCB.localPort.Val = MyTCB.localSSLPort.Val; 
....................    MyTCB.localSSLPort.Val = MyTCBStub.remoteHash.Val;    
....................  
....................    // Mark connection as handshaking and return 
....................    MyTCBStub.sslReqMessage = SSL_NO_MESSAGE; 
....................    MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................    MyTCBStub.sslTxHead = MyTCBStub.txHead; 
....................    MyTCBStub.Flags.bSSLHandshaking = 1; 
....................    for(i = 0; i < 5u; i++) 
....................    {// Skip first 5 bytes in TX for the record header 
....................       if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    return TRUE; 
.................... } 
.................... #endif // SSL Client 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPAddSSLListener(TCP_SOCKET hTCP, WORD port) 
....................  
....................   Summary: 
....................    Listens for SSL connection on a specific port. 
....................  
....................   Description: 
....................    This function adds an additional listening port to a TCP connection.   
....................    Connections made on this alternate port will be secured via SSL. 
....................  
....................   Precondition: 
....................    TCP is initialized and hTCP is listening. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to secure 
....................    port      - SSL port to listen on 
....................  
....................   Return Values: 
....................    TRUE      - SSL port was added. 
....................    FALSE      - The socket was not a listening socket. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL_SERVER) 
.................... BOOL TCPAddSSLListener(TCP_SOCKET hTCP, WORD port) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    if(MyTCBStub.smState != TCP_LISTEN) 
....................       return FALSE; 
....................     
....................    SyncTCB(); 
....................     
....................    MyTCB.localSSLPort.Val = port; 
....................    MyTCBStub.sslTxHead = port; 
....................  
....................    return TRUE; 
.................... } 
.................... #endif // SSL Server 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPRequestSSLMessage(TCP_SOCKET hTCP, BYTE msg) 
....................  
....................   Summary: 
....................    Requests an SSL message to be transmitted. 
....................  
....................   Description: 
....................    This function is called to request that a specific SSL message be 
....................    transmitted.  This message should only be called by the SSL module. 
....................     
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to use 
....................    msg         - One of the SSL_MESSAGE types to transmit. 
....................  
....................   Return Values: 
....................    TRUE      - The message was requested. 
....................    FALSE      - Another message is already pending transmission. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... BOOL TCPRequestSSLMessage(TCP_SOCKET hTCP, BYTE msg) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    if(msg == SSL_NO_MESSAGE || MyTCBStub.sslReqMessage == SSL_NO_MESSAGE) 
....................    { 
....................       MyTCBStub.sslReqMessage = msg; 
....................       return TRUE; 
....................    } 
....................     
....................    return FALSE; 
.................... } 
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPSSLIsHandshaking(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines if an SSL session is still handshaking. 
....................  
....................   Description: 
....................    Call this function after calling TCPStartSSLClient until FALSE is 
....................    returned.  Then your application may continue with its normal data 
....................    transfer (which is now secured). 
....................     
....................   Precondition: 
....................    TCP is initialized and hTCP is connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to check 
....................  
....................   Return Values: 
....................    TRUE      - SSL handshake is still progressing 
....................    FALSE      - SSL handshake has completed 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... BOOL TCPSSLIsHandshaking(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    return MyTCBStub.Flags.bSSLHandshaking;    
.................... } 
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPIsSSL(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines if a TCP connection is secured with SSL. 
....................  
....................   Description: 
....................    Call this function to determine whether or not a TCP connection is  
....................    secured with SSL. 
....................     
....................   Precondition: 
....................    TCP is initialized and hTCP is connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to check 
....................  
....................   Return Values: 
....................    TRUE      - Connection is secured via SSL 
....................    FALSE      - Connection is not secured 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... BOOL TCPIsSSL(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................       return FALSE; 
....................     
....................    return TRUE; 
.................... } 
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLHandshakeComplete(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Clears the SSL handshake flag. 
....................  
....................   Description: 
....................    This function clears the flag indicating that an SSL handshake is 
....................    complete. 
....................     
....................   Precondition: 
....................    TCP is initialized and hTCP is connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to set 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLHandshakeComplete(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    MyTCBStub.Flags.bSSLHandshaking = 0; 
.................... } 
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLDecryptMAC(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, WORD len) 
....................  
....................   Summary: 
....................    Decrypts and MACs data arriving via SSL. 
....................  
....................   Description: 
....................    This function decrypts data in the TCP buffer and calculates the MAC over 
....................    the data.  All data is left in the exact same location in the TCP buffer. 
....................    It is called to help process incoming SSL records. 
....................     
....................   Precondition: 
....................    TCP is initialized, hTCP is connected, and ctx's Sbox is loaded. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to decrypt in 
....................    ctx         - ARCFOUR encryption context to use 
....................    len       - Number of bytes to crypt 
....................    inPlace      - TRUE to write back in place, FALSE to write at end of 
....................                currently visible data. 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLDecryptMAC(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, WORD len) 
.................... { 
....................    PTR_BASE wSrc, wDest, wBlockLen, wTemp; 
....................    BYTE buffer[32]; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    // Set up the pointers 
....................    SyncTCBStub(hTCP); 
....................    wSrc = MyTCBStub.rxTail; 
....................    wDest = wSrc; 
....................     
....................    // Handle 32 bytes at a time 
....................    while(len) 
....................    { 
....................       // Determine how many bytes we can read 
....................       wBlockLen = sizeof(buffer); 
....................       if(wBlockLen > len) // Don't do more than we should 
....................          wBlockLen = len; 
....................        
....................       // Read those bytes to a buffer 
....................       if(wSrc + wBlockLen > MyTCBStub.bufferEnd) 
....................       {// Two part read 
....................          wTemp = MyTCBStub.bufferEnd - wSrc + 1; 
....................          TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, wSrc, MyTCBStub.vMemoryMedium, wTemp); 
....................          TCPRAMCopy((PTR_BASE)buffer+wTemp, TCP_PIC_RAM, MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, wBlockLen - wTemp); 
....................          wSrc = MyTCBStub.bufferRxStart + wBlockLen - wTemp; 
....................       } 
....................       else 
....................       { 
....................          TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, wSrc, MyTCBStub.vMemoryMedium, wBlockLen); 
....................          wSrc += wBlockLen; 
....................       } 
....................        
....................       // Decrypt and hash 
....................       ARCFOURCrypt(ctx, buffer, wBlockLen); 
....................       SSLMACAdd(buffer, wBlockLen); 
....................        
....................       // Write decrypted bytes back 
....................       if(wDest + wBlockLen > MyTCBStub.bufferEnd) 
....................       {// Two part write 
....................          wTemp = MyTCBStub.bufferEnd - wDest + 1; 
....................          TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, wTemp); 
....................          TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer+wTemp, TCP_PIC_RAM, wBlockLen - wTemp); 
....................          wDest = MyTCBStub.bufferRxStart + wBlockLen - wTemp; 
....................       } 
....................       else 
....................       { 
....................          TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, wBlockLen); 
....................          wDest += wBlockLen; 
....................       } 
....................        
....................       // Update the length remaining 
....................       len -= wBlockLen; 
....................    } 
.................... }    
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLInPlaceMACEncrypt(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx,  
....................                            BYTE* MACSecret, WORD len) 
....................  
....................   Summary: 
....................    Encrypts and MACs data in place in the TCP TX buffer. 
....................  
....................   Description: 
....................    This function encrypts data in the TCP buffer while calcuating a MAC.   
....................    When encryption is finished, the MAC is appended to the buffer and  
....................    the record will be ready to transmit. 
....................     
....................   Precondition: 
....................    TCP is initialized, hTCP is connected, and ctx's Sbox is loaded. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to encrypt in 
....................    ctx         - ARCFOUR encryption context to use 
....................    MACSecret   - MAC encryption secret to use 
....................    len       - Number of bytes to crypt 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLInPlaceMACEncrypt(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, BYTE* MACSecret, WORD len) 
.................... { 
....................    PTR_BASE pos; 
....................    WORD blockLen; 
....................    BYTE buffer[32]; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    // Set up the pointers 
....................    SyncTCBStub(hTCP); 
....................    pos = MyTCBStub.txHead; 
....................    for(blockLen = 0; blockLen < 5u; blockLen++) 
....................    {// Skips first 5 bytes for the header 
....................       if(++pos >= MyTCBStub.bufferRxStart) 
....................          pos = MyTCBStub.bufferTxStart; 
....................    } 
....................     
....................    // Handle 32 bytes at a time 
....................    while(len) 
....................    { 
....................       // Determine how many bytes we can read 
....................       blockLen = sizeof(buffer); 
....................       if(blockLen > len) // Don't do more than we should 
....................          blockLen = len; 
....................       if(blockLen > MyTCBStub.bufferRxStart - pos) // Don't pass the end 
....................          blockLen = MyTCBStub.bufferRxStart - pos; 
....................        
....................       // Read those bytes to a buffer 
....................       TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, pos, MyTCBStub.vMemoryMedium, blockLen); 
....................        
....................       // Hash and encrypt 
....................       SSLMACAdd(buffer, blockLen); 
....................       ARCFOURCrypt(ctx, buffer, blockLen); 
....................        
....................       // Put them back 
....................       TCPRAMCopy(pos, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, blockLen); 
....................        
....................       // Update the pointers 
....................       pos += blockLen; 
....................       len -= blockLen; 
....................       if(pos >= MyTCBStub.bufferRxStart) 
....................          pos = MyTCBStub.bufferTxStart; 
....................    } 
....................     
....................    // Calculate and add the MAC 
....................    SSLMACCalc(MACSecret, buffer); 
....................    ARCFOURCrypt(ctx, buffer, 16); 
....................  
....................    // Write the MAC to the TX FIFO 
....................    // Can't use TCPPutArray here because TCPIsPutReady() saves 16 bytes for the MAC 
....................    // TCPPut* functions use this to prevent writing too much data.  Therefore, the 
....................    // functionality is duplicated here. 
....................     
....................    len = 16; 
....................    blockLen = 0; 
....................    // See if we need a two part put 
....................    if(MyTCBStub.sslTxHead + len >= MyTCBStub.bufferRxStart) 
....................    { 
....................       blockLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead; 
....................       TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, blockLen); 
....................       len -= blockLen; 
....................       MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................     
....................    TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&buffer[blockLen], TCP_PIC_RAM, len); 
....................    MyTCBStub.sslTxHead += len; 
....................  
.................... }    
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLPutRecordHeader(TCP_SOCKET hTCP, BYTE* hdr, BOOL recDone) 
....................  
....................   Summary: 
....................    Writes an SSL record header and sends an SSL record. 
....................  
....................   Description: 
....................    This function writes an SSL record header to the pending TCP SSL data,  
....................    then indicates that the data is ready to be sent by moving the txHead 
....................    pointer. 
....................     
....................    If the record is complete, set recDone to TRUE.  The sslTxHead  
....................    pointer will be moved forward 5 bytes to leave space for a future  
....................    record header.  If the record is only partially sent, use FALSE and 
....................    to leave the pointer where it is so that more data can be added 
....................    to the record.  Partial records can only be used for the  
....................    SERVER_CERTIFICATE handshake message. 
....................     
....................   Precondition: 
....................    TCP is initialized, and hTCP is connected with an active SSL session. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to write the header and transmit with 
....................    hdr         - Record header (5 bytes) to send or NULL to just  
....................               move the pointerctx 
....................    recDone      - TRUE if the record is done, FALSE otherwise 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLPutRecordHeader(TCP_SOCKET hTCP, BYTE* hdr, BOOL recDone) 
.................... { 
....................    BYTE i; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    // Set up the pointers 
....................    SyncTCBStub(hTCP); 
....................     
....................    // Write the header if needed 
....................    if(hdr) 
....................    {// This is a new record, so insert the header 
....................       for(i = 0; i < 5u; i++) 
....................       { 
....................          TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)hdr+i, TCP_PIC_RAM, sizeof(BYTE)); 
....................          if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart) 
....................             MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................       } 
....................    } 
....................     
....................    // Move the txHead pointer to indicate what data is ready 
....................    // Also, flush just the header, then all the data.  This shotguns two  
....................    // packets down the line, therefore causing immediate ACKs by the  
....................    // remote node.  Reconnect handshakes are as much as 60% faster now. 
....................    TCPFlush(hTCP); 
....................    MyTCBStub.txHead = MyTCBStub.sslTxHead; 
....................    TCPFlush(hTCP); 
....................     
....................    // If this record is done, move the sslTxHead forward 
....................    // to accomodate the next record header 
....................    if(recDone) 
....................    { 
....................       for(i = 0; i < 5u; i++) 
....................       {// Skip first 5 bytes in TX for the record header 
....................          if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................             MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................       } 
....................    } 
.................... }    
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPSSLGetPendingTxSize(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines how many bytes are pending for a future SSL record. 
....................  
....................   Description: 
....................    This function determines how many bytes are pending for a future SSL 
....................    record. 
....................     
....................   Precondition: 
....................    TCP is initialized, and hTCP is connected with an active SSL connection. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to check 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... WORD TCPSSLGetPendingTxSize(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    // Non-SSL connections have no pending SSL data 
....................    //if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................    //   return 0; 
....................           
....................    // Determine how many bytes are waiting to be written in this record 
....................    if(MyTCBStub.sslTxHead > MyTCBStub.txHead) 
....................       return MyTCBStub.sslTxHead - MyTCBStub.txHead - 5; 
....................    else 
....................       return (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.txHead - MyTCBStub.sslTxHead - 1) - 5; 
.................... } 
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLHandleIncoming(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Hands newly arrive TCP data to the SSL module for processing. 
....................  
....................   Description: 
....................    This function processes incoming TCP data as an SSL record and  
....................    performs any necessary repositioning and decrypting. 
....................     
....................   Precondition: 
....................    TCP is initialized, and hTCP is connected with an active SSL session. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to handle incoming data on 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLHandleIncoming(TCP_SOCKET hTCP) 
.................... { 
....................    PTR_BASE prevRxTail, nextRxHead, startRxTail, wSrc, wDest; 
....................    WORD wToMove, wLen, wSSLBytesThatPoofed, wDecryptedBytes; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    // Sync the stub 
....................    SyncTCBStub(hTCP); 
....................  
....................    // If new data is waiting 
....................    if(MyTCBStub.sslRxHead != MyTCBStub.rxHead) 
....................    { 
....................       // Reconfigure pointers for SSL use 
....................       prevRxTail = MyTCBStub.rxTail; 
....................       nextRxHead = MyTCBStub.rxHead; 
....................       MyTCBStub.rxTail = MyTCBStub.rxHead; 
....................       MyTCBStub.rxHead = MyTCBStub.sslRxHead; 
....................        
....................       do 
....................       { 
....................          startRxTail = MyTCBStub.rxTail; 
....................  
....................          // Handle incoming data.  This function performs deframing of the  
....................          // SSL records, decryption, and MAC verification. 
....................          wSSLBytesThatPoofed = TCPIsGetReady(hTCP); 
....................          wDecryptedBytes = SSLRxRecord(hTCP, MyTCBStub.sslStubID); 
....................          wSSLBytesThatPoofed -= TCPIsGetReady(hTCP); 
....................  
....................          // Now need to move data to fill the SSL header/MAC/padding hole,  
....................          // if there is one 
....................          if(wSSLBytesThatPoofed) 
....................          {    
....................             // Sync the TCP so we can see if there is a TCP hole 
....................             SyncTCB(); 
....................  
....................             // Calculate how big the SSL hole is 
....................             if(MyTCB.sHoleSize == -1) 
....................             {// Just need to move pending SSL data 
....................                wToMove = TCPIsGetReady(hTCP); 
....................             } 
....................             else 
....................             {// A TCP hole exists, so move all data 
....................                wToMove = TCPIsGetReady(hTCP) + MyTCB.sHoleSize + MyTCB.wFutureDataSize; 
....................             } 
....................              
....................             // Start with the destination as the startRxTail and source as current rxTail 
....................             wDest = startRxTail; 
....................             wSrc = MyTCBStub.rxTail; 
....................              
....................             // If data exists between the end of the buffer and  
....................             // the destination, then move it forward 
....................             if(wSrc > wDest) 
....................             { 
....................                wLen = MyTCBStub.bufferEnd - wSrc + 1; 
....................                if(wLen > wToMove) 
....................                   wLen = wToMove; 
....................                TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium,  
....................                         wSrc, MyTCBStub.vMemoryMedium, wLen); 
....................                wDest += wLen; 
....................                wSrc = MyTCBStub.bufferRxStart; 
....................                wToMove -= wLen; 
....................             } 
....................              
....................             // If data remains to be moved, fill in to end of buffer 
....................             if(wToMove) 
....................             { 
....................                wLen = MyTCBStub.bufferEnd - wDest + 1; 
....................                if(wLen > wToMove) 
....................                   wLen = wToMove; 
....................                TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium,  
....................                         wSrc, MyTCBStub.vMemoryMedium, wLen); 
....................                wDest = MyTCBStub.bufferRxStart; 
....................                wSrc += wLen; 
....................                wToMove -= wLen; 
....................             } 
....................              
....................             // If data still remains, copy from from front + len to front 
....................             if(wToMove) 
....................             { 
....................                TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, 
....................                         wSrc, MyTCBStub.vMemoryMedium, wToMove); 
....................             } 
....................  
....................             // Since bytes poofed, we need to move the head pointers  
....................             // backwards by an equal amount. 
....................             MyTCBStub.rxHead -= wSSLBytesThatPoofed; 
....................             if(MyTCBStub.rxHead < MyTCBStub.bufferRxStart) 
....................                MyTCBStub.rxHead += MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................             MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................          } 
....................              
....................          // Move tail pointer forward by the number of decrypted bytes ready  
....................          // for the application (but not poofed bytes) 
....................          MyTCBStub.rxTail = startRxTail + wDecryptedBytes; 
....................          if(MyTCBStub.rxTail > MyTCBStub.bufferEnd) 
....................             MyTCBStub.rxTail -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................          nextRxHead += wDecryptedBytes; 
....................           
....................          // Loop until SSLRxRecord() runs out of data and stops doing  
....................          // anything 
....................       } while(wSSLBytesThatPoofed || (startRxTail != MyTCBStub.rxTail)); 
....................  
....................       // Restore TCP buffer pointers to point to the decrypted application data  
....................       // only 
....................       if(nextRxHead > MyTCBStub.bufferEnd) 
....................          nextRxHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................       MyTCBStub.rxTail = prevRxTail; 
....................       MyTCBStub.rxHead = nextRxHead; 
....................    } 
.................... }    
.................... #endif 
....................  
....................  
.................... #endif //#if defined(STACK_USE_TCP) 
....................  
....................     
....................    void TCPTouch(TCP_SOCKET s) 
....................    { 
....................       SyncTCBStub(s); 
....................       if(MyTCBStub.smState == TCP_ESTABLISHED) 
....................       { 
....................          MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
....................          SyncTCB(); 
....................       } 
....................    } 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
....................    #include "_DNS.c" //ccs had to rename this driver to not conflict an s7600 driver in the default include path - a bug in the compiler 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS) 
....................    #include "MPFS.c" 
.................... #endif 
....................  
.................... #if (defined(STACK_USE_HTTP2) || defined(STACK_USE_HTTP2_SERVER)) && !defined(__HTTP2_C) 
....................     #include "HTTP2.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_HTTP) || defined(STACK_USE_HTTP_SERVER) 
....................     #include "HTTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP1_SERVER) 
....................    #include "ccs_HTTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    #include "ccs_HTTP2.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP) && !defined(__SMTP_C) 
....................    #include "smtp.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SMTP) 
....................    #include "ccs_SMTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
....................    #include "SNTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    #include "ccs_SNTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TWITTER) 
....................    #include "ccs_twitter.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
....................    #include "TFTPc.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_TFTP_SERVER) 
....................    #include "ccs_TFTPs.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) && !defined(__ANNOUNCE_C) 
....................    #include "Announce.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
....................    #include "MPFS2.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_GRATUITOUS_ARP) 
....................    #include "ccs_gratarp.c" 
.................... #endif 
....................  
.................... #if defined(__18CXX) 
....................    #include "p18cxxx.c" 
.................... // CCS PCH C Compiler to Microchip C18 Compiler compatability layer. 
....................  
.................... #ifndef __P18CXXXX_C__ 
.................... #define __P18CXXXX_C__ 
....................  
.................... #include "p18cxxx.h" 
.................... // CCS PCH C Compiler to Microchip C18 Compiler compatability layer. 
....................  
.................... #ifndef __P18CXXXX_H__ 
.................... #define __P18CXXXX_H__ 
....................  
.................... #ifndef __18CXX 
.................... #define __18CXX 
.................... #endif 
....................  
.................... //#zero_local_ram 
.................... #zero_ram 
....................  
....................  
.................... #device PASS_STRINGS=IN_RAM 
.................... #device CONST=READ_ONLY 
....................  
.................... #case 
.................... #type signed 
.................... #type short=16 int=16 long=32 
....................  
.................... #define _asm #asm 
.................... #define _endasm #endasm 
....................  
.................... /* usualy 
.................... #define GetSystemClock()      getenv("CLOCK") 
.................... #define GetInstructionClock()   (GetSystemClock()/4) 
.................... #define GetPeripheralClock()   (unsigned int32)GetInstructionClock() 
.................... */ 
....................  
.................... #if getenv("DEVICE") == "PIC18F97J60" 
....................  #define __18F97J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F96J65" 
....................  #define __18F96J65) 
.................... #elif getenv("DEVICE") == "PIC18F96J60" 
....................  #define __18F96J60 
.................... #elif getenv("DEVICE") == "PIC18F87J60" 
....................  #define __18F87J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J60" 
....................  #define __18F86J60 
.................... #elif getenv("DEVICE") == "PIC18F67J60" 
....................  #define __18F67J60 
....................  #include "PIC18F67J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F66J65" 
....................  #define __18F66J65 
.................... #elif getenv("DEVICE") == "PIC18F66J60" 
....................  #define __18F66J60 
.................... #elif getenv("DEVICE") == "PIC18F67K22" 
....................  #define __18F67K22 
....................  #include "PIC18F67K22_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F4620" 
....................  #define __18F4620 
....................  #include "PIC18F4620_registers.h" 
.................... #else 
....................    #error Do this for your chip 
.................... #endif 
....................  
.................... #if defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) 
....................    #reserve 0xE80:0xEFF 
....................    #reserve 0xF00:0xFFF 
.................... #endif 
....................  
.................... #if defined(TRUE) 
....................    #undef TRUE 
.................... #endif 
....................  
.................... #if defined(FALSE) 
....................    #undef FALSE 
.................... #endif 
....................  
.................... #if defined(BYTE) 
....................    #undef BYTE 
.................... #endif 
....................  
....................       #define Reset()            reset_cpu() 
....................         #define far 
....................         #define ClrWdt()         restart_wdt() 
....................       #define Nop()            delay_cycles(1)       
....................  
.................... #define __CCS__ 
....................  
.................... //signed int8 memcmppgm2ram(void * s1, rom char *s2, unsigned int8 n); 
.................... signed int8 strcmppgm2ram(char *s1, __ADDRESS__ s2); 
.................... char *strchrpgm(__ADDRESS__ s, unsigned int8 c); 
.................... char *strstrrampgm(char *s1, __ADDRESS__ s2); 
.................... unsigned int8 strlenpgm(__ADDRESS__ s); 
.................... void memcpypgm2ram(unsigned int8 *d, __ADDRESS__ s, unsigned int16 n); 
.................... //char* strupr(char *s);   now in string.h 
.................... void strcpypgm2ram(char *d, __ADDRESS__ s); 
.................... #endif 
....................  
.................... /* STRING.H already has this exact function 
.................... signed int8 memcmppgm2ram(void * s1, rom char *s2, unsigned int8 n) 
.................... { 
....................   #if 1 
....................    char *su1; 
....................    rom char *su2; 
....................     
....................    for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
....................    { 
....................       if(*su1!=*su2) 
....................          return ((*su1<*su2)?-1:+1); 
....................    } 
....................    return 0; 
....................   #else 
....................    #error///warning memcmppgm2ram disabled 
....................   #endif 
.................... }*/ 
....................  
.................... #if 0 //this is in string.h and helpers.c 
.................... char* strupr(char *s) 
.................... { 
....................    char *p; 
....................     
....................    p=s; 
....................     
....................    while(*p) 
....................    { 
....................       *p = toupper(*p++); 
....................    } 
....................    return(s); 
.................... } 
.................... #endif 
....................  
.................... void memcpypgm2ram(unsigned int8 *d, __ADDRESS__ s, unsigned int16 n) 
.................... { 
....................    //printf("ROM_0x%LX-to-0x%LX ", d, s); 
....................   #if (getenv("PROGRAM_MEMORY") > 0x10000) 
....................    #warning temporary ccs bug fix 
....................    s |= 0x10000; 
....................   #endif 
....................    read_program_memory(s, d, n); 
.................... } 
....................  
.................... void strcpypgm2ram(char *d, __ADDRESS__ s) 
.................... { 
....................    char c; 
....................    do 
....................    { 
....................       memcpypgm2ram(&c, s++, 1); 
....................       *d++ = c; 
....................    } while(c); 
.................... } 
....................  
.................... #if 0 
.................... signed int8 strcmppgm2ram(char *s1, rom char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... char *strchrpgm(rom char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
....................  
.................... char *strstrrampgm(char *s1, rom char *s2) 
.................... { 
....................    char *s; 
....................    rom char *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... unsigned int8 strlenpgm(rom char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
.................... #endif   //if 0 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... int1 DHCPBoundOrDisabled(void) 
.................... { 
....................   #if defined(STACK_USE_DHCP_CLIENT) 
....................    return(!DHCPIsEnabled(0) || DHCPIsBound(0)); 
....................   #else 
....................    return(TRUE); 
....................   #endif 
.................... } 
....................  
.................... int1 IsLinked(void) 
.................... { 
....................   #if STACK_USE_WIFI && defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    if (AppConfig.networkType == WF_ADHOC) 
....................    { 
....................       return(MACIsLinked() && g_WifiAdhocIsConn); 
....................    } 
....................   #endif 
....................     
....................    return(MACIsLinked() && DHCPBoundOrDisabled()); 
.................... } 
....................  
.................... #if defined(STACK_USE_MPFS) 
.................... MPFS _MpfsEofLoc; 
....................  
.................... unsigned int16 MPFSGetBytes(unsigned int8 *pDest, unsigned int16 n) 
.................... { 
....................    unsigned int16 ret = 0; 
....................    unsigned int16 i; 
....................    unsigned int8 *p; 
....................    int1 escaped = FALSE; 
....................     
....................    p = pDest; 
....................     
....................    debug_mpfs2(debug_putc, "\r\nMPFSGetBytes() START %LX ", _currentHandle); 
....................     
....................    while(n) 
....................    { 
....................       HTTP_INTERRUPT_TASKS(); 
....................        
....................       debug_mpfs2(debug_putc, "n=%LX ", n); 
....................        
....................       _MpfsEofLoc = _currentHandle; 
....................      #if defined(MPFS_USE_SPI_FLASH) 
....................       SPIFlashReadArray(_currentHandle, pDest, n); 
....................      #else 
....................       memcpypgm2ram(pDest, _currentHandle, n); //__ccs__ change because MPFS isn't rom pointer 
....................      #endif 
....................  
....................       _currentHandle += n; 
....................  
....................       //debug_array("START", pDest, n); 
....................  
....................       i = n; 
....................       n = 0; 
....................        
....................       while(i--) 
....................       { 
....................          _MpfsEofLoc++; 
....................          if (escaped || (*pDest == MPFS_DLE)) 
....................          { 
....................             if (!escaped) 
....................             { 
....................                n++; 
....................             } 
....................              
....................             if (escaped || i) 
....................             { 
....................                if (!escaped) 
....................                { 
....................                   debug_mpfs2(debug_putc, "! "); 
....................                   memmove(pDest, pDest+1, i); 
....................                   _MpfsEofLoc++; 
....................                   i--; 
....................                } 
....................                ret++; 
....................                escaped = FALSE; 
....................             } 
....................             else 
....................             { 
....................                escaped = TRUE; 
....................                pDest--; //counter pDest++ below, since we need to start saving new bytes here 
....................             } 
....................          } 
....................          else if(*pDest == MPFS_ETX) 
....................          { 
....................             _MpfsEofLoc--; 
....................             debug_mpfs2(debug_putc, "EOF %LX ", _MpfsEofLoc); 
....................             _currentHandle = MPFS_INVALID; 
....................             n = 0; 
....................             break; 
....................          } 
....................          else 
....................          { 
....................             ret++; 
....................          } 
....................          pDest++; 
....................       } 
....................    } 
....................    //debug_array("STOP", p, ret);    
....................  
....................    return(ret); 
.................... } 
.................... #ENDIF 
....................  
.................... #if STACK_USE_WIFI 
....................  
.................... //extern int1 g_WifiTempDisFlag; 
.................... //extern TICK g_WifiTempDisTick; 
.................... //extern int1 g_wifiConnected; 
.................... extern int1 g_WifiConnectFail; 
....................  
.................... // see StackTsk2.h for documentation 
.................... #if 0 
.................... int1 MyWFisConnected(void) 
.................... { 
....................    int1 ret = FALSE; 
....................  
....................   #if defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    if (AppConfig.networkType == WF_ADHOC) 
....................    { 
....................       if ( 
....................             g_WifiAdhocIsConn && 
....................             ((TickGet() - g_WifiAdhocTickConn) > WIFI_ADHOC_CONNECTION_TIMER) 
....................          ) 
....................       { 
....................          g_WifiAdhocIsConn = FALSE; 
....................       } 
....................       return(g_WifiAdhocIsConn); 
....................    } 
....................   #endif 
....................  
....................    if (g_wifiConnected) 
....................    { 
....................       ret = TRUE; 
....................    } 
....................    else if (!g_WifiConnectFail) 
....................    { 
....................       if (g_WifiTempDisFlag) 
....................       { 
....................          if ((TickGet() - g_WifiTempDisTick) < ((TICK)5*TICKS_PER_SECOND)) 
....................          { 
....................             ret = TRUE; 
....................          } 
....................          else 
....................          { 
....................             g_WifiTempDisFlag = FALSE; 
....................          } 
....................       } 
....................    } 
....................  
....................    return(ret); 
.................... } 
.................... #endif 
....................  
.................... unsigned int8 g_connectionProfileID = 0xFF;  //used to communicate with the connection profile on the WiFi module 
....................  
.................... unsigned int8 WIFI_channelList[16]; 
.................... unsigned int8 WIFI_numChannelsInList; 
.................... unsigned int8 WIFI_region; 
....................  
.................... // this option will force the connection profile to be closed and reopened 
.................... // if we do not get a connection within this time.  might fix an errata that 
.................... // says WPA/WPA2 will lockup instead of sending an event. 
.................... #define WIFI_FORCE_RECONNECT_TICK   (TICK)(TICKS_PER_SECOND * 120)  //might be too short for WPA/WPA2 phrase 
....................  
.................... #ifndef wifi_debug 
.................... #define wifi_debug(a,b,c,d,e,f,g,h,i) 
.................... #endif 
....................  
.................... // this was based off of WF_Connect() in Microchip's demo application. 
.................... void WIFIConnectTask(void) 
.................... { 
....................    #if !defined(APP_GENERIC_SCRATCH) 
....................       char WIFIConnectTask_Scratch[6]; 
....................    #else 
....................       #define WIFIConnectTask_Scratch  APP_GENERIC_SCRATCH 
....................    #endif 
....................     
....................   #if defined(WIFI_FORCE_RECONNECT_TICK) 
....................    static TICK fTick; 
....................   #endif 
....................  
....................   #if defined(LED_CONNECTION_ON) || defined(LED_ACTIVITY_ON) 
....................    static TICK l; 
....................    // if you have both LED_CONNECTION_ON and LED_ACTIVITY_ON (2 WIFI LEDs),  
....................    //    then one LED is used for flickering on traffic and another is used to  
....................    //    show connection state. 
....................    // if you only have LED_CONNECTION_ON (only 1 WIFI LED), then WIFI  
....................    //    connection status and wifi traffic flickering is shared on the same 
....................    //    LED. 
....................    // this routine below handles the traffic led flickering.  the LED was 
....................    //    turned off in the TCP/IP stack, this routine turns it back on every 
....................    //    200ms. 
....................    if ((TickGet() - l) >= TICKS_PER_SECOND/5) 
....................    { 
....................       l = TickGet(); 
....................        
....................      #if defined(LED_ACTIVITY_ON) 
....................       LED_ACTIVITY_OFF(); 
....................      #else 
....................       if (IsLinked()) 
....................       { 
....................          LED_CONNECTION_ON(); 
....................       } 
....................       else 
....................       { 
....................          LED_CONNECTION_OFF(); 
....................       } 
....................      #endif 
....................    } 
....................   #endif 
....................  
....................   #if defined(LED_CONNECTION_ON) && defined(LED_ACTIVITY_ON) 
....................    // handle the connection status LED if you have 2 WIFI LEDs. 
....................    if (IsLinked()) 
....................    { 
....................       LED_CONNECTION_ON(); 
....................    } 
....................    else 
....................    { 
....................       LED_CONNECTION_OFF(); 
....................    } 
....................   #endif 
....................  
....................   #if STACK_USE_WIFI && defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    if (AppConfig.networkType == WF_ADHOC) 
....................    { 
....................       if ( 
....................             g_WifiAdhocIsConn && 
....................             ((TickGet() - g_WifiAdhocTickConn) > WIFI_ADHOC_CONNECTION_TIMER) 
....................          ) 
....................       { 
....................          g_WifiAdhocIsConn = FALSE; 
....................       } 
....................    } 
....................   #endif 
....................  
....................   #if defined(WIFI_FORCE_RECONNECT_TICK) 
....................    if ( 
....................          (AppConfig.networkType != WF_ADHOC) && 
....................          (g_connectionProfileID != 0xFF) 
....................       ) 
....................    { 
....................       if (IsLinked()) 
....................       { 
....................          fTick = TickGet(); 
....................       } 
....................       else if ((TickGet() - fTick) > WIFI_FORCE_RECONNECT_TICK) 
....................       { 
....................         #if defined(STACK_IS_CCS_EXAMPLE) 
....................          fprintf(STREAM_UI, "\r\nLong WIFI connection timeout, reseting module"); 
....................         #endif 
....................          delay_ms(200); 
....................          MACInit(); 
....................          delay_ms(200); 
....................          g_connectionProfileID = 0xFF; 
....................         #if defined(WIFI_EXTRA_LINK_STATUS) 
....................          g_LastWifiEvent = 20; 
....................         #endif 
....................       } 
....................    } 
....................   #endif 
....................  
....................    if (g_connectionProfileID == 0xFF) 
....................    { 
....................       g_WifiConnectFail = FALSE; 
....................        
....................       WF_CPCreate(&g_connectionProfileID); 
....................        
....................       if (g_connectionProfileID != 0xFF) 
....................       { 
....................         #if defined(WIFI_GET_VERSION_INFO) 
....................          WF_GetDeviceInfo(&WIFI_GET_VERSION_INFO); 
....................         #endif 
....................  
....................          g_WifiConnectFail = TRUE; 
....................  
....................          WF_CPSetSsid(g_connectionProfileID,  
....................                     AppConfig.MySSID,  
....................                     AppConfig.SsidLength); 
....................           
....................          memset(WIFIConnectTask_Scratch, 0xFF, 6); 
....................          WF_CPSetBssid(g_connectionProfileID, WIFIConnectTask_Scratch); 
....................  
....................          WF_CPSetNetworkType(g_connectionProfileID, AppConfig.networkType); 
....................           
....................          if(AppConfig.networkType == WF_ADHOC) 
....................          { 
....................             WF_CPSetAdHocBehavior(g_connectionProfileID, AppConfig.adhocBehavior); 
....................          } 
....................  
....................          WF_CASetScanType(MY_DEFAULT_SCAN_TYPE);   // was WF_ACTIVE_SCAN 
....................  
....................          WF_CASetChannelList(WIFI_channelList, WIFI_numChannelsInList); //was AppConfig.channelList, AppConfig.numChannelsInList 
....................  
....................          WF_SetRegionalDomain(WIFI_region);  //was AppConfig.region 
....................           
....................          WF_CASetListRetryCount(MY_DEFAULT_LIST_RETRY_COUNT);  // was WF_RETRY_FOREVER 
....................           
....................          WF_CASetEventNotificationAction(MY_DEFAULT_EVENT_NOTIFICATION_LIST); // was WF_NOTIFY_ALL_EVENTS 
....................           
....................          WF_CASetBeaconTimeout(MY_DEFAULT_BEACON_TIMEOUT); 
....................  
....................          WF_CASetBeaconTimeoutAction(WF_ATTEMPT_TO_RECONNECT); 
....................           
....................          WF_CASetDeauthAction(WF_ATTEMPT_TO_RECONNECT); 
....................  
....................        #if defined(DERIVE_KEY_FROM_PASSPHRASE_IN_HOST) 
....................            if (AppConfig.SecurityMode == WF_SECURITY_WPA_WITH_PASS_PHRASE 
....................                || AppConfig.SecurityMode == WF_SECURITY_WPA2_WITH_PASS_PHRASE 
....................                || AppConfig.SecurityMode == WF_SECURITY_WPA_AUTO_WITH_PASS_PHRASE) { 
....................                WF_ConvPassphrase2Key(AppConfig.SecurityKeyLength, AppConfig.SecurityKey, 
....................                    AppConfig.SsidLength, AppConfig.MySSID); 
....................                AppConfig.SecurityMode--; 
....................                AppConfig.SecurityKeyLength = 32; 
....................            } 
....................        #if defined (MRF24WG) 
....................            else if (AppConfig.SecurityMode == WF_SECURITY_WPS_PUSH_BUTTON 
....................                        || AppConfig.SecurityMode == WF_SECURITY_WPS_PIN) { 
....................                WF_YieldPassphrase2Host();     
....................            } 
....................        #endif    /* defined (MRF24WG) */ 
....................        #endif    /* defined(DERIVE_KEY_FROM_PASSPHRASE_IN_HOST) */ 
....................  
....................          WF_CPSetSecurity(g_connectionProfileID, 
....................                         AppConfig.SecurityMode, 
....................                         0, //AppConfig.WepKeyIndex, //AppConfig.WepKeyIndex,   /* only used if WEP enabled */ 
....................                         AppConfig.SecurityKey, 
....................                         AppConfig.SecurityKeyLength);       
....................   
....................       #if (MY_DEFAULT_WIFI_SECURITY_WEP_KEYTYPE!=WF_SECURITY_WEP_SHAREDKEY) 
....................         #if !defined(MRF24WG) 
....................          if (gRFModuleVer1209orLater) 
....................         #endif 
....................          { 
....................             // If WEP security is used, set WEP Key Type.  The default WEP Key Type is Shared Key. 
....................             if ((AppConfig.SecurityMode == WF_SECURITY_WEP_40) || (AppConfig.SecurityMode == WF_SECURITY_WEP_104)) 
....................             { 
....................                 WF_CPSetWepKeyType(g_connectionProfileID, MY_DEFAULT_WIFI_SECURITY_WEP_KEYTYPE); 
....................             } 
....................          } 
....................         #endif 
....................  
....................        #ifndef WF_FORCE_NO_PS_POLL 
....................        #if MY_DEFAULT_PS_POLL == WF_ENABLED 
....................            WF_PsPollEnable(TRUE); 
....................        #if !defined(MRF24WG)  
....................            if (gRFModuleVer1209orLater) 
....................                WFEnableDeferredPowerSave(); 
....................        #endif    // !defined(MRF24WG) 
....................        #else     // MY_DEFAULT_PS_POLL != WF_ENABLED 
....................            WF_PsPollDisable(); 
....................        #endif    // MY_DEFAULT_PS_POLL == WF_ENABLED 
....................     
....................        #ifdef WF_AGGRESSIVE_PS 
....................        #if !defined(MRF24WG) 
....................            if (gRFModuleVer1209orLater) 
....................                WFEnableAggressivePowerSave(); 
....................        #endif 
....................        #endif 
....................        #endif 
....................       } 
....................    } 
....................  
....................    if(g_WifiConnectFail) 
....................    { 
....................       wifi_debug(debug_putc, "Start WiFi Connect PROF=%u\r\n", g_connectionProfileID); 
....................       
....................      #if defined(STACK_IS_CCS_EXAMPLE) 
....................       fprintf(STREAM_UI, "\r\nStart WiFi Connect"); 
....................      #endif 
....................       
....................      #if defined(WIFI_FORCE_RECONNECT_TICK) 
....................       fTick = TickGet(); 
....................      #endif 
....................  
....................      #if defined(WF_FORCE_NO_PS_POLL) 
....................       WF_CCS_PsPollDisable(); 
....................      #endif 
....................     
....................       WF_CMConnect(g_connectionProfileID); 
....................    } 
....................     
....................    g_WifiConnectFail = 0; 
.................... } 
....................  
.................... void LinkTraffic(int1 isTx) 
.................... { 
....................   #if defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    if (!isTx && (AppConfig.networkType == WF_ADHOC)) 
....................    { 
....................       g_WifiAdhocIsConn = TRUE; 
....................       g_WifiAdhocTickConn = TickGet(); 
....................    } 
....................   #endif 
....................  
....................    // these LEDs are desribed in WIFIConnectTask() 
....................   #if defined(LED_ACTIVITY_ON) 
....................    LED_ACTIVITY_ON(); 
....................   #elif defined(LED_CONNECTION_ON) 
....................    LED_CONNECTION_OFF(); 
....................   #endif 
.................... } 
....................  
....................  
.................... #if defined(WF_FORCE_NO_PS_POLL) 
.................... #if defined(WF_USE_POWER_SAVE_FUNCTIONS) 
....................    #error dont use both at the same time 
.................... #endif 
.................... typedef struct pwrModeRequestStruct 
.................... { 
....................     UINT8 mode; 
....................     UINT8 wake; 
....................     UINT8 rcvDtims; 
....................     UINT8 reserved;            /* pad byte */ 
.................... } tWFPwrModeReq; 
....................  
.................... static void SendPowerModeMsg(tWFPwrModeReq *p_powerMode) 
.................... { 
....................     UINT8 hdr[2]; 
....................      
....................     hdr[0] = WF_MGMT_REQUEST_TYPE; 
....................     hdr[1] = WF_SET_POWER_MODE_SUBTYPE; 
....................  
....................     SendMgmtMsg(hdr, 
....................                 sizeof(hdr), 
....................                (UINT8 *)p_powerMode, 
....................                sizeof(tWFPwrModeReq)); 
....................  
....................     /* wait for mgmt response, free buffer after it comes in (no data to read) */ 
....................    WaitForMgmtResponse(WF_SET_POWER_MODE_SUBTYPE, FREE_MGMT_BUFFER); 
....................      
.................... }  
....................  
.................... void WF_CCS_PsPollDisable(void) 
.................... { 
....................    tWFPwrModeReq   pwrModeReq; 
....................      
....................     pwrModeReq.mode     = 1;  //PS_POLL_DISABLED; 
....................     pwrModeReq.wake     = 1; 
....................     pwrModeReq.rcvDtims = 1; 
....................     SendPowerModeMsg(&pwrModeReq); 
....................  
....................     //SetPowerSaveState(WF_PS_OFF); //not really needed, sets a global for their statemachine 
....................  
....................     WFConfigureLowPowerMode(WF_LOW_POWER_MODE_OFF);  
.................... } 
.................... #endif   //WF_FORCE_NO_PS_POLL 
....................  
.................... #endif //STACK_USE_WIFI 
....................  
.................... #if defined(__DO_DEBUG_MPFS2) 
.................... void debug_array(char *str, char *p, unsigned int16 n) 
.................... { 
....................    char c; 
....................    debug_mpfs2(debug_putc, "\r\n%s %LX ", str, n); 
....................    while(n--) 
....................    { 
....................       c = *p++; 
....................       if ((c >= ' ') && (c <= '}')) 
....................       { 
....................          debug_mpfs2(debug_putc, "%c", c); 
....................       } 
....................       else 
....................       { 
....................          debug_mpfs2(debug_putc, "+%X", c); 
....................       } 
....................    } 
....................    debug_mpfs2(debug_putc, " "); 
.................... } 
.................... #else 
.................... #define debug_array(str, p, n) 
.................... #endif 
....................  
.................... // if you call TickGet() from an ISR, this may be a lock-up condition. 
.................... // this is a morph of GetTickCopy() and TickUpdate() that works from an ISR. 
.................... // only works on PIC18. 
.................... #if defined(__PCH__) 
.................... TICK TickGetSafe(void) 
.................... { 
....................    BYTE myTickReading[6]; 
....................    do 
....................    { 
....................       if(INTCONbits.TMR0IF) 
....................       { 
....................          dwInternalTicks++; 
....................          INTCONbits.TMR0IF = 0; 
....................       } 
....................       myTickReading[0] = TMR0L; 
....................       myTickReading[1] = TMR0H; 
....................       *((DWORD*)&myTickReading[2]) = dwInternalTicks; 
....................    } while(INTCONbits.TMR0IF); 
....................     
....................    return *((DWORD*)&myTickReading[0]); 
.................... } 
.................... #endif 
....................  
.................... // this used to be called GenerateRandomBYTE() in an older CCS port of Helpers.c 
.................... BYTE GenerateRandomByteFromTimers(void) 
.................... { 
....................    BYTE rand; 
....................     
....................   #if getenv("TIMER0") && !defined(__PCD__) 
....................    rand+=get_timer0(); 
....................   #endif 
....................    
....................   #if getenv("TIMER1") 
....................    rand+=get_timer1(); 
....................   #endif 
....................    
....................   #if getenv("TIMER2") 
....................    rand+=get_timer2(); 
....................   #endif 
....................    
....................   #if getenv("TIMER3") 
....................    rand+=get_timer3(); 
....................   #endif 
....................    
....................   #if getenv("TIMER4") 
....................    rand+=get_timer4(); 
....................   #endif 
....................    
....................   #if getenv("TIMER5") 
....................    rand+=get_timer5(); 
....................   #endif 
....................    
....................    return(rand); 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................    Assigns the MAC address of the unit. 
....................    This is removed when using WIFI, so it will use the MAC address of the 
....................    WIFI module.  You can still override the MAC address of the WIFI module 
....................    if you remove the conditional compilation option. 
.................... */ 
.................... void MACAddrInit(void) 
.................... { 
....................   #if !STACK_USE_WIFI 
....................    MY_MAC_BYTE1=0; 
*
002F4:  CLRF   56
....................    MY_MAC_BYTE2=2; 
002F6:  MOVLW  02
002F8:  MOVWF  57
....................    MY_MAC_BYTE3=3; 
002FA:  MOVLW  03
002FC:  MOVWF  58
....................    MY_MAC_BYTE4=4; 
002FE:  MOVLW  04
00300:  MOVWF  59
....................    MY_MAC_BYTE5=5; 
00302:  MOVLW  05
00304:  MOVWF  5A
....................    MY_MAC_BYTE6=7; 
00306:  MOVLW  07
00308:  MOVWF  5B
....................   #endif 
0030A:  GOTO   0350 (RETURN)
.................... } 
....................  
.................... void IPAddrInit(void)  
.................... { 
....................    //IP address of this unit 
....................    MY_IP_BYTE1=192; 
0030E:  MOVLW  C0
00310:  MOVWF  29
....................    MY_IP_BYTE2=168; 
00312:  MOVLW  A8
00314:  MOVWF  2A
....................    MY_IP_BYTE3=100; 
00316:  MOVLW  64
00318:  MOVWF  2B
....................    MY_IP_BYTE4=7; 
0031A:  MOVLW  07
0031C:  MOVWF  2C
....................  
....................    //network gateway 
....................    MY_GATE_BYTE1=192; 
0031E:  MOVLW  C0
00320:  MOVWF  31
....................    MY_GATE_BYTE2=168; 
00322:  MOVLW  A8
00324:  MOVWF  32
....................    MY_GATE_BYTE3=100; 
00326:  MOVLW  64
00328:  MOVWF  33
....................    MY_GATE_BYTE4=1; 
0032A:  MOVLW  01
0032C:  MOVWF  34
....................  
....................    //subnet mask 
....................    MY_MASK_BYTE1=255; 
0032E:  SETF   2D
....................    MY_MASK_BYTE2=255; 
00330:  SETF   2E
....................    MY_MASK_BYTE3=255; 
00332:  SETF   2F
....................    MY_MASK_BYTE4=0; 
00334:  CLRF   30
....................    
....................   #if defined(STACK_USE_DNS) 
00336:  GOTO   0352 (RETURN)
....................    AppConfig.PrimaryDNSServer.v[0] = 192; 
....................    AppConfig.PrimaryDNSServer.v[1] = 168; 
....................    AppConfig.PrimaryDNSServer.v[2] = 100; 
....................    AppConfig.PrimaryDNSServer.v[3] = 1; 
....................   #endif 
.................... } 
....................  
.................... char ExampleIPDatagram[] = { 
....................    0x45, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
....................    0x64, 0x11, 0x2A, 0x9D, 0x0A, 0x0B, 0x0C, 0x0D, 
....................    0x0A, 0x0B, 0x0C, 0x0E 
.................... }; 
....................  
.................... char ExampleUDPPacket[] = { 
....................    0x04, 0x00, 0x04, 0x01, 0x00, 0x0C, 0x00, 0x00, 
....................    0x01, 0x02, 0x03, 0x04 
.................... }; 
....................  
.................... void MACToString(char *str, MAC_ADDR *mac) 
.................... { 
....................    sprintf(str, "%X:%X:%X:%X:%X:%X", mac->v[0], mac->v[1], mac->v[2], mac->v[3], mac->v[4], mac->v[5]); 
.................... } 
....................  
.................... void IPToString(char *str, IP_ADDR *ip) 
.................... { 
....................    sprintf(str, "%u.%u.%u.%u", ip->v[0], ip->v[1], ip->v[2], ip->v[3]); 
.................... } 
....................  
.................... /****************************************************************************** 
....................  * If using the newest stack, options for WiFi should be set in WF_Config.h 
....................  *****************************************************************************/ 
.................... #if STACK_USE_WIFI 
....................  
.................... #include "tcpip/StackTsk2.c" 
....................  
.................... #if !STACK_USE_CCS_INI 
.................... // initialize WIFI settings using harcoded values 
.................... void WIFI_Init(void) 
.................... { 
....................    unsigned int8 chans[] = MY_DEFAULT_CHANNEL_LIST; 
....................     
....................    g_connectionProfileID = 0xFF; 
....................     
....................    WIFI_numChannelsInList = sizeof(chans); 
....................    memcpy(WIFI_channelList, chans, WIFI_numChannelsInList); 
....................    WIFI_region = MY_DEFAULT_REGION; 
....................  
....................    // If MAC address is all zero's, then set it to the default MAC address. 
....................    // If the MAC address is the default MAC address, the stack will then use 
....................    // MAC internal to the WIFI module. 
....................    MAC_ADDR blankMac; 
....................    memset(&blankMac, 0x00, sizeof(MAC_ADDR)); 
....................    if (memcmp(&AppConfig.MyMACAddr, &blankMac, sizeof(MAC_ADDR)) == 0) 
....................    { 
....................       memcpy(&AppConfig.MyMACAddr, &MchpDefaultMacAddress, sizeof(MAC_ADDR)); 
....................    } 
....................     
....................    // Load the default SSID Name 
....................    strcpy(AppConfig.MySSID, MY_DEFAULT_SSID_NAME); 
....................    AppConfig.SsidLength = strlen(AppConfig.MySSID); 
....................  
....................    AppConfig.SecurityMode = MY_DEFAULT_WIFI_SECURITY_MODE; 
....................    AppConfig.WepKeyIndex  = MY_DEFAULT_WEP_KEY_INDEX; 
....................    
....................   #if (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_OPEN) 
....................       memset(AppConfig.SecurityKey, 0x00, sizeof(AppConfig.SecurityKey)); 
....................  
....................   #elif MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WEP_40 
....................       strcpy(AppConfig.SecurityKey, MY_DEFAULT_WEP_KEYS_40); 
....................  
....................   #elif MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WEP_104 
....................     strcpy(AppConfig.SecurityKey, MY_DEFAULT_WEP_KEYS_104); 
....................      
....................   #elif (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA_WITH_KEY)       || \ 
....................         (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA2_WITH_KEY)      || \ 
....................         (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA_AUTO_WITH_KEY) 
....................     strcpy(AppConfig.SecurityKey, MY_DEFAULT_PSK); 
....................  
....................   #elif (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA_WITH_PASS_PHRASE)     || \ 
....................         (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA2_WITH_PASS_PHRASE)    || \ 
....................         (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA_AUTO_WITH_PASS_PHRASE) 
....................       strcpy(AppConfig.SecurityKey, MY_DEFAULT_PSK_PHRASE); 
....................  
....................   #else  
....................       #error No security defined 
....................   #endif 
....................      
....................     AppConfig.networkType = MY_DEFAULT_NETWORK_TYPE; 
....................     AppConfig.adhocBehavior = MY_DEFAULT_ADHOC_BEHAVIOR; 
....................      
....................     AppConfig.SecurityKeyLength = strlen(AppConfig.SecurityKey); 
.................... } 
.................... #else  
.................... #define WIFI_Init()  g_connectionProfileID = 0xFF  //taken care of by CCS_INI 
.................... #endif   //!STACK_USE_CCS_INI 
.................... #endif   //!WIFI 
....................  
.................... void Init(void) 
.................... { 
....................    init_user_io(); 
*
0034C:  BRA    02A6
....................   
....................    MACAddrInit(); //used by CCS TCP/IP examples 
0034E:  BRA    02F4
....................     
....................    IPAddrInit();  //used by CCS TCP/IP examples 
00350:  BRA    030E
....................     
....................    TickInit(); 
00352:  BRA    033A
....................     
....................     
....................   #if STACK_USE_WIFI 
....................    delay_ms(50); //let the tick get a value for seeding rand 
....................    srand(TickGet() * get_timer0()); //seed random value for channel 
....................    WIFI_Init(); 
....................   #endif 
....................     
....................   #if defined(__PCH__) 
....................    enable_interrupts(GLOBAL); //used by TICK and WIFI 
00354:  MOVLW  C0
00356:  IORWF  FF2,F
....................   #else 
....................    enable_interrupts(INTR_GLOBAL); 
....................   #endif 
....................  
....................   #if STACK_USE_CCS_INI 
00358:  GOTO   662E (RETURN)
....................    EEInit(); 
....................  
....................    //printf("\r\n\nMAGIC RD = %X\r\n\n", EERead8(EE_MAGIC)); 
....................  
....................    if (EERead8(EE_MAGIC) != DEF_MAGIC) 
....................    { 
....................       printf(UserPutc, "\r\n\nResetting EEPROM...\r\n\n"); 
....................       EEPROMToDefaults(); 
....................    } 
....................  
....................    EELoadSettings();    
....................    
....................    UIInit(); 
....................   #endif 
.................... } 
....................  
.................... #if STACK_USE_CCS_INI 
....................    #include "ee.c" 
....................    #include "ccsui.c" 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... #int_addrerr FAST 
.................... void IsrAdrerr(void) 
.................... { 
....................    int16 w[16]; 
....................    int16 h,l; 
....................    int32 val; 
....................   #asm 
....................    POP.S 
....................    POP h; 
....................    POP l; 
....................   #endasm 
....................     
....................    w[0] = WREG0; 
....................    w[1] = WREG1; 
....................    w[2] = WREG2; 
....................    w[3] = WREG3; 
....................    w[4] = WREG4; 
....................    w[5] = WREG5; 
....................    w[6] = WREG6; 
....................    w[7] = WREG7; 
....................    w[8] = WREG8; 
....................    w[9] = WREG9; 
....................    w[10] = WREG10; 
....................    w[11] = WREG11; 
....................    w[12] = WREG12; 
....................    w[13] = WREG13; 
....................    w[14] = WREG14; 
....................    w[15] = WREG15; 
....................     
....................     
....................    h &= 0x00FF; 
....................     
....................    val = make32(h, l); 
....................    val -= 2; 
....................     
....................    // this address might be off by 2 bytes 
....................     
....................    printf("\r\n\nADDRESS FAULT 0x%LX ", val); 
....................    for (l=0;l<16;l++) 
....................    { 
....................       printf("W%U:%LX ", l, w[l]); 
....................    } 
....................    printf("\r\n"); 
....................  
....................    while(TRUE); 
.................... } 
.................... #int_stackerr 
.................... void IsrStackerr(void) 
.................... { 
....................    printf("\r\n\n*** STACKERR ***\r\n\n"); 
....................    for(;;) {} 
.................... } 
.................... #endif 
....................  
....................  
.................... // one general purpose TCP socket 
.................... TCPSocketInitializer_t TCPSocketInitializer[TCP_CONFIGURATION] = 
.................... { 
....................     {TCP_PURPOSE_DEFAULT, TCP_ETH_RAM, 500, 500} 
.................... }; 
....................  
.................... #define MY_HTTP_SOCKET  80 
....................  
.................... unsigned int8 HTTPSocket=INVALID_SOCKET; 
....................  
.................... void LCDTask(void)  
.................... { 
....................    static enum {LCD_INIT=0, LCD_NO_MAC, LCD_NO_DHCP, LCD_NO_WEB_INIT, LCD_NO_WEB, LCD_IDLE} state=0; 
....................  
....................    switch(state)  
*
0186A:  MOVLB  1
0186C:  MOVF   x64,W
0186E:  ADDLW  FA
01870:  BTFSC  FD8.0
01872:  BRA    19E6
01874:  ADDLW  06
01876:  MOVLB  0
01878:  GOTO   19EC
....................    { 
....................       case LCD_INIT: 
....................          printf(lcd_putc, "\fWebserver\n\rNo MAC Link"); 
0187C:  MOVLW  B6
0187E:  MOVWF  FF6
01880:  MOVLW  00
01882:  MOVWF  FF7
01884:  CALL   0678
....................          state = LCD_NO_MAC; 
01888:  MOVLW  01
0188A:  MOVLB  1
0188C:  MOVWF  x64
....................          LED_OFF(USER_LED1); 
0188E:  BCF    F92.5
01890:  BSF    F89.5
....................          break; 
01892:  BRA    19E6
....................           
....................       case LCD_NO_MAC: 
....................          if (MACIsLinked()) 
01894:  RCALL  1748
01896:  MOVF   01,F
01898:  BZ    18A2
....................          { 
....................            #if defined(STACK_USE_DHCP) 
....................             if (!DHCPIsEnabled(0)) 
....................            #else 
....................             if (1) 
....................            #endif 
....................             { 
....................                state = LCD_NO_WEB_INIT; 
0189A:  MOVLW  03
0189C:  MOVLB  1
0189E:  MOVWF  x64
018A0:  MOVLB  0
....................             } 
....................             else 
....................             { 
....................                printf(lcd_putc, "\fWebserver\n\rDHCP Not Bound"); 
....................                state = LCD_NO_DHCP; 
....................             } 
....................          } 
....................          break; 
018A2:  MOVLB  1
018A4:  BRA    19E6
....................  
....................    #if defined(STACK_USE_DHCP) 
....................      case LCD_NO_DHCP: 
....................          if (!MACIsLinked()) 
....................          { 
....................             state = LCD_INIT; 
....................             break; 
....................          } 
....................          if (DHCPIsBound(0)) 
....................          { 
....................             state = LCD_NO_WEB_INIT; 
....................             LED_ON(USER_LED1); 
....................          } 
....................          break; 
....................    #endif 
....................     
....................       case LCD_NO_WEB_INIT: 
....................             printf(lcd_putc, "\fWebserver Idle\n\r%u.%u.%u.%u", MY_IP_BYTE1, MY_IP_BYTE2, 
....................                MY_IP_BYTE3, MY_IP_BYTE4); 
018A6:  MOVLW  EA
018A8:  MOVWF  FF6
018AA:  MOVLW  00
018AC:  MOVWF  FF7
018AE:  MOVLW  11
018B0:  MOVLB  1
018B2:  MOVWF  x6C
018B4:  MOVLB  0
018B6:  RCALL  1764
018B8:  MOVFF  29,16C
018BC:  MOVLW  1B
018BE:  MOVLB  1
018C0:  MOVWF  x6D
018C2:  MOVLB  0
018C4:  RCALL  17BA
018C6:  MOVLW  2E
018C8:  MOVLB  1
018CA:  MOVWF  x6F
018CC:  MOVLB  0
018CE:  CALL   05C8
018D2:  MOVFF  2A,16C
018D6:  MOVLW  1B
018D8:  MOVLB  1
018DA:  MOVWF  x6D
018DC:  MOVLB  0
018DE:  RCALL  17BA
018E0:  MOVLW  2E
018E2:  MOVLB  1
018E4:  MOVWF  x6F
018E6:  MOVLB  0
018E8:  CALL   05C8
018EC:  MOVFF  2B,16C
018F0:  MOVLW  1B
018F2:  MOVLB  1
018F4:  MOVWF  x6D
018F6:  MOVLB  0
018F8:  RCALL  17BA
018FA:  MOVLW  2E
018FC:  MOVLB  1
018FE:  MOVWF  x6F
01900:  MOVLB  0
01902:  CALL   05C8
01906:  MOVFF  2C,16C
0190A:  MOVLW  1B
0190C:  MOVLB  1
0190E:  MOVWF  x6D
01910:  MOVLB  0
01912:  RCALL  17BA
....................             state = LCD_NO_WEB; 
01914:  MOVLW  04
01916:  MOVLB  1
01918:  MOVWF  x64
....................             break; 
0191A:  BRA    19E6
....................              
....................       case LCD_NO_WEB: 
....................          if ( 
....................                !MACIsLinked()  
....................               #if defined(STACK_USE_DHCP) 
0191C:  RCALL  1748
0191E:  MOVF   01,F
01920:  BNZ   1928
....................                || (DHCPIsEnabled(0) && !DHCPIsBound(0)) 
....................               #endif 
....................             ) 
....................          { 
....................             state = LCD_INIT; 
01922:  MOVLB  1
01924:  CLRF   x64
01926:  MOVLB  0
....................          } 
....................          if ((HTTPSocket!=INVALID_SOCKET) && TCPIsConnected(HTTPSocket)) 
01928:  MOVLB  1
0192A:  MOVF   x63,W
0192C:  SUBLW  FE
0192E:  BZ    19C0
01930:  MOVFF  163,268
01934:  MOVLB  0
01936:  RCALL  183C
01938:  MOVF   01,F
0193A:  BTFSS  FD8.2
0193C:  BRA    1942
0193E:  MOVLB  1
01940:  BRA    19C0
....................          { 
....................             SyncTCBStub(HTTPSocket); 
01942:  MOVFF  163,273
01946:  CALL   0D1A
....................             SyncTCB(); 
0194A:  RCALL  130A
....................              
....................             printf(lcd_putc,"\fConnected to\n\r%u.%u.%u.%u", MyTCB.remote.niRemoteMACIP.IPAddr.v[0], 
....................                      MyTCB.remote.niRemoteMACIP.IPAddr.v[1], 
....................                      MyTCB.remote.niRemoteMACIP.IPAddr.v[2], 
....................                      MyTCB.remote.niRemoteMACIP.IPAddr.v[3] 
....................                    ); 
0194C:  MOVLW  08
0194E:  MOVWF  FF6
01950:  MOVLW  01
01952:  MOVWF  FF7
01954:  MOVLW  0F
01956:  MOVLB  1
01958:  MOVWF  x6C
0195A:  MOVLB  0
0195C:  RCALL  1764
0195E:  MOVFF  CA,16C
01962:  MOVLW  1B
01964:  MOVLB  1
01966:  MOVWF  x6D
01968:  MOVLB  0
0196A:  RCALL  17BA
0196C:  MOVLW  2E
0196E:  MOVLB  1
01970:  MOVWF  x6F
01972:  MOVLB  0
01974:  CALL   05C8
01978:  MOVFF  CB,16C
0197C:  MOVLW  1B
0197E:  MOVLB  1
01980:  MOVWF  x6D
01982:  MOVLB  0
01984:  RCALL  17BA
01986:  MOVLW  2E
01988:  MOVLB  1
0198A:  MOVWF  x6F
0198C:  MOVLB  0
0198E:  CALL   05C8
01992:  MOVFF  CC,16C
01996:  MOVLW  1B
01998:  MOVLB  1
0199A:  MOVWF  x6D
0199C:  MOVLB  0
0199E:  RCALL  17BA
019A0:  MOVLW  2E
019A2:  MOVLB  1
019A4:  MOVWF  x6F
019A6:  MOVLB  0
019A8:  CALL   05C8
019AC:  MOVFF  CD,16C
019B0:  MOVLW  1B
019B2:  MOVLB  1
019B4:  MOVWF  x6D
019B6:  MOVLB  0
019B8:  RCALL  17BA
....................             state = LCD_IDLE; 
019BA:  MOVLW  05
019BC:  MOVLB  1
019BE:  MOVWF  x64
....................          } 
....................          break; 
019C0:  BRA    19E6
....................  
....................       case LCD_IDLE: 
....................          if ( 
....................                !MACIsLinked() 
....................               #if defined(STACK_USE_DHCP) 
019C2:  RCALL  1748
019C4:  MOVF   01,F
019C6:  BNZ   19CE
....................                || (DHCPIsEnabled(0) && !DHCPIsBound(0)) 
....................               #endif 
....................             ) 
....................          { 
....................             state = LCD_INIT; 
019C8:  MOVLB  1
019CA:  CLRF   x64
019CC:  MOVLB  0
....................          } 
....................          if (!TCPIsConnected(HTTPSocket)) 
019CE:  MOVFF  163,268
019D2:  RCALL  183C
019D4:  MOVF   01,F
019D6:  BNZ   19E0
....................          { 
....................             state = LCD_NO_WEB_INIT; 
019D8:  MOVLW  03
019DA:  MOVLB  1
019DC:  MOVWF  x64
019DE:  MOVLB  0
....................          } 
....................          break; 
019E0:  MOVLB  1
019E2:  BRA    19E6
019E4:  MOVLB  1
....................    } 
019E6:  MOVLB  0
019E8:  GOTO   6654 (RETURN)
.................... } 
....................  
.................... void HTTPPut(char c) { 
....................    TCPPut(HTTPSocket, c); 
*
0610C:  MOVFF  163,26D
06110:  MOVFF  26C,26E
06114:  BRA    5FEC
06116:  RETURN 0
.................... } 
....................  
.................... void HTTPTask(void) { 
....................    static enum {HTTP_ST_CONNECT=0, HTTP_ST_WAIT_CONNECT=1, HTTP_ST_GET=2, 
....................       HTTP_ST_PUT=3, HTTP_ST_DISCONNECT=4} state=0; 
....................    static TICK timeout_counter; 
....................    static char lc, lc2; 
....................    char c; 
....................    char content[250]; 
....................    unsigned int8 a0; 
....................   #if defined(SECONDARY_ADC_CHANNEL) 
....................    unsigned int8 a1; 
....................   #endif 
....................  
....................    if (HTTPSocket==INVALID_SOCKET) 
*
0620A:  MOVLB  1
0620C:  MOVF   x63,W
0620E:  SUBLW  FE
06210:  BNZ   6216
....................       state=HTTP_ST_CONNECT; 
06212:  CLRF   x65
06214:  BRA    6284
....................    else if (!TCPIsConnected(HTTPSocket)) 
06216:  MOVFF  163,268
0621A:  MOVLB  0
0621C:  CALL   183C
06220:  MOVF   01,F
06222:  BNZ   622E
....................       state=HTTP_ST_WAIT_CONNECT; 
06224:  MOVLW  01
06226:  MOVLB  1
06228:  MOVWF  x65
0622A:  BRA    6284
0622C:  MOVLB  0
....................    else if (TickGetDiff(TickGet(), timeout_counter) > TICKS_PER_SECOND*60) 
0622E:  CALL   1AC2
06232:  MOVFF  03,26B
06236:  MOVFF  02,26A
0623A:  MOVFF  01,269
0623E:  MOVFF  00,268
06242:  MOVLB  1
06244:  MOVF   x66,W
06246:  MOVLB  2
06248:  SUBWF  x68,F
0624A:  MOVLB  1
0624C:  MOVF   x67,W
0624E:  MOVLB  2
06250:  SUBWFB x69,F
06252:  MOVLB  1
06254:  MOVF   x68,W
06256:  MOVLB  2
06258:  SUBWFB x6A,F
0625A:  MOVLB  1
0625C:  MOVF   x69,W
0625E:  MOVLB  2
06260:  SUBWFB x6B,F
06262:  BNZ   627E
06264:  MOVF   x6A,W
06266:  SUBLW  22
06268:  BC    6286
0626A:  XORLW  FF
0626C:  BNZ   627E
0626E:  MOVF   x69,W
06270:  SUBLW  C2
06272:  BC    6286
06274:  XORLW  FF
06276:  BNZ   627E
06278:  MOVF   x68,W
0627A:  SUBLW  64
0627C:  BC    6286
....................       state=HTTP_ST_DISCONNECT; 
0627E:  MOVLW  04
06280:  MOVLB  1
06282:  MOVWF  x65
06284:  MOVLB  2
....................  
....................    switch(state) { 
06286:  MOVLB  1
06288:  MOVF   x65,W
0628A:  ADDLW  FB
0628C:  BTFSC  FD8.0
0628E:  BRA    6514
06290:  ADDLW  05
06292:  MOVLB  0
06294:  GOTO   651A
....................       case HTTP_ST_CONNECT: 
....................          HTTPSocket=TCPListen(MY_HTTP_SOCKET); 
06298:  MOVLB  2
0629A:  CLRF   x6B
0629C:  CLRF   x6A
0629E:  CLRF   x69
062A0:  CLRF   x68
062A2:  CLRF   x6C
062A4:  CLRF   x6E
062A6:  MOVLW  50
062A8:  MOVWF  x6D
062AA:  MOVLW  09
062AC:  MOVWF  x6F
062AE:  MOVLB  0
062B0:  BRA    5B04
062B2:  MOVFF  01,163
....................          if (HTTPSocket!=INVALID_SOCKET) { 
062B6:  MOVLB  1
062B8:  MOVF   x63,W
062BA:  SUBLW  FE
062BC:  BZ    62EA
....................             printf("\r\nHTTP: Listening"); 
062BE:  MOVLW  24
062C0:  MOVWF  FF6
062C2:  MOVLW  01
062C4:  MOVWF  FF7
062C6:  MOVLB  0
062C8:  CALL   035C
....................             state=HTTP_ST_WAIT_CONNECT; 
062CC:  MOVLW  01
062CE:  MOVLB  1
062D0:  MOVWF  x65
....................             timeout_counter=TickGet(); 
062D2:  MOVLB  0
062D4:  CALL   1AC2
062D8:  MOVFF  03,169
062DC:  MOVFF  02,168
062E0:  MOVFF  01,167
062E4:  MOVFF  00,166
062E8:  MOVLB  1
....................          } 
....................          break; 
062EA:  BRA    6514
....................  
....................       case HTTP_ST_WAIT_CONNECT: 
....................          timeout_counter=TickGet(); 
062EC:  CALL   1AC2
062F0:  MOVFF  03,169
062F4:  MOVFF  02,168
062F8:  MOVFF  01,167
062FC:  MOVFF  00,166
....................          if (TCPIsConnected(HTTPSocket)) { 
06300:  MOVFF  163,268
06304:  CALL   183C
06308:  MOVF   01,F
0630A:  BZ    6320
....................             state=HTTP_ST_GET; 
0630C:  MOVLW  02
0630E:  MOVLB  1
06310:  MOVWF  x65
....................             printf("\r\nHTTP: Connected"); 
06312:  MOVLW  36
06314:  MOVWF  FF6
06316:  MOVLW  01
06318:  MOVWF  FF7
0631A:  MOVLB  0
0631C:  CALL   035C
....................          } 
....................          break; 
06320:  MOVLB  1
06322:  BRA    6514
....................  
....................       case HTTP_ST_GET: 
....................          if (TCPIsGetReady(HTTPSocket)) { 
06324:  MOVFF  163,26D
06328:  RCALL  5CE0
0632A:  MOVF   01,W
0632C:  IORWF  02,W
0632E:  BZ    6374
....................             while (TCPGet(HTTPSocket, &c)) { 
06330:  MOVFF  163,268
06334:  MOVLW  01
06336:  MOVLB  2
06338:  MOVWF  x6A
0633A:  MOVLW  6C
0633C:  MOVWF  x69
0633E:  MOVLB  0
06340:  BRA    5D60
06342:  MOVF   01,F
06344:  BZ    6374
....................                if ( (c=='\n') && (lc2=='\n') ) { 
06346:  MOVLB  1
06348:  MOVF   x6C,W
0634A:  SUBLW  0A
0634C:  BNZ   6368
0634E:  MOVF   x6B,W
06350:  SUBLW  0A
06352:  BNZ   6368
....................                   state=HTTP_ST_PUT; 
06354:  MOVLW  03
06356:  MOVWF  x65
....................                   printf("\r\nHTTP: Got Page Request"); 
06358:  MOVLW  48
0635A:  MOVWF  FF6
0635C:  MOVLW  01
0635E:  MOVWF  FF7
06360:  MOVLB  0
06362:  CALL   035C
06366:  MOVLB  1
....................                } 
....................                lc2=lc; 
06368:  MOVFF  16A,16B
....................                lc=c; 
0636C:  MOVFF  16C,16A
06370:  MOVLB  0
06372:  BRA    6330
....................             } 
....................          } 
....................          break; 
06374:  MOVLB  1
06376:  BRA    6514
....................  
....................       case HTTP_ST_PUT: 
....................          if (TCPIsPutReady(HTTPSocket)) { 
06378:  MOVFF  163,271
0637C:  RCALL  5E10
0637E:  MOVF   01,W
06380:  IORWF  02,W
06382:  BTFSC  FD8.2
06384:  BRA    64E2
....................             printf("\r\nHTTP: Putting Page Response"); 
06386:  MOVLW  62
06388:  MOVWF  FF6
0638A:  MOVLW  01
0638C:  MOVWF  FF7
0638E:  CALL   035C
....................             a0=read_adc(); 
06392:  BSF    FC2.1
06394:  BTFSC  FC2.1
06396:  BRA    6394
06398:  MOVFF  FC4,267
....................            #if defined(SECONDARY_ADC_CHANNEL) 
....................             set_adc_channel(SECONDARY_ADC_CHANNEL); 
....................             delay_us(20); 
....................             a1=read_adc(); 
....................             set_adc_channel(STANDARD_ADC_CHANNEL); 
....................            #endif 
....................             sprintf(content, "<HTML><HEAD><TITLE>PICNET</TITLE></HEAD><BODY><H1>HELLO</H1>"); 
0639C:  MOVLW  01
0639E:  MOVLB  1
063A0:  MOVWF  x62
063A2:  MOVLW  6D
063A4:  MOVWF  x61
063A6:  MOVLW  80
063A8:  MOVWF  FF6
063AA:  MOVLW  01
063AC:  MOVWF  FF7
063AE:  MOVLB  0
063B0:  RCALL  5EE0
....................             sprintf(&content[0]+strlen(content),"<P>%s = 0x%X", STANDARD_ADC_STRING, a0); 
063B2:  MOVLW  01
063B4:  MOVLB  2
063B6:  MOVWF  x69
063B8:  MOVLW  6D
063BA:  MOVWF  x68
063BC:  MOVLB  0
063BE:  RCALL  5F00
063C0:  MOVLW  6D
063C2:  ADDWF  01,W
063C4:  MOVLB  2
063C6:  MOVWF  x68
063C8:  MOVLW  01
063CA:  MOVWF  x69
063CC:  BTFSC  FD8.0
063CE:  INCF   x69,F
063D0:  MOVFF  269,162
063D4:  MOVFF  268,161
063D8:  MOVLW  BE
063DA:  MOVWF  FF6
063DC:  MOVLW  01
063DE:  MOVWF  FF7
063E0:  MOVLW  03
063E2:  MOVWF  x6A
063E4:  MOVLB  0
063E6:  RCALL  5F3A
063E8:  MOVLW  CC
063EA:  MOVWF  FF6
063EC:  MOVLW  01
063EE:  MOVWF  FF7
063F0:  RCALL  5EE0
063F2:  MOVLW  C3
063F4:  MOVWF  FF6
063F6:  MOVLW  01
063F8:  MOVWF  FF7
063FA:  MOVLW  05
063FC:  MOVLB  2
063FE:  MOVWF  x6A
06400:  MOVLB  0
06402:  RCALL  5F3A
06404:  MOVFF  267,26A
06408:  MOVLW  37
0640A:  MOVLB  2
0640C:  MOVWF  x6B
0640E:  MOVLB  0
06410:  BRA    5F62
....................            #if defined(SECONDARY_ADC_CHANNEL) 
....................             sprintf(&content[0]+strlen(content),"<BR>%s = 0x%X", SECONDARY_ADC_STRING, a1); 
....................            #endif 
....................             sprintf(&content[0]+strlen(content),"</BODY></HTML>"); 
06412:  MOVLW  01
06414:  MOVLB  2
06416:  MOVWF  x69
06418:  MOVLW  6D
0641A:  MOVWF  x68
0641C:  MOVLB  0
0641E:  RCALL  5F00
06420:  MOVLW  6D
06422:  ADDWF  01,W
06424:  MOVLB  2
06426:  MOVWF  x68
06428:  MOVLW  01
0642A:  MOVWF  x69
0642C:  BTFSC  FD8.0
0642E:  INCF   x69,F
06430:  MOVFF  269,162
06434:  MOVFF  268,161
06438:  MOVLW  D0
0643A:  MOVWF  FF6
0643C:  MOVLW  01
0643E:  MOVWF  FF7
06440:  MOVLB  0
06442:  RCALL  5EE0
....................             printf(HTTPPut, "HTTP/1.1 200 OK\r\n"); 
06444:  MOVLW  E0
06446:  MOVWF  FF6
06448:  MOVLW  01
0644A:  MOVWF  FF7
0644C:  RCALL  6118
....................             printf(HTTPPut, "Content-Type: text/html\r\n"); 
0644E:  MOVLW  F2
06450:  MOVWF  FF6
06452:  MOVLW  01
06454:  MOVWF  FF7
06456:  RCALL  6118
....................             printf(HTTPPut, "Content-Length: %u\r\n",strlen(content)); 
06458:  MOVLW  01
0645A:  MOVLB  2
0645C:  MOVWF  x69
0645E:  MOVLW  6D
06460:  MOVWF  x68
06462:  MOVLB  0
06464:  RCALL  5F00
06466:  MOVFF  01,268
0646A:  MOVLW  0C
0646C:  MOVWF  FF6
0646E:  MOVLW  02
06470:  MOVWF  FF7
06472:  MOVLW  10
06474:  MOVLB  2
06476:  MOVWF  x69
06478:  MOVLB  0
0647A:  BRA    6138
0647C:  MOVFF  268,269
06480:  MOVLW  1B
06482:  MOVLB  2
06484:  MOVWF  x6A
06486:  MOVLB  0
06488:  BRA    6162
0648A:  MOVLW  0D
0648C:  MOVLB  2
0648E:  MOVWF  x6C
06490:  MOVLB  0
06492:  RCALL  610C
06494:  MOVLW  0A
06496:  MOVLB  2
06498:  MOVWF  x6C
0649A:  MOVLB  0
0649C:  RCALL  610C
....................             printf(HTTPPut, "\r\n"); 
0649E:  MOVLW  0D
064A0:  MOVLB  2
064A2:  MOVWF  x6C
064A4:  MOVLB  0
064A6:  RCALL  610C
064A8:  MOVLW  0A
064AA:  MOVLB  2
064AC:  MOVWF  x6C
064AE:  MOVLB  0
064B0:  RCALL  610C
....................             printf(HTTPPut, "%s", content); 
064B2:  MOVLW  01
064B4:  MOVWF  FEA
064B6:  MOVLW  6D
064B8:  MOVWF  FE9
064BA:  BRA    61E4
....................             printf("\r\nHTTP: Flushing..."); 
064BC:  MOVLW  22
064BE:  MOVWF  FF6
064C0:  MOVLW  02
064C2:  MOVWF  FF7
064C4:  CALL   035C
....................             TCPFlush(HTTPSocket); 
064C8:  MOVFF  163,271
064CC:  RCALL  5FAA
....................             printf("\r\nHTTP: Flushed!"); 
064CE:  MOVLW  36
064D0:  MOVWF  FF6
064D2:  MOVLW  02
064D4:  MOVWF  FF7
064D6:  CALL   035C
....................             state=HTTP_ST_GET; 
064DA:  MOVLW  02
064DC:  MOVLB  1
064DE:  MOVWF  x65
064E0:  MOVLB  0
....................          } 
....................          break; 
064E2:  MOVLB  1
064E4:  BRA    6514
....................  
....................       case HTTP_ST_DISCONNECT: 
....................          if (TCPIsPutReady(HTTPSocket)) { 
064E6:  MOVFF  163,271
064EA:  RCALL  5E10
064EC:  MOVF   01,W
064EE:  IORWF  02,W
064F0:  BZ    650E
....................             printf("\r\nHTTP: Force Disconnect"); 
064F2:  MOVLW  48
064F4:  MOVWF  FF6
064F6:  MOVLW  02
064F8:  MOVWF  FF7
064FA:  CALL   035C
....................             TCPDisconnect(HTTPSocket); 
064FE:  MOVFF  163,268
06502:  CALL   2CFE
....................             state=HTTP_ST_WAIT_CONNECT; 
06506:  MOVLW  01
06508:  MOVLB  1
0650A:  MOVWF  x65
0650C:  MOVLB  0
....................          } 
....................          break; 
0650E:  MOVLB  1
06510:  BRA    6514
06512:  MOVLB  1
....................    } 
06514:  MOVLB  0
06516:  GOTO   665A (RETURN)
.................... } 
....................  
.................... void main(void)  
*
06548:  CLRF   FF8
0654A:  BCF    FD0.7
0654C:  BSF    07.7
0654E:  MOVLW  7E
06550:  MOVWF  00
06552:  MOVLW  10
06554:  MOVWF  01
06556:  MOVLW  02
06558:  MOVWF  FE9
0655A:  MOVLW  00
0655C:  MOVWF  FEA
0655E:  CLRF   FEE
06560:  DECFSZ 00,F
06562:  BRA    655E
06564:  DECFSZ 01,F
06566:  BRA    655E
06568:  CLRF   16
0656A:  BSF    FB8.3
0656C:  MOVLW  11
0656E:  MOVWF  FAF
06570:  MOVLW  04
06572:  MOVWF  FB0
06574:  MOVLW  A6
06576:  MOVWF  FAC
06578:  MOVLW  90
0657A:  MOVWF  FAB
0657C:  BCF    67.0
0657E:  MOVLW  41
06580:  MOVWF  6B
06582:  MOVLW  FE
06584:  MOVWF  6A
06586:  MOVLW  9F
06588:  MOVWF  69
0658A:  MOVLW  9E
0658C:  MOVWF  68
0658E:  CLRF   73
06590:  CLRF   72
06592:  CLRF   71
06594:  CLRF   70
06596:  CLRF   x80
06598:  CLRF   7F
0659A:  BCF    67.2
0659C:  MOVLW  FE
0659E:  MOVWF  xDB
065A0:  MOVLB  1
065A2:  MOVWF  x34
065A4:  CLRF   x62
065A6:  CLRF   x61
065A8:  MOVWF  x63
065AA:  CLRF   x64
065AC:  CLRF   x65
065AE:  MOVF   FC1,W
065B0:  ANDLW  C0
065B2:  IORLW  0F
065B4:  MOVWF  FC1
065B6:  MOVLW  07
065B8:  MOVWF  FB4
065BA:  BRA    65EA
065BC:  DATA 04,01
065BE:  DATA 41,45
065C0:  DATA 00,00
065C2:  DATA 20,04
065C4:  DATA C0,00
065C6:  DATA 18,80
065C8:  DATA 64,11
065CA:  DATA 2A,9D
065CC:  DATA 0A,0B
065CE:  DATA 0C,0D
065D0:  DATA 0A,0B
065D2:  DATA 0C,0E
065D4:  DATA 04,00
065D6:  DATA 04,01
065D8:  DATA 00,0C
065DA:  DATA 00,00
065DC:  DATA 01,02
065DE:  DATA 03,04
065E0:  DATA 06,00
065E2:  DATA 23,09
065E4:  DATA 00,F4
065E6:  DATA 01,F4
065E8:  DATA 01,00
065EA:  MOVLW  00
065EC:  MOVWF  FF8
065EE:  MOVLW  65
065F0:  MOVWF  FF7
065F2:  MOVLW  BC
065F4:  MOVWF  FF6
065F6:  TBLRD*+
065F8:  MOVF   FF5,W
065FA:  MOVWF  00
065FC:  XORLW  00
065FE:  BZ    6626
06600:  TBLRD*+
06602:  MOVF   FF5,W
06604:  MOVWF  01
06606:  BTFSC  FE8.7
06608:  BRA    6614
0660A:  ANDLW  0F
0660C:  MOVWF  FEA
0660E:  TBLRD*+
06610:  MOVFF  FF5,FE9
06614:  BTFSC  01.6
06616:  TBLRD*+
06618:  BTFSS  01.6
0661A:  TBLRD*+
0661C:  MOVFF  FF5,FEE
06620:  DCFSNZ 00,F
06622:  BRA    65F6
06624:  BRA    6618
06626:  CLRF   FF8
.................... { 
....................    Init(); 
06628:  MOVLB  0
0662A:  GOTO   034C
....................     
....................    printf("\r\n\nCCS TCP/IP TUTORIAL, EXAMPLE 14 (HTTP SERVER)\r\n"); 
0662E:  MOVLW  62
06630:  MOVWF  FF6
06632:  MOVLW  02
06634:  MOVWF  FF7
06636:  CALL   035C
....................  
....................    lcd_init(); 
0663A:  GOTO   04F2
....................  
....................    printf(lcd_putc, "\fInit Stack..."); 
0663E:  MOVLW  96
06640:  MOVWF  FF6
06642:  MOVLW  02
06644:  MOVWF  FF7
06646:  CALL   0678
....................  
....................    StackInit(); 
0664A:  GOTO   164E
....................     
....................   #if STACK_USE_WIFI 
....................    WIFIConnectTask(); 
....................   #endif 
....................  
....................    while(TRUE)  
....................    { 
....................       restart_wdt(); 
0664E:  CLRWDT
....................  
....................       LCDTask(); 
06650:  GOTO   186A
....................  
....................       StackTask(); 
06654:  GOTO   59CA
....................  
....................      #if STACK_USE_WIFI 
....................       WIFIConnectTask();   //uses hardcoded ap/router info 
....................  
....................       //don't attempt anything else TCP/IP related if not connected. 
....................       if (!MyWFisConnected()) 
....................          continue; 
....................      #endif 
....................        
....................       HTTPTask(); 
06658:  BRA    620A
0665A:  BRA    664E
....................    } 
.................... } 
0665C:  SLEEP 

Configuration Fuses:
   Word  1: C600   H4 FCMEN IESO
   Word  2: 1E1E   PUT BROWNOUT BORV21 NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
